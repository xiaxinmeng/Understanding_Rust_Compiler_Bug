{"sha": "a831e7ce13aa19acf0f65e508097351f8dabca84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MzFlN2NlMTNhYTE5YWNmMGY2NWU1MDgwOTczNTFmOGRhYmNhODQ=", "commit": {"author": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2012-01-28T16:50:48Z"}, "committer": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2012-01-28T16:50:48Z"}, "message": "Merge remote-tracking branch 'mozilla/master'", "tree": {"sha": "e8b14ee2373337d3867ee573d61227387191c962", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8b14ee2373337d3867ee573d61227387191c962"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a831e7ce13aa19acf0f65e508097351f8dabca84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a831e7ce13aa19acf0f65e508097351f8dabca84", "html_url": "https://github.com/rust-lang/rust/commit/a831e7ce13aa19acf0f65e508097351f8dabca84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a831e7ce13aa19acf0f65e508097351f8dabca84/comments", "author": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcb381410d59b89336a528103582a956334c9777", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcb381410d59b89336a528103582a956334c9777", "html_url": "https://github.com/rust-lang/rust/commit/fcb381410d59b89336a528103582a956334c9777"}, {"sha": "0794195fbdb6efa34388dfdf3dfc968bbbf06215", "url": "https://api.github.com/repos/rust-lang/rust/commits/0794195fbdb6efa34388dfdf3dfc968bbbf06215", "html_url": "https://github.com/rust-lang/rust/commit/0794195fbdb6efa34388dfdf3dfc968bbbf06215"}], "stats": {"total": 354, "additions": 254, "deletions": 100}, "files": [{"sha": "3fd634894d5985bcfd07231392bb5a844b5720d7", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -5,6 +5,7 @@ Graydon Hoare <graydon@mozilla.com>\n Other authors:\n \n Adam Bozanich <adam.boz@gmail.com>\n+Aleksander Balicki <balicki.aleksander@gmail.com>\n Andreas Gal <gal@mozilla.com>\n Austin Seipp <mad.one@gmail.com>\n Ben Striegel <ben.striegel@gmail.com>"}, {"sha": "9a5ad5a6c9fbbf7186f4045df6f02a00b76ae16d", "filename": "mk/install.mk", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -5,12 +5,12 @@\n # Installation macro. Call with source directory as arg 1,\n # destination directory as arg 2, and filename/libname-glob as arg 3\n ifdef VERBOSE\n- INSTALL = cp $(1)/$(3) $(2)/$(3)\n- INSTALL_LIB = cp `ls -rt1 $(1)/$(3) | tail -1` $(2)/\n+ INSTALL = install -m755 -T $(1)/$(3) $(2)/$(3)\n+ INSTALL_LIB = install -m644 `ls -rt1 $(1)/$(3) | tail -1` $(2)/\n else\n- INSTALL = $(Q)$(call E, install: $(2)/$(3)) && cp $(1)/$(3) $(2)/$(3)\n+ INSTALL = $(Q)$(call E, install: $(2)/$(3)) && install -m755 -T $(1)/$(3) $(2)/$(3)\n  INSTALL_LIB = $(Q)$(call E, install_lib: $(2)/$(3)) &&                    \\\n-\t       cp `ls -rt1 $(1)/$(3) | tail -1` $(2)/\n+\t       install -m644 `ls -rt1 $(1)/$(3) | tail -1` $(2)/\n endif\n \n # The stage we install from"}, {"sha": "426263d654a7adf31cf28f3e1b49f54805106acd", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -83,7 +83,7 @@ fn item_family(item: ebml::doc) -> u8 {\n \n fn item_symbol(item: ebml::doc) -> str {\n     let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n-    ret str::unsafe_from_bytes(ebml::doc_data(sym));\n+    ret str::from_bytes(ebml::doc_data(sym));\n }\n \n fn variant_enum_id(d: ebml::doc) -> ast::def_id {\n@@ -162,7 +162,7 @@ fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> [ast::def_id] {\n // definition the path refers to.\n fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n     fn eq_item(data: [u8], s: str) -> bool {\n-        ret str::eq(str::unsafe_from_bytes(data), s);\n+        ret str::eq(str::from_bytes(data), s);\n     }\n     let s = str::connect(path, \"::\");\n     let md = ebml::new_doc(data);\n@@ -178,7 +178,7 @@ fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n \n fn item_name(item: ebml::doc) -> ast::ident {\n     let name = ebml::get_doc(item, tag_paths_data_name);\n-    str::unsafe_from_bytes(ebml::doc_data(name))\n+    str::from_bytes(ebml::doc_data(name))\n }\n \n fn lookup_item_name(data: @[u8], id: ast::node_id) -> ast::ident {\n@@ -325,7 +325,7 @@ fn read_path(d: ebml::doc) -> {path: str, pos: uint} {\n     let desc = ebml::doc_data(d);\n     let pos = ebml::be_uint_from_bytes(@desc, 0u, 4u);\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n-    let path = str::unsafe_from_bytes(pathbytes);\n+    let path = str::from_bytes(pathbytes);\n     ret {path: path, pos: pos};\n }\n \n@@ -358,21 +358,21 @@ fn get_meta_items(md: ebml::doc) -> [@ast::meta_item] {\n     let items: [@ast::meta_item] = [];\n     ebml::tagged_docs(md, tag_meta_item_word) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+        let n = str::from_bytes(ebml::doc_data(nd));\n         items += [attr::mk_word_item(n)];\n     };\n     ebml::tagged_docs(md, tag_meta_item_name_value) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n-        let v = str::unsafe_from_bytes(ebml::doc_data(vd));\n+        let n = str::from_bytes(ebml::doc_data(nd));\n+        let v = str::from_bytes(ebml::doc_data(vd));\n         // FIXME (#611): Should be able to decode meta_name_value variants,\n         // but currently they can't be encoded\n         items += [attr::mk_name_value_item_str(n, v)];\n     };\n     ebml::tagged_docs(md, tag_meta_item_list) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+        let n = str::from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n         items += [attr::mk_list_item(n, subitems)];\n     };\n@@ -427,7 +427,7 @@ fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n     let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n     let crate_num = 1;\n     ebml::tagged_docs(depsdoc, tag_crate_dep) {|depdoc|\n-        let depname = str::unsafe_from_bytes(ebml::doc_data(depdoc));\n+        let depname = str::from_bytes(ebml::doc_data(depdoc));\n         deps += [{cnum: crate_num, ident: depname}];\n         crate_num += 1;\n     };\n@@ -447,7 +447,7 @@ fn list_crate_deps(data: @[u8], out: io::writer) {\n fn get_crate_hash(data: @[u8]) -> str {\n     let cratedoc = ebml::new_doc(data);\n     let hashdoc = ebml::get_doc(cratedoc, tag_crate_hash);\n-    ret str::unsafe_from_bytes(ebml::doc_data(hashdoc));\n+    ret str::from_bytes(ebml::doc_data(hashdoc));\n }\n \n fn list_crate_items(bytes: @[u8], md: ebml::doc, out: io::writer) {"}, {"sha": "e74a2d62ced46c2500aed3175e6413d350c0cbed", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -661,7 +661,7 @@ fn encode_hash(ebml_w: ebml::writer, hash: str) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> str {\n+fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> [u8] {\n \n     let abbrevs = ty::new_ty_hash();\n     let ecx = @{ccx: cx, type_abbrevs: abbrevs};\n@@ -694,7 +694,7 @@ fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> str {\n     // Pad this, since something (LLVM, presumably) is cutting off the\n     // remaining % 4 bytes.\n     buf_w.write([0u8, 0u8, 0u8, 0u8]);\n-    io::mem_buffer_str(buf)\n+    io::mem_buffer_buf(buf)\n }\n \n // Get the encoded string for a type"}, {"sha": "b7adcfadf12d54a1e37647fd78ff56e1d60dccc9", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -39,7 +39,7 @@ fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n    ast::ident {\n     let rslt = \"\";\n     while !is_last(peek(st) as char) {\n-        rslt += str::unsafe_from_byte(next(st));\n+        rslt += str::from_byte(next(st));\n     }\n     ret rslt;\n }\n@@ -226,7 +226,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         while peek(st) as char != ']' {\n             let name = \"\";\n             while peek(st) as char != '=' {\n-                name += str::unsafe_from_byte(next(st));\n+                name += str::from_byte(next(st));\n             }\n             st.pos = st.pos + 1u;\n             fields += [{ident: name, mt: parse_mt(st, conv)}];"}, {"sha": "7ecdd8be8f1adf9c9464bd29c6c9a00118bba5b5", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -5,7 +5,7 @@ import syntax::visit;\n import syntax::ast_util;\n import driver::session::session;\n \n-enum deref_t { unbox, field, index, }\n+enum deref_t { unbox(bool), field, index, }\n \n type deref = @{mut: bool, kind: deref_t, outer_t: ty::t};\n \n@@ -20,15 +20,15 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n         while true {\n             alt ty::struct(tcx, t) {\n               ty::ty_box(mt) {\n-                ds += [@{mut: mt.mut == mut, kind: unbox, outer_t: t}];\n+                ds += [@{mut: mt.mut == mut, kind: unbox(false), outer_t: t}];\n                 t = mt.ty;\n               }\n               ty::ty_uniq(mt) {\n-                ds += [@{mut: mt.mut == mut, kind: unbox, outer_t: t}];\n+                ds += [@{mut: mt.mut == mut, kind: unbox(false), outer_t: t}];\n                 t = mt.ty;\n               }\n               ty::ty_res(_, inner, tps) {\n-                ds += [@{mut: false, kind: unbox, outer_t: t}];\n+                ds += [@{mut: false, kind: unbox(false), outer_t: t}];\n                 t = ty::substitute_type_params(tcx, tps, inner);\n               }\n               ty::ty_enum(did, tps) {\n@@ -37,7 +37,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n                        vec::len(variants[0].args) != 1u {\n                     break;\n                 }\n-                ds += [@{mut: false, kind: unbox, outer_t: t}];\n+                ds += [@{mut: false, kind: unbox(false), outer_t: t}];\n                 t = ty::substitute_type_params(tcx, tps, variants[0].args[0]);\n               }\n               _ { break; }\n@@ -85,15 +85,16 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n           expr_unary(op, base) {\n             if op == deref {\n                 let base_t = ty::expr_ty(tcx, base);\n-                let is_mut = false;\n+                let is_mut = false, ptr = false;\n                 alt ty::struct(tcx, base_t) {\n                   ty::ty_box(mt) { is_mut = mt.mut == mut; }\n                   ty::ty_uniq(mt) { is_mut = mt.mut == mut; }\n                   ty::ty_res(_, _, _) { }\n                   ty::ty_enum(_, _) { }\n-                  ty::ty_ptr(mt) { is_mut = mt.mut == mut; }\n+                  ty::ty_ptr(mt) { is_mut = mt.mut == mut; ptr = true; }\n                 }\n-                ds += [@{mut: is_mut, kind: unbox, outer_t: base_t}];\n+                ds += [@{mut: is_mut, kind: unbox(ptr && is_mut),\n+                         outer_t: base_t}];\n                 ex = base;\n             } else { break; }\n           }\n@@ -187,7 +188,7 @@ fn check_lval(cx: @ctx, dest: @expr, msg: msg) {\n         } else if !root.ds[0].mut {\n             let name =\n                 alt root.ds[0].kind {\n-                  mut::unbox { \"immutable box\" }\n+                  mut::unbox(_) { \"immutable box\" }\n                   mut::field { \"immutable field\" }\n                   mut::index { \"immutable vec content\" }\n                 };\n@@ -212,7 +213,8 @@ fn check_move_rhs(cx: @ctx, src: @expr) {\n         let root = expr_root(cx.tcx, src, false);\n \n         // Not a path and no-derefs means this is a temporary.\n-        if vec::len(*root.ds) != 0u {\n+        if vec::len(*root.ds) != 0u &&\n+           root.ds[vec::len(*root.ds) - 1u].kind != unbox(true) {\n             cx.tcx.sess.span_err(src.span, \"moving out of a data structure\");\n         }\n       }"}, {"sha": "9b423be389e435e49da32d2ebfe1b546f7a132a1", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -268,7 +268,7 @@ fn sanitize(s: str) -> str {\n                            c != ' ' as u8 && c != '\\t' as u8 && c != ';' as u8\n                        {\n                         let v = [c];\n-                        result += str::unsafe_from_bytes(v);\n+                        result += str::from_bytes(v);\n                     }\n                 }\n             }\n@@ -5412,7 +5412,7 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n \n fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n     if !cx.sess.building_library { ret; }\n-    let llmeta = C_postr(metadata::encoder::encode_metadata(cx, crate));\n+    let llmeta = C_bytes(metadata::encoder::encode_metadata(cx, crate));\n     let llconst = C_struct([llmeta]);\n     let llglobal = str::as_buf(\"rust_metadata\", {|buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)"}, {"sha": "502510063dfd130286377ccd0729cf8a059ae378", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -172,6 +172,7 @@ export type_is_str;\n export type_is_unique;\n export type_is_enum;\n export type_is_c_like_enum;\n+export type_structurally_contains;\n export type_structurally_contains_uniques;\n export type_autoderef;\n export type_param;\n@@ -2420,7 +2421,8 @@ mod unify {\n     fn fixup_vars(tcx: ty_ctxt, sp: option::t<span>, vb: @var_bindings,\n                   typ: t) -> fixup_result {\n         fn subst_vars(tcx: ty_ctxt, sp: option::t<span>, vb: @var_bindings,\n-                      unresolved: @mutable option::t<int>, vid: int) -> t {\n+                      unresolved: @mutable option::t<int>,\n+                      vars_seen: std::list::list<int>, vid: int) -> t {\n             // Should really return a fixup_result instead of a t, but fold_ty\n             // doesn't allow returning anything but a t.\n             if vid as uint >= ufind::set_count(vb.sets) {\n@@ -2431,21 +2433,28 @@ mod unify {\n             alt smallintmap::find::<t>(vb.types, root_id) {\n               none { *unresolved = some(vid); ret ty::mk_var(tcx, vid); }\n               some(rt) {\n-                if occurs_check_fails(tcx, sp, vid, rt) {\n-                    // Return the type unchanged, so we can error out\n-                    // downstream\n-                    ret rt;\n+                let give_up = false;\n+                std::list::iter(vars_seen) {|v|\n+                    if v == vid {\n+                        give_up = true;\n+                        option::may(sp) {|sp|\n+                            tcx.sess.span_fatal(\n+                                sp, \"can not instantiate infinite type\");\n+                        }\n+                    }\n                 }\n-                ret fold_ty(tcx,\n-                            fm_var(bind subst_vars(tcx, sp, vb, unresolved,\n-                                                   _)), rt);\n+                // Return the type unchanged, so we can error out\n+                // downstream\n+                if give_up { ret rt; }\n+                ret fold_ty(tcx, fm_var(bind subst_vars(\n+                    tcx, sp, vb, unresolved, std::list::cons(vid, @vars_seen),\n+                    _)), rt);\n               }\n             }\n         }\n         let unresolved = @mutable none::<int>;\n-        let rty =\n-            fold_ty(tcx, fm_var(bind subst_vars(tcx, sp, vb, unresolved, _)),\n-                    typ);\n+        let rty = fold_ty(tcx, fm_var(bind subst_vars(\n+            tcx, sp, vb, unresolved, std::list::nil, _)), typ);\n         let ur = *unresolved;\n         alt ur {\n           none { ret fix_ok(rty); }"}, {"sha": "8a06314a96bcd1dfddb06fa7bdb5eb742defa443", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -259,10 +259,9 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n     alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n       some(some(ty)) { ret ty; }\n       some(none) {\n-        tcx.sess.span_fatal(ast_ty.span,\n-                            \"illegal recursive type \\\n-                              insert a enum in the cycle, \\\n-                              if this is desired)\");\n+        tcx.sess.span_fatal(ast_ty.span, \"illegal recursive type. \\\n+                                          insert a enum in the cycle, \\\n+                                          if this is desired)\");\n       }\n       none { }\n     } /* go on */\n@@ -2298,7 +2297,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                 let msg = #fmt[\"attempted access of field %s on type %s, but \\\n                                 no method implementation was found\",\n                                field, ty_to_str(tcx, t_err)];\n-                tcx.sess.span_fatal(expr.span, msg);\n+                tcx.sess.span_err(expr.span, msg);\n+                // NB: Adding a bogus type to allow typechecking to continue\n+                write::ty_only_fixup(fcx, id, ty::mk_nil(tcx));\n               }\n             }\n         }\n@@ -2490,7 +2491,7 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     demand::simple(fcx, e.span, declty, cty);\n }\n \n-fn check_enum_variants(ccx: @crate_ctxt, _sp: span, vs: [ast::variant],\n+fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n                       id: ast::node_id) {\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n@@ -2512,7 +2513,7 @@ fn check_enum_variants(ccx: @crate_ctxt, _sp: span, vs: [ast::variant],\n           some(e) {\n             check_expr(fcx, e);\n             let cty = expr_ty(fcx.ccx.tcx, e);\n-            let declty =ty::mk_int(fcx.ccx.tcx);\n+            let declty = ty::mk_int(fcx.ccx.tcx);\n             demand::simple(fcx, e.span, declty, cty);\n             // FIXME: issue #1417\n             // Also, check_expr (from check_const pass) doesn't guarantee that\n@@ -2537,6 +2538,20 @@ fn check_enum_variants(ccx: @crate_ctxt, _sp: span, vs: [ast::variant],\n         disr_vals += [disr_val];\n         disr_val += 1;\n     }\n+    let outer = true, did = local_def(id);\n+    if ty::type_structurally_contains(ccx.tcx, rty, {|sty|\n+        alt sty {\n+          ty::ty_enum(id, _) if id == did {\n+            if outer { outer = false; false }\n+            else { true }\n+          }\n+          _ { false }\n+        }\n+    }) {\n+        ccx.tcx.sess.span_fatal(sp, \"illegal recursive enum type. \\\n+                                     wrap the inner value in a box to \\\n+                                     make it represenable\");\n+    }\n }\n \n // A generic function for checking the pred in a check"}, {"sha": "d2fbe02d63ad3ed15dd91034eb0a1734d7b2e91c", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -672,7 +672,7 @@ fn gather_comments_and_literals(cm: codemap::codemap,\n                                 path: str,\n                                 srdr: io::reader) ->\n    {cmnts: [cmnt], lits: [lit]} {\n-    let src = @str::unsafe_from_bytes(srdr.read_whole_stream());\n+    let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = @interner::mk::<str>(str::hash, str::eq);\n     let rdr = new_reader(cm, span_diagnostic,\n                          codemap::new_filemap(path, src, 0u, 0u), itr);"}, {"sha": "2ae8a860a2709c2fc9deb7ccc11371b84478dc98", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -118,7 +118,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       }\n       ty_var(v) { \"<T\" + int::str(v) + \">\" }\n       ty_param(id, _) {\n-        \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)])\n+        \"'\" + str::from_bytes([('a' as u8) + (id as u8)])\n       }\n       _ { ty_to_short_str(cx, typ) }\n     }"}, {"sha": "6f3fd87466a6c84cb632212f00be1caaca6124d9", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -85,7 +85,7 @@ fn readclose(fd: fd_t) -> str {\n     let buf = \"\";\n     while !reader.eof() {\n         let bytes = reader.read_bytes(4096u);\n-        buf += str::unsafe_from_bytes(bytes);\n+        buf += str::from_bytes(bytes);\n     }\n     os::fclose(file);\n     ret buf;\n@@ -114,8 +114,8 @@ fn worker(p: port<request>) {\n                 // the alt discriminant are wrong.\n                 alt recv(p) {\n                   exec(lib_path, prog, args, respchan) {\n-                    {lib_path: str::unsafe_from_bytes(lib_path),\n-                     prog: str::unsafe_from_bytes(prog),\n+                    {lib_path: str::from_bytes(lib_path),\n+                     prog: str::from_bytes(prog),\n                      args: clone_vecu8str(args),\n                      respchan: respchan}\n                   }\n@@ -189,7 +189,7 @@ fn clone_vecstr(v: [str]) -> [[u8]] {\n fn clone_vecu8str(v: [[u8]]) -> [str] {\n     let r = [];\n     for t in vec::slice(v, 0u, vec::len(v)) {\n-        r += [str::unsafe_from_bytes(t)];\n+        r += [str::from_bytes(t)];\n     }\n     ret r;\n }"}, {"sha": "eb91c2cb5d517e60d588e8606549d4ea9dbe7f57", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -390,7 +390,7 @@ mod rt {\n     fn str_init_elt(n_elts: uint, c: char) -> str {\n         let svec = vec::init_elt::<u8>(n_elts, c as u8);\n \n-        ret str::unsafe_from_bytes(svec);\n+        ret str::from_bytes(svec);\n     }\n     enum pad_mode { pad_signed, pad_unsigned, pad_nozero, }\n     fn pad(cv: conv, s: str, mode: pad_mode) -> str {\n@@ -439,7 +439,8 @@ mod rt {\n         if signed && zero_padding && str::byte_len(s) > 0u {\n             let head = s[0];\n             if head == '+' as u8 || head == '-' as u8 || head == ' ' as u8 {\n-                let headstr = str::unsafe_from_bytes([head]);\n+                let headstr = str::from_bytes([head]);\n+                // FIXME: not UTF-8 safe\n                 let bytelen = str::byte_len(s);\n                 let numpart = str::substr(s, 1u, bytelen - 1u);\n                 ret headstr + padstr + numpart;"}, {"sha": "dad10eced7f2b96492348c9abfc7aba5cba96b4f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -13,6 +13,7 @@ export\n    // Creating a string\n    from_bytes,\n    unsafe_from_bytes,\n+   from_byte,\n    unsafe_from_byte,\n    //push_utf8_bytes,\n    from_char,\n@@ -117,14 +118,11 @@ Section: Creating a string\n /*\n Function: from_bytes\n \n-Safely convert a vector of bytes to a UTF-8 string, or error\n+Convert a vector of bytes to a UTF-8 string.  Fails if invalid UTF-8.\n */\n-fn from_bytes(vv: [u8]) -> result::t<str, str> {\n-   if is_utf8(vv) {\n-      ret result::ok(unsafe_from_bytes(vv));\n-   } else {\n-      ret result::err(\"vector doesn't contain valid UTF-8\");\n-   }\n+fn from_bytes(vv: [u8]) -> str {\n+   assert is_utf8(vv);\n+   ret unsafe_from_bytes(vv);\n }\n \n /*\n@@ -133,7 +131,7 @@ Function: unsafe_from_bytes\n Converts a vector of bytes to a string. Does not verify that the\n vector contains valid UTF-8.\n \n-// FIXME: remove?\n+FIXME: stop exporting\n */\n fn unsafe_from_bytes(v: [const u8]) -> str unsafe {\n     let vcopy: [u8] = v + [0u8];\n@@ -148,10 +146,20 @@ Function: unsafe_from_byte\n Converts a byte to a string. Does not verify that the byte is\n valid UTF-8.\n \n-FIXME: rename to 'from_byte'\n+FIXME: stop exporting\n */\n fn unsafe_from_byte(u: u8) -> str { unsafe_from_bytes([u]) }\n \n+\n+/*\n+Function: from_byte\n+\n+Convert a byte to a UTF-8 string.  Fails if invalid UTF-8.\n+*/\n+fn from_byte(uu: u8) -> str {\n+    from_bytes([uu])\n+}\n+\n fn push_utf8_bytes(&s: str, ch: char) {\n     let code = ch as uint;\n     let bytes =\n@@ -209,16 +217,16 @@ Function: from_cstr\n Create a Rust string from a null-terminated C string\n */\n unsafe fn from_cstr(cstr: sbuf) -> str {\n-    let res = \"\";\n+    let res = [];\n     let start = cstr;\n     let curr = start;\n     let i = 0u;\n     while *curr != 0u8 {\n-        push_byte(res, *curr);\n+        vec::push(res, *curr);\n         i += 1u;\n         curr = ptr::offset(start, i);\n     }\n-    ret res;\n+    ret from_bytes(res);\n }\n \n /*\n@@ -526,7 +534,7 @@ fn split(s: str, sep: u8) -> [str] {\n             v += [accum];\n             accum = \"\";\n             ends_with_sep = true;\n-        } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n+        } else { accum += from_byte(c); ends_with_sep = false; }\n     }\n     if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n     ret v;\n@@ -554,7 +562,7 @@ fn splitn(s: str, sep: u8, count: uint) -> [str] {\n             v += [accum];\n             accum = \"\";\n             ends_with_sep = true;\n-        } else { accum += unsafe_from_byte(c); ends_with_sep = false; }\n+        } else { accum += from_byte(c); ends_with_sep = false; }\n     }\n     if byte_len(accum) != 0u || ends_with_sep { v += [accum]; }\n     ret v;\n@@ -575,26 +583,26 @@ FIXME: should behave like split and split_char:\n */\n fn split_str(s: str, sep: str) -> [str] {\n     assert byte_len(sep) > 0u;\n-    let v: [str] = [], accum = \"\", sep_match = 0u, leading = true;\n+    let v: [str] = [], accum = [], sep_match = 0u, leading = true;\n     for c: u8 in s {\n         // Did we match the entire separator?\n         if sep_match == byte_len(sep) {\n-            if !leading { v += [accum]; }\n-            accum = \"\";\n+            if !leading { vec::push(v, from_bytes(accum)); }\n+            accum = [];\n             sep_match = 0u;\n         }\n \n         if c == sep[sep_match] {\n             sep_match += 1u;\n         } else {\n             sep_match = 0u;\n-            accum += unsafe_from_byte(c);\n+            vec::push(accum, c);\n             leading = false;\n         }\n     }\n \n-    if byte_len(accum) > 0u { v += [accum]; }\n-    if sep_match == byte_len(sep) { v += [\"\"]; }\n+    if vec::len(accum) > 0u { vec::push(v, from_bytes(accum)); }\n+    if sep_match == byte_len(sep) { vec::push(v, \"\"); }\n \n     ret v;\n }\n@@ -1783,7 +1791,24 @@ mod tests {\n                   0x20_u8, 0x4e_u8, 0x61_u8,\n                   0x6d_u8];\n \n-         assert ss == result::get(from_bytes(bb));\n+         assert ss == from_bytes(bb);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_from_bytes_fail() {\n+        let bb = [0xff_u8, 0xb8_u8, 0xa8_u8,\n+                  0xe0_u8, 0xb9_u8, 0x84_u8,\n+                  0xe0_u8, 0xb8_u8, 0x97_u8,\n+                  0xe0_u8, 0xb8_u8, 0xa2_u8,\n+                  0xe4_u8, 0xb8_u8, 0xad_u8,\n+                  0xe5_u8, 0x8d_u8, 0x8e_u8,\n+                  0x56_u8, 0x69_u8, 0xe1_u8,\n+                  0xbb_u8, 0x87_u8, 0x74_u8,\n+                  0x20_u8, 0x4e_u8, 0x61_u8,\n+                  0x6d_u8];\n+\n+         let _x = from_bytes(bb);\n     }\n \n     #[test]\n@@ -1821,7 +1846,7 @@ mod tests {\n         let s1: str = \"All mimsy were the borogoves\";\n \n         let v: [u8] = bytes(s1);\n-        let s2: str = unsafe_from_bytes(v);\n+        let s2: str = from_bytes(v);\n         let i: uint = 0u;\n         let n1: uint = byte_len(s1);\n         let n2: uint = vec::len::<u8>(v);"}, {"sha": "2112399ba8026b29aee9d95dd2b4b0860a6a7c68", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -236,12 +236,12 @@ fn to_str(num: uint, radix: uint) -> str {\n     if n == 0u { ret \"0\"; }\n     let s: str = \"\";\n     while n != 0u {\n-        s += str::unsafe_from_byte(digit(n % radix) as u8);\n+        s += str::from_byte(digit(n % radix) as u8);\n         n /= radix;\n     }\n     let s1: str = \"\";\n     let len: uint = str::byte_len(s);\n-    while len != 0u { len -= 1u; s1 += str::unsafe_from_byte(s[len]); }\n+    while len != 0u { len -= 1u; s1 += str::from_byte(s[len]); }\n     ret s1;\n }\n "}, {"sha": "4dabab99c238317e12a8c7219da2574db4eb2148", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -307,6 +307,14 @@ fn pop<T: copy>(&v: [const T]) -> T {\n     let e = v[ln];\n     v = slice(v, 0u, ln);\n     ret e;\n+// FIXME use this implementation after the next snapshot (27.01.2012)\n+/*  let new_ln = len(v) - 1u;\n+    assert (new_ln > 0u);\n+    let valptr = ptr::mut_addr_of(v[new_ln]);\n+    let val <- *valptr;\n+    unsafe::set_len(v, new_ln);\n+    val\n+*/\n }\n \n /*"}, {"sha": "89aad5d7777856e632d2715c8b742a9a69a4f0d1", "filename": "src/libstd/freebsd_os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Ffreebsd_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Ffreebsd_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffreebsd_os.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -129,7 +129,8 @@ fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".so\"; }\n /// followed by a path separator\n fn get_exe_path() -> option::t<fs::path> unsafe {\n     let bufsize = 1023u;\n-    let path = str::unsafe_from_bytes(vec::init_elt(bufsize, 0u8));\n+    // FIXME: path \"strings\" will likely need fixing...\n+    let path = str::from_bytes(vec::init_elt(bufsize, 0u8));\n     let mib = [libc_constants::CTL_KERN,\n                libc_constants::KERN_PROC,\n                libc_constants::KERN_PROC_PATHNAME, -1i32];"}, {"sha": "934352e7788445897651ede08f0d401426f52b35", "filename": "src/libstd/generic_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgeneric_os.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -75,7 +75,7 @@ fn getenv(n: str) -> option::t<str> {\n             unsafe {\n                 vec::unsafe::set_len(v, res);\n             }\n-            ret option::some(str::unsafe_from_bytes(v));\n+            ret option::some(str::from_bytes(v)); // UTF-8 or fail\n         } else { nsize = res; }\n     }\n     fail;"}, {"sha": "5cc08813d6abc344a746b90922796b5caead633a", "filename": "src/libstd/io.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -109,7 +109,7 @@ impl reader_util for reader {\n             if ch == -1 || ch == 10 { break; }\n             buf += [ch as u8];\n         }\n-        str::unsafe_from_bytes(buf)\n+        str::from_bytes(buf)\n     }\n \n     fn read_c_str() -> str {\n@@ -118,7 +118,7 @@ impl reader_util for reader {\n             let ch = self.read_byte();\n             if ch < 1 { break; } else { buf += [ch as u8]; }\n         }\n-        str::unsafe_from_bytes(buf)\n+        str::from_bytes(buf)\n     }\n \n     // FIXME deal with eof?\n@@ -461,7 +461,10 @@ fn mk_mem_buffer() -> mem_buffer {\n }\n fn mem_buffer_writer(b: mem_buffer) -> writer { b as writer }\n fn mem_buffer_buf(b: mem_buffer) -> [u8] { vec::from_mut(b.buf) }\n-fn mem_buffer_str(b: mem_buffer) -> str { str::unsafe_from_bytes(b.buf) }\n+fn mem_buffer_str(b: mem_buffer) -> str {\n+   let b_ = vec::from_mut(b.buf);\n+   str::from_bytes(b_)\n+}\n \n // Utility functions\n fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n@@ -479,7 +482,7 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n \n fn read_whole_file_str(file: str) -> result::t<str, str> {\n     result::chain(read_whole_file(file), { |bytes|\n-        result::ok(str::unsafe_from_bytes(bytes))\n+        result::ok(str::from_bytes(bytes))\n     })\n }\n "}, {"sha": "82b1197a51fbd226d96aaa9fe4a1c5a959ac9a39", "filename": "src/libstd/linux_os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flinux_os.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -125,7 +125,8 @@ fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".so\"; }\n /// followed by a path separator\n fn get_exe_path() -> option::t<fs::path> {\n     let bufsize = 1023u;\n-    let path = str::unsafe_from_bytes(vec::init_elt(bufsize, 0u8));\n+    // FIXME: path \"strings\" will likely need fixing...\n+    let path = str::from_bytes(vec::init_elt(bufsize, 0u8));\n     ret str::as_buf(\"/proc/self/exe\", { |proc_self_buf|\n         str::as_buf(path, { |path_buf|\n             if libc::readlink(proc_self_buf, path_buf, bufsize) != -1 {"}, {"sha": "e393b42b9f25c02335939c7ec625b7aee597e293", "filename": "src/libstd/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -128,7 +128,7 @@ Function: tail\n \n Returns all but the first element of a list\n */\n-pure fn tail<T: copy>(ls: list<T>) : is_not_empty(ls) -> list<T> {\n+pure fn tail<T: copy>(ls: list<T>) -> list<T> {\n     alt ls {\n         cons(_, tl) { ret *tl; }\n         nil { fail \"list empty\" }"}, {"sha": "cd984870781cb0cab0f32ab3eb91f358646f5dcb", "filename": "src/libstd/macos_os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacos_os.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -133,8 +133,9 @@ fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".dylib\"; }\n \n fn get_exe_path() -> option::t<fs::path> {\n     // FIXME: This doesn't handle the case where the buffer is too small\n+    // FIXME: path \"strings\" will likely need fixing...\n     let bufsize = 1023u32;\n-    let path = str::unsafe_from_bytes(vec::init_elt(bufsize as uint, 0u8));\n+    let path = str::from_bytes(vec::init_elt(bufsize as uint, 0u8));\n     ret str::as_buf(path, { |path_buf|\n         if mac_libc::_NSGetExecutablePath(path_buf,\n                                           ptr::mut_addr_of(bufsize)) == 0i32 {"}, {"sha": "5b2de1e57d0c880358f8cb54c606babdcd82744f", "filename": "src/libstd/run_program.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun_program.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -216,7 +216,7 @@ fn read_all(rd: io::reader) -> str {\n     let buf = \"\";\n     while !rd.eof() {\n         let bytes = rd.read_bytes(4096u);\n-        buf += str::unsafe_from_bytes(bytes);\n+        buf += str::from_bytes(bytes);\n     }\n     ret buf;\n }\n@@ -347,7 +347,7 @@ mod tests {\n             let buf = \"\";\n             while !reader.eof() {\n                 let bytes = reader.read_bytes(4096u);\n-                buf += str::unsafe_from_bytes(bytes);\n+                buf += str::from_bytes(bytes);\n             }\n             os::fclose(file);\n             ret buf;"}, {"sha": "ae08cd5ed5e013b7dd3767675376d0a2d36d6eae", "filename": "src/libstd/uvtmp.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Fuvtmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Fuvtmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuvtmp.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -27,6 +27,11 @@ native mod rustrt {\n         thread: thread,\n         req_id: u32,\n         chan: comm::chan<iomsg>);\n+    fn rust_uvtmp_timer(\n+        thread: thread,\n+        timeout: u32,\n+        req_id: u32,\n+        chan: comm::chan<iomsg>);\n     fn rust_uvtmp_delete_buf(buf: *u8);\n     fn rust_uvtmp_get_req_id(cd: connect_data) -> u32;\n }\n@@ -39,7 +44,9 @@ enum iomsg {\n     whatever,\n     connected(connect_data),\n     wrote(connect_data),\n-    read(connect_data, *u8, ctypes::ssize_t)\n+    read(connect_data, *u8, ctypes::ssize_t),\n+    timer(u32),\n+    exit\n }\n \n fn create_thread() -> thread {\n@@ -80,6 +87,11 @@ fn read_start(thread: thread, req_id: u32,\n     rustrt::rust_uvtmp_read_start(thread, req_id, chan);\n }\n \n+fn timer_start(thread: thread, timeout: u32, req_id: u32,\n+              chan: comm::chan<iomsg>) {\n+    rustrt::rust_uvtmp_timer(thread, timeout, req_id, chan);\n+}\n+\n fn delete_buf(buf: *u8) {\n     rustrt::rust_uvtmp_delete_buf(buf);\n }\n@@ -138,7 +150,7 @@ fn test_http() {\n                     unsafe {\n                         log(error, len);\n                         let buf = vec::unsafe::from_buf(buf, len as uint);\n-                        let str = str::unsafe_from_bytes(buf);\n+                        let str = str::from_bytes(buf);\n                         #error(\"read something\");\n                         io::println(str);\n                     }\n@@ -153,4 +165,4 @@ fn test_http() {\n     }\n     join_thread(thread);\n     delete_thread(thread);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "83306c757a4dd9bbad46fcfbc77be85449915223", "filename": "src/libstd/win32_os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Flibstd%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fwin32_os.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -113,8 +113,9 @@ fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n \n fn get_exe_path() -> option::t<fs::path> {\n     // FIXME: This doesn't handle the case where the buffer is too small\n+    // FIXME: path \"strings\" will likely need fixing...\n     let bufsize = 1023u;\n-    let path = str::unsafe_from_bytes(vec::init_elt(bufsize, 0u8));\n+    let path = str::from_bytes(vec::init_elt(bufsize, 0u8));\n     ret str::as_buf(path, { |path_buf|\n         if kernel32::GetModuleFileNameA(0u, path_buf,\n                                         bufsize as u32) != 0u32 {"}, {"sha": "7f4b425e5ec8e1aadd4bd72b0ecbb477ab18fadb", "filename": "src/rt/rust_uvtmp.cpp", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Frt%2Frust_uvtmp.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Frt%2Frust_uvtmp.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uvtmp.cpp?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -15,9 +15,12 @@ struct connect_data {\n     chan_handle chan;\n };\n \n+const intptr_t whatever_tag = 0;\n const intptr_t connected_tag = 1;\n const intptr_t wrote_tag = 2;\n const intptr_t read_tag = 3;\n+const intptr_t timer_tag = 4;\n+const intptr_t exit_tag = 5;\n \n struct iomsg {\n     intptr_t tag;\n@@ -29,6 +32,7 @@ struct iomsg {\n \t    uint8_t *buf;\n \t    ssize_t nread;\n \t} read_val;\n+        uint32_t timer_req_id;\n     } val;\n };\n \n@@ -44,6 +48,13 @@ struct read_start_data {\n     chan_handle chan;\n };\n \n+struct timer_start_data {\n+    rust_uvtmp_thread *thread;\n+    uint32_t timeout;\n+    uint32_t req_id;\n+    chan_handle chan;\n+};\n+\n // FIXME: Copied from rust_builtins.cpp. Could bitrot easily\n static void\n send(rust_task *task, chan_handle chan, void *data) {\n@@ -72,7 +83,7 @@ class rust_uvtmp_thread : public rust_thread {\n     std::queue<connect_data*> close_connection_queue;\n     std::queue<write_data*> write_queue;\n     std::queue<read_start_data*> read_start_queue;\n-\n+    std::queue<timer_start_data*> timer_start_queue;\n public:\n \n     rust_uvtmp_thread() {\n@@ -139,6 +150,17 @@ class rust_uvtmp_thread : public rust_thread {\n         read_start_queue.push(rd);\n     }\n \n+    void\n+    timer(uint32_t timeout, uint32_t req_id, chan_handle chan) {\n+        scoped_lock with(lock);\n+\n+        timer_start_data *td = new timer_start_data();\n+        td->timeout = timeout;\n+        td->req_id = req_id;\n+        td->chan = chan;\n+        timer_start_queue.push(td);\n+    }\n+\n private:\n \n     virtual void\n@@ -159,6 +181,7 @@ class rust_uvtmp_thread : public rust_thread {\n \tclose_connections();\n \twrite_buffers();\n \tstart_reads();\n+        start_timers();\n \tclose_idle_if_stop();\n     }\n \n@@ -246,7 +269,7 @@ class rust_uvtmp_thread : public rust_thread {\n     void\n     on_write(uv_write_t *handle, write_data *wd) {\n \tiomsg msg;\n-\tmsg.tag = wrote_tag;\n+\tmsg.tag = timer_tag;\n \tmsg.val.wrote_val = wd->cd;\n \n \tsend(task, wd->chan, &msg);\n@@ -299,6 +322,40 @@ class rust_uvtmp_thread : public rust_thread {\n \t}\n     }\n \n+    void\n+    start_timers() {\n+\tassert (lock.lock_held_by_current_thread());\n+\twhile (!timer_start_queue.empty()) {\n+\t    timer_start_data *td = timer_start_queue.front();\n+\t    timer_start_queue.pop();\n+\n+            td->thread = this;\n+\n+            uv_timer_t *timer = (uv_timer_t *)malloc(sizeof(uv_timer_t));\n+            timer->data = td;\n+            uv_timer_init(loop, timer);\n+            uv_timer_start(timer, timer_cb, td->timeout, 0);\n+\t}\n+    }\n+\n+    static void\n+    timer_cb(uv_timer_t *handle, int what) {\n+\ttimer_start_data *td = (timer_start_data*)handle->data;\n+\trust_uvtmp_thread *self = td->thread;\n+\tself->on_timer(td);\n+        free(handle);\n+    }\n+\n+    void\n+    on_timer(timer_start_data *rd) {\n+\tiomsg msg;\n+\tmsg.tag = timer_tag;\n+        msg.val.timer_req_id = rd->req_id;\n+\n+\tsend(task, rd->chan, &msg);\n+        delete rd;\n+    }\n+\n     void\n     close_idle_if_stop() {\n \tassert(lock.lock_held_by_current_thread());\n@@ -353,6 +410,11 @@ rust_uvtmp_read_start(rust_uvtmp_thread *thread, uint32_t req_id,\n     thread->read_start(req_id, *chan);\n }\n \n+extern \"C\" void\n+rust_uvtmp_timer(rust_uvtmp_thread *thread, uint32_t timeout, uint32_t req_id, chan_handle *chan) {\n+    thread->timer(timeout, req_id, *chan);\n+}\n+\n extern \"C\" void\n rust_uvtmp_delete_buf(uint8_t *buf) {\n     delete [] buf;"}, {"sha": "052f4a42779cd4405cec886ae21c03322d2ec73a", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -96,6 +96,7 @@ rust_uvtmp_connect\n rust_uvtmp_close_connection\n rust_uvtmp_write\n rust_uvtmp_read_start\n+rust_uvtmp_timer\n rust_uvtmp_delete_buf\n rust_uvtmp_get_req_id\n "}, {"sha": "8be28fabd79435fc9209911e0cfada3e96b1c785", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -32,7 +32,7 @@ import comm::recv;\n import comm::send;\n \n fn map(&&filename: [u8], emit: map_reduce::putter<[u8], int>) {\n-    let f = io::file_reader(str::unsafe_from_bytes(filename));\n+    let f = io::file_reader(str::from_bytes(filename));\n \n     while true {\n         alt read_word(f) {"}, {"sha": "7ead10b3f63371160b853fb20f28fa7fa30fead0", "filename": "src/test/compile-fail/attempted-access-non-fatal.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Ftest%2Fcompile-fail%2Fattempted-access-non-fatal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Ftest%2Fcompile-fail%2Fattempted-access-non-fatal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattempted-access-non-fatal.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -0,0 +1,6 @@\n+// Check that bogus field access is non-fatal\n+fn main() {\n+    let x = 0;\n+    log(debug, x.foo); //! ERROR attempted access of field\n+    log(debug, x.bar); //! ERROR attempted access of field\n+}\n\\ No newline at end of file"}, {"sha": "069bd0a5bbd72510e0a12df911d8696af5663801", "filename": "src/test/compile-fail/occurs-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -1,2 +1,2 @@\n-// error-pattern: Type inference failed because I could not find\n+// error-pattern: can not instantiate infinite type\n fn main() { let f; f = @f; }"}, {"sha": "b3764036b99f08647983fa005270bfc3adbfdd26", "filename": "src/test/compile-fail/recursive-enum.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Ftest%2Fcompile-fail%2Frecursive-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Ftest%2Fcompile-fail%2Frecursive-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursive-enum.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -0,0 +1,5 @@\n+// error-pattern: illegal recursive enum type\n+\n+enum list<T> { cons(T, list<T>), nil }\n+\n+fn main() {}"}, {"sha": "9301d93874ebed0e4ed623a7f007df05e3b04fb8", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a831e7ce13aa19acf0f65e508097351f8dabca84/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=a831e7ce13aa19acf0f65e508097351f8dabca84", "patch": "@@ -81,7 +81,7 @@ mod map_reduce {\n               mapper_done { num_mappers -= 1; }\n               find_reducer(k, cc) {\n                 let c;\n-                alt reducers.find(str::unsafe_from_bytes(k)) {\n+                alt reducers.find(str::from_bytes(k)) {\n                   some(_c) { c = _c; }\n                   none { c = 0; }\n                 }"}]}