{"sha": "98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4YjM3NTQ4M2M0NGM2ODAwOWQ2OTlhNGNkNGI3YjBhM2Q1ZDk3YTM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-01-25T18:48:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-01-25T18:48:49Z"}, "message": "Rollup merge of #47502 - petrochenkov:label, r=eddyb\n\nAST/HIR: Add a separate structure for labels", "tree": {"sha": "1cba42b1aa98db0d012cbecfb36d7d2dea428232", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cba42b1aa98db0d012cbecfb36d7d2dea428232"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "html_url": "https://github.com/rust-lang/rust/commit/98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "304885d959cae6b1fd6cb9aa64b70df6269d04b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/304885d959cae6b1fd6cb9aa64b70df6269d04b4", "html_url": "https://github.com/rust-lang/rust/commit/304885d959cae6b1fd6cb9aa64b70df6269d04b4"}, {"sha": "2d56abfbebdc905dafc9cf9edc0a6f58e4de7cbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d56abfbebdc905dafc9cf9edc0a6f58e4de7cbd", "html_url": "https://github.com/rust-lang/rust/commit/2d56abfbebdc905dafc9cf9edc0a6f58e4de7cbd"}], "stats": {"total": 405, "additions": 203, "deletions": 202}, "files": [{"sha": "97cf9b01410b1bccedfe309845fdac247c1ac4b8", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -43,7 +43,6 @@\n \n use syntax::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n-use syntax::codemap::Spanned;\n use syntax_pos::Span;\n use hir::*;\n use hir::def::Def;\n@@ -336,6 +335,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics, item_id: NodeId) {\n         walk_variant(self, v, g, item_id)\n     }\n+    fn visit_label(&mut self, label: &'v Label) {\n+        walk_label(self, label)\n+    }\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n@@ -370,18 +372,6 @@ pub trait Visitor<'v> : Sized {\n     }\n }\n \n-pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n-    if let Some(name) = opt_name {\n-        visitor.visit_name(span, name);\n-    }\n-}\n-\n-pub fn walk_opt_sp_name<'v, V: Visitor<'v>>(visitor: &mut V, opt_sp_name: &Option<Spanned<Name>>) {\n-    if let Some(ref sp_name) = *opt_sp_name {\n-        visitor.visit_name(sp_name.span, sp_name.node);\n-    }\n-}\n-\n /// Walks the contents of a crate. See also `Crate::visit_all_items`.\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n@@ -420,6 +410,10 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     walk_list!(visitor, visit_ty, &local.ty);\n }\n \n+pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n+    visitor.visit_name(label.span, label.name);\n+}\n+\n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n     visitor.visit_id(lifetime.id);\n     match lifetime.name {\n@@ -452,7 +446,9 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     match item.node {\n         ItemExternCrate(opt_name) => {\n             visitor.visit_id(item.id);\n-            walk_opt_name(visitor, item.span, opt_name)\n+            if let Some(name) = opt_name {\n+                visitor.visit_name(item.span, name);\n+            }\n         }\n         ItemUse(ref path, _) => {\n             visitor.visit_id(item.id);\n@@ -993,14 +989,14 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhile(ref subexpression, ref block, ref opt_sp_name) => {\n+        ExprWhile(ref subexpression, ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_sp_name(visitor, opt_sp_name);\n         }\n-        ExprLoop(ref block, ref opt_sp_name, _) => {\n+        ExprLoop(ref block, ref opt_label, _) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n-            walk_opt_sp_name(visitor, opt_sp_name);\n         }\n         ExprMatch(ref subexpression, ref arms, _) => {\n             visitor.visit_expr(subexpression);\n@@ -1036,28 +1032,28 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprPath(ref qpath) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n         }\n-        ExprBreak(label, ref opt_expr) => {\n-            label.ident.map(|ident| {\n-                match label.target_id {\n+        ExprBreak(ref destination, ref opt_expr) => {\n+            if let Some(ref label) = destination.label {\n+                visitor.visit_label(label);\n+                match destination.target_id {\n                     ScopeTarget::Block(node_id) |\n                     ScopeTarget::Loop(LoopIdResult::Ok(node_id)) =>\n                         visitor.visit_def_mention(Def::Label(node_id)),\n                     ScopeTarget::Loop(LoopIdResult::Err(_)) => {},\n                 };\n-                visitor.visit_name(ident.span, ident.node.name);\n-            });\n+            }\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprAgain(label) => {\n-            label.ident.map(|ident| {\n-                match label.target_id {\n+        ExprAgain(ref destination) => {\n+            if let Some(ref label) = destination.label {\n+                visitor.visit_label(label);\n+                match destination.target_id {\n                     ScopeTarget::Block(_) => bug!(\"can't `continue` to a non-loop block\"),\n                     ScopeTarget::Loop(LoopIdResult::Ok(node_id)) =>\n                         visitor.visit_def_mention(Def::Label(node_id)),\n                     ScopeTarget::Loop(LoopIdResult::Err(_)) => {},\n                 };\n-                visitor.visit_name(ident.span, ident.node.name);\n-            });\n+            }\n         }\n         ExprRet(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}, {"sha": "dc2f2583c0177c1ddc687b2b2175f739894e620e", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -773,22 +773,22 @@ impl<'a> LoweringContext<'a> {\n         *self.name_map.entry(ident).or_insert_with(|| Symbol::from_ident(ident))\n     }\n \n-    fn lower_opt_sp_ident(&mut self, o_id: Option<Spanned<Ident>>) -> Option<Spanned<Name>> {\n-        o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n+    fn lower_label(&mut self, label: Option<Label>) -> Option<hir::Label> {\n+        label.map(|label| hir::Label { name: label.ident.name, span: label.span })\n     }\n \n-    fn lower_loop_destination(&mut self, destination: Option<(NodeId, Spanned<Ident>)>)\n+    fn lower_loop_destination(&mut self, destination: Option<(NodeId, Label)>)\n         -> hir::Destination\n     {\n         match destination {\n-            Some((id, label_ident)) => {\n+            Some((id, label)) => {\n                 let target = if let Def::Label(loop_id) = self.expect_full_def(id) {\n                     hir::LoopIdResult::Ok(self.lower_node_id(loop_id).node_id)\n                 } else {\n                     hir::LoopIdResult::Err(hir::LoopIdError::UnresolvedLabel)\n                 };\n                 hir::Destination {\n-                    ident: Some(label_ident),\n+                    label: self.lower_label(Some(label)),\n                     target_id: hir::ScopeTarget::Loop(target),\n                 }\n             },\n@@ -798,7 +798,7 @@ impl<'a> LoweringContext<'a> {\n                                   .map(|innermost_loop_id| *innermost_loop_id);\n \n                 hir::Destination {\n-                    ident: None,\n+                    label: None,\n                     target_id: hir::ScopeTarget::Loop(\n                         loop_id.map(|id| Ok(self.lower_node_id(id).node_id))\n                                .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope))\n@@ -2751,17 +2751,17 @@ impl<'a> LoweringContext<'a> {\n \n                 hir::ExprIf(P(self.lower_expr(cond)), P(then_expr), else_opt)\n             }\n-            ExprKind::While(ref cond, ref body, opt_ident) => {\n+            ExprKind::While(ref cond, ref body, opt_label) => {\n                 self.with_loop_scope(e.id, |this|\n                     hir::ExprWhile(\n                         this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n                         this.lower_block(body, false),\n-                        this.lower_opt_sp_ident(opt_ident)))\n+                        this.lower_label(opt_label)))\n             }\n-            ExprKind::Loop(ref body, opt_ident) => {\n+            ExprKind::Loop(ref body, opt_label) => {\n                 self.with_loop_scope(e.id, |this|\n                     hir::ExprLoop(this.lower_block(body, false),\n-                                  this.lower_opt_sp_ident(opt_ident),\n+                                  this.lower_label(opt_label),\n                                   hir::LoopSource::Loop))\n             }\n             ExprKind::Catch(ref body) => {\n@@ -2877,30 +2877,30 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional,\n                                                ImplTraitContext::Disallowed))\n             }\n-            ExprKind::Break(opt_ident, ref opt_expr) => {\n-                let label_result = if self.is_in_loop_condition && opt_ident.is_none() {\n+            ExprKind::Break(opt_label, ref opt_expr) => {\n+                let destination = if self.is_in_loop_condition && opt_label.is_none() {\n                     hir::Destination {\n-                        ident: opt_ident,\n+                        label: None,\n                         target_id: hir::ScopeTarget::Loop(\n                                 Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into()),\n                     }\n                 } else {\n-                    self.lower_loop_destination(opt_ident.map(|ident| (e.id, ident)))\n+                    self.lower_loop_destination(opt_label.map(|label| (e.id, label)))\n                 };\n                 hir::ExprBreak(\n-                        label_result,\n+                        destination,\n                         opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n             }\n-            ExprKind::Continue(opt_ident) =>\n+            ExprKind::Continue(opt_label) =>\n                 hir::ExprAgain(\n-                    if self.is_in_loop_condition && opt_ident.is_none() {\n+                    if self.is_in_loop_condition && opt_label.is_none() {\n                         hir::Destination {\n-                            ident: opt_ident,\n+                            label: None,\n                             target_id: hir::ScopeTarget::Loop(Err(\n                                 hir::LoopIdError::UnlabeledCfInWhileCondition).into()),\n                         }\n                     } else {\n-                        self.lower_loop_destination(opt_ident.map( |ident| (e.id, ident)))\n+                        self.lower_loop_destination(opt_label.map(|label| (e.id, label)))\n                     }),\n             ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n             ExprKind::InlineAsm(ref asm) => {\n@@ -3000,7 +3000,7 @@ impl<'a> LoweringContext<'a> {\n \n             // Desugar ExprWhileLet\n             // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n-            ExprKind::WhileLet(ref pat, ref sub_expr, ref body, opt_ident) => {\n+            ExprKind::WhileLet(ref pat, ref sub_expr, ref body, opt_label) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -3041,15 +3041,15 @@ impl<'a> LoweringContext<'a> {\n \n                 // `[opt_ident]: loop { ... }`\n                 let loop_block = P(self.block_expr(P(match_expr)));\n-                let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n+                let loop_expr = hir::ExprLoop(loop_block, self.lower_label(opt_label),\n                                               hir::LoopSource::WhileLet);\n                 // add attributes to the outer returned expr node\n                 loop_expr\n             }\n \n             // Desugar ExprForLoop\n             // From: `[opt_ident]: for <pat> in <head> <body>`\n-            ExprKind::ForLoop(ref pat, ref head, ref body, opt_ident) => {\n+            ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n                 // to:\n                 //\n                 //   {\n@@ -3150,7 +3150,7 @@ impl<'a> LoweringContext<'a> {\n                                                   None));\n \n                 // `[opt_ident]: loop { ... }`\n-                let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n+                let loop_expr = hir::ExprLoop(loop_block, self.lower_label(opt_label),\n                                               hir::LoopSource::ForLoop);\n                 let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n                 let loop_expr = P(hir::Expr {\n@@ -3270,7 +3270,7 @@ impl<'a> LoweringContext<'a> {\n                             e.span,\n                             hir::ExprBreak(\n                                 hir::Destination {\n-                                    ident: None,\n+                                    label: None,\n                                     target_id: hir::ScopeTarget::Block(catch_node),\n                                 },\n                                 Some(from_err_expr)"}, {"sha": "2854b9da1476f618e964195d89ca3954367fa17f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -34,7 +34,7 @@ use util::nodemap::{NodeMap, FxHashSet};\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n-use syntax::ast::{self, Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n+use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n@@ -172,6 +172,18 @@ pub const DUMMY_HIR_ID: HirId = HirId {\n \n pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId(!0);\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub struct Label {\n+    pub name: Name,\n+    pub span: Span,\n+}\n+\n+impl fmt::Debug for Label {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"label({:?})\", self.name)\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -1276,11 +1288,11 @@ pub enum Expr_ {\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    ExprWhile(P<Expr>, P<Block>, Option<Spanned<Name>>),\n+    ExprWhile(P<Expr>, P<Block>, Option<Label>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    ExprLoop(P<Block>, Option<Spanned<Name>>, LoopSource),\n+    ExprLoop(P<Block>, Option<Label>, LoopSource),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n     ExprMatch(P<Expr>, HirVec<Arm>, MatchSource),\n@@ -1459,7 +1471,7 @@ impl ScopeTarget {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct Destination {\n     // This is `Some(_)` iff there is an explicit user-specified `label\n-    pub ident: Option<Spanned<Ident>>,\n+    pub label: Option<Label>,\n \n     // These errors are caught and then reported during the diagnostics pass in\n     // librustc_passes/loops.rs"}, {"sha": "30c1ad01d140138705fd350114a595c59d3ab2de", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -1337,19 +1337,19 @@ impl<'a> State<'a> {\n             hir::ExprIf(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n-            hir::ExprWhile(ref test, ref blk, opt_sp_name) => {\n-                if let Some(sp_name) = opt_sp_name {\n-                    self.print_name(sp_name.node)?;\n+            hir::ExprWhile(ref test, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_name(label.name)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n                 self.print_expr_as_cond(&test)?;\n                 self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprLoop(ref blk, opt_sp_name, _) => {\n-                if let Some(sp_name) = opt_sp_name {\n-                    self.print_name(sp_name.node)?;\n+            hir::ExprLoop(ref blk, opt_label, _) => {\n+                if let Some(label) = opt_label {\n+                    self.print_name(label.name)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;\n@@ -1424,23 +1424,23 @@ impl<'a> State<'a> {\n             hir::ExprPath(ref qpath) => {\n                 self.print_qpath(qpath, true)?\n             }\n-            hir::ExprBreak(label, ref opt_expr) => {\n+            hir::ExprBreak(destination, ref opt_expr) => {\n                 self.s.word(\"break\")?;\n                 self.s.space()?;\n-                if let Some(label_ident) = label.ident {\n-                    self.print_name(label_ident.node.name)?;\n+                if let Some(label) = destination.label {\n+                    self.print_name(label.name)?;\n                     self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                     self.s.space()?;\n                 }\n             }\n-            hir::ExprAgain(label) => {\n+            hir::ExprAgain(destination) => {\n                 self.s.word(\"continue\")?;\n                 self.s.space()?;\n-                if let Some(label_ident) = label.ident {\n-                    self.print_name(label_ident.node.name)?;\n+                if let Some(label) = destination.label {\n+                    self.print_name(label.name)?;\n                     self.s.space()?\n                 }\n             }"}, {"sha": "7dca96f94e655f8b4ff318f9f24d69d875391471", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -148,6 +148,11 @@ impl_stable_hash_for!(enum hir::LifetimeName {\n     Name(name)\n });\n \n+impl_stable_hash_for!(struct hir::Label {\n+    span,\n+    name\n+});\n+\n impl_stable_hash_for!(struct hir::Lifetime {\n     id,\n     span,\n@@ -619,7 +624,7 @@ impl_stable_hash_for!(enum hir::CaptureClause {\n impl_stable_hash_for_spanned!(usize);\n \n impl_stable_hash_for!(struct hir::Destination {\n-    ident,\n+    label,\n     target_id\n });\n "}, {"sha": "944d770516375ea20dd03aad6cd987722f7f3c8f", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -1018,7 +1018,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n         match ex.node {\n             hir::ExprWhile(.., Some(label)) | hir::ExprLoop(_, Some(label), _) => {\n-                Some((label.node, label.span))\n+                Some((label.name, label.span))\n             }\n             _ => None,\n         }"}, {"sha": "6971033c8994b97afb28085257c269afabd0f4d7", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -141,14 +141,6 @@ impl<'a> AstValidator<'a> {\n impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_expr(&mut self, expr: &'a Expr) {\n         match expr.node {\n-            ExprKind::While(.., Some(ident)) |\n-            ExprKind::Loop(_, Some(ident)) |\n-            ExprKind::WhileLet(.., Some(ident)) |\n-            ExprKind::ForLoop(.., Some(ident)) |\n-            ExprKind::Break(Some(ident), _) |\n-            ExprKind::Continue(Some(ident)) => {\n-                self.check_label(ident.node, ident.span);\n-            }\n             ExprKind::InlineAsm(..) if !self.session.target.target.options.allow_asm => {\n                 span_err!(self.session, expr.span, E0472, \"asm! is unsupported on this target\");\n             }\n@@ -211,6 +203,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_use_tree(self, use_tree, id);\n     }\n \n+    fn visit_label(&mut self, label: &'a Label) {\n+        self.check_label(label.ident, label.span);\n+        visit::walk_label(self, label);\n+    }\n+\n     fn visit_lifetime(&mut self, lifetime: &'a Lifetime) {\n         self.check_lifetime(lifetime);\n         visit::walk_lifetime(self, lifetime);"}, {"sha": "1df19b6b678a9ea3ee7dd36a38530dc3ab1a512e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -55,7 +55,7 @@ use syntax::attr;\n use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParam, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n-use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n+use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n use syntax::feature_gate::{feature_err, emit_feature_err, GateIssue};\n use syntax::parse::token;\n@@ -3415,21 +3415,21 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn with_resolved_label<F>(&mut self, label: Option<SpannedIdent>, id: NodeId, f: F)\n+    fn with_resolved_label<F>(&mut self, label: Option<Label>, id: NodeId, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n         if let Some(label) = label {\n             let def = Def::Label(id);\n             self.with_label_rib(|this| {\n-                this.label_ribs.last_mut().unwrap().bindings.insert(label.node, def);\n+                this.label_ribs.last_mut().unwrap().bindings.insert(label.ident, def);\n                 f(this);\n             });\n         } else {\n             f(self);\n         }\n     }\n \n-    fn resolve_labeled_block(&mut self, label: Option<SpannedIdent>, id: NodeId, block: &Block) {\n+    fn resolve_labeled_block(&mut self, label: Option<Label>, id: NodeId, block: &Block) {\n         self.with_resolved_label(label, id, |this| this.visit_block(block));\n     }\n \n@@ -3452,19 +3452,19 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n-                match self.search_label(label.node, |rib, id| rib.bindings.get(&id).cloned()) {\n+                match self.search_label(label.ident, |rib, id| rib.bindings.get(&id).cloned()) {\n                     None => {\n                         // Search again for close matches...\n                         // Picks the first label that is \"close enough\", which is not necessarily\n                         // the closest match\n-                        let close_match = self.search_label(label.node, |rib, ident| {\n+                        let close_match = self.search_label(label.ident, |rib, ident| {\n                             let names = rib.bindings.iter().map(|(id, _)| &id.name);\n                             find_best_match_for_name(names, &*ident.name.as_str(), None)\n                         });\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n                                       label.span,\n-                                      ResolutionError::UndeclaredLabel(&label.node.name.as_str(),\n+                                      ResolutionError::UndeclaredLabel(&label.ident.name.as_str(),\n                                                                        close_match));\n                     }\n                     Some(def @ Def::Label(_)) => {"}, {"sha": "73810b3fe81d73cc02bc58bca039e36f7ad06536", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -33,6 +33,18 @@ use std::fmt;\n use std::rc::Rc;\n use std::u32;\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub struct Label {\n+    pub ident: Ident,\n+    pub span: Span,\n+}\n+\n+impl fmt::Debug for Label {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"label({:?})\", self.ident)\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -1078,23 +1090,23 @@ pub enum ExprKind {\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    While(P<Expr>, P<Block>, Option<SpannedIdent>),\n+    While(P<Expr>, P<Block>, Option<Label>),\n     /// A while-let loop, with an optional label\n     ///\n     /// `'label: while let pat = expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    WhileLet(P<Pat>, P<Expr>, P<Block>, Option<SpannedIdent>),\n+    WhileLet(P<Pat>, P<Expr>, P<Block>, Option<Label>),\n     /// A for loop, with an optional label\n     ///\n     /// `'label: for pat in expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    ForLoop(P<Pat>, P<Expr>, P<Block>, Option<SpannedIdent>),\n+    ForLoop(P<Pat>, P<Expr>, P<Block>, Option<Label>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    Loop(P<Block>, Option<SpannedIdent>),\n+    Loop(P<Block>, Option<Label>),\n     /// A `match` block.\n     Match(P<Expr>, Vec<Arm>),\n     /// A closure (for example, `move |a, b, c| a + b + c`)\n@@ -1133,9 +1145,9 @@ pub enum ExprKind {\n     /// A referencing operation (`&a` or `&mut a`)\n     AddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break, and an optional expression\n-    Break(Option<SpannedIdent>, Option<P<Expr>>),\n+    Break(Option<Label>, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n-    Continue(Option<SpannedIdent>),\n+    Continue(Option<Label>),\n     /// A `return`, with an optional value to be returned\n     Ret(Option<P<Expr>>),\n "}, {"sha": "0f8fe57e380e557e02379331bcdb4b774ffce223", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -193,6 +193,10 @@ pub trait Folder : Sized {\n         noop_fold_macro_def(def, self)\n     }\n \n+    fn fold_label(&mut self, label: Label) -> Label {\n+        noop_fold_label(label, self)\n+    }\n+\n     fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n         noop_fold_lifetime(l, self)\n     }\n@@ -696,6 +700,13 @@ pub fn noop_fold_generic_params<T: Folder>(\n     params.move_map(|p| fld.fold_generic_param(p))\n }\n \n+pub fn noop_fold_label<T: Folder>(label: Label, fld: &mut T) -> Label {\n+    Label {\n+        ident: fld.fold_ident(label.ident),\n+        span: fld.new_span(label.span),\n+    }\n+}\n+\n pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n         id: fld.new_id(l.id),\n@@ -1206,30 +1217,26 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                           folder.fold_block(tr),\n                           fl.map(|x| folder.fold_expr(x)))\n             }\n-            ExprKind::While(cond, body, opt_ident) => {\n+            ExprKind::While(cond, body, opt_label) => {\n                 ExprKind::While(folder.fold_expr(cond),\n                           folder.fold_block(body),\n-                          opt_ident.map(|label| respan(folder.new_span(label.span),\n-                                                       folder.fold_ident(label.node))))\n+                          opt_label.map(|label| folder.fold_label(label)))\n             }\n-            ExprKind::WhileLet(pat, expr, body, opt_ident) => {\n+            ExprKind::WhileLet(pat, expr, body, opt_label) => {\n                 ExprKind::WhileLet(folder.fold_pat(pat),\n                              folder.fold_expr(expr),\n                              folder.fold_block(body),\n-                             opt_ident.map(|label| respan(folder.new_span(label.span),\n-                                                          folder.fold_ident(label.node))))\n+                             opt_label.map(|label| folder.fold_label(label)))\n             }\n-            ExprKind::ForLoop(pat, iter, body, opt_ident) => {\n+            ExprKind::ForLoop(pat, iter, body, opt_label) => {\n                 ExprKind::ForLoop(folder.fold_pat(pat),\n                             folder.fold_expr(iter),\n                             folder.fold_block(body),\n-                            opt_ident.map(|label| respan(folder.new_span(label.span),\n-                                                         folder.fold_ident(label.node))))\n+                            opt_label.map(|label| folder.fold_label(label)))\n             }\n-            ExprKind::Loop(body, opt_ident) => {\n+            ExprKind::Loop(body, opt_label) => {\n                 ExprKind::Loop(folder.fold_block(body),\n-                               opt_ident.map(|label| respan(folder.new_span(label.span),\n-                                                            folder.fold_ident(label.node))))\n+                               opt_label.map(|label| folder.fold_label(label)))\n             }\n             ExprKind::Match(expr, arms) => {\n                 ExprKind::Match(folder.fold_expr(expr),\n@@ -1278,15 +1285,13 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 });\n                 ExprKind::Path(qself, folder.fold_path(path))\n             }\n-            ExprKind::Break(opt_ident, opt_expr) => {\n-                ExprKind::Break(opt_ident.map(|label| respan(folder.new_span(label.span),\n-                                                             folder.fold_ident(label.node))),\n+            ExprKind::Break(opt_label, opt_expr) => {\n+                ExprKind::Break(opt_label.map(|label| folder.fold_label(label)),\n                                 opt_expr.map(|e| folder.fold_expr(e)))\n             }\n-            ExprKind::Continue(opt_ident) => ExprKind::Continue(opt_ident.map(|label|\n-                respan(folder.new_span(label.span),\n-                       folder.fold_ident(label.node)))\n-            ),\n+            ExprKind::Continue(opt_label) => {\n+                ExprKind::Continue(opt_label.map(|label| folder.fold_label(label)))\n+            }\n             ExprKind::Ret(e) => ExprKind::Ret(e.map(|x| folder.fold_expr(x))),\n             ExprKind::InlineAsm(asm) => ExprKind::InlineAsm(asm.map(|asm| {\n                 InlineAsm {"}, {"sha": "d393cab471850a5af744a53f39f23ccee8a83bbb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 41, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -23,7 +23,7 @@ use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n use ast::GenericParam;\n use ast::{Ident, ImplItem, IsAuto, Item, ItemKind};\n-use ast::{Lifetime, LifetimeDef, Lit, LitKind, UintTy};\n+use ast::{Label, Lifetime, LifetimeDef, Lit, LitKind, UintTy};\n use ast::Local;\n use ast::MacStmtStyle;\n use ast::Mac_;\n@@ -1325,15 +1325,17 @@ impl<'a> Parser<'a> {\n             self.check_keyword(keywords::Extern)\n     }\n \n-    fn get_label(&mut self) -> ast::Ident {\n-        match self.token {\n+    fn eat_label(&mut self) -> Option<Label> {\n+        let ident = match self.token {\n             token::Lifetime(ref ident) => *ident,\n             token::Interpolated(ref nt) => match nt.0 {\n                 token::NtLifetime(lifetime) => lifetime.ident,\n-                _ => self.bug(\"not a lifetime\"),\n+                _ => return None,\n             },\n-            _ => self.bug(\"not a lifetime\"),\n-        }\n+            _ => return None,\n+        };\n+        self.bump();\n+        Some(Label { ident, span: self.prev_span })\n     }\n \n     /// parse a TyKind::BareFn type:\n@@ -2317,11 +2319,8 @@ impl<'a> Parser<'a> {\n                     let lo = self.prev_span;\n                     return self.parse_while_expr(None, lo, attrs);\n                 }\n-                if self.token.is_lifetime() {\n-                    let label = Spanned { node: self.get_label(),\n-                                          span: self.span };\n-                    let lo = self.span;\n-                    self.bump();\n+                if let Some(label) = self.eat_label() {\n+                    let lo = label.span;\n                     self.expect(&token::Colon)?;\n                     if self.eat_keyword(keywords::While) {\n                         return self.parse_while_expr(Some(label), lo, attrs)\n@@ -2339,16 +2338,8 @@ impl<'a> Parser<'a> {\n                     return self.parse_loop_expr(None, lo, attrs);\n                 }\n                 if self.eat_keyword(keywords::Continue) {\n-                    let ex = if self.token.is_lifetime() {\n-                        let ex = ExprKind::Continue(Some(Spanned{\n-                            node: self.get_label(),\n-                            span: self.span\n-                        }));\n-                        self.bump();\n-                        ex\n-                    } else {\n-                        ExprKind::Continue(None)\n-                    };\n+                    let label = self.eat_label();\n+                    let ex = ExprKind::Continue(label);\n                     let hi = self.prev_span;\n                     return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n                 }\n@@ -2376,16 +2367,7 @@ impl<'a> Parser<'a> {\n                         ex = ExprKind::Ret(None);\n                     }\n                 } else if self.eat_keyword(keywords::Break) {\n-                    let lt = if self.token.is_lifetime() {\n-                        let spanned_lt = Spanned {\n-                            node: self.get_label(),\n-                            span: self.span\n-                        };\n-                        self.bump();\n-                        Some(spanned_lt)\n-                    } else {\n-                        None\n-                    };\n+                    let label = self.eat_label();\n                     let e = if self.token.can_begin_expr()\n                                && !(self.token == token::OpenDelim(token::Brace)\n                                     && self.restrictions.contains(\n@@ -2394,7 +2376,7 @@ impl<'a> Parser<'a> {\n                     } else {\n                         None\n                     };\n-                    ex = ExprKind::Break(lt, e);\n+                    ex = ExprKind::Break(label, e);\n                     hi = self.prev_span;\n                 } else if self.eat_keyword(keywords::Yield) {\n                     if self.token.can_begin_expr() {\n@@ -3291,7 +3273,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n-    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n+    pub fn parse_for_expr(&mut self, opt_label: Option<Label>,\n                           span_lo: Span,\n                           mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n@@ -3309,25 +3291,25 @@ impl<'a> Parser<'a> {\n         attrs.extend(iattrs);\n \n         let hi = self.prev_span;\n-        Ok(self.mk_expr(span_lo.to(hi), ExprKind::ForLoop(pat, expr, loop_block, opt_ident), attrs))\n+        Ok(self.mk_expr(span_lo.to(hi), ExprKind::ForLoop(pat, expr, loop_block, opt_label), attrs))\n     }\n \n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n-    pub fn parse_while_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n+    pub fn parse_while_expr(&mut self, opt_label: Option<Label>,\n                             span_lo: Span,\n                             mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n-            return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n+            return self.parse_while_let_expr(opt_label, span_lo, attrs);\n         }\n         let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n-        return Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_ident), attrs));\n+        return Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_label), attrs));\n     }\n \n     /// Parse a 'while let' expression ('while' token already eaten)\n-    pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n+    pub fn parse_while_let_expr(&mut self, opt_label: Option<Label>,\n                                 span_lo: Span,\n                                 mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         self.expect_keyword(keywords::Let)?;\n@@ -3337,17 +3319,17 @@ impl<'a> Parser<'a> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n-        return Ok(self.mk_expr(span, ExprKind::WhileLet(pat, expr, body, opt_ident), attrs));\n+        return Ok(self.mk_expr(span, ExprKind::WhileLet(pat, expr, body, opt_label), attrs));\n     }\n \n     // parse `loop {...}`, `loop` token already eaten\n-    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n+    pub fn parse_loop_expr(&mut self, opt_label: Option<Label>,\n                            span_lo: Span,\n                            mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n-        Ok(self.mk_expr(span, ExprKind::Loop(body, opt_ident), attrs))\n+        Ok(self.mk_expr(span, ExprKind::Loop(body, opt_label), attrs))\n     }\n \n     /// Parse a `do catch {...}` expression (`do catch` token already eaten)"}, {"sha": "ae459c668aae403c3b6ddc09ac65c4e0526bd7f6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -2104,19 +2104,19 @@ impl<'a> State<'a> {\n             ast::ExprKind::IfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n                 self.print_if_let(pat, expr, blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n-            ast::ExprKind::While(ref test, ref blk, opt_ident) => {\n-                if let Some(ident) = opt_ident {\n-                    self.print_ident(ident.node)?;\n+            ast::ExprKind::While(ref test, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n                 self.print_expr_as_cond(test)?;\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n-            ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n-                if let Some(ident) = opt_ident {\n-                    self.print_ident(ident.node)?;\n+            ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while let\")?;\n@@ -2127,9 +2127,9 @@ impl<'a> State<'a> {\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n-            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n-                if let Some(ident) = opt_ident {\n-                    self.print_ident(ident.node)?;\n+            ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"for\")?;\n@@ -2140,9 +2140,9 @@ impl<'a> State<'a> {\n                 self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n-            ast::ExprKind::Loop(ref blk, opt_ident) => {\n-                if let Some(ident) = opt_ident {\n-                    self.print_ident(ident.node)?;\n+            ast::ExprKind::Loop(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;\n@@ -2238,23 +2238,23 @@ impl<'a> State<'a> {\n             ast::ExprKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, true)?\n             }\n-            ast::ExprKind::Break(opt_ident, ref opt_expr) => {\n+            ast::ExprKind::Break(opt_label, ref opt_expr) => {\n                 self.s.word(\"break\")?;\n                 self.s.space()?;\n-                if let Some(ident) = opt_ident {\n-                    self.print_ident(ident.node)?;\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n                     self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                     self.s.space()?;\n                 }\n             }\n-            ast::ExprKind::Continue(opt_ident) => {\n+            ast::ExprKind::Continue(opt_label) => {\n                 self.s.word(\"continue\")?;\n                 self.s.space()?;\n-                if let Some(ident) = opt_ident {\n-                    self.print_ident(ident.node)?;\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n                     self.s.space()?\n                 }\n             }"}, {"sha": "bbb123dab286844ec4e8ce5b0dcaa837aeba7d81", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98b375483c44c68009d699a4cd4b7b0a3d5d97a3/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=98b375483c44c68009d699a4cd4b7b0a3d5d97a3", "patch": "@@ -101,6 +101,9 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_variant(&mut self, v: &'ast Variant, g: &'ast Generics, item_id: NodeId) {\n         walk_variant(self, v, g, item_id)\n     }\n+    fn visit_label(&mut self, label: &'ast Label) {\n+        walk_label(self, label)\n+    }\n     fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n@@ -163,25 +166,6 @@ macro_rules! walk_list {\n     }\n }\n \n-pub fn walk_opt_name<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n-    if let Some(name) = opt_name {\n-        visitor.visit_name(span, name);\n-    }\n-}\n-\n-pub fn walk_opt_ident<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n-    if let Some(ident) = opt_ident {\n-        visitor.visit_ident(span, ident);\n-    }\n-}\n-\n-pub fn walk_opt_sp_ident<'a, V: Visitor<'a>>(visitor: &mut V,\n-                                             opt_sp_ident: &Option<Spanned<Ident>>) {\n-    if let Some(ref sp_ident) = *opt_sp_ident {\n-        visitor.visit_ident(sp_ident.span, sp_ident.node);\n-    }\n-}\n-\n pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, ident: Ident) {\n     visitor.visit_name(span, ident.name);\n }\n@@ -204,6 +188,10 @@ pub fn walk_local<'a, V: Visitor<'a>>(visitor: &mut V, local: &'a Local) {\n     walk_list!(visitor, visit_expr, &local.init);\n }\n \n+pub fn walk_label<'a, V: Visitor<'a>>(visitor: &mut V, label: &'a Label) {\n+    visitor.visit_ident(label.span, label.ident);\n+}\n+\n pub fn walk_lifetime<'a, V: Visitor<'a>>(visitor: &mut V, lifetime: &'a Lifetime) {\n     visitor.visit_ident(lifetime.span, lifetime.ident);\n }\n@@ -226,7 +214,9 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     visitor.visit_ident(item.span, item.ident);\n     match item.node {\n         ItemKind::ExternCrate(opt_name) => {\n-            walk_opt_name(visitor, item.span, opt_name)\n+            if let Some(name) = opt_name {\n+                visitor.visit_name(item.span, name);\n+            }\n         }\n         ItemKind::Use(ref use_tree) => {\n             visitor.visit_use_tree(use_tree, item.id, false)\n@@ -622,7 +612,9 @@ pub fn walk_struct_def<'a, V: Visitor<'a>>(visitor: &mut V, struct_definition: &\n \n pub fn walk_struct_field<'a, V: Visitor<'a>>(visitor: &mut V, struct_field: &'a StructField) {\n     visitor.visit_vis(&struct_field.vis);\n-    walk_opt_ident(visitor, struct_field.span, struct_field.ident);\n+    if let Some(ident) = struct_field.ident {\n+        visitor.visit_ident(struct_field.span, ident);\n+    }\n     visitor.visit_ty(&struct_field.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.attrs);\n }\n@@ -708,32 +700,32 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::While(ref subexpression, ref block, ref opt_sp_ident) => {\n+        ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::WhileLet(ref pattern, ref subexpression, ref block, ref opt_sp_ident) => {\n+        ExprKind::WhileLet(ref pattern, ref subexpression, ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n-        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, ref opt_sp_ident) => {\n+        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n-        ExprKind::Loop(ref block, ref opt_sp_ident) => {\n+        ExprKind::Loop(ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n-            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::Match(ref subexpression, ref arms) => {\n             visitor.visit_expr(subexpression);\n@@ -775,12 +767,12 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprKind::Break(ref opt_sp_ident, ref opt_expr) => {\n-            walk_opt_sp_ident(visitor, opt_sp_ident);\n+        ExprKind::Break(ref opt_label, ref opt_expr) => {\n+            walk_list!(visitor, visit_label, opt_label);\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprKind::Continue(ref opt_sp_ident) => {\n-            walk_opt_sp_ident(visitor, opt_sp_ident);\n+        ExprKind::Continue(ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n         }\n         ExprKind::Ret(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}]}