{"sha": "8ea72fae99b55d7e35773185787805592977c484", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYTcyZmFlOTliNTVkN2UzNTc3MzE4NTc4NzgwNTU5Mjk3N2M0ODQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-27T06:03:06Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-27T15:30:45Z"}, "message": "Move more non-value-returning things to trans_expr_dps.\n\nIssue #667", "tree": {"sha": "efb5777b1110cc1098bbf47534765f28ad56fcf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efb5777b1110cc1098bbf47534765f28ad56fcf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ea72fae99b55d7e35773185787805592977c484", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ea72fae99b55d7e35773185787805592977c484", "html_url": "https://github.com/rust-lang/rust/commit/8ea72fae99b55d7e35773185787805592977c484", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ea72fae99b55d7e35773185787805592977c484/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b49f4689f54f8ab6b3d7350d4902236a78e5852f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b49f4689f54f8ab6b3d7350d4902236a78e5852f", "html_url": "https://github.com/rust-lang/rust/commit/b49f4689f54f8ab6b3d7350d4902236a78e5852f"}], "stats": {"total": 177, "additions": 90, "deletions": 87}, "files": [{"sha": "1e9910762a1914a2527f14b48e449406e89f399b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 88, "deletions": 85, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/8ea72fae99b55d7e35773185787805592977c484/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea72fae99b55d7e35773185787805592977c484/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8ea72fae99b55d7e35773185787805592977c484", "patch": "@@ -2298,6 +2298,43 @@ fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n     }\n }\n \n+fn trans_assign_op(bcx: @block_ctxt, op: ast::binop, dst: @ast::expr,\n+                   src: @ast::expr) -> @block_ctxt {\n+    let tcx = bcx_tcx(bcx);\n+    let t = ty::expr_ty(tcx, src);\n+    let lhs_res = trans_lval(bcx, dst);\n+    assert (lhs_res.is_mem);\n+    // Special case for `+= [x]`\n+    alt ty::struct(tcx, t) {\n+      ty::ty_vec(_) {\n+        alt src.node {\n+          ast::expr_vec(args, _) {\n+            ret tvec::trans_append_literal(lhs_res.bcx,\n+                                           lhs_res.val, t, args);\n+          }\n+          _ { }\n+        }\n+      }\n+      _ { }\n+    }\n+    let rhs_res = trans_expr(lhs_res.bcx, src);\n+    if ty::type_is_sequence(tcx, t) {\n+        alt op {\n+          ast::add. {\n+            ret tvec::trans_append(rhs_res.bcx, t, lhs_res.val,\n+                                   rhs_res.val);\n+          }\n+          _ { }\n+        }\n+    }\n+    let lhs_val = load_if_immediate(rhs_res.bcx, lhs_res.val, t);\n+    let v = trans_eager_binop(rhs_res.bcx, op, lhs_val, t, rhs_res.val, t);\n+    // FIXME: calculate copy init-ness in typestate.\n+    // This is always a temporary, so can always be safely moved\n+    ret move_val(v.bcx, DROP_EXISTING, lhs_res.val,\n+                 lval_val(v.bcx, v.val), t);\n+}\n+\n fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n     let v1: ValueRef = v;\n     let t1: ty::t = t;\n@@ -2540,7 +2577,7 @@ fn trans_if(cx: @block_ctxt, cond: @ast::expr, thn: ast::blk,\n }\n \n fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n-             body: ast::blk) -> result {\n+             body: ast::blk) -> @block_ctxt {\n     fn inner(bcx: @block_ctxt, local: @ast::local, curr: ValueRef, t: ty::t,\n              body: ast::blk, outer_next_cx: @block_ctxt) -> @block_ctxt {\n         let next_cx = new_sub_block_ctxt(bcx, \"next\");\n@@ -2567,7 +2604,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n         tvec::iter_vec_raw(bcx, seq, seq_ty, fill,\n                            bind inner(_, local, _, _, body, next_cx));\n     Br(bcx, next_cx.llbb);\n-    ret rslt(next_cx, C_nil());\n+    ret next_cx;\n }\n \n \n@@ -2789,7 +2826,7 @@ fn load_environment(enclosing_cx: @block_ctxt, fcx: @fn_ctxt, envty: ty::t,\n }\n \n fn trans_for_each(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n-                  body: ast::blk) -> result {\n+                  body: ast::blk) -> @block_ctxt {\n     /*\n      * The translation is a little .. complex here. Code like:\n      *\n@@ -2865,12 +2902,13 @@ fn trans_for_each(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n         let pair =\n             create_real_fn_pair(cx, iter_body_llty, lliterbody, llenv.ptr);\n         let r = trans_call(cx, f, some(pair), args, seq.id);\n-        ret rslt(r.res.bcx, C_nil());\n+        ret r.res.bcx;\n       }\n     }\n }\n \n-fn trans_while(cx: @block_ctxt, cond: @ast::expr, body: ast::blk) -> result {\n+fn trans_while(cx: @block_ctxt, cond: @ast::expr, body: ast::blk)\n+    -> @block_ctxt {\n     let next_cx = new_sub_block_ctxt(cx, \"while next\");\n     let cond_cx =\n         new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n@@ -2882,11 +2920,11 @@ fn trans_while(cx: @block_ctxt, cond: @ast::expr, body: ast::blk) -> result {\n     let cond_bcx = trans_block_cleanups(cond_res.bcx, cond_cx);\n     CondBr(cond_bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n     Br(cx, cond_cx.llbb);\n-    ret rslt(next_cx, C_nil());\n+    ret next_cx;\n }\n \n fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n-   result {\n+    @block_ctxt {\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let body_cx =\n         new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n@@ -2895,7 +2933,7 @@ fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n     let cond_res = trans_expr(body_res.bcx, cond);\n     CondBr(cond_res.bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n     Br(cx, body_cx.llbb);\n-    ret rslt(next_cx, body_res.val);\n+    ret next_cx;\n }\n \n type generic_info =\n@@ -4093,12 +4131,6 @@ fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n     alt e.node {\n       ast::expr_lit(lit) { ret trans_lit(cx, *lit); }\n       ast::expr_binary(op, x, y) { ret trans_binary(cx, op, x, y); }\n-      ast::expr_for(decl, seq, body) { ret trans_for(cx, decl, seq, body); }\n-      ast::expr_for_each(decl, seq, body) {\n-        ret trans_for_each(cx, decl, seq, body);\n-      }\n-      ast::expr_while(cond, body) { ret trans_while(cx, cond, body); }\n-      ast::expr_do_while(body, cond) { ret trans_do_while(cx, body, cond); }\n       ast::expr_fn(f) {\n         let ccx = bcx_ccx(cx);\n         let fty = node_id_type(ccx, e.id);\n@@ -4152,77 +4184,6 @@ fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n                      t);\n         ret rslt(bcx, C_nil());\n       }\n-      ast::expr_assign(dst, src) {\n-        let lhs_res = trans_lval(cx, dst);\n-        assert (lhs_res.is_mem);\n-        // FIXME Fill in lhs_res.bcx.sp\n-        let rhs = trans_lval(lhs_res.bcx, src);\n-        let t = ty::expr_ty(bcx_tcx(cx), src);\n-        // FIXME: calculate copy init-ness in typestate.\n-        let bcx =\n-            move_val_if_temp(rhs.bcx, DROP_EXISTING, lhs_res.val, rhs,\n-                             t);\n-        ret rslt(bcx, C_nil());\n-      }\n-      ast::expr_swap(dst, src) {\n-        let lhs_res = trans_lval(cx, dst);\n-        assert (lhs_res.is_mem);\n-        // FIXME Fill in lhs_res.bcx.sp\n-\n-        let rhs_res = trans_lval(lhs_res.bcx, src);\n-        let t = ty::expr_ty(bcx_tcx(cx), src);\n-        let {bcx: bcx, val: tmp_alloc} = alloc_ty(rhs_res.bcx, t);\n-        // Swap through a temporary.\n-\n-        bcx = move_val(bcx, INIT, tmp_alloc, lhs_res, t);\n-        bcx = move_val(bcx, INIT, lhs_res.val, rhs_res, t);\n-        bcx =\n-            move_val(bcx, INIT, rhs_res.val, lval_mem(bcx, tmp_alloc), t);\n-        ret rslt(bcx, C_nil());\n-      }\n-      ast::expr_assign_op(op, dst, src) {\n-        let tcx = bcx_tcx(cx);\n-        let t = ty::expr_ty(tcx, src);\n-        let lhs_res = trans_lval(cx, dst);\n-        assert (lhs_res.is_mem);\n-\n-        // Special case for `+= [x]`\n-        alt ty::struct(tcx, t) {\n-          ty::ty_vec(_) {\n-            alt src.node {\n-              ast::expr_vec(args, _) {\n-                let bcx =\n-                    tvec::trans_append_literal(lhs_res.bcx,\n-                                               lhs_res.val, t, args);\n-                ret rslt(bcx, C_nil());\n-              }\n-              _ { }\n-            }\n-          }\n-          _ { }\n-        }\n-\n-        // FIXME Fill in lhs_res.bcx.sp\n-        let rhs_res = trans_expr(lhs_res.bcx, src);\n-        if ty::type_is_sequence(tcx, t) {\n-            alt op {\n-              ast::add. {\n-                ret tvec::trans_append(rhs_res.bcx, t, lhs_res.val,\n-                                       rhs_res.val);\n-              }\n-              _ { }\n-            }\n-        }\n-        let lhs_val = load_if_immediate(rhs_res.bcx, lhs_res.val, t);\n-        let v =\n-            trans_eager_binop(rhs_res.bcx, op, lhs_val, t, rhs_res.val, t);\n-        // FIXME: calculate copy init-ness in typestate.\n-        // This is always a temporary, so can always be safely moved\n-        let bcx =\n-            move_val(v.bcx, DROP_EXISTING, lhs_res.val,\n-                     lval_val(v.bcx, v.val), t);\n-        ret rslt(bcx, C_nil());\n-      }\n       ast::expr_bind(f, args) { ret trans_bind(cx, f, args, e.id); }\n       ast::expr_cast(val, _) { ret trans_cast(cx, val, e.id); }\n       ast::expr_vec(args, _) { ret tvec::trans_vec(cx, args, e.id); }\n@@ -4360,6 +4321,48 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n         ret join_branches(bcx, [rslt(check_cx, C_nil()),\n                                 rslt(else_cx, C_nil())]);\n       }\n+      ast::expr_for(decl, seq, body) {\n+        assert dest == ignore;\n+        ret trans_for(bcx, decl, seq, body);\n+      }\n+      ast::expr_for_each(decl, seq, body) {\n+        assert dest == ignore;\n+        ret trans_for_each(bcx, decl, seq, body);\n+      }\n+      ast::expr_while(cond, body) {\n+        assert dest == ignore;\n+        ret trans_while(bcx, cond, body);\n+      }\n+      ast::expr_do_while(body, cond) {\n+        assert dest == ignore;\n+        ret trans_do_while(bcx, body, cond);\n+      }\n+      ast::expr_assign(dst, src) {\n+        assert dest == ignore;\n+        let lhs_res = trans_lval(bcx, dst);\n+        assert (lhs_res.is_mem);\n+        let rhs = trans_lval(lhs_res.bcx, src);\n+        let t = ty::expr_ty(bcx_tcx(bcx), src);\n+        // FIXME: calculate copy init-ness in typestate.\n+        ret move_val_if_temp(rhs.bcx, DROP_EXISTING, lhs_res.val,\n+                             rhs, t);\n+      }\n+      ast::expr_swap(dst, src) {\n+        assert dest == ignore;\n+        let lhs_res = trans_lval(bcx, dst);\n+        assert (lhs_res.is_mem);\n+        let rhs_res = trans_lval(lhs_res.bcx, src);\n+        let t = ty::expr_ty(bcx_tcx(bcx), src);\n+        let {bcx: bcx, val: tmp_alloc} = alloc_ty(rhs_res.bcx, t);\n+        // Swap through a temporary.\n+        bcx = move_val(bcx, INIT, tmp_alloc, lhs_res, t);\n+        bcx = move_val(bcx, INIT, lhs_res.val, rhs_res, t);\n+        ret move_val(bcx, INIT, rhs_res.val, lval_mem(bcx, tmp_alloc), t);\n+      }\n+      ast::expr_assign_op(op, dst, src) {\n+        assert dest == ignore;\n+        ret trans_assign_op(bcx, op, dst, src);\n+      }\n \n       ast::expr_mac(_) { ret bcx_ccx(bcx).sess.bug(\"unexpanded macro\"); }\n       // Convert back from result to DPS"}, {"sha": "e47e841bd033310e4c8dbda94e04a4b50b6112da", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ea72fae99b55d7e35773185787805592977c484/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea72fae99b55d7e35773185787805592977c484/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=8ea72fae99b55d7e35773185787805592977c484", "patch": "@@ -141,7 +141,7 @@ fn trans_str(bcx: @block_ctxt, s: str) -> result {\n }\n \n fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n-                rhsptr: ValueRef) -> result {\n+                rhsptr: ValueRef) -> @block_ctxt {\n     // Cast to opaque interior vector types if necessary.\n     let unit_ty = ty::sequence_element_type(bcx_tcx(cx), vec_ty);\n     let dynamic = ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty);\n@@ -190,7 +190,7 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n                                write_ptr_ptr);\n                          ret bcx;\n                      });\n-    ret rslt(bcx, C_nil());\n+    ret bcx;\n }\n \n fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,"}]}