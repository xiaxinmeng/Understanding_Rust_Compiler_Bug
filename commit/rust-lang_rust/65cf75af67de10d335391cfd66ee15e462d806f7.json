{"sha": "65cf75af67de10d335391cfd66ee15e462d806f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1Y2Y3NWFmNjdkZTEwZDMzNTM5MWNmZDY2ZWUxNWU0NjJkODA2Zjc=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-13T21:31:13Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-15T19:57:31Z"}, "message": "Fix select deschedule environment race for real this time, in light of task killing.", "tree": {"sha": "badb39e50709a4e9a296e33bf570747d9ddecfb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/badb39e50709a4e9a296e33bf570747d9ddecfb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65cf75af67de10d335391cfd66ee15e462d806f7", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65cf75af67de10d335391cfd66ee15e462d806f7", "html_url": "https://github.com/rust-lang/rust/commit/65cf75af67de10d335391cfd66ee15e462d806f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65cf75af67de10d335391cfd66ee15e462d806f7/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d817ee869387322dec4d3f7d407dcc9f91c2632", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d817ee869387322dec4d3f7d407dcc9f91c2632", "html_url": "https://github.com/rust-lang/rust/commit/0d817ee869387322dec4d3f7d407dcc9f91c2632"}], "stats": {"total": 41, "additions": 23, "deletions": 18}, "files": [{"sha": "8209ce420031239ecca031241e20bd02ed866b7d", "filename": "src/libstd/select.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/65cf75af67de10d335391cfd66ee15e462d806f7/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65cf75af67de10d335391cfd66ee15e462d806f7/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=65cf75af67de10d335391cfd66ee15e462d806f7", "patch": "@@ -20,6 +20,7 @@ use rt::select::{SelectInner, SelectPortInner};\n use rt::local::Local;\n use rt::rtio::EventLoop;\n use task;\n+use unstable::finally::Finally;\n use vec::{OwnedVector, MutableVector};\n \n /// Trait for message-passing primitives that can be select()ed on.\n@@ -57,28 +58,32 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     let p = Cell::new(p);\n     let c = Cell::new(c);\n \n-    let sched = Local::take::<Scheduler>();\n-    do sched.deschedule_running_task_and_then |sched, task| {\n-        let task_handles = task.make_selectable(ports.len());\n-\n-        for (index, (port, task_handle)) in\n-                ports.mut_iter().zip(task_handles.move_iter()).enumerate() {\n-            // If one of the ports has data by now, it will wake the handle.\n-            if port.block_on(sched, task_handle) {\n-                ready_index = index;\n-                break;\n+    do (|| {\n+        let c = Cell::new(c.take());\n+        let sched = Local::take::<Scheduler>();\n+        do sched.deschedule_running_task_and_then |sched, task| {\n+            let task_handles = task.make_selectable(ports.len());\n+\n+            for (index, (port, task_handle)) in\n+                    ports.mut_iter().zip(task_handles.move_iter()).enumerate() {\n+                // If one of the ports has data by now, it will wake the handle.\n+                if port.block_on(sched, task_handle) {\n+                    ready_index = index;\n+                    break;\n+                }\n             }\n-        }\n \n-        let c = Cell::new(c.take());\n-        do sched.event_loop.callback { c.take().send_deferred(()) }\n+            let c = Cell::new(c.take());\n+            do sched.event_loop.callback { c.take().send_deferred(()) }\n+        }\n+    }).finally {\n+        let p = Cell::new(p.take());\n+        // Unkillable is necessary not because getting killed is dangerous here,\n+        // but to force the recv not to use the same kill-flag that we used for\n+        // selecting. Otherwise a user-sender could spuriously wakeup us here.\n+        do task::unkillable { p.take().recv(); }\n     }\n \n-    // Unkillable is necessary not because getting killed is dangerous here,\n-    // but to force the recv not to use the same kill-flag that we used for\n-    // selecting. Otherwise a user-sender could spuriously wakeup us here.\n-    do task::unkillable { p.take().recv(); }\n-\n     // Task resumes. Now unblock ourselves from all the ports we blocked on.\n     // If the success index wasn't reset, 'take' will just take all of them.\n     // Iterate in reverse so the 'earliest' index that's ready gets returned."}]}