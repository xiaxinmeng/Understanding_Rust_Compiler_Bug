{"sha": "be489ee9e2f30d2daf1c9726536631162e21dff5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNDg5ZWU5ZTJmMzBkMmRhZjFjOTcyNjUzNjYzMTE2MmUyMWRmZjU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-12T17:59:18Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-14T19:00:48Z"}, "message": "rustc: Move much of metadata reading over to interior vectors", "tree": {"sha": "532d570a7b7971a4be83eeeb969bff9b12ecfb87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/532d570a7b7971a4be83eeeb969bff9b12ecfb87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be489ee9e2f30d2daf1c9726536631162e21dff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be489ee9e2f30d2daf1c9726536631162e21dff5", "html_url": "https://github.com/rust-lang/rust/commit/be489ee9e2f30d2daf1c9726536631162e21dff5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be489ee9e2f30d2daf1c9726536631162e21dff5/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4664b67ea2d0240cf121851d6c47e72bc26222b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4664b67ea2d0240cf121851d6c47e72bc26222b8", "html_url": "https://github.com/rust-lang/rust/commit/4664b67ea2d0240cf121851d6c47e72bc26222b8"}], "stats": {"total": 673, "additions": 337, "deletions": 336}, "files": [{"sha": "abf7e99a57dee66f854b54bc97f89cbdd212ffb4", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -27,7 +27,7 @@ import std::option::none;\n import std::str;\n import std::vec;\n import std::int;\n-import std::io;\n+import std::ioivec;\n import std::run;\n import std::getopts;\n import std::getopts::optopt;\n@@ -209,19 +209,19 @@ fn pretty_print_input(session::session sess, ast::crate_cfg cfg,\n             ann = pprust::no_ann();\n         }\n     }\n-    pprust::print_crate(sess.get_codemap(), crate, input,\n-                        std::io::stdout(), ann);\n+    pprust::print_crate(sess.get_codemap(), crate, input, ioivec::stdout(),\n+                        ann);\n }\n \n fn version(str argv0) {\n     auto vers = \"unknown version\";\n     auto env_vers = #env(\"CFG_VERSION\");\n     if (str::byte_len(env_vers) != 0u) { vers = env_vers; }\n-    io::stdout().write_str(#fmt(\"%s %s\\n\", argv0, vers));\n+    ioivec::stdout().write_str(#fmt(\"%s %s\\n\", argv0, vers));\n }\n \n fn usage(str argv0) {\n-    io::stdout().write_str(#fmt(\"usage: %s [options] <input>\\n\", argv0) +\n+    ioivec::stdout().write_str(#fmt(\"usage: %s [options] <input>\\n\", argv0) +\n                                \"\n options:\n \n@@ -450,7 +450,7 @@ fn main(vec[str] args) {\n         case (none[pp_mode]) {/* continue */ }\n     }\n     if (ls) {\n-        metadata::creader::list_file_metadata(ifile, std::io::stdout());\n+        metadata::creader::list_file_metadata(ifile, ioivec::stdout());\n         ret;\n     }\n "}, {"sha": "1689d35c4ade219cec3bd854068211047edd3a5f", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -5,7 +5,6 @@ import syntax::codemap;\n import codemap::span;\n import syntax::ast::ty_mach;\n import std::uint;\n-import std::io;\n import std::map;\n import std::option;\n import std::option::some;"}, {"sha": "9e5ae8ff27b9dfeb265449345bf28151ba1e3a41", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -15,9 +15,8 @@ import util::common;\n import std::ivec;\n import std::str;\n import std::vec;\n-import std::ebml;\n import std::fs;\n-import std::io;\n+import std::ioivec;\n import std::option;\n import std::option::none;\n import std::option::some;\n@@ -88,7 +87,7 @@ fn visit_item(env e, &@ast::item i) {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-fn list_file_metadata(str path, io::writer out) {\n+fn list_file_metadata(str path, ioivec::writer out) {\n     alt (get_metadata_section(path)) {\n         case (option::some(?bytes)) {\n             decoder::list_crate_metadata(bytes, out);\n@@ -99,8 +98,7 @@ fn list_file_metadata(str path, io::writer out) {\n     }\n }\n \n-fn metadata_matches(&vec[u8] crate_data,\n-                    &(@ast::meta_item)[] metas) -> bool {\n+fn metadata_matches(&@u8[] crate_data, &(@ast::meta_item)[] metas) -> bool {\n     auto attrs = decoder::get_crate_attributes(crate_data);\n     auto linkage_metas = attr::find_linkage_metas(attrs);\n \n@@ -130,8 +128,8 @@ fn default_native_lib_naming(session::session sess, bool static) ->\n \n fn find_library_crate(&session::session sess, &ast::ident ident,\n                       &(@ast::meta_item)[] metas,\n-                      &vec[str] library_search_paths) ->\n-   option::t[tup(str, vec[u8])] {\n+                      &vec[str] library_search_paths)\n+        -> option::t[tup(str, @u8[])] {\n \n     attr::require_unique_names(sess, metas);\n \n@@ -165,7 +163,7 @@ fn find_library_crate(&session::session sess, &ast::ident ident,\n fn find_library_crate_aux(&rec(str prefix, str suffix) nn, str crate_name,\n                           &(@ast::meta_item)[] metas,\n                           &vec[str] library_search_paths) ->\n-                          option::t[tup(str, vec[u8])] {\n+                          option::t[tup(str, @u8[])] {\n     let str prefix = nn.prefix + crate_name;\n     // FIXME: we could probably use a 'glob' function in std::fs but it will\n     // be much easier to write once the unsafe module knows more about FFI\n@@ -200,10 +198,10 @@ fn find_library_crate_aux(&rec(str prefix, str suffix) nn, str crate_name,\n     ret none;\n }\n \n-fn get_metadata_section(str filename) -> option::t[vec[u8]] {\n+fn get_metadata_section(str filename) -> option::t[@u8[]] {\n     auto b = str::buf(filename);\n     auto mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(b);\n-    if (mb as int == 0) { ret option::none[vec[u8]]; }\n+    if (mb as int == 0) { ret option::none[@u8[]]; }\n     auto of = mk_object_file(mb);\n     auto si = mk_section_iter(of.llof);\n     while (llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False) {\n@@ -212,18 +210,17 @@ fn get_metadata_section(str filename) -> option::t[vec[u8]] {\n         if (str::eq(name, x86::get_meta_sect_name())) {\n             auto cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             auto csz = llvm::LLVMGetSectionSize(si.llsi);\n-            auto cvbuf = cbuf as vec::vbuf;\n-            ret option::some[vec[u8]](vec::vec_from_vbuf[u8](cvbuf, csz));\n+            let *u8 cvbuf = std::unsafe::reinterpret_cast(cbuf);\n+            ret option::some[@u8[]](@ivec::unsafe::from_buf(cvbuf, csz));\n         }\n         llvm::LLVMMoveToNextSection(si.llsi);\n     }\n-    ret option::none[vec[u8]];\n+    ret option::none[@u8[]];\n }\n \n fn load_library_crate(&session::session sess, span span,\n                       &ast::ident ident, &(@ast::meta_item)[] metas,\n-                      &vec[str] library_search_paths)\n-    -> tup(str, vec[u8]) {\n+                      &vec[str] library_search_paths) -> tup(str, @u8[]) {\n \n     alt (find_library_crate(sess, ident, metas, library_search_paths)) {\n         case (some(?t)) {\n@@ -266,7 +263,7 @@ fn resolve_crate(env e, ast::ident ident, (@ast::meta_item)[] metas,\n }\n \n // Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(env e, &vec[u8] cdata) -> cstore::cnum_map {\n+fn resolve_crate_deps(env e, &@u8[] cdata) -> cstore::cnum_map {\n     log \"resolving deps of external crate\";\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers"}, {"sha": "f051f1641302c7df1d0f35df0b16612d9dc23179", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -2,7 +2,6 @@\n \n import syntax::ast;\n import middle::ty;\n-import std::io;\n import std::option;\n import driver::session;\n "}, {"sha": "9c743125a01238612ddb99af11d127d9ec5878d4", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -29,9 +29,7 @@ export get_use_stmt_cnum;\n // own crate numbers.\n type cnum_map = map::hashmap[ast::crate_num, ast::crate_num];\n \n-type crate_metadata = rec(str name,\n-                          vec[u8] data,\n-                          cnum_map cnum_map);\n+type crate_metadata = rec(str name, @u8[] data, cnum_map cnum_map);\n \n // This is a bit of an experiment at encapsulating the data in cstore. By\n // keeping all the data in a non-exported tag variant, it's impossible for"}, {"sha": "0d69c3ca4e30c2483cf68965d9c2972c623cfd2b", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 107, "deletions": 106, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -1,11 +1,11 @@\n // Decoding metadata from a single crate's metadata\n \n-import std::ebml;\n+import std::ebmlivec;\n import std::ivec;\n import std::option;\n import std::vec;\n import std::str;\n-import std::io;\n+import std::ioivec;\n import std::map::hashmap;\n import syntax::ast;\n import front::attr;\n@@ -35,69 +35,69 @@ export external_resolver;\n // build.\n type external_resolver = fn(&ast::def_id def_id) -> ast::def_id;\n \n-fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool  eq_fn, uint hash) ->\n-   vec[ebml::doc] {\n-    auto index = ebml::get_doc(d, tag_index);\n-    auto table = ebml::get_doc(index, tag_index_table);\n+fn lookup_hash(&ebmlivec::doc d, fn(&u8[]) -> bool  eq_fn, uint hash) ->\n+   (ebmlivec::doc)[] {\n+    auto index = ebmlivec::get_doc(d, tag_index);\n+    auto table = ebmlivec::get_doc(index, tag_index_table);\n     auto hash_pos = table.start + hash % 256u * 4u;\n-    auto pos = ebml::be_uint_from_bytes(d.data, hash_pos, 4u);\n-    auto bucket = ebml::doc_at(d.data, pos);\n+    auto pos = ebmlivec::be_uint_from_bytes(d.data, hash_pos, 4u);\n+    auto bucket = ebmlivec::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n \n-    let vec[ebml::doc] result = [];\n+    let (ebmlivec::doc)[] result = ~[];\n     auto belt = tag_index_buckets_bucket_elt;\n-    for each (ebml::doc elt in ebml::tagged_docs(bucket, belt)) {\n-        auto pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n-        if (eq_fn(vec::slice[u8](elt.data, elt.start + 4u, elt.end))) {\n-            vec::push(result, ebml::doc_at(d.data, pos));\n+    for each (ebmlivec::doc elt in ebmlivec::tagged_docs(bucket, belt)) {\n+        auto pos = ebmlivec::be_uint_from_bytes(elt.data, elt.start, 4u);\n+        if (eq_fn(ivec::slice[u8](*elt.data, elt.start + 4u, elt.end))) {\n+            result += ~[ebmlivec::doc_at(d.data, pos)];\n         }\n     }\n     ret result;\n }\n \n-fn maybe_find_item(int item_id, &ebml::doc items) -> option::t[ebml::doc] {\n-    fn eq_item(vec[u8] bytes, int item_id) -> bool {\n-        ret ebml::be_uint_from_bytes(bytes, 0u, 4u) as int == item_id;\n+fn maybe_find_item(int item_id, &ebmlivec::doc items) -> option::t[ebmlivec::doc] {\n+    fn eq_item(&u8[] bytes, int item_id) -> bool {\n+        ret ebmlivec::be_uint_from_bytes(@bytes, 0u, 4u) as int == item_id;\n     }\n     auto eqer = bind eq_item(_, item_id);\n     auto found = lookup_hash(items, eqer, hash_node_id(item_id));\n-    if (vec::len(found) == 0u) {\n-        ret option::none[ebml::doc];\n-    } else { ret option::some[ebml::doc](found.(0)); }\n+    if (ivec::len(found) == 0u) {\n+        ret option::none[ebmlivec::doc];\n+    } else { ret option::some[ebmlivec::doc](found.(0)); }\n }\n \n-fn find_item(int item_id, &ebml::doc items) -> ebml::doc {\n+fn find_item(int item_id, &ebmlivec::doc items) -> ebmlivec::doc {\n     ret option::get(maybe_find_item(item_id, items));\n }\n \n-// Looks up an item in the given metadata and returns an ebml doc pointing\n+// Looks up an item in the given metadata and returns an ebmlivec doc pointing\n // to the item data.\n-fn lookup_item(int item_id, vec[u8] data) -> ebml::doc {\n-    auto items = ebml::get_doc(ebml::new_doc(data), tag_items);\n+fn lookup_item(int item_id, &@u8[] data) -> ebmlivec::doc {\n+    auto items = ebmlivec::get_doc(ebmlivec::new_doc(data), tag_items);\n     ret find_item(item_id, items);\n }\n \n-fn item_kind(&ebml::doc item) -> u8 {\n-    auto kind = ebml::get_doc(item, tag_items_data_item_kind);\n-    ret ebml::doc_as_uint(kind) as u8;\n+fn item_kind(&ebmlivec::doc item) -> u8 {\n+    auto kind = ebmlivec::get_doc(item, tag_items_data_item_kind);\n+    ret ebmlivec::doc_as_uint(kind) as u8;\n }\n \n-fn item_symbol(&ebml::doc item) -> str {\n-    auto sym = ebml::get_doc(item, tag_items_data_item_symbol);\n-    ret str::unsafe_from_bytes(ebml::doc_data(sym));\n+fn item_symbol(&ebmlivec::doc item) -> str {\n+    auto sym = ebmlivec::get_doc(item, tag_items_data_item_symbol);\n+    ret str::unsafe_from_bytes_ivec(ebmlivec::doc_data(sym));\n }\n \n-fn variant_tag_id(&ebml::doc d) -> ast::def_id {\n-    auto tagdoc = ebml::get_doc(d, tag_items_data_item_tag_id);\n-    ret parse_def_id(ebml::doc_data(tagdoc));\n+fn variant_tag_id(&ebmlivec::doc d) -> ast::def_id {\n+    auto tagdoc = ebmlivec::get_doc(d, tag_items_data_item_tag_id);\n+    ret parse_def_id(ebmlivec::doc_data(tagdoc));\n }\n \n-fn item_type(&ebml::doc item, ast::crate_num this_cnum,\n+fn item_type(&ebmlivec::doc item, ast::crate_num this_cnum,\n              ty::ctxt tcx, &external_resolver extres) -> ty::t {\n     fn parse_external_def_id(ast::crate_num this_cnum,\n                              &external_resolver extres,\n                              str s) -> ast::def_id {\n-        auto buf = str::bytes(s);\n+        auto buf = str::bytes_ivec(s);\n         auto external_def_id = parse_def_id(buf);\n \n         // This item was defined in the crate we're searching if it's has the\n@@ -108,60 +108,60 @@ fn item_type(&ebml::doc item, ast::crate_num this_cnum,\n             ret extres(external_def_id);\n         }\n     }\n-    auto tp = ebml::get_doc(item, tag_items_data_item_type);\n+    auto tp = ebmlivec::get_doc(item, tag_items_data_item_type);\n     auto def_parser = bind parse_external_def_id(this_cnum, extres, _);\n     ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n                       def_parser, tcx);\n }\n \n-fn item_ty_param_count(&ebml::doc item) -> uint {\n+fn item_ty_param_count(&ebmlivec::doc item) -> uint {\n     let uint ty_param_count = 0u;\n     auto tp = tag_items_data_item_ty_param_count;\n-    for each (ebml::doc p in ebml::tagged_docs(item, tp)) {\n-        ty_param_count = ebml::vint_at(ebml::doc_data(p), 0u)._0;\n+    for each (ebmlivec::doc p in ebmlivec::tagged_docs(item, tp)) {\n+        ty_param_count = ebmlivec::vint_at(ebmlivec::doc_data(p), 0u)._0;\n     }\n     ret ty_param_count;\n }\n \n-fn tag_variant_ids(&ebml::doc item,\n+fn tag_variant_ids(&ebmlivec::doc item,\n                    ast::crate_num this_cnum) -> vec[ast::def_id] {\n     let vec[ast::def_id] ids = [];\n     auto v = tag_items_data_item_variant;\n-    for each (ebml::doc p in ebml::tagged_docs(item, v)) {\n-        auto ext = parse_def_id(ebml::doc_data(p));\n+    for each (ebmlivec::doc p in ebmlivec::tagged_docs(item, v)) {\n+        auto ext = parse_def_id(ebmlivec::doc_data(p));\n         vec::push[ast::def_id](ids, tup(this_cnum, ext._1));\n     }\n     ret ids;\n }\n \n // Given a path and serialized crate metadata, returns the ID of the\n // definition the path refers to.\n-fn resolve_path(vec[ast::ident] path, vec[u8] data) -> vec[ast::def_id] {\n-    fn eq_item(vec[u8] data, str s) -> bool {\n-        ret str::eq(str::unsafe_from_bytes(data), s);\n+fn resolve_path(vec[ast::ident] path, @u8[] data) -> vec[ast::def_id] {\n+    fn eq_item(&u8[] data, str s) -> bool {\n+        ret str::eq(str::unsafe_from_bytes_ivec(data), s);\n     }\n     auto s = str::connect(path, \"::\");\n-    auto md = ebml::new_doc(data);\n-    auto paths = ebml::get_doc(md, tag_paths);\n+    auto md = ebmlivec::new_doc(data);\n+    auto paths = ebmlivec::get_doc(md, tag_paths);\n     auto eqer = bind eq_item(_, s);\n     let vec[ast::def_id] result = [];\n-    for (ebml::doc doc in lookup_hash(paths, eqer, hash_path(s))) {\n-        auto did_doc = ebml::get_doc(doc, tag_def_id);\n-        vec::push(result, parse_def_id(ebml::doc_data(did_doc)));\n+    for (ebmlivec::doc doc in lookup_hash(paths, eqer, hash_path(s))) {\n+        auto did_doc = ebmlivec::get_doc(doc, tag_def_id);\n+        vec::push(result, parse_def_id(ebmlivec::doc_data(did_doc)));\n     }\n     ret result;\n }\n \n // Crate metadata queries\n-fn lookup_defs(&vec[u8] data, ast::crate_num cnum,\n+fn lookup_defs(&@u8[] data, ast::crate_num cnum,\n                vec[ast::ident] path) -> vec[ast::def] {\n     ret vec::map(bind lookup_def(cnum, data, _), resolve_path(path, data));\n }\n \n \n // FIXME doesn't yet handle re-exported externals\n-fn lookup_def(ast::crate_num cnum, vec[u8] data,\n-              &ast::def_id did_) -> ast::def {\n+fn lookup_def(ast::crate_num cnum, @u8[] data, &ast::def_id did_)\n+        -> ast::def {\n     auto item = lookup_item(did_._1, data);\n     auto kind_ch = item_kind(item);\n     auto did = tup(cnum, did_._1);\n@@ -186,7 +186,7 @@ fn lookup_def(ast::crate_num cnum, vec[u8] data,\n     ret def;\n }\n \n-fn get_type(&vec[u8] data, ast::def_id def, &ty::ctxt tcx,\n+fn get_type(@u8[] data, ast::def_id def, &ty::ctxt tcx,\n             &external_resolver extres) -> ty::ty_param_count_and_ty {\n     auto this_cnum = def._0;\n     auto node_id = def._1;\n@@ -201,21 +201,21 @@ fn get_type(&vec[u8] data, ast::def_id def, &ty::ctxt tcx,\n     ret tup(tp_count, t);\n }\n \n-fn get_type_param_count(&vec[u8] data, ast::node_id id) -> uint {\n+fn get_type_param_count(@u8[] data, ast::node_id id) -> uint {\n     ret item_ty_param_count(lookup_item(id, data));\n }\n \n-fn get_symbol(&vec[u8] data, ast::node_id id) -> str {\n+fn get_symbol(@u8[] data, ast::node_id id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n \n-fn get_tag_variants(&vec[u8] data, ast::def_id def,\n+fn get_tag_variants(&@u8[] data, ast::def_id def,\n                     &ty::ctxt tcx,\n                     &external_resolver extres) -> ty::variant_info[] {\n     auto external_crate_id = def._0;\n     auto data = cstore::get_crate_data(tcx.sess.get_cstore(),\n                                        external_crate_id).data;\n-    auto items = ebml::get_doc(ebml::new_doc(data), tag_items);\n+    auto items = ebmlivec::get_doc(ebmlivec::new_doc(data), tag_items);\n     auto item = find_item(def._1, items);\n     let ty::variant_info[] infos = ~[];\n     auto variant_ids = tag_variant_ids(item, external_crate_id);\n@@ -252,15 +252,15 @@ fn kind_has_type_params(u8 kind_ch) -> bool {\n         };\n }\n \n-fn read_path(&ebml::doc d) -> tup(str, uint) {\n-    auto desc = ebml::doc_data(d);\n-    auto pos = ebml::be_uint_from_bytes(desc, 0u, 4u);\n-    auto pathbytes = vec::slice[u8](desc, 4u, vec::len[u8](desc));\n-    auto path = str::unsafe_from_bytes(pathbytes);\n+fn read_path(&ebmlivec::doc d) -> tup(str, uint) {\n+    auto desc = ebmlivec::doc_data(d);\n+    auto pos = ebmlivec::be_uint_from_bytes(@desc, 0u, 4u);\n+    auto pathbytes = ivec::slice[u8](desc, 4u, ivec::len[u8](desc));\n+    auto path = str::unsafe_from_bytes_ivec(pathbytes);\n     ret tup(path, pos);\n }\n \n-fn describe_def(&ebml::doc items, ast::def_id id) -> str {\n+fn describe_def(&ebmlivec::doc items, ast::def_id id) -> str {\n     if (id._0 != 0) { ret \"external\"; }\n     ret item_kind_to_str(item_kind(find_item(id._1, items)));\n }\n@@ -280,40 +280,40 @@ fn item_kind_to_str(u8 kind) -> str {\n     }\n }\n \n-fn get_meta_items(&ebml::doc md) -> (@ast::meta_item)[] {\n+fn get_meta_items(&ebmlivec::doc md) -> (@ast::meta_item)[] {\n     let (@ast::meta_item)[] items = ~[];\n-    for each (ebml::doc meta_item_doc in\n-              ebml::tagged_docs(md, tag_meta_item_word)) {\n-        auto nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        auto n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+    for each (ebmlivec::doc meta_item_doc in\n+              ebmlivec::tagged_docs(md, tag_meta_item_word)) {\n+        auto nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n+        auto n = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(nd));\n         items += ~[attr::mk_word_item(n)];\n     }\n-    for each (ebml::doc meta_item_doc in\n-              ebml::tagged_docs(md, tag_meta_item_name_value)) {\n-        auto nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        auto vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n-        auto n = str::unsafe_from_bytes(ebml::doc_data(nd));\n-        auto v = str::unsafe_from_bytes(ebml::doc_data(vd));\n+    for each (ebmlivec::doc meta_item_doc in\n+              ebmlivec::tagged_docs(md, tag_meta_item_name_value)) {\n+        auto nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n+        auto vd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_value);\n+        auto n = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(nd));\n+        auto v = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(vd));\n         // FIXME (#611): Should be able to decode meta_name_value variants,\n         // but currently they can't be encoded\n         items += ~[attr::mk_name_value_item_str(n, v)];\n     }\n-    for each (ebml::doc meta_item_doc in\n-              ebml::tagged_docs(md, tag_meta_item_list)) {\n-        auto nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        auto n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+    for each (ebmlivec::doc meta_item_doc in\n+              ebmlivec::tagged_docs(md, tag_meta_item_list)) {\n+        auto nd = ebmlivec::get_doc(meta_item_doc, tag_meta_item_name);\n+        auto n = str::unsafe_from_bytes_ivec(ebmlivec::doc_data(nd));\n         auto subitems = get_meta_items(meta_item_doc);\n         items += ~[attr::mk_list_item(n, subitems)];\n     }\n     ret items;\n }\n \n-fn get_attributes(&ebml::doc md) -> ast::attribute[] {\n+fn get_attributes(&ebmlivec::doc md) -> ast::attribute[] {\n     let ast::attribute[] attrs = ~[];\n-    alt (ebml::maybe_get_doc(md, tag_attributes)) {\n+    alt (ebmlivec::maybe_get_doc(md, tag_attributes)) {\n         case (option::some(?attrs_d)) {\n-            for each (ebml::doc attr_doc in\n-                      ebml::tagged_docs(attrs_d, tag_attribute)) {\n+            for each (ebmlivec::doc attr_doc in\n+                      ebmlivec::tagged_docs(attrs_d, tag_attribute)) {\n                 auto meta_items = get_meta_items(attr_doc);\n                 // Currently it's only possible to have a single meta item on\n                 // an attribute\n@@ -329,13 +329,13 @@ fn get_attributes(&ebml::doc md) -> ast::attribute[] {\n     ret attrs;\n }\n \n-fn list_meta_items(&ebml::doc meta_items, io::writer out) {\n+fn list_meta_items(&ebmlivec::doc meta_items, ioivec::writer out) {\n     for (@ast::meta_item mi in get_meta_items(meta_items)) {\n         out.write_str(#fmt(\"%s\\n\", pprust::meta_item_to_str(*mi)));\n     }\n }\n \n-fn list_crate_attributes(&ebml::doc md, io::writer out) {\n+fn list_crate_attributes(&ebmlivec::doc md, ioivec::writer out) {\n     out.write_str(\"=Crate Attributes=\\n\");\n \n     for (ast::attribute attr in get_attributes(md)) {\n@@ -345,27 +345,28 @@ fn list_crate_attributes(&ebml::doc md, io::writer out) {\n     out.write_str(\"\\n\\n\");\n }\n \n-fn get_crate_attributes(&vec[u8] data) -> ast::attribute[] {\n-    ret get_attributes(ebml::new_doc(data));\n+fn get_crate_attributes(@u8[] data) -> ast::attribute[] {\n+    ret get_attributes(ebmlivec::new_doc(data));\n }\n \n type crate_dep = tup(ast::crate_num, str);\n \n-fn get_crate_deps(&vec[u8] data) -> vec[crate_dep] {\n+fn get_crate_deps(@u8[] data) -> vec[crate_dep] {\n     let vec[crate_dep] deps = [];\n-    auto cratedoc = ebml::new_doc(data);\n-    auto depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n+    auto cratedoc = ebmlivec::new_doc(data);\n+    auto depsdoc = ebmlivec::get_doc(cratedoc, tag_crate_deps);\n     auto crate_num = 1;\n-    for each (ebml::doc depdoc in\n-              ebml::tagged_docs(depsdoc, tag_crate_dep)) {\n-        auto depname = str::unsafe_from_bytes(ebml::doc_data(depdoc));\n+    for each (ebmlivec::doc depdoc in\n+              ebmlivec::tagged_docs(depsdoc, tag_crate_dep)) {\n+        auto depname =\n+            str::unsafe_from_bytes_ivec(ebmlivec::doc_data(depdoc));\n         deps += [tup(crate_num, depname)];\n         crate_num += 1;\n     }\n     ret deps;\n }\n \n-fn list_crate_deps(&vec[u8] data, io::writer out) {\n+fn list_crate_deps(@u8[] data, ioivec::writer out) {\n     out.write_str(\"=External Dependencies=\\n\");\n \n     for (crate_dep dep in get_crate_deps(data)) {\n@@ -375,29 +376,29 @@ fn list_crate_deps(&vec[u8] data, io::writer out) {\n     out.write_str(\"\\n\");\n }\n \n-fn list_crate_items(vec[u8] bytes, &ebml::doc md, io::writer out) {\n+fn list_crate_items(&@u8[] bytes, &ebmlivec::doc md, ioivec::writer out) {\n     out.write_str(\"=Items=\\n\");\n-    auto paths = ebml::get_doc(md, tag_paths);\n-    auto items = ebml::get_doc(md, tag_items);\n-    auto index = ebml::get_doc(paths, tag_index);\n-    auto bs = ebml::get_doc(index, tag_index_buckets);\n-    for each (ebml::doc bucket in\n-             ebml::tagged_docs(bs, tag_index_buckets_bucket)) {\n+    auto paths = ebmlivec::get_doc(md, tag_paths);\n+    auto items = ebmlivec::get_doc(md, tag_items);\n+    auto index = ebmlivec::get_doc(paths, tag_index);\n+    auto bs = ebmlivec::get_doc(index, tag_index_buckets);\n+    for each (ebmlivec::doc bucket in\n+             ebmlivec::tagged_docs(bs, tag_index_buckets_bucket)) {\n         auto et = tag_index_buckets_bucket_elt;\n-        for each (ebml::doc elt in ebml::tagged_docs(bucket, et)) {\n+        for each (ebmlivec::doc elt in ebmlivec::tagged_docs(bucket, et)) {\n             auto data = read_path(elt);\n-            auto def = ebml::doc_at(bytes, data._1);\n-            auto did_doc = ebml::get_doc(def, tag_def_id);\n-            auto did = parse_def_id(ebml::doc_data(did_doc));\n+            auto def = ebmlivec::doc_at(bytes, data._1);\n+            auto did_doc = ebmlivec::get_doc(def, tag_def_id);\n+            auto did = parse_def_id(ebmlivec::doc_data(did_doc));\n             out.write_str(#fmt(\"%s (%s)\\n\", data._0,\n                                describe_def(items, did)));\n         }\n     }\n     out.write_str(\"\\n\");\n }\n \n-fn list_crate_metadata(vec[u8] bytes, io::writer out) {\n-    auto md = ebml::new_doc(bytes);\n+fn list_crate_metadata(&@u8[] bytes, ioivec::writer out) {\n+    auto md = ebmlivec::new_doc(bytes);\n     list_crate_attributes(md, out);\n     list_crate_deps(bytes, out);\n     list_crate_items(bytes, md, out);"}, {"sha": "e792aca6ab05c11cd5d2d8eacdf5267f4c1bd3de", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 153, "deletions": 153, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -4,11 +4,11 @@ import std::ivec;\n import std::str;\n import std::vec;\n import std::uint;\n-import std::io;\n+import std::ioivec;\n import std::option;\n import std::option::some;\n import std::option::none;\n-import std::ebml;\n+import std::ebmlivec;\n import std::map;\n import syntax::ast::*;\n import common::*;\n@@ -26,198 +26,198 @@ type encode_ctxt = rec(@crate_ctxt ccx,\n                        abbrev_map type_abbrevs);\n \n // Path table encoding\n-fn encode_name(&ebml::writer ebml_w, &str name) {\n-    ebml::start_tag(ebml_w, tag_paths_data_name);\n-    ebml_w.writer.write(str::bytes(name));\n-    ebml::end_tag(ebml_w);\n+fn encode_name(&ebmlivec::writer ebml_w, &str name) {\n+    ebmlivec::start_tag(ebml_w, tag_paths_data_name);\n+    ebml_w.writer.write(str::bytes_ivec(name));\n+    ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_def_id(&ebml::writer ebml_w, &def_id id) {\n-    ebml::start_tag(ebml_w, tag_def_id);\n-    ebml_w.writer.write(str::bytes(def_to_str(id)));\n-    ebml::end_tag(ebml_w);\n+fn encode_def_id(&ebmlivec::writer ebml_w, &def_id id) {\n+    ebmlivec::start_tag(ebml_w, tag_def_id);\n+    ebml_w.writer.write(str::bytes_ivec(def_to_str(id)));\n+    ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_paths(&ebml::writer ebml_w, &variant[] variants,\n+fn encode_tag_variant_paths(&ebmlivec::writer ebml_w, &variant[] variants,\n                             &vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n     for (variant variant in variants) {\n         add_to_index(ebml_w, path, index, variant.node.name);\n-        ebml::start_tag(ebml_w, tag_paths_data_item);\n+        ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, variant.node.name);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n-        ebml::end_tag(ebml_w);\n+        ebmlivec::end_tag(ebml_w);\n     }\n }\n \n-fn add_to_index(&ebml::writer ebml_w, &vec[str] path,\n+fn add_to_index(&ebmlivec::writer ebml_w, &vec[str] path,\n                 &mutable vec[tup(str, uint)] index, &str name) {\n     auto full_path = path + [name];\n     index += [tup(str::connect(full_path, \"::\"), ebml_w.writer.tell())];\n }\n \n-fn encode_native_module_item_paths(&ebml::writer ebml_w,\n+fn encode_native_module_item_paths(&ebmlivec::writer ebml_w,\n                                    &native_mod nmod, &vec[str] path,\n                                    &mutable vec[tup(str, uint)] index) {\n     for (@native_item nitem in nmod.items) {\n         add_to_index(ebml_w, path, index, nitem.ident);\n-        ebml::start_tag(ebml_w, tag_paths_data_item);\n+        ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, nitem.ident);\n         encode_def_id(ebml_w, local_def(nitem.id));\n-        ebml::end_tag(ebml_w);\n+        ebmlivec::end_tag(ebml_w);\n     }\n }\n \n-fn encode_module_item_paths(&ebml::writer ebml_w, &_mod module,\n+fn encode_module_item_paths(&ebmlivec::writer ebml_w, &_mod module,\n                             &vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n     for (@item it in module.items) {\n         if (!is_exported(it.ident, module)) { cont; }\n         alt (it.node) {\n             case (item_const(_, _)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n                 encode_def_id(ebml_w, local_def(it.id));\n-                ebml::end_tag(ebml_w);\n+                ebmlivec::end_tag(ebml_w);\n             }\n             case (item_fn(_, ?tps)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n                 encode_def_id(ebml_w, local_def(it.id));\n-                ebml::end_tag(ebml_w);\n+                ebmlivec::end_tag(ebml_w);\n             }\n             case (item_mod(?_mod)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_mod);\n+                ebmlivec::start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, it.ident);\n                 encode_def_id(ebml_w, local_def(it.id));\n                 encode_module_item_paths(ebml_w, _mod, path + [it.ident],\n                                          index);\n-                ebml::end_tag(ebml_w);\n+                ebmlivec::end_tag(ebml_w);\n             }\n             case (item_native_mod(?nmod)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_mod);\n+                ebmlivec::start_tag(ebml_w, tag_paths_data_mod);\n                 encode_name(ebml_w, it.ident);\n                 encode_def_id(ebml_w, local_def(it.id));\n                 encode_native_module_item_paths(ebml_w, nmod,\n                                                 path + [it.ident], index);\n-                ebml::end_tag(ebml_w);\n+                ebmlivec::end_tag(ebml_w);\n             }\n             case (item_ty(_, ?tps)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n                 encode_def_id(ebml_w, local_def(it.id));\n-                ebml::end_tag(ebml_w);\n+                ebmlivec::end_tag(ebml_w);\n             }\n             case (item_res(_, _, ?tps, ?ctor_id)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n                 encode_def_id(ebml_w, local_def(ctor_id));\n-                ebml::end_tag(ebml_w);\n+                ebmlivec::end_tag(ebml_w);\n                 add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n                 encode_def_id(ebml_w, local_def(it.id));\n-                ebml::end_tag(ebml_w);\n+                ebmlivec::end_tag(ebml_w);\n             }\n             case (item_tag(?variants, ?tps)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n                 encode_def_id(ebml_w, local_def(it.id));\n-                ebml::end_tag(ebml_w);\n+                ebmlivec::end_tag(ebml_w);\n                 encode_tag_variant_paths(ebml_w, variants, path, index);\n             }\n             case (item_obj(_, ?tps, ?ctor_id)) {\n                 add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n                 encode_def_id(ebml_w, local_def(ctor_id));\n-                ebml::end_tag(ebml_w);\n+                ebmlivec::end_tag(ebml_w);\n                 add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                ebmlivec::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, it.ident);\n                 encode_def_id(ebml_w, local_def(it.id));\n-                ebml::end_tag(ebml_w);\n+                ebmlivec::end_tag(ebml_w);\n             }\n         }\n     }\n }\n \n-fn encode_item_paths(&ebml::writer ebml_w, &@crate crate) ->\n+fn encode_item_paths(&ebmlivec::writer ebml_w, &@crate crate) ->\n    vec[tup(str, uint)] {\n     let vec[tup(str, uint)] index = [];\n     let vec[str] path = [];\n-    ebml::start_tag(ebml_w, tag_paths);\n+    ebmlivec::start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n-    ebml::end_tag(ebml_w);\n+    ebmlivec::end_tag(ebml_w);\n     ret index;\n }\n \n \n // Item info table encoding\n-fn encode_kind(&ebml::writer ebml_w, u8 c) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_kind);\n-    ebml_w.writer.write([c]);\n-    ebml::end_tag(ebml_w);\n+fn encode_kind(&ebmlivec::writer ebml_w, u8 c) {\n+    ebmlivec::start_tag(ebml_w, tag_items_data_item_kind);\n+    ebml_w.writer.write(~[c]);\n+    ebmlivec::end_tag(ebml_w);\n }\n \n fn def_to_str(&def_id did) -> str { ret #fmt(\"%d:%d\", did._0, did._1); }\n \n-fn encode_type_param_count(&ebml::writer ebml_w, &ty_param[] tps) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_ty_param_count);\n-    ebml::write_vint(ebml_w.writer, ivec::len[ty_param](tps));\n-    ebml::end_tag(ebml_w);\n+fn encode_type_param_count(&ebmlivec::writer ebml_w, &ty_param[] tps) {\n+    ebmlivec::start_tag(ebml_w, tag_items_data_item_ty_param_count);\n+    ebmlivec::write_vint(ebml_w.writer, ivec::len[ty_param](tps));\n+    ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_variant_id(&ebml::writer ebml_w, &def_id vid) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_variant);\n-    ebml_w.writer.write(str::bytes(def_to_str(vid)));\n-    ebml::end_tag(ebml_w);\n+fn encode_variant_id(&ebmlivec::writer ebml_w, &def_id vid) {\n+    ebmlivec::start_tag(ebml_w, tag_items_data_item_variant);\n+    ebml_w.writer.write(str::bytes_ivec(def_to_str(vid)));\n+    ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_type(&@encode_ctxt ecx, &ebml::writer ebml_w, &ty::t typ) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_type);\n+fn encode_type(&@encode_ctxt ecx, &ebmlivec::writer ebml_w, &ty::t typ) {\n+    ebmlivec::start_tag(ebml_w, tag_items_data_item_type);\n     auto f = def_to_str;\n     auto ty_str_ctxt =\n         @rec(ds=f, tcx=ecx.ccx.tcx,\n              abbrevs=tyencode::ac_use_abbrevs(ecx.type_abbrevs));\n-    tyencode::enc_ty(io::new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n-    ebml::end_tag(ebml_w);\n+    tyencode::enc_ty(ioivec::new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n+    ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_symbol(&@encode_ctxt ecx, &ebml::writer ebml_w,\n+fn encode_symbol(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n                  node_id id) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::bytes(ecx.ccx.item_symbols.get(id)));\n-    ebml::end_tag(ebml_w);\n+    ebmlivec::start_tag(ebml_w, tag_items_data_item_symbol);\n+    ebml_w.writer.write(str::bytes_ivec(ecx.ccx.item_symbols.get(id)));\n+    ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_discriminant(&@encode_ctxt ecx, &ebml::writer ebml_w,\n+fn encode_discriminant(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n                        node_id id) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::bytes(ecx.ccx.discrim_symbols.get(id)));\n-    ebml::end_tag(ebml_w);\n+    ebmlivec::start_tag(ebml_w, tag_items_data_item_symbol);\n+    ebml_w.writer.write(str::bytes_ivec(ecx.ccx.discrim_symbols.get(id)));\n+    ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_tag_id(&ebml::writer ebml_w, &def_id id) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_tag_id);\n-    ebml_w.writer.write(str::bytes(def_to_str(id)));\n-    ebml::end_tag(ebml_w);\n+fn encode_tag_id(&ebmlivec::writer ebml_w, &def_id id) {\n+    ebmlivec::start_tag(ebml_w, tag_items_data_item_tag_id);\n+    ebml_w.writer.write(str::bytes_ivec(def_to_str(id)));\n+    ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_info(&@encode_ctxt ecx, &ebml::writer ebml_w,\n+fn encode_tag_variant_info(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n                            node_id id, &variant[] variants,\n                            &mutable vec[tup(int, uint)] index,\n                            &ty_param[] ty_params) {\n     for (variant variant in variants) {\n         index += [tup(variant.node.id, ebml_w.writer.tell())];\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n+        ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_kind(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, local_def(id));\n@@ -228,24 +228,24 @@ fn encode_tag_variant_info(&@encode_ctxt ecx, &ebml::writer ebml_w,\n         }\n         encode_discriminant(ecx, ebml_w, variant.node.id);\n         encode_type_param_count(ebml_w, ty_params);\n-        ebml::end_tag(ebml_w);\n+        ebmlivec::end_tag(ebml_w);\n     }\n }\n \n-fn encode_info_for_item(@encode_ctxt ecx, &ebml::writer ebml_w,\n+fn encode_info_for_item(@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n                         @item item, &mutable vec[tup(int, uint)] index) {\n     alt (item.node) {\n         case (item_const(_, _)) {\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n+            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'c' as u8);\n             encode_type(ecx, ebml_w,\n                         node_id_to_monotype(ecx.ccx.tcx, item.id));\n             encode_symbol(ecx, ebml_w, item.id);\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n         }\n         case (item_fn(?fd, ?tps)) {\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n+            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, alt (fd.decl.purity) {\n                                   case (pure_fn) { 'p' }\n@@ -254,31 +254,31 @@ fn encode_info_for_item(@encode_ctxt ecx, &ebml::writer ebml_w,\n             encode_type(ecx, ebml_w,\n                         node_id_to_monotype(ecx.ccx.tcx, item.id));\n             encode_symbol(ecx, ebml_w, item.id);\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n         }\n         case (item_mod(_)) {\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n+            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'm' as u8);\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n         }\n         case (item_native_mod(_)) {\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n+            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'n' as u8);\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n         }\n         case (item_ty(_, ?tps)) {\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n+            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(ecx, ebml_w,\n                         node_id_to_monotype(ecx.ccx.tcx, item.id));\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n         }\n         case (item_tag(?variants, ?tps)) {\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n+            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 't' as u8);\n             encode_type_param_count(ebml_w, tps);\n@@ -287,55 +287,55 @@ fn encode_info_for_item(@encode_ctxt ecx, &ebml::writer ebml_w,\n             for (variant v in variants) {\n                 encode_variant_id(ebml_w, local_def(v.node.id));\n             }\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n             encode_tag_variant_info(ecx, ebml_w, item.id, variants, index,\n                                     tps);\n         }\n         case (item_res(_, _, ?tps, ?ctor_id)) {\n             auto fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n \n-            ebml::start_tag(ebml_w, tag_items_data_item);\n+            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n             encode_symbol(ecx, ebml_w, item.id);\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n \n             index += [tup(ctor_id, ebml_w.writer.tell())];\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n+            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             encode_kind(ebml_w, 'f' as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(ecx, ebml_w, fn_ty);\n             encode_symbol(ecx, ebml_w, ctor_id);\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n         }\n         case (item_obj(_, ?tps, ?ctor_id)) {\n             auto fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n \n-            ebml::start_tag(ebml_w, tag_items_data_item);\n+            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n \n             index += [tup(ctor_id, ebml_w.writer.tell())];\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n+            ebmlivec::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             encode_kind(ebml_w, 'f' as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(ecx, ebml_w, fn_ty);\n             encode_symbol(ecx, ebml_w, ctor_id);\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n         }\n     }\n }\n \n-fn encode_info_for_native_item(&@encode_ctxt ecx, &ebml::writer ebml_w,\n+fn encode_info_for_native_item(&@encode_ctxt ecx, &ebmlivec::writer ebml_w,\n                                &@native_item nitem) {\n-    ebml::start_tag(ebml_w, tag_items_data_item);\n+    ebmlivec::start_tag(ebml_w, tag_items_data_item);\n     alt (nitem.node) {\n         case (native_item_ty) {\n             encode_def_id(ebml_w, local_def(nitem.id));\n@@ -352,13 +352,13 @@ fn encode_info_for_native_item(&@encode_ctxt ecx, &ebml::writer ebml_w,\n             encode_symbol(ecx, ebml_w, nitem.id);\n         }\n     }\n-    ebml::end_tag(ebml_w);\n+    ebmlivec::end_tag(ebml_w);\n }\n \n-fn encode_info_for_items(&@encode_ctxt ecx, &ebml::writer ebml_w) ->\n+fn encode_info_for_items(&@encode_ctxt ecx, &ebmlivec::writer ebml_w) ->\n    vec[tup(int, uint)] {\n     let vec[tup(int, uint)] index = [];\n-    ebml::start_tag(ebml_w, tag_items_data);\n+    ebmlivec::start_tag(ebml_w, tag_items_data);\n     for each (@tup(node_id, middle::ast_map::ast_node) kvp in\n               ecx.ccx.ast_map.items()) {\n         alt (kvp._1) {\n@@ -373,7 +373,7 @@ fn encode_info_for_items(&@encode_ctxt ecx, &ebml::writer ebml_w) ->\n             case (_) {}\n         }\n     }\n-    ebml::end_tag(ebml_w);\n+    ebmlivec::end_tag(ebml_w);\n     ret index;\n }\n \n@@ -391,81 +391,81 @@ fn create_index[T](&vec[tup(T, uint)] index, fn(&T) -> uint  hash_fn) ->\n     ret vec::freeze(buckets);\n }\n \n-fn encode_index[T](&ebml::writer ebml_w, &vec[vec[tup(T, uint)]] buckets,\n-                   fn(&io::writer, &T)  write_fn) {\n-    auto writer = io::new_writer_(ebml_w.writer);\n-    ebml::start_tag(ebml_w, tag_index);\n+fn encode_index[T](&ebmlivec::writer ebml_w, &vec[vec[tup(T, uint)]] buckets,\n+                   fn(&ioivec::writer, &T)  write_fn) {\n+    auto writer = ioivec::new_writer_(ebml_w.writer);\n+    ebmlivec::start_tag(ebml_w, tag_index);\n     let vec[uint] bucket_locs = [];\n-    ebml::start_tag(ebml_w, tag_index_buckets);\n+    ebmlivec::start_tag(ebml_w, tag_index_buckets);\n     for (vec[tup(T, uint)] bucket in buckets) {\n         bucket_locs += [ebml_w.writer.tell()];\n-        ebml::start_tag(ebml_w, tag_index_buckets_bucket);\n+        ebmlivec::start_tag(ebml_w, tag_index_buckets_bucket);\n         for (tup(T, uint) elt in bucket) {\n-            ebml::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n+            ebmlivec::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n             writer.write_be_uint(elt._1, 4u);\n             write_fn(writer, elt._0);\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n         }\n-        ebml::end_tag(ebml_w);\n+        ebmlivec::end_tag(ebml_w);\n     }\n-    ebml::end_tag(ebml_w);\n-    ebml::start_tag(ebml_w, tag_index_table);\n+    ebmlivec::end_tag(ebml_w);\n+    ebmlivec::start_tag(ebml_w, tag_index_table);\n     for (uint pos in bucket_locs) { writer.write_be_uint(pos, 4u); }\n-    ebml::end_tag(ebml_w);\n-    ebml::end_tag(ebml_w);\n+    ebmlivec::end_tag(ebml_w);\n+    ebmlivec::end_tag(ebml_w);\n }\n \n-fn write_str(&io::writer writer, &str s) { writer.write_str(s); }\n+fn write_str(&ioivec::writer writer, &str s) { writer.write_str(s); }\n \n-fn write_int(&io::writer writer, &int n) {\n+fn write_int(&ioivec::writer writer, &int n) {\n     writer.write_be_uint(n as uint, 4u);\n }\n \n-fn encode_meta_item(&ebml::writer ebml_w, &meta_item mi) {\n+fn encode_meta_item(&ebmlivec::writer ebml_w, &meta_item mi) {\n     alt (mi.node) {\n         case (meta_word(?name)) {\n-            ebml::start_tag(ebml_w, tag_meta_item_word);\n-            ebml::start_tag(ebml_w, tag_meta_item_name);\n-            ebml_w.writer.write(str::bytes(name));\n-            ebml::end_tag(ebml_w);\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::start_tag(ebml_w, tag_meta_item_word);\n+            ebmlivec::start_tag(ebml_w, tag_meta_item_name);\n+            ebml_w.writer.write(str::bytes_ivec(name));\n+            ebmlivec::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n         }\n         case (meta_name_value(?name, ?value)) {\n             alt (value.node) {\n                 case (lit_str(?value, _)) {\n-                    ebml::start_tag(ebml_w, tag_meta_item_name_value);\n-                    ebml::start_tag(ebml_w, tag_meta_item_name);\n-                    ebml_w.writer.write(str::bytes(name));\n-                    ebml::end_tag(ebml_w);\n-                    ebml::start_tag(ebml_w, tag_meta_item_value);\n-                    ebml_w.writer.write(str::bytes(value));\n-                    ebml::end_tag(ebml_w);\n-                    ebml::end_tag(ebml_w);\n+                    ebmlivec::start_tag(ebml_w, tag_meta_item_name_value);\n+                    ebmlivec::start_tag(ebml_w, tag_meta_item_name);\n+                    ebml_w.writer.write(str::bytes_ivec(name));\n+                    ebmlivec::end_tag(ebml_w);\n+                    ebmlivec::start_tag(ebml_w, tag_meta_item_value);\n+                    ebml_w.writer.write(str::bytes_ivec(value));\n+                    ebmlivec::end_tag(ebml_w);\n+                    ebmlivec::end_tag(ebml_w);\n                 }\n                 case (_) { /* FIXME (#611) */ }\n             }\n         }\n         case (meta_list(?name, ?items)) {\n-            ebml::start_tag(ebml_w, tag_meta_item_list);\n-            ebml::start_tag(ebml_w, tag_meta_item_name);\n-            ebml_w.writer.write(str::bytes(name));\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::start_tag(ebml_w, tag_meta_item_list);\n+            ebmlivec::start_tag(ebml_w, tag_meta_item_name);\n+            ebml_w.writer.write(str::bytes_ivec(name));\n+            ebmlivec::end_tag(ebml_w);\n             for (@meta_item inner_item in items) {\n                 encode_meta_item(ebml_w, *inner_item);\n             }\n-            ebml::end_tag(ebml_w);\n+            ebmlivec::end_tag(ebml_w);\n         }\n     }\n }\n \n-fn encode_attributes(&ebml::writer ebml_w, &vec[attribute] attrs) {\n-    ebml::start_tag(ebml_w, tag_attributes);\n+fn encode_attributes(&ebmlivec::writer ebml_w, &vec[attribute] attrs) {\n+    ebmlivec::start_tag(ebml_w, tag_attributes);\n     for (attribute attr in attrs) {\n-        ebml::start_tag(ebml_w, tag_attribute);\n+        ebmlivec::start_tag(ebml_w, tag_attribute);\n         encode_meta_item(ebml_w, attr.node.value);\n-        ebml::end_tag(ebml_w);\n+        ebmlivec::end_tag(ebml_w);\n     }\n-    ebml::end_tag(ebml_w);\n+    ebmlivec::end_tag(ebml_w);\n }\n \n // So there's a special crate attribute called 'link' which defines the\n@@ -520,7 +520,7 @@ fn synthesize_crate_attrs(&@encode_ctxt ecx,\n     ret attrs;\n }\n \n-fn encode_crate_deps(&ebml::writer ebml_w, &cstore::cstore cstore) {\n+fn encode_crate_deps(&ebmlivec::writer ebml_w, &cstore::cstore cstore) {\n \n     fn get_ordered_names(&cstore::cstore cstore) -> vec[str] {\n         type hashkv = @tup(crate_num, cstore::crate_metadata);\n@@ -554,23 +554,23 @@ fn encode_crate_deps(&ebml::writer ebml_w, &cstore::cstore cstore) {\n     // that they are numbered 1 to n.\n     // FIXME: This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n-    ebml::start_tag(ebml_w, tag_crate_deps);\n+    ebmlivec::start_tag(ebml_w, tag_crate_deps);\n     for (str cname in get_ordered_names(cstore)) {\n-        ebml::start_tag(ebml_w, tag_crate_dep);\n-        ebml_w.writer.write(str::bytes(cname));\n-        ebml::end_tag(ebml_w);\n+        ebmlivec::start_tag(ebml_w, tag_crate_dep);\n+        ebml_w.writer.write(str::bytes_ivec(cname));\n+        ebmlivec::end_tag(ebml_w);\n     }\n-    ebml::end_tag(ebml_w);\n+    ebmlivec::end_tag(ebml_w);\n }\n \n fn encode_metadata(&@crate_ctxt cx, &@crate crate) -> str {\n \n     auto abbrevs = map::mk_hashmap(ty::hash_ty, ty::eq_ty);\n     auto ecx = @rec(ccx = cx, type_abbrevs = abbrevs);\n \n-    auto string_w = io::string_writer();\n+    auto string_w = ioivec::string_writer();\n     auto buf_w = string_w.get_writer().get_buf_writer();\n-    auto ebml_w = ebml::create_writer(buf_w);\n+    auto ebml_w = ebmlivec::create_writer(buf_w);\n \n     auto crate_attrs = synthesize_crate_attrs(ecx, crate);\n     encode_attributes(ebml_w, crate_attrs);\n@@ -579,26 +579,26 @@ fn encode_metadata(&@crate_ctxt cx, &@crate crate) -> str {\n \n     // Encode and index the paths.\n \n-    ebml::start_tag(ebml_w, tag_paths);\n+    ebmlivec::start_tag(ebml_w, tag_paths);\n     auto paths_index = encode_item_paths(ebml_w, crate);\n     auto str_writer = write_str;\n     auto path_hasher = hash_path;\n     auto paths_buckets = create_index[str](paths_index, path_hasher);\n     encode_index[str](ebml_w, paths_buckets, str_writer);\n-    ebml::end_tag(ebml_w);\n+    ebmlivec::end_tag(ebml_w);\n     // Encode and index the items.\n \n-    ebml::start_tag(ebml_w, tag_items);\n+    ebmlivec::start_tag(ebml_w, tag_items);\n     auto items_index = encode_info_for_items(ecx, ebml_w);\n     auto int_writer = write_int;\n     auto item_hasher = hash_node_id;\n     auto items_buckets = create_index[int](items_index, item_hasher);\n     encode_index[int](ebml_w, items_buckets, int_writer);\n-    ebml::end_tag(ebml_w);\n+    ebmlivec::end_tag(ebml_w);\n     // Pad this, since something (LLVM, presumably) is cutting off the\n-    // remaining % 4 bytes.\n+    // remaining % 4 bytes_ivec.\n \n-    buf_w.write([0u8, 0u8, 0u8, 0u8]);\n+    buf_w.write(~[0u8, 0u8, 0u8, 0u8]);\n     ret string_w.get_str();\n }\n \n@@ -607,7 +607,7 @@ fn encoded_ty(&ty::ctxt tcx, &ty::t t) -> str {\n     auto cx = @rec(ds = def_to_str,\n                    tcx = tcx,\n                    abbrevs = tyencode::ac_no_abbrevs);\n-    auto sw = io::string_writer();\n+    auto sw = ioivec::string_writer();\n     tyencode::enc_ty(sw.get_writer(), cx, t);\n     ret sw.get_str();\n }"}, {"sha": "1c2494758687e9db57f6d919a950bfe218134f13", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -1,5 +1,6 @@\n // Type decoding\n \n+import std::ivec;\n import std::str;\n import std::vec;\n import std::uint;\n@@ -21,7 +22,7 @@ export parse_ty_data;\n type str_def = fn(str) -> ast::def_id ;\n \n type pstate =\n-    rec(vec[u8] data, int crate, mutable uint pos, uint len, ty::ctxt tcx);\n+    rec(@u8[] data, int crate, mutable uint pos, uint len, ty::ctxt tcx);\n \n tag ty_or_bang { a_ty(ty::t); a_bang; }\n \n@@ -50,7 +51,7 @@ fn parse_ident_(@pstate st, str_def sd, fn(char) -> bool is_last)\n }\n \n \n-fn parse_ty_data(vec[u8] data, int crate_num, uint pos, uint len, str_def sd,\n+fn parse_ty_data(@u8[] data, int crate_num, uint pos, uint len, str_def sd,\n                  ty::ctxt tcx) -> ty::t {\n     auto st =\n         @rec(data=data, crate=crate_num, mutable pos=pos, len=len, tcx=tcx);\n@@ -361,19 +362,25 @@ fn parse_ty_fn(@pstate st, str_def sd) ->\n \n \n // Rust metadata parsing\n-fn parse_def_id(vec[u8] buf) -> ast::def_id {\n+fn parse_def_id(&u8[] buf) -> ast::def_id {\n     auto colon_idx = 0u;\n-    auto len = vec::len[u8](buf);\n+    auto len = ivec::len[u8](buf);\n     while (colon_idx < len && buf.(colon_idx) != ':' as u8) {\n         colon_idx += 1u;\n     }\n     if (colon_idx == len) {\n         log_err \"didn't find ':' when parsing def id\";\n         fail;\n     }\n-    auto crate_part = vec::slice[u8](buf, 0u, colon_idx);\n-    auto def_part = vec::slice[u8](buf, colon_idx + 1u, len);\n-    auto crate_num = uint::parse_buf(crate_part, 10u) as int;\n-    auto def_id = uint::parse_buf(def_part, 10u) as int;\n+    auto crate_part = ivec::slice[u8](buf, 0u, colon_idx);\n+    auto def_part = ivec::slice[u8](buf, colon_idx + 1u, len);\n+\n+    // FIXME: Remove these ivec->vec conversions.\n+    auto crate_part_vec = []; auto def_part_vec = [];\n+    for (u8 b in crate_part) { crate_part_vec += [b]; }\n+    for (u8 b in def_part) { def_part_vec += [b]; }\n+\n+    auto crate_num = uint::parse_buf(crate_part_vec, 10u) as int;\n+    auto def_id = uint::parse_buf(def_part_vec, 10u) as int;\n     ret tup(crate_num, def_id);\n }"}, {"sha": "4d7e1b8ac187bc66675c1ebde05426fd6a150560", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -1,6 +1,6 @@\n // Type encoding\n \n-import std::io;\n+import std::ioivec;\n import std::map::hashmap;\n import std::option::some;\n import std::option::none;\n@@ -36,14 +36,14 @@ fn cx_uses_abbrevs(&@ctxt cx) -> bool {\n     }\n }\n \n-fn enc_ty(&io::writer w, &@ctxt cx, &ty::t t) {\n+fn enc_ty(&ioivec::writer w, &@ctxt cx, &ty::t t) {\n     alt (cx.abbrevs) {\n         case (ac_no_abbrevs) {\n             auto result_str;\n             alt (cx.tcx.short_names_cache.find(t)) {\n                 case (some(?s)) { result_str = s; }\n                 case (none) {\n-                    auto sw = io::string_writer();\n+                    auto sw = ioivec::string_writer();\n                     enc_sty(sw.get_writer(), cx, ty::struct(cx.tcx, t));\n                     result_str = sw.get_str();\n                     cx.tcx.short_names_cache.insert(t, result_str);\n@@ -82,15 +82,15 @@ fn enc_ty(&io::writer w, &@ctxt cx, &ty::t t) {\n         }\n     }\n }\n-fn enc_mt(&io::writer w, &@ctxt cx, &ty::mt mt) {\n+fn enc_mt(&ioivec::writer w, &@ctxt cx, &ty::mt mt) {\n     alt (mt.mut) {\n         case (imm) { }\n         case (mut) { w.write_char('m'); }\n         case (maybe_mut) { w.write_char('?'); }\n     }\n     enc_ty(w, cx, mt.ty);\n }\n-fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n+fn enc_sty(&ioivec::writer w, &@ctxt cx, &ty::sty st) {\n     alt (st) {\n         case (ty::ty_nil) { w.write_char('n'); }\n         case (ty::ty_bot) { w.write_char('z'); }\n@@ -192,13 +192,13 @@ fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n         case (ty::ty_task) { w.write_char('a'); }\n     }\n }\n-fn enc_proto(&io::writer w, proto proto) {\n+fn enc_proto(&ioivec::writer w, proto proto) {\n     alt (proto) {\n         case (proto_iter) { w.write_char('W'); }\n         case (proto_fn) { w.write_char('F'); }\n     }\n }\n-fn enc_ty_fn(&io::writer w, &@ctxt cx, &ty::arg[] args, &ty::t out,\n+fn enc_ty_fn(&ioivec::writer w, &@ctxt cx, &ty::arg[] args, &ty::t out,\n              &controlflow cf, &(@ty::constr_def)[] constrs) {\n     w.write_char('[');\n     for (ty::arg arg in args) {\n@@ -226,7 +226,7 @@ fn enc_ty_fn(&io::writer w, &@ctxt cx, &ty::arg[] args, &ty::t out,\n     }\n \n }\n-fn enc_constr(&io::writer w, &@ctxt cx, &@ty::constr_def c) {\n+fn enc_constr(&ioivec::writer w, &@ctxt cx, &@ty::constr_def c) {\n     w.write_str(path_to_str(c.node.path));\n     w.write_char('(');\n     w.write_str(cx.ds(c.node.id));"}, {"sha": "46105f5320ee3183240f9c28ddc09b88ab2ba352", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -1,8 +1,8 @@\n import std::uint;\n import std::str;\n import std::vec;\n-import std::term;\n-import std::io;\n+import std::termivec;\n+import std::ioivec;\n import std::option;\n import std::option::some;\n import std::option::none;\n@@ -70,21 +70,21 @@ fn emit_diagnostic(&option::t[span] sp, &str msg, &str kind, u8 color,\n         }\n         case (none) { }\n     }\n-    io::stdout().write_str(ss + \": \");\n-    if (term::color_supported()) {\n-        term::fg(io::stdout().get_buf_writer(), color);\n+    ioivec::stdout().write_str(ss + \": \");\n+    if (termivec::color_supported()) {\n+        termivec::fg(ioivec::stdout().get_buf_writer(), color);\n     }\n-    io::stdout().write_str(#fmt(\"%s:\", kind));\n-    if (term::color_supported()) {\n-        term::reset(io::stdout().get_buf_writer());\n+    ioivec::stdout().write_str(#fmt(\"%s:\", kind));\n+    if (termivec::color_supported()) {\n+        termivec::reset(ioivec::stdout().get_buf_writer());\n     }\n-    io::stdout().write_str(#fmt(\" %s\\n\", msg));\n+    ioivec::stdout().write_str(#fmt(\" %s\\n\", msg));\n     alt (maybe_lines) {\n         case (some(?lines)) {\n             // FIXME: reading in the entire file is the worst possible way to\n             //        get access to the necessary lines.\n-            auto rdr = io::file_reader(lines.name);\n-            auto file = str::unsafe_from_bytes(rdr.read_whole_stream());\n+            auto rdr = ioivec::file_reader(lines.name);\n+            auto file = str::unsafe_from_bytes_ivec(rdr.read_whole_stream());\n             auto fm = codemap::get_filemap(cm, lines.name);\n \n             // arbitrarily only print up to six lines of the error\n@@ -97,12 +97,13 @@ fn emit_diagnostic(&option::t[span] sp, &str msg, &str kind, u8 color,\n             }\n             // Print the offending lines\n             for (uint line in display_lines) {\n-                io::stdout().write_str(#fmt(\"%s:%u \", fm.name, line + 1u));\n+                ioivec::stdout().write_str(#fmt(\"%s:%u \", fm.name,\n+                                                line + 1u));\n                 auto s = codemap::get_line(fm, line as int, file);\n                 if (!str::ends_with(s, \"\\n\")) {\n                     s += \"\\n\";\n                 }\n-                io::stdout().write_str(s);\n+                ioivec::stdout().write_str(s);\n             }\n             if (elided) {\n                 auto last_line = display_lines.(vec::len(display_lines) - 1u);\n@@ -111,7 +112,7 @@ fn emit_diagnostic(&option::t[span] sp, &str msg, &str kind, u8 color,\n                 auto out = \"\";\n                 while (indent > 0u) { out += \" \"; indent -= 1u; }\n                 out += \"...\\n\";\n-                io::stdout().write_str(out);\n+                ioivec::stdout().write_str(out);\n             }\n \n             // If there's one line at fault we can easily point to the problem\n@@ -138,7 +139,7 @@ fn emit_diagnostic(&option::t[span] sp, &str msg, &str kind, u8 color,\n                         width -= 1u;\n                     }\n                 }\n-                io::stdout().write_str(s + \"\\n\");\n+                ioivec::stdout().write_str(s + \"\\n\");\n             }\n         }\n         case (_) {}"}, {"sha": "77bde6280149408e2bfc89fd9266a28b75bbf734", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -1,5 +1,5 @@\n \n-import std::io;\n+import std::ioivec;\n import std::str;\n import std::vec;\n import std::int;\n@@ -734,8 +734,8 @@ type lit = rec(str lit, uint pos);\n \n fn gather_comments_and_literals(&codemap::codemap cm, str path)\n         -> rec(cmnt[] cmnts, lit[] lits) {\n-    auto srdr = io::file_reader(path);\n-    auto src = str::unsafe_from_bytes(srdr.read_whole_stream());\n+    auto srdr = ioivec::file_reader(path);\n+    auto src = str::unsafe_from_bytes_ivec(srdr.read_whole_stream());\n     auto itr = @interner::mk[str](str::hash, str::eq);\n     auto rdr = new_reader(cm, src, codemap::new_filemap(path, 0u), itr);\n     let cmnt[] comments = ~[];"}, {"sha": "d238e6eb2e750df0f6a006d75c4adbd1544cd28b", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -1,5 +1,5 @@\n \n-import std::io;\n+import std::ioivec;\n import std::ivec;\n import std::vec;\n import std::str;\n@@ -59,8 +59,8 @@ fn new_parser_from_file(parse_sess sess, ast::crate_cfg cfg,\n                         str path, uint pos) -> parser {\n     auto ftype = SOURCE_FILE;\n     if (str::ends_with(path, \".rc\")) { ftype = CRATE_FILE; }\n-    auto srdr = io::file_reader(path);\n-    auto src = str::unsafe_from_bytes(srdr.read_whole_stream());\n+    auto srdr = ioivec::file_reader(path);\n+    auto src = str::unsafe_from_bytes_ivec(srdr.read_whole_stream());\n     auto filemap = codemap::new_filemap(path, pos);\n     vec::push(sess.cm.files, filemap);\n     auto itr = @interner::mk(str::hash, str::eq);"}, {"sha": "7ac10f6bcf012a1fbf6a9420ceb531e14af976d2", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -1,5 +1,5 @@\n \n-import std::io;\n+import std::ioivec;\n import std::vec;\n import std::str;\n \n@@ -98,7 +98,7 @@ type print_stack_elt = rec(int offset, print_stack_break pbreak);\n \n const int size_infinity = 0xffff;\n \n-fn mk_printer(io::writer out, uint linewidth) -> printer {\n+fn mk_printer(ioivec::writer out, uint linewidth) -> printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n \n@@ -198,7 +198,7 @@ fn mk_printer(io::writer out, uint linewidth) -> printer {\n  * the method called 'pretty_print', and the 'PRINT' process is the method\n  * called 'print'.\n  */\n-obj printer(io::writer out,\n+obj printer(ioivec::writer out,\n             uint buf_len,\n             mutable int margin, // width of lines we're constrained to\n "}, {"sha": "dd3d98fb45bf5c4c16f372863f20a8d6764a31e7", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -1,7 +1,7 @@\n \n import std::ivec;\n import std::int;\n-import std::io;\n+import std::ioivec;\n import std::str;\n import std::uint;\n import std::vec;\n@@ -57,7 +57,7 @@ fn ibox(&ps s, uint u) {\n \n fn end(&ps s) { ivec::pop(s.boxes); pp::end(s.s); }\n \n-fn rust_printer(io::writer writer) -> ps {\n+fn rust_printer(ioivec::writer writer) -> ps {\n     let pp::breaks[] boxes = ~[];\n     ret @rec(s=pp::mk_printer(writer, default_columns),\n              cm=none[codemap],\n@@ -74,7 +74,7 @@ const uint indent_unit = 4u;\n const uint default_columns = 78u;\n \n fn print_crate(&codemap cm, @ast::crate crate, str filename,\n-               io::writer out, &pp_ann ann) {\n+               ioivec::writer out, &pp_ann ann) {\n     let pp::breaks[] boxes = ~[];\n     auto r = lexer::gather_comments_and_literals(cm, filename);\n     auto s =\n@@ -104,15 +104,15 @@ fn item_to_str(&@ast::item i) -> str { be to_str(i, print_item); }\n fn path_to_str(&ast::path p) -> str { be to_str(p, print_path); }\n \n fn fun_to_str(&ast::_fn f, str name, &ast::ty_param[] params) -> str {\n-    auto writer = io::string_writer();\n+    auto writer = ioivec::string_writer();\n     auto s = rust_printer(writer.get_writer());\n     print_fn(s, f.decl, f.proto, name, params);\n     eof(s.s);\n     ret writer.get_str();\n }\n \n fn block_to_str(&ast::block blk) -> str {\n-    auto writer = io::string_writer();\n+    auto writer = ioivec::string_writer();\n     auto s = rust_printer(writer.get_writer());\n     // containing cbox, will be closed by print-block at }\n \n@@ -1505,7 +1505,7 @@ fn escape_str(str st, char to_escape) -> str {\n }\n \n fn to_str[T](&T t, fn(&ps, &T)  f) -> str {\n-    auto writer = io::string_writer();\n+    auto writer = ioivec::string_writer();\n     auto s = rust_printer(writer.get_writer());\n     f(s, t);\n     eof(s.s);"}, {"sha": "0b2f995135a8ec08d73fc8046fa10248d06bf450", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -14,9 +14,9 @@ import syntax::codemap::span;\n import ast::lit;\n import ast::path;\n import syntax::walk;\n-import std::io::stdout;\n-import std::io::str_writer;\n-import std::io::string_writer;\n+import std::ioivec::stdout;\n+import std::ioivec::str_writer;\n+import std::ioivec::string_writer;\n import syntax::print;\n import print::pprust::print_block;\n import print::pprust::print_item;"}, {"sha": "c1fb0798c0e285955d8534467f697c03dd685063", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be489ee9e2f30d2daf1c9726536631162e21dff5/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=be489ee9e2f30d2daf1c9726536631162e21dff5", "patch": "@@ -1,4 +1,3 @@\n-import std::io;\n import std::ivec;\n import std::str;\n import std::int;"}]}