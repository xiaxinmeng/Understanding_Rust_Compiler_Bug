{"sha": "94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZGRiNTFjOWMwYTUzMTAzZGMwYzJhNGMwMjYwZTcxZjYyZTZlZjg=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-10-23T15:43:18Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-10-28T01:20:08Z"}, "message": "DSTify [T]/str extension traits\n\nThis PR changes the signature of several methods from `foo(self, ...)` to\n`foo(&self, ...)`/`foo(&mut self, ...)`, but there is no breakage of the usage\nof these methods due to the autoref nature of `method.call()`s. This PR also\nremoves the lifetime parameter from some traits (`Trait<'a>` -> `Trait`). These\nchanges break any use of the extension traits for generic programming, but\nthose traits are not meant to be used for generic programming in the first\nplace. In the whole rust distribution there was only one misuse of a extension\ntrait as a bound, which got corrected (the bound was unnecessary and got\nremoved) as part of this PR.\n\n[breaking-change]", "tree": {"sha": "1caa837696e414cc829385da5127f1c3a1fe208b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1caa837696e414cc829385da5127f1c3a1fe208b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8", "html_url": "https://github.com/rust-lang/rust/commit/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/comments", "author": null, "committer": null, "parents": [{"sha": "bd7138dd698dde29fb4d7fd34529a863b85d947e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd7138dd698dde29fb4d7fd34529a863b85d947e", "html_url": "https://github.com/rust-lang/rust/commit/bd7138dd698dde29fb4d7fd34529a863b85d947e"}], "stats": {"total": 465, "additions": 235, "deletions": 230}, "files": [{"sha": "a3fcd890eb2a64f76491c02cb14b523b3eafa4e9", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8", "patch": "@@ -89,6 +89,7 @@\n \n use alloc::boxed::Box;\n use core::cmp;\n+use core::kinds::Sized;\n use core::mem::size_of;\n use core::mem;\n use core::prelude::{Clone, Collection, Greater, Iterator, Less, None, Option};\n@@ -109,7 +110,7 @@ pub use core::slice::{Found, NotFound};\n // Functional utilities\n \n #[allow(missing_doc)]\n-pub trait VectorVector<T> {\n+pub trait VectorVector<T> for Sized? {\n     // FIXME #5898: calling these .concat and .connect conflicts with\n     // StrVector::con{cat,nect}, since they have generic contents.\n     /// Flattens a vector of vectors of `T` into a single `Vec<T>`.\n@@ -119,7 +120,7 @@ pub trait VectorVector<T> {\n     fn connect_vec(&self, sep: &T) -> Vec<T>;\n }\n \n-impl<'a, T: Clone, V: AsSlice<T>> VectorVector<T> for &'a [V] {\n+impl<T: Clone, V: AsSlice<T>> VectorVector<T> for [V] {\n     fn concat_vec(&self) -> Vec<T> {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size);\n@@ -267,17 +268,17 @@ impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n }\n \n /// Extension methods for vector slices with cloneable elements\n-pub trait CloneableVector<T> {\n+pub trait CloneableVector<T> for Sized? {\n     /// Copies `self` into a new `Vec`.\n     fn to_vec(&self) -> Vec<T>;\n }\n \n-impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n+impl<T: Clone> CloneableVector<T> for [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n     fn to_vec(&self) -> Vec<T> {\n         let mut vector = Vec::with_capacity(self.len());\n-        vector.push_all(*self);\n+        vector.push_all(self);\n         vector\n     }\n }\n@@ -300,7 +301,7 @@ impl<T> BoxedSlice<T> for Box<[T]> {\n }\n \n /// Extension methods for vectors containing `Clone` elements.\n-pub trait ImmutableCloneableVector<T> {\n+pub trait ImmutableCloneableVector<T> for Sized? {\n     /// Partitions the vector into two vectors `(a, b)`, where all\n     /// elements of `a` satisfy `f` and all elements of `b` do not.\n     fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>);\n@@ -329,10 +330,10 @@ pub trait ImmutableCloneableVector<T> {\n     /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n     /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n     /// ```\n-    fn permutations(self) -> Permutations<T>;\n+    fn permutations(&self) -> Permutations<T>;\n }\n \n-impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n+impl<T: Clone> ImmutableCloneableVector<T> for [T] {\n     #[inline]\n     fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts  = Vec::new();\n@@ -350,7 +351,7 @@ impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n     }\n \n     /// Returns an iterator over all permutations of a vector.\n-    fn permutations(self) -> Permutations<T> {\n+    fn permutations(&self) -> Permutations<T> {\n         Permutations{\n             swaps: ElementSwaps::new(self.len()),\n             v: self.to_vec(),\n@@ -564,7 +565,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n \n /// Extension methods for vectors such that their elements are\n /// mutable.\n-pub trait MutableSliceAllocating<'a, T> {\n+pub trait MutableSliceAllocating<T> for Sized? {\n     /// Sorts the slice, in place, using `compare` to compare\n     /// elements.\n     ///\n@@ -582,7 +583,7 @@ pub trait MutableSliceAllocating<'a, T> {\n     /// v.sort_by(|a, b| b.cmp(a));\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n-    fn sort_by(self, compare: |&T, &T| -> Ordering);\n+    fn sort_by(&mut self, compare: |&T, &T| -> Ordering);\n \n     /// Consumes `src` and moves as many elements as it can into `self`\n     /// from the range [start,end).\n@@ -605,17 +606,17 @@ pub trait MutableSliceAllocating<'a, T> {\n     /// assert_eq!(num_moved, 3);\n     /// assert!(a == [6i, 7, 8, 4, 5]);\n     /// ```\n-    fn move_from(self, src: Vec<T>, start: uint, end: uint) -> uint;\n+    fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n }\n \n-impl<'a,T> MutableSliceAllocating<'a, T> for &'a mut [T] {\n+impl<T> MutableSliceAllocating<T> for [T] {\n     #[inline]\n-    fn sort_by(self, compare: |&T, &T| -> Ordering) {\n+    fn sort_by(&mut self, compare: |&T, &T| -> Ordering) {\n         merge_sort(self, compare)\n     }\n \n     #[inline]\n-    fn move_from(self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n+    fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n         for (a, b) in self.iter_mut().zip(src[mut start..end].iter_mut()) {\n             mem::swap(a, b);\n         }\n@@ -625,7 +626,7 @@ impl<'a,T> MutableSliceAllocating<'a, T> for &'a mut [T] {\n \n /// Methods for mutable vectors with orderable elements, such as\n /// in-place sorting.\n-pub trait MutableOrdSlice<T> {\n+pub trait MutableOrdSlice<T> for Sized? {\n     /// Sorts the slice, in place.\n     ///\n     /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n@@ -638,7 +639,7 @@ pub trait MutableOrdSlice<T> {\n     /// v.sort();\n     /// assert!(v == [-5i, -3, 1, 2, 4]);\n     /// ```\n-    fn sort(self);\n+    fn sort(&mut self);\n \n     /// Mutates the slice to the next lexicographic permutation.\n     ///\n@@ -656,7 +657,7 @@ pub trait MutableOrdSlice<T> {\n     /// let b: &mut [_] = &mut [1i, 0, 2];\n     /// assert!(v == b);\n     /// ```\n-    fn next_permutation(self) -> bool;\n+    fn next_permutation(&mut self) -> bool;\n \n     /// Mutates the slice to the previous lexicographic permutation.\n     ///\n@@ -674,16 +675,16 @@ pub trait MutableOrdSlice<T> {\n     /// let b: &mut [_] = &mut [0i, 1, 2];\n     /// assert!(v == b);\n     /// ```\n-    fn prev_permutation(self) -> bool;\n+    fn prev_permutation(&mut self) -> bool;\n }\n \n-impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n+impl<T: Ord> MutableOrdSlice<T> for [T] {\n     #[inline]\n-    fn sort(self) {\n-        self.sort_by(|a,b| a.cmp(b))\n+    fn sort(&mut self) {\n+        self.sort_by(|a, b| a.cmp(b))\n     }\n \n-    fn next_permutation(self) -> bool {\n+    fn next_permutation(&mut self) -> bool {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n \n@@ -713,7 +714,7 @@ impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n         true\n     }\n \n-    fn prev_permutation(self) -> bool {\n+    fn prev_permutation(&mut self) -> bool {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n "}, {"sha": "9cd8bde4a95b373485bbf9333759269ed40d0108", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8", "patch": "@@ -58,6 +58,7 @@ use core::default::Default;\n use core::fmt;\n use core::cmp;\n use core::iter::AdditiveIterator;\n+use core::kinds::Sized;\n use core::prelude::{Char, Clone, Collection, Eq, Equiv, ImmutableSlice};\n use core::prelude::{Iterator, MutableSlice, None, Option, Ord, Ordering};\n use core::prelude::{PartialEq, PartialOrd, Result, AsSlice, Some, Tuple2};\n@@ -84,7 +85,7 @@ Section: Creating a string\n */\n \n /// Methods for vectors of strings.\n-pub trait StrVector {\n+pub trait StrVector for Sized? {\n     /// Concatenates a vector of strings.\n     ///\n     /// # Example\n@@ -110,7 +111,7 @@ pub trait StrVector {\n     fn connect(&self, sep: &str) -> String;\n }\n \n-impl<'a, S: Str> StrVector for &'a [S] {\n+impl<S: Str> StrVector for [S] {\n     fn concat(&self) -> String {\n         if self.is_empty() {\n             return String::new();\n@@ -157,7 +158,7 @@ impl<'a, S: Str> StrVector for &'a [S] {\n     }\n }\n \n-impl<'a, S: Str> StrVector for Vec<S> {\n+impl<S: Str> StrVector for Vec<S> {\n     #[inline]\n     fn concat(&self) -> String {\n         self.as_slice().concat()"}, {"sha": "16342dcae779fd2ede7ea2e4deb24c3a288d16c5", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8", "patch": "@@ -19,6 +19,7 @@\n //! Their definition should always match the ABI defined in `rustc::back::abi`.\n \n use mem;\n+use kinds::Sized;\n \n /// The representation of a Rust slice\n #[repr(C)]\n@@ -53,14 +54,14 @@ pub struct TraitObject {\n \n /// This trait is meant to map equivalences between raw structs and their\n /// corresponding rust values.\n-pub trait Repr<T> {\n+pub trait Repr<T> for Sized? {\n     /// This function \"unwraps\" a rust value (without consuming it) into its raw\n     /// struct representation. This can be used to read/write different values\n     /// for the struct. This is a safe method because by default it does not\n     /// enable write-access to the fields of the return value in safe code.\n     #[inline]\n-    fn repr(&self) -> T { unsafe { mem::transmute_copy(self) } }\n+    fn repr(&self) -> T { unsafe { mem::transmute_copy(&self) } }\n }\n \n-impl<'a, T> Repr<Slice<T>> for &'a [T] {}\n-impl<'a> Repr<Slice<u8>> for &'a str {}\n+impl<T> Repr<Slice<T>> for [T] {}\n+impl Repr<Slice<u8>> for str {}"}, {"sha": "aadf540afbe20f6abb1cb11fdf6f34eb521f9b8e", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 109, "deletions": 110, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8", "patch": "@@ -48,7 +48,7 @@ use ptr;\n use ptr::RawPtr;\n use mem;\n use mem::size_of;\n-use kinds::marker;\n+use kinds::{Sized, marker};\n use raw::Repr;\n // Avoid conflicts with *both* the Slice trait (buggy) and the `slice::raw` module.\n use raw::Slice as RawSlice;\n@@ -60,31 +60,31 @@ use raw::Slice as RawSlice;\n \n /// Extension methods for immutable slices.\n #[unstable = \"may merge with other traits; region parameter may disappear\"]\n-pub trait ImmutableSlice<'a, T> {\n+pub trait ImmutableSlice<T> for Sized? {\n     /// Returns a subslice spanning the interval [`start`, `end`).\n     ///\n     /// Fails when the end of the new slice lies beyond the end of the\n     /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n     #[unstable = \"waiting on final error conventions/slicing syntax\"]\n-    fn slice(&self, start: uint, end: uint) -> &'a [T];\n+    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T];\n \n     /// Returns a subslice from `start` to the end of the slice.\n     ///\n     /// Fails when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[unstable = \"waiting on final error conventions/slicing syntax\"]\n-    fn slice_from(&self, start: uint) -> &'a [T];\n+    fn slice_from<'a>(&'a self, start: uint) -> &'a [T];\n \n     /// Returns a subslice from the start of the slice to `end`.\n     ///\n     /// Fails when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[unstable = \"waiting on final error conventions/slicing syntax\"]\n-    fn slice_to(&self, end: uint) -> &'a [T];\n+    fn slice_to<'a>(&'a self, end: uint) -> &'a [T];\n \n     /// Divides one slice into two at an index.\n     ///\n@@ -94,29 +94,29 @@ pub trait ImmutableSlice<'a, T> {\n     ///\n     /// Fails if `mid > len`.\n     #[unstable = \"waiting on final error conventions\"]\n-    fn split_at(&self, mid: uint) -> (&'a [T], &'a [T]);\n+    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]);\n \n     /// Returns an iterator over the slice\n     #[unstable = \"iterator type may change\"]\n-    fn iter(self) -> Items<'a, T>;\n+    fn iter<'a>(&'a self) -> Items<'a, T>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n     #[unstable = \"iterator type may change, waiting on unboxed closures\"]\n-    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n+    fn split<'a>(&'a self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[unstable = \"iterator type may change\"]\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>>;\n+    fn splitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[unstable = \"iterator type may change\"]\n-    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>>;\n+    fn rsplitn<'a>(&'a self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>>;\n \n     /// Returns an iterator over all contiguous windows of length\n     /// `size`. The windows overlap. If the slice is shorter than\n@@ -138,7 +138,7 @@ pub trait ImmutableSlice<'a, T> {\n     /// }\n     /// ```\n     #[unstable = \"iterator type may change\"]\n-    fn windows(self, size: uint) -> Windows<'a, T>;\n+    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T>;\n \n     /// Returns an iterator over `size` elements of the slice at a\n     /// time. The chunks do not overlap. If `size` does not divide the\n@@ -161,33 +161,33 @@ pub trait ImmutableSlice<'a, T> {\n     /// }\n     /// ```\n     #[unstable = \"iterator type may change\"]\n-    fn chunks(self, size: uint) -> Chunks<'a, T>;\n+    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T>;\n \n     /// Returns the element of a slice at the given index, or `None` if the\n     /// index is out of bounds.\n     #[unstable = \"waiting on final collection conventions\"]\n-    fn get(&self, index: uint) -> Option<&'a T>;\n+    fn get<'a>(&'a self, index: uint) -> Option<&'a T>;\n \n     /// Returns the first element of a slice, or `None` if it is empty.\n     #[unstable = \"name may change\"]\n-    fn head(&self) -> Option<&'a T>;\n+    fn head<'a>(&'a self) -> Option<&'a T>;\n \n     /// Returns all but the first element of a slice.\n     #[unstable = \"name may change\"]\n-    fn tail(&self) -> &'a [T];\n+    fn tail<'a>(&'a self) -> &'a [T];\n \n     /// Returns all but the last element of a slice.\n     #[unstable = \"name may change\"]\n-    fn init(&self) -> &'a [T];\n+    fn init<'a>(&'a self) -> &'a [T];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n     #[unstable = \"name may change\"]\n-    fn last(&self) -> Option<&'a T>;\n+    fn last<'a>(&'a self) -> Option<&'a T>;\n \n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[unstable]\n-    unsafe fn unsafe_get(self, index: uint) -> &'a T;\n+    unsafe fn unsafe_get<'a>(&'a self, index: uint) -> &'a T;\n \n     /// Returns an unsafe pointer to the slice's buffer\n     ///\n@@ -237,9 +237,9 @@ pub trait ImmutableSlice<'a, T> {\n }\n \n #[unstable]\n-impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n+impl<T> ImmutableSlice<T> for [T] {\n     #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n+    fn slice(&self, start: uint, end: uint) -> &[T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n         unsafe {\n@@ -251,22 +251,22 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn slice_from(&self, start: uint) -> &'a [T] {\n+    fn slice_from(&self, start: uint) -> &[T] {\n         self.slice(start, self.len())\n     }\n \n     #[inline]\n-    fn slice_to(&self, end: uint) -> &'a [T] {\n+    fn slice_to(&self, end: uint) -> &[T] {\n         self.slice(0, end)\n     }\n \n     #[inline]\n-    fn split_at(&self, mid: uint) -> (&'a [T], &'a [T]) {\n-        ((*self)[..mid], (*self)[mid..])\n+    fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n+        (self[..mid], self[mid..])\n     }\n \n     #[inline]\n-    fn iter(self) -> Items<'a, T> {\n+    fn iter<'a>(&'a self) -> Items<'a, T> {\n         unsafe {\n             let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n@@ -282,7 +282,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n+    fn split<'a>(&'a self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n         Splits {\n             v: self,\n             pred: pred,\n@@ -291,7 +291,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n+    fn splitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n         SplitsN {\n             iter: self.split(pred),\n             count: n,\n@@ -300,7 +300,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n+    fn rsplitn<'a>(&'a self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n         SplitsN {\n             iter: self.split(pred),\n             count: n,\n@@ -309,42 +309,42 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn windows(self, size: uint) -> Windows<'a, T> {\n+    fn windows(&self, size: uint) -> Windows<T> {\n         assert!(size != 0);\n         Windows { v: self, size: size }\n     }\n \n     #[inline]\n-    fn chunks(self, size: uint) -> Chunks<'a, T> {\n+    fn chunks(&self, size: uint) -> Chunks<T> {\n         assert!(size != 0);\n         Chunks { v: self, size: size }\n     }\n \n     #[inline]\n-    fn get(&self, index: uint) -> Option<&'a T> {\n+    fn get(&self, index: uint) -> Option<&T> {\n         if index < self.len() { Some(&self[index]) } else { None }\n     }\n \n     #[inline]\n-    fn head(&self) -> Option<&'a T> {\n+    fn head(&self) -> Option<&T> {\n         if self.len() == 0 { None } else { Some(&self[0]) }\n     }\n \n     #[inline]\n-    fn tail(&self) -> &'a [T] { (*self)[1..] }\n+    fn tail(&self) -> &[T] { self[1..] }\n \n     #[inline]\n-    fn init(&self) -> &'a [T] {\n-        (*self)[..self.len() - 1]\n+    fn init(&self) -> &[T] {\n+        self[..self.len() - 1]\n     }\n \n     #[inline]\n-    fn last(&self) -> Option<&'a T> {\n+    fn last(&self) -> Option<&T> {\n         if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n     }\n \n     #[inline]\n-    unsafe fn unsafe_get(self, index: uint) -> &'a T {\n+    unsafe fn unsafe_get(&self, index: uint) -> &T {\n         transmute(self.repr().data.offset(index as int))\n     }\n \n@@ -436,14 +436,14 @@ impl<T> ops::SliceMut<uint, [T]> for [T] {\n /// Extension methods for slices such that their elements are\n /// mutable.\n #[experimental = \"may merge with other traits; may lose region param; needs review\"]\n-pub trait MutableSlice<'a, T> {\n+pub trait MutableSlice<T> for Sized? {\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n     #[unstable = \"waiting on final error conventions\"]\n-    fn get_mut(self, index: uint) -> Option<&'a mut T>;\n+    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T>;\n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T, ..N].\n-    fn as_mut_slice(self) -> &'a mut [T];\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T];\n \n     /// Returns a mutable subslice spanning the interval [`start`, `end`).\n     ///\n@@ -452,61 +452,61 @@ pub trait MutableSlice<'a, T> {\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n     #[unstable = \"waiting on final error conventions\"]\n-    fn slice_mut(self, start: uint, end: uint) -> &'a mut [T];\n+    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T];\n \n     /// Returns a mutable subslice from `start` to the end of the slice.\n     ///\n     /// Fails when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[unstable = \"waiting on final error conventions\"]\n-    fn slice_from_mut(self, start: uint) -> &'a mut [T];\n+    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T];\n \n     /// Returns a mutable subslice from the start of the slice to `end`.\n     ///\n     /// Fails when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[unstable = \"waiting on final error conventions\"]\n-    fn slice_to_mut(self, end: uint) -> &'a mut [T];\n+    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T];\n \n     /// Returns an iterator that allows modifying each value\n     #[unstable = \"waiting on iterator type name conventions\"]\n-    fn iter_mut(self) -> MutItems<'a, T>;\n+    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T>;\n \n     /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n     #[unstable = \"name may change\"]\n-    fn head_mut(self) -> Option<&'a mut T>;\n+    fn head_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n \n     /// Returns all but the first element of a mutable slice\n     #[unstable = \"name may change\"]\n-    fn tail_mut(self) -> &'a mut [T];\n+    fn tail_mut<'a>(&'a mut self) -> &'a mut [T];\n \n     /// Returns all but the last element of a mutable slice\n     #[unstable = \"name may change\"]\n-    fn init_mut(self) -> &'a mut [T];\n+    fn init_mut<'a>(&'a mut self) -> &'a mut [T];\n \n     /// Returns a mutable pointer to the last item in the slice.\n     #[unstable = \"name may change\"]\n-    fn last_mut(self) -> Option<&'a mut T>;\n+    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n \n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn split_mut(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n+    fn split_mut<'a>(&'a mut self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn splitn_mut(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>>;\n+    fn splitn_mut<'a>(&'a mut self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn rsplitn_mut(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>>;\n+    fn rsplitn_mut<'a>(&'a mut self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>>;\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable and do not overlap. If `chunk_size` does\n@@ -517,7 +517,7 @@ pub trait MutableSlice<'a, T> {\n     ///\n     /// Fails if `chunk_size` is 0.\n     #[unstable = \"waiting on iterator type name conventions\"]\n-    fn chunks_mut(self, chunk_size: uint) -> MutChunks<'a, T>;\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> MutChunks<'a, T>;\n \n     /// Swaps two elements in a slice.\n     ///\n@@ -536,7 +536,7 @@ pub trait MutableSlice<'a, T> {\n     /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n     /// ```\n     #[unstable = \"waiting on final error conventions\"]\n-    fn swap(self, a: uint, b: uint);\n+    fn swap(&mut self, a: uint, b: uint);\n \n     /// Divides one `&mut` into two at an index.\n     ///\n@@ -571,7 +571,7 @@ pub trait MutableSlice<'a, T> {\n     /// }\n     /// ```\n     #[unstable = \"waiting on final error conventions\"]\n-    fn split_at_mut(self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n+    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n \n     /// Reverse the order of elements in a slice, in place.\n     ///\n@@ -583,11 +583,11 @@ pub trait MutableSlice<'a, T> {\n     /// assert!(v == [3i, 2, 1]);\n     /// ```\n     #[experimental = \"may be moved to iterators instead\"]\n-    fn reverse(self);\n+    fn reverse(&mut self);\n \n     /// Returns an unsafe mutable pointer to the element in index\n     #[experimental = \"waiting on unsafe conventions\"]\n-    unsafe fn unsafe_mut(self, index: uint) -> &'a mut T;\n+    unsafe fn unsafe_mut<'a>(&'a mut self, index: uint) -> &'a mut T;\n \n     /// Return an unsafe mutable pointer to the slice's buffer.\n     ///\n@@ -598,43 +598,43 @@ pub trait MutableSlice<'a, T> {\n     /// would also make any pointers to it invalid.\n     #[inline]\n     #[unstable]\n-    fn as_mut_ptr(self) -> *mut T;\n+    fn as_mut_ptr(&mut self) -> *mut T;\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n+impl<T> MutableSlice<T> for [T] {\n     #[inline]\n-    fn get_mut(self, index: uint) -> Option<&'a mut T> {\n+    fn get_mut(&mut self, index: uint) -> Option<&mut T> {\n         if index < self.len() { Some(&mut self[index]) } else { None }\n     }\n \n     #[inline]\n-    fn as_mut_slice(self) -> &'a mut [T] { self }\n+    fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n-    fn slice_mut(self, start: uint, end: uint) -> &'a mut [T] {\n+    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T] {\n         self[mut start..end]\n     }\n \n     #[inline]\n-    fn slice_from_mut(self, start: uint) -> &'a mut [T] {\n+    fn slice_from_mut(&mut self, start: uint) -> &mut [T] {\n         self[mut start..]\n     }\n \n     #[inline]\n-    fn slice_to_mut(self, end: uint) -> &'a mut [T] {\n+    fn slice_to_mut(&mut self, end: uint) -> &mut [T] {\n         self[mut ..end]\n     }\n \n     #[inline]\n-    fn split_at_mut(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n+    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]) {\n         unsafe {\n-            let self2: &'a mut [T] = mem::transmute_copy(&self);\n+            let self2: &mut [T] = mem::transmute_copy(&self);\n             (self[mut ..mid], self2[mut mid..])\n         }\n     }\n \n     #[inline]\n-    fn iter_mut(self) -> MutItems<'a, T> {\n+    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n         unsafe {\n             let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n@@ -652,36 +652,36 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n-    fn last_mut(self) -> Option<&'a mut T> {\n+    fn last_mut(&mut self) -> Option<&mut T> {\n         let len = self.len();\n         if len == 0 { return None; }\n         Some(&mut self[len - 1])\n     }\n \n     #[inline]\n-    fn head_mut(self) -> Option<&'a mut T> {\n+    fn head_mut(&mut self) -> Option<&mut T> {\n         if self.len() == 0 { None } else { Some(&mut self[0]) }\n     }\n \n     #[inline]\n-    fn tail_mut(self) -> &'a mut [T] {\n+    fn tail_mut(&mut self) -> &mut [T] {\n         let len = self.len();\n         self[mut 1..len]\n     }\n \n     #[inline]\n-    fn init_mut(self) -> &'a mut [T] {\n+    fn init_mut(&mut self) -> &mut [T] {\n         let len = self.len();\n         self[mut 0..len - 1]\n     }\n \n     #[inline]\n-    fn split_mut(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n+    fn split_mut<'a>(&'a mut self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n         MutSplits { v: self, pred: pred, finished: false }\n     }\n \n     #[inline]\n-    fn splitn_mut(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>> {\n+    fn splitn_mut<'a>(&'a mut self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>> {\n         SplitsN {\n             iter: self.split_mut(pred),\n             count: n,\n@@ -690,7 +690,7 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n-    fn rsplitn_mut(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>> {\n+    fn rsplitn_mut<'a>(&'a mut self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>> {\n         SplitsN {\n             iter: self.split_mut(pred),\n             count: n,\n@@ -699,12 +699,12 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n    }\n \n     #[inline]\n-    fn chunks_mut(self, chunk_size: uint) -> MutChunks<'a, T> {\n+    fn chunks_mut(&mut self, chunk_size: uint) -> MutChunks<T> {\n         assert!(chunk_size > 0);\n         MutChunks { v: self, chunk_size: chunk_size }\n     }\n \n-    fn swap(self, a: uint, b: uint) {\n+    fn swap(&mut self, a: uint, b: uint) {\n         unsafe {\n             // Can't take two mutable loans from one vector, so instead just cast\n             // them to their raw pointers to do the swap\n@@ -714,7 +714,7 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n         }\n     }\n \n-    fn reverse(self) {\n+    fn reverse(&mut self) {\n         let mut i: uint = 0;\n         let ln = self.len();\n         while i < ln / 2 {\n@@ -729,19 +729,19 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n-    unsafe fn unsafe_mut(self, index: uint) -> &'a mut T {\n+    unsafe fn unsafe_mut(&mut self, index: uint) -> &mut T {\n         transmute((self.repr().data as *mut T).offset(index as int))\n     }\n \n     #[inline]\n-    fn as_mut_ptr(self) -> *mut T {\n+    fn as_mut_ptr(&mut self) -> *mut T {\n         self.repr().data as *mut T\n     }\n }\n \n /// Extension methods for slices containing `PartialEq` elements.\n #[unstable = \"may merge with other traits\"]\n-pub trait ImmutablePartialEqSlice<T:PartialEq> {\n+pub trait ImmutablePartialEqSlice<T: PartialEq> for Sized? {\n     /// Find the first index containing a matching value.\n     fn position_elem(&self, t: &T) -> Option<uint>;\n \n@@ -759,7 +759,7 @@ pub trait ImmutablePartialEqSlice<T:PartialEq> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a,T:PartialEq> ImmutablePartialEqSlice<T> for &'a [T] {\n+impl<T: PartialEq> ImmutablePartialEqSlice<T> for [T] {\n     #[inline]\n     fn position_elem(&self, x: &T) -> Option<uint> {\n         self.iter().position(|y| *x == *y)\n@@ -778,19 +778,19 @@ impl<'a,T:PartialEq> ImmutablePartialEqSlice<T> for &'a [T] {\n     #[inline]\n     fn starts_with(&self, needle: &[T]) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle == (*self)[..n]\n+        self.len() >= n && needle == self[..n]\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &[T]) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == (*self)[m-n..]\n+        m >= n && needle == self[m-n..]\n     }\n }\n \n /// Extension methods for slices containing `Ord` elements.\n #[unstable = \"may merge with other traits\"]\n-pub trait ImmutableOrdSlice<T: Ord> {\n+pub trait ImmutableOrdSlice<T: Ord> for Sized? {\n     /// Binary search a sorted slice for a given element.\n     ///\n     /// If the value is found then `Found` is returned, containing the\n@@ -820,7 +820,7 @@ pub trait ImmutableOrdSlice<T: Ord> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, T: Ord> ImmutableOrdSlice<T> for &'a [T] {\n+impl<T: Ord> ImmutableOrdSlice<T> for [T] {\n     #[unstable]\n     fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n         self.binary_search(|p| p.cmp(x))\n@@ -829,7 +829,7 @@ impl<'a, T: Ord> ImmutableOrdSlice<T> for &'a [T] {\n \n /// Trait for &[T] where T is Cloneable\n #[unstable = \"may merge with other traits\"]\n-pub trait MutableCloneableSlice<T> {\n+pub trait MutableCloneableSlice<T> for Sized? {\n     /// Copies as many elements from `src` as it can into `self` (the\n     /// shorter of `self.len()` and `src.len()`). Returns the number\n     /// of elements copied.\n@@ -849,13 +849,13 @@ pub trait MutableCloneableSlice<T> {\n     /// assert!(dst.clone_from_slice(src2) == 3);\n     /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    fn clone_from_slice(self, &[T]) -> uint;\n+    fn clone_from_slice(&mut self, &[T]) -> uint;\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, T: Clone> MutableCloneableSlice<T> for &'a mut [T] {\n+impl<T: Clone> MutableCloneableSlice<T> for [T] {\n     #[inline]\n-    fn clone_from_slice(self, src: &[T]) -> uint {\n+    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n         let min = cmp::min(self.len(), src.len());\n         let dst = self.slice_to_mut(min);\n         let src = src.slice_to(min);\n@@ -1509,19 +1509,20 @@ pub mod raw {\n #[experimental = \"needs review\"]\n pub mod bytes {\n     use collections::Collection;\n+    use kinds::Sized;\n     use ptr;\n     use slice::{ImmutableSlice, MutableSlice};\n \n     /// A trait for operations on mutable `[u8]`s.\n-    pub trait MutableByteVector {\n+    pub trait MutableByteVector for Sized? {\n         /// Sets all bytes of the receiver to the given value.\n-        fn set_memory(self, value: u8);\n+        fn set_memory(&mut self, value: u8);\n     }\n \n-    impl<'a> MutableByteVector for &'a mut [u8] {\n+    impl MutableByteVector for [u8] {\n         #[inline]\n         #[allow(experimental)]\n-        fn set_memory(self, value: u8) {\n+        fn set_memory(&mut self, value: u8) {\n             unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n         }\n     }\n@@ -1623,53 +1624,51 @@ impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n \n /// Extension methods for immutable slices containing integers.\n #[experimental]\n-pub trait ImmutableIntSlice<'a, U, S> {\n+pub trait ImmutableIntSlice<U, S> for Sized? {\n     /// Converts the slice to an immutable slice of unsigned integers with the same width.\n-    fn as_unsigned(self) -> &'a [U];\n+    fn as_unsigned<'a>(&'a self) -> &'a [U];\n     /// Converts the slice to an immutable slice of signed integers with the same width.\n-    fn as_signed(self) -> &'a [S];\n+    fn as_signed<'a>(&'a self) -> &'a [S];\n }\n \n /// Extension methods for mutable slices containing integers.\n #[experimental]\n-pub trait MutableIntSlice<'a, U, S>: ImmutableIntSlice<'a, U, S> {\n+pub trait MutableIntSlice<U, S> for Sized?: ImmutableIntSlice<U, S> {\n     /// Converts the slice to a mutable slice of unsigned integers with the same width.\n-    fn as_unsigned_mut(self) -> &'a mut [U];\n+    fn as_unsigned_mut<'a>(&'a mut self) -> &'a mut [U];\n     /// Converts the slice to a mutable slice of signed integers with the same width.\n-    fn as_signed_mut(self) -> &'a mut [S];\n+    fn as_signed_mut<'a>(&'a mut self) -> &'a mut [S];\n }\n \n macro_rules! impl_immut_int_slice {\n     ($u:ty, $s:ty, $t:ty) => {\n         #[experimental]\n-        impl<'a> ImmutableIntSlice<'a, $u, $s> for $t {\n+        impl ImmutableIntSlice<$u, $s> for [$t] {\n             #[inline]\n-            fn as_unsigned(self) -> &'a [$u] { unsafe { transmute(self) } }\n+            fn as_unsigned(&self) -> &[$u] { unsafe { transmute(self) } }\n             #[inline]\n-            fn as_signed(self) -> &'a [$s] { unsafe { transmute(self) } }\n+            fn as_signed(&self) -> &[$s] { unsafe { transmute(self) } }\n         }\n     }\n }\n macro_rules! impl_mut_int_slice {\n     ($u:ty, $s:ty, $t:ty) => {\n         #[experimental]\n-        impl<'a> MutableIntSlice<'a, $u, $s> for $t {\n+        impl MutableIntSlice<$u, $s> for [$t] {\n             #[inline]\n-            fn as_unsigned_mut(self) -> &'a mut [$u] { unsafe { transmute(self) } }\n+            fn as_unsigned_mut(&mut self) -> &mut [$u] { unsafe { transmute(self) } }\n             #[inline]\n-            fn as_signed_mut(self) -> &'a mut [$s] { unsafe { transmute(self) } }\n+            fn as_signed_mut(&mut self) -> &mut [$s] { unsafe { transmute(self) } }\n         }\n     }\n }\n \n macro_rules! impl_int_slice {\n     ($u:ty, $s:ty) => {\n-        impl_immut_int_slice!($u, $s, &'a [$u])\n-        impl_immut_int_slice!($u, $s, &'a [$s])\n-        impl_immut_int_slice!($u, $s, &'a mut [$u])\n-        impl_immut_int_slice!($u, $s, &'a mut [$s])\n-        impl_mut_int_slice!($u, $s, &'a mut [$u])\n-        impl_mut_int_slice!($u, $s, &'a mut [$s])\n+        impl_immut_int_slice!($u, $s, $u)\n+        impl_immut_int_slice!($u, $s, $s)\n+        impl_mut_int_slice!($u, $s, $u)\n+        impl_mut_int_slice!($u, $s, $s)\n     }\n }\n "}, {"sha": "0c2415753faf0b681254ed6e95636b1d1f947a83", "filename": "src/libcore/str.rs", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8", "patch": "@@ -27,6 +27,7 @@ use default::Default;\n use iter::{Map, Iterator};\n use iter::{DoubleEndedIterator, ExactSize};\n use iter::range;\n+use kinds::Sized;\n use num::{CheckedMul, Saturating};\n use option::{Option, None, Some};\n use raw::Repr;\n@@ -1206,7 +1207,7 @@ impl<'a> Collection for &'a str {\n }\n \n /// Methods for string slices\n-pub trait StrSlice<'a> {\n+pub trait StrSlice for Sized? {\n     /// Returns true if one string contains another\n     ///\n     /// # Arguments\n@@ -1218,7 +1219,7 @@ pub trait StrSlice<'a> {\n     /// ```rust\n     /// assert!(\"bananas\".contains(\"nana\"));\n     /// ```\n-    fn contains<'a>(&self, needle: &'a str) -> bool;\n+    fn contains(&self, needle: &str) -> bool;\n \n     /// Returns true if a string contains a char.\n     ///\n@@ -1242,7 +1243,7 @@ pub trait StrSlice<'a> {\n     /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n     /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n-    fn chars(&self) -> Chars<'a>;\n+    fn chars<'a>(&'a self) -> Chars<'a>;\n \n     /// An iterator over the bytes of `self`\n     ///\n@@ -1252,10 +1253,10 @@ pub trait StrSlice<'a> {\n     /// let v: Vec<u8> = \"bors\".bytes().collect();\n     /// assert_eq!(v, b\"bors\".to_vec());\n     /// ```\n-    fn bytes(&self) -> Bytes<'a>;\n+    fn bytes<'a>(&'a self) -> Bytes<'a>;\n \n     /// An iterator over the characters of `self` and their byte offsets.\n-    fn char_indices(&self) -> CharOffsets<'a>;\n+    fn char_indices<'a>(&'a self) -> CharOffsets<'a>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n@@ -1275,7 +1276,7 @@ pub trait StrSlice<'a> {\n     /// let v: Vec<&str> = \"\".split('X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n+    fn split<'a, Sep: CharEq>(&'a self, sep: Sep) -> CharSplits<'a, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, restricted to splitting at most `count`\n@@ -1299,7 +1300,7 @@ pub trait StrSlice<'a> {\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n-    fn splitn<Sep: CharEq>(&self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n+    fn splitn<'a, Sep: CharEq>(&'a self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n@@ -1325,7 +1326,7 @@ pub trait StrSlice<'a> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n-    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n+    fn split_terminator<'a, Sep: CharEq>(&'a self, sep: Sep) -> CharSplits<'a, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, starting from the end of the string.\n@@ -1343,7 +1344,7 @@ pub trait StrSlice<'a> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n-    fn rsplitn<Sep: CharEq>(&self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n+    fn rsplitn<'a, Sep: CharEq>(&'a self, count: uint, sep: Sep) -> CharSplitsN<'a, Sep>;\n \n     /// An iterator over the start and end indices of the disjoint\n     /// matches of `sep` within `self`.\n@@ -1365,7 +1366,7 @@ pub trait StrSlice<'a> {\n     /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n     /// ```\n-    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a>;\n+    fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a>;\n \n     /// An iterator over the substrings of `self` separated by `sep`.\n     ///\n@@ -1378,7 +1379,7 @@ pub trait StrSlice<'a> {\n     /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n     /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n     /// ```\n-    fn split_str(&self, &'a str) -> StrSplits<'a>;\n+    fn split_str<'a>(&'a self, &'a str) -> StrSplits<'a>;\n \n     /// An iterator over the lines of a string (subsequences separated\n     /// by `\\n`). This does not include the empty string after a\n@@ -1391,7 +1392,7 @@ pub trait StrSlice<'a> {\n     /// let v: Vec<&str> = four_lines.lines().collect();\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    fn lines(&self) -> CharSplits<'a, char>;\n+    fn lines<'a>(&'a self) -> CharSplits<'a, char>;\n \n     /// An iterator over the lines of a string, separated by either\n     /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n@@ -1404,7 +1405,7 @@ pub trait StrSlice<'a> {\n     /// let v: Vec<&str> = four_lines.lines_any().collect();\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    fn lines_any(&self) -> AnyLines<'a>;\n+    fn lines_any<'a>(&'a self) -> AnyLines<'a>;\n \n     /// Returns the number of Unicode code points (`char`) that a\n     /// string holds.\n@@ -1469,7 +1470,7 @@ pub trait StrSlice<'a> {\n     /// // byte 100 is outside the string\n     /// // s.slice(3, 100);\n     /// ```\n-    fn slice(&self, begin: uint, end: uint) -> &'a str;\n+    fn slice<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n \n     /// Returns a slice of the string from `begin` to its end.\n     ///\n@@ -1479,7 +1480,7 @@ pub trait StrSlice<'a> {\n     /// out of bounds.\n     ///\n     /// See also `slice`, `slice_to` and `slice_chars`.\n-    fn slice_from(&self, begin: uint) -> &'a str;\n+    fn slice_from<'a>(&'a self, begin: uint) -> &'a str;\n \n     /// Returns a slice of the string from the beginning to byte\n     /// `end`.\n@@ -1490,7 +1491,7 @@ pub trait StrSlice<'a> {\n     /// out of bounds.\n     ///\n     /// See also `slice`, `slice_from` and `slice_chars`.\n-    fn slice_to(&self, end: uint) -> &'a str;\n+    fn slice_to<'a>(&'a self, end: uint) -> &'a str;\n \n     /// Returns a slice of the string from the character range\n     /// [`begin`..`end`).\n@@ -1515,7 +1516,7 @@ pub trait StrSlice<'a> {\n     /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n     /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n     /// ```\n-    fn slice_chars(&self, begin: uint, end: uint) -> &'a str;\n+    fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n \n     /// Returns true if `needle` is a prefix of the string.\n     ///\n@@ -1549,7 +1550,7 @@ pub trait StrSlice<'a> {\n     /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\")\n     /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\")\n     /// ```\n-    fn trim_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n+    fn trim_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n \n     /// Returns a string with leading `chars_to_trim` removed.\n     ///\n@@ -1565,7 +1566,7 @@ pub trait StrSlice<'a> {\n     /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\")\n     /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\")\n     /// ```\n-    fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n+    fn trim_left_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n \n     /// Returns a string with trailing `chars_to_trim` removed.\n     ///\n@@ -1581,7 +1582,7 @@ pub trait StrSlice<'a> {\n     /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\")\n     /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\")\n     /// ```\n-    fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n+    fn trim_right_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n \n     /// Check that `index`-th byte lies at the start and/or end of a\n     /// UTF-8 code point sequence.\n@@ -1707,7 +1708,7 @@ pub trait StrSlice<'a> {\n     /// ```rust\n     /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n     /// ```\n-    fn as_bytes(&self) -> &'a [u8];\n+    fn as_bytes<'a>(&'a self) -> &'a [u8];\n \n     /// Returns the byte index of the first character of `self` that\n     /// matches `search`.\n@@ -1798,7 +1799,7 @@ pub trait StrSlice<'a> {\n     /// assert_eq!(c, Some('\u00f6'));\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    fn slice_shift_char(&self) -> (Option<char>, &'a str);\n+    fn slice_shift_char<'a>(&'a self) -> (Option<char>, &'a str);\n \n     /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n     ///\n@@ -1825,7 +1826,7 @@ pub trait StrSlice<'a> {\n     fn as_ptr(&self) -> *const u8;\n \n     /// Return an iterator of `u16` over the string encoded as UTF-16.\n-    fn utf16_units(&self) -> Utf16CodeUnits<'a>;\n+    fn utf16_units<'a>(&'a self) -> Utf16CodeUnits<'a>;\n }\n \n #[inline(never)]\n@@ -1835,9 +1836,9 @@ fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n           begin, end, s);\n }\n \n-impl<'a> StrSlice<'a> for &'a str {\n+impl StrSlice for str {\n     #[inline]\n-    fn contains<'a>(&self, needle: &'a str) -> bool {\n+    fn contains(&self, needle: &str) -> bool {\n         self.find_str(needle).is_some()\n     }\n \n@@ -1847,24 +1848,24 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn chars(&self) -> Chars<'a> {\n+    fn chars(&self) -> Chars {\n         Chars{iter: self.as_bytes().iter()}\n     }\n \n     #[inline]\n-    fn bytes(&self) -> Bytes<'a> {\n+    fn bytes(&self) -> Bytes {\n         self.as_bytes().iter().map(|&b| b)\n     }\n \n     #[inline]\n-    fn char_indices(&self) -> CharOffsets<'a> {\n+    fn char_indices(&self) -> CharOffsets {\n         CharOffsets{front_offset: 0, iter: self.chars()}\n     }\n \n     #[inline]\n-    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep> {\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<Sep> {\n         CharSplits {\n-            string: *self,\n+            string: self,\n             only_ascii: sep.only_ascii(),\n             sep: sep,\n             allow_trailing_empty: true,\n@@ -1874,7 +1875,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn splitn<Sep: CharEq>(&self, count: uint, sep: Sep)\n-        -> CharSplitsN<'a, Sep> {\n+        -> CharSplitsN<Sep> {\n         CharSplitsN {\n             iter: self.split(sep),\n             count: count,\n@@ -1884,7 +1885,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn split_terminator<Sep: CharEq>(&self, sep: Sep)\n-        -> CharSplits<'a, Sep> {\n+        -> CharSplits<Sep> {\n         CharSplits {\n             allow_trailing_empty: false,\n             ..self.split(sep)\n@@ -1893,7 +1894,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn rsplitn<Sep: CharEq>(&self, count: uint, sep: Sep)\n-        -> CharSplitsN<'a, Sep> {\n+        -> CharSplitsN<Sep> {\n         CharSplitsN {\n             iter: self.split(sep),\n             count: count,\n@@ -1902,17 +1903,17 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a> {\n+    fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a> {\n         assert!(!sep.is_empty())\n         MatchIndices {\n-            haystack: *self,\n+            haystack: self,\n             needle: sep,\n             searcher: Searcher::new(self.as_bytes(), sep.as_bytes())\n         }\n     }\n \n     #[inline]\n-    fn split_str(&self, sep: &'a str) -> StrSplits<'a> {\n+    fn split_str<'a>(&'a self, sep: &'a str) -> StrSplits<'a> {\n         StrSplits {\n             it: self.match_indices(sep),\n             last_end: 0,\n@@ -1921,11 +1922,11 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn lines(&self) -> CharSplits<'a, char> {\n+    fn lines(&self) -> CharSplits<char> {\n         self.split_terminator('\\n')\n     }\n \n-    fn lines_any(&self) -> AnyLines<'a> {\n+    fn lines_any(&self) -> AnyLines {\n         self.lines().map(|line| {\n             let l = line.len();\n             if l > 0 && line.as_bytes()[l - 1] == b'\\r' { line.slice(0, l - 1) }\n@@ -1937,38 +1938,38 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn char_len(&self) -> uint { self.chars().count() }\n \n     #[inline]\n-    fn slice(&self, begin: uint, end: uint) -> &'a str {\n+    fn slice(&self, begin: uint, end: uint) -> &str {\n         // is_char_boundary checks that the index is in [0, .len()]\n         if begin <= end &&\n            self.is_char_boundary(begin) &&\n            self.is_char_boundary(end) {\n-            unsafe { raw::slice_unchecked(*self, begin, end) }\n+            unsafe { raw::slice_unchecked(self, begin, end) }\n         } else {\n-            slice_error_fail(*self, begin, end)\n+            slice_error_fail(self, begin, end)\n         }\n     }\n \n     #[inline]\n-    fn slice_from(&self, begin: uint) -> &'a str {\n+    fn slice_from(&self, begin: uint) -> &str {\n         // is_char_boundary checks that the index is in [0, .len()]\n         if self.is_char_boundary(begin) {\n-            unsafe { raw::slice_unchecked(*self, begin, self.len()) }\n+            unsafe { raw::slice_unchecked(self, begin, self.len()) }\n         } else {\n-            slice_error_fail(*self, begin, self.len())\n+            slice_error_fail(self, begin, self.len())\n         }\n     }\n \n     #[inline]\n-    fn slice_to(&self, end: uint) -> &'a str {\n+    fn slice_to(&self, end: uint) -> &str {\n         // is_char_boundary checks that the index is in [0, .len()]\n         if self.is_char_boundary(end) {\n-            unsafe { raw::slice_unchecked(*self, 0, end) }\n+            unsafe { raw::slice_unchecked(self, 0, end) }\n         } else {\n-            slice_error_fail(*self, 0, end)\n+            slice_error_fail(self, 0, end)\n         }\n     }\n \n-    fn slice_chars(&self, begin: uint, end: uint) -> &'a str {\n+    fn slice_chars(&self, begin: uint, end: uint) -> &str {\n         assert!(begin <= end);\n         let mut count = 0;\n         let mut begin_byte = None;\n@@ -1987,12 +1988,12 @@ impl<'a> StrSlice<'a> for &'a str {\n         match (begin_byte, end_byte) {\n             (None, _) => fail!(\"slice_chars: `begin` is beyond end of string\"),\n             (_, None) => fail!(\"slice_chars: `end` is beyond end of string\"),\n-            (Some(a), Some(b)) => unsafe { raw::slice_bytes(*self, a, b) }\n+            (Some(a), Some(b)) => unsafe { raw::slice_bytes(self, a, b) }\n         }\n     }\n \n     #[inline]\n-    fn starts_with<'a>(&self, needle: &'a str) -> bool {\n+    fn starts_with(&self, needle: &str) -> bool {\n         let n = needle.len();\n         self.len() >= n && needle.as_bytes() == self.as_bytes()[..n]\n     }\n@@ -2004,10 +2005,10 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n+    fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &str {\n         let cur = match self.find(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n-            Some(i) => unsafe { raw::slice_bytes(*self, i, self.len()) }\n+            Some(i) => unsafe { raw::slice_bytes(self, i, self.len()) }\n         };\n         match cur.rfind(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n@@ -2019,20 +2020,20 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn trim_left_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n+    fn trim_left_chars<C: CharEq>(&self, mut to_trim: C) -> &str {\n         match self.find(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n-            Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n+            Some(first) => unsafe { raw::slice_bytes(self, first, self.len()) }\n         }\n     }\n \n     #[inline]\n-    fn trim_right_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n+    fn trim_right_chars<C: CharEq>(&self, mut to_trim: C) -> &str {\n         match self.rfind(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(last) => {\n                 let next = self.char_range_at(last).next;\n-                unsafe { raw::slice_bytes(*self, 0u, next) }\n+                unsafe { raw::slice_bytes(self, 0u, next) }\n             }\n         }\n     }\n@@ -2066,7 +2067,7 @@ impl<'a> StrSlice<'a> for &'a str {\n             return CharRange {ch: unsafe { mem::transmute(val) }, next: i + w};\n         }\n \n-        return multibyte_char_range_at(*self, i);\n+        return multibyte_char_range_at(self, i);\n     }\n \n     #[inline]\n@@ -2097,7 +2098,7 @@ impl<'a> StrSlice<'a> for &'a str {\n             return CharRange {ch: unsafe { mem::transmute(val) }, next: i};\n         }\n \n-        return multibyte_char_range_at_reverse(*self, prev);\n+        return multibyte_char_range_at_reverse(self, prev);\n     }\n \n     #[inline]\n@@ -2111,8 +2112,8 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn as_bytes(&self) -> &'a [u8] {\n-        unsafe { mem::transmute(*self) }\n+    fn as_bytes(&self) -> &[u8] {\n+        unsafe { mem::transmute(self) }\n     }\n \n     fn find<C: CharEq>(&self, mut search: C) -> Option<uint> {\n@@ -2148,12 +2149,12 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn slice_shift_char(&self) -> (Option<char>, &'a str) {\n+    fn slice_shift_char(&self) -> (Option<char>, &str) {\n         if self.is_empty() {\n-            return (None, *self);\n+            return (None, self);\n         } else {\n             let CharRange {ch, next} = self.char_range_at(0u);\n-            let next_s = unsafe { raw::slice_bytes(*self, next, self.len()) };\n+            let next_s = unsafe { raw::slice_bytes(self, next, self.len()) };\n             return (Some(ch), next_s);\n         }\n     }\n@@ -2175,7 +2176,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn utf16_units(&self) -> Utf16CodeUnits<'a> {\n+    fn utf16_units(&self) -> Utf16CodeUnits {\n         Utf16CodeUnits{ chars: self.chars(), extra: 0}\n     }\n }"}, {"sha": "6b6b08c5e6e3aefa4115d89eed695e1e892d4124", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8", "patch": "@@ -15,6 +15,7 @@\n #![experimental]\n \n use collections::Collection;\n+use core::kinds::Sized;\n use fmt;\n use iter::Iterator;\n use mem;\n@@ -272,7 +273,7 @@ impl OwnedAsciiCast for Vec<u8> {\n \n /// Trait for converting an ascii type to a string. Needed to convert\n /// `&[Ascii]` to `&str`.\n-pub trait AsciiStr {\n+pub trait AsciiStr for Sized? {\n     /// Convert to a string.\n     fn as_str_ascii<'a>(&'a self) -> &'a str;\n \n@@ -291,13 +292,13 @@ pub trait AsciiStr {\n     fn to_uppercase(&self) -> Vec<Ascii>;\n \n     /// Compares two Ascii strings ignoring case.\n-    fn eq_ignore_case(self, other: &[Ascii]) -> bool;\n+    fn eq_ignore_case(&self, other: &[Ascii]) -> bool;\n }\n \n-impl<'a> AsciiStr for &'a [Ascii] {\n+impl AsciiStr for [Ascii] {\n     #[inline]\n     fn as_str_ascii<'a>(&'a self) -> &'a str {\n-        unsafe { mem::transmute(*self) }\n+        unsafe { mem::transmute(self) }\n     }\n \n     #[inline]\n@@ -321,7 +322,7 @@ impl<'a> AsciiStr for &'a [Ascii] {\n     }\n \n     #[inline]\n-    fn eq_ignore_case(self, other: &[Ascii]) -> bool {\n+    fn eq_ignore_case(&self, other: &[Ascii]) -> bool {\n         self.iter().zip(other.iter()).all(|(&a, &b)| a.eq_ignore_case(b))\n     }\n }\n@@ -372,7 +373,7 @@ pub trait OwnedAsciiExt {\n }\n \n /// Extension methods for ASCII-subset only operations on string slices\n-pub trait AsciiExt<T> {\n+pub trait AsciiExt<T> for Sized? {\n     /// Makes a copy of the string in ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n@@ -386,10 +387,10 @@ pub trait AsciiExt<T> {\n     /// Check that two strings are an ASCII case-insensitive match.\n     /// Same as `to_ascii_lower(a) == to_ascii_lower(b)`,\n     /// but without allocating and copying temporary strings.\n-    fn eq_ignore_ascii_case(&self, other: Self) -> bool;\n+    fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n }\n \n-impl<'a> AsciiExt<String> for &'a str {\n+impl AsciiExt<String> for str {\n     #[inline]\n     fn to_ascii_upper(&self) -> String {\n         // Vec<u8>::to_ascii_upper() preserves the UTF-8 invariant.\n@@ -422,7 +423,7 @@ impl OwnedAsciiExt for String {\n     }\n }\n \n-impl<'a> AsciiExt<Vec<u8>> for &'a [u8] {\n+impl AsciiExt<Vec<u8>> for [u8] {\n     #[inline]\n     fn to_ascii_upper(&self) -> Vec<u8> {\n         self.iter().map(|&byte| ASCII_UPPER_MAP[byte as uint]).collect()"}, {"sha": "f27a1c1fedad417584b37b00986b461914560b48", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8", "patch": "@@ -367,7 +367,7 @@ impl Path {\n \n     /// Returns a normalized byte vector representation of a path, by removing all empty\n     /// components, and unnecessary . and .. components.\n-    fn normalize<V: AsSlice<u8>+CloneableVector<u8>>(v: V) -> Vec<u8> {\n+    fn normalize<V: AsSlice<u8>>(v: V) -> Vec<u8> {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;"}, {"sha": "e4148440252afae255ca54954bcd09dd1086d13a", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=94ddb51c9c0a53103dc0c2a4c0260e71f62e6ef8", "patch": "@@ -21,6 +21,7 @@ use core::clone::Clone;\n use core::cmp;\n use core::collections::Collection;\n use core::iter::{Filter, AdditiveIterator, Iterator, DoubleEndedIterator};\n+use core::kinds::Sized;\n use core::option::{Option, None, Some};\n use core::str::{CharSplits, StrSlice};\n use u_char;\n@@ -32,7 +33,7 @@ pub type Words<'a> =\n     Filter<'a, &'a str, CharSplits<'a, extern \"Rust\" fn(char) -> bool>>;\n \n /// Methods for Unicode string slices\n-pub trait UnicodeStrSlice<'a> {\n+pub trait UnicodeStrSlice for Sized? {\n     /// Returns an iterator over the\n     /// [grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n     /// of the string.\n@@ -52,7 +53,7 @@ pub trait UnicodeStrSlice<'a> {\n     /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n     /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n-    fn graphemes(&self, is_extended: bool) -> Graphemes<'a>;\n+    fn graphemes<'a>(&'a self, is_extended: bool) -> Graphemes<'a>;\n \n     /// Returns an iterator over the grapheme clusters of self and their byte offsets.\n     /// See `graphemes()` method for more information.\n@@ -64,7 +65,7 @@ pub trait UnicodeStrSlice<'a> {\n     /// let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n-    fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices<'a>;\n+    fn grapheme_indices<'a>(&'a self, is_extended: bool) -> GraphemeIndices<'a>;\n \n     /// An iterator over the words of a string (subsequences separated\n     /// by any sequence of whitespace). Sequences of whitespace are\n@@ -77,7 +78,7 @@ pub trait UnicodeStrSlice<'a> {\n     /// let v: Vec<&str> = some_words.words().collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n-    fn words(&self) -> Words<'a>;\n+    fn words<'a>(&'a self) -> Words<'a>;\n \n     /// Returns true if the string contains only whitespace.\n     ///\n@@ -120,28 +121,28 @@ pub trait UnicodeStrSlice<'a> {\n     fn width(&self, is_cjk: bool) -> uint;\n \n     /// Returns a string with leading and trailing whitespace removed.\n-    fn trim(&self) -> &'a str;\n+    fn trim<'a>(&'a self) -> &'a str;\n \n     /// Returns a string with leading whitespace removed.\n-    fn trim_left(&self) -> &'a str;\n+    fn trim_left<'a>(&'a self) -> &'a str;\n \n     /// Returns a string with trailing whitespace removed.\n-    fn trim_right(&self) -> &'a str;\n+    fn trim_right<'a>(&'a self) -> &'a str;\n }\n \n-impl<'a> UnicodeStrSlice<'a> for &'a str {\n+impl UnicodeStrSlice for str {\n     #[inline]\n-    fn graphemes(&self, is_extended: bool) -> Graphemes<'a> {\n-        Graphemes { string: *self, extended: is_extended, cat: None, catb: None }\n+    fn graphemes(&self, is_extended: bool) -> Graphemes {\n+        Graphemes { string: self, extended: is_extended, cat: None, catb: None }\n     }\n \n     #[inline]\n-    fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices<'a> {\n+    fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n         GraphemeIndices { start_offset: self.as_ptr() as uint, iter: self.graphemes(is_extended) }\n     }\n \n     #[inline]\n-    fn words(&self) -> Words<'a> {\n+    fn words(&self) -> Words {\n         self.split(u_char::is_whitespace).filter(|s| !s.is_empty())\n     }\n \n@@ -157,17 +158,17 @@ impl<'a> UnicodeStrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn trim(&self) -> &'a str {\n+    fn trim(&self) -> &str {\n         self.trim_left().trim_right()\n     }\n \n     #[inline]\n-    fn trim_left(&self) -> &'a str {\n+    fn trim_left(&self) -> &str {\n         self.trim_left_chars(u_char::is_whitespace)\n     }\n \n     #[inline]\n-    fn trim_right(&self) -> &'a str {\n+    fn trim_right(&self) -> &str {\n         self.trim_right_chars(u_char::is_whitespace)\n     }\n }"}]}