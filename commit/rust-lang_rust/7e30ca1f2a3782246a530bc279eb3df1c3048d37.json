{"sha": "7e30ca1f2a3782246a530bc279eb3df1c3048d37", "node_id": "C_kwDOAAsO6NoAKDdlMzBjYTFmMmEzNzgyMjQ2YTUzMGJjMjc5ZWIzZGYxYzMwNDhkMzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-22T15:31:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-22T15:31:32Z"}, "message": "Auto merge of #12844 - Veykril:highlight-attr, r=Veykril\n\nfix: Improve syntax highlighting in attributes\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/12842", "tree": {"sha": "539d03021165e5bb1294644472c931305bbb8b73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/539d03021165e5bb1294644472c931305bbb8b73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e30ca1f2a3782246a530bc279eb3df1c3048d37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e30ca1f2a3782246a530bc279eb3df1c3048d37", "html_url": "https://github.com/rust-lang/rust/commit/7e30ca1f2a3782246a530bc279eb3df1c3048d37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e30ca1f2a3782246a530bc279eb3df1c3048d37/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb8a3be2a158466abe984c4d8448775983a6f388", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb8a3be2a158466abe984c4d8448775983a6f388", "html_url": "https://github.com/rust-lang/rust/commit/cb8a3be2a158466abe984c4d8448775983a6f388"}, {"sha": "1ab862a62808a1ca06782d71142550bb8b396879", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ab862a62808a1ca06782d71142550bb8b396879", "html_url": "https://github.com/rust-lang/rust/commit/1ab862a62808a1ca06782d71142550bb8b396879"}], "stats": {"total": 71, "additions": 64, "deletions": 7}, "files": [{"sha": "043f2b7c24dcb42adbf82307e9341543d5f91460", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7e30ca1f2a3782246a530bc279eb3df1c3048d37/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e30ca1f2a3782246a530bc279eb3df1c3048d37/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=7e30ca1f2a3782246a530bc279eb3df1c3048d37", "patch": "@@ -22,7 +22,7 @@ use smallvec::{smallvec, SmallVec};\n use syntax::{\n     algo::skip_trivia_token,\n     ast::{self, HasAttrs as _, HasGenericParams, HasLoopBody},\n-    match_ast, AstNode, Direction, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextSize,\n+    match_ast, AstNode, Direction, SyntaxKind, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextSize,\n };\n \n use crate::{\n@@ -217,6 +217,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.descend_into_macros_with_same_text(token)\n     }\n \n+    pub fn descend_into_macros_with_kind_preference(&self, token: SyntaxToken) -> SyntaxToken {\n+        self.imp.descend_into_macros_with_kind_preference(token)\n+    }\n+\n     /// Maps a node down by mapping its first and last token down.\n     pub fn descend_node_into_attributes<N: AstNode>(&self, node: N) -> SmallVec<[N; 1]> {\n         self.imp.descend_node_into_attributes(node)\n@@ -680,6 +684,32 @@ impl<'db> SemanticsImpl<'db> {\n         res\n     }\n \n+    fn descend_into_macros_with_kind_preference(&self, token: SyntaxToken) -> SyntaxToken {\n+        let fetch_kind = |token: &SyntaxToken| match token.parent() {\n+            Some(node) => match node.kind() {\n+                kind @ (SyntaxKind::NAME | SyntaxKind::NAME_REF) => {\n+                    node.parent().map_or(kind, |it| it.kind())\n+                }\n+                _ => token.kind(),\n+            },\n+            None => token.kind(),\n+        };\n+        let preferred_kind = fetch_kind(&token);\n+        let mut res = None;\n+        self.descend_into_macros_impl(token.clone(), &mut |InFile { value, .. }| {\n+            if fetch_kind(&value) == preferred_kind {\n+                res = Some(value);\n+                true\n+            } else {\n+                if let None = res {\n+                    res = Some(value)\n+                }\n+                false\n+            }\n+        });\n+        res.unwrap_or(token)\n+    }\n+\n     fn descend_into_macros_single(&self, token: SyntaxToken) -> SyntaxToken {\n         let mut res = token.clone();\n         self.descend_into_macros_impl(token, &mut |InFile { value, .. }| {"}, {"sha": "d7ad6a75799536f228fa15a8329d09af0f8988d7", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7e30ca1f2a3782246a530bc279eb3df1c3048d37/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e30ca1f2a3782246a530bc279eb3df1c3048d37/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=7e30ca1f2a3782246a530bc279eb3df1c3048d37", "patch": "@@ -206,6 +206,19 @@ fn traverse(\n     let is_unlinked = sema.to_module_def(file_id).is_none();\n     let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n \n+    enum AttrOrDerive {\n+        Attr(ast::Item),\n+        Derive(ast::Item),\n+    }\n+\n+    impl AttrOrDerive {\n+        fn item(&self) -> &ast::Item {\n+            match self {\n+                AttrOrDerive::Attr(item) | AttrOrDerive::Derive(item) => item,\n+            }\n+        }\n+    }\n+\n     let mut tt_level = 0;\n     let mut attr_or_derive_item = None;\n     let mut current_macro: Option<ast::Macro> = None;\n@@ -260,7 +273,7 @@ fn traverse(\n \n                         if attr_or_derive_item.is_none() {\n                             if sema.is_attr_macro_call(&item) {\n-                                attr_or_derive_item = Some(item);\n+                                attr_or_derive_item = Some(AttrOrDerive::Attr(item));\n                             } else {\n                                 let adt = match item {\n                                     ast::Item::Enum(it) => Some(ast::Adt::Enum(it)),\n@@ -270,7 +283,8 @@ fn traverse(\n                                 };\n                                 match adt {\n                                     Some(adt) if sema.is_derive_annotated(&adt) => {\n-                                        attr_or_derive_item = Some(ast::Item::from(adt));\n+                                        attr_or_derive_item =\n+                                            Some(AttrOrDerive::Derive(ast::Item::from(adt)));\n                                     }\n                                     _ => (),\n                                 }\n@@ -292,7 +306,9 @@ fn traverse(\n                         current_macro = None;\n                         macro_highlighter = MacroHighlighter::default();\n                     }\n-                    Some(item) if attr_or_derive_item.as_ref().map_or(false, |it| *it == item) => {\n+                    Some(item)\n+                        if attr_or_derive_item.as_ref().map_or(false, |it| *it.item() == item) =>\n+                    {\n                         attr_or_derive_item = None;\n                     }\n                     _ => (),\n@@ -330,15 +346,26 @@ fn traverse(\n \n         // Descending tokens into macros is expensive even if no descending occurs, so make sure\n         // that we actually are in a position where descending is possible.\n-        let in_macro = tt_level > 0 || attr_or_derive_item.is_some();\n+        let in_macro = tt_level > 0\n+            || match attr_or_derive_item {\n+                Some(AttrOrDerive::Attr(_)) => true,\n+                Some(AttrOrDerive::Derive(_)) => inside_attribute,\n+                None => false,\n+            };\n         let descended_element = if in_macro {\n             // Attempt to descend tokens into macro-calls.\n             match element {\n                 NodeOrToken::Token(token) if token.kind() != COMMENT => {\n-                    let token = sema.descend_into_macros_single(token);\n+                    let token = match attr_or_derive_item {\n+                        Some(AttrOrDerive::Attr(_)) => {\n+                            sema.descend_into_macros_with_kind_preference(token)\n+                        }\n+                        Some(AttrOrDerive::Derive(_)) | None => {\n+                            sema.descend_into_macros_single(token)\n+                        }\n+                    };\n                     match token.parent().and_then(ast::NameLike::cast) {\n                         // Remap the token into the wrapping single token nodes\n-                        // FIXME: if the node doesn't resolve, we also won't do token based highlighting!\n                         Some(parent) => match (token.kind(), parent.syntax().kind()) {\n                             (T![self] | T![ident], NAME | NAME_REF) => NodeOrToken::Node(parent),\n                             (T![self] | T![super] | T![crate] | T![Self], NAME_REF) => {"}]}