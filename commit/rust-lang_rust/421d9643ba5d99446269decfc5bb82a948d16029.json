{"sha": "421d9643ba5d99446269decfc5bb82a948d16029", "node_id": "C_kwDOAAsO6NoAKDQyMWQ5NjQzYmE1ZDk5NDQ2MjY5ZGVjZmM1YmI4MmE5NDhkMTYwMjk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-12T15:28:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-12T15:28:33Z"}, "message": "Merge #11693\n\n11693: internal: Remove ide_completion::render::build_ext module r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "f618a657d0af29ebaab610d6d58357b28e271c23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f618a657d0af29ebaab610d6d58357b28e271c23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/421d9643ba5d99446269decfc5bb82a948d16029", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiLLwhCRBK7hj4Ov3rIwAAvj4IAFO1dlkGlN4tboYoWtSxCRbM\nXQRomvMmC0gYD6JnGqDzJV/UxAh3mPNTZFNXZmVGDcPyy7XKOelT5+AlsEty3N7H\nHOjBbUcY9FZbb532ZEdTMVl8p1g8nirc1mZA2Sb7FNfEf3x9dtLqceR3qPDTKyqg\ntbkc8WE6MhQolKiykd9lBbcVo7VMzQZy1C5GPFx3SuFupTZrouzVWojXWBMzfE+w\nqjIOrjytZcCR0pjjwQIvUbtgi1BmCuwBL7I4Ls0tfuhy+yF9YPuqnOZ9i71IRoNh\nmslqdzRc4sfm/gci8O3If9Uef4moFwZw2r++fYX3v+Cs2uer3kTT7TnU7vR4xds=\n=Js+S\n-----END PGP SIGNATURE-----\n", "payload": "tree f618a657d0af29ebaab610d6d58357b28e271c23\nparent d65f9a28fab62912070496a5f86a93ed8609581d\nparent 301711ee71568c939cb5595a3fe4313d8664757a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647098913 +0000\ncommitter GitHub <noreply@github.com> 1647098913 +0000\n\nMerge #11693\n\n11693: internal: Remove ide_completion::render::build_ext module r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/421d9643ba5d99446269decfc5bb82a948d16029", "html_url": "https://github.com/rust-lang/rust/commit/421d9643ba5d99446269decfc5bb82a948d16029", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/421d9643ba5d99446269decfc5bb82a948d16029/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d65f9a28fab62912070496a5f86a93ed8609581d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d65f9a28fab62912070496a5f86a93ed8609581d", "html_url": "https://github.com/rust-lang/rust/commit/d65f9a28fab62912070496a5f86a93ed8609581d"}, {"sha": "301711ee71568c939cb5595a3fe4313d8664757a", "url": "https://api.github.com/repos/rust-lang/rust/commits/301711ee71568c939cb5595a3fe4313d8664757a", "html_url": "https://github.com/rust-lang/rust/commit/301711ee71568c939cb5595a3fe4313d8664757a"}], "stats": {"total": 336, "additions": 166, "deletions": 170}, "files": [{"sha": "d83fb16d10fdaaa1eef5639cdcfb0bda24932be9", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/421d9643ba5d99446269decfc5bb82a948d16029/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421d9643ba5d99446269decfc5bb82a948d16029/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=421d9643ba5d99446269decfc5bb82a948d16029", "patch": "@@ -1325,7 +1325,7 @@ impl Function {\n     /// Get this function's return type\n     pub fn ret_type(self, db: &dyn HirDatabase) -> Type {\n         let resolver = self.id.resolver(db.upcast());\n-        let krate = self.id.lookup(db.upcast()).container.module(db.upcast()).krate();\n+        let krate = self.krate_id(db);\n         let ret_type = &db.function_data(self.id).ret_type;\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n         let ty = ctx.lower_ty(ret_type);\n@@ -1341,7 +1341,7 @@ impl Function {\n \n     pub fn assoc_fn_params(self, db: &dyn HirDatabase) -> Vec<Param> {\n         let resolver = self.id.resolver(db.upcast());\n-        let krate = self.id.lookup(db.upcast()).container.module(db.upcast()).krate();\n+        let krate = self.krate_id(db);\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n         let environment = db.trait_environment(self.id.into());\n         db.function_data(self.id)\n@@ -1359,9 +1359,25 @@ impl Function {\n         if self.self_param(db).is_none() {\n             return None;\n         }\n-        let mut res = self.assoc_fn_params(db);\n-        res.remove(0);\n-        Some(res)\n+        Some(self.params_without_self(db))\n+    }\n+\n+    pub fn params_without_self(self, db: &dyn HirDatabase) -> Vec<Param> {\n+        let resolver = self.id.resolver(db.upcast());\n+        let krate = self.krate_id(db);\n+        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n+        let environment = db.trait_environment(self.id.into());\n+        let skip = if db.function_data(self.id).has_self_param() { 1 } else { 0 };\n+        db.function_data(self.id)\n+            .params\n+            .iter()\n+            .enumerate()\n+            .skip(skip)\n+            .map(|(idx, (_, type_ref))| {\n+                let ty = Type { krate, env: environment.clone(), ty: ctx.lower_ty(type_ref) };\n+                Param { func: self, ty, idx }\n+            })\n+            .collect()\n     }\n \n     pub fn is_unsafe(self, db: &dyn HirDatabase) -> bool {\n@@ -1410,6 +1426,10 @@ impl Function {\n \n         result\n     }\n+\n+    fn krate_id(self, db: &dyn HirDatabase) -> CrateId {\n+        self.id.lookup(db.upcast()).module(db.upcast()).krate()\n+    }\n }\n \n // Note: logically, this belongs to `hir_ty`, but we are not using it there yet."}, {"sha": "a203ebd45a07a9737cc564b6fa101454a678ceb4", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/421d9643ba5d99446269decfc5bb82a948d16029/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421d9643ba5d99446269decfc5bb82a948d16029/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=421d9643ba5d99446269decfc5bb82a948d16029", "patch": "@@ -59,7 +59,7 @@ pub(super) enum PathKind {\n #[derive(Debug)]\n pub(crate) struct PathCompletionCtx {\n     /// If this is a call with () already there\n-    has_call_parens: bool,\n+    pub(super) has_call_parens: bool,\n     /// Whether this path stars with a `::`.\n     pub(super) is_absolute_path: bool,\n     /// The qualifier of the current path if it exists."}, {"sha": "8624a8c3d2d9e58dd6471f95269b47bc879a0de5", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/421d9643ba5d99446269decfc5bb82a948d16029/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421d9643ba5d99446269decfc5bb82a948d16029/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=421d9643ba5d99446269decfc5bb82a948d16029", "patch": "@@ -10,8 +10,6 @@ pub(crate) mod type_alias;\n pub(crate) mod struct_literal;\n pub(crate) mod compound;\n \n-mod builder_ext;\n-\n use hir::{AsAssocItem, HasAttrs, HirDisplay, ScopeDef};\n use ide_db::{helpers::item_name, RootDatabase, SnippetCap, SymbolKind};\n use syntax::{SmolStr, SyntaxKind, TextRange};"}, {"sha": "70767a2a9ccadc69b989efbf2283d83a4146fb6a", "filename": "crates/ide_completion/src/render/builder_ext.rs", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/d65f9a28fab62912070496a5f86a93ed8609581d/crates%2Fide_completion%2Fsrc%2Frender%2Fbuilder_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d65f9a28fab62912070496a5f86a93ed8609581d/crates%2Fide_completion%2Fsrc%2Frender%2Fbuilder_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fbuilder_ext.rs?ref=d65f9a28fab62912070496a5f86a93ed8609581d", "patch": "@@ -1,129 +0,0 @@\n-//! Extensions for `Builder` structure required for item rendering.\n-\n-use itertools::Itertools;\n-use syntax::SmolStr;\n-\n-use crate::{context::PathKind, item::Builder, patterns::ImmediateLocation, CompletionContext};\n-\n-#[derive(Debug)]\n-pub(super) enum Params {\n-    Named(Option<hir::SelfParam>, Vec<hir::Param>),\n-    #[allow(dead_code)]\n-    Anonymous(usize),\n-}\n-\n-impl Params {\n-    pub(super) fn len(&self) -> usize {\n-        match self {\n-            Params::Named(selv, params) => params.len() + if selv.is_some() { 1 } else { 0 },\n-            Params::Anonymous(len) => *len,\n-        }\n-    }\n-\n-    pub(super) fn is_empty(&self) -> bool {\n-        self.len() == 0\n-    }\n-}\n-\n-impl Builder {\n-    fn should_add_parens(&self, ctx: &CompletionContext) -> bool {\n-        if !ctx.config.add_call_parenthesis {\n-            return false;\n-        }\n-        if let Some(PathKind::Use) = ctx.path_kind() {\n-            cov_mark::hit!(no_parens_in_use_item);\n-            return false;\n-        }\n-        if matches!(ctx.path_kind(), Some(PathKind::Expr | PathKind::Pat) if ctx.path_is_call())\n-            | matches!(\n-                ctx.completion_location,\n-                Some(ImmediateLocation::MethodCall { has_parens: true, .. })\n-            )\n-        {\n-            return false;\n-        }\n-\n-        // Don't add parentheses if the expected type is some function reference.\n-        if let Some(ty) = &ctx.expected_type {\n-            if ty.is_fn() {\n-                cov_mark::hit!(no_call_parens_if_fn_ptr_needed);\n-                return false;\n-            }\n-        }\n-\n-        // Nothing prevents us from adding parentheses\n-        true\n-    }\n-\n-    pub(super) fn add_call_parens(\n-        &mut self,\n-        ctx: &CompletionContext,\n-        name: SmolStr,\n-        params: Params,\n-    ) -> &mut Builder {\n-        if !self.should_add_parens(ctx) {\n-            return self;\n-        }\n-\n-        let cap = match ctx.config.snippet_cap {\n-            Some(it) => it,\n-            None => return self,\n-        };\n-        // If not an import, add parenthesis automatically.\n-        cov_mark::hit!(inserts_parens_for_function_calls);\n-\n-        let (snippet, label) = if params.is_empty() {\n-            (format!(\"{}()$0\", name), format!(\"{}()\", name))\n-        } else {\n-            self.trigger_call_info();\n-            let snippet = match (ctx.config.add_call_argument_snippets, params) {\n-                (true, Params::Named(self_param, params)) => {\n-                    let offset = if self_param.is_some() { 2 } else { 1 };\n-                    let function_params_snippet = params.iter().enumerate().format_with(\n-                        \", \",\n-                        |(index, param), f| match param.name(ctx.db) {\n-                            Some(n) => {\n-                                let smol_str = n.to_smol_str();\n-                                let text = smol_str.as_str().trim_start_matches('_');\n-                                let ref_ = ref_of_param(ctx, text, param.ty());\n-                                f(&format_args!(\"${{{}:{}{}}}\", index + offset, ref_, text))\n-                            }\n-                            None => f(&format_args!(\"${{{}:_}}\", index + offset,)),\n-                        },\n-                    );\n-                    match self_param {\n-                        Some(self_param) => {\n-                            format!(\n-                                \"{}(${{1:{}}}{}{})$0\",\n-                                name,\n-                                self_param.display(ctx.db),\n-                                if params.is_empty() { \"\" } else { \", \" },\n-                                function_params_snippet\n-                            )\n-                        }\n-                        None => {\n-                            format!(\"{}({})$0\", name, function_params_snippet)\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    cov_mark::hit!(suppress_arg_snippets);\n-                    format!(\"{}($0)\", name)\n-                }\n-            };\n-\n-            (snippet, format!(\"{}(\u2026)\", name))\n-        };\n-        self.lookup_by(name).label(label).insert_snippet(cap, snippet)\n-    }\n-}\n-fn ref_of_param(ctx: &CompletionContext, arg: &str, ty: &hir::Type) -> &'static str {\n-    if let Some(derefed_ty) = ty.remove_ref() {\n-        for (name, local) in ctx.locals.iter() {\n-            if name.as_text().as_deref() == Some(arg) && local.ty(ctx.db) == derefed_ty {\n-                return if ty.is_mutable_reference() { \"&mut \" } else { \"&\" };\n-            }\n-        }\n-    }\n-    \"\"\n-}"}, {"sha": "2b9f82fc54e23f05dabe1e73ab6783a13b87b683", "filename": "crates/ide_completion/src/render/function.rs", "status": "modified", "additions": 140, "deletions": 33, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/421d9643ba5d99446269decfc5bb82a948d16029/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421d9643ba5d99446269decfc5bb82a948d16029/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs?ref=421d9643ba5d99446269decfc5bb82a948d16029", "patch": "@@ -1,20 +1,19 @@\n //! Renderer for function calls.\n \n use hir::{db::HirDatabase, AsAssocItem, HirDisplay};\n-use ide_db::SymbolKind;\n+use ide_db::{SnippetCap, SymbolKind};\n use itertools::Itertools;\n use stdx::format_to;\n+use syntax::SmolStr;\n \n use crate::{\n-    context::CompletionContext,\n-    item::{CompletionItem, CompletionItemKind, CompletionRelevance, ImportEdit},\n-    render::{\n-        builder_ext::Params, compute_exact_name_match, compute_ref_match, compute_type_match,\n-        RenderContext,\n-    },\n+    context::{CompletionContext, PathCompletionCtx, PathKind},\n+    item::{Builder, CompletionItem, CompletionItemKind, CompletionRelevance, ImportEdit},\n+    patterns::ImmediateLocation,\n+    render::{compute_exact_name_match, compute_ref_match, compute_type_match, RenderContext},\n };\n \n-enum FuncType {\n+enum FuncKind {\n     Function,\n     Method(Option<hir::Name>),\n }\n@@ -26,7 +25,7 @@ pub(crate) fn render_fn(\n     func: hir::Function,\n ) -> CompletionItem {\n     let _p = profile::span(\"render_fn\");\n-    render(ctx, local_name, func, FuncType::Function, import_to_add)\n+    render(ctx, local_name, func, FuncKind::Function, import_to_add)\n }\n \n pub(crate) fn render_method(\n@@ -37,23 +36,22 @@ pub(crate) fn render_method(\n     func: hir::Function,\n ) -> CompletionItem {\n     let _p = profile::span(\"render_method\");\n-    render(ctx, local_name, func, FuncType::Method(receiver), import_to_add)\n+    render(ctx, local_name, func, FuncKind::Method(receiver), import_to_add)\n }\n \n fn render(\n     ctx @ RenderContext { completion, .. }: RenderContext<'_>,\n     local_name: Option<hir::Name>,\n     func: hir::Function,\n-    func_type: FuncType,\n+    func_kind: FuncKind,\n     import_to_add: Option<ImportEdit>,\n ) -> CompletionItem {\n     let db = completion.db;\n \n     let name = local_name.unwrap_or_else(|| func.name(db));\n-    let params = params(completion, func, &func_type);\n \n-    let call = match &func_type {\n-        FuncType::Method(Some(receiver)) => format!(\"{}.{}\", receiver, &name).into(),\n+    let call = match &func_kind {\n+        FuncKind::Method(Some(receiver)) => format!(\"{}.{}\", receiver, &name).into(),\n         _ => name.to_smol_str(),\n     };\n     let mut item = CompletionItem::new(\n@@ -82,15 +80,23 @@ fn render(\n         // FIXME\n         // For now we don't properly calculate the edits for ref match\n         // completions on methods, so we've disabled them. See #8058.\n-        if matches!(func_type, FuncType::Function) {\n+        if matches!(func_kind, FuncKind::Function) {\n             item.ref_match(ref_match);\n         }\n     }\n \n     item.set_documentation(ctx.docs(func))\n         .set_deprecated(ctx.is_deprecated(func) || ctx.is_deprecated_assoc_item(func))\n         .detail(detail(db, func))\n-        .add_call_parens(completion, call, params);\n+        .lookup_by(name.to_smol_str());\n+\n+    match completion.config.snippet_cap {\n+        Some(cap) if should_add_parens(completion) => {\n+            let (self_param, params) = params(completion, func, &func_kind);\n+            add_call_parens(&mut item, completion, cap, call, self_param, params);\n+        }\n+        _ => (),\n+    }\n \n     if import_to_add.is_none() {\n         if let Some(actm) = func.as_assoc_item(db) {\n@@ -103,11 +109,116 @@ fn render(\n     if let Some(import_to_add) = import_to_add {\n         item.add_import(import_to_add);\n     }\n-    item.lookup_by(name.to_smol_str());\n-\n     item.build()\n }\n \n+pub(super) fn add_call_parens<'b>(\n+    builder: &'b mut Builder,\n+    ctx: &CompletionContext,\n+    cap: SnippetCap,\n+    name: SmolStr,\n+    self_param: Option<hir::SelfParam>,\n+    params: Vec<hir::Param>,\n+) -> &'b mut Builder {\n+    cov_mark::hit!(inserts_parens_for_function_calls);\n+\n+    let (snippet, label_suffix) = if self_param.is_none() && params.is_empty() {\n+        (format!(\"{}()$0\", name), \"()\")\n+    } else {\n+        builder.trigger_call_info();\n+        let snippet = if ctx.config.add_call_argument_snippets {\n+            let offset = if self_param.is_some() { 2 } else { 1 };\n+            let function_params_snippet =\n+                params.iter().enumerate().format_with(\", \", |(index, param), f| {\n+                    match param.name(ctx.db) {\n+                        Some(n) => {\n+                            let smol_str = n.to_smol_str();\n+                            let text = smol_str.as_str().trim_start_matches('_');\n+                            let ref_ = ref_of_param(ctx, text, param.ty());\n+                            f(&format_args!(\"${{{}:{}{}}}\", index + offset, ref_, text))\n+                        }\n+                        None => f(&format_args!(\"${{{}:_}}\", index + offset,)),\n+                    }\n+                });\n+            match self_param {\n+                Some(self_param) => {\n+                    format!(\n+                        \"{}(${{1:{}}}{}{})$0\",\n+                        name,\n+                        self_param.display(ctx.db),\n+                        if params.is_empty() { \"\" } else { \", \" },\n+                        function_params_snippet\n+                    )\n+                }\n+                None => {\n+                    format!(\"{}({})$0\", name, function_params_snippet)\n+                }\n+            }\n+        } else {\n+            cov_mark::hit!(suppress_arg_snippets);\n+            format!(\"{}($0)\", name)\n+        };\n+\n+        (snippet, \"(\u2026)\")\n+    };\n+    builder.label(SmolStr::from_iter([&name, label_suffix])).insert_snippet(cap, snippet)\n+}\n+\n+fn ref_of_param(ctx: &CompletionContext, arg: &str, ty: &hir::Type) -> &'static str {\n+    if let Some(derefed_ty) = ty.remove_ref() {\n+        for (name, local) in ctx.locals.iter() {\n+            if name.as_text().as_deref() == Some(arg) {\n+                return if local.ty(ctx.db) == derefed_ty {\n+                    if ty.is_mutable_reference() {\n+                        \"&mut \"\n+                    } else {\n+                        \"&\"\n+                    }\n+                } else {\n+                    \"\"\n+                };\n+            }\n+        }\n+    }\n+    \"\"\n+}\n+\n+fn should_add_parens(ctx: &CompletionContext) -> bool {\n+    if !ctx.config.add_call_parenthesis {\n+        return false;\n+    }\n+\n+    match ctx.path_context {\n+        Some(PathCompletionCtx { kind: Some(PathKind::Expr), has_call_parens: true, .. }) => {\n+            return false\n+        }\n+        Some(PathCompletionCtx { kind: Some(PathKind::Use), .. }) => {\n+            cov_mark::hit!(no_parens_in_use_item);\n+            return false;\n+        }\n+        _ => {}\n+    };\n+\n+    if matches!(\n+        ctx.completion_location,\n+        Some(ImmediateLocation::MethodCall { has_parens: true, .. })\n+    ) {\n+        return false;\n+    }\n+\n+    // Don't add parentheses if the expected type is some function reference.\n+    if let Some(ty) = &ctx.expected_type {\n+        // FIXME: check signature matches?\n+        if ty.is_fn() {\n+            cov_mark::hit!(no_call_parens_if_fn_ptr_needed);\n+            return false;\n+        }\n+    }\n+\n+    // Nothing prevents us from adding parentheses\n+    true\n+}\n+\n fn detail(db: &dyn HirDatabase, func: hir::Function) -> String {\n     let ret_ty = func.ret_type(db);\n     let mut detail = String::new();\n@@ -150,21 +261,17 @@ fn params_display(db: &dyn HirDatabase, func: hir::Function) -> String {\n     }\n }\n \n-fn params(ctx: &CompletionContext<'_>, func: hir::Function, func_type: &FuncType) -> Params {\n-    let (params, self_param) =\n-        if ctx.has_dot_receiver() || matches!(func_type, FuncType::Method(Some(_))) {\n-            (func.method_params(ctx.db).unwrap_or_default(), None)\n-        } else {\n-            let self_param = func.self_param(ctx.db);\n-\n-            let mut assoc_params = func.assoc_fn_params(ctx.db);\n-            if self_param.is_some() {\n-                assoc_params.remove(0);\n-            }\n-            (assoc_params, self_param)\n-        };\n-\n-    Params::Named(self_param, params)\n+fn params(\n+    ctx: &CompletionContext<'_>,\n+    func: hir::Function,\n+    func_kind: &FuncKind,\n+) -> (Option<hir::SelfParam>, Vec<hir::Param>) {\n+    let self_param = if ctx.has_dot_receiver() || matches!(func_kind, FuncKind::Method(Some(_))) {\n+        None\n+    } else {\n+        func.self_param(ctx.db)\n+    };\n+    (self_param, func.params_without_self(ctx.db))\n }\n \n #[cfg(test)]"}]}