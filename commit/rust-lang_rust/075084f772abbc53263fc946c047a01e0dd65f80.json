{"sha": "075084f772abbc53263fc946c047a01e0dd65f80", "node_id": "C_kwDOAAsO6NoAKDA3NTA4NGY3NzJhYmJjNTMyNjNmYzk0NmMwNDdhMDFlMGRkNjVmODA", "commit": {"author": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2022-08-23T00:07:26Z"}, "committer": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2022-09-04T12:35:23Z"}, "message": "Make `const_eval_select` a real intrinsic", "tree": {"sha": "7097f458481e5bbd99cec69bd8ed02309b498bf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7097f458481e5bbd99cec69bd8ed02309b498bf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/075084f772abbc53263fc946c047a01e0dd65f80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/075084f772abbc53263fc946c047a01e0dd65f80", "html_url": "https://github.com/rust-lang/rust/commit/075084f772abbc53263fc946c047a01e0dd65f80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/075084f772abbc53263fc946c047a01e0dd65f80/comments", "author": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8521a8c92da6c0c845d4f6394e903651a227946a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8521a8c92da6c0c845d4f6394e903651a227946a", "html_url": "https://github.com/rust-lang/rust/commit/8521a8c92da6c0c845d4f6394e903651a227946a"}], "stats": {"total": 715, "additions": 430, "deletions": 285}, "files": [{"sha": "3154f12a77964b2baacf13fb5f70718368e67073", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -13,8 +13,7 @@ use rustc_ast as ast;\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::Idx;\n-use rustc_middle::mir::AssertKind;\n-use rustc_middle::mir::{self, SwitchTargets};\n+use rustc_middle::mir::{self, AssertKind, SwitchTargets};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Instance, Ty, TypeVisitable};"}, {"sha": "6e5c840bdfd6a7bca628508b6366c6d54a8f1e60", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -35,21 +35,7 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n         // All `#[rustc_do_not_const_check]` functions should be hooked here.\n         let def_id = instance.def_id();\n \n-        if Some(def_id) == self.tcx.lang_items().const_eval_select() {\n-            // redirect to const_eval_select_ct\n-            if let Some(const_eval_select) = self.tcx.lang_items().const_eval_select_ct() {\n-                return Ok(Some(\n-                    ty::Instance::resolve(\n-                        *self.tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        const_eval_select,\n-                        instance.substs,\n-                    )\n-                    .unwrap()\n-                    .unwrap(),\n-                ));\n-            }\n-        } else if Some(def_id) == self.tcx.lang_items().panic_display()\n+        if Some(def_id) == self.tcx.lang_items().panic_display()\n             || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n         {\n             // &str or &&str"}, {"sha": "bc1ea1c4c736f4f3ba1bcc1e040b3c6d0bec0c34", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -269,8 +269,6 @@ language_item_table! {\n     DropInPlace,             sym::drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);\n     Oom,                     sym::oom,                 oom,                        Target::Fn,             GenericRequirement::None;\n     AllocLayout,             sym::alloc_layout,        alloc_layout,               Target::Struct,         GenericRequirement::None;\n-    ConstEvalSelect,         sym::const_eval_select,   const_eval_select,          Target::Fn,             GenericRequirement::Exact(4);\n-    ConstConstEvalSelect,    sym::const_eval_select_ct,const_eval_select_ct,       Target::Fn,             GenericRequirement::Exact(4);\n \n     Start,                   sym::start,               start_fn,                   Target::Fn,             GenericRequirement::Exact(1);\n "}, {"sha": "a803fca0d5b8930bddefc80688bf8b791f8671e5", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -18,7 +18,7 @@ use rustc_macros::{HashStable, TyDecodable, TyEncodable};\n /// `ValTree` does not have this problem with representation, as it only contains integers or\n /// lists of (nested) `ValTree`.\n pub enum ValTree<'tcx> {\n-    /// ZSTs, integers, `bool`, `char` are represented as scalars.\n+    /// integers, `bool`, `char` are represented as scalars.\n     /// See the `ScalarInt` documentation for how `ScalarInt` guarantees that equal values\n     /// of these types have the same representation.\n     Leaf(ScalarInt),\n@@ -27,8 +27,11 @@ pub enum ValTree<'tcx> {\n     // dont use SliceOrStr for now\n     /// The fields of any kind of aggregate. Structs, tuples and arrays are represented by\n     /// listing their fields' values in order.\n+    ///\n     /// Enums are represented by storing their discriminant as a field, followed by all\n     /// the fields of the variant.\n+    ///\n+    /// ZST types are represented as an empty slice.\n     Branch(&'tcx [ValTree<'tcx>]),\n }\n "}, {"sha": "2c587b76f025f49a2a6d0a3b3853cec065ab3b39", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 89, "deletions": 86, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -263,6 +263,7 @@ fn layout_of<'tcx>(\n     Ok(layout)\n }\n \n+#[derive(Clone, Copy)]\n pub struct LayoutCx<'tcx, C> {\n     pub tcx: C,\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -3063,6 +3064,93 @@ fn fn_abi_of_instance<'tcx>(\n     )\n }\n \n+// Handle safe Rust thin and fat pointers.\n+pub fn adjust_for_rust_scalar<'tcx>(\n+    cx: LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    attrs: &mut ArgAttributes,\n+    scalar: Scalar,\n+    layout: TyAndLayout<'tcx>,\n+    offset: Size,\n+    is_return: bool,\n+) {\n+    // Booleans are always a noundef i1 that needs to be zero-extended.\n+    if scalar.is_bool() {\n+        attrs.ext(ArgExtension::Zext);\n+        attrs.set(ArgAttribute::NoUndef);\n+        return;\n+    }\n+\n+    // Scalars which have invalid values cannot be undef.\n+    if !scalar.is_always_valid(&cx) {\n+        attrs.set(ArgAttribute::NoUndef);\n+    }\n+\n+    // Only pointer types handled below.\n+    let Scalar::Initialized { value: Pointer, valid_range} = scalar else { return };\n+\n+    if !valid_range.contains(0) {\n+        attrs.set(ArgAttribute::NonNull);\n+    }\n+\n+    if let Some(pointee) = layout.pointee_info_at(&cx, offset) {\n+        if let Some(kind) = pointee.safe {\n+            attrs.pointee_align = Some(pointee.align);\n+\n+            // `Box` (`UniqueBorrowed`) are not necessarily dereferenceable\n+            // for the entire duration of the function as they can be deallocated\n+            // at any time. Same for shared mutable references. If LLVM had a\n+            // way to say \"dereferenceable on entry\" we could use it here.\n+            attrs.pointee_size = match kind {\n+                PointerKind::UniqueBorrowed\n+                | PointerKind::UniqueBorrowedPinned\n+                | PointerKind::Frozen => pointee.size,\n+                PointerKind::SharedMutable | PointerKind::UniqueOwned => Size::ZERO,\n+            };\n+\n+            // `Box`, `&T`, and `&mut T` cannot be undef.\n+            // Note that this only applies to the value of the pointer itself;\n+            // this attribute doesn't make it UB for the pointed-to data to be undef.\n+            attrs.set(ArgAttribute::NoUndef);\n+\n+            // The aliasing rules for `Box<T>` are still not decided, but currently we emit\n+            // `noalias` for it. This can be turned off using an unstable flag.\n+            // See https://github.com/rust-lang/unsafe-code-guidelines/issues/326\n+            let noalias_for_box = cx.tcx.sess.opts.unstable_opts.box_noalias.unwrap_or(true);\n+\n+            // `&mut` pointer parameters never alias other parameters,\n+            // or mutable global data\n+            //\n+            // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n+            // and can be marked as both `readonly` and `noalias`, as\n+            // LLVM's definition of `noalias` is based solely on memory\n+            // dependencies rather than pointer equality\n+            //\n+            // Due to past miscompiles in LLVM, we apply a separate NoAliasMutRef attribute\n+            // for UniqueBorrowed arguments, so that the codegen backend can decide whether\n+            // or not to actually emit the attribute. It can also be controlled with the\n+            // `-Zmutable-noalias` debugging option.\n+            let no_alias = match kind {\n+                PointerKind::SharedMutable\n+                | PointerKind::UniqueBorrowed\n+                | PointerKind::UniqueBorrowedPinned => false,\n+                PointerKind::UniqueOwned => noalias_for_box,\n+                PointerKind::Frozen => !is_return,\n+            };\n+            if no_alias {\n+                attrs.set(ArgAttribute::NoAlias);\n+            }\n+\n+            if kind == PointerKind::Frozen && !is_return {\n+                attrs.set(ArgAttribute::ReadOnly);\n+            }\n+\n+            if kind == PointerKind::UniqueBorrowed && !is_return {\n+                attrs.set(ArgAttribute::NoAliasMutRef);\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n     // FIXME(eddyb) perhaps group the signature/type-containing (or all of them?)\n     // arguments of this method, into a separate `struct`.\n@@ -3118,91 +3206,6 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         use SpecAbi::*;\n         let rust_abi = matches!(sig.abi, RustIntrinsic | PlatformIntrinsic | Rust | RustCall);\n \n-        // Handle safe Rust thin and fat pointers.\n-        let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n-                                      scalar: Scalar,\n-                                      layout: TyAndLayout<'tcx>,\n-                                      offset: Size,\n-                                      is_return: bool| {\n-            // Booleans are always a noundef i1 that needs to be zero-extended.\n-            if scalar.is_bool() {\n-                attrs.ext(ArgExtension::Zext);\n-                attrs.set(ArgAttribute::NoUndef);\n-                return;\n-            }\n-\n-            // Scalars which have invalid values cannot be undef.\n-            if !scalar.is_always_valid(self) {\n-                attrs.set(ArgAttribute::NoUndef);\n-            }\n-\n-            // Only pointer types handled below.\n-            let Scalar::Initialized { value: Pointer, valid_range} = scalar else { return };\n-\n-            if !valid_range.contains(0) {\n-                attrs.set(ArgAttribute::NonNull);\n-            }\n-\n-            if let Some(pointee) = layout.pointee_info_at(self, offset) {\n-                if let Some(kind) = pointee.safe {\n-                    attrs.pointee_align = Some(pointee.align);\n-\n-                    // `Box` (`UniqueBorrowed`) are not necessarily dereferenceable\n-                    // for the entire duration of the function as they can be deallocated\n-                    // at any time. Same for shared mutable references. If LLVM had a\n-                    // way to say \"dereferenceable on entry\" we could use it here.\n-                    attrs.pointee_size = match kind {\n-                        PointerKind::UniqueBorrowed\n-                        | PointerKind::UniqueBorrowedPinned\n-                        | PointerKind::Frozen => pointee.size,\n-                        PointerKind::SharedMutable | PointerKind::UniqueOwned => Size::ZERO,\n-                    };\n-\n-                    // `Box`, `&T`, and `&mut T` cannot be undef.\n-                    // Note that this only applies to the value of the pointer itself;\n-                    // this attribute doesn't make it UB for the pointed-to data to be undef.\n-                    attrs.set(ArgAttribute::NoUndef);\n-\n-                    // The aliasing rules for `Box<T>` are still not decided, but currently we emit\n-                    // `noalias` for it. This can be turned off using an unstable flag.\n-                    // See https://github.com/rust-lang/unsafe-code-guidelines/issues/326\n-                    let noalias_for_box =\n-                        self.tcx().sess.opts.unstable_opts.box_noalias.unwrap_or(true);\n-\n-                    // `&mut` pointer parameters never alias other parameters,\n-                    // or mutable global data\n-                    //\n-                    // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n-                    // and can be marked as both `readonly` and `noalias`, as\n-                    // LLVM's definition of `noalias` is based solely on memory\n-                    // dependencies rather than pointer equality\n-                    //\n-                    // Due to past miscompiles in LLVM, we apply a separate NoAliasMutRef attribute\n-                    // for UniqueBorrowed arguments, so that the codegen backend can decide whether\n-                    // or not to actually emit the attribute. It can also be controlled with the\n-                    // `-Zmutable-noalias` debugging option.\n-                    let no_alias = match kind {\n-                        PointerKind::SharedMutable\n-                        | PointerKind::UniqueBorrowed\n-                        | PointerKind::UniqueBorrowedPinned => false,\n-                        PointerKind::UniqueOwned => noalias_for_box,\n-                        PointerKind::Frozen => !is_return,\n-                    };\n-                    if no_alias {\n-                        attrs.set(ArgAttribute::NoAlias);\n-                    }\n-\n-                    if kind == PointerKind::Frozen && !is_return {\n-                        attrs.set(ArgAttribute::ReadOnly);\n-                    }\n-\n-                    if kind == PointerKind::UniqueBorrowed && !is_return {\n-                        attrs.set(ArgAttribute::NoAliasMutRef);\n-                    }\n-                }\n-            }\n-        };\n-\n         let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| -> Result<_, FnAbiError<'tcx>> {\n             let is_return = arg_idx.is_none();\n \n@@ -3218,7 +3221,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n             let mut arg = ArgAbi::new(self, layout, |layout, scalar, offset| {\n                 let mut attrs = ArgAttributes::new();\n-                adjust_for_rust_scalar(&mut attrs, scalar, *layout, offset, is_return);\n+                adjust_for_rust_scalar(*self, &mut attrs, scalar, *layout, offset, is_return);\n                 attrs\n             });\n "}, {"sha": "69b49604250b4491607f8e31b9245b5ff4f2bd9f", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -10,6 +10,7 @@\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n #![feature(yeet_expr)]\n+#![feature(if_let_guard)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]\n@@ -27,10 +28,13 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::Visitor as _;\n use rustc_middle::mir::{\n-    traversal, AnalysisPhase, Body, ConstQualifs, MirPass, MirPhase, Promoted, RuntimePhase,\n+    traversal, AnalysisPhase, Body, ConstQualifs, Constant, LocalDecl, MirPass, MirPhase, Operand,\n+    Place, ProjectionElem, Promoted, RuntimePhase, Rvalue, SourceInfo, Statement, StatementKind,\n+    TerminatorKind,\n };\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n+use rustc_span::sym;\n \n #[macro_use]\n mod pass_manager;\n@@ -140,6 +144,64 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n+fn remap_mir_for_const_eval_select<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mut body: Body<'tcx>,\n+    context: hir::Constness,\n+) -> Body<'tcx> {\n+    for bb in body.basic_blocks.as_mut().iter_mut() {\n+        let terminator = bb.terminator.as_mut().expect(\"invalid terminator\");\n+        match terminator.kind {\n+            TerminatorKind::Call {\n+                func: Operand::Constant(box Constant { ref literal, .. }),\n+                ref mut args,\n+                destination,\n+                target,\n+                cleanup,\n+                fn_span,\n+                ..\n+            } if let ty::FnDef(def_id, _) = *literal.ty().kind()\n+                && tcx.item_name(def_id) == sym::const_eval_select\n+                && tcx.is_intrinsic(def_id) =>\n+            {\n+                let [tupled_args, called_in_const, called_at_rt]: [_; 3] = std::mem::take(args).try_into().unwrap();\n+                let ty = tupled_args.ty(&body.local_decls, tcx);\n+                let fields = ty.tuple_fields();\n+                let num_args = fields.len();\n+                let func = if context == hir::Constness::Const { called_in_const } else { called_at_rt };\n+                let (method, place): (fn(Place<'tcx>) -> Operand<'tcx>, Place<'tcx>) = match tupled_args {\n+                    Operand::Constant(_) => {\n+                        // there is no good way of extracting a tuple arg from a constant (const generic stuff)\n+                        // so we just create a temporary and deconstruct that.\n+                        let local = body.local_decls.push(LocalDecl::new(ty, fn_span));\n+                        bb.statements.push(Statement {\n+                            source_info: SourceInfo::outermost(fn_span),\n+                            kind: StatementKind::Assign(Box::new((local.into(), Rvalue::Use(tupled_args.clone())))),\n+                        });\n+                        (Operand::Move, local.into())\n+                    }\n+                    Operand::Move(place) => (Operand::Move, place),\n+                    Operand::Copy(place) => (Operand::Copy, place),\n+                };\n+                let place_elems = place.projection;\n+                let arguments = (0..num_args).map(|x| {\n+                    let mut place_elems = place_elems.to_vec();\n+                    place_elems.push(ProjectionElem::Field(x.into(), fields[x]));\n+                    let projection = tcx.intern_place_elems(&place_elems);\n+                    let place = Place {\n+                        local: place.local,\n+                        projection,\n+                    };\n+                    method(place)\n+                }).collect();\n+                terminator.kind = TerminatorKind::Call { func, args: arguments, destination, target, cleanup, from_hir_call: false, fn_span };\n+            }\n+            _ => {}\n+        }\n+    }\n+    body\n+}\n+\n fn is_mir_available(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let def_id = def_id.expect_local();\n     tcx.mir_keys(()).contains(&def_id)\n@@ -354,7 +416,7 @@ fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -\n \n     debug_assert!(!body.has_free_regions(), \"Free regions in MIR for CTFE\");\n \n-    body\n+    remap_mir_for_const_eval_select(tcx, body, hir::Constness::Const)\n }\n \n /// Obtain just the main MIR (no promoteds) and run some cleanups on it. This also runs\n@@ -565,7 +627,7 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> Body<'_> {\n \n     debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");\n \n-    body\n+    remap_mir_for_const_eval_select(tcx, body, hir::Constness::NotConst)\n }\n \n /// Fetch all the promoteds of an item and prepare their MIR bodies to be ready for"}, {"sha": "be74a9d11e3c5abe6dcf4b4726785b65788d617a", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -112,12 +112,6 @@\n //! method in operand position, we treat it as a neighbor of the current\n //! mono item. Calls are just a special case of that.\n //!\n-//! #### Closures\n-//! In a way, closures are a simple case. Since every closure object needs to be\n-//! constructed somewhere, we can reliably discover them by observing\n-//! `RValue::Aggregate` expressions with `AggregateKind::Closure`. This is also\n-//! true for closures inlined from other crates.\n-//!\n //! #### Drop glue\n //! Drop glue mono items are introduced by MIR drop-statements. The\n //! generated mono item will again have drop-glue item neighbors if the\n@@ -835,7 +829,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.body, tcx);\n                 let callee_ty = self.monomorphize(callee_ty);\n-                visit_fn_use(self.tcx, callee_ty, true, source, &mut self.output);\n+                visit_fn_use(self.tcx, callee_ty, true, source, &mut self.output)\n             }\n             mir::TerminatorKind::Drop { ref place, .. }\n             | mir::TerminatorKind::DropAndReplace { ref place, .. } => {"}, {"sha": "f6ce7675c8faeae58ca87af6f66be5be9c5bbe51", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -510,7 +510,6 @@ symbols! {\n         const_deallocate,\n         const_eval_limit,\n         const_eval_select,\n-        const_eval_select_ct,\n         const_evaluatable_checked,\n         const_extern_fn,\n         const_fn,"}, {"sha": "d1d27db9131fde6fcb675a6311f358a36a5fd233", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -31,7 +31,7 @@ use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty, TypeSuperVisitable, TypeVisitor};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n-use rustc_span::{self, Span};\n+use rustc_span::{self, sym, Span};\n use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext};\n \n use std::iter;\n@@ -224,6 +224,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let minimum_input_count = expected_input_tys.len();\n         let provided_arg_count = provided_args.len();\n \n+        let is_const_eval_select = matches!(fn_def_id, Some(def_id) if\n+            self.tcx.def_kind(def_id) == hir::def::DefKind::Fn\n+            && self.tcx.is_intrinsic(def_id)\n+            && self.tcx.item_name(def_id) == sym::const_eval_select);\n+\n         // We introduce a helper function to demand that a given argument satisfy a given input\n         // This is more complicated than just checking type equality, as arguments could be coerced\n         // This version writes those types back so further type checking uses the narrowed types\n@@ -259,6 +264,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return Compatibility::Incompatible(coerce_error);\n             }\n \n+            // Check that second and third argument of `const_eval_select` must be `FnDef`, and additionally that\n+            // the second argument must be `const fn`. The first argument must be a tuple, but this is already expressed\n+            // in the function signature (`F: FnOnce<ARG>`), so I did not bother to add another check here.\n+            //\n+            // This check is here because there is currently no way to express a trait bound for `FnDef` types only.\n+            if is_const_eval_select && (1..=2).contains(&idx) {\n+                if let ty::FnDef(def_id, _) = checked_ty.kind() {\n+                    if idx == 1 && !self.tcx.is_const_fn_raw(*def_id) {\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(provided_arg.span, \"this argument must be a `const fn`\")\n+                            .help(\"consult the documentation on `const_eval_select` for more information\")\n+                            .emit();\n+                    }\n+                } else {\n+                    self.tcx\n+                        .sess\n+                        .struct_span_err(provided_arg.span, \"this argument must be a function item\")\n+                        .note(format!(\"expected a function item, found {checked_ty}\"))\n+                        .help(\n+                            \"consult the documentation on `const_eval_select` for more information\",\n+                        )\n+                        .emit();\n+                }\n+            }\n+\n             // 3. Check if the formal type is a supertype of the checked one\n             //    and register any such obligations for future type checks\n             let supertype_error = self"}, {"sha": "12e4dfe74fb88538a3cc8f6ab0d5375645357ec9", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 81, "deletions": 62, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -54,7 +54,9 @@\n )]\n #![allow(missing_docs)]\n \n-use crate::marker::{Destruct, DiscriminantKind};\n+#[cfg(bootstrap)]\n+use crate::marker::Destruct;\n+use crate::marker::DiscriminantKind;\n use crate::mem;\n \n // These imports are used for simplifying intra-doc links\n@@ -2085,6 +2087,65 @@ extern \"rust-intrinsic\" {\n     /// `ptr` must point to a vtable.\n     /// The intrinsic will return the alignment stored in that vtable.\n     pub fn vtable_align(ptr: *const ()) -> usize;\n+\n+    /// Selects which function to call depending on the context.\n+    ///\n+    /// If this function is evaluated at compile-time, then a call to this\n+    /// intrinsic will be replaced with a call to `called_in_const`. It gets\n+    /// replaced with a call to `called_at_rt` otherwise.\n+    ///\n+    /// # Type Requirements\n+    ///\n+    /// The two functions must be both function items. They cannot be function\n+    /// pointers or closures. The first function must be a `const fn`.\n+    ///\n+    /// `arg` will be the tupled arguments that will be passed to either one of\n+    /// the two functions, therefore, both functions must accept the same type of\n+    /// arguments. Both functions must return RET.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The two functions must behave observably equivalent. Safe code in other\n+    /// crates may assume that calling a `const fn` at compile-time and at run-time\n+    /// produces the same result. A function that produces a different result when\n+    /// evaluated at run-time, or has any other observable side-effects, is\n+    /// *unsound*.\n+    ///\n+    /// Here is an example of how this could cause a problem:\n+    /// ```no_run\n+    /// #![feature(const_eval_select)]\n+    /// #![feature(core_intrinsics)]\n+    /// use std::hint::unreachable_unchecked;\n+    /// use std::intrinsics::const_eval_select;\n+    ///\n+    /// // Crate A\n+    /// pub const fn inconsistent() -> i32 {\n+    ///     fn runtime() -> i32 { 1 }\n+    ///     const fn compiletime() -> i32 { 2 }\n+    ///\n+    ///     unsafe {\n+    //          // \u26a0 This code violates the required equivalence of `compiletime`\n+    ///         // and `runtime`.\n+    ///         const_eval_select((), compiletime, runtime)\n+    ///     }\n+    /// }\n+    ///\n+    /// // Crate B\n+    /// const X: i32 = inconsistent();\n+    /// let x = inconsistent();\n+    /// if x != X { unsafe { unreachable_unchecked(); }}\n+    /// ```\n+    ///\n+    /// This code causes Undefined Behavior when being run, since the\n+    /// `unreachable_unchecked` is actually being reached. The bug is in *crate A*,\n+    /// which violates the principle that a `const fn` must behave the same at\n+    /// compile-time and at run-time. The unsafe code in crate B is fine.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_unstable(feature = \"const_eval_select\", issue = \"none\")]\n+    pub fn const_eval_select<ARG, F, G, RET>(arg: ARG, called_in_const: F, called_at_rt: G) -> RET\n+    where\n+        G: FnOnce<ARG, Output = RET>,\n+        F: FnOnce<ARG, Output = RET>;\n }\n \n // Some functions are defined here because they accidentally got made\n@@ -2095,6 +2156,11 @@ extern \"rust-intrinsic\" {\n /// Check that the preconditions of an unsafe function are followed, if debug_assertions are on,\n /// and only at runtime.\n ///\n+/// This macro should be called as `assert_unsafe_precondition!([Generics](name: Type) => Expression)`\n+/// where the names specified will be moved into the macro as captured variables, and defines an item\n+/// to call `const_eval_select` on. The tokens inside the square brackets are used to denote generics\n+/// for the function declaractions and can be omitted if there is no generics.\n+///\n /// # Safety\n ///\n /// Invoking this macro is only sound if the following code is already UB when the passed\n@@ -2109,18 +2175,20 @@ extern \"rust-intrinsic\" {\n /// the occasional mistake, and this check should help them figure things out.\n #[allow_internal_unstable(const_eval_select)] // permit this to be called in stably-const fn\n macro_rules! assert_unsafe_precondition {\n-    ($e:expr) => {\n+    ($([$($tt:tt)*])?($($i:ident:$ty:ty),*$(,)?) => $e:expr) => {\n         if cfg!(debug_assertions) {\n-            // Use a closure so that we can capture arbitrary expressions from the invocation\n-            let runtime = || {\n+            // allow non_snake_case to allow capturing const generics\n+            #[allow(non_snake_case)]\n+            fn runtime$(<$($tt)*>)?($($i:$ty),*) {\n                 if !$e {\n                     // abort instead of panicking to reduce impact on code size\n                     ::core::intrinsics::abort();\n                 }\n-            };\n-            const fn comptime() {}\n+            }\n+            #[allow(non_snake_case)]\n+            const fn comptime$(<$($tt)*>)?($(_:$ty),*) {}\n \n-            ::core::intrinsics::const_eval_select((), comptime, runtime);\n+            ::core::intrinsics::const_eval_select(($($i,)*), comptime, runtime);\n         }\n     };\n }\n@@ -2243,7 +2311,7 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n     // SAFETY: the safety contract for `copy_nonoverlapping` must be\n     // upheld by the caller.\n     unsafe {\n-        assert_unsafe_precondition!(\n+        assert_unsafe_precondition!([T](src: *const T, dst: *mut T, count: usize) =>\n             is_aligned_and_not_null(src)\n                 && is_aligned_and_not_null(dst)\n                 && is_nonoverlapping(src, dst, count)\n@@ -2329,7 +2397,8 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n \n     // SAFETY: the safety contract for `copy` must be upheld by the caller.\n     unsafe {\n-        assert_unsafe_precondition!(is_aligned_and_not_null(src) && is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!([T](src: *const T, dst: *mut T) =>\n+            is_aligned_and_not_null(src) && is_aligned_and_not_null(dst));\n         copy(src, dst, count)\n     }\n }\n@@ -2397,63 +2466,12 @@ pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n \n     // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n     unsafe {\n-        assert_unsafe_precondition!(is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n         write_bytes(dst, val, count)\n     }\n }\n \n-/// Selects which function to call depending on the context.\n-///\n-/// If this function is evaluated at compile-time, then a call to this\n-/// intrinsic will be replaced with a call to `called_in_const`. It gets\n-/// replaced with a call to `called_at_rt` otherwise.\n-///\n-/// # Type Requirements\n-///\n-/// The two functions must be both function items. They cannot be function\n-/// pointers or closures.\n-///\n-/// `arg` will be the arguments that will be passed to either one of the\n-/// two functions, therefore, both functions must accept the same type of\n-/// arguments. Both functions must return RET.\n-///\n-/// # Safety\n-///\n-/// The two functions must behave observably equivalent. Safe code in other\n-/// crates may assume that calling a `const fn` at compile-time and at run-time\n-/// produces the same result. A function that produces a different result when\n-/// evaluated at run-time, or has any other observable side-effects, is\n-/// *unsound*.\n-///\n-/// Here is an example of how this could cause a problem:\n-/// ```no_run\n-/// #![feature(const_eval_select)]\n-/// #![feature(core_intrinsics)]\n-/// use std::hint::unreachable_unchecked;\n-/// use std::intrinsics::const_eval_select;\n-///\n-/// // Crate A\n-/// pub const fn inconsistent() -> i32 {\n-///     fn runtime() -> i32 { 1 }\n-///     const fn compiletime() -> i32 { 2 }\n-///\n-///     unsafe {\n-//          // \u26a0 This code violates the required equivalence of `compiletime`\n-///         // and `runtime`.\n-///         const_eval_select((), compiletime, runtime)\n-///     }\n-/// }\n-///\n-/// // Crate B\n-/// const X: i32 = inconsistent();\n-/// let x = inconsistent();\n-/// if x != X { unsafe { unreachable_unchecked(); }}\n-/// ```\n-///\n-/// This code causes Undefined Behavior when being run, since the\n-/// `unreachable_unchecked` is actually being reached. The bug is in *crate A*,\n-/// which violates the principle that a `const fn` must behave the same at\n-/// compile-time and at run-time. The unsafe code in crate B is fine.\n+#[cfg(bootstrap)]\n #[unstable(\n     feature = \"const_eval_select\",\n     issue = \"none\",\n@@ -2475,6 +2493,7 @@ where\n     called_at_rt.call_once(arg)\n }\n \n+#[cfg(bootstrap)]\n #[unstable(\n     feature = \"const_eval_select\",\n     issue = \"none\","}, {"sha": "32b2afb72b0dc306bbca2f545b92d29eec6571b2", "filename": "library/core/src/mem/valid_align.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fmem%2Fvalid_align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fmem%2Fvalid_align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fvalid_align.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -28,7 +28,7 @@ impl ValidAlign {\n     #[inline]\n     pub(crate) const unsafe fn new_unchecked(align: usize) -> Self {\n         // SAFETY: Precondition passed to the caller.\n-        unsafe { assert_unsafe_precondition!(align.is_power_of_two()) };\n+        unsafe { assert_unsafe_precondition!((align: usize) => align.is_power_of_two()) };\n \n         // SAFETY: By precondition, this must be a power of two, and\n         // our variants encompass all possible powers of two."}, {"sha": "6983d83808db8b2b5e68639aa1b39d4d16f044a9", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -1033,10 +1033,13 @@ impl f32 {\n                 }\n             }\n         }\n-        // SAFETY: `u32` is a plain old datatype so we can always... uh...\n-        // ...look, just pretend you forgot what you just read.\n-        // Stability concerns.\n-        let rt_f32_to_u32 = |rt| unsafe { mem::transmute::<f32, u32>(rt) };\n+\n+        fn rt_f32_to_u32(x: f32) -> u32 {\n+            // SAFETY: `u32` is a plain old datatype so we can always... uh...\n+            // ...look, just pretend you forgot what you just read.\n+            // Stability concerns.\n+            unsafe { mem::transmute(x) }\n+        }\n         // SAFETY: We use internal implementations that either always work or fail at compile time.\n         unsafe { intrinsics::const_eval_select((self,), ct_f32_to_u32, rt_f32_to_u32) }\n     }\n@@ -1121,10 +1124,13 @@ impl f32 {\n                 }\n             }\n         }\n-        // SAFETY: `u32` is a plain old datatype so we can always... uh...\n-        // ...look, just pretend you forgot what you just read.\n-        // Stability concerns.\n-        let rt_u32_to_f32 = |rt| unsafe { mem::transmute::<u32, f32>(rt) };\n+\n+        fn rt_u32_to_f32(x: u32) -> f32 {\n+            // SAFETY: `u32` is a plain old datatype so we can always... uh...\n+            // ...look, just pretend you forgot what you just read.\n+            // Stability concerns.\n+            unsafe { mem::transmute(x) }\n+        }\n         // SAFETY: We use internal implementations that either always work or fail at compile time.\n         unsafe { intrinsics::const_eval_select((v,), ct_u32_to_f32, rt_u32_to_f32) }\n     }"}, {"sha": "ce64afc0bd892b3da048892a9b5d080954b720ec", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -1026,10 +1026,13 @@ impl f64 {\n                 }\n             }\n         }\n-        // SAFETY: `u64` is a plain old datatype so we can always... uh...\n-        // ...look, just pretend you forgot what you just read.\n-        // Stability concerns.\n-        let rt_f64_to_u64 = |rt| unsafe { mem::transmute::<f64, u64>(rt) };\n+\n+        fn rt_f64_to_u64(rt: f64) -> u64 {\n+            // SAFETY: `u64` is a plain old datatype so we can always... uh...\n+            // ...look, just pretend you forgot what you just read.\n+            // Stability concerns.\n+            unsafe { mem::transmute::<f64, u64>(rt) }\n+        }\n         // SAFETY: We use internal implementations that either always work or fail at compile time.\n         unsafe { intrinsics::const_eval_select((self,), ct_f64_to_u64, rt_f64_to_u64) }\n     }\n@@ -1119,10 +1122,13 @@ impl f64 {\n                 }\n             }\n         }\n-        // SAFETY: `u64` is a plain old datatype so we can always... uh...\n-        // ...look, just pretend you forgot what you just read.\n-        // Stability concerns.\n-        let rt_u64_to_f64 = |rt| unsafe { mem::transmute::<u64, f64>(rt) };\n+\n+        fn rt_u64_to_f64(rt: u64) -> f64 {\n+            // SAFETY: `u64` is a plain old datatype so we can always... uh...\n+            // ...look, just pretend you forgot what you just read.\n+            // Stability concerns.\n+            unsafe { mem::transmute::<u64, f64>(rt) }\n+        }\n         // SAFETY: We use internal implementations that either always work or fail at compile time.\n         unsafe { intrinsics::const_eval_select((v,), ct_u64_to_f64, rt_u64_to_f64) }\n     }"}, {"sha": "532a09736a7acf43c99859ca2c7f18552df0b363", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -56,7 +56,7 @@ macro_rules! nonzero_integers {\n                 pub const unsafe fn new_unchecked(n: $Int) -> Self {\n                     // SAFETY: this is guaranteed to be safe by the caller.\n                     unsafe {\n-                        core::intrinsics::assert_unsafe_precondition!(n != 0);\n+                        core::intrinsics::assert_unsafe_precondition!((n: $Int) => n != 0);\n                         Self(n)\n                     }\n                 }"}, {"sha": "80bff74f3e9f4712c8d7e26ab320655a32e081cd", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -755,9 +755,12 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n+        let this = self;\n         // SAFETY: The comparison has no side-effects, and the intrinsic\n         // does this check internally in the CTFE implementation.\n-        unsafe { assert_unsafe_precondition!(self >= origin) };\n+        unsafe {\n+            assert_unsafe_precondition!([T](this: *const T, origin: *const T) => this >= origin)\n+        };\n \n         let pointee_size = mem::size_of::<T>();\n         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);"}, {"sha": "e976abed774b8d21cd1a4b3b48fbe74f8e7cd8c1", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -886,7 +886,7 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n     // SAFETY: the caller must guarantee that `x` and `y` are\n     // valid for writes and properly aligned.\n     unsafe {\n-        assert_unsafe_precondition!(\n+        assert_unsafe_precondition!([T](x: *mut T, y: *mut T, count: usize) =>\n             is_aligned_and_not_null(x)\n                 && is_aligned_and_not_null(y)\n                 && is_nonoverlapping(x, y, count)\n@@ -983,7 +983,7 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n     // and cannot overlap `src` since `dst` must point to a distinct\n     // allocated object.\n     unsafe {\n-        assert_unsafe_precondition!(is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n         mem::swap(&mut *dst, &mut src); // cannot overlap\n     }\n     src\n@@ -1470,7 +1470,7 @@ pub const unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n pub unsafe fn read_volatile<T>(src: *const T) -> T {\n     // SAFETY: the caller must uphold the safety contract for `volatile_load`.\n     unsafe {\n-        assert_unsafe_precondition!(is_aligned_and_not_null(src));\n+        assert_unsafe_precondition!([T](src: *const T) => is_aligned_and_not_null(src));\n         intrinsics::volatile_load(src)\n     }\n }\n@@ -1541,7 +1541,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n     // SAFETY: the caller must uphold the safety contract for `volatile_store`.\n     unsafe {\n-        assert_unsafe_precondition!(is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n         intrinsics::volatile_store(dst, src);\n     }\n }"}, {"sha": "3403a5a86f7cb8af4022bab30abaee5bb1ddd240", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -48,10 +48,12 @@ const fn slice_start_index_len_fail(index: usize, len: usize) -> ! {\n }\n \n // FIXME const-hack\n+#[track_caller]\n fn slice_start_index_len_fail_rt(index: usize, len: usize) -> ! {\n     panic!(\"range start index {index} out of range for slice of length {len}\");\n }\n \n+#[track_caller]\n const fn slice_start_index_len_fail_ct(_: usize, _: usize) -> ! {\n     panic!(\"slice start index is out of range for slice\");\n }\n@@ -69,10 +71,12 @@ const fn slice_end_index_len_fail(index: usize, len: usize) -> ! {\n }\n \n // FIXME const-hack\n+#[track_caller]\n fn slice_end_index_len_fail_rt(index: usize, len: usize) -> ! {\n     panic!(\"range end index {index} out of range for slice of length {len}\");\n }\n \n+#[track_caller]\n const fn slice_end_index_len_fail_ct(_: usize, _: usize) -> ! {\n     panic!(\"slice end index is out of range for slice\");\n }\n@@ -88,10 +92,12 @@ const fn slice_index_order_fail(index: usize, end: usize) -> ! {\n }\n \n // FIXME const-hack\n+#[track_caller]\n fn slice_index_order_fail_rt(index: usize, end: usize) -> ! {\n     panic!(\"slice index starts at {index} but ends at {end}\");\n }\n \n+#[track_caller]\n const fn slice_index_order_fail_ct(_: usize, _: usize) -> ! {\n     panic!(\"slice index start is larger than end\");\n }\n@@ -217,21 +223,23 @@ unsafe impl<T> const SliceIndex<[T]> for usize {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {\n+        let this = self;\n         // SAFETY: the caller guarantees that `slice` is not dangling, so it\n         // cannot be longer than `isize::MAX`. They also guarantee that\n         // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n         // so the call to `add` is safe.\n         unsafe {\n-            assert_unsafe_precondition!(self < slice.len());\n+            assert_unsafe_precondition!([T](this: usize, slice: *const [T]) => this < slice.len());\n             slice.as_ptr().add(self)\n         }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut T {\n+        let this = self;\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n-            assert_unsafe_precondition!(self < slice.len());\n+            assert_unsafe_precondition!([T](this: usize, slice: *mut [T]) => this < slice.len());\n             slice.as_mut_ptr().add(self)\n         }\n     }\n@@ -276,22 +284,26 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        let this = ops::Range { start: self.start, end: self.end };\n         // SAFETY: the caller guarantees that `slice` is not dangling, so it\n         // cannot be longer than `isize::MAX`. They also guarantee that\n         // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n         // so the call to `add` is safe.\n \n         unsafe {\n-            assert_unsafe_precondition!(self.end >= self.start && self.end <= slice.len());\n+            assert_unsafe_precondition!([T](this: ops::Range<usize>, slice: *const [T]) =>\n+            this.end >= this.start && this.end <= slice.len());\n             ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start)\n         }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n+        let this = ops::Range { start: self.start, end: self.end };\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n-            assert_unsafe_precondition!(self.end >= self.start && self.end <= slice.len());\n+            assert_unsafe_precondition!([T](this: ops::Range<usize>, slice: *mut [T]) =>\n+                this.end >= this.start && this.end <= slice.len());\n             ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n         }\n     }"}, {"sha": "6a7150d2986edf50ef3e439ac23ea62d00d0a735", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -656,10 +656,11 @@ impl<T> [T] {\n     #[unstable(feature = \"slice_swap_unchecked\", issue = \"88539\")]\n     #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n     pub const unsafe fn swap_unchecked(&mut self, a: usize, b: usize) {\n-        let ptr = self.as_mut_ptr();\n+        let this = self;\n+        let ptr = this.as_mut_ptr();\n         // SAFETY: caller has to guarantee that `a < self.len()` and `b < self.len()`\n         unsafe {\n-            assert_unsafe_precondition!(a < self.len() && b < self.len());\n+            assert_unsafe_precondition!([T](a: usize, b: usize, this: &mut [T]) => a < this.len() && b < this.len());\n             ptr::swap(ptr.add(a), ptr.add(b));\n         }\n     }\n@@ -972,9 +973,10 @@ impl<T> [T] {\n     #[inline]\n     #[must_use]\n     pub unsafe fn as_chunks_unchecked<const N: usize>(&self) -> &[[T; N]] {\n+        let this = self;\n         // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n         let new_len = unsafe {\n-            assert_unsafe_precondition!(N != 0 && self.len() % N == 0);\n+            assert_unsafe_precondition!([T](this: &[T], N: usize) => N != 0 && this.len() % N == 0);\n             exact_div(self.len(), N)\n         };\n         // SAFETY: We cast a slice of `new_len * N` elements into\n@@ -1111,10 +1113,11 @@ impl<T> [T] {\n     #[inline]\n     #[must_use]\n     pub unsafe fn as_chunks_unchecked_mut<const N: usize>(&mut self) -> &mut [[T; N]] {\n+        let this = &*self;\n         // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n         let new_len = unsafe {\n-            assert_unsafe_precondition!(N != 0 && self.len() % N == 0);\n-            exact_div(self.len(), N)\n+            assert_unsafe_precondition!([T](this: &[T], N: usize) => N != 0 && this.len() % N == 0);\n+            exact_div(this.len(), N)\n         };\n         // SAFETY: We cast a slice of `new_len * N` elements into\n         // a slice of `new_len` many `N` elements chunks.\n@@ -1687,7 +1690,7 @@ impl<T> [T] {\n         // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference\n         // is fine.\n         unsafe {\n-            assert_unsafe_precondition!(mid <= len);\n+            assert_unsafe_precondition!((mid: usize, len: usize) => mid <= len);\n             (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid))\n         }\n     }"}, {"sha": "f1e8bc79bf4a2d042d19a9ea90fd6a8e61e9482f", "filename": "library/core/src/slice/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -90,7 +90,7 @@ use crate::ptr;\n pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n     unsafe {\n-        assert_unsafe_precondition!(\n+        assert_unsafe_precondition!([T](data: *const T, len: usize) =>\n             is_aligned_and_not_null(data)\n                 && crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize\n         );\n@@ -134,7 +134,7 @@ pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T]\n pub const unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n     unsafe {\n-        assert_unsafe_precondition!(\n+        assert_unsafe_precondition!([T](data: *mut T, len: usize) =>\n             is_aligned_and_not_null(data)\n                 && crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize\n         );"}, {"sha": "f673aa2a44b1023ee612a5e355ad4bbc59e25074", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -91,10 +91,12 @@ const fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     }\n }\n \n+#[track_caller]\n const fn slice_error_fail_ct(_: &str, _: usize, _: usize) -> ! {\n     panic!(\"failed to slice string\");\n }\n \n+#[track_caller]\n fn slice_error_fail_rt(s: &str, begin: usize, end: usize) -> ! {\n     const MAX_DISPLAY_LENGTH: usize = 256;\n     let trunc_len = s.floor_char_boundary(MAX_DISPLAY_LENGTH);"}, {"sha": "01f2f48956458cf35e3eeea2386c6c2c0b5955c8", "filename": "src/test/ui/consts/const-float-bits-reject-conv.stderr", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-reject-conv.stderr?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -10,16 +10,6 @@ LL |                     panic!(\"const-eval error: cannot use f32::to_bits on a\n LL |         unsafe { intrinsics::const_eval_select((self,), ct_f32_to_u32, rt_f32_to_u32) }\n    |                  -------------------------------------------------------------------- inside `core::f32::<impl f32>::to_bits` at $SRC_DIR/core/src/num/f32.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n-   |     ------------------------------------------------------------------ inside `<fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32} as FnOnce<(f32,)>>::call_once - shim(fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32})` at $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-  ::: $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n-LL |     called_in_const.call_once(arg)\n-   |     ------------------------------ inside `const_eval_select::<(f32,), fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32}, [closure@core::f32::<impl f32>::to_bits::{closure#0}], u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n   ::: $DIR/const-float-bits-reject-conv.rs:27:30\n    |\n LL |     const MASKED_NAN1: u32 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n@@ -39,16 +29,6 @@ LL |                     panic!(\"const-eval error: cannot use f32::to_bits on a\n LL |         unsafe { intrinsics::const_eval_select((self,), ct_f32_to_u32, rt_f32_to_u32) }\n    |                  -------------------------------------------------------------------- inside `core::f32::<impl f32>::to_bits` at $SRC_DIR/core/src/num/f32.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n-   |     ------------------------------------------------------------------ inside `<fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32} as FnOnce<(f32,)>>::call_once - shim(fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32})` at $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-  ::: $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n-LL |     called_in_const.call_once(arg)\n-   |     ------------------------------ inside `const_eval_select::<(f32,), fn(f32) -> u32 {core::f32::<impl f32>::to_bits::ct_f32_to_u32}, [closure@core::f32::<impl f32>::to_bits::{closure#0}], u32>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n   ::: $DIR/const-float-bits-reject-conv.rs:28:30\n    |\n LL |     const MASKED_NAN2: u32 = f32::NAN.to_bits() ^ 0x0055_5555;\n@@ -117,16 +97,6 @@ LL |                     panic!(\"const-eval error: cannot use f64::to_bits on a\n LL |         unsafe { intrinsics::const_eval_select((self,), ct_f64_to_u64, rt_f64_to_u64) }\n    |                  -------------------------------------------------------------------- inside `core::f64::<impl f64>::to_bits` at $SRC_DIR/core/src/num/f64.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n-   |     ------------------------------------------------------------------ inside `<fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64} as FnOnce<(f64,)>>::call_once - shim(fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64})` at $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-  ::: $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n-LL |     called_in_const.call_once(arg)\n-   |     ------------------------------ inside `const_eval_select::<(f64,), fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64}, [closure@core::f64::<impl f64>::to_bits::{closure#0}], u64>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n   ::: $DIR/const-float-bits-reject-conv.rs:54:30\n    |\n LL |     const MASKED_NAN1: u64 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n@@ -146,16 +116,6 @@ LL |                     panic!(\"const-eval error: cannot use f64::to_bits on a\n LL |         unsafe { intrinsics::const_eval_select((self,), ct_f64_to_u64, rt_f64_to_u64) }\n    |                  -------------------------------------------------------------------- inside `core::f64::<impl f64>::to_bits` at $SRC_DIR/core/src/num/f64.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-LL |     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n-   |     ------------------------------------------------------------------ inside `<fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64} as FnOnce<(f64,)>>::call_once - shim(fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64})` at $SRC_DIR/core/src/ops/function.rs:LL:COL\n-   |\n-  ::: $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n-LL |     called_in_const.call_once(arg)\n-   |     ------------------------------ inside `const_eval_select::<(f64,), fn(f64) -> u64 {core::f64::<impl f64>::to_bits::ct_f64_to_u64}, [closure@core::f64::<impl f64>::to_bits::{closure#0}], u64>` at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n-   |\n   ::: $DIR/const-float-bits-reject-conv.rs:55:30\n    |\n LL |     const MASKED_NAN2: u64 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;"}, {"sha": "29aefe07162b3170d285ad0844a5d2c4ee78aa15", "filename": "src/test/ui/intrinsics/const-eval-select-backtrace-std.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-backtrace-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-backtrace-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-backtrace-std.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -0,0 +1,6 @@\n+// See issue #100696.\n+// run-fail\n+// check-run-results\n+fn main() {\n+    &\"\"[1..];\n+}"}, {"sha": "e53e6034620ca74541580ff12d67cf78733a89d6", "filename": "src/test/ui/intrinsics/const-eval-select-backtrace-std.run.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-backtrace-std.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-backtrace-std.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-backtrace-std.run.stderr?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -0,0 +1,2 @@\n+thread 'main' panicked at 'byte index 1 is out of bounds of ``', $DIR/const-eval-select-backtrace-std.rs:5:6\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}, {"sha": "99f0725200c1d74a19eb2e28498846413c44c3b3", "filename": "src/test/ui/intrinsics/const-eval-select-backtrace.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-backtrace.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -0,0 +1,18 @@\n+#![feature(core_intrinsics)]\n+// See issue #100696.\n+// run-fail\n+// check-run-results\n+\n+#[track_caller]\n+fn uhoh() {\n+    panic!(\"Aaah!\")\n+}\n+\n+const fn c() {}\n+\n+fn main() {\n+    // safety: this is unsound and just used to test\n+    unsafe {\n+        std::intrinsics::const_eval_select((), c, uhoh);\n+    }\n+}"}, {"sha": "2fd730ac7a68a7e8fa95b6c44a6c320cae414423", "filename": "src/test/ui/intrinsics/const-eval-select-backtrace.run.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-backtrace.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-backtrace.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-backtrace.run.stderr?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -0,0 +1,2 @@\n+thread 'main' panicked at 'Aaah!', $DIR/const-eval-select-backtrace.rs:16:9\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}, {"sha": "fa14efad7b4a473ebd2f8744a2d9b7b154f2a7ce", "filename": "src/test/ui/intrinsics/const-eval-select-bad.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.rs?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -5,10 +5,13 @@ use std::intrinsics::const_eval_select;\n \n const fn not_fn_items() {\n     const_eval_select((), || {}, || {});\n-    //~^ ERROR the trait bound\n+    //~^ ERROR this argument must be a function item\n+    //~| ERROR this argument must be a function item\n     const_eval_select((), 42, 0xDEADBEEF);\n-    //~^ ERROR the trait bound\n+    //~^ ERROR expected a `FnOnce<()>` closure\n     //~| ERROR expected a `FnOnce<()>` closure\n+    //~| ERROR this argument must be a function item\n+    //~| ERROR this argument must be a function item\n }\n \n const fn foo(n: i32) -> i32 {\n@@ -35,4 +38,9 @@ const fn args_ty_mismatch() {\n     //~^ ERROR type mismatch\n }\n \n+const fn non_const_fn() {\n+    const_eval_select((1,), bar, bar);\n+    //~^ ERROR this argument must be a `const fn`\n+}\n+\n fn main() {}"}, {"sha": "3720528ad4e402b0e4feb3131b1213ee50812ead", "filename": "src/test/ui/intrinsics/const-eval-select-bad.stderr", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/075084f772abbc53263fc946c047a01e0dd65f80/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr?ref=075084f772abbc53263fc946c047a01e0dd65f80", "patch": "@@ -1,42 +1,57 @@\n-error[E0277]: the trait bound `[closure@$DIR/const-eval-select-bad.rs:7:27: 7:29]: FnOnce<()>` is not satisfied\n+error: this argument must be a function item\n   --> $DIR/const-eval-select-bad.rs:7:27\n    |\n LL |     const_eval_select((), || {}, || {});\n-   |     -----------------     ^^^^^ expected an `FnOnce<()>` closure, found `[closure@$DIR/const-eval-select-bad.rs:7:27: 7:29]`\n-   |     |\n-   |     required by a bound introduced by this call\n+   |                           ^^^^^\n    |\n-   = help: the trait `~const FnOnce<()>` is not implemented for closure `[closure@$DIR/const-eval-select-bad.rs:7:27: 7:29]`\n-note: the trait `FnOnce<()>` is implemented for `[closure@$DIR/const-eval-select-bad.rs:7:27: 7:29]`, but that implementation is not `const`\n-  --> $DIR/const-eval-select-bad.rs:7:27\n+   = note: expected a function item, found [closure@$DIR/const-eval-select-bad.rs:7:27: 7:29]\n+   = help: consult the documentation on `const_eval_select` for more information\n+\n+error: this argument must be a function item\n+  --> $DIR/const-eval-select-bad.rs:7:34\n    |\n LL |     const_eval_select((), || {}, || {});\n-   |                           ^^^^^\n-   = note: wrap the `[closure@$DIR/const-eval-select-bad.rs:7:27: 7:29]` in a closure with no arguments: `|| { /* code */ }`\n-note: required by a bound in `const_eval_select`\n-  --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+   |                                  ^^^^^\n    |\n-LL |     F: ~const FnOnce<ARG, Output = RET>,\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n+   = note: expected a function item, found [closure@$DIR/const-eval-select-bad.rs:7:34: 7:36]\n+   = help: consult the documentation on `const_eval_select` for more information\n \n-error[E0277]: the trait bound `{integer}: FnOnce<()>` is not satisfied\n-  --> $DIR/const-eval-select-bad.rs:9:27\n+error: this argument must be a function item\n+  --> $DIR/const-eval-select-bad.rs:10:27\n+   |\n+LL |     const_eval_select((), 42, 0xDEADBEEF);\n+   |                           ^^\n+   |\n+   = note: expected a function item, found {integer}\n+   = help: consult the documentation on `const_eval_select` for more information\n+\n+error[E0277]: expected a `FnOnce<()>` closure, found `{integer}`\n+  --> $DIR/const-eval-select-bad.rs:10:27\n    |\n LL |     const_eval_select((), 42, 0xDEADBEEF);\n    |     -----------------     ^^ expected an `FnOnce<()>` closure, found `{integer}`\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the trait `~const FnOnce<()>` is not implemented for `{integer}`\n+   = help: the trait `FnOnce<()>` is not implemented for `{integer}`\n    = note: wrap the `{integer}` in a closure with no arguments: `|| { /* code */ }`\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    |\n-LL |     F: ~const FnOnce<ARG, Output = RET>,\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n+LL |         F: FnOnce<ARG, Output = RET>;\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n+\n+error: this argument must be a function item\n+  --> $DIR/const-eval-select-bad.rs:10:31\n+   |\n+LL |     const_eval_select((), 42, 0xDEADBEEF);\n+   |                               ^^^^^^^^^^\n+   |\n+   = note: expected a function item, found {integer}\n+   = help: consult the documentation on `const_eval_select` for more information\n \n error[E0277]: expected a `FnOnce<()>` closure, found `{integer}`\n-  --> $DIR/const-eval-select-bad.rs:9:31\n+  --> $DIR/const-eval-select-bad.rs:10:31\n    |\n LL |     const_eval_select((), 42, 0xDEADBEEF);\n    |     -----------------         ^^^^^^^^^^ expected an `FnOnce<()>` closure, found `{integer}`\n@@ -48,11 +63,11 @@ LL |     const_eval_select((), 42, 0xDEADBEEF);\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    |\n-LL |     G: FnOnce<ARG, Output = RET> + ~const Destruct,\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n+LL |         G: FnOnce<ARG, Output = RET>,\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n \n error[E0271]: expected `fn(i32) -> bool {bar}` to be a fn item that returns `i32`, but it returns `bool`\n-  --> $DIR/const-eval-select-bad.rs:29:34\n+  --> $DIR/const-eval-select-bad.rs:32:34\n    |\n LL |     const_eval_select((1,), foo, bar);\n    |     -----------------            ^^^ expected `i32`, found `bool`\n@@ -62,11 +77,11 @@ LL |     const_eval_select((1,), foo, bar);\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    |\n-LL |     G: FnOnce<ARG, Output = RET> + ~const Destruct,\n-   |                    ^^^^^^^^^^^^ required by this bound in `const_eval_select`\n+LL |         G: FnOnce<ARG, Output = RET>,\n+   |                        ^^^^^^^^^^^^ required by this bound in `const_eval_select`\n \n error[E0631]: type mismatch in function arguments\n-  --> $DIR/const-eval-select-bad.rs:34:32\n+  --> $DIR/const-eval-select-bad.rs:37:32\n    |\n LL | const fn foo(n: i32) -> i32 {\n    | --------------------------- found signature defined here\n@@ -81,10 +96,18 @@ LL |     const_eval_select((true,), foo, baz);\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    |\n-LL |     F: ~const FnOnce<ARG, Output = RET>,\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n+LL |         F: FnOnce<ARG, Output = RET>;\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n+\n+error: this argument must be a `const fn`\n+  --> $DIR/const-eval-select-bad.rs:42:29\n+   |\n+LL |     const_eval_select((1,), bar, bar);\n+   |                             ^^^\n+   |\n+   = help: consult the documentation on `const_eval_select` for more information\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0271, E0277, E0631.\n For more information about an error, try `rustc --explain E0271`."}]}