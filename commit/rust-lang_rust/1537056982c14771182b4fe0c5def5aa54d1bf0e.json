{"sha": "1537056982c14771182b4fe0c5def5aa54d1bf0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MzcwNTY5ODJjMTQ3NzExODJiNGZlMGM1ZGVmNWFhNTRkMWJmMGU=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-05-17T17:18:35Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-05T19:01:37Z"}, "message": "just use TLS interner", "tree": {"sha": "9d17fd9263e54537afec3451b8369a43b6d3b09d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d17fd9263e54537afec3451b8369a43b6d3b09d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1537056982c14771182b4fe0c5def5aa54d1bf0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1537056982c14771182b4fe0c5def5aa54d1bf0e", "html_url": "https://github.com/rust-lang/rust/commit/1537056982c14771182b4fe0c5def5aa54d1bf0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1537056982c14771182b4fe0c5def5aa54d1bf0e/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22d21ab4c28f1023d55ced53746daf7a69b7559d", "url": "https://api.github.com/repos/rust-lang/rust/commits/22d21ab4c28f1023d55ced53746daf7a69b7559d", "html_url": "https://github.com/rust-lang/rust/commit/22d21ab4c28f1023d55ced53746daf7a69b7559d"}], "stats": {"total": 159, "additions": 84, "deletions": 75}, "files": [{"sha": "2cd8e5dea679612e09304349b6f17bf150d154a7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -81,15 +81,13 @@ pub type Mrk = uint;\n \n impl<S:Encoder> Encodable<S> for ident {\n     fn encode(&self, s: &mut S) {\n-        let intr = get_ident_interner();\n-        s.emit_str(*(*intr).get(*self));\n+        s.emit_str(*get_ident_interner().get(*self));\n     }\n }\n \n impl<D:Decoder> Decodable<D> for ident {\n     fn decode(d: &mut D) -> ident {\n-        let intr = get_ident_interner();\n-        (*intr).intern(d.read_str())\n+        get_ident_interner().intern(d.read_str())\n     }\n }\n "}, {"sha": "bf9f32b60302ee9f495bf36e3ddb3b2d1c5e1039", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -19,7 +19,7 @@ use diagnostic::span_handler;\n use ext;\n use parse;\n use parse::token;\n-use parse::token::{intern};\n+use parse::token::{intern, get_ident_interner};\n \n use core::hashmap::HashMap;\n use core::vec;\n@@ -310,10 +310,10 @@ impl ExtCtxt {\n         *self.trace_mac = x\n     }\n     pub fn str_of(&self, id: ast::ident) -> ~str {\n-        copy *self.parse_sess.interner.get(id)\n+        copy *get_ident_interner().get(id)\n     }\n     pub fn ident_of(&self, st: &str) -> ast::ident {\n-        self.parse_sess.interner.intern(st)\n+        get_ident_interner().intern(st)\n     }\n }\n "}, {"sha": "cdb57adb7bb5c25301c5fa7c5f7f32b0d8470cf8", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -15,6 +15,7 @@ use codemap::span;\n use ext::base::*;\n use ext::base;\n use parse::token;\n+use parse::token::{get_ident_interner};\n \n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n@@ -33,7 +34,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n             }\n         }\n     }\n-    let res = cx.parse_sess().interner.intern(res_str);\n+    let res = get_ident_interner().intern(res_str);\n \n     let e = @ast::expr {\n         id: cx.next_id(),"}, {"sha": "75602352b3f7b88628f7fd6fa45e5fdb7f57a696", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -735,6 +735,7 @@ mod test {\n     use codemap;\n     use codemap::spanned;\n     use parse;\n+    use parse::token::{get_ident_interner};\n     use core::io;\n     use core::option::{None, Some};\n     use util::parser_testing::{string_to_item_and_sess};"}, {"sha": "46b1334835f2fccfa94172bc8bd26949f3c78557", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -25,6 +25,7 @@ use ext::build::AstBuilder;\n use core::option;\n use core::unstable::extfmt::ct::*;\n use core::vec;\n+use parse::token::{get_ident_interner};\n \n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n@@ -53,7 +54,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                   pieces: ~[Piece], args: ~[@ast::expr])\n    -> @ast::expr {\n     fn make_path_vec(cx: @ExtCtxt, ident: &str) -> ~[ast::ident] {\n-        let intr = cx.parse_sess().interner;\n+        let intr = get_ident_interner();\n         return ~[intr.intern(\"std\"),\n                  intr.intern(\"unstable\"),\n                  intr.intern(\"extfmt\"),\n@@ -112,7 +113,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n         fn make_conv_struct(cx: @ExtCtxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n-            let intr = cx.parse_sess().interner;\n+            let intr = get_ident_interner();\n             cx.expr_struct(\n                 sp,\n                 cx.path_global(sp, make_path_vec(cx, \"Conv\")),\n@@ -255,11 +256,11 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n     let nargs = args.len();\n \n     /* 'ident' is the local buffer building up the result of fmt! */\n-    let ident = cx.parse_sess().interner.intern(\"__fmtbuf\");\n+    let ident = get_ident_interner().intern(\"__fmtbuf\");\n     let buf = || cx.expr_ident(fmt_sp, ident);\n-    let core_ident = cx.parse_sess().interner.intern(\"std\");\n-    let str_ident = cx.parse_sess().interner.intern(\"str\");\n-    let push_ident = cx.parse_sess().interner.intern(\"push_str\");\n+    let core_ident = get_ident_interner().intern(\"std\");\n+    let str_ident = get_ident_interner().intern(\"str\");\n+    let push_ident = get_ident_interner().intern(\"push_str\");\n     let mut stms = ~[];\n \n     /* Translate each piece (portion of the fmt expression) by invoking the"}, {"sha": "3ad4f87083f3db0d1ba484fe18b255c92e3c0508", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -15,6 +15,7 @@ use codemap;\n use ext::base::*;\n use ext::base;\n use print;\n+use parse::token::{get_ident_interner};\n \n use core::io;\n use core::vec;\n@@ -28,7 +29,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt,\n     io::stdout().write_line(\n         print::pprust::tt_to_str(\n             ast::tt_delim(vec::to_owned(tt)),\n-            cx.parse_sess().interner));\n+            get_ident_interner()));\n \n     //trivial expression\n     MRExpr(@ast::expr {"}, {"sha": "906fa08bad7dd72ba0bb56784c003a4dbce95e0b", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -52,7 +52,7 @@ use ext::pipes::pipec::gen_init;\n use ext::pipes::proto::visit;\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n-\n+use parse::token::{get_ident_interner};\n use core::option::None;\n \n pub mod ast_builder;\n@@ -68,7 +68,7 @@ pub fn expand_proto(cx: @ExtCtxt, _sp: span, id: ast::ident,\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n-                               cx.parse_sess().interner,\n+                               get_ident_interner(),\n                                None,\n                                copy tt);\n     let rdr = tt_rdr as @reader;"}, {"sha": "732094655f2f99ab4e7ffe3483ff05364417e0ce", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -17,6 +17,7 @@ use ext::pipes::proto::*;\n use parse::common::SeqSep;\n use parse::parser;\n use parse::token;\n+use parse::token::{get_ident_interner};\n \n pub trait proto_parser {\n     fn parse_proto(&self, id: ~str) -> protocol;\n@@ -42,11 +43,11 @@ impl proto_parser for parser::Parser {\n \n     fn parse_state(&self, proto: protocol) {\n         let id = self.parse_ident();\n-        let name = copy *self.interner.get(id);\n+        let name = copy *get_ident_interner().get(id);\n \n         self.expect(&token::COLON);\n         let dir = match copy *self.token {\n-            token::IDENT(n, _) => self.interner.get(n),\n+            token::IDENT(n, _) => get_ident_interner().get(n),\n             _ => fail!()\n         };\n         self.bump();\n@@ -77,7 +78,7 @@ impl proto_parser for parser::Parser {\n     }\n \n     fn parse_message(&self, state: state) {\n-        let mname = copy *self.interner.get(self.parse_ident());\n+        let mname = copy *get_ident_interner().get(self.parse_ident());\n \n         let args = if *self.token == token::LPAREN {\n             self.parse_unspanned_seq(\n@@ -96,7 +97,7 @@ impl proto_parser for parser::Parser {\n \n         let next = match *self.token {\n           token::IDENT(_, _) => {\n-            let name = copy *self.interner.get(self.parse_ident());\n+            let name = copy *get_ident_interner().get(self.parse_ident());\n             let ntys = if *self.token == token::LT {\n                 self.parse_unspanned_seq(\n                     &token::LT,"}, {"sha": "bfa4faa8b28b4e0a996b445c3ac53a39476abe40", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -80,13 +80,13 @@ pub mod rt {\n \n     impl ToSource for ast::ident {\n         fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            copy *cx.parse_sess().interner.get(*self)\n+            copy *get_ident_interner().get(*self)\n         }\n     }\n \n     impl ToSource for @ast::item {\n         fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            item_to_str(*self, cx.parse_sess().interner)\n+            item_to_str(*self, get_ident_interner())\n         }\n     }\n \n@@ -98,7 +98,7 @@ pub mod rt {\n \n     impl ToSource for @ast::Ty {\n         fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            ty_to_str(*self, cx.parse_sess().interner)\n+            ty_to_str(*self, get_ident_interner())\n         }\n     }\n \n@@ -110,19 +110,19 @@ pub mod rt {\n \n     impl ToSource for Generics {\n         fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            pprust::generics_to_str(self, cx.parse_sess().interner)\n+            pprust::generics_to_str(self, get_ident_interner())\n         }\n     }\n \n     impl ToSource for @ast::expr {\n         fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            pprust::expr_to_str(*self, cx.parse_sess().interner)\n+            pprust::expr_to_str(*self, get_ident_interner())\n         }\n     }\n \n     impl ToSource for ast::blk {\n         fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            pprust::block_to_str(self, cx.parse_sess().interner)\n+            pprust::block_to_str(self, get_ident_interner())\n         }\n     }\n \n@@ -418,11 +418,11 @@ pub fn expand_quote_stmt(cx: @ExtCtxt,\n }\n \n fn ids_ext(cx: @ExtCtxt, strs: ~[~str]) -> ~[ast::ident] {\n-    strs.map(|str| cx.parse_sess().interner.intern(*str))\n+    strs.map(|str| get_ident_interner().intern(*str))\n }\n \n fn id_ext(cx: @ExtCtxt, str: &str) -> ast::ident {\n-    cx.parse_sess().interner.intern(str)\n+    get_ident_interner().intern(str)\n }\n \n // Lift an ident to the expr that evaluates to that ident."}, {"sha": "fcdfb0a6ba7b6dd1e2aef289b2b4ce6c8d3616d3", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -18,6 +18,7 @@ use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use parse;\n+use parse::token::{get_ident_interner};\n use print::pprust;\n \n use core::io;\n@@ -65,7 +66,7 @@ pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n \n pub fn expand_stringify(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n-    let s = pprust::tts_to_str(tts, cx.parse_sess().interner);\n+    let s = pprust::tts_to_str(tts, get_ident_interner());\n     base::MRExpr(cx.expr_str(sp, s))\n }\n "}, {"sha": "3515041c9b6c24a4bd180e7e604b8239e29e45a9", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -17,6 +17,7 @@ use ext::base;\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n use parse::token::keywords;\n+use parse::token::{get_ident_interner};\n \n use core::vec;\n \n@@ -28,7 +29,7 @@ pub fn expand_trace_macros(cx: @ExtCtxt,\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(\n         copy cx.parse_sess().span_diagnostic,\n-        cx.parse_sess().interner,\n+        get_ident_interner(),\n         None,\n         vec::to_owned(tt)\n     );"}, {"sha": "1b23b96a732e094149a2fbaad94db69441c54c82", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -19,7 +19,7 @@ use codemap;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n use parse::parser::Parser;\n-use parse::token::{Token, EOF, to_str, nonterminal};\n+use parse::token::{Token, EOF, to_str, nonterminal, get_ident_interner};\n use parse::token;\n \n use core::hashmap::HashMap;\n@@ -205,7 +205,7 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n           } => {\n             if ret_val.contains_key(&bind_name) {\n                 p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"+\n-                                               *p_s.interner.get(bind_name))\n+                                               *get_ident_interner().get(bind_name))\n             }\n             ret_val.insert(bind_name, res[idx]);\n           }\n@@ -373,8 +373,8 @@ pub fn parse(\n                 let nts = str::connect(vec::map(bb_eis, |ei| {\n                     match ei.elts[ei.idx].node {\n                       match_nonterminal(bind,name,_) => {\n-                        fmt!(\"%s ('%s')\", *sess.interner.get(name),\n-                             *sess.interner.get(bind))\n+                        fmt!(\"%s ('%s')\", *get_ident_interner().get(name),\n+                             *get_ident_interner().get(bind))\n                       }\n                       _ => fail!()\n                     } }), \" or \");\n@@ -384,7 +384,7 @@ pub fn parse(\n                     nts, next_eis.len()));\n             } else if (bb_eis.len() == 0u && next_eis.len() == 0u) {\n                 return failure(sp, ~\"No rules expected the token: \"\n-                            + to_str(rdr.interner(), &tok));\n+                            + to_str(get_ident_interner(), &tok));\n             } else if (next_eis.len() > 0u) {\n                 /* Now process the next token */\n                 while(next_eis.len() > 0u) {\n@@ -398,7 +398,7 @@ pub fn parse(\n                 match ei.elts[ei.idx].node {\n                   match_nonterminal(_, name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal(\n-                        parse_nt(&rust_parser, *sess.interner.get(name))));\n+                        parse_nt(&rust_parser, *get_ident_interner().get(name))));\n                     ei.idx += 1u;\n                   }\n                   _ => fail!()\n@@ -430,7 +430,7 @@ pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n       \"ident\" => match *p.token {\n         token::IDENT(sn,b) => { p.bump(); token::nt_ident(sn,b) }\n         _ => p.fatal(~\"expected ident, found \"\n-                     + token::to_str(p.reader.interner(), &copy *p.token))\n+                     + token::to_str(get_ident_interner(), &copy *p.token))\n       },\n       \"path\" => token::nt_path(p.parse_path_with_tps(false)),\n       \"tt\" => {"}, {"sha": "13393b766639f76969f51a94c747820edf2efa1c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -21,7 +21,7 @@ use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use ext::tt::macro_parser::{parse, parse_or_else, success, failure};\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n-use parse::token::special_idents;\n+use parse::token::{get_ident_interner, special_idents};\n use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt};\n use print;\n \n@@ -38,8 +38,8 @@ pub fn add_new_extension(cx: @ExtCtxt,\n         spanned { node: copy m, span: dummy_sp() }\n     }\n \n-    let lhs_nm =  cx.parse_sess().interner.gensym(\"lhs\");\n-    let rhs_nm =  cx.parse_sess().interner.gensym(\"rhs\");\n+    let lhs_nm =  get_ident_interner().gensym(\"lhs\");\n+    let rhs_nm =  get_ident_interner().gensym(\"rhs\");\n \n     // The grammar for macro_rules! is:\n     // $( $lhs:mtcs => $rhs:tt );+\n@@ -57,7 +57,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n-                                   cx.parse_sess().interner, None, copy arg);\n+                                   get_ident_interner(), None, copy arg);\n     let argument_map = parse_or_else(cx.parse_sess(),\n                                      cx.cfg(),\n                                      arg_reader as @reader,\n@@ -85,15 +85,15 @@ pub fn add_new_extension(cx: @ExtCtxt,\n                              cx.str_of(name),\n                              print::pprust::tt_to_str(\n                                  ast::tt_delim(vec::to_owned(arg)),\n-                                 cx.parse_sess().interner)));\n+                                 get_ident_interner())));\n         }\n \n         // Which arm's failure should we report? (the one furthest along)\n         let mut best_fail_spot = dummy_sp();\n         let mut best_fail_msg = ~\"internal error: ran no matchers\";\n \n         let s_d = cx.parse_sess().span_diagnostic;\n-        let itr = cx.parse_sess().interner;\n+        let itr = get_ident_interner();\n \n         for lhses.eachi |i, lhs| { // try each arm's matchers\n             match *lhs {\n@@ -151,7 +151,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n         |cx, sp, arg| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n \n     return MRDef(MacroDef{\n-        name: copy *cx.parse_sess().interner.get(name),\n+        name: copy *get_ident_interner().get(name),\n         ext: NormalTT(base::SyntaxExpanderTT{expander: exp, span: Some(sp)})\n     });\n }"}, {"sha": "b508b342478746f950dac7947ada8784582318c9", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -15,7 +15,7 @@ use ast::{token_tree, tt_delim, tt_tok, tt_seq, tt_nonterminal,ident};\n use codemap::{span, dummy_sp};\n use diagnostic::span_handler;\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n-use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident, ident_interner};\n+use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident, ident_interner, get_ident_interner};\n use parse::lexer::TokenAndSpan;\n \n use core::hashmap::HashMap;\n@@ -93,7 +93,7 @@ fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n     @mut TtReader {\n         sp_diag: r.sp_diag,\n-        interner: r.interner,\n+        interner: get_ident_interner(),\n         stack: dup_tt_frame(r.stack),\n         repeat_idx: copy r.repeat_idx,\n         repeat_len: copy r.repeat_len,\n@@ -144,8 +144,8 @@ fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n             lis_contradiction(_) => copy rhs,\n             lis_constraint(r_len, _) if l_len == r_len => copy lhs,\n             lis_constraint(r_len, r_id) => {\n-                let l_n = copy *r.interner.get(l_id);\n-                let r_n = copy *r.interner.get(r_id);\n+                let l_n = copy *get_ident_interner().get(l_id);\n+                let r_n = copy *get_ident_interner().get(r_id);\n                 lis_contradiction(fmt!(\"Inconsistent lockstep iteration: \\\n                                        '%s' has %u items, but '%s' has %u\",\n                                         l_n, l_len, r_n, r_len))\n@@ -295,7 +295,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 r.sp_diag.span_fatal(\n                     copy r.cur_span, /* blame the macro writer */\n                     fmt!(\"variable '%s' is still repeating at this depth\",\n-                         *r.interner.get(ident)));\n+                         *get_ident_interner().get(ident)));\n               }\n             }\n           }"}, {"sha": "00fe8cf545a42362f14b9f05f905b48e34a34acb", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -18,6 +18,7 @@ use parse::lexer::{StringReader, bump, is_eof, nextch, TokenAndSpan};\n use parse::lexer::{is_line_non_doc_comment, is_block_non_doc_comment};\n use parse::lexer;\n use parse::token;\n+use parse::token::{get_ident_interner};\n use parse;\n \n use core::io;\n@@ -358,7 +359,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n             debug!(\"tok lit: %s\", s);\n             literals.push(lit {lit: s, pos: sp.lo});\n         } else {\n-            debug!(\"tok: %s\", token::to_str(rdr.interner, &tok));\n+            debug!(\"tok: %s\", token::to_str(get_ident_interner(), &tok));\n         }\n         first_read = false;\n     }"}, {"sha": "9fb69821953ac3cbe1f6ec03e66b4e867f42c2d9", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -16,6 +16,7 @@ use parse::lexer::reader;\n use parse::parser::Parser;\n use parse::token::keywords;\n use parse::token;\n+use parse::token::{get_ident_interner};\n \n use opt_vec;\n use opt_vec::OptVec;\n@@ -49,13 +50,13 @@ pub fn seq_sep_none() -> SeqSep {\n // maps any token back to a string. not necessary if you know it's\n // an identifier....\n pub fn token_to_str(reader: @reader, token: &token::Token) -> ~str {\n-    token::to_str(reader.interner(), token)\n+    token::to_str(get_ident_interner(), token)\n }\n \n impl Parser {\n     // convert a token to a string using self's reader\n     pub fn token_to_str(&self, token: &token::Token) -> ~str {\n-        token::to_str(self.reader.interner(), token)\n+        token::to_str(get_ident_interner(), token)\n     }\n \n     // convert the current token to a string using self's reader"}, {"sha": "f98d0f3dea8e53758d601ce1be48417281490886", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -17,6 +17,7 @@ use diagnostic::span_handler;\n use ext::tt::transcribe::{tt_next_token};\n use ext::tt::transcribe::{dup_tt_reader};\n use parse::token;\n+use parse::token::{get_ident_interner};\n \n use core::char;\n use core::either;\n@@ -100,7 +101,7 @@ fn dup_string_reader(r: @mut StringReader) -> @mut StringReader {\n         col: r.col,\n         curr: r.curr,\n         filemap: r.filemap,\n-        interner: r.interner,\n+        interner: get_ident_interner(),\n         peek_tok: copy r.peek_tok,\n         peek_span: copy r.peek_span\n     }\n@@ -121,7 +122,7 @@ impl reader for StringReader {\n         self.span_diagnostic.span_fatal(copy self.peek_span, m)\n     }\n     fn span_diag(@mut self) -> @span_handler { self.span_diagnostic }\n-    fn interner(@mut self) -> @token::ident_interner { self.interner }\n+    fn interner(@mut self) -> @token::ident_interner { get_ident_interner() }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: copy self.peek_tok,\n@@ -138,7 +139,7 @@ impl reader for TtReader {\n         self.sp_diag.span_fatal(copy self.cur_span, m);\n     }\n     fn span_diag(@mut self) -> @span_handler { self.sp_diag }\n-    fn interner(@mut self) -> @token::ident_interner { self.interner }\n+    fn interner(@mut self) -> @token::ident_interner { get_ident_interner() }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: copy self.cur_tok,\n@@ -277,7 +278,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n                 // but comments with only more \"/\"s are not\n                 if !is_line_non_doc_comment(acc) {\n                     return Some(TokenAndSpan{\n-                        tok: token::DOC_COMMENT(rdr.interner.intern(acc)),\n+                        tok: token::DOC_COMMENT(get_ident_interner().intern(acc)),\n                         sp: codemap::mk_sp(start_bpos, rdr.pos)\n                     });\n                 }\n@@ -331,7 +332,7 @@ fn consume_block_comment(rdr: @mut StringReader)\n             // but comments with only \"*\"s between two \"/\"s are not\n             if !is_block_non_doc_comment(acc) {\n                 return Some(TokenAndSpan{\n-                    tok: token::DOC_COMMENT(rdr.interner.intern(acc)),\n+                    tok: token::DOC_COMMENT(get_ident_interner().intern(acc)),\n                     sp: codemap::mk_sp(start_bpos, rdr.pos)\n                 });\n             }\n@@ -477,12 +478,12 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         if c == '3' && n == '2' {\n             bump(rdr);\n             bump(rdr);\n-            return token::LIT_FLOAT(rdr.interner.intern(num_str),\n+            return token::LIT_FLOAT(get_ident_interner().intern(num_str),\n                                  ast::ty_f32);\n         } else if c == '6' && n == '4' {\n             bump(rdr);\n             bump(rdr);\n-            return token::LIT_FLOAT(rdr.interner.intern(num_str),\n+            return token::LIT_FLOAT(get_ident_interner().intern(num_str),\n                                  ast::ty_f64);\n             /* FIXME (#2252): if this is out of range for either a\n             32-bit or 64-bit float, it won't be noticed till the\n@@ -494,9 +495,9 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     }\n     if is_float {\n         if is_machine_float {\n-            return token::LIT_FLOAT(rdr.interner.intern(num_str), ast::ty_f);\n+            return token::LIT_FLOAT(get_ident_interner().intern(num_str), ast::ty_f);\n         }\n-        return token::LIT_FLOAT_UNSUFFIXED(rdr.interner.intern(num_str));\n+        return token::LIT_FLOAT_UNSUFFIXED(get_ident_interner().intern(num_str));\n     } else {\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n@@ -559,7 +560,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         let is_mod_name = c == ':' && nextch(rdr) == ':';\n \n         // FIXME: perform NFKC normalization here. (Issue #2253)\n-        return token::IDENT(rdr.interner.intern(accum_str), is_mod_name);\n+        return token::IDENT(get_ident_interner().intern(accum_str), is_mod_name);\n     }\n     if is_dec_digit(c) {\n         return scan_number(c, rdr);\n@@ -669,7 +670,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                 lifetime_name.push_char(rdr.curr);\n                 bump(rdr);\n             }\n-            return token::LIFETIME(rdr.interner.intern(lifetime_name));\n+            return token::LIFETIME(get_ident_interner().intern(lifetime_name));\n         }\n \n         // Otherwise it is a character constant:\n@@ -742,7 +743,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n             }\n         }\n         bump(rdr);\n-        return token::LIT_STR(rdr.interner.intern(accum_str));\n+        return token::LIT_STR(get_ident_interner().intern(accum_str));\n       }\n       '-' => {\n         if nextch(rdr) == '>' {\n@@ -786,6 +787,7 @@ mod test {\n     use core::option::None;\n     use diagnostic;\n     use parse::token;\n+    use parse::token::{get_ident_interner};\n \n     // represents a testing reader (incl. both reader and interner)\n     struct Env {\n@@ -840,7 +842,7 @@ mod test {\n \n     // make the identifier by looking up the string in the interner\n     fn mk_ident (env: Env, id: &str, is_mod_name: bool) -> token::Token {\n-        token::IDENT (env.interner.intern(id),is_mod_name)\n+        token::IDENT (get_ident_interner().intern(id),is_mod_name)\n     }\n \n     #[test] fn doublecolonparsing () {\n@@ -899,7 +901,7 @@ mod test {\n         let env = setup(~\"'abc\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        let id = env.interner.intern(\"abc\");\n+        let id = get_ident_interner().intern(\"abc\");\n         assert_eq!(tok, token::LIFETIME(id));\n     }\n "}, {"sha": "46a76e4572dd53c8fd0ada99c35eb3d6773a6830", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -314,7 +314,7 @@ pub fn filemap_to_tts(sess: @mut ParseSess, filemap: @FileMap)\n     let cfg = ~[];\n     let srdr = lexer::new_string_reader(copy sess.span_diagnostic,\n                                         filemap,\n-                                        sess.interner);\n+                                        get_ident_interner());\n     let p1 = Parser(sess, cfg, srdr as @reader);\n     p1.parse_all_token_trees()\n }\n@@ -325,7 +325,7 @@ pub fn tts_to_parser(sess: @mut ParseSess,\n                      cfg: ast::crate_cfg) -> Parser {\n     let trdr = lexer::new_tt_reader(\n         copy sess.span_diagnostic,\n-        sess.interner,\n+        get_ident_interner(),\n         None,\n         tts\n     );"}, {"sha": "6260e7c460ca0a813b6cb8bfec2b33298b650988", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1537056982c14771182b4fe0c5def5aa54d1bf0e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1537056982c14771182b4fe0c5def5aa54d1bf0e", "patch": "@@ -85,7 +85,7 @@ use parse::obsolete::{ObsoleteLifetimeNotation, ObsoleteConstManagedPointer};\n use parse::obsolete::{ObsoletePurity, ObsoleteStaticMethod};\n use parse::obsolete::{ObsoleteConstItem, ObsoleteFixedLengthVectorType};\n use parse::obsolete::{ObsoleteNamedExternModule, ObsoleteMultipleLocalDecl};\n-use parse::token::{can_begin_expr, is_ident, is_ident_or_path};\n+use parse::token::{can_begin_expr, get_ident_interner, is_ident, is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents, token_to_binop};\n use parse::token;\n use parse::{new_sub_parser_from_file, next_node_id, ParseSess};\n@@ -219,7 +219,7 @@ pub fn Parser(sess: @mut ParseSess,\n               rdr: @reader)\n            -> Parser {\n     let tok0 = copy rdr.next_token();\n-    let interner = rdr.interner();\n+    let interner = get_ident_interner();\n \n     Parser {\n         reader: rdr,\n@@ -333,7 +333,7 @@ impl Parser {\n     pub fn get_id(&self) -> node_id { next_node_id(self.sess) }\n \n     pub fn id_to_str(&self, id: ident) -> @~str {\n-        self.sess.interner.get(id)\n+        get_ident_interner().get(id)\n     }\n \n     // is this one of the keywords that signals a closure type?\n@@ -3370,7 +3370,7 @@ impl Parser {\n             }\n             if fields.len() == 0 {\n                 self.fatal(fmt!(\"Unit-like struct should be written as `struct %s;`\",\n-                                *self.interner.get(class_name)));\n+                                *get_ident_interner().get(class_name)));\n             }\n             self.bump();\n         } else if *self.token == token::LPAREN {\n@@ -3582,7 +3582,7 @@ impl Parser {\n     }\n \n     fn push_mod_path(&self, id: ident, attrs: ~[ast::attribute]) {\n-        let default_path = self.sess.interner.get(id);\n+        let default_path = get_ident_interner().get(id);\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             attrs, \"path\") {\n \n@@ -3605,7 +3605,7 @@ impl Parser {\n         let prefix = prefix.dir_path();\n         let mod_path_stack = &*self.mod_path_stack;\n         let mod_path = Path(\".\").push_many(*mod_path_stack);\n-        let default_path = *self.sess.interner.get(id) + \".rs\";\n+        let default_path = *get_ident_interner().get(id) + \".rs\";\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             outer_attrs, \"path\") {\n             Some(d) => {"}]}