{"sha": "123a6ef25cdd5463eef183d0113e3166cdd7b800", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyM2E2ZWYyNWNkZDU0NjNlZWYxODNkMDExM2UzMTY2Y2RkN2I4MDA=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-10-19T21:15:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-19T21:15:00Z"}, "message": "Rollup merge of #37241 - zackmdavis:if_let_over_none_spaced_empty_block_arm, r=nikomatsakis\n\nprefer `if let` to match with `None => { }` arm in some places\n\nIn #34268 (8531d581), we replaced matches of None to the unit value `()`\nwith `if let`s in places where it was deemed that this made the code\nunambiguously clearer and more idiomatic. In #34638 (d37edef9), we did\nthe same for matches of None to the empty block `{}`.\n\nA casual observer, upon seeing these commits fly by, might suppose that\nthe matter was then settled, that no further pull requests on this\nutterly trivial point of style could or would be made. Unless ...\n\nIt turns out that sometimes people write the empty block with a space in\nbetween the braces. Who knew?", "tree": {"sha": "62a81a2af818ae4dc089b1bdf5ea3ea37fa0d20e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62a81a2af818ae4dc089b1bdf5ea3ea37fa0d20e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/123a6ef25cdd5463eef183d0113e3166cdd7b800", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/123a6ef25cdd5463eef183d0113e3166cdd7b800", "html_url": "https://github.com/rust-lang/rust/commit/123a6ef25cdd5463eef183d0113e3166cdd7b800", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/123a6ef25cdd5463eef183d0113e3166cdd7b800/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce369bfa1120b1293933c8e12a1c18e62a2a153e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce369bfa1120b1293933c8e12a1c18e62a2a153e", "html_url": "https://github.com/rust-lang/rust/commit/ce369bfa1120b1293933c8e12a1c18e62a2a153e"}, {"sha": "1e7cd5edcca6598720e6a6cb7b7a2c103018028d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e7cd5edcca6598720e6a6cb7b7a2c103018028d", "html_url": "https://github.com/rust-lang/rust/commit/1e7cd5edcca6598720e6a6cb7b7a2c103018028d"}], "stats": {"total": 233, "additions": 97, "deletions": 136}, "files": [{"sha": "828f9f32baac8d3446b066ed01f7e20dbc20ed49", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=123a6ef25cdd5463eef183d0113e3166cdd7b800", "patch": "@@ -61,9 +61,8 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n                   -> Ty<'tcx> where\n         F: FnOnce(u32) -> ty::InferTy,\n     {\n-        match opt_ty {\n-            Some(ty) => { return ty.fold_with(self); }\n-            None => { }\n+        if let Some(ty) = opt_ty {\n+            return ty.fold_with(self);\n         }\n \n         match self.freshen_map.entry(key) {"}, {"sha": "30b735b9c24e359c9561a2e5f0b19ce4b8a01841", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=123a6ef25cdd5463eef183d0113e3166cdd7b800", "patch": "@@ -478,12 +478,9 @@ impl RegionMaps {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n-        match self.rvalue_scopes.borrow().get(&expr_id) {\n-            Some(&s) => {\n-                debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n-                return Some(s);\n-            }\n-            None => { }\n+        if let Some(&s) = self.rvalue_scopes.borrow().get(&expr_id) {\n+            debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n+            return Some(s);\n         }\n \n         let scope_map : &[CodeExtent] = &self.scope_map.borrow();\n@@ -928,19 +925,15 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n     //\n     // FIXME(#6308) -- Note that `[]` patterns work more smoothly post-DST.\n \n-    match local.init {\n-        Some(ref expr) => {\n-            record_rvalue_scope_if_borrow_expr(visitor, &expr, blk_scope);\n+    if let Some(ref expr) = local.init {\n+        record_rvalue_scope_if_borrow_expr(visitor, &expr, blk_scope);\n \n-            let is_borrow =\n-                if let Some(ref ty) = local.ty { is_borrowed_ty(&ty) } else { false };\n+        let is_borrow =\n+            if let Some(ref ty) = local.ty { is_borrowed_ty(&ty) } else { false };\n \n-            if is_binding_pat(&local.pat) || is_borrow {\n-                record_rvalue_scope(visitor, &expr, blk_scope);\n-            }\n+        if is_binding_pat(&local.pat) || is_borrow {\n+            record_rvalue_scope(visitor, &expr, blk_scope);\n         }\n-\n-        None => { }\n     }\n \n     intravisit::walk_local(visitor, local);\n@@ -1023,16 +1016,12 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id)\n             }\n             hir::ExprBlock(ref block) => {\n-                match block.expr {\n-                    Some(ref subexpr) => {\n-                        record_rvalue_scope_if_borrow_expr(\n-                            visitor, &subexpr, blk_id);\n-                    }\n-                    None => { }\n+                if let Some(ref subexpr) = block.expr {\n+                    record_rvalue_scope_if_borrow_expr(\n+                        visitor, &subexpr, blk_id);\n                 }\n             }\n-            _ => {\n-            }\n+            _ => {}\n         }\n     }\n "}, {"sha": "27554c0d2a44db50522b7e4f52ec384a2bed98a3", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=123a6ef25cdd5463eef183d0113e3166cdd7b800", "patch": "@@ -1405,9 +1405,8 @@ impl<'tcx> ProjectionCache<'tcx> {\n     /// cache hit, so it's actually a good thing).\n     fn try_start(&mut self, key: ty::ProjectionTy<'tcx>)\n                  -> Result<(), ProjectionCacheEntry<'tcx>> {\n-        match self.map.get(&key) {\n-            Some(entry) => return Err(entry.clone()),\n-            None => { }\n+        if let Some(entry) = self.map.get(&key) {\n+            return Err(entry.clone());\n         }\n \n         self.map.insert(key, ProjectionCacheEntry::InProgress);"}, {"sha": "f4747b5b108a171b3388cb880b22c6d2035178e0", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=123a6ef25cdd5463eef183d0113e3166cdd7b800", "patch": "@@ -788,14 +788,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                stack);\n         assert!(!stack.obligation.predicate.has_escaping_regions());\n \n-        match self.check_candidate_cache(&cache_fresh_trait_pred) {\n-            Some(c) => {\n-                debug!(\"CACHE HIT: SELECT({:?})={:?}\",\n-                       cache_fresh_trait_pred,\n-                       c);\n-                return c;\n-            }\n-            None => { }\n+        if let Some(c) = self.check_candidate_cache(&cache_fresh_trait_pred) {\n+            debug!(\"CACHE HIT: SELECT({:?})={:?}\",\n+                   cache_fresh_trait_pred,\n+                   c);\n+            return c;\n         }\n \n         // If no match, compute result and insert into cache."}, {"sha": "b2032e6a1bf9fcb843680971de24ff7f9e8dd3ab", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 51, "deletions": 61, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=123a6ef25cdd5463eef183d0113e3166cdd7b800", "patch": "@@ -135,15 +135,12 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n-        match opt_loan_path(&cmt) {\n-            Some(lp) => {\n-                let moved_value_use_kind = match loan_cause {\n-                    euv::ClosureCapture(_) => MovedInCapture,\n-                    _ => MovedInUse,\n-                };\n-                self.check_if_path_is_moved(borrow_id, borrow_span, moved_value_use_kind, &lp);\n-            }\n-            None => { }\n+        if let Some(lp) = opt_loan_path(&cmt) {\n+            let moved_value_use_kind = match loan_cause {\n+                euv::ClosureCapture(_) => MovedInCapture,\n+                _ => MovedInUse,\n+            };\n+            self.check_if_path_is_moved(borrow_id, borrow_span, moved_value_use_kind, &lp);\n         }\n \n         self.check_for_conflicting_loans(borrow_id);\n@@ -158,33 +155,29 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         debug!(\"mutate(assignment_id={}, assignee_cmt={:?})\",\n                assignment_id, assignee_cmt);\n \n-        match opt_loan_path(&assignee_cmt) {\n-            Some(lp) => {\n-                match mode {\n-                    MutateMode::Init | MutateMode::JustWrite => {\n-                        // In a case like `path = 1`, then path does not\n-                        // have to be *FULLY* initialized, but we still\n-                        // must be careful lest it contains derefs of\n-                        // pointers.\n-                        self.check_if_assigned_path_is_moved(assignee_cmt.id,\n-                                                             assignment_span,\n-                                                             MovedInUse,\n-                                                             &lp);\n-                    }\n-                    MutateMode::WriteAndRead => {\n-                        // In a case like `path += 1`, then path must be\n-                        // fully initialized, since we will read it before\n-                        // we write it.\n-                        self.check_if_path_is_moved(assignee_cmt.id,\n-                                                    assignment_span,\n-                                                    MovedInUse,\n-                                                    &lp);\n-                    }\n+        if let Some(lp) = opt_loan_path(&assignee_cmt) {\n+            match mode {\n+                MutateMode::Init | MutateMode::JustWrite => {\n+                    // In a case like `path = 1`, then path does not\n+                    // have to be *FULLY* initialized, but we still\n+                    // must be careful lest it contains derefs of\n+                    // pointers.\n+                    self.check_if_assigned_path_is_moved(assignee_cmt.id,\n+                                                         assignment_span,\n+                                                         MovedInUse,\n+                                                         &lp);\n+                }\n+                MutateMode::WriteAndRead => {\n+                    // In a case like `path += 1`, then path must be\n+                    // fully initialized, since we will read it before\n+                    // we write it.\n+                    self.check_if_path_is_moved(assignee_cmt.id,\n+                                                assignment_span,\n+                                                MovedInUse,\n+                                                &lp);\n                 }\n             }\n-            None => { }\n         }\n-\n         self.check_assignment(assignment_id, assignment_span, assignee_cmt);\n     }\n \n@@ -601,39 +594,36 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                       span: Span,\n                       cmt: mc::cmt<'tcx>,\n                       mode: euv::ConsumeMode) {\n-        match opt_loan_path(&cmt) {\n-            Some(lp) => {\n-                let moved_value_use_kind = match mode {\n-                    euv::Copy => {\n-                        self.check_for_copy_of_frozen_path(id, span, &lp);\n-                        MovedInUse\n-                    }\n-                    euv::Move(_) => {\n-                        match self.move_data.kind_of_move_of_path(id, &lp) {\n-                            None => {\n-                                // Sometimes moves don't have a move kind;\n-                                // this either means that the original move\n-                                // was from something illegal to move,\n-                                // or was moved from referent of an unsafe\n-                                // pointer or something like that.\n+        if let Some(lp) = opt_loan_path(&cmt) {\n+            let moved_value_use_kind = match mode {\n+                euv::Copy => {\n+                    self.check_for_copy_of_frozen_path(id, span, &lp);\n+                    MovedInUse\n+                }\n+                euv::Move(_) => {\n+                    match self.move_data.kind_of_move_of_path(id, &lp) {\n+                        None => {\n+                            // Sometimes moves don't have a move kind;\n+                            // this either means that the original move\n+                            // was from something illegal to move,\n+                            // or was moved from referent of an unsafe\n+                            // pointer or something like that.\n+                            MovedInUse\n+                        }\n+                        Some(move_kind) => {\n+                            self.check_for_move_of_borrowed_path(id, span,\n+                                                                 &lp, move_kind);\n+                            if move_kind == move_data::Captured {\n+                                MovedInCapture\n+                            } else {\n                                 MovedInUse\n                             }\n-                            Some(move_kind) => {\n-                                self.check_for_move_of_borrowed_path(id, span,\n-                                                                     &lp, move_kind);\n-                                if move_kind == move_data::Captured {\n-                                    MovedInCapture\n-                                } else {\n-                                    MovedInUse\n-                                }\n-                            }\n                         }\n                     }\n-                };\n+                }\n+            };\n \n-                self.check_if_path_is_moved(id, span, moved_value_use_kind, &lp);\n-            }\n-            None => { }\n+            self.check_if_path_is_moved(id, span, moved_value_use_kind, &lp);\n         }\n     }\n "}, {"sha": "37cac7c526555c85deca767f740e753c25f1f348", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=123a6ef25cdd5463eef183d0113e3166cdd7b800", "patch": "@@ -302,9 +302,8 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n     };\n \n     // Check if we already trans'd this shim.\n-    match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty_maybe_ref) {\n-        Some(&llval) => { return llval; }\n-        None => { }\n+    if let Some(&llval) = ccx.fn_pointer_shims().borrow().get(&bare_fn_ty_maybe_ref) {\n+        return llval;\n     }\n \n     debug!(\"trans_fn_pointer_shim(bare_fn_ty={:?})\","}, {"sha": "1e687f5ff6e3a51bc29e304e3d3838349a7c7291", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=123a6ef25cdd5463eef183d0113e3166cdd7b800", "patch": "@@ -119,9 +119,8 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n     // Check the cache.\n-    match ccx.vtables().borrow().get(&trait_ref) {\n-        Some(&val) => { return val }\n-        None => { }\n+    if let Some(&val) = ccx.vtables().borrow().get(&trait_ref) {\n+        return val;\n     }\n \n     // Not in the cache. Build it."}, {"sha": "4fbb31cf0a534d3bfaeafc021700ea990020c1a3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=123a6ef25cdd5463eef183d0113e3166cdd7b800", "patch": "@@ -1629,9 +1629,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n \n         let cache = self.ast_ty_to_ty_cache();\n-        match cache.borrow().get(&ast_ty.id) {\n-            Some(ty) => { return ty; }\n-            None => { }\n+        if let Some(ty) = cache.borrow().get(&ast_ty.id) {\n+            return ty;\n         }\n \n         let result_ty = match ast_ty.node {"}, {"sha": "703c6ade40a26a9da5f99faef391fbd027ffde1d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=123a6ef25cdd5463eef183d0113e3166cdd7b800", "patch": "@@ -742,17 +742,14 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemImpl(.., ref impl_items) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n           let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n-          match ccx.tcx.impl_trait_ref(impl_def_id) {\n-              Some(impl_trait_ref) => {\n-                  check_impl_items_against_trait(ccx,\n-                                                 it.span,\n-                                                 impl_def_id,\n-                                                 &impl_trait_ref,\n-                                                 impl_items);\n-                  let trait_def_id = impl_trait_ref.def_id;\n-                  check_on_unimplemented(ccx, trait_def_id, it);\n-              }\n-              None => { }\n+          if let Some(impl_trait_ref) = ccx.tcx.impl_trait_ref(impl_def_id) {\n+              check_impl_items_against_trait(ccx,\n+                                             it.span,\n+                                             impl_def_id,\n+                                             &impl_trait_ref,\n+                                             impl_items);\n+              let trait_def_id = impl_trait_ref.def_id;\n+              check_on_unimplemented(ccx, trait_def_id, it);\n           }\n       }\n       hir::ItemTrait(..) => {\n@@ -1812,9 +1809,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  f: F) where\n         F: FnOnce(&ty::ItemSubsts<'tcx>),\n     {\n-        match self.tables.borrow().item_substs.get(&id) {\n-            Some(s) => { f(s) }\n-            None => { }\n+        if let Some(s) = self.tables.borrow().item_substs.get(&id) {\n+            f(s);\n         }\n     }\n "}, {"sha": "40b19b01cd901cfda65786bfeeb0d04e8f3f463c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=123a6ef25cdd5463eef183d0113e3166cdd7b800", "patch": "@@ -156,13 +156,10 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     {\n         {\n             let mut stack = self.stack.borrow_mut();\n-            match stack.iter().enumerate().rev().find(|&(_, r)| *r == request) {\n-                None => { }\n-                Some((i, _)) => {\n-                    let cycle = &stack[i..];\n-                    self.report_cycle(span, cycle);\n-                    return Err(ErrorReported);\n-                }\n+            if let Some((i, _)) = stack.iter().enumerate().rev().find(|&(_, r)| *r == request) {\n+                let cycle = &stack[i..];\n+                self.report_cycle(span, cycle);\n+                return Err(ErrorReported);\n             }\n             stack.push(request);\n         }"}, {"sha": "c7248fe68fafd39c2ef283c0099b44336f19a633", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a6ef25cdd5463eef183d0113e3166cdd7b800/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=123a6ef25cdd5463eef183d0113e3166cdd7b800", "patch": "@@ -2449,13 +2449,10 @@ impl<'a> State<'a> {\n                     |s, ty| s.print_type(&ty)));\n                 try!(word(&mut self.s, \")\"));\n \n-                match data.output {\n-                    None => { }\n-                    Some(ref ty) => {\n-                        try!(self.space_if_not_bol());\n-                        try!(self.word_space(\"->\"));\n-                        try!(self.print_type(&ty));\n-                    }\n+                if let Some(ref ty) = data.output {\n+                    try!(self.space_if_not_bol());\n+                    try!(self.word_space(\"->\"));\n+                    try!(self.print_type(&ty));\n                 }\n             }\n         }"}]}