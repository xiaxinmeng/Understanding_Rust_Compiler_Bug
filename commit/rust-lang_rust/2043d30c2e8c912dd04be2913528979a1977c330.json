{"sha": "2043d30c2e8c912dd04be2913528979a1977c330", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNDNkMzBjMmU4YzkxMmRkMDRiZTI5MTM1Mjg5NzlhMTk3N2MzMzA=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-06T09:45:11Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-12-03T09:33:02Z"}, "message": "codegen_llvm_back: improve allocations", "tree": {"sha": "575ba5f48d9c9b014a1a3b2c23bad188614ab494", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/575ba5f48d9c9b014a1a3b2c23bad188614ab494"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2043d30c2e8c912dd04be2913528979a1977c330", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2043d30c2e8c912dd04be2913528979a1977c330", "html_url": "https://github.com/rust-lang/rust/commit/2043d30c2e8c912dd04be2913528979a1977c330", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2043d30c2e8c912dd04be2913528979a1977c330/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a563ceb3b9471acbb827e27686c5cacadc49a032", "url": "https://api.github.com/repos/rust-lang/rust/commits/a563ceb3b9471acbb827e27686c5cacadc49a032", "html_url": "https://github.com/rust-lang/rust/commit/a563ceb3b9471acbb827e27686c5cacadc49a032"}], "stats": {"total": 44, "additions": 23, "deletions": 21}, "files": [{"sha": "68da14570e4479a04bf583b8352233479fc2e888", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2043d30c2e8c912dd04be2913528979a1977c330/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2043d30c2e8c912dd04be2913528979a1977c330/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=2043d30c2e8c912dd04be2913528979a1977c330", "patch": "@@ -72,12 +72,12 @@ pub(crate) fn link_binary(sess: &Session,\n            bug!(\"invalid output type `{:?}` for target os `{}`\",\n                 crate_type, sess.opts.target_triple);\n         }\n-        let mut out_files = link_binary_output(sess,\n-                                               codegen_results,\n-                                               crate_type,\n-                                               outputs,\n-                                               crate_name);\n-        out_filenames.append(&mut out_files);\n+        let out_files = link_binary_output(sess,\n+                                           codegen_results,\n+                                           crate_type,\n+                                           outputs,\n+                                           crate_name);\n+        out_filenames.extend(out_files);\n     }\n \n     // Remove the temporary object file and metadata if we aren't saving temps"}, {"sha": "99828e5b7fbbe4ae2c2252ad6a80284558229190", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2043d30c2e8c912dd04be2913528979a1977c330/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2043d30c2e8c912dd04be2913528979a1977c330/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=2043d30c2e8c912dd04be2913528979a1977c330", "patch": "@@ -225,11 +225,12 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // and we want to move everything to the same LLVM context. Currently the\n         // way we know of to do that is to serialize them to a string and them parse\n         // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n-        for module in modules {\n+        serialized_modules.extend(modules.into_iter().map(|module| {\n             let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n             let llmod_id = CString::new(&module.name[..]).unwrap();\n-            serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n-        }\n+\n+            (SerializedModule::Local(buffer), llmod_id)\n+        }));\n \n         // For all serialized bitcode files we parse them and link them in as we did\n         // above, this is all mostly handled in C++. Like above, though, we don't\n@@ -349,9 +350,10 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             .map(|&(_, ref wp)| (wp.cgu_name.clone(), wp.clone()))\n             .collect();\n \n-        let mut thin_buffers = Vec::new();\n-        let mut module_names = Vec::new();\n-        let mut thin_modules = Vec::new();\n+        let full_scope_len = modules.len() + serialized_modules.len() + cached_modules.len();\n+        let mut thin_buffers = Vec::with_capacity(modules.len());\n+        let mut module_names = Vec::with_capacity(full_scope_len);\n+        let mut thin_modules = Vec::with_capacity(full_scope_len);\n \n         // FIXME: right now, like with fat LTO, we serialize all in-memory\n         //        modules before working with them and ThinLTO. We really\n@@ -360,7 +362,7 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         //        into the global index. It turns out that this loop is by far\n         //        the most expensive portion of this small bit of global\n         //        analysis!\n-        for (i, module) in modules.iter().enumerate() {\n+        for (i, module) in modules.into_iter().enumerate() {\n             info!(\"local module: {} - {}\", i, module.name);\n             let name = CString::new(module.name.clone()).unwrap();\n             let buffer = ThinBuffer::new(module.module_llvm.llmod());\n@@ -406,7 +408,7 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         //        incremental ThinLTO first where we could actually avoid\n         //        looking at upstream modules entirely sometimes (the contents,\n         //        we must always unconditionally look at the index).\n-        let mut serialized = Vec::new();\n+        let mut serialized = Vec::with_capacity(serialized_modules.len() + cached_modules.len());\n \n         let cached_modules = cached_modules.into_iter().map(|(sm, wp)| {\n             (sm, CString::new(wp.cgu_name).unwrap())"}, {"sha": "73a7366d0a393eda2a7c141568052e8370aa1ba8", "filename": "src/librustc_codegen_llvm/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2043d30c2e8c912dd04be2913528979a1977c330/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2043d30c2e8c912dd04be2913528979a1977c330/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs?ref=2043d30c2e8c912dd04be2913528979a1977c330", "patch": "@@ -31,14 +31,12 @@ pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n         return Vec::new();\n     }\n \n-    let mut flags = Vec::new();\n-\n     debug!(\"preparing the RPATH!\");\n \n     let libs = config.used_crates.clone();\n     let libs = libs.iter().filter_map(|&(_, ref l)| l.option()).collect::<Vec<_>>();\n     let rpaths = get_rpaths(config, &libs);\n-    flags.extend_from_slice(&rpaths_to_flags(&rpaths));\n+    let mut flags = rpaths_to_flags(&rpaths);\n \n     // Use DT_RUNPATH instead of DT_RPATH if available\n     if config.linker_is_gnu {\n@@ -49,7 +47,8 @@ pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n }\n \n fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n-    let mut ret = Vec::new();\n+    let mut ret = Vec::with_capacity(rpaths.len()); // the minimum needed capacity\n+\n     for rpath in rpaths {\n         if rpath.contains(',') {\n             ret.push(\"-Wl,-rpath\".into());"}, {"sha": "d25917e51bfd69b735ded1c85ad6eb4dfd27069f", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2043d30c2e8c912dd04be2913528979a1977c330/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2043d30c2e8c912dd04be2913528979a1977c330/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=2043d30c2e8c912dd04be2913528979a1977c330", "patch": "@@ -229,10 +229,11 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"__llvm_profile_raw_version\",\n             \"__llvm_profile_filename\",\n         ];\n-        for sym in &PROFILER_WEAK_SYMBOLS {\n+\n+        symbols.extend(PROFILER_WEAK_SYMBOLS.iter().map(|sym| {\n             let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(sym));\n-            symbols.push((exported_symbol, SymbolExportLevel::C));\n-        }\n+            (exported_symbol, SymbolExportLevel::C)\n+        }));\n     }\n \n     if tcx.sess.crate_types.borrow().contains(&config::CrateType::Dylib) {"}]}