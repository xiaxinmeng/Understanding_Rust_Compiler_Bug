{"sha": "cff9a758ae116a0b54a55033f6a5156f8656cc0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZjlhNzU4YWUxMTZhMGI1NGE1NTAzM2Y2YTUxNTZmODY1NmNjMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-17T21:57:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-17T21:57:06Z"}, "message": "Auto merge of #71264 - Dylan-DPC:rollup-njgbey7, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #70467 (Use `call` instead of `invoke` for functions that cannot unwind )\n - #71070 (rustbuild: Remove stage 0 LLD flavor workaround for MSVC)\n - #71167 (big-O notation: parenthesis for function calls, explicit multiplication)\n - #71238 (Miri: fix typo)\n - #71242 (Format Mailmap To Work With GitHub)\n - #71243 (Account for use of `try!()` in 2018 edition and guide users in the right direction)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d763343c30cab7190d2280146cc464515c13cca3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d763343c30cab7190d2280146cc464515c13cca3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cff9a758ae116a0b54a55033f6a5156f8656cc0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cff9a758ae116a0b54a55033f6a5156f8656cc0c", "html_url": "https://github.com/rust-lang/rust/commit/cff9a758ae116a0b54a55033f6a5156f8656cc0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cff9a758ae116a0b54a55033f6a5156f8656cc0c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce93331e2cf21ac4b72a53854b105955919114e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce93331e2cf21ac4b72a53854b105955919114e7", "html_url": "https://github.com/rust-lang/rust/commit/ce93331e2cf21ac4b72a53854b105955919114e7"}, {"sha": "4b9eeca5c55f4064731a963674fa4056a9a50ce5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9eeca5c55f4064731a963674fa4056a9a50ce5", "html_url": "https://github.com/rust-lang/rust/commit/4b9eeca5c55f4064731a963674fa4056a9a50ce5"}], "stats": {"total": 241, "additions": 160, "deletions": 81}, "files": [{"sha": "aed3a4ca5b002ac96a6d140824a3732f39084c12", "filename": ".mailmap", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -133,7 +133,7 @@ Jo\u00e3o Oliveira <hello@jxs.pt> joaoxsouls <joaoxsouls@gmail.com>\n Johann Hofmann <git@johann-hofmann.com> Johann <git@johann-hofmann.com>\n John Clements <clements@racket-lang.org> <clements@brinckerhoff.org>\n John Hodge <acessdev@gmail.com> John Hodge <tpg@mutabah.net>\n-John Ka\u030are Alsaker <john.kare.alsaker@gmail.com>\n+John K\u00e5re Alsaker <john.kare.alsaker@gmail.com>\n John Talling <inrustwetrust@users.noreply.github.com>\n Jonathan Bailey <jbailey@mozilla.com> <jbailey@jbailey-20809.local>\n Jonathan S <gereeter@gmail.com> Jonathan S <gereeter+code@gmail.com>\n@@ -153,7 +153,7 @@ Lauren\u021biu Nicola <lnicola@dend.ro>\n Lee Jeffery <leejeffery@gmail.com> Lee Jeffery <lee@leejeffery.co.uk>\n Lee Wondong <wdlee91@gmail.com>\n Lennart Kudling <github@kudling.de>\n-Le\u0301o Testard <leo.testard@gmail.com>\n+L\u00e9o Testard <leo.testard@gmail.com>\n Lindsey Kuper <lindsey@composition.al> <lindsey@rockstargirl.org>\n Lindsey Kuper <lindsey@composition.al> <lkuper@mozilla.com>\n Luke Metz <luke.metz@students.olin.edu>"}, {"sha": "a8c00c8c3ca88368764e4d5cb22068f9057671fc", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -134,11 +134,6 @@ fn main() {\n             cmd.arg(format!(\"-Clinker={}\", host_linker));\n         }\n \n-        // Override linker flavor if necessary.\n-        if let Ok(host_linker_flavor) = env::var(\"RUSTC_HOST_LINKER_FLAVOR\") {\n-            cmd.arg(format!(\"-Clinker-flavor={}\", host_linker_flavor));\n-        }\n-\n         if let Ok(s) = env::var(\"RUSTC_HOST_CRT_STATIC\") {\n             if s == \"true\" {\n                 cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");"}, {"sha": "8d6c2db792645ad0af93f7861768f0c576c4c116", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -969,27 +969,11 @@ impl<'a> Builder<'a> {\n         // See https://github.com/rust-lang/rust/issues/68647.\n         let can_use_lld = mode != Mode::Std;\n \n-        // FIXME: The beta compiler doesn't pick the `lld-link` flavor for `*-pc-windows-msvc`\n-        // Remove `RUSTC_HOST_LINKER_FLAVOR` when this is fixed\n-        let lld_linker_flavor = |linker: &Path, target: Interned<String>| {\n-            compiler.stage == 0\n-                && linker.file_name() == Some(OsStr::new(\"rust-lld\"))\n-                && target.contains(\"pc-windows-msvc\")\n-        };\n-\n         if let Some(host_linker) = self.linker(compiler.host, can_use_lld) {\n-            if lld_linker_flavor(host_linker, compiler.host) {\n-                cargo.env(\"RUSTC_HOST_LINKER_FLAVOR\", \"lld-link\");\n-            }\n-\n             cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n         }\n \n         if let Some(target_linker) = self.linker(target, can_use_lld) {\n-            if lld_linker_flavor(target_linker, target) {\n-                rustflags.arg(\"-Clinker-flavor=lld-link\");\n-            }\n-\n             let target = crate::envify(&target);\n             cargo.env(&format!(\"CARGO_TARGET_{}_LINKER\", target), target_linker);\n         }"}, {"sha": "03c9164fb909536b23b2255d04fcfd78ce622a76", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -1,10 +1,10 @@\n //! A priority queue implemented with a binary heap.\n //!\n-//! Insertion and popping the largest element have `O(log n)` time complexity.\n+//! Insertion and popping the largest element have `O(log(n))` time complexity.\n //! Checking the largest element is `O(1)`. Converting a vector to a binary heap\n //! can be done in-place, and has `O(n)` complexity. A binary heap can also be\n-//! converted to a sorted vector in-place, allowing it to be used for an `O(n\n-//! log n)` in-place heapsort.\n+//! converted to a sorted vector in-place, allowing it to be used for an `O(n * log(n))`\n+//! in-place heapsort.\n //!\n //! # Examples\n //!\n@@ -233,9 +233,9 @@ use super::SpecExtend;\n ///\n /// # Time complexity\n ///\n-/// | [push] | [pop]    | [peek]/[peek\\_mut] |\n-/// |--------|----------|--------------------|\n-/// | O(1)~  | O(log n) | O(1)               |\n+/// | [push] | [pop]     | [peek]/[peek\\_mut] |\n+/// |--------|-----------|--------------------|\n+/// | O(1)~  | O(log(n)) | O(1)               |\n ///\n /// The value for `push` is an expected cost; the method documentation gives a\n /// more detailed analysis.\n@@ -398,7 +398,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// Cost is O(1) in the worst case.\n+    /// Cost is `O(1)` in the worst case.\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n         if self.is_empty() { None } else { Some(PeekMut { heap: self, sift: true }) }\n@@ -422,8 +422,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// The worst case cost of `pop` on a heap containing *n* elements is O(log\n-    /// n).\n+    /// The worst case cost of `pop` on a heap containing *n* elements is `O(log(n))`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n@@ -456,15 +455,15 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// The expected cost of `push`, averaged over every possible ordering of\n     /// the elements being pushed, and over a sufficiently large number of\n-    /// pushes, is O(1). This is the most meaningful cost metric when pushing\n+    /// pushes, is `O(1)`. This is the most meaningful cost metric when pushing\n     /// elements that are *not* already in any sorted pattern.\n     ///\n     /// The time complexity degrades if elements are pushed in predominantly\n     /// ascending order. In the worst case, elements are pushed in ascending\n-    /// sorted order and the amortized cost per push is O(log n) against a heap\n+    /// sorted order and the amortized cost per push is `O(log(n))` against a heap\n     /// containing *n* elements.\n     ///\n-    /// The worst case cost of a *single* call to `push` is O(n). The worst case\n+    /// The worst case cost of a *single* call to `push` is `O(n)`. The worst case\n     /// occurs when capacity is exhausted and needs a resize. The resize cost\n     /// has been amortized in the previous figures.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -623,7 +622,7 @@ impl<T: Ord> BinaryHeap<T> {\n \n         // `rebuild` takes O(len1 + len2) operations\n         // and about 2 * (len1 + len2) comparisons in the worst case\n-        // while `extend` takes O(len2 * log_2(len1)) operations\n+        // while `extend` takes O(len2 * log(len1)) operations\n         // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n         // assuming len1 >= len2.\n         #[inline]\n@@ -644,7 +643,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// The remaining elements will be removed on drop in heap order.\n     ///\n     /// Note:\n-    /// * `.drain_sorted()` is O(n lg n); much slower than `.drain()`.\n+    /// * `.drain_sorted()` is `O(n * log(n))`; much slower than `.drain()`.\n     ///   You should use the latter for most cases.\n     ///\n     /// # Examples\n@@ -729,7 +728,7 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// Cost is O(1) in the worst case.\n+    /// Cost is `O(1)` in the worst case.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)"}, {"sha": "91d93a1be1c98040ed6dca95dfc8274abe0d905c", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -40,7 +40,7 @@ use UnderflowResult::*;\n /// performance on *small* nodes of elements which are cheap to compare. However in the future we\n /// would like to further explore choosing the optimal search strategy based on the choice of B,\n /// and possibly other factors. Using linear search, searching for a random element is expected\n-/// to take O(B log<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice,\n+/// to take O(B * log(n)) comparisons, which is generally worse than a BST. In practice,\n /// however, performance is excellent.\n ///\n /// It is a logic error for a key to be modified in such a way that the key's ordering relative to"}, {"sha": "af341e6c1caab8313f9d3d6172db6c2a41194032", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -390,7 +390,7 @@ impl<T> LinkedList<T> {\n     /// This reuses all the nodes from `other` and moves them into `self`. After\n     /// this operation, `other` becomes empty.\n     ///\n-    /// This operation should compute in O(1) time and O(1) memory.\n+    /// This operation should compute in `O(1)` time and `O(1)` memory.\n     ///\n     /// # Examples\n     ///\n@@ -547,7 +547,7 @@ impl<T> LinkedList<T> {\n \n     /// Returns `true` if the `LinkedList` is empty.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -568,7 +568,7 @@ impl<T> LinkedList<T> {\n \n     /// Returns the length of the `LinkedList`.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -594,7 +594,7 @@ impl<T> LinkedList<T> {\n \n     /// Removes all elements from the `LinkedList`.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// This operation should compute in `O(n)` time.\n     ///\n     /// # Examples\n     ///\n@@ -737,7 +737,7 @@ impl<T> LinkedList<T> {\n \n     /// Adds an element first in the list.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -760,7 +760,7 @@ impl<T> LinkedList<T> {\n     /// Removes the first element and returns it, or `None` if the list is\n     /// empty.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -783,7 +783,7 @@ impl<T> LinkedList<T> {\n \n     /// Appends an element to the back of a list.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -803,7 +803,7 @@ impl<T> LinkedList<T> {\n     /// Removes the last element from a list and returns it, or `None` if\n     /// it is empty.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -824,7 +824,7 @@ impl<T> LinkedList<T> {\n     /// Splits the list into two at the given index. Returns everything after the given index,\n     /// including the index.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// This operation should compute in `O(n)` time.\n     ///\n     /// # Panics\n     ///\n@@ -880,7 +880,7 @@ impl<T> LinkedList<T> {\n \n     /// Removes the element at the given index and returns it.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// This operation should compute in `O(n)` time.\n     ///\n     /// # Panics\n     /// Panics if at >= len"}, {"sha": "091b068b0b2459cf2950fe679b4f3d4f08e49963", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -1391,7 +1391,7 @@ impl<T> VecDeque<T> {\n     /// Removes an element from anywhere in the `VecDeque` and returns it,\n     /// replacing it with the first element.\n     ///\n-    /// This does not preserve ordering, but is O(1).\n+    /// This does not preserve ordering, but is `O(1)`.\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n@@ -1426,7 +1426,7 @@ impl<T> VecDeque<T> {\n     /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n     /// last element.\n     ///\n-    /// This does not preserve ordering, but is O(1).\n+    /// This does not preserve ordering, but is `O(1)`.\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n@@ -2927,7 +2927,7 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// [`Vec<T>`]: crate::vec::Vec\n     /// [`VecDeque<T>`]: crate::collections::VecDeque\n     ///\n-    /// This never needs to re-allocate, but does need to do O(n) data movement if\n+    /// This never needs to re-allocate, but does need to do `O(n)` data movement if\n     /// the circular buffer doesn't happen to be at the beginning of the allocation.\n     ///\n     /// # Examples"}, {"sha": "955cbe77819e5b29b5bef6495684cfdcfedd02d7", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -165,7 +165,7 @@ mod hack {\n impl<T> [T] {\n     /// Sorts the slice.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n@@ -200,7 +200,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a comparator function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -254,7 +254,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n log n)`\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(m * n * log(n))`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n     /// For expensive key functions (e.g. functions that are not simple property accesses or\n@@ -297,7 +297,7 @@ impl<T> [T] {\n     ///\n     /// During sorting, the key function is called only once per element.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n + n log n)`\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(m * n + n * log(n))`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n     /// For simple key functions (e.g., functions that are property accesses or\n@@ -935,7 +935,7 @@ where\n /// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n /// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n ///\n-/// The invariants ensure that the total running time is `O(n log n)` worst-case.\n+/// The invariants ensure that the total running time is `O(n * log(n))` worst-case.\n fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,"}, {"sha": "df976128b5efb7e92e6f6d5f9131432ab8835eed", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -1606,7 +1606,7 @@ impl<T> [T] {\n     /// Sorts the slice, but may not preserve the order of equal elements.\n     ///\n     /// This sort is unstable (i.e., may reorder equal elements), in-place\n-    /// (i.e., does not allocate), and `O(n log n)` worst-case.\n+    /// (i.e., does not allocate), and `O(n * log(n))` worst-case.\n     ///\n     /// # Current implementation\n     ///\n@@ -1642,7 +1642,7 @@ impl<T> [T] {\n     /// elements.\n     ///\n     /// This sort is unstable (i.e., may reorder equal elements), in-place\n-    /// (i.e., does not allocate), and `O(n log n)` worst-case.\n+    /// (i.e., does not allocate), and `O(n * log(n))` worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -1697,7 +1697,7 @@ impl<T> [T] {\n     /// elements.\n     ///\n     /// This sort is unstable (i.e., may reorder equal elements), in-place\n-    /// (i.e., does not allocate), and `O(m n log n)` worst-case, where the key function is\n+    /// (i.e., does not allocate), and `O(m * n * log(n))` worst-case, where the key function is\n     /// `O(m)`.\n     ///\n     /// # Current implementation\n@@ -1957,7 +1957,7 @@ impl<T> [T] {\n         // over all the elements, swapping as we go so that at the end\n         // the elements we wish to keep are in the front, and those we\n         // wish to reject are at the back. We can then split the slice.\n-        // This operation is still O(n).\n+        // This operation is still `O(n)`.\n         //\n         // Example: We start in this state, where `r` represents \"next\n         // read\" and `w` represents \"next_write`."}, {"sha": "be3e7aaa2e89a678fbd297d70a3b67874b65817e", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -143,7 +143,7 @@ where\n     }\n }\n \n-/// Sorts `v` using heapsort, which guarantees `O(n log n)` worst-case.\n+/// Sorts `v` using heapsort, which guarantees `O(n * log(n))` worst-case.\n #[cold]\n pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n where\n@@ -621,7 +621,7 @@ where\n         }\n \n         // If too many bad pivot choices were made, simply fall back to heapsort in order to\n-        // guarantee `O(n log n)` worst-case.\n+        // guarantee `O(n * log(n))` worst-case.\n         if limit == 0 {\n             heapsort(v, is_less);\n             return;\n@@ -684,7 +684,7 @@ where\n     }\n }\n \n-/// Sorts `v` using pattern-defeating quicksort, which is `O(n log n)` worst-case.\n+/// Sorts `v` using pattern-defeating quicksort, which is `O(n * log(n))` worst-case.\n pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,"}, {"sha": "4913138650880cd4b6267f11ed1adfb1db7bd0f5", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -111,7 +111,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         destination: Option<(ReturnDest<'tcx, Bx::Value>, mir::BasicBlock)>,\n         cleanup: Option<mir::BasicBlock>,\n     ) {\n-        if let Some(cleanup) = cleanup {\n+        // If there is a cleanup block and the function we're calling can unwind, then\n+        // do an invoke, otherwise do a call.\n+        if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n             let ret_bx = if let Some((_, target)) = destination {\n                 fx.blocks[target]\n             } else {"}, {"sha": "71275452fb688599de12200b025f673d7730198a", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -26,7 +26,7 @@ pub enum MemPlaceMeta<Tag = (), Id = AllocId> {\n     /// `Sized` types or unsized `extern type`\n     None,\n     /// The address of this place may not be taken. This protects the `MemPlace` from coming from\n-    /// a ZST Operand with a backing allocation and being converted to an integer address. This\n+    /// a ZST Operand without a backing allocation and being converted to an integer address. This\n     /// should be impossible, because you can't take the address of an operand, but this is a second\n     /// protection layer ensuring that we don't mess up.\n     Poison,"}, {"sha": "552f3d798ae8aa1a010ff54f490cb957bee4922d", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -1054,6 +1054,39 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    pub(super) fn try_macro_suggestion(&mut self) -> PResult<'a, P<Expr>> {\n+        let is_try = self.token.is_keyword(kw::Try);\n+        let is_questionmark = self.look_ahead(1, |t| t == &token::Not); //check for !\n+        let is_open = self.look_ahead(2, |t| t == &token::OpenDelim(token::Paren)); //check for (\n+\n+        if is_try && is_questionmark && is_open {\n+            let lo = self.token.span;\n+            self.bump(); //remove try\n+            self.bump(); //remove !\n+            let try_span = lo.to(self.token.span); //we take the try!( span\n+            self.bump(); //remove (\n+            let is_empty = self.token == token::CloseDelim(token::Paren); //check if the block is empty\n+            self.consume_block(token::Paren, ConsumeClosingDelim::No); //eat the block\n+            let hi = self.token.span;\n+            self.bump(); //remove )\n+            let mut err = self.struct_span_err(lo.to(hi), \"use of deprecated `try` macro\");\n+            err.note(\"in the 2018 edition `try` is a reserved keyword, and the `try!()` macro is deprecated\");\n+            let prefix = if is_empty { \"\" } else { \"alternatively, \" };\n+            if !is_empty {\n+                err.multipart_suggestion(\n+                    \"you can use the `?` operator instead\",\n+                    vec![(try_span, \"\".to_owned()), (hi, \"?\".to_owned())],\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            err.span_suggestion(lo.shrink_to_lo(), &format!(\"{}you can still access the deprecated `try!()` macro using the \\\"raw identifier\\\" syntax\", prefix), \"r#\".to_string(), Applicability::MachineApplicable);\n+            err.emit();\n+            Ok(self.mk_expr_err(lo.to(hi)))\n+        } else {\n+            Err(self.expected_expression_found()) // The user isn't trying to invoke the try! macro\n+        }\n+    }\n+\n     /// Recovers a situation like `for ( $pat in $expr )`\n     /// and suggest writing `for $pat in $expr` instead.\n     ///"}, {"sha": "986f5410e26c0b454d83fa098d7a6f1a62185401", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -1006,7 +1006,7 @@ impl<'a> Parser<'a> {\n                 let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Lit(literal), attrs);\n                 self.maybe_recover_from_bad_qpath(expr, true)\n             }\n-            None => Err(self.expected_expression_found()),\n+            None => self.try_macro_suggestion(),\n         }\n     }\n "}, {"sha": "cc6663bebd3d4cf99aa8ce21f798d0f43010d3dc", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -110,10 +110,10 @@\n //!\n //! For Sets, all operations have the cost of the equivalent Map operation.\n //!\n-//! |              | get       | insert   | remove   | predecessor | append |\n-//! |--------------|-----------|----------|----------|-------------|--------|\n-//! | [`HashMap`]  | O(1)~     | O(1)~*   | O(1)~    | N/A         | N/A    |\n-//! | [`BTreeMap`] | O(log n)  | O(log n) | O(log n) | O(log n)    | O(n+m) |\n+//! |              | get       | insert    | remove    | predecessor | append |\n+//! |--------------|-----------|-----------|-----------|-------------|--------|\n+//! | [`HashMap`]  | O(1)~     | O(1)~*    | O(1)~     | N/A         | N/A    |\n+//! | [`BTreeMap`] | O(log(n)) | O(log(n)) | O(log(n)) | O(log(n))   | O(n+m) |\n //!\n //! # Correct and Efficient Usage of Collections\n //!"}, {"sha": "5aca7b7476a52f2025390d8143121e714563a1cd", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -43,8 +43,8 @@\n //! terminator, so the buffer length is really `len+1` characters.\n //! Rust strings don't have a nul terminator; their length is always\n //! stored and does not need to be calculated. While in Rust\n-//! accessing a string's length is a O(1) operation (because the\n-//! length is stored); in C it is an O(length) operation because the\n+//! accessing a string's length is a `O(1)` operation (because the\n+//! length is stored); in C it is an `O(length)` operation because the\n //! length needs to be computed by scanning the string for the nul\n //! terminator.\n //!"}, {"sha": "29c82686731ca5c96a0ba24d695eea67de0cfe63", "filename": "src/test/codegen/c-variadic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Ftest%2Fcodegen%2Fc-variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Ftest%2Fcodegen%2Fc-variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fc-variadic.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -16,38 +16,38 @@ extern \"C\" {\n #[unwind(aborts)] // FIXME(#58794)\n pub unsafe extern \"C\" fn use_foreign_c_variadic_0() {\n     // Ensure that we correctly call foreign C-variadic functions.\n-    // CHECK: invoke void (i32, ...) @foreign_c_variadic_0([[PARAM:i32( signext)?]] 0)\n+    // CHECK: call void (i32, ...) @foreign_c_variadic_0([[PARAM:i32( signext)?]] 0)\n     foreign_c_variadic_0(0);\n-    // CHECK: invoke void (i32, ...) @foreign_c_variadic_0([[PARAM]] 0, [[PARAM]] 42)\n+    // CHECK: call void (i32, ...) @foreign_c_variadic_0([[PARAM]] 0, [[PARAM]] 42)\n     foreign_c_variadic_0(0, 42i32);\n-    // CHECK: invoke void (i32, ...) @foreign_c_variadic_0([[PARAM]] 0, [[PARAM]] 42, [[PARAM]] 1024)\n+    // CHECK: call void (i32, ...) @foreign_c_variadic_0([[PARAM]] 0, [[PARAM]] 42, [[PARAM]] 1024)\n     foreign_c_variadic_0(0, 42i32, 1024i32);\n-    // CHECK: invoke void (i32, ...) @foreign_c_variadic_0([[PARAM]] 0, [[PARAM]] 42, [[PARAM]] 1024, [[PARAM]] 0)\n+    // CHECK: call void (i32, ...) @foreign_c_variadic_0([[PARAM]] 0, [[PARAM]] 42, [[PARAM]] 1024, [[PARAM]] 0)\n     foreign_c_variadic_0(0, 42i32, 1024i32, 0i32);\n }\n \n // Ensure that we do not remove the `va_list` passed to the foreign function when\n // removing the \"spoofed\" `VaListImpl` that is used by Rust defined C-variadics.\n #[unwind(aborts)] // FIXME(#58794)\n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_0(ap: VaList) {\n-    // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap)\n+    // CHECK: call void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap)\n     foreign_c_variadic_1(ap);\n }\n \n #[unwind(aborts)] // FIXME(#58794)\n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_1(ap: VaList) {\n-    // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 42)\n+    // CHECK: call void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 42)\n     foreign_c_variadic_1(ap, 42i32);\n }\n #[unwind(aborts)] // FIXME(#58794)\n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_2(ap: VaList) {\n-    // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 2, [[PARAM]] 42)\n+    // CHECK: call void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 2, [[PARAM]] 42)\n     foreign_c_variadic_1(ap, 2i32, 42i32);\n }\n \n #[unwind(aborts)] // FIXME(#58794)\n pub unsafe extern \"C\" fn use_foreign_c_variadic_1_3(ap: VaList) {\n-    // CHECK: invoke void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 2, [[PARAM]] 42, [[PARAM]] 0)\n+    // CHECK: call void ({{.*}}*, ...) @foreign_c_variadic_1({{.*}} %ap, [[PARAM]] 2, [[PARAM]] 42, [[PARAM]] 0)\n     foreign_c_variadic_1(ap, 2i32, 42i32, 0i32);\n }\n "}, {"sha": "c7a464a9b0ef24513f8838ea990f2e00b2aca5fe", "filename": "src/test/codegen/call-llvm-intrinsics.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Ftest%2Fcodegen%2Fcall-llvm-intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Ftest%2Fcodegen%2Fcall-llvm-intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcall-llvm-intrinsics.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -0,0 +1,27 @@\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![feature(link_llvm_intrinsics)]\n+#![crate_type = \"lib\"]\n+\n+struct A;\n+\n+impl Drop for A {\n+    fn drop(&mut self) {\n+        println!(\"A\");\n+    }\n+}\n+\n+extern {\n+    #[link_name = \"llvm.sqrt.f32\"]\n+    fn sqrt(x: f32) -> f32;\n+}\n+\n+pub fn do_call() {\n+    let _a = A;\n+\n+    unsafe {\n+        // Ensure that we `call` LLVM intrinsics instead of trying to `invoke` them\n+        // CHECK: call float @llvm.sqrt.f32(float 4.000000e+00\n+        sqrt(4.0);\n+    }\n+}"}, {"sha": "635ceac0b199ede4debc7d089b319e6f65c109a7", "filename": "src/test/ui/try-macro-suggestion.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Ftest%2Fui%2Ftry-macro-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Ftest%2Fui%2Ftry-macro-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-macro-suggestion.rs?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: --edition 2018\n+fn foo() -> Result<(), ()> {\n+    Ok(try!()); //~ ERROR use of deprecated `try` macro\n+    Ok(try!(Ok(()))) //~ ERROR use of deprecated `try` macro\n+}\n+\n+fn main() {\n+    let _ = foo();\n+}"}, {"sha": "9d833ef5ed9fb50cba6d1a66a7c8144017b973d7", "filename": "src/test/ui/try-macro-suggestion.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Ftest%2Fui%2Ftry-macro-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cff9a758ae116a0b54a55033f6a5156f8656cc0c/src%2Ftest%2Fui%2Ftry-macro-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-macro-suggestion.stderr?ref=cff9a758ae116a0b54a55033f6a5156f8656cc0c", "patch": "@@ -0,0 +1,30 @@\n+error: use of deprecated `try` macro\n+  --> $DIR/try-macro-suggestion.rs:3:8\n+   |\n+LL |     Ok(try!());\n+   |        ^^^^^^\n+   |\n+   = note: in the 2018 edition `try` is a reserved keyword, and the `try!()` macro is deprecated\n+help: you can still access the deprecated `try!()` macro using the \"raw identifier\" syntax\n+   |\n+LL |     Ok(r#try!());\n+   |        ^^\n+\n+error: use of deprecated `try` macro\n+  --> $DIR/try-macro-suggestion.rs:4:8\n+   |\n+LL |     Ok(try!(Ok(())))\n+   |        ^^^^^^^^^^^^\n+   |\n+   = note: in the 2018 edition `try` is a reserved keyword, and the `try!()` macro is deprecated\n+help: you can use the `?` operator instead\n+   |\n+LL |     Ok(Ok(())?)\n+   |       --     ^\n+help: alternatively, you can still access the deprecated `try!()` macro using the \"raw identifier\" syntax\n+   |\n+LL |     Ok(r#try!(Ok(())))\n+   |        ^^\n+\n+error: aborting due to 2 previous errors\n+"}]}