{"sha": "6c80f7c4fcb83be65c0b3595eb30690c626a30e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjODBmN2M0ZmNiODNiZTY1YzBiMzU5NWViMzA2OTBjNjI2YTMwZTM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-11-28T05:45:58Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-11-29T06:11:59Z"}, "message": "Fix whitespace in `pp.rs`.\n\nThis commit converts some 2-space indents to 4-space indents.", "tree": {"sha": "d7b6dddafbe4dc8fba4449d5ebcb3aed162a1402", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7b6dddafbe4dc8fba4449d5ebcb3aed162a1402"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c80f7c4fcb83be65c0b3595eb30690c626a30e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c80f7c4fcb83be65c0b3595eb30690c626a30e3", "html_url": "https://github.com/rust-lang/rust/commit/6c80f7c4fcb83be65c0b3595eb30690c626a30e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c80f7c4fcb83be65c0b3595eb30690c626a30e3/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bd451b26580de465d59ed5389209ed191b7dbdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bd451b26580de465d59ed5389209ed191b7dbdd", "html_url": "https://github.com/rust-lang/rust/commit/5bd451b26580de465d59ed5389209ed191b7dbdd"}], "stats": {"total": 252, "additions": 126, "deletions": 126}, "files": [{"sha": "00f22597a3fa3fdb7facb53f3345a6d64f767f47", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 126, "deletions": 126, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/6c80f7c4fcb83be65c0b3595eb30690c626a30e3/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c80f7c4fcb83be65c0b3595eb30690c626a30e3/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=6c80f7c4fcb83be65c0b3595eb30690c626a30e3", "patch": "@@ -316,75 +316,75 @@ impl<'a> Printer<'a> {\n     pub fn pretty_print(&mut self, token: Token) -> io::Result<()> {\n         debug!(\"pp Vec<{},{}>\", self.left, self.right);\n         match token {\n-          Token::Eof => {\n-            if !self.scan_stack.is_empty() {\n-                self.check_stack(0);\n-                self.advance_left()?;\n-            }\n-            self.indent(0);\n-            Ok(())\n-          }\n-          Token::Begin(b) => {\n-            if self.scan_stack.is_empty() {\n-                self.left_total = 1;\n-                self.right_total = 1;\n-                self.left = 0;\n-                self.right = 0;\n-            } else {\n-                self.advance_right();\n+            Token::Eof => {\n+                if !self.scan_stack.is_empty() {\n+                    self.check_stack(0);\n+                    self.advance_left()?;\n+                }\n+                self.indent(0);\n+                Ok(())\n             }\n-            debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n-                   b.offset, self.left, self.right);\n-            self.buf[self.right] = BufEntry { token: token, size: -self.right_total };\n-            let right = self.right;\n-            self.scan_push(right);\n-            Ok(())\n-          }\n-          Token::End => {\n-            if self.scan_stack.is_empty() {\n-                debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n-                self.print(token, 0)\n-            } else {\n-                debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n-                self.advance_right();\n-                self.buf[self.right] = BufEntry { token: token, size: -1 };\n+            Token::Begin(b) => {\n+                if self.scan_stack.is_empty() {\n+                    self.left_total = 1;\n+                    self.right_total = 1;\n+                    self.left = 0;\n+                    self.right = 0;\n+                } else {\n+                    self.advance_right();\n+                }\n+                debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n+                       b.offset, self.left, self.right);\n+                self.buf[self.right] = BufEntry { token: token, size: -self.right_total };\n                 let right = self.right;\n                 self.scan_push(right);\n                 Ok(())\n             }\n-          }\n-          Token::Break(b) => {\n-            if self.scan_stack.is_empty() {\n-                self.left_total = 1;\n-                self.right_total = 1;\n-                self.left = 0;\n-                self.right = 0;\n-            } else {\n-                self.advance_right();\n+            Token::End => {\n+                if self.scan_stack.is_empty() {\n+                    debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n+                    self.print(token, 0)\n+                } else {\n+                    debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n+                    self.advance_right();\n+                    self.buf[self.right] = BufEntry { token: token, size: -1 };\n+                    let right = self.right;\n+                    self.scan_push(right);\n+                    Ok(())\n+                }\n             }\n-            debug!(\"pp Break({})/buffer Vec<{},{}>\",\n-                   b.offset, self.left, self.right);\n-            self.check_stack(0);\n-            let right = self.right;\n-            self.scan_push(right);\n-            self.buf[self.right] = BufEntry { token: token, size: -self.right_total };\n-            self.right_total += b.blank_space;\n-            Ok(())\n-          }\n-          Token::String(s, len) => {\n-            if self.scan_stack.is_empty() {\n-                debug!(\"pp String('{}')/print Vec<{},{}>\",\n-                       s, self.left, self.right);\n-                self.print(Token::String(s, len), len)\n-            } else {\n-                debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n-                       s, self.left, self.right);\n-                self.advance_right();\n-                self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n-                self.right_total += len;\n-                self.check_stream()\n+            Token::Break(b) => {\n+                if self.scan_stack.is_empty() {\n+                    self.left_total = 1;\n+                    self.right_total = 1;\n+                    self.left = 0;\n+                    self.right = 0;\n+                } else {\n+                    self.advance_right();\n+                }\n+                debug!(\"pp Break({})/buffer Vec<{},{}>\",\n+                       b.offset, self.left, self.right);\n+                self.check_stack(0);\n+                let right = self.right;\n+                self.scan_push(right);\n+                self.buf[self.right] = BufEntry { token: token, size: -self.right_total };\n+                self.right_total += b.blank_space;\n+                Ok(())\n+            }\n+            Token::String(s, len) => {\n+                if self.scan_stack.is_empty() {\n+                    debug!(\"pp String('{}')/print Vec<{},{}>\",\n+                           s, self.left, self.right);\n+                    self.print(Token::String(s, len), len)\n+                } else {\n+                    debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n+                           s, self.left, self.right);\n+                    self.advance_right();\n+                    self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n+                    self.right_total += len;\n+                    self.check_stream()\n+                }\n             }\n-          }\n         }\n     }\n     pub fn check_stream(&mut self) -> io::Result<()> {\n@@ -523,74 +523,74 @@ impl<'a> Printer<'a> {\n                              self.right,\n                              6));\n         match token {\n-          Token::Begin(b) => {\n-            if l > self.space {\n-                let col = self.margin - self.space + b.offset;\n-                debug!(\"print Begin -> push broken block at col {}\", col);\n-                self.print_stack.push(PrintStackElem {\n-                    offset: col,\n-                    pbreak: PrintStackBreak::Broken(b.breaks)\n-                });\n-            } else {\n-                debug!(\"print Begin -> push fitting block\");\n-                self.print_stack.push(PrintStackElem {\n-                    offset: 0,\n-                    pbreak: PrintStackBreak::Fits\n-                });\n-            }\n-            Ok(())\n-          }\n-          Token::End => {\n-            debug!(\"print End -> pop End\");\n-            let print_stack = &mut self.print_stack;\n-            assert!(!print_stack.is_empty());\n-            print_stack.pop().unwrap();\n-            Ok(())\n-          }\n-          Token::Break(b) => {\n-            let top = self.get_top();\n-            match top.pbreak {\n-              PrintStackBreak::Fits => {\n-                debug!(\"print Break({}) in fitting block\", b.blank_space);\n-                self.space -= b.blank_space;\n-                self.indent(b.blank_space);\n-                Ok(())\n-              }\n-              PrintStackBreak::Broken(Breaks::Consistent) => {\n-                debug!(\"print Break({}+{}) in consistent block\",\n-                       top.offset, b.offset);\n-                let ret = self.print_newline(top.offset + b.offset);\n-                self.space = self.margin - (top.offset + b.offset);\n-                ret\n-              }\n-              PrintStackBreak::Broken(Breaks::Inconsistent) => {\n+            Token::Begin(b) => {\n                 if l > self.space {\n-                    debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n-                           top.offset, b.offset);\n-                    let ret = self.print_newline(top.offset + b.offset);\n-                    self.space = self.margin - (top.offset + b.offset);\n-                    ret\n+                    let col = self.margin - self.space + b.offset;\n+                    debug!(\"print Begin -> push broken block at col {}\", col);\n+                    self.print_stack.push(PrintStackElem {\n+                        offset: col,\n+                        pbreak: PrintStackBreak::Broken(b.breaks)\n+                    });\n                 } else {\n-                    debug!(\"print Break({}) w/o newline in inconsistent\",\n-                           b.blank_space);\n-                    self.indent(b.blank_space);\n-                    self.space -= b.blank_space;\n-                    Ok(())\n+                    debug!(\"print Begin -> push fitting block\");\n+                    self.print_stack.push(PrintStackElem {\n+                        offset: 0,\n+                        pbreak: PrintStackBreak::Fits\n+                    });\n                 }\n-              }\n+                Ok(())\n+            }\n+            Token::End => {\n+                debug!(\"print End -> pop End\");\n+                let print_stack = &mut self.print_stack;\n+                assert!(!print_stack.is_empty());\n+                print_stack.pop().unwrap();\n+                Ok(())\n+            }\n+            Token::Break(b) => {\n+                let top = self.get_top();\n+                match top.pbreak {\n+                    PrintStackBreak::Fits => {\n+                        debug!(\"print Break({}) in fitting block\", b.blank_space);\n+                        self.space -= b.blank_space;\n+                        self.indent(b.blank_space);\n+                        Ok(())\n+                    }\n+                    PrintStackBreak::Broken(Breaks::Consistent) => {\n+                        debug!(\"print Break({}+{}) in consistent block\",\n+                               top.offset, b.offset);\n+                        let ret = self.print_newline(top.offset + b.offset);\n+                        self.space = self.margin - (top.offset + b.offset);\n+                        ret\n+                    }\n+                    PrintStackBreak::Broken(Breaks::Inconsistent) => {\n+                        if l > self.space {\n+                            debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n+                                   top.offset, b.offset);\n+                            let ret = self.print_newline(top.offset + b.offset);\n+                            self.space = self.margin - (top.offset + b.offset);\n+                            ret\n+                        } else {\n+                            debug!(\"print Break({}) w/o newline in inconsistent\",\n+                                   b.blank_space);\n+                            self.indent(b.blank_space);\n+                            self.space -= b.blank_space;\n+                            Ok(())\n+                        }\n+                    }\n+                }\n+            }\n+            Token::String(ref s, len) => {\n+                debug!(\"print String({})\", s);\n+                assert_eq!(l, len);\n+                // assert!(l <= space);\n+                self.space -= len;\n+                self.print_str(s)\n+            }\n+            Token::Eof => {\n+                // Eof should never get here.\n+                panic!();\n             }\n-          }\n-          Token::String(ref s, len) => {\n-            debug!(\"print String({})\", s);\n-            assert_eq!(l, len);\n-            // assert!(l <= space);\n-            self.space -= len;\n-            self.print_str(s)\n-          }\n-          Token::Eof => {\n-            // Eof should never get here.\n-            panic!();\n-          }\n         }\n     }\n "}]}