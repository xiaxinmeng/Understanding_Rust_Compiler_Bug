{"sha": "69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZDA1MGZiNmIyYTZkOGVjMGMwMWE0NGNjZmFmNzk0MDljNGI0NDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-03T15:50:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-03T15:50:30Z"}, "message": "Auto merge of #1495 - samrat:fd-trait, r=oli-obk\n\nAdd FileDescriptor trait to abstract fn's on File's and Stdin,Stdout,Stderr\n\nRelated issue: #1486\n\nInstead of mapping FDs to `FileHandle`, map them to a `FileDescriptor` trait object. The goal is to eventually have both `FileHandle` as well as `Stdin`, `Stdout` and `Stderr` implement this trait so that syscalls involving FDs can handle both `File`s as well as the standard IO streams.\n\nThis PR adds the `FileDescriptor` trait and an `impl` for `FileHandle`. I'll open a separate PR for implementing the trait for the standard IO streams.", "tree": {"sha": "df7e11ac9857794f7f4b39a7be15e817831aa7e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df7e11ac9857794f7f4b39a7be15e817831aa7e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446", "html_url": "https://github.com/rust-lang/rust/commit/69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d2820dc77754e1793cd79c42d933957bf792923", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d2820dc77754e1793cd79c42d933957bf792923", "html_url": "https://github.com/rust-lang/rust/commit/2d2820dc77754e1793cd79c42d933957bf792923"}, {"sha": "79e066fc95c036e64716a4222c580782a9c932c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/79e066fc95c036e64716a4222c580782a9c932c2", "html_url": "https://github.com/rust-lang/rust/commit/79e066fc95c036e64716a4222c580782a9c932c2"}], "stats": {"total": 190, "additions": 129, "deletions": 61}, "files": [{"sha": "f9dd48fdbae2adc07d696da157c57b49321a1e72", "filename": "src/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446", "patch": "@@ -250,7 +250,7 @@ pub struct Evaluator<'mir, 'tcx> {\n     /// Whether to enforce the validity invariant.\n     pub(crate) validate: bool,\n \n-    pub(crate) file_handler: shims::posix::FileHandler,\n+    pub(crate) file_handler: shims::posix::FileHandler<'tcx>,\n     pub(crate) dir_handler: shims::posix::DirHandler,\n \n     /// The temporary used for storing the argument of"}, {"sha": "2d784490656c9fbcfb176e80a3b4cd8c803251c3", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 128, "deletions": 60, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446", "patch": "@@ -1,7 +1,7 @@\n use std::collections::BTreeMap;\n use std::convert::{TryFrom, TryInto};\n use std::fs::{read_dir, remove_dir, remove_file, rename, DirBuilder, File, FileType, OpenOptions, ReadDir};\n-use std::io::{Read, Seek, SeekFrom, Write};\n+use std::io::{self, Read, Seek, SeekFrom, Write};\n use std::path::Path;\n use std::time::SystemTime;\n \n@@ -22,15 +22,42 @@ struct FileHandle {\n     writable: bool,\n }\n \n+trait FileDescriptor<'tcx> : std::fmt::Debug {\n+    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle>;\n+\n+    fn read(&mut self, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>>;\n+    fn write(&mut self, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>>;\n+    fn seek(&mut self, offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>>;\n+}\n+\n+impl<'tcx> FileDescriptor<'tcx> for FileHandle {\n+    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle> {\n+        Ok(&self)\n+    }\n+\n+    fn read(&mut self, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        Ok(self.file.read(bytes))\n+    }\n+\n+    fn write(&mut self, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        Ok(self.file.write(bytes))\n+    }\n+\n+    fn seek(&mut self, offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+        Ok(self.file.seek(offset))\n+    }\n+}\n+\n #[derive(Debug, Default)]\n-pub struct FileHandler {\n-    handles: BTreeMap<i32, FileHandle>,\n+pub struct FileHandler<'tcx> {\n+    handles: BTreeMap<i32, Box<dyn FileDescriptor<'tcx>>>,\n }\n \n+\n // fd numbers 0, 1, and 2 are reserved for stdin, stdout, and stderr\n const MIN_NORMAL_FILE_FD: i32 = 3;\n \n-impl FileHandler {\n+impl<'tcx> FileHandler<'tcx> {\n     fn insert_fd(&mut self, file_handle: FileHandle) -> i32 {\n         self.insert_fd_with_min_fd(file_handle, 0)\n     }\n@@ -62,7 +89,7 @@ impl FileHandler {\n             self.handles.last_key_value().map(|(fd, _)| fd.checked_add(1).unwrap()).unwrap_or(min_fd)\n         });\n \n-        self.handles.insert(new_fd, file_handle).unwrap_none();\n+        self.handles.insert(new_fd, Box::new(file_handle)).unwrap_none();\n         new_fd\n     }\n }\n@@ -383,7 +410,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             let fh = &mut this.machine.file_handler;\n             let (file_result, writable) = match fh.handles.get(&fd) {\n-                Some(FileHandle { file, writable }) => (file.try_clone(), *writable),\n+                Some(file_descriptor) => match file_descriptor.as_file_handle() {\n+                    Ok(FileHandle { file, writable }) => (file.try_clone(), *writable),\n+                    Err(_) => return this.handle_not_found(),\n+                },\n                 None => return this.handle_not_found(),\n             };\n             let fd_result = file_result.map(|duplicated| {\n@@ -394,9 +424,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             && cmd == this.eval_libc_i32(\"F_FULLFSYNC\")?\n         {\n             let &[_, _] = check_arg_count(args)?;\n-            if let Some(FileHandle { file, writable }) = this.machine.file_handler.handles.get(&fd) {\n-                let io_result = maybe_sync_file(file, *writable, File::sync_all);\n-                this.try_unwrap_io_result(io_result)\n+            if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n+                match file_descriptor.as_file_handle() {\n+                    Ok(FileHandle { file, writable }) => {\n+                        let io_result = maybe_sync_file(&file, *writable, File::sync_all);\n+                        this.try_unwrap_io_result(io_result)\n+                    },\n+                    Err(_) => this.handle_not_found(),\n+                }\n             } else {\n                 this.handle_not_found()\n             }\n@@ -412,24 +447,29 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n \n-        if let Some(FileHandle { file, writable }) = this.machine.file_handler.handles.remove(&fd) {\n-            // We sync the file if it was opened in a mode different than read-only.\n-            if writable {\n-                // `File::sync_all` does the checks that are done when closing a file. We do this to\n-                // to handle possible errors correctly.\n-                let result = this.try_unwrap_io_result(file.sync_all().map(|_| 0i32));\n-                // Now we actually close the file.\n-                drop(file);\n-                // And return the result.\n-                result\n-            } else {\n-                // We drop the file, this closes it but ignores any errors produced when closing\n-                // it. This is done because `File::sync_all` cannot be done over files like\n-                // `/dev/urandom` which are read-only. Check\n-                // https://github.com/rust-lang/miri/issues/999#issuecomment-568920439 for a deeper\n-                // discussion.\n-                drop(file);\n-                Ok(0)\n+        if let Some(file_descriptor) = this.machine.file_handler.handles.remove(&fd) {\n+            match file_descriptor.as_file_handle() {\n+                Ok(FileHandle { file, writable }) => {\n+                    // We sync the file if it was opened in a mode different than read-only.\n+                    if *writable {\n+                        // `File::sync_all` does the checks that are done when closing a file. We do this to\n+                        // to handle possible errors correctly.\n+                        let result = this.try_unwrap_io_result(file.sync_all().map(|_| 0i32));\n+                        // Now we actually close the file.\n+                        drop(file);\n+                        // And return the result.\n+                        result\n+                    } else {\n+                        // We drop the file, this closes it but ignores any errors produced when closing\n+                        // it. This is done because `File::sync_all` cannot be done over files like\n+                        // `/dev/urandom` which are read-only. Check\n+                        // https://github.com/rust-lang/miri/issues/999#issuecomment-568920439 for a deeper\n+                        // discussion.\n+                        drop(file);\n+                        Ok(0)\n+                    }\n+                },\n+                Err(_) => this.handle_not_found()\n             }\n         } else {\n             this.handle_not_found()\n@@ -460,15 +500,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count.min(this.machine_isize_max() as u64).min(isize::MAX as u64);\n \n-        if let Some(FileHandle { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n-            trace!(\"read: FD mapped to {:?}\", file);\n+        if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n+            trace!(\"read: FD mapped to {:?}\", file_descriptor);\n             // We want to read at most `count` bytes. We are sure that `count` is not negative\n             // because it was a target's `usize`. Also we are sure that its smaller than\n             // `usize::MAX` because it is a host's `isize`.\n             let mut bytes = vec![0; count as usize];\n-            let result = file\n-                .read(&mut bytes)\n-                // `File::read` never returns a value larger than `count`, so this cannot fail.\n+            // `File::read` never returns a value larger than `count`,\n+            // so this cannot fail.\n+            let result = file_descriptor\n+                .read(&mut bytes)?\n                 .map(|c| i64::try_from(c).unwrap());\n \n             match result {\n@@ -510,9 +551,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count.min(this.machine_isize_max() as u64).min(isize::MAX as u64);\n \n-        if let Some(FileHandle { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n+        if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n             let bytes = this.memory.read_bytes(buf, Size::from_bytes(count))?;\n-            let result = file.write(&bytes).map(|c| i64::try_from(c).unwrap());\n+            let result = file_descriptor\n+                .write(&bytes)?\n+                .map(|c| i64::try_from(c).unwrap());\n             this.try_unwrap_io_result(result)\n         } else {\n             this.handle_not_found()\n@@ -545,8 +588,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(-1);\n         };\n \n-        if let Some(FileHandle { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n-            let result = file.seek(seek_from).map(|offset| i64::try_from(offset).unwrap());\n+        if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n+            let result = file_descriptor\n+                .seek(seek_from)?\n+                .map(|offset| i64::try_from(offset).unwrap());\n             this.try_unwrap_io_result(result)\n         } else {\n             this.handle_not_found()\n@@ -1103,21 +1148,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n         let length = this.read_scalar(length_op)?.to_i64()?;\n-        if let Some(FileHandle { file, writable }) = this.machine.file_handler.handles.get_mut(&fd) {\n-            if *writable {\n-                if let Ok(length) = length.try_into() {\n-                    let result = file.set_len(length);\n-                    this.try_unwrap_io_result(result.map(|_| 0i32))\n-                } else {\n-                    let einval = this.eval_libc(\"EINVAL\")?;\n-                    this.set_last_error(einval)?;\n-                    Ok(-1)\n+        if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n+            match file_descriptor.as_file_handle() {\n+                Ok(FileHandle { file, writable }) => {\n+                    if *writable {\n+                        if let Ok(length) = length.try_into() {\n+                            let result = file.set_len(length);\n+                            this.try_unwrap_io_result(result.map(|_| 0i32))\n+                        } else {\n+                            let einval = this.eval_libc(\"EINVAL\")?;\n+                            this.set_last_error(einval)?;\n+                            Ok(-1)\n+                        }\n+                    } else {\n+                        // The file is not writable\n+                        let einval = this.eval_libc(\"EINVAL\")?;\n+                        this.set_last_error(einval)?;\n+                        Ok(-1)\n+                    }\n                 }\n-            } else {\n-                // The file is not writable\n-                let einval = this.eval_libc(\"EINVAL\")?;\n-                this.set_last_error(einval)?;\n-                Ok(-1)\n+                Err(_) => this.handle_not_found()\n             }\n         } else {\n             this.handle_not_found()\n@@ -1135,9 +1185,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.check_no_isolation(\"fsync\")?;\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n-        if let Some(FileHandle { file, writable }) = this.machine.file_handler.handles.get(&fd) {\n-            let io_result = maybe_sync_file(file, *writable, File::sync_all);\n-            this.try_unwrap_io_result(io_result)\n+        if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n+            match file_descriptor.as_file_handle() {\n+                Ok(FileHandle { file, writable }) => {\n+                    let io_result = maybe_sync_file(&file, *writable, File::sync_all);\n+                    this.try_unwrap_io_result(io_result)\n+                }\n+                Err(_) => this.handle_not_found()\n+            }\n         } else {\n             this.handle_not_found()\n         }\n@@ -1149,9 +1204,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.check_no_isolation(\"fdatasync\")?;\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n-        if let Some(FileHandle { file, writable }) = this.machine.file_handler.handles.get(&fd) {\n-            let io_result = maybe_sync_file(file, *writable, File::sync_data);\n-            this.try_unwrap_io_result(io_result)\n+        if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n+            match file_descriptor.as_file_handle() {\n+                Ok(FileHandle { file, writable }) => {\n+                    let io_result = maybe_sync_file(&file, *writable, File::sync_data);\n+                    this.try_unwrap_io_result(io_result)\n+                }\n+                Err(_) => this.handle_not_found()\n+            }\n         } else {\n             this.handle_not_found()\n         }\n@@ -1187,9 +1247,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(-1);\n         }\n \n-        if let Some(FileHandle { file, writable }) = this.machine.file_handler.handles.get(&fd) {\n-            let io_result = maybe_sync_file(file, *writable, File::sync_data);\n-            this.try_unwrap_io_result(io_result)\n+        if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n+            match file_descriptor.as_file_handle() {\n+                Ok(FileHandle { file, writable }) => {\n+                    let io_result = maybe_sync_file(&file, *writable, File::sync_data);\n+                    this.try_unwrap_io_result(io_result)\n+                },\n+                Err(_) => this.handle_not_found()\n+            }\n         } else {\n             this.handle_not_found()\n         }\n@@ -1239,7 +1304,10 @@ impl FileMetadata {\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n         let option = ecx.machine.file_handler.handles.get(&fd);\n         let file = match option {\n-            Some(FileHandle { file, writable: _ }) => file,\n+            Some(file_descriptor) => match file_descriptor.as_file_handle() {\n+                Ok(FileHandle { file, writable: _ }) => file,\n+                Err(_) => return ecx.handle_not_found().map(|_: i32| None),\n+            },\n             None => return ecx.handle_not_found().map(|_: i32| None),\n         };\n         let metadata = file.metadata();"}]}