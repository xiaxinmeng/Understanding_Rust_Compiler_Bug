{"sha": "5e637a890ce4bf5204872f322c101aa113d2ca8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNjM3YTg5MGNlNGJmNTIwNDg3MmYzMjJjMTAxYWExMTNkMmNhOGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-07T16:54:58Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-08T01:00:47Z"}, "message": "librustc: Move block contexts into per-function arenas, and\nstack-allocate function contexts.", "tree": {"sha": "389964cd778628832df0d846d72b7c1577dffaff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/389964cd778628832df0d846d72b7c1577dffaff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e637a890ce4bf5204872f322c101aa113d2ca8c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e637a890ce4bf5204872f322c101aa113d2ca8c", "html_url": "https://github.com/rust-lang/rust/commit/5e637a890ce4bf5204872f322c101aa113d2ca8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e637a890ce4bf5204872f322c101aa113d2ca8c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7ff9c1a599eab76d25c476afc8097aab2a3d502", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7ff9c1a599eab76d25c476afc8097aab2a3d502", "html_url": "https://github.com/rust-lang/rust/commit/b7ff9c1a599eab76d25c476afc8097aab2a3d502"}], "stats": {"total": 1873, "additions": 1128, "deletions": 745}, "files": [{"sha": "c6f375bbc1b7e984e894e1d368d51d58222cccf0", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 205, "deletions": 171, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -306,12 +306,13 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     }\n }\n \n-pub enum opt_result {\n-    single_result(Result),\n-    lower_bound(Result),\n-    range_result(Result, Result),\n+pub enum opt_result<'a> {\n+    single_result(Result<'a>),\n+    lower_bound(Result<'a>),\n+    range_result(Result<'a>, Result<'a>),\n }\n-fn trans_opt(bcx: @Block, o: &Opt) -> opt_result {\n+\n+fn trans_opt<'a>(bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n     let _icx = push_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n     let bcx = bcx;\n@@ -346,8 +347,7 @@ fn trans_opt(bcx: @Block, o: &Opt) -> opt_result {\n     }\n }\n \n-fn variant_opt(bcx: @Block, pat_id: ast::NodeId)\n-    -> Opt {\n+fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n     let ccx = bcx.ccx();\n     let def_map = ccx.tcx.def_map.borrow();\n     match def_map.get().get_copy(&pat_id) {\n@@ -397,8 +397,8 @@ struct BindingInfo {\n type BindingsMap = HashMap<Ident, BindingInfo>;\n \n #[deriving(Clone)]\n-struct ArmData<'a> {\n-    bodycx: @Block,\n+struct ArmData<'a,'b> {\n+    bodycx: &'b Block<'b>,\n     arm: &'a ast::Arm,\n     bindings_map: @BindingsMap\n }\n@@ -410,13 +410,13 @@ struct ArmData<'a> {\n  * these pointers are stored in llmatch variables just before executing `data` arm.\n  */\n #[deriving(Clone)]\n-struct Match<'a> {\n+struct Match<'a,'b> {\n     pats: ~[@ast::Pat],\n-    data: ArmData<'a>,\n+    data: ArmData<'a,'b>,\n     bound_ptrs: ~[(Ident, ValueRef)]\n }\n \n-impl<'a> Repr for Match<'a> {\n+impl<'a,'b> Repr for Match<'a,'b> {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n@@ -437,11 +437,12 @@ fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-fn expand_nested_bindings<'r>(bcx: @Block,\n-                                  m: &[Match<'r>],\n-                                  col: uint,\n-                                  val: ValueRef)\n-                              -> ~[Match<'r>] {\n+fn expand_nested_bindings<'r,'b>(\n+                          bcx: &'b Block<'b>,\n+                          m: &[Match<'r,'b>],\n+                          col: uint,\n+                          val: ValueRef)\n+                          -> ~[Match<'r,'b>] {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -471,7 +472,7 @@ fn expand_nested_bindings<'r>(bcx: @Block,\n     })\n }\n \n-fn assert_is_binding_or_wild(bcx: @Block, p: @ast::Pat) {\n+fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n@@ -482,13 +483,14 @@ fn assert_is_binding_or_wild(bcx: @Block, p: @ast::Pat) {\n \n type enter_pat<'a> = 'a |@ast::Pat| -> Option<~[@ast::Pat]>;\n \n-fn enter_match<'r>(bcx: @Block,\n-                       dm: DefMap,\n-                       m: &[Match<'r>],\n-                       col: uint,\n-                       val: ValueRef,\n-                       e: enter_pat)\n-                    -> ~[Match<'r>] {\n+fn enter_match<'r,'b>(\n+               bcx: &'b Block<'b>,\n+               dm: DefMap,\n+               m: &[Match<'r,'b>],\n+               col: uint,\n+               val: ValueRef,\n+               e: enter_pat)\n+               -> ~[Match<'r,'b>] {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -531,13 +533,14 @@ fn enter_match<'r>(bcx: @Block,\n     return result;\n }\n \n-fn enter_default<'r>(bcx: @Block,\n-                     dm: DefMap,\n-                     m: &[Match<'r>],\n-                     col: uint,\n-                     val: ValueRef,\n-                     chk: FailureHandler)\n-                      -> ~[Match<'r>] {\n+fn enter_default<'r,'b>(\n+                 bcx: &'b Block<'b>,\n+                 dm: DefMap,\n+                 m: &[Match<'r,'b>],\n+                 col: uint,\n+                 val: ValueRef,\n+                 chk: &FailureHandler)\n+                 -> ~[Match<'r,'b>] {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -601,13 +604,14 @@ fn enter_default<'r>(bcx: @Block,\n // <nmatsakis> so all patterns must either be records (resp. tuples) or\n //             wildcards\n \n-fn enter_opt<'r>(bcx: @Block,\n-                     m: &[Match<'r>],\n-                     opt: &Opt,\n-                     col: uint,\n-                     variant_size: uint,\n-                     val: ValueRef)\n-                  -> ~[Match<'r>] {\n+fn enter_opt<'r,'b>(\n+             bcx: &'b Block<'b>,\n+             m: &[Match<'r,'b>],\n+             opt: &Opt,\n+             col: uint,\n+             variant_size: uint,\n+             val: ValueRef)\n+             -> ~[Match<'r,'b>] {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -744,13 +748,14 @@ fn enter_opt<'r>(bcx: @Block,\n     })\n }\n \n-fn enter_rec_or_struct<'r>(bcx: @Block,\n-                               dm: DefMap,\n-                               m: &[Match<'r>],\n-                               col: uint,\n-                               fields: &[ast::Ident],\n-                               val: ValueRef)\n-                            -> ~[Match<'r>] {\n+fn enter_rec_or_struct<'r,'b>(\n+                       bcx: &'b Block<'b>,\n+                       dm: DefMap,\n+                       m: &[Match<'r,'b>],\n+                       col: uint,\n+                       fields: &[ast::Ident],\n+                       val: ValueRef)\n+                       -> ~[Match<'r,'b>] {\n     debug!(\"enter_rec_or_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -779,13 +784,14 @@ fn enter_rec_or_struct<'r>(bcx: @Block,\n     })\n }\n \n-fn enter_tup<'r>(bcx: @Block,\n-                     dm: DefMap,\n-                     m: &[Match<'r>],\n-                     col: uint,\n-                     val: ValueRef,\n-                     n_elts: uint)\n-                  -> ~[Match<'r>] {\n+fn enter_tup<'r,'b>(\n+             bcx: &'b Block<'b>,\n+             dm: DefMap,\n+             m: &[Match<'r,'b>],\n+             col: uint,\n+             val: ValueRef,\n+             n_elts: uint)\n+             -> ~[Match<'r,'b>] {\n     debug!(\"enter_tup(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -805,13 +811,14 @@ fn enter_tup<'r>(bcx: @Block,\n     })\n }\n \n-fn enter_tuple_struct<'r>(bcx: @Block,\n-                              dm: DefMap,\n-                              m: &[Match<'r>],\n-                              col: uint,\n-                              val: ValueRef,\n-                              n_elts: uint)\n-                          -> ~[Match<'r>] {\n+fn enter_tuple_struct<'r,'b>(\n+                      bcx: &'b Block<'b>,\n+                      dm: DefMap,\n+                      m: &[Match<'r,'b>],\n+                      col: uint,\n+                      val: ValueRef,\n+                      n_elts: uint)\n+                      -> ~[Match<'r,'b>] {\n     debug!(\"enter_tuple_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -831,12 +838,13 @@ fn enter_tuple_struct<'r>(bcx: @Block,\n     })\n }\n \n-fn enter_box<'r>(bcx: @Block,\n-                     dm: DefMap,\n-                     m: &[Match<'r>],\n-                     col: uint,\n-                     val: ValueRef)\n-                 -> ~[Match<'r>] {\n+fn enter_box<'r,'b>(\n+             bcx: &'b Block<'b>,\n+             dm: DefMap,\n+             m: &[Match<'r,'b>],\n+             col: uint,\n+             val: ValueRef)\n+             -> ~[Match<'r,'b>] {\n     debug!(\"enter_box(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -858,12 +866,13 @@ fn enter_box<'r>(bcx: @Block,\n     })\n }\n \n-fn enter_uniq<'r>(bcx: @Block,\n-                      dm: DefMap,\n-                      m: &[Match<'r>],\n-                      col: uint,\n-                      val: ValueRef)\n-                  -> ~[Match<'r>] {\n+fn enter_uniq<'r,'b>(\n+              bcx: &'b Block<'b>,\n+              dm: DefMap,\n+              m: &[Match<'r,'b>],\n+              col: uint,\n+              val: ValueRef)\n+              -> ~[Match<'r,'b>] {\n     debug!(\"enter_uniq(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -885,12 +894,14 @@ fn enter_uniq<'r>(bcx: @Block,\n     })\n }\n \n-fn enter_region<'r>(bcx: @Block,\n-                        dm: DefMap,\n-                        m: &[Match<'r>],\n-                        col: uint,\n-                        val: ValueRef)\n-                    -> ~[Match<'r>] {\n+fn enter_region<'r,\n+                'b>(\n+                bcx: &'b Block<'b>,\n+                dm: DefMap,\n+                m: &[Match<'r,'b>],\n+                col: uint,\n+                val: ValueRef)\n+                -> ~[Match<'r,'b>] {\n     debug!(\"enter_region(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -915,7 +926,7 @@ fn enter_region<'r>(bcx: @Block,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-fn get_options(bcx: @Block, m: &[Match], col: uint) -> ~[Opt] {\n+fn get_options(bcx: &Block, m: &[Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n@@ -1005,16 +1016,17 @@ fn get_options(bcx: @Block, m: &[Match], col: uint) -> ~[Opt] {\n     return found;\n }\n \n-struct ExtractedBlock {\n+struct ExtractedBlock<'a> {\n     vals: ~[ValueRef],\n-    bcx: @Block\n+    bcx: &'a Block<'a>,\n }\n \n-fn extract_variant_args(bcx: @Block,\n-                            repr: &adt::Repr,\n-                            disr_val: ty::Disr,\n-                            val: ValueRef)\n-    -> ExtractedBlock {\n+fn extract_variant_args<'a>(\n+                        bcx: &'a Block<'a>,\n+                        repr: &adt::Repr,\n+                        disr_val: ty::Disr,\n+                        val: ValueRef)\n+                        -> ExtractedBlock<'a> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n     let args = vec::from_fn(adt::num_args(repr, disr_val), |i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n@@ -1023,7 +1035,8 @@ fn extract_variant_args(bcx: @Block,\n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n-fn match_datum(bcx: @Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n+fn match_datum<'a>(bcx: &'a Block<'a>, val: ValueRef, pat_id: ast::NodeId)\n+               -> Datum {\n     //! Helper for converting from the ValueRef that we pass around in\n     //! the match code, which is always by ref, into a Datum. Eventually\n     //! we should just pass around a Datum and be done with it.\n@@ -1033,14 +1046,15 @@ fn match_datum(bcx: @Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n }\n \n \n-fn extract_vec_elems(bcx: @Block,\n-                         pat_span: Span,\n-                         pat_id: ast::NodeId,\n-                         elem_count: uint,\n-                         slice: Option<uint>,\n-                         val: ValueRef,\n-                         count: ValueRef)\n-                      -> ExtractedBlock {\n+fn extract_vec_elems<'a>(\n+                     bcx: &'a Block<'a>,\n+                     pat_span: Span,\n+                     pat_id: ast::NodeId,\n+                     elem_count: uint,\n+                     slice: Option<uint>,\n+                     val: ValueRef,\n+                     count: ValueRef)\n+                     -> ExtractedBlock<'a> {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(bcx, val, pat_id);\n     let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span, pat_id, 0);\n@@ -1086,10 +1100,11 @@ fn extract_vec_elems(bcx: @Block,\n /// Function returns None if there is no struct pattern.\n /// Function doesn't collect fields from struct-like enum variants.\n /// Function can return empty list if there is only wildcard struct pattern.\n-fn collect_record_or_struct_fields(bcx: @Block,\n-                                       m: &[Match],\n-                                       col: uint)\n-                                    -> Option<~[ast::Ident]> {\n+fn collect_record_or_struct_fields<'a>(\n+                                   bcx: &'a Block<'a>,\n+                                   m: &[Match],\n+                                   col: uint)\n+                                   -> Option<~[ast::Ident]> {\n     let mut fields: ~[ast::Ident] = ~[];\n     let mut found = false;\n     for br in m.iter() {\n@@ -1122,10 +1137,7 @@ fn collect_record_or_struct_fields(bcx: @Block,\n     }\n }\n \n-fn pats_require_rooting(bcx: @Block,\n-                            m: &[Match],\n-                            col: uint)\n-                         -> bool {\n+fn pats_require_rooting(bcx: &Block, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n         let pat_id = br.pats[col].id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n@@ -1134,11 +1146,12 @@ fn pats_require_rooting(bcx: @Block,\n     })\n }\n \n-fn root_pats_as_necessary(mut bcx: @Block,\n-                              m: &[Match],\n-                              col: uint,\n-                              val: ValueRef)\n-                           -> @Block {\n+fn root_pats_as_necessary<'r,'b>(\n+                          mut bcx: &'b Block<'b>,\n+                          m: &[Match<'r,'b>],\n+                          col: uint,\n+                          val: ValueRef)\n+                          -> &'b Block<'b> {\n     for br in m.iter() {\n         let pat_id = br.pats[col].id;\n         if pat_id != 0 {\n@@ -1181,7 +1194,7 @@ fn any_tup_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::PatTup(_))\n }\n \n-fn any_tuple_struct_pat(bcx: @Block, m: &[Match], col: uint) -> bool {\n+fn any_tuple_struct_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n         let pat = br.pats[col];\n         match pat.node {\n@@ -1198,18 +1211,14 @@ fn any_tuple_struct_pat(bcx: @Block, m: &[Match], col: uint) -> bool {\n     })\n }\n \n-trait CustomFailureHandler {\n-    fn handle_fail(&self) -> BasicBlockRef;\n-}\n-\n-struct DynamicFailureHandler {\n-    bcx: @Block,\n+struct DynamicFailureHandler<'a> {\n+    bcx: &'a Block<'a>,\n     sp: Span,\n     msg: @str,\n     finished: @Cell<Option<BasicBlockRef>>,\n }\n \n-impl CustomFailureHandler for DynamicFailureHandler {\n+impl<'a> DynamicFailureHandler<'a> {\n     fn handle_fail(&self) -> BasicBlockRef {\n         match self.finished.get() {\n             Some(bb) => return bb,\n@@ -1224,13 +1233,13 @@ impl CustomFailureHandler for DynamicFailureHandler {\n }\n \n /// What to do when the pattern match fails.\n-enum FailureHandler {\n+enum FailureHandler<'a> {\n     Infallible,\n     JumpToBasicBlock(BasicBlockRef),\n-    CustomFailureHandlerClass(@CustomFailureHandler),\n+    DynamicFailureHandlerClass(~DynamicFailureHandler<'a>),\n }\n \n-impl FailureHandler {\n+impl<'a> FailureHandler<'a> {\n     fn is_infallible(&self) -> bool {\n         match *self {\n             Infallible => true,\n@@ -1248,8 +1257,8 @@ impl FailureHandler {\n                 fail!(\"attempted to fail in infallible failure handler!\")\n             }\n             JumpToBasicBlock(basic_block) => basic_block,\n-            CustomFailureHandlerClass(custom_failure_handler) => {\n-                custom_failure_handler.handle_fail()\n+            DynamicFailureHandlerClass(ref dynamic_failure_handler) => {\n+                dynamic_failure_handler.handle_fail()\n             }\n         }\n     }\n@@ -1290,11 +1299,12 @@ pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n // Compiles a comparison between two things.\n //\n // NB: This must produce an i1, not a Rust bool (i8).\n-fn compare_values(cx: @Block,\n-                      lhs: ValueRef,\n-                      rhs: ValueRef,\n-                      rhs_t: ty::t)\n-                   -> Result {\n+fn compare_values<'a>(\n+                  cx: &'a Block<'a>,\n+                  lhs: ValueRef,\n+                  rhs: ValueRef,\n+                  rhs_t: ty::t)\n+                  -> Result<'a> {\n     let _icx = push_ctxt(\"compare_values\");\n     if ty::type_is_scalar(rhs_t) {\n       let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq);\n@@ -1333,11 +1343,11 @@ fn compare_values(cx: @Block,\n     }\n }\n \n-fn store_non_ref_bindings(bcx: @Block,\n+fn store_non_ref_bindings<'a>(\n+                          bcx: &'a Block<'a>,\n                           bindings_map: &BindingsMap,\n                           mut opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n-                          -> @Block\n-{\n+                          -> &'a Block<'a> {\n     /*!\n      *\n      * For each copy/move binding, copy the value from the value\n@@ -1367,9 +1377,11 @@ fn store_non_ref_bindings(bcx: @Block,\n     return bcx;\n }\n \n-fn insert_lllocals(bcx: @Block,\n+fn insert_lllocals<'a>(\n+                   bcx: &'a Block<'a>,\n                    bindings_map: &BindingsMap,\n-                   add_cleans: bool) -> @Block {\n+                   add_cleans: bool)\n+                   -> &'a Block<'a> {\n     /*!\n      * For each binding in `data.bindings_map`, adds an appropriate entry into\n      * the `fcx.lllocals` map.  If add_cleans is true, then adds cleanups for\n@@ -1413,13 +1425,15 @@ fn insert_lllocals(bcx: @Block,\n     return bcx;\n }\n \n-fn compile_guard(bcx: @Block,\n-                     guard_expr: &ast::Expr,\n-                     data: &ArmData,\n-                     m: &[Match],\n-                     vals: &[ValueRef],\n-                     chk: FailureHandler)\n-                  -> @Block {\n+fn compile_guard<'r,\n+                 'b>(\n+                 bcx: &'b Block<'b>,\n+                 guard_expr: &ast::Expr,\n+                 data: &ArmData,\n+                 m: &[Match<'r,'b>],\n+                 vals: &[ValueRef],\n+                 chk: &FailureHandler)\n+                 -> &'b Block<'b> {\n     debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n            bcx.expr_to_str(guard_expr),\n@@ -1454,7 +1468,8 @@ fn compile_guard(bcx: @Block,\n         bcx\n     });\n \n-    fn drop_bindings(bcx: @Block, data: &ArmData) -> @Block {\n+    fn drop_bindings<'a>(bcx: &'a Block<'a>, data: &ArmData)\n+                     -> &'a Block<'a> {\n         let mut bcx = bcx;\n         for (_, &binding_info) in data.bindings_map.iter() {\n             match binding_info.trmode {\n@@ -1470,10 +1485,12 @@ fn compile_guard(bcx: @Block,\n     }\n }\n \n-fn compile_submatch(bcx: @Block,\n-                    m: &[Match],\n+fn compile_submatch<'r,\n+                    'b>(\n+                    bcx: &'b Block<'b>,\n+                    m: &[Match<'r,'b>],\n                     vals: &[ValueRef],\n-                    chk: FailureHandler) {\n+                    chk: &FailureHandler) {\n     debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -1522,10 +1539,12 @@ fn compile_submatch(bcx: @Block,\n     }\n }\n \n-fn compile_submatch_continue(mut bcx: @Block,\n-                             m: &[Match],\n+fn compile_submatch_continue<'r,\n+                             'b>(\n+                             mut bcx: &'b Block<'b>,\n+                             m: &[Match<'r,'b>],\n                              vals: &[ValueRef],\n-                             chk: FailureHandler,\n+                             chk: &FailureHandler,\n                              col: uint,\n                              val: ValueRef) {\n     let tcx = bcx.tcx();\n@@ -1695,7 +1714,7 @@ fn compile_submatch_continue(mut bcx: @Block,\n         // the failure case so that instead of failing, it proceeds to\n         // try more matching. branch_chk, then, is the proper failure case\n         // for the current conditional branch.\n-        let mut branch_chk = chk;\n+        let mut branch_chk = None;\n         let mut opt_cx = else_cx;\n         if !exhaustive || i+1 < len {\n             opt_cx = sub_block(bcx, \"match_case\");\n@@ -1791,7 +1810,7 @@ fn compile_submatch_continue(mut bcx: @Block,\n \n                   // If none of these subcases match, move on to the\n                   // next condition.\n-                  branch_chk = JumpToBasicBlock(bcx.llbb);\n+                  branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               _ => ()\n@@ -1825,7 +1844,13 @@ fn compile_submatch_continue(mut bcx: @Block,\n         }\n         let opt_ms = enter_opt(opt_cx, m, opt, col, size, val);\n         let opt_vals = vec::append(unpacked, vals_left);\n-        compile_submatch(opt_cx, opt_ms, opt_vals, branch_chk);\n+\n+        match branch_chk {\n+            None => compile_submatch(opt_cx, opt_ms, opt_vals, chk),\n+            Some(branch_chk) => {\n+                compile_submatch(opt_cx, opt_ms, opt_vals, &branch_chk)\n+            }\n+        }\n     }\n \n     // Compile the fall-through case, if any\n@@ -1839,18 +1864,20 @@ fn compile_submatch_continue(mut bcx: @Block,\n     }\n }\n \n-pub fn trans_match(bcx: @Block,\n+pub fn trans_match<'a>(\n+                   bcx: &'a Block<'a>,\n                    match_expr: &ast::Expr,\n                    discr_expr: &ast::Expr,\n                    arms: &[ast::Arm],\n-                   dest: Dest) -> @Block {\n+                   dest: Dest)\n+                   -> &'a Block<'a> {\n     let _icx = push_ctxt(\"match::trans_match\");\n     with_scope(bcx, match_expr.info(), \"match\", |bcx| {\n         trans_match_inner(bcx, discr_expr, arms, dest)\n     })\n }\n \n-fn create_bindings_map(bcx: @Block, pat: @ast::Pat) -> BindingsMap {\n+fn create_bindings_map(bcx: &Block, pat: @ast::Pat) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n     // Note that we use the names because each binding will have many ids\n@@ -1890,10 +1917,12 @@ fn create_bindings_map(bcx: @Block, pat: @ast::Pat) -> BindingsMap {\n     return bindings_map;\n }\n \n-fn trans_match_inner(scope_cx: @Block,\n-                         discr_expr: &ast::Expr,\n-                         arms: &[ast::Arm],\n-                         dest: Dest) -> @Block {\n+fn trans_match_inner<'a>(\n+                     scope_cx: &'a Block<'a>,\n+                     discr_expr: &ast::Expr,\n+                     arms: &[ast::Arm],\n+                     dest: Dest)\n+                     -> &'a Block<'a> {\n     let _icx = push_ctxt(\"match::trans_match_inner\");\n     let mut bcx = scope_cx;\n     let tcx = bcx.tcx();\n@@ -1930,19 +1959,19 @@ fn trans_match_inner(scope_cx: @Block,\n         if ty::type_is_empty(tcx, t) {\n             // Special case for empty types\n             let fail_cx = @Cell::new(None);\n-            let fail_handler = @DynamicFailureHandler {\n+            let fail_handler = ~DynamicFailureHandler {\n                 bcx: scope_cx,\n                 sp: discr_expr.span,\n                 msg: @\"scrutinizing value that can't exist\",\n                 finished: fail_cx,\n-            } as @CustomFailureHandler;\n-            CustomFailureHandlerClass(fail_handler)\n+            };\n+            DynamicFailureHandlerClass(fail_handler)\n         } else {\n             Infallible\n         }\n     };\n     let lldiscr = discr_datum.to_ref_llval(bcx);\n-    compile_submatch(bcx, matches, [lldiscr], chk);\n+    compile_submatch(bcx, matches, [lldiscr], &chk);\n \n     let mut arm_cxs = ~[];\n     for arm_data in arm_datas.iter() {\n@@ -1975,10 +2004,11 @@ enum IrrefutablePatternBindingMode {\n     BindArgument\n }\n \n-pub fn store_local(bcx: @Block,\n+pub fn store_local<'a>(\n+                   bcx: &'a Block<'a>,\n                    pat: @ast::Pat,\n                    opt_init_expr: Option<@ast::Expr>)\n-                   -> @Block {\n+                   -> &'a Block<'a> {\n     /*!\n      * Generates code for a local variable declaration like\n      * `let <pat>;` or `let <pat> = <opt_init_expr>`.\n@@ -2029,7 +2059,8 @@ pub fn store_local(bcx: @Block,\n         }\n     };\n \n-    fn create_dummy_locals(mut bcx: @Block, pat: @ast::Pat) -> @Block {\n+    fn create_dummy_locals<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat)\n+                           -> &'a Block<'a> {\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n@@ -2042,10 +2073,8 @@ pub fn store_local(bcx: @Block,\n     }\n }\n \n-pub fn store_arg(mut bcx: @Block,\n-                 pat: @ast::Pat,\n-                 llval: ValueRef)\n-                 -> @Block {\n+pub fn store_arg<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat, llval: ValueRef)\n+                 -> &'a Block<'a> {\n     /*!\n      * Generates code for argument patterns like `fn foo(<pat>: T)`.\n      * Creates entries in the `llargs` map for each of the bindings\n@@ -2090,12 +2119,16 @@ pub fn store_arg(mut bcx: @Block,\n     return bcx;\n }\n \n-fn mk_binding_alloca(mut bcx: @Block,\n+fn mk_binding_alloca<'a>(\n+                     mut bcx: &'a Block<'a>,\n                      p_id: ast::NodeId,\n                      path: &ast::Path,\n                      binding_mode: IrrefutablePatternBindingMode,\n-                     populate: |@Block, ty::t, ValueRef| -> @Block)\n-                     -> @Block {\n+                     populate: |&'a Block<'a>,\n+                                ty::t,\n+                                ValueRef|\n+                                -> &'a Block<'a>)\n+                     -> &'a Block<'a> {\n     let var_ty = node_id_type(bcx, p_id);\n     let ident = ast_util::path_to_ident(path);\n     let llval = alloc_ty(bcx, var_ty, bcx.ident(ident));\n@@ -2109,11 +2142,12 @@ fn mk_binding_alloca(mut bcx: @Block,\n     return bcx;\n }\n \n-fn bind_irrefutable_pat(bcx: @Block,\n+fn bind_irrefutable_pat<'a>(\n+                        bcx: &'a Block<'a>,\n                         pat: @ast::Pat,\n                         val: ValueRef,\n                         binding_mode: IrrefutablePatternBindingMode)\n-                        -> @Block {\n+                        -> &'a Block<'a> {\n     /*!\n      * A simple version of the pattern matching code that only handles\n      * irrefutable patterns. This is used in let/argument patterns,"}, {"sha": "296a99423c0928cdce32600c96fc1236248e36e9", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -111,7 +111,7 @@ pub struct Struct {\n  * these, for places in trans where the `ty::t` isn't directly\n  * available.\n  */\n-pub fn represent_node(bcx: @Block, node: ast::NodeId) -> @Repr {\n+pub fn represent_node(bcx: &Block, node: ast::NodeId) -> @Repr {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n@@ -463,7 +463,7 @@ fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool) -> ~[Type] {\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_switch(bcx: @Block, r: &Repr, scrutinee: ValueRef)\n+pub fn trans_switch(bcx: &Block, r: &Repr, scrutinee: ValueRef)\n     -> (_match::branch_kind, Option<ValueRef>) {\n     match *r {\n         CEnum(..) | General(..) => {\n@@ -481,7 +481,7 @@ pub fn trans_switch(bcx: @Block, r: &Repr, scrutinee: ValueRef)\n \n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr(bcx: @Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n+pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n     -> ValueRef {\n     let signed;\n     let val;\n@@ -510,7 +510,7 @@ pub fn trans_get_discr(bcx: @Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n     }\n }\n \n-fn nullable_bitdiscr(bcx: @Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n+fn nullable_bitdiscr(bcx: &Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uint,\n                      scrutinee: ValueRef) -> ValueRef {\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n@@ -519,7 +519,7 @@ fn nullable_bitdiscr(bcx: @Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uin\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: @Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n+fn load_discr(bcx: &Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     -> ValueRef {\n     let llty = ll_inttype(bcx.ccx(), ity);\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n@@ -547,7 +547,8 @@ fn load_discr(bcx: @Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_case(bcx: @Block, r: &Repr, discr: Disr) -> _match::opt_result {\n+pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n+                  -> _match::opt_result<'a> {\n     match *r {\n         CEnum(ity, _, _) => {\n             _match::single_result(rslt(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n@@ -572,7 +573,7 @@ pub fn trans_case(bcx: @Block, r: &Repr, discr: Disr) -> _match::opt_result {\n  * representation.  The fields, if any, should then be initialized via\n  * `trans_field_ptr`.\n  */\n-pub fn trans_start_init(bcx: @Block, r: &Repr, val: ValueRef, discr: Disr) {\n+pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n     match *r {\n         CEnum(ity, min, max) => {\n             assert_discr_in_range(ity, min, max, discr);\n@@ -628,7 +629,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr(bcx: @Block, r: &Repr, val: ValueRef, discr: Disr,\n+pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n                        ix: uint) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n@@ -661,7 +662,7 @@ pub fn trans_field_ptr(bcx: @Block, r: &Repr, val: ValueRef, discr: Disr,\n     }\n }\n \n-fn struct_field_ptr(bcx: @Block, st: &Struct, val: ValueRef, ix: uint,\n+fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef, ix: uint,\n               needs_cast: bool) -> ValueRef {\n     let ccx = bcx.ccx();\n \n@@ -677,7 +678,7 @@ fn struct_field_ptr(bcx: @Block, st: &Struct, val: ValueRef, ix: uint,\n }\n \n /// Access the struct drop flag, if present.\n-pub fn trans_drop_flag_ptr(bcx: @Block, r: &Repr, val: ValueRef) -> ValueRef {\n+pub fn trans_drop_flag_ptr(bcx: &Block, r: &Repr, val: ValueRef) -> ValueRef {\n     match *r {\n         Univariant(ref st, true) => GEPi(bcx, val, [0, st.fields.len() - 1]),\n         _ => bcx.ccx().sess.bug(\"tried to get drop flag of non-droppable type\")"}, {"sha": "974ef9cf99d4da408fdf9ee5d71658daca19eb46", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -27,8 +27,8 @@ use middle::trans::type_::Type;\n use syntax::ast;\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn trans_inline_asm(bcx: @Block, ia: &ast::inline_asm) -> @Block {\n-\n+pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::inline_asm)\n+                        -> &'a Block<'a> {\n     let mut bcx = bcx;\n     let mut constraints = ~[];\n     let mut cleanups = ~[];"}, {"sha": "9730d664189f64698a6b6d914f941eb21ede2081", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 251, "deletions": 152, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -68,13 +68,14 @@ use util::ppaux::{Repr, ty_to_str};\n use util::sha2::Sha256;\n use middle::trans::type_::Type;\n \n+use extra::arena::TypedArena;\n+use extra::time;\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::libc::c_uint;\n use std::vec;\n use std::local_data;\n-use extra::time;\n use syntax::ast::Name;\n use syntax::ast_map::{path, path_elt_to_str, path_name, path_pretty_name};\n use syntax::ast_util::{local_def, is_local};\n@@ -307,9 +308,8 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n // known.\n //\n // The runtime equivalent is box_body() in \"rust_internal.h\".\n-pub fn opaque_box_body(bcx: @Block,\n-                       body_t: ty::t,\n-                       boxptr: ValueRef) -> ValueRef {\n+pub fn opaque_box_body(bcx: &Block, body_t: ty::t, boxptr: ValueRef)\n+                       -> ValueRef {\n     let _icx = push_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let ty = type_of(ccx, body_t);\n@@ -320,14 +320,16 @@ pub fn opaque_box_body(bcx: @Block,\n \n // malloc_raw_dyn: allocates a box to contain a given type, but with a\n // potentially dynamic size.\n-pub fn malloc_raw_dyn(bcx: @Block,\n+pub fn malloc_raw_dyn<'a>(\n+                      bcx: &'a Block,\n                       t: ty::t,\n                       heap: heap,\n-                      size: ValueRef) -> Result {\n+                      size: ValueRef)\n+                      -> Result<'a> {\n     let _icx = push_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n-    fn require_alloc_fn(bcx: @Block, t: ty::t, it: LangItem) -> ast::DefId {\n+    fn require_alloc_fn(bcx: &Block, t: ty::t, it: LangItem) -> ast::DefId {\n         let li = &bcx.tcx().lang_items;\n         match li.require(it) {\n             Ok(id) => id,\n@@ -387,22 +389,27 @@ pub fn malloc_raw_dyn(bcx: @Block,\n // malloc_raw: expects an unboxed type and returns a pointer to\n // enough space for a box of that type.  This includes a rust_opaque_box\n // header.\n-pub fn malloc_raw(bcx: @Block, t: ty::t, heap: heap) -> Result {\n+pub fn malloc_raw<'a>(bcx: &'a Block<'a>, t: ty::t, heap: heap)\n+                  -> Result<'a> {\n     let ty = type_of(bcx.ccx(), t);\n     let size = llsize_of(bcx.ccx(), ty);\n     malloc_raw_dyn(bcx, t, heap, size)\n }\n \n-pub struct MallocResult {\n-    bcx: @Block,\n+pub struct MallocResult<'a> {\n+    bcx: &'a Block<'a>,\n     smart_ptr: ValueRef,\n     body: ValueRef\n }\n \n // malloc_general_dyn: usefully wraps malloc_raw_dyn; allocates a smart\n // pointer, and pulls out the body\n-pub fn malloc_general_dyn(bcx: @Block, t: ty::t, heap: heap, size: ValueRef)\n-    -> MallocResult {\n+pub fn malloc_general_dyn<'a>(\n+                          bcx: &'a Block<'a>,\n+                          t: ty::t,\n+                          heap: heap,\n+                          size: ValueRef)\n+                          -> MallocResult<'a> {\n     assert!(heap != heap_exchange);\n     let _icx = push_ctxt(\"malloc_general\");\n     let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n@@ -415,21 +422,22 @@ pub fn malloc_general_dyn(bcx: @Block, t: ty::t, heap: heap, size: ValueRef)\n     }\n }\n \n-pub fn malloc_general(bcx: @Block, t: ty::t, heap: heap) -> MallocResult {\n+pub fn malloc_general<'a>(bcx: &'a Block, t: ty::t, heap: heap)\n+                      -> MallocResult<'a> {\n     let ty = type_of(bcx.ccx(), t);\n     assert!(heap != heap_exchange);\n     malloc_general_dyn(bcx, t, heap, llsize_of(bcx.ccx(), ty))\n }\n \n-pub fn heap_for_unique(bcx: @Block, t: ty::t) -> heap {\n+pub fn heap_for_unique(bcx: &Block, t: ty::t) -> heap {\n     if ty::type_contents(bcx.tcx(), t).owns_managed() {\n         heap_managed_unique\n     } else {\n         heap_exchange\n     }\n }\n \n-pub fn maybe_set_managed_unique_rc(bcx: @Block, bx: ValueRef, heap: heap) {\n+pub fn maybe_set_managed_unique_rc(bcx: &Block, bx: ValueRef, heap: heap) {\n     assert!(heap != heap_exchange);\n     if heap == heap_managed_unique {\n         // In cases where we are looking at a unique-typed allocation in the\n@@ -597,12 +605,13 @@ pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n // NB: This produces an i1, not a Rust bool (i8).\n-pub fn compare_scalar_types(cx: @Block,\n+pub fn compare_scalar_types<'a>(\n+                            cx: &'a Block<'a>,\n                             lhs: ValueRef,\n                             rhs: ValueRef,\n                             t: ty::t,\n                             op: ast::BinOp)\n-                         -> Result {\n+                            -> Result<'a> {\n     let f = |a| compare_scalar_values(cx, lhs, rhs, a, op);\n \n     match ty::get(t).sty {\n@@ -629,14 +638,15 @@ pub fn compare_scalar_types(cx: @Block,\n \n \n // A helper function to do the actual comparison of scalar values.\n-pub fn compare_scalar_values(cx: @Block,\n+pub fn compare_scalar_values<'a>(\n+                             cx: &'a Block<'a>,\n                              lhs: ValueRef,\n                              rhs: ValueRef,\n                              nt: scalar_type,\n                              op: ast::BinOp)\n-                          -> ValueRef {\n+                             -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n-    fn die(cx: @Block) -> ! {\n+    fn die(cx: &Block) -> ! {\n         cx.tcx().sess.bug(\"compare_scalar_values: must be a\\\n                            comparison operator\");\n     }\n@@ -690,25 +700,41 @@ pub fn compare_scalar_values(cx: @Block,\n     }\n }\n \n-pub type val_and_ty_fn<'a> = 'a |@Block, ValueRef, ty::t|\n-                                       -> @Block;\n+pub type val_and_ty_fn<'r,'b> =\n+    'r |&'b Block<'b>, ValueRef, ty::t| -> &'b Block<'b>;\n \n-pub fn load_inbounds(cx: @Block, p: ValueRef, idxs: &[uint]) -> ValueRef {\n+pub fn load_inbounds<'a>(cx: &'a Block<'a>, p: ValueRef, idxs: &[uint])\n+                     -> ValueRef {\n     return Load(cx, GEPi(cx, p, idxs));\n }\n \n-pub fn store_inbounds(cx: @Block, v: ValueRef, p: ValueRef, idxs: &[uint]) {\n+pub fn store_inbounds<'a>(\n+                      cx: &'a Block<'a>,\n+                      v: ValueRef,\n+                      p: ValueRef,\n+                      idxs: &[uint]) {\n     Store(cx, v, GEPi(cx, p, idxs));\n }\n \n // Iterates through the elements of a structural type.\n-pub fn iter_structural_ty(cx: @Block, av: ValueRef, t: ty::t,\n-                          f: val_and_ty_fn) -> @Block {\n+pub fn iter_structural_ty<'r,\n+                          'b>(\n+                          cx: &'b Block<'b>,\n+                          av: ValueRef,\n+                          t: ty::t,\n+                          f: val_and_ty_fn<'r,'b>)\n+                          -> &'b Block<'b> {\n     let _icx = push_ctxt(\"iter_structural_ty\");\n \n-    fn iter_variant(cx: @Block, repr: &adt::Repr, av: ValueRef,\n+    fn iter_variant<'r,\n+                    'b>(\n+                    cx: &'b Block<'b>,\n+                    repr: &adt::Repr,\n+                    av: ValueRef,\n                     variant: @ty::VariantInfo,\n-                    tps: &[ty::t], f: val_and_ty_fn) -> @Block {\n+                    tps: &[ty::t],\n+                    f: val_and_ty_fn<'r,'b>)\n+                    -> &'b Block<'b> {\n         let _icx = push_ctxt(\"iter_variant\");\n         let tcx = cx.tcx();\n         let mut cx = cx;\n@@ -794,8 +820,12 @@ pub fn iter_structural_ty(cx: @Block, av: ValueRef, t: ty::t,\n     return cx;\n }\n \n-pub fn cast_shift_expr_rhs(cx: @Block, op: ast::BinOp,\n-                           lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn cast_shift_expr_rhs<'a>(\n+                           cx: &'a Block<'a>,\n+                           op: ast::BinOp,\n+                           lhs: ValueRef,\n+                           rhs: ValueRef)\n+                           -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n                    |a,b| Trunc(cx, a, b),\n                    |a,b| ZExt(cx, a, b))\n@@ -836,8 +866,13 @@ pub fn cast_shift_rhs(op: ast::BinOp,\n     }\n }\n \n-pub fn fail_if_zero(cx: @Block, span: Span, divrem: ast::BinOp,\n-                    rhs: ValueRef, rhs_t: ty::t) -> @Block {\n+pub fn fail_if_zero<'a>(\n+                    cx: &'a Block<'a>,\n+                    span: Span,\n+                    divrem: ast::BinOp,\n+                    rhs: ValueRef,\n+                    rhs_t: ty::t)\n+                    -> &'a Block<'a> {\n     let text = if divrem == ast::BiDiv {\n         @\"attempted to divide by zero\"\n     } else {\n@@ -895,12 +930,13 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n     }\n }\n \n-pub fn invoke(bcx: @Block,\n+pub fn invoke<'a>(\n+              bcx: &'a Block<'a>,\n               llfn: ValueRef,\n               llargs: ~[ValueRef],\n               attributes: &[(uint, lib::llvm::Attribute)],\n               call_info: Option<NodeInfo>)\n-           -> (ValueRef, @Block) {\n+              -> (ValueRef, &'a Block<'a>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n         return (C_null(Type::i8()), bcx);\n@@ -954,7 +990,7 @@ pub fn invoke(bcx: @Block,\n     }\n }\n \n-pub fn need_invoke(bcx: @Block) -> bool {\n+pub fn need_invoke(bcx: &Block) -> bool {\n     if bcx.ccx().sess.no_landing_pads() {\n         return false;\n     }\n@@ -997,7 +1033,7 @@ pub fn need_invoke(bcx: @Block) -> bool {\n     }\n }\n \n-pub fn have_cached_lpad(bcx: @Block) -> bool {\n+pub fn have_cached_lpad(bcx: &Block) -> bool {\n     let mut res = false;\n     in_lpad_scope_cx(bcx, |inf| {\n         match inf.landing_pad.get() {\n@@ -1008,7 +1044,7 @@ pub fn have_cached_lpad(bcx: @Block) -> bool {\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: @Block, f: |si: &ScopeInfo|) {\n+pub fn in_lpad_scope_cx<'a>(bcx: &'a Block<'a>, f: |si: &'a ScopeInfo<'a>|) {\n     let mut bcx = bcx;\n     let mut cur_scope = bcx.scope.get();\n     loop {\n@@ -1028,7 +1064,7 @@ pub fn in_lpad_scope_cx(bcx: @Block, f: |si: &ScopeInfo|) {\n     }\n }\n \n-pub fn get_landing_pad(bcx: @Block) -> BasicBlockRef {\n+pub fn get_landing_pad<'a>(bcx: &'a Block<'a>) -> BasicBlockRef {\n     let _icx = push_ctxt(\"get_landing_pad\");\n \n     let mut cached = None;\n@@ -1074,7 +1110,8 @@ pub fn get_landing_pad(bcx: @Block) -> BasicBlockRef {\n     return pad_bcx.llbb;\n }\n \n-pub fn find_bcx_for_scope(bcx: @Block, scope_id: ast::NodeId) -> @Block {\n+pub fn find_bcx_for_scope<'a>(bcx: &'a Block<'a>, scope_id: ast::NodeId)\n+                          -> &'a Block<'a> {\n     let mut bcx_sid = bcx;\n     let mut cur_scope = bcx_sid.scope.get();\n     loop {\n@@ -1103,7 +1140,7 @@ pub fn find_bcx_for_scope(bcx: @Block, scope_id: ast::NodeId) -> @Block {\n }\n \n \n-pub fn do_spill(bcx: @Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn do_spill(bcx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n         return C_null(Type::i8p());\n     }\n@@ -1114,31 +1151,32 @@ pub fn do_spill(bcx: @Block, v: ValueRef, t: ty::t) -> ValueRef {\n \n // Since this function does *not* root, it is the caller's responsibility to\n // ensure that the referent is pointed to by a root.\n-pub fn do_spill_noroot(cx: @Block, v: ValueRef) -> ValueRef {\n+pub fn do_spill_noroot(cx: &Block, v: ValueRef) -> ValueRef {\n     let llptr = alloca(cx, val_ty(v), \"\");\n     Store(cx, v, llptr);\n     return llptr;\n }\n \n-pub fn spill_if_immediate(cx: @Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn spill_if_immediate(cx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"spill_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return do_spill(cx, v, t); }\n     return v;\n }\n \n-pub fn load_if_immediate(cx: @Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_if_immediate(cx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return Load(cx, v); }\n     return v;\n }\n \n-pub fn ignore_lhs(_bcx: @Block, local: &ast::Local) -> bool {\n+pub fn ignore_lhs(_bcx: &Block, local: &ast::Local) -> bool {\n     match local.pat.node {\n         ast::PatWild => true, _ => false\n     }\n }\n \n-pub fn init_local(bcx: @Block, local: &ast::Local) -> @Block {\n+pub fn init_local<'a>(bcx: &'a Block<'a>, local: &ast::Local)\n+                  -> &'a Block<'a> {\n \n     debug!(\"init_local(bcx={}, local.id={:?})\",\n            bcx.to_str(), local.id);\n@@ -1159,7 +1197,7 @@ pub fn init_local(bcx: @Block, local: &ast::Local) -> @Block {\n     _match::store_local(bcx, local.pat, local.init)\n }\n \n-pub fn trans_stmt(cx: @Block, s: &ast::Stmt) -> @Block {\n+pub fn trans_stmt<'a>(cx: &'a Block<'a>, s: &ast::Stmt) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_stmt\");\n     debug!(\"trans_stmt({})\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n@@ -1192,22 +1230,19 @@ pub fn trans_stmt(cx: @Block, s: &ast::Stmt) -> @Block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-pub fn new_block(cx: @FunctionContext,\n-                 parent: Option<@Block>,\n-                 scope: Option<@ScopeInfo>,\n+pub fn new_block<'a>(\n+                 cx: &'a FunctionContext<'a>,\n+                 parent: Option<&'a Block<'a>>,\n+                 scope: Option<&'a ScopeInfo<'a>>,\n                  is_lpad: bool,\n                  name: &str,\n                  opt_node_info: Option<NodeInfo>)\n-              -> @Block {\n+                 -> &'a Block<'a> {\n     unsafe {\n         let llbb = name.with_c_str(|buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx.ccx.llcx, cx.llfn, buf)\n         });\n-        let bcx = @Block::new(llbb,\n-                                  parent,\n-                                  is_lpad,\n-                                  opt_node_info,\n-                                  cx);\n+        let bcx = Block::new(llbb, parent, is_lpad, opt_node_info, cx);\n         bcx.scope.set(scope);\n         for cx in parent.iter() {\n             if cx.unreachable.get() {\n@@ -1219,62 +1254,87 @@ pub fn new_block(cx: @FunctionContext,\n     }\n }\n \n-pub fn simple_block_scope(parent: Option<@ScopeInfo>,\n+pub fn simple_block_scope<'a>(\n+                          fcx: &'a FunctionContext<'a>,\n+                          parent: Option<&'a ScopeInfo<'a>>,\n                           node_info: Option<NodeInfo>)\n-                          -> @ScopeInfo {\n-    @ScopeInfo {\n+                          -> &'a ScopeInfo<'a> {\n+    fcx.scope_info_arena.alloc(ScopeInfo {\n         parent: parent,\n         loop_break: None,\n         loop_label: None,\n         cleanups: RefCell::new(~[]),\n         cleanup_paths: RefCell::new(~[]),\n         landing_pad: Cell::new(None),\n         node_info: node_info,\n-    }\n+    })\n }\n \n // Use this when you're at the top block of a function or the like.\n-pub fn top_scope_block(fcx: @FunctionContext, opt_node_info: Option<NodeInfo>)\n-                    -> @Block {\n-    return new_block(fcx, None, Some(simple_block_scope(None, opt_node_info)), false,\n-                  \"function top level\", opt_node_info);\n-}\n-\n-pub fn scope_block(bcx: @Block,\n+pub fn top_scope_block<'a>(\n+                       fcx: &'a FunctionContext<'a>,\n+                       opt_node_info: Option<NodeInfo>)\n+                       -> &'a Block<'a> {\n+    new_block(fcx,\n+              None,\n+              Some(simple_block_scope(fcx, None, opt_node_info)),\n+              false,\n+              \"function top level\",\n+              opt_node_info)\n+}\n+\n+pub fn scope_block<'a>(\n+                   bcx: &'a Block<'a>,\n                    opt_node_info: Option<NodeInfo>,\n-                   n: &str) -> @Block {\n-    return new_block(bcx.fcx, Some(bcx), Some(simple_block_scope(None, opt_node_info)), bcx.is_lpad,\n-                  n, opt_node_info);\n-}\n-\n-pub fn loop_scope_block(bcx: @Block,\n-                        loop_break: @Block,\n+                   n: &str)\n+                   -> &'a Block<'a> {\n+    new_block(bcx.fcx,\n+              Some(bcx),\n+              Some(simple_block_scope(bcx.fcx, None, opt_node_info)),\n+              bcx.is_lpad,\n+              n,\n+              opt_node_info)\n+}\n+\n+pub fn loop_scope_block<'a>(\n+                        bcx: &'a Block<'a>,\n+                        loop_break: &'a Block<'a>,\n                         loop_label: Option<Name>,\n                         n: &str,\n-                        opt_node_info: Option<NodeInfo>) -> @Block {\n-    return new_block(bcx.fcx, Some(bcx), Some(@ScopeInfo {\n-        parent: None,\n-        loop_break: Some(loop_break),\n-        loop_label: loop_label,\n-        cleanups: RefCell::new(~[]),\n-        cleanup_paths: RefCell::new(~[]),\n-        landing_pad: Cell::new(None),\n-        node_info: opt_node_info,\n-    }), bcx.is_lpad, n, opt_node_info);\n+                        opt_node_info: Option<NodeInfo>)\n+                        -> &'a Block<'a> {\n+    new_block(bcx.fcx,\n+              Some(bcx),\n+              Some(bcx.fcx.scope_info_arena.alloc(ScopeInfo {\n+                parent: None,\n+                loop_break: Some(loop_break),\n+                loop_label: loop_label,\n+                cleanups: RefCell::new(~[]),\n+                cleanup_paths: RefCell::new(~[]),\n+                landing_pad: Cell::new(None),\n+                node_info: opt_node_info,\n+              })),\n+              bcx.is_lpad,\n+              n,\n+              opt_node_info)\n }\n \n // Use this when creating a block for the inside of a landing pad.\n-pub fn lpad_block(bcx: @Block, n: &str) -> @Block {\n+pub fn lpad_block<'a>(bcx: &'a Block<'a>, n: &str) -> &'a Block<'a> {\n     new_block(bcx.fcx, Some(bcx), None, true, n, None)\n }\n \n // Use this when you're making a general CFG BB within a scope.\n-pub fn sub_block(bcx: @Block, n: &str) -> @Block {\n+pub fn sub_block<'a>(bcx: &'a Block<'a>, n: &str) -> &'a Block<'a> {\n     new_block(bcx.fcx, Some(bcx), None, bcx.is_lpad, n, None)\n }\n \n-pub fn raw_block(fcx: @FunctionContext, is_lpad: bool, llbb: BasicBlockRef) -> @Block {\n-    @Block::new(llbb, None, is_lpad, None, fcx)\n+pub fn raw_block<'a>(\n+                 fcx: &'a FunctionContext<'a>,\n+                 is_lpad: bool,\n+                 llbb: BasicBlockRef)\n+                 -> &'a Block<'a> {\n+    Block::new(llbb, None, is_lpad, None, fcx)\n }\n \n \n@@ -1285,14 +1345,16 @@ pub fn raw_block(fcx: @FunctionContext, is_lpad: bool, llbb: BasicBlockRef) -> @\n // need to make sure those variables go out of scope when the block ends.  We\n // do that by running a 'cleanup' function for each variable.\n // trans_block_cleanups runs all the cleanup functions for the block.\n-pub fn trans_block_cleanups(bcx: @Block, cleanups: ~[cleanup]) -> @Block {\n+pub fn trans_block_cleanups<'a>(bcx: &'a Block<'a>, cleanups: ~[cleanup])\n+                            -> &'a Block<'a> {\n     trans_block_cleanups_(bcx, cleanups, false)\n }\n \n-pub fn trans_block_cleanups_(bcx: @Block,\n+pub fn trans_block_cleanups_<'a>(\n+                             bcx: &'a Block<'a>,\n                              cleanups: &[cleanup],\n-                             /* cleanup_cx: block, */\n-                             is_lpad: bool) -> @Block {\n+                             is_lpad: bool)\n+                             -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_block_cleanups\");\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n@@ -1318,7 +1380,8 @@ pub fn trans_block_cleanups_(bcx: @Block,\n // In the last argument, Some(block) mean jump to this block, and none means\n // this is a landing pad and leaving should be accomplished with a resume\n // instruction.\n-pub fn cleanup_and_leave(bcx: @Block,\n+pub fn cleanup_and_leave<'a>(\n+                         bcx: &'a Block<'a>,\n                          upto: Option<BasicBlockRef>,\n                          leave: Option<BasicBlockRef>) {\n     let _icx = push_ctxt(\"cleanup_and_leave\");\n@@ -1398,7 +1461,8 @@ pub fn cleanup_and_leave(bcx: @Block,\n     }\n }\n \n-pub fn cleanup_block(bcx: @Block, upto: Option<BasicBlockRef>) -> @Block{\n+pub fn cleanup_block<'a>(bcx: &'a Block<'a>, upto: Option<BasicBlockRef>)\n+                     -> &'a Block<'a> {\n     let _icx = push_ctxt(\"cleanup_block\");\n     let mut cur = bcx;\n     let mut bcx = bcx;\n@@ -1431,12 +1495,16 @@ pub fn cleanup_block(bcx: @Block, upto: Option<BasicBlockRef>) -> @Block{\n     bcx\n }\n \n-pub fn cleanup_and_Br(bcx: @Block, upto: @Block, target: BasicBlockRef) {\n+pub fn cleanup_and_Br<'a>(\n+                      bcx: &'a Block<'a>,\n+                      upto: &'a Block<'a>,\n+                      target: BasicBlockRef) {\n     let _icx = push_ctxt(\"cleanup_and_Br\");\n     cleanup_and_leave(bcx, Some(upto.llbb), Some(target));\n }\n \n-pub fn leave_block(bcx: @Block, out_of: @Block) -> @Block {\n+pub fn leave_block<'a>(bcx: &'a Block<'a>, out_of: &'a Block<'a>)\n+                   -> &'a Block<'a> {\n     let _icx = push_ctxt(\"leave_block\");\n     let next_cx = sub_block(block_parent(out_of), \"next\");\n     if bcx.unreachable.get() {\n@@ -1446,33 +1514,35 @@ pub fn leave_block(bcx: @Block, out_of: @Block) -> @Block {\n     next_cx\n }\n \n-pub fn with_scope(bcx: @Block,\n+pub fn with_scope<'a>(\n+                  bcx: &'a Block<'a>,\n                   opt_node_info: Option<NodeInfo>,\n                   name: &str,\n-                  f: |@Block| -> @Block)\n-                  -> @Block {\n+                  f: |&'a Block<'a>| -> &'a Block<'a>)\n+                  -> &'a Block<'a> {\n     let _icx = push_ctxt(\"with_scope\");\n \n     debug!(\"with_scope(bcx={}, opt_node_info={:?}, name={})\",\n            bcx.to_str(), opt_node_info, name);\n     let _indenter = indenter();\n \n-    let scope = simple_block_scope(bcx.scope.get(), opt_node_info);\n+    let scope = simple_block_scope(bcx.fcx, bcx.scope.get(), opt_node_info);\n     bcx.scope.set(Some(scope));\n     let ret = f(bcx);\n     let ret = trans_block_cleanups_(ret, scope.cleanups.get(), false);\n     bcx.scope.set(scope.parent);\n     ret\n }\n \n-pub fn with_scope_result(bcx: @Block,\n+pub fn with_scope_result<'a>(\n+                         bcx: &'a Block<'a>,\n                          opt_node_info: Option<NodeInfo>,\n                          _name: &str,\n-                         f: |@Block| -> Result)\n-                         -> Result {\n+                         f: |&'a Block<'a>| -> Result<'a>)\n+                         -> Result<'a> {\n     let _icx = push_ctxt(\"with_scope_result\");\n \n-    let scope = simple_block_scope(bcx.scope.get(), opt_node_info);\n+    let scope = simple_block_scope(bcx.fcx, bcx.scope.get(), opt_node_info);\n     bcx.scope.set(Some(scope));\n     let Result { bcx: out_bcx, val } = f(bcx);\n     let out_bcx = trans_block_cleanups_(out_bcx, scope.cleanups.get(), false);\n@@ -1481,11 +1551,12 @@ pub fn with_scope_result(bcx: @Block,\n     rslt(out_bcx, val)\n }\n \n-pub fn with_scope_datumblock(bcx: @Block,\n+pub fn with_scope_datumblock<'a>(\n+                             bcx: &'a Block<'a>,\n                              opt_node_info: Option<NodeInfo>,\n                              name: &str,\n-                             f: |@Block| -> datum::DatumBlock)\n-                             -> datum::DatumBlock {\n+                             f: |&'a Block| -> datum::DatumBlock<'a>)\n+                             -> datum::DatumBlock<'a> {\n     use middle::trans::datum::DatumBlock;\n \n     let _icx = push_ctxt(\"with_scope_result\");\n@@ -1509,10 +1580,11 @@ pub fn block_locals(b: &ast::Block, it: |@ast::Local|) {\n     }\n }\n \n-pub fn with_cond(bcx: @Block,\n+pub fn with_cond<'a>(\n+                 bcx: &'a Block<'a>,\n                  val: ValueRef,\n-                 f: |@Block| -> @Block)\n-                 -> @Block {\n+                 f: |&'a Block<'a>| -> &'a Block<'a>)\n+                 -> &'a Block<'a> {\n     let _icx = push_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, \"next\");\n     let cond_cx = base::sub_block(bcx, \"cond\");\n@@ -1524,7 +1596,7 @@ pub fn with_cond(bcx: @Block,\n     next_cx\n }\n \n-pub fn call_memcpy(cx: @Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n+pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess.targ_cfg.arch {\n@@ -1540,7 +1612,7 @@ pub fn call_memcpy(cx: @Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef,\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], []);\n }\n \n-pub fn memcpy_ty(bcx: @Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n+pub fn memcpy_ty(bcx: &Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n@@ -1553,7 +1625,7 @@ pub fn memcpy_ty(bcx: @Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     }\n }\n \n-pub fn zero_mem(cx: @Block, llptr: ValueRef, t: ty::t) {\n+pub fn zero_mem(cx: &Block, llptr: ValueRef, t: ty::t) {\n     if cx.unreachable.get() { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n@@ -1585,7 +1657,7 @@ pub fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], []);\n }\n \n-pub fn alloc_ty(bcx: @Block, t: ty::t, name: &str) -> ValueRef {\n+pub fn alloc_ty(bcx: &Block, t: ty::t, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n@@ -1594,11 +1666,11 @@ pub fn alloc_ty(bcx: @Block, t: ty::t, name: &str) -> ValueRef {\n     return val;\n }\n \n-pub fn alloca(cx: @Block, ty: Type, name: &str) -> ValueRef {\n+pub fn alloca(cx: &Block, ty: Type, name: &str) -> ValueRef {\n     alloca_maybe_zeroed(cx, ty, name, false)\n }\n \n-pub fn alloca_maybe_zeroed(cx: @Block, ty: Type, name: &str, zero: bool) -> ValueRef {\n+pub fn alloca_maybe_zeroed(cx: &Block, ty: Type, name: &str, zero: bool) -> ValueRef {\n     let _icx = push_ctxt(\"alloca\");\n     if cx.unreachable.get() {\n         unsafe {\n@@ -1615,7 +1687,7 @@ pub fn alloca_maybe_zeroed(cx: @Block, ty: Type, name: &str, zero: bool) -> Valu\n     p\n }\n \n-pub fn arrayalloca(cx: @Block, ty: Type, v: ValueRef) -> ValueRef {\n+pub fn arrayalloca(cx: &Block, ty: Type, v: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"arrayalloca\");\n     if cx.unreachable.get() {\n         unsafe {\n@@ -1650,7 +1722,8 @@ pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n \n // Creates and returns space for, or returns the argument representing, the\n // slot where the return value of the function must go.\n-pub fn make_return_pointer(fcx: @FunctionContext, output_type: ty::t) -> ValueRef {\n+pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n+                           -> ValueRef {\n     unsafe {\n         if type_of::return_uses_outptr(fcx.ccx, output_type) {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n@@ -1668,16 +1741,17 @@ pub fn make_return_pointer(fcx: @FunctionContext, output_type: ty::t) -> ValueRe\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n+//\n+// Be warned! You must call `init_function` before doing anything with the\n+// returned function context.\n pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n                         path: path,\n                         llfndecl: ValueRef,\n                         id: ast::NodeId,\n                         output_type: ty::t,\n-                        skip_retptr: bool,\n                         param_substs: Option<@param_substs>,\n-                        opt_node_info: Option<NodeInfo>,\n                         sp: Option<Span>)\n-                     -> @FunctionContext {\n+                        -> FunctionContext {\n     for p in param_substs.iter() { p.validate(); }\n \n     debug!(\"new_fn_ctxt_w_id(path={}, id={:?}, \\\n@@ -1695,7 +1769,7 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n     let uses_outptr = type_of::return_uses_outptr(ccx, substd_output_type);\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n \n-    let fcx = @FunctionContext {\n+    let fcx = FunctionContext {\n           llfn: llfndecl,\n           llenv: unsafe {\n               Cell::new(llvm::LLVMGetUndef(Type::i8p().to_ref()))\n@@ -1714,13 +1788,26 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n           param_substs: param_substs,\n           span: sp,\n           path: path,\n+          block_arena: TypedArena::new(),\n+          scope_info_arena: TypedArena::new(),\n           ccx: ccx,\n           debug_context: debug_context,\n     };\n     fcx.llenv.set(unsafe {\n           llvm::LLVMGetParam(llfndecl, fcx.env_arg_pos() as c_uint)\n     });\n \n+    fcx\n+}\n+\n+/// Performs setup on a newly created function, creating the entry scope block\n+/// and allocating space for the return pointer.\n+pub fn init_function<'a>(\n+                     fcx: &'a FunctionContext<'a>,\n+                     skip_retptr: bool,\n+                     output_type: ty::t,\n+                     param_substs: Option<@param_substs>,\n+                     opt_node_info: Option<NodeInfo>) {\n     unsafe {\n         let entry_bcx = top_scope_block(fcx, opt_node_info);\n         Load(entry_bcx, C_null(Type::i8p()));\n@@ -1730,27 +1817,38 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n                 llvm::LLVMGetFirstInstruction(entry_bcx.llbb)));\n     }\n \n-    if !ty::type_is_voidish(ccx.tcx, substd_output_type) {\n+    let substd_output_type = match param_substs {\n+        None => output_type,\n+        Some(substs) => {\n+            ty::subst_tps(fcx.ccx.tcx,\n+                          substs.tys,\n+                          substs.self_ty,\n+                          output_type)\n+        }\n+    };\n+\n+    if !ty::type_is_voidish(fcx.ccx.tcx, substd_output_type) {\n         // If the function returns nil/bot, there is no real return\n         // value, so do not set `llretptr`.\n-        if !skip_retptr || uses_outptr {\n+        if !skip_retptr || fcx.caller_expects_out_pointer {\n             // Otherwise, we normally allocate the llretptr, unless we\n             // have been instructed to skip it for immediate return\n             // values.\n             fcx.llretptr.set(Some(make_return_pointer(fcx,\n                                                       substd_output_type)));\n         }\n     }\n-    fcx\n }\n \n pub fn new_fn_ctxt(ccx: @CrateContext,\n                    path: path,\n                    llfndecl: ValueRef,\n                    output_type: ty::t,\n                    sp: Option<Span>)\n-                -> @FunctionContext {\n-    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, false, None, None, sp)\n+                   -> FunctionContext {\n+    // FIXME(#11385): Do not call `init_function` here; it will typecheck\n+    // but segfault.\n+    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, None, sp)\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1767,10 +1865,10 @@ pub fn new_fn_ctxt(ccx: @CrateContext,\n // spaces that have been created for them (by code in the llallocas field of\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n-pub fn create_llargs_for_fn_args(cx: @FunctionContext,\n+pub fn create_llargs_for_fn_args(cx: &FunctionContext,\n                                  self_arg: self_arg,\n                                  args: &[ast::arg])\n-                              -> ~[ValueRef] {\n+                                 -> ~[ValueRef] {\n     let _icx = push_ctxt(\"create_llargs_for_fn_args\");\n \n     match self_arg {\n@@ -1791,11 +1889,13 @@ pub fn create_llargs_for_fn_args(cx: @FunctionContext,\n     })\n }\n \n-pub fn copy_args_to_allocas(fcx: @FunctionContext,\n-                            bcx: @Block,\n+pub fn copy_args_to_allocas<'a>(\n+                            fcx: &FunctionContext<'a>,\n+                            bcx: &'a Block<'a>,\n                             args: &[ast::arg],\n                             raw_llargs: &[ValueRef],\n-                            arg_tys: &[ty::t]) -> @Block {\n+                            arg_tys: &[ty::t])\n+                            -> &'a Block<'a> {\n     debug!(\"copy_args_to_allocas: raw_llargs={} arg_tys={}\",\n            raw_llargs.llrepr(fcx.ccx),\n            arg_tys.repr(fcx.ccx.tcx));\n@@ -1855,7 +1955,7 @@ pub fn copy_args_to_allocas(fcx: @FunctionContext,\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n-pub fn finish_fn(fcx: @FunctionContext, last_bcx: @Block) {\n+pub fn finish_fn(fcx: &FunctionContext, last_bcx: &Block) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n     let ret_cx = match fcx.llreturn.get() {\n@@ -1873,7 +1973,7 @@ pub fn finish_fn(fcx: @FunctionContext, last_bcx: @Block) {\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: &FunctionContext, ret_cx: @Block) {\n+pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block) {\n     // Return the value if this function immediate; otherwise, return void.\n     if fcx.llretptr.get().is_none() || fcx.caller_expects_out_pointer {\n         return RetVoid(ret_cx);\n@@ -1916,7 +2016,7 @@ pub fn trans_closure(ccx: @CrateContext,\n                      id: ast::NodeId,\n                      _attributes: &[ast::Attribute],\n                      output_type: ty::t,\n-                     maybe_load_env: |@FunctionContext|) {\n+                     maybe_load_env: |&FunctionContext|) {\n     ccx.stats.n_closures.set(ccx.stats.n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n@@ -1930,10 +2030,9 @@ pub fn trans_closure(ccx: @CrateContext,\n                                llfndecl,\n                                id,\n                                output_type,\n-                               false,\n                                param_substs,\n-                               body.info(),\n                                Some(body.span));\n+    init_function(&fcx, false, output_type, param_substs, body.info());\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n@@ -1943,16 +2042,16 @@ pub fn trans_closure(ccx: @CrateContext,\n \n     // Set up arguments to the function.\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n-    let raw_llargs = create_llargs_for_fn_args(fcx, self_arg, decl.inputs);\n+    let raw_llargs = create_llargs_for_fn_args(&fcx, self_arg, decl.inputs);\n \n-    bcx = copy_args_to_allocas(fcx, bcx, decl.inputs, raw_llargs, arg_tys);\n+    bcx = copy_args_to_allocas(&fcx, bcx, decl.inputs, raw_llargs, arg_tys);\n \n-    maybe_load_env(fcx);\n+    maybe_load_env(&fcx);\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n     // emitting should be enabled.\n-    debuginfo::start_emitting_source_locations(fcx);\n+    debuginfo::start_emitting_source_locations(&fcx);\n \n     // This call to trans_block is the place where we bridge between\n     // translation calls that don't have a return value (trans_crate,\n@@ -1980,7 +2079,7 @@ pub fn trans_closure(ccx: @CrateContext,\n     }\n \n     // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(fcx, bcx);\n+    finish_fn(&fcx, bcx);\n }\n \n // trans_fn: creates an LLVM function corresponding to a source language\n@@ -2015,10 +2114,9 @@ pub fn trans_fn(ccx: @CrateContext,\n                   |_fcx| { });\n }\n \n-fn insert_synthetic_type_entries(bcx: @Block,\n+fn insert_synthetic_type_entries(bcx: &Block,\n                                  fn_args: &[ast::arg],\n-                                 arg_tys: &[ty::t])\n-{\n+                                 arg_tys: &[ty::t]) {\n     /*!\n      * For tuple-like structs and enum-variants, we generate\n      * synthetic AST nodes for the arguments.  These have no types\n@@ -2143,19 +2241,18 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n                                llfndecl,\n                                ctor_id,\n                                result_ty,\n-                               false,\n                                param_substs,\n-                               None,\n                                None);\n+    init_function(&fcx, false, result_ty, param_substs, None);\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n+    let raw_llargs = create_llargs_for_fn_args(&fcx, no_self, fn_args);\n \n     let bcx = fcx.entry_bcx.get().unwrap();\n \n     insert_synthetic_type_entries(bcx, fn_args, arg_tys);\n-    let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n+    let bcx = copy_args_to_allocas(&fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n     let repr = adt::represent_type(ccx, result_ty);\n     adt::trans_start_init(bcx, repr, fcx.llretptr.get().unwrap(), disr);\n@@ -2172,7 +2269,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n         let arg_ty = arg_tys[i];\n         memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n     }\n-    finish_fn(fcx, bcx);\n+    finish_fn(&fcx, bcx);\n }\n \n pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n@@ -2471,7 +2568,9 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n     }\n }\n \n-pub fn fill_fn_pair(bcx: @Block, pair: ValueRef, llfn: ValueRef,\n+pub fn fill_fn_pair(bcx: &Block,\n+                    pair: ValueRef,\n+                    llfn: ValueRef,\n                     llenvptr: ValueRef) {\n     let ccx = bcx.ccx();\n     let code_cell = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n@@ -2798,7 +2897,7 @@ pub fn register_method(ccx: @CrateContext,\n     llfn\n }\n \n-pub fn vp2i(cx: @Block, v: ValueRef) -> ValueRef {\n+pub fn vp2i(cx: &Block, v: ValueRef) -> ValueRef {\n     let ccx = cx.ccx();\n     return PtrToInt(cx, v, ccx.int_type);\n }\n@@ -2966,7 +3065,7 @@ pub fn declare_dbg_intrinsics(llmod: ModuleRef, intrinsics: &mut HashMap<&'stati\n          \"llvm.dbg.value\",   [Type::metadata(), Type::i64(), Type::metadata()], Type::void());\n }\n \n-pub fn trap(bcx: @Block) {\n+pub fn trap(bcx: &Block) {\n     match bcx.ccx().intrinsics.find_equiv(& &\"llvm.trap\") {\n       Some(&x) => { Call(bcx, x, [], []); },\n       _ => bcx.sess().bug(\"unbound llvm.trap in trap\")"}, {"sha": "0dd0d1589ff5841ec3a6aaf09e17c01040d7c6e3", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -54,28 +54,30 @@ pub fn RetVoid(cx: &Block) {\n     B(cx).ret_void();\n }\n \n-pub fn Ret(cx: @Block, V: ValueRef) {\n+pub fn Ret(cx: &Block, V: ValueRef) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Ret\");\n     B(cx).ret(V);\n }\n \n-pub fn AggregateRet(cx: @Block, RetVals: &[ValueRef]) {\n+pub fn AggregateRet(cx: &Block, RetVals: &[ValueRef]) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n     B(cx).aggregate_ret(RetVals);\n }\n \n-pub fn Br(cx: @Block, Dest: BasicBlockRef) {\n+pub fn Br(cx: &Block, Dest: BasicBlockRef) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Br\");\n     B(cx).br(Dest);\n }\n \n-pub fn CondBr(cx: @Block, If: ValueRef, Then: BasicBlockRef,\n+pub fn CondBr(cx: &Block,\n+              If: ValueRef,\n+              Then: BasicBlockRef,\n               Else: BasicBlockRef) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n@@ -105,13 +107,13 @@ pub fn IndirectBr(cx: &Block, Addr: ValueRef, NumDests: uint) {\n     B(cx).indirect_br(Addr, NumDests);\n }\n \n-pub fn Invoke(cx: @Block,\n+pub fn Invoke(cx: &Block,\n               Fn: ValueRef,\n               Args: &[ValueRef],\n               Then: BasicBlockRef,\n               Catch: BasicBlockRef,\n               attributes: &[(uint, lib::llvm::Attribute)])\n-           -> ValueRef {\n+              -> ValueRef {\n     if cx.unreachable.get() {\n         return C_null(Type::i8());\n     }\n@@ -762,7 +764,7 @@ pub fn SetCleanup(cx: &Block, LandingPad: ValueRef) {\n     B(cx).set_cleanup(LandingPad)\n }\n \n-pub fn Resume(cx: @Block, Exn: ValueRef) -> ValueRef {\n+pub fn Resume(cx: &Block, Exn: ValueRef) -> ValueRef {\n     check_not_terminated(cx);\n     terminate(cx, \"Resume\");\n     B(cx).resume(Exn)"}, {"sha": "6bf1babb9e5fc330b963f001442a596967034ed2", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -70,12 +70,12 @@ pub enum CalleeData {\n     Method(MethodData)\n }\n \n-pub struct Callee {\n-    bcx: @Block,\n+pub struct Callee<'a> {\n+    bcx: &'a Block<'a>,\n     data: CalleeData\n }\n \n-pub fn trans(bcx: @Block, expr: &ast::Expr) -> Callee {\n+pub fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n     let _icx = push_ctxt(\"trans_callee\");\n     debug!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n \n@@ -90,7 +90,7 @@ pub fn trans(bcx: @Block, expr: &ast::Expr) -> Callee {\n     // any other expressions are closures:\n     return datum_callee(bcx, expr);\n \n-    fn datum_callee(bcx: @Block, expr: &ast::Expr) -> Callee {\n+    fn datum_callee<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n         let DatumBlock {bcx, datum} = expr::trans_to_datum(bcx, expr);\n         match ty::get(datum.ty).sty {\n             ty::ty_bare_fn(..) => {\n@@ -109,11 +109,12 @@ pub fn trans(bcx: @Block, expr: &ast::Expr) -> Callee {\n         }\n     }\n \n-    fn fn_callee(bcx: @Block, fd: FnData) -> Callee {\n+    fn fn_callee<'a>(bcx: &'a Block<'a>, fd: FnData) -> Callee<'a> {\n         return Callee {bcx: bcx, data: Fn(fd)};\n     }\n \n-    fn trans_def(bcx: @Block, def: ast::Def, ref_expr: &ast::Expr) -> Callee {\n+    fn trans_def<'a>(bcx: &'a Block<'a>, def: ast::Def, ref_expr: &ast::Expr)\n+                 -> Callee<'a> {\n         match def {\n             ast::DefFn(did, _) |\n             ast::DefStaticMethod(did, ast::FromImpl(_), _) => {\n@@ -158,16 +159,17 @@ pub fn trans(bcx: @Block, expr: &ast::Expr) -> Callee {\n     }\n }\n \n-pub fn trans_fn_ref_to_callee(bcx: @Block,\n+pub fn trans_fn_ref_to_callee<'a>(\n+                              bcx: &'a Block<'a>,\n                               def_id: ast::DefId,\n-                              ref_id: ast::NodeId) -> Callee {\n+                              ref_id: ast::NodeId)\n+                              -> Callee<'a> {\n     Callee {bcx: bcx,\n             data: Fn(trans_fn_ref(bcx, def_id, ref_id))}\n }\n \n-pub fn trans_fn_ref(bcx: @Block,\n-                    def_id: ast::DefId,\n-                    ref_id: ast::NodeId) -> FnData {\n+pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, ref_id: ast::NodeId)\n+                    -> FnData {\n     /*!\n      *\n      * Translates a reference (with id `ref_id`) to the fn/method\n@@ -184,19 +186,19 @@ pub fn trans_fn_ref(bcx: @Block,\n     trans_fn_ref_with_vtables(bcx, def_id, ref_id, type_params, vtables)\n }\n \n-pub fn trans_fn_ref_with_vtables_to_callee(\n-        bcx: @Block,\n-        def_id: ast::DefId,\n-        ref_id: ast::NodeId,\n-        type_params: &[ty::t],\n-        vtables: Option<typeck::vtable_res>)\n-     -> Callee {\n+pub fn trans_fn_ref_with_vtables_to_callee<'a>(\n+                                           bcx: &'a Block<'a>,\n+                                           def_id: ast::DefId,\n+                                           ref_id: ast::NodeId,\n+                                           type_params: &[ty::t],\n+                                           vtables: Option<typeck::vtable_res>)\n+                                           -> Callee<'a> {\n     Callee {bcx: bcx,\n             data: Fn(trans_fn_ref_with_vtables(bcx, def_id, ref_id,\n                                                type_params, vtables))}\n }\n \n-fn resolve_default_method_vtables(bcx: @Block,\n+fn resolve_default_method_vtables(bcx: &Block,\n                                   impl_id: ast::DefId,\n                                   method: &ty::Method,\n                                   substs: &ty::substs,\n@@ -239,7 +241,7 @@ fn resolve_default_method_vtables(bcx: @Block,\n \n \n pub fn trans_fn_ref_with_vtables(\n-        bcx: @Block,       //\n+        bcx: &Block,       //\n         def_id: ast::DefId,   // def id of fn\n         ref_id: ast::NodeId,  // node id of use of fn; may be zero if N/A\n         type_params: &[ty::t], // values for fn's ty params\n@@ -447,13 +449,14 @@ pub fn trans_fn_ref_with_vtables(\n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_call(in_cx: @Block,\n+pub fn trans_call<'a>(\n+                  in_cx: &'a Block<'a>,\n                   call_ex: &ast::Expr,\n                   f: &ast::Expr,\n                   args: CallArgs,\n                   id: ast::NodeId,\n                   dest: expr::Dest)\n-                  -> @Block {\n+                  -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n                      call_ex.info(),\n@@ -465,13 +468,14 @@ pub fn trans_call(in_cx: @Block,\n                      DontAutorefArg).bcx\n }\n \n-pub fn trans_method_call(in_cx: @Block,\n+pub fn trans_method_call<'a>(\n+                         in_cx: &'a Block<'a>,\n                          call_ex: &ast::Expr,\n                          callee_id: ast::NodeId,\n                          rcvr: &ast::Expr,\n                          args: CallArgs,\n                          dest: expr::Dest)\n-                         -> @Block {\n+                         -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={}, rcvr={})\",\n            call_ex.repr(in_cx.tcx()),\n@@ -507,11 +511,12 @@ pub fn trans_method_call(in_cx: @Block,\n         DontAutorefArg).bcx\n }\n \n-pub fn trans_lang_call(bcx: @Block,\n+pub fn trans_lang_call<'a>(\n+                       bcx: &'a Block<'a>,\n                        did: ast::DefId,\n                        args: &[ValueRef],\n                        dest: Option<expr::Dest>)\n-    -> Result {\n+                       -> Result<'a> {\n     let fty = if did.crate == ast::LOCAL_CRATE {\n         ty::node_id_to_type(bcx.ccx().tcx, did.node)\n     } else {\n@@ -534,12 +539,13 @@ pub fn trans_lang_call(bcx: @Block,\n                              DontAutorefArg)\n }\n \n-pub fn trans_lang_call_with_type_params(bcx: @Block,\n+pub fn trans_lang_call_with_type_params<'a>(\n+                                        bcx: &'a Block<'a>,\n                                         did: ast::DefId,\n                                         args: &[ValueRef],\n                                         type_params: &[ty::t],\n                                         dest: expr::Dest)\n-    -> @Block {\n+                                        -> &'a Block<'a> {\n     let fty;\n     if did.crate == ast::LOCAL_CRATE {\n         fty = ty::node_id_to_type(bcx.tcx(), did.node);\n@@ -574,15 +580,16 @@ pub fn trans_lang_call_with_type_params(bcx: @Block,\n         ArgVals(args), Some(dest), DontAutorefArg).bcx;\n }\n \n-pub fn trans_call_inner(in_cx: @Block,\n+pub fn trans_call_inner<'a>(\n+                        in_cx: &'a Block<'a>,\n                         call_info: Option<NodeInfo>,\n                         callee_ty: ty::t,\n                         ret_ty: ty::t,\n-                        get_callee: |@Block| -> Callee,\n+                        get_callee: |&'a Block<'a>| -> Callee<'a>,\n                         args: CallArgs,\n                         dest: Option<expr::Dest>,\n                         autoref_arg: AutorefArg)\n-                        -> Result {\n+                        -> Result<'a> {\n     /*!\n      * This behemoth of a function translates function calls.\n      * Unfortunately, in order to generate more efficient LLVM\n@@ -762,12 +769,13 @@ pub enum CallArgs<'a> {\n     ArgVals(&'a [ValueRef])\n }\n \n-pub fn trans_args(cx: @Block,\n+pub fn trans_args<'a>(\n+                  cx: &'a Block<'a>,\n                   args: CallArgs,\n                   fn_ty: ty::t,\n                   autoref_arg: AutorefArg,\n-                  llargs: &mut ~[ValueRef]) -> @Block\n-{\n+                  llargs: &mut ~[ValueRef])\n+                  -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n     let arg_tys = ty::ty_fn_args(fn_ty);\n@@ -821,12 +829,14 @@ pub enum AutorefArg {\n \n // temp_cleanups: cleanups that should run only if failure occurs before the\n // call takes place:\n-pub fn trans_arg_expr(bcx: @Block,\n+pub fn trans_arg_expr<'a>(\n+                      bcx: &'a Block<'a>,\n                       formal_arg_ty: ty::t,\n                       self_mode: ty::SelfMode,\n                       arg_expr: &ast::Expr,\n                       temp_cleanups: &mut ~[ValueRef],\n-                      autoref_arg: AutorefArg) -> Result {\n+                      autoref_arg: AutorefArg)\n+                      -> Result<'a> {\n     let _icx = push_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n "}, {"sha": "44bce6b2a2aeb72f81b77261a08ddaea4d4dcadd", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -155,16 +155,19 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     return cdata_ty;\n }\n \n-fn heap_for_unique_closure(bcx: @Block, t: ty::t) -> heap {\n+fn heap_for_unique_closure(bcx: &Block, t: ty::t) -> heap {\n     if ty::type_contents(bcx.tcx(), t).owns_managed() {\n         heap_managed_unique\n     } else {\n         heap_exchange_closure\n     }\n }\n \n-pub fn allocate_cbox(bcx: @Block, sigil: ast::Sigil, cdata_ty: ty::t)\n-                  -> Result {\n+pub fn allocate_cbox<'a>(\n+                     bcx: &'a Block<'a>,\n+                     sigil: ast::Sigil,\n+                     cdata_ty: ty::t)\n+                     -> Result<'a> {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n@@ -185,20 +188,21 @@ pub fn allocate_cbox(bcx: @Block, sigil: ast::Sigil, cdata_ty: ty::t)\n     }\n }\n \n-pub struct ClosureResult {\n-    llbox: ValueRef, // llvalue of ptr to closure\n-    cdata_ty: ty::t, // type of the closure data\n-    bcx: @Block       // final bcx\n+pub struct ClosureResult<'a> {\n+    llbox: ValueRef,    // llvalue of ptr to closure\n+    cdata_ty: ty::t,    // type of the closure data\n+    bcx: &'a Block<'a>  // final bcx\n }\n \n // Given a block context and a list of tydescs and values to bind\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n-pub fn store_environment(bcx: @Block,\n+pub fn store_environment<'a>(\n+                         bcx: &'a Block<'a>,\n                          bound_values: ~[EnvValue],\n                          sigil: ast::Sigil)\n-                         -> ClosureResult {\n+                         -> ClosureResult<'a> {\n     let _icx = push_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n@@ -257,9 +261,11 @@ pub fn store_environment(bcx: @Block,\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n-pub fn build_closure(bcx0: @Block,\n+pub fn build_closure<'a>(\n+                     bcx0: &'a Block<'a>,\n                      cap_vars: &[moves::CaptureVar],\n-                     sigil: ast::Sigil) -> ClosureResult {\n+                     sigil: ast::Sigil)\n+                     -> ClosureResult<'a> {\n     let _icx = push_ctxt(\"closure::build_closure\");\n \n     // If we need to, package up the iterator body to call\n@@ -293,7 +299,7 @@ pub fn build_closure(bcx0: @Block,\n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n-pub fn load_environment(fcx: @FunctionContext,\n+pub fn load_environment(fcx: &FunctionContext,\n                         cdata_ty: ty::t,\n                         cap_vars: &[moves::CaptureVar],\n                         sigil: ast::Sigil) {\n@@ -349,13 +355,15 @@ pub fn load_environment(fcx: @FunctionContext,\n     }\n }\n \n-pub fn trans_expr_fn(bcx: @Block,\n+pub fn trans_expr_fn<'a>(\n+                     bcx: &'a Block<'a>,\n                      sigil: ast::Sigil,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n                      outer_id: ast::NodeId,\n                      user_id: ast::NodeId,\n-                     dest: expr::Dest) -> @Block {\n+                     dest: expr::Dest)\n+                     -> &'a Block<'a> {\n     /*!\n      *\n      * Translates the body of a closure expression.\n@@ -429,12 +437,13 @@ pub fn trans_expr_fn(bcx: @Block,\n     return bcx;\n }\n \n-pub fn make_closure_glue(cx: @Block,\n+pub fn make_closure_glue<'a>(\n+                         cx: &'a Block<'a>,\n                          v: ValueRef,\n                          t: ty::t,\n-                         glue_fn: |@Block, v: ValueRef, t: ty::t|\n-                                   -> @Block)\n-                         -> @Block {\n+                         glue_fn: |&'a Block<'a>, v: ValueRef, t: ty::t|\n+                                   -> &'a Block<'a>)\n+                         -> &'a Block<'a> {\n     let _icx = push_ctxt(\"closure::make_closure_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n@@ -453,11 +462,11 @@ pub fn make_closure_glue(cx: @Block,\n     }\n }\n \n-pub fn make_opaque_cbox_drop_glue(\n-    bcx: @Block,\n-    sigil: ast::Sigil,\n-    cboxptr: ValueRef)     // ptr to the opaque closure\n-    -> @Block {\n+pub fn make_opaque_cbox_drop_glue<'a>(\n+                                  bcx: &'a Block<'a>,\n+                                  sigil: ast::Sigil,\n+                                  cboxptr: ValueRef)    // opaque closure ptr\n+                                  -> &'a Block<'a> {\n     let _icx = push_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n     match sigil {\n         ast::BorrowedSigil => bcx,\n@@ -473,10 +482,11 @@ pub fn make_opaque_cbox_drop_glue(\n }\n \n /// `cbox` is a pointer to a pointer to an opaque closure.\n-pub fn make_opaque_cbox_free_glue(bcx: @Block,\n+pub fn make_opaque_cbox_free_glue<'a>(\n+                                  bcx: &'a Block<'a>,\n                                   sigil: ast::Sigil,\n                                   cbox: ValueRef)\n-                                  -> @Block {\n+                                  -> &'a Block<'a> {\n     let _icx = push_ctxt(\"closure::make_opaque_cbox_free_glue\");\n     match sigil {\n         ast::BorrowedSigil => {"}, {"sha": "4baae9279b1736035a7d9980d9144b821893ea89", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 68, "deletions": 51, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -23,13 +23,14 @@ use middle::trans::build;\n use middle::trans::datum;\n use middle::trans::glue;\n use middle::trans::debuginfo;\n+use middle::trans::type_::Type;\n use middle::ty::substs;\n use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n \n-use middle::trans::type_::Type;\n \n+use extra::arena::TypedArena;\n use std::c_str::ToCStr;\n use std::cast::transmute;\n use std::cast;\n@@ -195,7 +196,7 @@ impl Repr for param_substs {\n \n // Function context.  Every LLVM function we create will have one of\n // these.\n-pub struct FunctionContext {\n+pub struct FunctionContext<'a> {\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n     // instructions for this function that will go in the .text\n@@ -212,7 +213,7 @@ pub struct FunctionContext {\n     // always be Some.\n     llretptr: Cell<Option<ValueRef>>,\n \n-    entry_bcx: RefCell<Option<@Block>>,\n+    entry_bcx: RefCell<Option<&'a Block<'a>>>,\n \n     // These elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n@@ -258,14 +259,20 @@ pub struct FunctionContext {\n     span: Option<Span>,\n     path: path,\n \n+    // The arena that blocks are allocated from.\n+    block_arena: TypedArena<Block<'a>>,\n+\n+    // The arena that scope info is allocated from.\n+    scope_info_arena: TypedArena<ScopeInfo<'a>>,\n+\n     // This function's enclosing crate context.\n     ccx: @CrateContext,\n \n     // Used and maintained by the debuginfo module.\n     debug_context: debuginfo::FunctionDebugContext,\n }\n \n-impl FunctionContext {\n+impl<'a> FunctionContext<'a> {\n     pub fn arg_pos(&self, arg: uint) -> uint {\n         if self.caller_expects_out_pointer {\n             arg + 2u\n@@ -332,7 +339,7 @@ pub enum cleantype {\n \n /// A cleanup function: a built-in destructor.\n pub trait CleanupFunction {\n-    fn clean(&self, block: @Block) -> @Block;\n+    fn clean<'a>(&self, block: &'a Block<'a>) -> &'a Block<'a>;\n }\n \n /// A cleanup function that calls the \"drop glue\" (destructor function) on\n@@ -343,7 +350,7 @@ pub struct TypeDroppingCleanupFunction {\n }\n \n impl CleanupFunction for TypeDroppingCleanupFunction {\n-    fn clean(&self, block: @Block) -> @Block {\n+    fn clean<'a>(&self, block: &'a Block<'a>) -> &'a Block<'a> {\n         glue::drop_ty(block, self.val, self.t)\n     }\n }\n@@ -356,7 +363,7 @@ pub struct ImmediateTypeDroppingCleanupFunction {\n }\n \n impl CleanupFunction for ImmediateTypeDroppingCleanupFunction {\n-    fn clean(&self, block: @Block) -> @Block {\n+    fn clean<'a>(&self, block: &'a Block<'a>) -> &'a Block<'a> {\n         glue::drop_ty_immediate(block, self.val, self.t)\n     }\n }\n@@ -367,7 +374,7 @@ pub struct GCHeapFreeingCleanupFunction {\n }\n \n impl CleanupFunction for GCHeapFreeingCleanupFunction {\n-    fn clean(&self, bcx: @Block) -> @Block {\n+    fn clean<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n         glue::trans_free(bcx, self.ptr)\n     }\n }\n@@ -378,7 +385,7 @@ pub struct ExchangeHeapFreeingCleanupFunction {\n }\n \n impl CleanupFunction for ExchangeHeapFreeingCleanupFunction {\n-    fn clean(&self, bcx: @Block) -> @Block {\n+    fn clean<'a>(&self, bcx: &'a Block) -> &'a Block<'a> {\n         glue::trans_exchange_free(bcx, self.ptr)\n     }\n }\n@@ -432,7 +439,7 @@ pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n     }\n }\n \n-pub fn add_clean(bcx: @Block, val: ValueRef, t: ty::t) {\n+pub fn add_clean(bcx: &Block, val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) {\n         return\n     }\n@@ -453,7 +460,7 @@ pub fn add_clean(bcx: @Block, val: ValueRef, t: ty::t) {\n     })\n }\n \n-pub fn add_clean_temp_immediate(cx: @Block, val: ValueRef, ty: ty::t) {\n+pub fn add_clean_temp_immediate(cx: &Block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n     debug!(\"add_clean_temp_immediate({}, {}, {})\",\n            cx.to_str(), cx.val_to_str(val),\n@@ -473,18 +480,18 @@ pub fn add_clean_temp_immediate(cx: @Block, val: ValueRef, ty: ty::t) {\n     })\n }\n \n-pub fn add_clean_temp_mem(bcx: @Block, val: ValueRef, t: ty::t) {\n+pub fn add_clean_temp_mem(bcx: &Block, val: ValueRef, t: ty::t) {\n     add_clean_temp_mem_in_scope_(bcx, None, val, t);\n }\n \n-pub fn add_clean_temp_mem_in_scope(bcx: @Block,\n+pub fn add_clean_temp_mem_in_scope(bcx: &Block,\n                                    scope_id: ast::NodeId,\n                                    val: ValueRef,\n                                    t: ty::t) {\n     add_clean_temp_mem_in_scope_(bcx, Some(scope_id), val, t);\n }\n \n-pub fn add_clean_temp_mem_in_scope_(bcx: @Block, scope_id: Option<ast::NodeId>,\n+pub fn add_clean_temp_mem_in_scope_(bcx: &Block, scope_id: Option<ast::NodeId>,\n                                     val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean_temp_mem({}, {}, {})\",\n@@ -505,7 +512,7 @@ pub fn add_clean_temp_mem_in_scope_(bcx: @Block, scope_id: Option<ast::NodeId>,\n     })\n }\n \n-pub fn add_clean_free(cx: @Block, ptr: ValueRef, heap: heap) {\n+pub fn add_clean_free(cx: &Block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n         heap_managed | heap_managed_unique => {\n             @GCHeapFreeingCleanupFunction {\n@@ -533,7 +540,7 @@ pub fn add_clean_free(cx: @Block, ptr: ValueRef, heap: heap) {\n // to a system where we can also cancel the cleanup on local variables, but\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n-pub fn revoke_clean(cx: @Block, val: ValueRef) {\n+pub fn revoke_clean(cx: &Block, val: ValueRef) {\n     in_scope_cx(cx, None, |scope_info| {\n         let cleanup_pos = {\n             let mut cleanups = scope_info.cleanups.borrow_mut();\n@@ -564,9 +571,9 @@ pub fn block_cleanups(bcx: &Block) -> ~[cleanup] {\n     }\n }\n \n-pub struct ScopeInfo {\n-    parent: Option<@ScopeInfo>,\n-    loop_break: Option<@Block>,\n+pub struct ScopeInfo<'a> {\n+    parent: Option<&'a ScopeInfo<'a>>,\n+    loop_break: Option<&'a Block<'a>>,\n     loop_label: Option<Name>,\n     // A list of functions that must be run at when leaving this\n     // block, cleaning up any variables that were introduced in the\n@@ -581,7 +588,7 @@ pub struct ScopeInfo {\n     node_info: Option<NodeInfo>,\n }\n \n-impl ScopeInfo {\n+impl<'a> ScopeInfo<'a> {\n     pub fn empty_cleanups(&self) -> bool {\n         let cleanups = self.cleanups.borrow();\n         cleanups.get().is_empty()\n@@ -625,7 +632,7 @@ pub struct NodeInfo {\n // code.  Each basic block we generate is attached to a function, typically\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n-pub struct Block {\n+pub struct Block<'a> {\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n@@ -634,39 +641,42 @@ pub struct Block {\n     llbb: BasicBlockRef,\n     terminated: Cell<bool>,\n     unreachable: Cell<bool>,\n-    parent: Option<@Block>,\n+    parent: Option<&'a Block<'a>>,\n     // The current scope within this basic block\n-    scope: RefCell<Option<@ScopeInfo>>,\n+    scope: RefCell<Option<&'a ScopeInfo<'a>>>,\n     // Is this block part of a landing pad?\n     is_lpad: bool,\n     // info about the AST node this block originated from, if any\n     node_info: Option<NodeInfo>,\n     // The function context for the function to which this block is\n     // attached.\n-    fcx: @FunctionContext\n+    fcx: &'a FunctionContext<'a>,\n }\n \n-impl Block {\n-    pub fn new(llbb: BasicBlockRef,\n-               parent: Option<@Block>,\n+impl<'a> Block<'a> {\n+    pub fn new<'a>(\n+               llbb: BasicBlockRef,\n+               parent: Option<&'a Block<'a>>,\n                is_lpad: bool,\n                node_info: Option<NodeInfo>,\n-               fcx: @FunctionContext)\n-               -> Block {\n-        Block {\n+               fcx: &'a FunctionContext<'a>)\n+               -> &'a Block<'a> {\n+        fcx.block_arena.alloc(Block {\n             llbb: llbb,\n             terminated: Cell::new(false),\n             unreachable: Cell::new(false),\n             parent: parent,\n             scope: RefCell::new(None),\n             is_lpad: is_lpad,\n             node_info: node_info,\n-            fcx: fcx\n-        }\n+            fcx: fcx,\n+        })\n     }\n \n     pub fn ccx(&self) -> @CrateContext { self.fcx.ccx }\n-    pub fn tcx(&self) -> ty::ctxt { self.fcx.ccx.tcx }\n+    pub fn tcx(&self) -> ty::ctxt {\n+        self.fcx.ccx.tcx\n+    }\n     pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n \n     pub fn ident(&self, ident: Ident) -> @str {\n@@ -722,17 +732,20 @@ impl Block {\n     }\n }\n \n-pub struct Result {\n-    bcx: @Block,\n+pub struct Result<'a> {\n+    bcx: &'a Block<'a>,\n     val: ValueRef\n }\n \n-pub fn rslt(bcx: @Block, val: ValueRef) -> Result {\n-    Result {bcx: bcx, val: val}\n+pub fn rslt<'a>(bcx: &'a Block<'a>, val: ValueRef) -> Result<'a> {\n+    Result {\n+        bcx: bcx,\n+        val: val,\n+    }\n }\n \n-impl Result {\n-    pub fn unpack(&self, bcx: &mut @Block) -> ValueRef {\n+impl<'a> Result<'a> {\n+    pub fn unpack(&self, bcx: &mut &'a Block<'a>) -> ValueRef {\n         *bcx = self.bcx;\n         return self.val;\n     }\n@@ -744,9 +757,10 @@ pub fn val_ty(v: ValueRef) -> Type {\n     }\n }\n \n-pub fn in_scope_cx(cx: @Block,\n+pub fn in_scope_cx<'a>(\n+                   cx: &'a Block<'a>,\n                    scope_id: Option<ast::NodeId>,\n-                   f: |si: &ScopeInfo|) {\n+                   f: |si: &'a ScopeInfo<'a>|) {\n     let mut cur = cx;\n     let mut cur_scope = cur.scope.get();\n     loop {\n@@ -776,7 +790,7 @@ pub fn in_scope_cx(cx: @Block,\n     }\n }\n \n-pub fn block_parent(cx: @Block) -> @Block {\n+pub fn block_parent<'a>(cx: &'a Block<'a>) -> &'a Block<'a> {\n     match cx.parent {\n       Some(b) => b,\n       None    => cx.sess().bug(format!(\"block_parent called on root block {:?}\",\n@@ -1048,17 +1062,17 @@ pub struct mono_id_ {\n \n pub type mono_id = @mono_id_;\n \n-pub fn umax(cx: @Block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umax(cx: &Block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     return build::Select(cx, cond, b, a);\n }\n \n-pub fn umin(cx: @Block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umin(cx: &Block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     return build::Select(cx, cond, a, b);\n }\n \n-pub fn align_to(cx: @Block, off: ValueRef, align: ValueRef) -> ValueRef {\n+pub fn align_to(cx: &Block, off: ValueRef, align: ValueRef) -> ValueRef {\n     let mask = build::Sub(cx, align, C_int(cx.ccx(), 1));\n     let bumped = build::Add(cx, off, mask);\n     return build::And(cx, bumped, build::Not(cx, mask));\n@@ -1132,7 +1146,7 @@ pub fn node_id_type_params(bcx: &Block, id: ast::NodeId) -> ~[ty::t] {\n     }\n }\n \n-pub fn node_vtables(bcx: @Block, id: ast::NodeId)\n+pub fn node_vtables(bcx: &Block, id: ast::NodeId)\n                  -> Option<typeck::vtable_res> {\n     let vtable_map = bcx.ccx().maps.vtable_map.borrow();\n     let raw_vtables = vtable_map.get().find(&id);\n@@ -1233,8 +1247,8 @@ pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n     }\n }\n \n-pub fn filename_and_line_num_from_span(bcx: @Block,\n-                                       span: Span) -> (ValueRef, ValueRef) {\n+pub fn filename_and_line_num_from_span(bcx: &Block, span: Span)\n+                                       -> (ValueRef, ValueRef) {\n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n     let filename_cstr = C_cstr(bcx.ccx(), loc.file.name);\n     let filename = build::PointerCast(bcx, filename_cstr, Type::i8p());\n@@ -1243,12 +1257,15 @@ pub fn filename_and_line_num_from_span(bcx: @Block,\n }\n \n // Casts a Rust bool value to an i1.\n-pub fn bool_to_i1(bcx: @Block, llval: ValueRef) -> ValueRef {\n+pub fn bool_to_i1(bcx: &Block, llval: ValueRef) -> ValueRef {\n     build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))\n }\n \n-pub fn langcall(bcx: @Block, span: Option<Span>, msg: &str,\n-                li: LangItem) -> ast::DefId {\n+pub fn langcall(bcx: &Block,\n+                span: Option<Span>,\n+                msg: &str,\n+                li: LangItem)\n+                -> ast::DefId {\n     match bcx.tcx().lang_items.require(li) {\n         Ok(id) => id,\n         Err(s) => {"}, {"sha": "97e338eab856573f392f5fb63cfa813565f3f899", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 52, "deletions": 27, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -28,7 +28,8 @@ use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit::Visitor;\n \n-pub fn trans_block(bcx: @Block, b: &ast::Block, dest: expr::Dest) -> @Block {\n+pub fn trans_block<'a>(bcx: &'a Block<'a>, b: &ast::Block, dest: expr::Dest)\n+                   -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     for s in b.stmts.iter() {\n@@ -45,12 +46,13 @@ pub fn trans_block(bcx: @Block, b: &ast::Block, dest: expr::Dest) -> @Block {\n     return bcx;\n }\n \n-pub fn trans_if(bcx: @Block,\n-            cond: &ast::Expr,\n-            thn: ast::P<ast::Block>,\n-            els: Option<@ast::Expr>,\n-            dest: expr::Dest)\n-         -> @Block {\n+pub fn trans_if<'a>(\n+                bcx: &'a Block<'a>,\n+                cond: &ast::Expr,\n+                thn: ast::P<ast::Block>,\n+                els: Option<@ast::Expr>,\n+                dest: expr::Dest)\n+                -> &'a Block<'a> {\n     debug!(\"trans_if(bcx={}, cond={}, thn={:?}, dest={})\",\n            bcx.to_str(), bcx.expr_to_str(cond), thn.id,\n            dest.to_str(bcx.ccx()));\n@@ -137,8 +139,12 @@ pub fn trans_if(bcx: @Block,\n     return next_bcx;\n \n     // trans `else [ if { .. } ... | { .. } ]`\n-    fn trans_if_else(else_bcx_in: @Block, elexpr: @ast::Expr,\n-                     dest: expr::Dest, cleanup: bool) -> @Block {\n+    fn trans_if_else<'a>(\n+                     else_bcx_in: &'a Block<'a>,\n+                     elexpr: @ast::Expr,\n+                     dest: expr::Dest,\n+                     cleanup: bool)\n+                     -> &'a Block<'a> {\n         let else_bcx_out = match elexpr.node {\n             ast::ExprIf(_, _, _) => {\n                 let elseif_blk = ast_util::block_from_expr(elexpr);\n@@ -159,7 +165,10 @@ pub fn trans_if(bcx: @Block,\n     }\n }\n \n-pub fn join_blocks(parent_bcx: @Block, in_cxs: &[@Block]) -> @Block {\n+pub fn join_blocks<'a>(\n+                   parent_bcx: &'a Block<'a>,\n+                   in_cxs: &[&'a Block<'a>])\n+                   -> &'a Block<'a> {\n     let out = sub_block(parent_bcx, \"join\");\n     let mut reachable = false;\n     for bcx in in_cxs.iter() {\n@@ -174,7 +183,11 @@ pub fn join_blocks(parent_bcx: @Block, in_cxs: &[@Block]) -> @Block {\n     return out;\n }\n \n-pub fn trans_while(bcx: @Block, cond: &ast::Expr, body: &ast::Block) -> @Block {\n+pub fn trans_while<'a>(\n+                   bcx: &'a Block<'a>,\n+                   cond: &ast::Expr,\n+                   body: &ast::Block)\n+                   -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_while\");\n     let next_bcx = sub_block(bcx, \"while next\");\n \n@@ -213,10 +226,11 @@ pub fn trans_while(bcx: @Block, cond: &ast::Expr, body: &ast::Block) -> @Block {\n     return next_bcx;\n }\n \n-pub fn trans_loop(bcx:@Block,\n+pub fn trans_loop<'a>(\n+                  bcx: &'a Block<'a>,\n                   body: &ast::Block,\n                   opt_label: Option<Name>)\n-               -> @Block {\n+                  -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_loop\");\n     let next_bcx = sub_block(bcx, \"next\");\n     let body_bcx_in = loop_scope_block(bcx, next_bcx, opt_label, \"`loop`\",\n@@ -227,18 +241,19 @@ pub fn trans_loop(bcx:@Block,\n     return next_bcx;\n }\n \n-pub fn trans_break_cont(bcx: @Block,\n+pub fn trans_break_cont<'a>(\n+                        bcx: &'a Block<'a>,\n                         opt_label: Option<Name>,\n                         to_end: bool)\n-                     -> @Block {\n+                        -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n     let mut cur_scope = unwind.scope.get();\n     let mut target;\n     loop {\n         cur_scope = match cur_scope {\n-            Some(@ScopeInfo {\n+            Some(&ScopeInfo {\n                 loop_break: Some(brk),\n                 loop_label: l,\n                 parent,\n@@ -283,15 +298,18 @@ pub fn trans_break_cont(bcx: @Block,\n     return bcx;\n }\n \n-pub fn trans_break(bcx: @Block, label_opt: Option<Name>) -> @Block {\n+pub fn trans_break<'a>(bcx: &'a Block<'a>, label_opt: Option<Name>)\n+                   -> &'a Block<'a> {\n     return trans_break_cont(bcx, label_opt, true);\n }\n \n-pub fn trans_cont(bcx: @Block, label_opt: Option<Name>) -> @Block {\n+pub fn trans_cont<'a>(bcx: &'a Block<'a>, label_opt: Option<Name>)\n+                  -> &'a Block<'a> {\n     return trans_break_cont(bcx, label_opt, false);\n }\n \n-pub fn trans_ret(bcx: @Block, e: Option<@ast::Expr>) -> @Block {\n+pub fn trans_ret<'a>(bcx: &'a Block<'a>, e: Option<@ast::Expr>)\n+                 -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n     let dest = match bcx.fcx.llretptr.get() {\n@@ -309,10 +327,11 @@ pub fn trans_ret(bcx: @Block, e: Option<@ast::Expr>) -> @Block {\n     return bcx;\n }\n \n-pub fn trans_fail_expr(bcx: @Block,\n+pub fn trans_fail_expr<'a>(\n+                       bcx: &'a Block<'a>,\n                        sp_opt: Option<Span>,\n                        fail_expr: Option<@ast::Expr>)\n-                    -> @Block {\n+                       -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_fail_expr\");\n     let mut bcx = bcx;\n     match fail_expr {\n@@ -337,19 +356,21 @@ pub fn trans_fail_expr(bcx: @Block,\n     }\n }\n \n-pub fn trans_fail(bcx: @Block,\n+pub fn trans_fail<'a>(\n+                  bcx: &'a Block<'a>,\n                   sp_opt: Option<Span>,\n                   fail_str: @str)\n-               -> @Block {\n+                  -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n     return trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n-fn trans_fail_value(bcx: @Block,\n+fn trans_fail_value<'a>(\n+                    bcx: &'a Block<'a>,\n                     sp_opt: Option<Span>,\n                     V_fail_str: ValueRef)\n-                 -> @Block {\n+                    -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n     let (V_filename, V_line) = match sp_opt {\n@@ -372,8 +393,12 @@ fn trans_fail_value(bcx: @Block,\n     return bcx;\n }\n \n-pub fn trans_fail_bounds_check(bcx: @Block, sp: Span,\n-                               index: ValueRef, len: ValueRef) -> @Block {\n+pub fn trans_fail_bounds_check<'a>(\n+                               bcx: &'a Block<'a>,\n+                               sp: Span,\n+                               index: ValueRef,\n+                               len: ValueRef)\n+                               -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n     let (filename, line) = filename_and_line_num_from_span(bcx, sp);\n     let args = ~[filename, line, index, len];"}, {"sha": "b34e68d9a57b7217f71ee1efe8e3033fec01b9db", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 105, "deletions": 77, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -125,8 +125,8 @@ pub struct Datum {\n     mode: DatumMode,\n }\n \n-pub struct DatumBlock {\n-    bcx: @Block,\n+pub struct DatumBlock<'a> {\n+    bcx: &'a Block<'a>,\n     datum: Datum,\n }\n \n@@ -163,14 +163,16 @@ pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum {\n     return Datum {val: val, ty: ty, mode: ByValue};\n }\n \n-pub fn immediate_rvalue_bcx(bcx: @Block,\n-                            val: ValueRef,\n-                            ty: ty::t)\n-                         -> DatumBlock {\n-    return DatumBlock {bcx: bcx, datum: immediate_rvalue(val, ty)};\n+pub fn immediate_rvalue_bcx<'a>(bcx: &'a Block<'a>, val: ValueRef, ty: ty::t)\n+                            -> DatumBlock<'a> {\n+    DatumBlock {\n+        bcx: bcx,\n+        datum: immediate_rvalue(val, ty),\n+    }\n }\n \n-pub fn scratch_datum(bcx: @Block, ty: ty::t, name: &str, zero: bool) -> Datum {\n+pub fn scratch_datum(bcx: &Block, ty: ty::t, name: &str, zero: bool)\n+                     -> Datum {\n     /*!\n      * Allocates temporary space on the stack using alloca() and\n      * returns a by-ref Datum pointing to it.  If `zero` is true, the\n@@ -203,11 +205,12 @@ pub fn appropriate_mode(ccx: &CrateContext, ty: ty::t) -> DatumMode {\n }\n \n impl Datum {\n-    pub fn store_to(&self,\n-                    bcx: @Block,\n+    pub fn store_to<'a>(\n+                    &self,\n+                    bcx: &'a Block<'a>,\n                     action: CopyAction,\n                     dst: ValueRef)\n-                    -> @Block {\n+                    -> &'a Block<'a> {\n         /*!\n          *\n          * Stores this value into its final home.  This moves if\n@@ -221,10 +224,8 @@ impl Datum {\n         }\n     }\n \n-    pub fn store_to_dest(&self,\n-                         bcx: @Block,\n-                         dest: expr::Dest)\n-                         -> @Block {\n+    pub fn store_to_dest<'a>(&self, bcx: &'a Block<'a>, dest: expr::Dest)\n+                         -> &'a Block<'a> {\n         match dest {\n             expr::Ignore => {\n                 return bcx;\n@@ -235,31 +236,44 @@ impl Datum {\n         }\n     }\n \n-    pub fn store_to_datum(&self,\n-                          bcx: @Block,\n+    pub fn store_to_datum<'a>(\n+                          &self,\n+                          bcx: &'a Block<'a>,\n                           action: CopyAction,\n                           datum: Datum)\n-                          -> @Block {\n+                          -> &'a Block<'a> {\n         debug!(\"store_to_datum(self={}, action={:?}, datum={})\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n         assert!(datum.mode.is_by_ref());\n         self.store_to(bcx, action, datum.val)\n     }\n \n-    pub fn move_to_datum(&self, bcx: @Block, action: CopyAction, datum: Datum)\n-                         -> @Block {\n+    pub fn move_to_datum<'a>(\n+                         &self,\n+                         bcx: &'a Block<'a>,\n+                         action: CopyAction,\n+                         datum: Datum)\n+                         -> &'a Block<'a> {\n         assert!(datum.mode.is_by_ref());\n         self.move_to(bcx, action, datum.val)\n     }\n \n-    pub fn copy_to_datum(&self, bcx: @Block, action: CopyAction, datum: Datum)\n-                         -> @Block {\n+    pub fn copy_to_datum<'a>(\n+                         &self,\n+                         bcx: &'a Block<'a>,\n+                         action: CopyAction,\n+                         datum: Datum)\n+                         -> &'a Block<'a> {\n         assert!(datum.mode.is_by_ref());\n         self.copy_to(bcx, action, datum.val)\n     }\n \n-    pub fn copy_to(&self, bcx: @Block, action: CopyAction, dst: ValueRef)\n-                   -> @Block {\n+    pub fn copy_to<'a>(\n+                   &self,\n+                   bcx: &'a Block<'a>,\n+                   action: CopyAction,\n+                   dst: ValueRef)\n+                   -> &'a Block<'a> {\n         /*!\n          *\n          * Copies the value into `dst`, which should be a pointer to a\n@@ -301,11 +315,12 @@ impl Datum {\n         }\n     }\n \n-    pub fn copy_to_no_check(&self,\n-                            bcx: @Block,\n+    pub fn copy_to_no_check<'a>(\n+                            &self,\n+                            bcx: &'a Block<'a>,\n                             action: CopyAction,\n                             dst: ValueRef)\n-                            -> @Block {\n+                            -> &'a Block<'a> {\n         /*!\n          *\n          * A helper for `copy_to()` which does not check to see if we\n@@ -333,8 +348,12 @@ impl Datum {\n     // This works like copy_val, except that it deinitializes the source.\n     // Since it needs to zero out the source, src also needs to be an lval.\n     //\n-    pub fn move_to(&self, bcx: @Block, action: CopyAction, dst: ValueRef)\n-                   -> @Block {\n+    pub fn move_to<'a>(\n+                   &self,\n+                   bcx: &'a Block<'a>,\n+                   action: CopyAction,\n+                   dst: ValueRef)\n+                   -> &'a Block<'a> {\n         let _icx = push_ctxt(\"move_to\");\n         let mut bcx = bcx;\n \n@@ -363,7 +382,7 @@ impl Datum {\n         return bcx;\n     }\n \n-    pub fn add_clean(&self, bcx: @Block) {\n+    pub fn add_clean(&self, bcx: &Block) {\n         /*!\n          * Schedules this datum for cleanup in `bcx`.  The datum\n          * must be an rvalue.\n@@ -383,7 +402,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn cancel_clean(&self, bcx: @Block) {\n+    pub fn cancel_clean(&self, bcx: &Block) {\n         if ty::type_needs_drop(bcx.tcx(), self.ty) {\n             match self.mode {\n                 ByValue |\n@@ -408,7 +427,7 @@ impl Datum {\n              self.mode)\n     }\n \n-    pub fn to_value_datum(&self, bcx: @Block) -> Datum {\n+    pub fn to_value_datum(&self, bcx: &Block) -> Datum {\n         /*!\n          *\n          * Yields a by-value form of this datum.  This may involve\n@@ -425,7 +444,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_value_llval(&self, bcx: @Block) -> ValueRef {\n+    pub fn to_value_llval(&self, bcx: &Block) -> ValueRef {\n         /*!\n          *\n          * Yields the value itself. */\n@@ -446,7 +465,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_ref_datum(&self, bcx: @Block) -> Datum {\n+    pub fn to_ref_datum(&self, bcx: &Block) -> Datum {\n         /*!\n          * Yields a by-ref form of this datum.  This may involve\n          * creation of a temporary stack slot.  The value returned by\n@@ -463,7 +482,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_ref_llval(&self, bcx: @Block) -> ValueRef {\n+    pub fn to_ref_llval(&self, bcx: &Block) -> ValueRef {\n         match self.mode {\n             ByRef(_) => self.val,\n             ByValue => {\n@@ -496,7 +515,7 @@ impl Datum {\n         appropriate_mode(ccx, self.ty)\n     }\n \n-    pub fn to_appropriate_llval(&self, bcx: @Block) -> ValueRef {\n+    pub fn to_appropriate_llval(&self, bcx: &Block) -> ValueRef {\n         /*!\n          *\n          * Yields an llvalue with the `appropriate_mode()`. */\n@@ -507,7 +526,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_appropriate_datum(&self, bcx: @Block) -> Datum {\n+    pub fn to_appropriate_datum(&self, bcx: &Block) -> Datum {\n         /*!\n          *\n          * Yields a datum with the `appropriate_mode()`. */\n@@ -519,7 +538,7 @@ impl Datum {\n     }\n \n     pub fn get_element(&self,\n-                       bcx: @Block,\n+                       bcx: &Block,\n                        ty: ty::t,\n                        source: DatumCleanup,\n                        gep: |ValueRef| -> ValueRef)\n@@ -532,7 +551,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn drop_val(&self, bcx: @Block) -> @Block {\n+    pub fn drop_val<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n         if !ty::type_needs_drop(bcx.tcx(), self.ty) {\n             return bcx;\n         }\n@@ -543,7 +562,7 @@ impl Datum {\n         };\n     }\n \n-    pub fn box_body(&self, bcx: @Block) -> Datum {\n+    pub fn box_body(&self, bcx: &Block) -> Datum {\n         /*!\n          *\n          * This datum must represent an @T or ~T box.  Returns a new\n@@ -576,7 +595,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn to_rptr(&self, bcx: @Block) -> Datum {\n+    pub fn to_rptr(&self, bcx: &Block) -> Datum {\n         //! Returns a new datum of region-pointer type containing the\n         //! the same ptr as this datum (after converting to by-ref\n         //! using `to_ref_llval()`).\n@@ -596,13 +615,14 @@ impl Datum {\n     /// expr_id: ID of deref expr.\n     /// derefs: Number of times deref'd already.\n     /// is_auto: If true, only deref if auto-derefable.\n-    pub fn try_deref(&self,\n-                     bcx: @Block,\n+    pub fn try_deref<'a>(\n+                     &self,\n+                     bcx: &'a Block<'a>,\n                      span: Span,\n                      expr_id: ast::NodeId,\n                      derefs: uint,\n                      is_auto: bool)\n-                     -> (Option<Datum>, @Block) {\n+                     -> (Option<Datum>, &'a Block<'a>) {\n         debug!(\"try_deref(expr_id={:?}, derefs={:?}, is_auto={}, self={:?})\",\n                expr_id, derefs, is_auto, self.to_str(bcx.ccx()));\n \n@@ -629,7 +649,7 @@ impl Datum {\n             }\n         }\n \n-        fn deref_ptr(bcx: @Block, lv: &Datum, ty: ty::t) -> Datum {\n+        fn deref_ptr(bcx: &Block, lv: &Datum, ty: ty::t) -> Datum {\n             Datum {\n                 val: lv.to_value_llval(bcx),\n                 ty: ty,\n@@ -639,8 +659,12 @@ impl Datum {\n     }\n \n     /// expr: The deref expression.\n-    pub fn deref(&self, bcx: @Block, expr: &ast::Expr, derefs: uint)\n-                 -> DatumBlock {\n+    pub fn deref<'a>(\n+                 &self,\n+                 bcx: &'a Block<'a>,\n+                 expr: &ast::Expr,\n+                 derefs: uint)\n+                 -> DatumBlock<'a> {\n         match self.try_deref(bcx, expr.span, expr.id, derefs, false) {\n             (Some(lvres), bcx) => DatumBlock { bcx: bcx, datum: lvres },\n             (None, _) => {\n@@ -650,12 +674,13 @@ impl Datum {\n         }\n     }\n \n-    pub fn autoderef(&self,\n-                     bcx: @Block,\n+    pub fn autoderef<'a>(\n+                     &self,\n+                     bcx: &'a Block<'a>,\n                      span: Span,\n                      expr_id: ast::NodeId,\n                      max: uint)\n-                     -> DatumBlock {\n+                     -> DatumBlock<'a> {\n         let _icx = push_ctxt(\"autoderef\");\n \n         debug!(\"autoderef(expr_id={}, max={:?}, self={:?})\",\n@@ -683,12 +708,13 @@ impl Datum {\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n \n-    pub fn get_vec_base_and_byte_len(&self,\n-                                     mut bcx: @Block,\n+    pub fn get_vec_base_and_byte_len<'a>(\n+                                     &self,\n+                                     mut bcx: &'a Block<'a>,\n                                      span: Span,\n                                      expr_id: ast::NodeId,\n                                      derefs: uint)\n-                                     -> (@Block, ValueRef, ValueRef) {\n+                                     -> (&'a Block<'a>, ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Performs rooting\n         //! and write guards checks.\n \n@@ -698,7 +724,7 @@ impl Datum {\n         (bcx, base, len)\n     }\n \n-    pub fn get_vec_base_and_byte_len_no_root(&self, bcx: @Block)\n+    pub fn get_vec_base_and_byte_len_no_root(&self, bcx: &Block)\n                                              -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Des not root\n         //! nor perform write guard checks.\n@@ -707,12 +733,13 @@ impl Datum {\n         tvec::get_base_and_byte_len(bcx, llval, self.ty)\n     }\n \n-    pub fn get_vec_base_and_len(&self,\n-                                     mut bcx: @Block,\n-                                     span: Span,\n-                                     expr_id: ast::NodeId,\n-                                     derefs: uint)\n-                                     -> (@Block, ValueRef, ValueRef) {\n+    pub fn get_vec_base_and_len<'a>(\n+                                &self,\n+                                mut bcx: &'a Block<'a>,\n+                                span: Span,\n+                                expr_id: ast::NodeId,\n+                                derefs: uint)\n+                                -> (&'a Block<'a>, ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Performs rooting\n         //! and write guards checks.\n \n@@ -722,64 +749,65 @@ impl Datum {\n         (bcx, base, len)\n     }\n \n-    pub fn get_vec_base_and_len_no_root(&self, bcx: @Block)\n-                                             -> (ValueRef, ValueRef) {\n+    pub fn get_vec_base_and_len_no_root<'a>(&self, bcx: &'a Block<'a>)\n+                                        -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Des not root\n         //! nor perform write guard checks.\n \n         let llval = self.to_appropriate_llval(bcx);\n         tvec::get_base_and_len(bcx, llval, self.ty)\n     }\n \n-    pub fn root_and_write_guard(&self,\n-                                bcx: @Block,\n+    pub fn root_and_write_guard<'a>(\n+                                &self,\n+                                bcx: &'a Block<'a>,\n                                 span: Span,\n                                 expr_id: ast::NodeId,\n                                 derefs: uint)\n-                                -> @Block {\n+                                -> &'a Block<'a> {\n         write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs)\n     }\n \n-    pub fn to_result(&self, bcx: @Block) -> common::Result {\n+    pub fn to_result<'a>(&self, bcx: &'a Block<'a>) -> common::Result<'a> {\n         rslt(bcx, self.to_appropriate_llval(bcx))\n     }\n }\n \n-impl DatumBlock {\n-    pub fn unpack(&self, bcx: &mut @Block) -> Datum {\n+impl<'a> DatumBlock<'a> {\n+    pub fn unpack(&self, bcx: &mut &'a Block<'a>) -> Datum {\n         *bcx = self.bcx;\n         return self.datum;\n     }\n \n-    pub fn assert_by_ref(&self) -> DatumBlock {\n+    pub fn assert_by_ref(&self) -> DatumBlock<'a> {\n         assert!(self.datum.mode.is_by_ref());\n         *self\n     }\n \n-    pub fn drop_val(&self) -> @Block {\n+    pub fn drop_val(&self) -> &'a Block<'a> {\n         self.datum.drop_val(self.bcx)\n     }\n \n-    pub fn store_to(&self,\n-                    action: CopyAction,\n-                    dst: ValueRef)\n-                    -> @Block {\n+    pub fn store_to(&self, action: CopyAction, dst: ValueRef)\n+                    -> &'a Block<'a> {\n         self.datum.store_to(self.bcx, action, dst)\n     }\n \n-    pub fn copy_to(&self, action: CopyAction, dst: ValueRef) -> @Block {\n+    pub fn copy_to(&self, action: CopyAction, dst: ValueRef)\n+                   -> &'a Block<'a> {\n         self.datum.copy_to(self.bcx, action, dst)\n     }\n \n-    pub fn move_to(&self, action: CopyAction, dst: ValueRef) -> @Block {\n+    pub fn move_to(&self, action: CopyAction, dst: ValueRef)\n+                   -> &'a Block<'a> {\n         self.datum.move_to(self.bcx, action, dst)\n     }\n \n     pub fn to_value_llval(&self) -> ValueRef {\n         self.datum.to_value_llval(self.bcx)\n     }\n \n-    pub fn to_result(&self) -> common::Result {\n+    pub fn to_result(&self) -> common::Result<'a> {\n         rslt(self.bcx, self.datum.to_appropriate_llval(self.bcx))\n     }\n "}, {"sha": "549e5d18fbeadae5d2fc4acec5321cfa342d1cbf", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -270,8 +270,7 @@ pub fn finalize(cx: @CrateContext) {\n /// Creates debug information for the given local variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_local_var_metadata(bcx: @Block,\n-                                 local: &ast::Local) {\n+pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n@@ -310,7 +309,7 @@ pub fn create_local_var_metadata(bcx: @Block,\n /// Creates debug information for a variable captured in a closure.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_captured_var_metadata(bcx: @Block,\n+pub fn create_captured_var_metadata(bcx: &Block,\n                                     node_id: ast::NodeId,\n                                     env_data_type: ty::t,\n                                     env_pointer: ValueRef,\n@@ -380,7 +379,7 @@ pub fn create_captured_var_metadata(bcx: @Block,\n /// Creates debug information for a local variable introduced in the head of a match-statement arm.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_match_binding_metadata(bcx: @Block,\n+pub fn create_match_binding_metadata(bcx: &Block,\n                                      variable_ident: ast::Ident,\n                                      node_id: ast::NodeId,\n                                      variable_type: ty::t,\n@@ -417,7 +416,7 @@ pub fn create_match_binding_metadata(bcx: @Block,\n /// Creates debug information for the self argument of a method.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_self_argument_metadata(bcx: @Block,\n+pub fn create_self_argument_metadata(bcx: &Block,\n                                      type_of_self: ty::t,\n                                      llptr: ValueRef) {\n     if fn_should_be_ignored(bcx.fcx) {\n@@ -495,8 +494,7 @@ pub fn create_self_argument_metadata(bcx: @Block,\n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_argument_metadata(bcx: @Block,\n-                                arg: &ast::arg) {\n+pub fn create_argument_metadata(bcx: &Block, arg: &ast::arg) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n@@ -973,7 +971,7 @@ fn compile_unit_metadata(cx: @CrateContext) {\n     });\n }\n \n-fn declare_local(bcx: @Block,\n+fn declare_local(bcx: &Block,\n                  variable_ident: ast::Ident,\n                  variable_type: ty::t,\n                  scope_metadata: DIScope,"}, {"sha": "422e70425054edbc9e35b15ad2aff67e28d2b6a3", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 138, "deletions": 71, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -175,7 +175,8 @@ impl Dest {\n     }\n }\n \n-pub fn trans_to_datum(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n+pub fn trans_to_datum<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n+                      -> DatumBlock<'a> {\n     debug!(\"trans_to_datum(expr={})\", bcx.expr_to_str(expr));\n \n     let mut bcx = bcx;\n@@ -249,13 +250,15 @@ pub fn trans_to_datum(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     debug!(\"after adjustments, datum={}\", datum.to_str(bcx.ccx()));\n     return DatumBlock {bcx: bcx, datum: datum};\n \n-    fn auto_ref(bcx: @Block, datum: Datum) -> DatumBlock {\n+    fn auto_ref<'a>(bcx: &'a Block<'a>, datum: Datum) -> DatumBlock<'a> {\n         DatumBlock {bcx: bcx, datum: datum.to_rptr(bcx)}\n     }\n \n-    fn auto_borrow_fn(bcx: @Block,\n+    fn auto_borrow_fn<'a>(\n+                      bcx: &'a Block<'a>,\n                       adjusted_ty: ty::t,\n-                      datum: Datum) -> DatumBlock {\n+                      datum: Datum)\n+                      -> DatumBlock<'a> {\n         // Currently, all closure types are represented precisely the\n         // same, so no runtime adjustment is required, but we still\n         // must patchup the type.\n@@ -264,10 +267,12 @@ pub fn trans_to_datum(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n                                   mode: datum.mode}}\n     }\n \n-    fn auto_slice(bcx: @Block,\n+    fn auto_slice<'a>(\n+                  bcx: &'a Block<'a>,\n                   autoderefs: uint,\n                   expr: &ast::Expr,\n-                  datum: Datum) -> DatumBlock {\n+                  datum: Datum)\n+                  -> DatumBlock<'a> {\n         // This is not the most efficient thing possible; since slices\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -293,7 +298,8 @@ pub fn trans_to_datum(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n-    fn add_env(bcx: @Block, expr: &ast::Expr, datum: Datum) -> DatumBlock {\n+    fn add_env<'a>(bcx: &'a Block<'a>, expr: &ast::Expr, datum: Datum)\n+               -> DatumBlock<'a> {\n         // This is not the most efficient thing possible; since closures\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -312,18 +318,22 @@ pub fn trans_to_datum(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n-    fn auto_slice_and_ref(bcx: @Block,\n+    fn auto_slice_and_ref<'a>(\n+                          bcx: &'a Block<'a>,\n                           autoderefs: uint,\n                           expr: &ast::Expr,\n-                          datum: Datum) -> DatumBlock {\n+                          datum: Datum)\n+                          -> DatumBlock<'a> {\n         let DatumBlock { bcx, datum } = auto_slice(bcx, autoderefs, expr, datum);\n         auto_ref(bcx, datum)\n     }\n \n-    fn auto_borrow_obj(mut bcx: @Block,\n+    fn auto_borrow_obj<'a>(\n+                       mut bcx: &'a Block<'a>,\n                        autoderefs: uint,\n                        expr: &ast::Expr,\n-                       source_datum: Datum) -> DatumBlock {\n+                       source_datum: Datum)\n+                       -> DatumBlock<'a> {\n         let tcx = bcx.tcx();\n         let target_obj_ty = expr_ty_adjusted(bcx, expr);\n         debug!(\"auto_borrow_obj(target={})\",\n@@ -428,7 +438,8 @@ pub fn trans_to_datum(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     }\n }\n \n-pub fn trans_into(bcx: @Block, expr: &ast::Expr, dest: Dest) -> @Block {\n+pub fn trans_into<'a>(bcx: &'a Block<'a>, expr: &ast::Expr, dest: Dest)\n+                  -> &'a Block<'a> {\n     let adjustment_found = {\n         let adjustments = bcx.tcx().adjustments.borrow();\n         adjustments.get().contains_key(&expr.id)\n@@ -446,7 +457,11 @@ pub fn trans_into(bcx: @Block, expr: &ast::Expr, dest: Dest) -> @Block {\n     trans_into_unadjusted(bcx, expr, dest)\n }\n \n-pub fn trans_into_unadjusted(bcx: @Block, expr: &ast::Expr, dest: Dest) -> @Block {\n+pub fn trans_into_unadjusted<'a>(\n+                             bcx: &'a Block<'a>,\n+                             expr: &ast::Expr,\n+                             dest: Dest)\n+                             -> &'a Block<'a> {\n     let ty = expr_ty(bcx, expr);\n \n     debug!(\"trans_into_unadjusted(expr={}, dest={})\",\n@@ -494,7 +509,7 @@ pub fn trans_into_unadjusted(bcx: @Block, expr: &ast::Expr, dest: Dest) -> @Bloc\n     };\n }\n \n-fn trans_lvalue(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n+fn trans_lvalue<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> DatumBlock<'a> {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n@@ -517,7 +532,8 @@ fn trans_lvalue(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     }\n }\n \n-fn trans_to_datum_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n+fn trans_to_datum_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n+                             -> DatumBlock<'a> {\n     /*!\n      * Translates an expression into a datum.  If this expression\n      * is an rvalue, this will result in a temporary value being\n@@ -577,13 +593,17 @@ fn trans_to_datum_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n         }\n     }\n \n-    fn nil(bcx: @Block, ty: ty::t) -> DatumBlock {\n+    fn nil<'a>(bcx: &'a Block<'a>, ty: ty::t) -> DatumBlock<'a> {\n         let datum = immediate_rvalue(C_nil(), ty);\n-        DatumBlock {bcx: bcx, datum: datum}\n+        DatumBlock {\n+            bcx: bcx,\n+            datum: datum,\n+        }\n     }\n }\n \n-fn trans_rvalue_datum_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n+fn trans_rvalue_datum_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n+                                 -> DatumBlock<'a> {\n     let _icx = push_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n     match expr.node {\n@@ -636,7 +656,8 @@ fn trans_rvalue_datum_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     }\n }\n \n-fn trans_rvalue_stmt_unadjusted(bcx: @Block, expr: &ast::Expr) -> @Block {\n+fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n+                                -> &'a Block<'a> {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rvalue_stmt\");\n \n@@ -688,8 +709,11 @@ fn trans_rvalue_stmt_unadjusted(bcx: @Block, expr: &ast::Expr) -> @Block {\n     };\n }\n \n-fn trans_rvalue_dps_unadjusted(bcx: @Block, expr: &ast::Expr,\n-                               dest: Dest) -> @Block {\n+fn trans_rvalue_dps_unadjusted<'a>(\n+                               bcx: &'a Block<'a>,\n+                               expr: &ast::Expr,\n+                               dest: Dest)\n+                               -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n \n@@ -813,8 +837,12 @@ fn trans_rvalue_dps_unadjusted(bcx: @Block, expr: &ast::Expr,\n     }\n }\n \n-fn trans_def_dps_unadjusted(bcx: @Block, ref_expr: &ast::Expr,\n-                            def: ast::Def, dest: Dest) -> @Block {\n+fn trans_def_dps_unadjusted<'a>(\n+                            bcx: &'a Block<'a>,\n+                            ref_expr: &ast::Expr,\n+                            def: ast::Def,\n+                            dest: Dest)\n+                            -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n     let ccx = bcx.ccx();\n \n@@ -863,10 +891,11 @@ fn trans_def_dps_unadjusted(bcx: @Block, ref_expr: &ast::Expr,\n     }\n }\n \n-fn trans_def_datum_unadjusted(bcx: @Block,\n+fn trans_def_datum_unadjusted<'a>(\n+                              bcx: &'a Block<'a>,\n                               ref_expr: &ast::Expr,\n-                              def: ast::Def) -> DatumBlock\n-{\n+                              def: ast::Def)\n+                              -> DatumBlock<'a> {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     let fn_data = match def {\n@@ -898,7 +927,8 @@ fn trans_def_datum_unadjusted(bcx: @Block,\n     }\n }\n \n-fn trans_lvalue_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n+fn trans_lvalue_unadjusted<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n+                           -> DatumBlock<'a> {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n@@ -935,9 +965,11 @@ fn trans_lvalue_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n         }\n     };\n \n-    fn trans_rec_field(bcx: @Block,\n+    fn trans_rec_field<'a>(\n+                       bcx: &'a Block<'a>,\n                        base: &ast::Expr,\n-                       field: ast::Ident) -> DatumBlock {\n+                       field: ast::Ident)\n+                       -> DatumBlock<'a> {\n         //! Translates `base.field`.\n \n         let mut bcx = bcx;\n@@ -959,10 +991,12 @@ fn trans_lvalue_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n         })\n     }\n \n-    fn trans_index(bcx: @Block,\n+    fn trans_index<'a>(\n+                   bcx: &'a Block<'a>,\n                    index_expr: &ast::Expr,\n                    base: &ast::Expr,\n-                   idx: &ast::Expr) -> DatumBlock {\n+                   idx: &ast::Expr)\n+                   -> DatumBlock<'a> {\n         //! Translates `base[idx]`.\n \n         let _icx = push_ctxt(\"trans_index\");\n@@ -1013,11 +1047,11 @@ fn trans_lvalue_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n         };\n     }\n \n-    fn trans_def_lvalue(bcx: @Block,\n+    fn trans_def_lvalue<'a>(\n+                        bcx: &'a Block<'a>,\n                         ref_expr: &ast::Expr,\n                         def: ast::Def)\n-        -> DatumBlock\n-    {\n+                        -> DatumBlock<'a> {\n         //! Translates a reference to a path.\n \n         let _icx = push_ctxt(\"trans_def_lvalue\");\n@@ -1034,7 +1068,7 @@ fn trans_lvalue_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n                     }\n                 }\n \n-                fn get_val(bcx: @Block, did: ast::DefId, const_ty: ty::t)\n+                fn get_val(bcx: &Block, did: ast::DefId, const_ty: ty::t)\n                            -> ValueRef {\n                     // For external constants, we don't inline.\n                     if did.crate == ast::LOCAL_CRATE {\n@@ -1094,7 +1128,7 @@ fn trans_lvalue_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n     }\n }\n \n-pub fn trans_local_var(bcx: @Block, def: ast::Def) -> Datum {\n+pub fn trans_local_var(bcx: &Block, def: ast::Def) -> Datum {\n     let _icx = push_ctxt(\"trans_local_var\");\n \n     return match def {\n@@ -1149,9 +1183,10 @@ pub fn trans_local_var(bcx: @Block, def: ast::Def) -> Datum {\n         }\n     };\n \n-    fn take_local(bcx: @Block,\n+    fn take_local(bcx: &Block,\n                   table: &HashMap<ast::NodeId, ValueRef>,\n-                  nid: ast::NodeId) -> Datum {\n+                  nid: ast::NodeId)\n+                  -> Datum {\n         let v = match table.find(&nid) {\n             Some(&v) => v,\n             None => {\n@@ -1222,13 +1257,14 @@ pub fn with_field_tys<R>(\n     }\n }\n \n-fn trans_rec_or_struct(bcx: @Block,\n+fn trans_rec_or_struct<'a>(\n+                       bcx: &'a Block<'a>,\n                        fields: &[ast::Field],\n                        base: Option<@ast::Expr>,\n                        expr_span: codemap::Span,\n                        id: ast::NodeId,\n-                       dest: Dest) -> @Block\n-{\n+                       dest: Dest)\n+                       -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_rec\");\n     let bcx = bcx;\n \n@@ -1301,10 +1337,14 @@ struct StructBaseInfo {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-fn trans_adt(bcx: @Block, repr: &adt::Repr, discr: ty::Disr,\n+fn trans_adt<'a>(\n+             bcx: &'a Block<'a>,\n+             repr: &adt::Repr,\n+             discr: ty::Disr,\n              fields: &[(uint, @ast::Expr)],\n              optbase: Option<StructBaseInfo>,\n-             dest: Dest) -> @Block {\n+             dest: Dest)\n+             -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_adt\");\n     let mut bcx = bcx;\n     let addr = match dest {\n@@ -1349,18 +1389,23 @@ fn trans_adt(bcx: @Block, repr: &adt::Repr, discr: ty::Disr,\n }\n \n \n-fn trans_immediate_lit(bcx: @Block, expr: &ast::Expr,\n-                       lit: ast::lit) -> DatumBlock {\n+fn trans_immediate_lit<'a>(\n+                       bcx: &'a Block<'a>,\n+                       expr: &ast::Expr,\n+                       lit: ast::lit)\n+                       -> DatumBlock<'a> {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n     let ty = expr_ty(bcx, expr);\n     immediate_rvalue_bcx(bcx, consts::const_lit(bcx.ccx(), expr, lit), ty)\n }\n \n-fn trans_unary_datum(bcx: @Block,\n+fn trans_unary_datum<'a>(\n+                     bcx: &'a Block<'a>,\n                      un_expr: &ast::Expr,\n                      op: ast::UnOp,\n-                     sub_expr: &ast::Expr) -> DatumBlock {\n+                     sub_expr: &ast::Expr)\n+                     -> DatumBlock<'a> {\n     let _icx = push_ctxt(\"trans_unary_datum\");\n \n     // if deref, would be LvalueExpr\n@@ -1419,11 +1464,13 @@ fn trans_unary_datum(bcx: @Block,\n         }\n     };\n \n-    fn trans_boxed_expr(bcx: @Block,\n+    fn trans_boxed_expr<'a>(\n+                        bcx: &'a Block<'a>,\n                         box_ty: ty::t,\n                         contents: &ast::Expr,\n                         contents_ty: ty::t,\n-                        heap: heap) -> DatumBlock {\n+                        heap: heap)\n+                        -> DatumBlock<'a> {\n         let _icx = push_ctxt(\"trans_boxed_expr\");\n         if heap == heap_exchange {\n             let llty = type_of::type_of(bcx.ccx(), contents_ty);\n@@ -1448,8 +1495,11 @@ fn trans_unary_datum(bcx: @Block,\n     }\n }\n \n-fn trans_addr_of(bcx: @Block, expr: &ast::Expr,\n-                 subexpr: &ast::Expr) -> DatumBlock {\n+fn trans_addr_of<'a>(\n+                 bcx: &'a Block<'a>,\n+                 expr: &ast::Expr,\n+                 subexpr: &ast::Expr)\n+                 -> DatumBlock<'a> {\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n     let sub_datum = unpack_datum!(bcx, trans_to_datum(bcx, subexpr));\n@@ -1459,13 +1509,14 @@ fn trans_addr_of(bcx: @Block, expr: &ast::Expr,\n \n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n-fn trans_eager_binop(bcx: @Block,\n+fn trans_eager_binop<'a>(\n+                     bcx: &'a Block<'a>,\n                      binop_expr: &ast::Expr,\n                      binop_ty: ty::t,\n                      op: ast::BinOp,\n                      lhs_datum: &Datum,\n                      rhs_datum: &Datum)\n-                  -> DatumBlock {\n+                     -> DatumBlock<'a> {\n     let _icx = push_ctxt(\"trans_eager_binop\");\n \n     let lhs = lhs_datum.to_appropriate_llval(bcx);\n@@ -1560,13 +1611,18 @@ fn trans_eager_binop(bcx: @Block,\n }\n \n // refinement types would obviate the need for this\n-enum lazy_binop_ty { lazy_and, lazy_or }\n+enum lazy_binop_ty {\n+    lazy_and,\n+    lazy_or,\n+}\n \n-fn trans_lazy_binop(bcx: @Block,\n+fn trans_lazy_binop<'a>(\n+                    bcx: &'a Block<'a>,\n                     binop_expr: &ast::Expr,\n                     op: lazy_binop_ty,\n                     a: &ast::Expr,\n-                    b: &ast::Expr) -> DatumBlock {\n+                    b: &ast::Expr)\n+                    -> DatumBlock<'a> {\n     let _icx = push_ctxt(\"trans_lazy_binop\");\n     let binop_ty = expr_ty(bcx, binop_expr);\n     let bcx = bcx;\n@@ -1607,12 +1663,13 @@ fn trans_lazy_binop(bcx: @Block,\n     return immediate_rvalue_bcx(join, phi, binop_ty);\n }\n \n-fn trans_binary(bcx: @Block,\n+fn trans_binary<'a>(\n+                bcx: &'a Block<'a>,\n                 binop_expr: &ast::Expr,\n                 op: ast::BinOp,\n                 lhs: &ast::Expr,\n-                rhs: &ast::Expr) -> DatumBlock\n-{\n+                rhs: &ast::Expr)\n+                -> DatumBlock<'a> {\n     let _icx = push_ctxt(\"trans_binary\");\n \n     match op {\n@@ -1633,14 +1690,15 @@ fn trans_binary(bcx: @Block,\n     }\n }\n \n-fn trans_overloaded_op(bcx: @Block,\n+fn trans_overloaded_op<'a>(\n+                       bcx: &'a Block<'a>,\n                        expr: &ast::Expr,\n                        callee_id: ast::NodeId,\n                        rcvr: &ast::Expr,\n                        args: ~[@ast::Expr],\n                        ret_ty: ty::t,\n                        dest: Dest)\n-                       -> @Block {\n+                       -> &'a Block<'a> {\n     let origin = {\n         let method_map = bcx.ccx().maps.method_map.borrow();\n         method_map.get().get_copy(&expr.id)\n@@ -1661,8 +1719,12 @@ fn trans_overloaded_op(bcx: @Block,\n                              DoAutorefArg).bcx\n }\n \n-fn int_cast(bcx: @Block, lldsttype: Type, llsrctype: Type,\n-            llsrc: ValueRef, signed: bool) -> ValueRef {\n+fn int_cast(bcx: &Block,\n+            lldsttype: Type,\n+            llsrctype: Type,\n+            llsrc: ValueRef,\n+            signed: bool)\n+            -> ValueRef {\n     let _icx = push_ctxt(\"int_cast\");\n     unsafe {\n         let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype.to_ref());\n@@ -1679,8 +1741,11 @@ fn int_cast(bcx: @Block, lldsttype: Type, llsrctype: Type,\n     }\n }\n \n-fn float_cast(bcx: @Block, lldsttype: Type, llsrctype: Type,\n-              llsrc: ValueRef) -> ValueRef {\n+fn float_cast(bcx: &Block,\n+              lldsttype: Type,\n+              llsrctype: Type,\n+              llsrc: ValueRef)\n+              -> ValueRef {\n     let _icx = push_ctxt(\"float_cast\");\n     let srcsz = llsrctype.float_width();\n     let dstsz = lldsttype.float_width();\n@@ -1715,8 +1780,8 @@ pub fn cast_type_kind(t: ty::t) -> cast_kind {\n     }\n }\n \n-fn trans_imm_cast(bcx: @Block, expr: &ast::Expr,\n-                  id: ast::NodeId) -> DatumBlock {\n+fn trans_imm_cast<'a>(bcx: &'a Block<'a>, expr: &ast::Expr, id: ast::NodeId)\n+                  -> DatumBlock<'a> {\n     let _icx = push_ctxt(\"trans_cast\");\n     let ccx = bcx.ccx();\n \n@@ -1790,13 +1855,14 @@ fn trans_imm_cast(bcx: @Block, expr: &ast::Expr,\n     return immediate_rvalue_bcx(bcx, newval, t_out);\n }\n \n-fn trans_assign_op(bcx: @Block,\n+fn trans_assign_op<'a>(\n+                   bcx: &'a Block<'a>,\n                    expr: &ast::Expr,\n                    callee_id: ast::NodeId,\n                    op: ast::BinOp,\n                    dst: &ast::Expr,\n-                   src: @ast::Expr) -> @Block\n-{\n+                   src: @ast::Expr)\n+                   -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n \n@@ -1835,7 +1901,7 @@ fn trans_assign_op(bcx: @Block,\n     return result_datum.copy_to_datum(bcx, DROP_EXISTING, dst_datum);\n }\n \n-pub fn trans_log_level(bcx: @Block) -> DatumBlock {\n+pub fn trans_log_level<'a>(bcx: &'a Block<'a>) -> DatumBlock<'a> {\n     let _icx = push_ctxt(\"trans_log_level\");\n     let ccx = bcx.ccx();\n \n@@ -1891,3 +1957,4 @@ pub fn trans_log_level(bcx: @Block) -> DatumBlock {\n \n     return immediate_rvalue_bcx(bcx, Load(bcx, global), ty::mk_u32());\n }\n+"}, {"sha": "b9d4defc5bee271669e9d079f2fa4095f43281f2", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -161,12 +161,14 @@ pub fn register_foreign_item_fn(ccx: @CrateContext,\n     return llfn;\n }\n \n-pub fn trans_native_call(bcx: @Block,\n+pub fn trans_native_call<'a>(\n+                         bcx: &'a Block<'a>,\n                          callee_ty: ty::t,\n                          llfn: ValueRef,\n                          llretptr: ValueRef,\n                          llargs_rust: &[ValueRef],\n-                         passed_arg_tys: ~[ty::t]) -> @Block {\n+                         passed_arg_tys: ~[ty::t])\n+                         -> &'a Block<'a> {\n     /*!\n      * Prepares a call to a native function. This requires adapting\n      * from the Rust argument passing rules to the native rules."}, {"sha": "c93c0db8c3f7235124c3e2fb7cc775720d0ee04b", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 55, "deletions": 24, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -41,23 +41,25 @@ use std::cell::Cell;\n use std::libc::c_uint;\n use syntax::ast;\n \n-pub fn trans_free(cx: @Block, v: ValueRef) -> @Block {\n+pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", FreeFnLangItem),\n         [PointerCast(cx, v, Type::i8p())],\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn trans_exchange_free(cx: @Block, v: ValueRef) -> @Block {\n+pub fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef)\n+                           -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n         [PointerCast(cx, v, Type::i8p())],\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn take_ty(cx: @Block, v: ValueRef, t: ty::t) -> @Block {\n+pub fn take_ty<'a>(cx: &'a Block<'a>, v: ValueRef, t: ty::t)\n+               -> &'a Block<'a> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"take_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -66,7 +68,8 @@ pub fn take_ty(cx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     return cx;\n }\n \n-pub fn drop_ty(cx: @Block, v: ValueRef, t: ty::t) -> @Block {\n+pub fn drop_ty<'a>(cx: &'a Block<'a>, v: ValueRef, t: ty::t)\n+               -> &'a Block<'a> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"drop_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -75,14 +78,16 @@ pub fn drop_ty(cx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     return cx;\n }\n \n-pub fn drop_ty_immediate(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n+pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n+                         -> &'a Block<'a> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     Store(bcx, v, vp);\n     drop_ty(bcx, vp, t)\n }\n \n-pub fn free_ty(cx: @Block, v: ValueRef, t: ty::t) -> @Block {\n+pub fn free_ty<'a>(cx: &'a Block<'a>, v: ValueRef, t: ty::t)\n+               -> &'a Block<'a> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"free_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n@@ -91,7 +96,8 @@ pub fn free_ty(cx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     return cx;\n }\n \n-pub fn free_ty_immediate(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n+pub fn free_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n+                         -> &'a Block<'a> {\n     let _icx = push_ctxt(\"free_ty_immediate\");\n     match ty::get(t).sty {\n       ty::ty_uniq(_) |\n@@ -269,7 +275,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue_full(bcx: @Block,\n+pub fn call_tydesc_glue_full(bcx: &Block,\n                              v: ValueRef,\n                              tydesc: ValueRef,\n                              field: uint,\n@@ -328,15 +334,20 @@ pub fn call_tydesc_glue_full(bcx: @Block,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue(cx: @Block, v: ValueRef, t: ty::t, field: uint)\n-    -> @Block {\n+pub fn call_tydesc_glue<'a>(\n+                        cx: &'a Block<'a>,\n+                        v: ValueRef,\n+                        t: ty::t,\n+                        field: uint)\n+                        -> &'a Block<'a> {\n     let _icx = push_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n     call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n     return cx;\n }\n \n-pub fn make_visit_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n+pub fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n+                       -> &'a Block<'a> {\n     let _icx = push_ctxt(\"make_visit_glue\");\n     with_scope(bcx, None, \"visitor cleanup\", |bcx| {\n         let mut bcx = bcx;\n@@ -355,7 +366,8 @@ pub fn make_visit_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     })\n }\n \n-pub fn make_free_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n+pub fn make_free_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n+                      -> &'a Block<'a> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_free_glue\");\n     match ty::get(t).sty {\n@@ -392,17 +404,29 @@ pub fn make_free_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     }\n }\n \n-pub fn trans_struct_drop_flag(bcx: @Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n-                              class_did: ast::DefId, substs: &ty::substs) -> @Block {\n+pub fn trans_struct_drop_flag<'a>(\n+                              bcx: &'a Block<'a>,\n+                              t: ty::t,\n+                              v0: ValueRef,\n+                              dtor_did: ast::DefId,\n+                              class_did: ast::DefId,\n+                              substs: &ty::substs)\n+                              -> &'a Block<'a> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n     with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag)), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n }\n \n-pub fn trans_struct_drop(bcx: @Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n-                         class_did: ast::DefId, substs: &ty::substs) -> @Block {\n+pub fn trans_struct_drop<'a>(\n+                         bcx: &'a Block<'a>,\n+                         t: ty::t,\n+                         v0: ValueRef,\n+                         dtor_did: ast::DefId,\n+                         class_did: ast::DefId,\n+                         substs: &ty::substs)\n+                         -> &'a Block<'a> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n     // Find and call the actual destructor\n@@ -439,7 +463,8 @@ pub fn trans_struct_drop(bcx: @Block, t: ty::t, v0: ValueRef, dtor_did: ast::Def\n     })\n }\n \n-pub fn make_drop_glue(bcx: @Block, v0: ValueRef, t: ty::t) -> @Block {\n+pub fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t)\n+                      -> &'a Block<'a> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n@@ -510,10 +535,12 @@ pub fn make_drop_glue(bcx: @Block, v0: ValueRef, t: ty::t) -> @Block {\n }\n \n // box_ptr_ptr is optional, it is constructed if not supplied.\n-pub fn decr_refcnt_maybe_free(bcx: @Block, box_ptr: ValueRef,\n+pub fn decr_refcnt_maybe_free<'a>(\n+                              bcx: &'a Block<'a>,\n+                              box_ptr: ValueRef,\n                               box_ptr_ptr: Option<ValueRef>,\n                               t: ty::t)\n-                           -> @Block {\n+                              -> &'a Block<'a> {\n     let _icx = push_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n \n@@ -539,7 +566,8 @@ pub fn decr_refcnt_maybe_free(bcx: @Block, box_ptr: ValueRef,\n }\n \n \n-pub fn make_take_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n+pub fn make_take_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n+                      -> &'a Block<'a> {\n     let _icx = push_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     match ty::get(t).sty {\n@@ -580,7 +608,7 @@ pub fn make_take_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     }\n }\n \n-pub fn incr_refcnt_of_boxed(cx: @Block, box_ptr: ValueRef) {\n+pub fn incr_refcnt_of_boxed(cx: &Block, box_ptr: ValueRef) {\n     let _icx = push_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]);\n@@ -644,8 +672,8 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n     return inf;\n }\n \n-pub type glue_helper<'a> = 'a |@Block, ValueRef, ty::t|\n-                                     -> @Block;\n+pub type glue_helper<'a> =\n+    'a |&'a Block<'a>, ValueRef, ty::t| -> &'a Block<'a>;\n \n pub fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n                             name: &str) -> ValueRef {\n@@ -663,7 +691,10 @@ pub fn make_generic_glue_inner(ccx: @CrateContext,\n                                helper: glue_helper)\n                             -> ValueRef {\n     let _icx = push_ctxt(\"make_generic_glue_inner\");\n+\n     let fcx = new_fn_ctxt(ccx, ~[], llfn, ty::mk_nil(), None);\n+    init_function(&fcx, false, ty::mk_nil(), None, None);\n+\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created.set(ccx.stats.n_glues_created.get() + 1u);\n     // All glue functions take values passed *by alias*; this is a\n@@ -679,7 +710,7 @@ pub fn make_generic_glue_inner(ccx: @CrateContext,\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);\n \n-    finish_fn(fcx, bcx);\n+    finish_fn(&fcx, bcx);\n \n     return llfn;\n }"}, {"sha": "fe9d227f053c3df76c65bf13e06ddcf5c1175898", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -38,7 +38,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                        ref_id: Option<ast::NodeId>) {\n     debug!(\"trans_intrinsic(item.ident={})\", ccx.sess.str_of(item.ident));\n \n-    fn simple_llvm_intrinsic(bcx: @Block, name: &'static str, num_args: uint) {\n+    fn simple_llvm_intrinsic(bcx: &Block, name: &'static str, num_args: uint) {\n         assert!(num_args <= 4);\n         let mut args = [0 as ValueRef, ..4];\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n@@ -50,7 +50,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         Ret(bcx, llcall);\n     }\n \n-    fn with_overflow_instrinsic(bcx: @Block, name: &'static str, t: ty::t) {\n+    fn with_overflow_instrinsic(bcx: &Block, name: &'static str, t: ty::t) {\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n         let a = get_param(bcx.fcx.llfn, first_real_arg);\n         let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n@@ -73,15 +73,15 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         }\n     }\n \n-    fn volatile_load_intrinsic(bcx: @Block) {\n+    fn volatile_load_intrinsic(bcx: &Block) {\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n         let src = get_param(bcx.fcx.llfn, first_real_arg);\n \n         let val = VolatileLoad(bcx, src);\n         Ret(bcx, val);\n     }\n \n-    fn volatile_store_intrinsic(bcx: @Block) {\n+    fn volatile_store_intrinsic(bcx: &Block) {\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n         let dst = get_param(bcx.fcx.llfn, first_real_arg);\n         let val = get_param(bcx.fcx.llfn, first_real_arg + 1);\n@@ -90,7 +90,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         RetVoid(bcx);\n     }\n \n-    fn copy_intrinsic(bcx: @Block, allow_overlap: bool, tp_ty: ty::t) {\n+    fn copy_intrinsic(bcx: &Block, allow_overlap: bool, tp_ty: ty::t) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n         let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -121,7 +121,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         RetVoid(bcx);\n     }\n \n-    fn memset_intrinsic(bcx: @Block, tp_ty: ty::t) {\n+    fn memset_intrinsic(bcx: &Block, tp_ty: ty::t) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n         let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -143,7 +143,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         RetVoid(bcx);\n     }\n \n-    fn count_zeros_intrinsic(bcx: @Block, name: &'static str) {\n+    fn count_zeros_intrinsic(bcx: &Block, name: &'static str) {\n         let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n         let y = C_i1(false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n@@ -158,10 +158,9 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                                decl,\n                                item.id,\n                                output_type,\n-                               true,\n                                Some(substs),\n-                               None,\n                                Some(item.span));\n+    init_function(&fcx, true, output_type, Some(substs), None);\n \n     set_always_inline(fcx.llfn);\n "}, {"sha": "0ab559301d4966a975335e2db57d6cde4ea1871b", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -138,10 +138,12 @@ pub fn trans_method(ccx: @CrateContext,\n              []);\n }\n \n-pub fn trans_self_arg(bcx: @Block,\n+pub fn trans_self_arg<'a>(\n+                      bcx: &'a Block<'a>,\n                       base: &ast::Expr,\n                       temp_cleanups: &mut ~[ValueRef],\n-                      mentry: typeck::method_map_entry) -> Result {\n+                      mentry: typeck::method_map_entry)\n+                      -> Result<'a> {\n     let _icx = push_ctxt(\"impl::trans_self_arg\");\n \n     // self is passed as an opaque box in the environment slot\n@@ -154,11 +156,12 @@ pub fn trans_self_arg(bcx: @Block,\n                    DontAutorefArg)\n }\n \n-pub fn trans_method_callee(bcx: @Block,\n+pub fn trans_method_callee<'a>(\n+                           bcx: &'a Block<'a>,\n                            callee_id: ast::NodeId,\n                            this: &ast::Expr,\n                            mentry: typeck::method_map_entry)\n-                           -> Callee {\n+                           -> Callee<'a> {\n     let _icx = push_ctxt(\"impl::trans_method_callee\");\n \n     debug!(\"trans_method_callee(callee_id={:?}, this={}, mentry={})\",\n@@ -212,11 +215,11 @@ pub fn trans_method_callee(bcx: @Block,\n     }\n }\n \n-pub fn trans_static_method_callee(bcx: @Block,\n+pub fn trans_static_method_callee(bcx: &Block,\n                                   method_id: ast::DefId,\n                                   trait_id: ast::DefId,\n                                   callee_id: ast::NodeId)\n-                               -> FnData {\n+                                  -> FnData {\n     let _icx = push_ctxt(\"impl::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n@@ -322,14 +325,15 @@ pub fn method_with_name(ccx: &CrateContext,\n     meth.def_id\n }\n \n-pub fn trans_monomorphized_callee(bcx: @Block,\n+pub fn trans_monomorphized_callee<'a>(\n+                                  bcx: &'a Block<'a>,\n                                   callee_id: ast::NodeId,\n                                   base: &ast::Expr,\n                                   mentry: typeck::method_map_entry,\n                                   trait_id: ast::DefId,\n                                   n_method: uint,\n                                   vtbl: typeck::vtable_origin)\n-                                  -> Callee {\n+                                  -> Callee<'a> {\n     let _icx = push_ctxt(\"impl::trans_monomorphized_callee\");\n     return match vtbl {\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n@@ -379,7 +383,7 @@ pub fn trans_monomorphized_callee(bcx: @Block,\n \n }\n \n-pub fn combine_impl_and_methods_tps(bcx: @Block,\n+pub fn combine_impl_and_methods_tps(bcx: &Block,\n                                     mth_did: ast::DefId,\n                                     callee_id: ast::NodeId,\n                                     rcvr_substs: &[ty::t],\n@@ -428,11 +432,12 @@ pub fn combine_impl_and_methods_tps(bcx: @Block,\n     return (ty_substs, vtables);\n }\n \n-pub fn trans_trait_callee(bcx: @Block,\n+pub fn trans_trait_callee<'a>(\n+                          bcx: &'a Block<'a>,\n                           callee_id: ast::NodeId,\n                           n_method: uint,\n                           self_expr: &ast::Expr)\n-                          -> Callee {\n+                          -> Callee<'a> {\n     /*!\n      * Create a method callee where the method is coming from a trait\n      * object (e.g., @Trait type).  In this case, we must pull the fn\n@@ -470,12 +475,13 @@ pub fn trans_trait_callee(bcx: @Block,\n                                   Some(self_scratch.val))\n }\n \n-pub fn trans_trait_callee_from_llval(bcx: @Block,\n+pub fn trans_trait_callee_from_llval<'a>(\n+                                     bcx: &'a Block<'a>,\n                                      callee_ty: ty::t,\n                                      n_method: uint,\n                                      llpair: ValueRef,\n                                      temp_cleanup: Option<ValueRef>)\n-                                  -> Callee {\n+                                     -> Callee<'a> {\n     /*!\n      * Same as `trans_trait_callee()` above, except that it is given\n      * a by-ref pointer to the object pair.\n@@ -541,7 +547,7 @@ pub fn vtable_id(ccx: @CrateContext,\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n-pub fn get_vtable(bcx: @Block,\n+pub fn get_vtable(bcx: &Block,\n                   self_ty: ty::t,\n                   origins: typeck::vtable_param_res)\n                   -> ValueRef {\n@@ -604,7 +610,7 @@ pub fn make_vtable(ccx: &CrateContext,\n     }\n }\n \n-fn emit_vtable_methods(bcx: @Block,\n+fn emit_vtable_methods(bcx: &Block,\n                        impl_id: ast::DefId,\n                        substs: &[ty::t],\n                        vtables: typeck::vtable_res)\n@@ -645,13 +651,14 @@ fn emit_vtable_methods(bcx: @Block,\n     })\n }\n \n-pub fn trans_trait_cast(bcx: @Block,\n+pub fn trans_trait_cast<'a>(\n+                        bcx: &'a Block<'a>,\n                         val: &ast::Expr,\n                         id: ast::NodeId,\n                         dest: expr::Dest,\n                         _store: ty::TraitStore,\n                         do_adjustments: bool)\n-                     -> @Block {\n+                        -> &'a Block<'a> {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"impl::trans_cast\");\n "}, {"sha": "181fad4f7e6a1ca6ea138085f4b954f01656adf0", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -34,15 +34,15 @@ use syntax::parse::token::special_idents;\n \n use middle::trans::type_::Type;\n \n-pub struct Reflector {\n+pub struct Reflector<'a> {\n     visitor_val: ValueRef,\n     visitor_methods: @~[@ty::Method],\n-    final_bcx: @Block,\n+    final_bcx: &'a Block<'a>,\n     tydesc_ty: Type,\n-    bcx: @Block\n+    bcx: &'a Block<'a>\n }\n \n-impl Reflector {\n+impl<'a> Reflector<'a> {\n     pub fn c_uint(&mut self, u: uint) -> ValueRef {\n         C_uint(self.bcx.ccx(), u)\n     }\n@@ -301,6 +301,8 @@ impl Reflector {\n                                       llfdecl,\n                                       ty::mk_u64(),\n                                       None);\n+                init_function(&fcx, false, ty::mk_u64(), None, None);\n+\n                 let arg = unsafe {\n                     //\n                     // we know the return type of llfdecl is an int here, so\n@@ -317,7 +319,7 @@ impl Reflector {\n                     Some(llreturn) => cleanup_and_Br(bcx, bcx, llreturn),\n                     None => bcx = cleanup_block(bcx, Some(bcx.llbb))\n                 };\n-                finish_fn(fcx, bcx);\n+                finish_fn(&fcx, bcx);\n                 llfdecl\n             };\n \n@@ -385,11 +387,12 @@ impl Reflector {\n }\n \n // Emit a sequence of calls to visit_ty::visit_foo\n-pub fn emit_calls_to_trait_visit_ty(bcx: @Block,\n+pub fn emit_calls_to_trait_visit_ty<'a>(\n+                                    bcx: &'a Block<'a>,\n                                     t: ty::t,\n                                     visitor_val: ValueRef,\n                                     visitor_trait_id: DefId)\n-                                 -> @Block {\n+                                    -> &'a Block<'a> {\n     let final = sub_block(bcx, \"final\");\n     let tydesc_ty = ty::get_tydesc_ty(bcx.ccx().tcx).unwrap();\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);"}, {"sha": "18bfe52f643a5ef322fc0d8caae108fc85ece437", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 84, "deletions": 41, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -53,39 +53,46 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn get_fill(bcx: @Block, vptr: ValueRef) -> ValueRef {\n+pub fn get_fill(bcx: &Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n }\n-pub fn set_fill(bcx: @Block, vptr: ValueRef, fill: ValueRef) {\n+\n+pub fn set_fill(bcx: &Block, vptr: ValueRef, fill: ValueRef) {\n     Store(bcx, fill, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]));\n }\n-pub fn get_alloc(bcx: @Block, vptr: ValueRef) -> ValueRef {\n+\n+pub fn get_alloc(bcx: &Block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n \n-pub fn get_bodyptr(bcx: @Block, vptr: ValueRef, t: ty::t) -> ValueRef {\n+pub fn get_bodyptr(bcx: &Block, vptr: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_contents(bcx.tcx(), t).owns_managed() {\n         GEPi(bcx, vptr, [0u, abi::box_field_body])\n     } else {\n         vptr\n     }\n }\n \n-pub fn get_dataptr(bcx: @Block, vptr: ValueRef) -> ValueRef {\n+pub fn get_dataptr(bcx: &Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_dataptr\");\n     GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n \n-pub fn pointer_add_byte(bcx: @Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n+pub fn pointer_add_byte(bcx: &Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::pointer_add_byte\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, Type::i8p());\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-pub fn alloc_raw(bcx: @Block, unit_ty: ty::t,\n-                 fill: ValueRef, alloc: ValueRef, heap: heap) -> Result {\n+pub fn alloc_raw<'a>(\n+                 bcx: &'a Block<'a>,\n+                 unit_ty: ty::t,\n+                 fill: ValueRef,\n+                 alloc: ValueRef,\n+                 heap: heap)\n+                 -> Result<'a> {\n     let _icx = push_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n \n@@ -107,16 +114,21 @@ pub fn alloc_raw(bcx: @Block, unit_ty: ty::t,\n     }\n }\n \n-pub fn alloc_uniq_raw(bcx: @Block, unit_ty: ty::t,\n-                      fill: ValueRef, alloc: ValueRef) -> Result {\n+pub fn alloc_uniq_raw<'a>(\n+                      bcx: &'a Block<'a>,\n+                      unit_ty: ty::t,\n+                      fill: ValueRef,\n+                      alloc: ValueRef)\n+                      -> Result<'a> {\n     alloc_raw(bcx, unit_ty, fill, alloc, base::heap_for_unique(bcx, unit_ty))\n }\n \n-pub fn alloc_vec(bcx: @Block,\n+pub fn alloc_vec<'a>(\n+                 bcx: &'a Block<'a>,\n                  unit_ty: ty::t,\n                  elts: uint,\n                  heap: heap)\n-              -> Result {\n+                 -> Result<'a> {\n     let _icx = push_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n     let llunitty = type_of::type_of(ccx, unit_ty);\n@@ -130,8 +142,11 @@ pub fn alloc_vec(bcx: @Block,\n     return rslt(bcx, vptr);\n }\n \n-pub fn make_drop_glue_unboxed(bcx: @Block, vptr: ValueRef, vec_ty: ty::t) ->\n-   @Block {\n+pub fn make_drop_glue_unboxed<'a>(\n+                              bcx: &'a Block<'a>,\n+                              vptr: ValueRef,\n+                              vec_ty: ty::t)\n+                              -> &'a Block<'a> {\n     let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx();\n     let unit_ty = ty::sequence_element_type(tcx, vec_ty);\n@@ -160,11 +175,12 @@ impl VecTypes {\n     }\n }\n \n-pub fn trans_fixed_vstore(bcx: @Block,\n+pub fn trans_fixed_vstore<'a>(\n+                          bcx: &'a Block<'a>,\n                           vstore_expr: &ast::Expr,\n                           content_expr: &ast::Expr,\n                           dest: expr::Dest)\n-                       -> @Block {\n+                          -> &'a Block<'a> {\n     //!\n     //\n     // [...] allocates a fixed-size array and moves it around \"by value\".\n@@ -189,11 +205,12 @@ pub fn trans_fixed_vstore(bcx: @Block,\n     };\n }\n \n-pub fn trans_slice_vstore(bcx: @Block,\n+pub fn trans_slice_vstore<'a>(\n+                          bcx: &'a Block<'a>,\n                           vstore_expr: &ast::Expr,\n                           content_expr: &ast::Expr,\n                           dest: expr::Dest)\n-                       -> @Block {\n+                          -> &'a Block<'a> {\n     //!\n     //\n     // &[...] allocates memory on the stack and writes the values into it,\n@@ -247,11 +264,12 @@ pub fn trans_slice_vstore(bcx: @Block,\n     return bcx;\n }\n \n-pub fn trans_lit_str(bcx: @Block,\n+pub fn trans_lit_str<'a>(\n+                     bcx: &'a Block<'a>,\n                      lit_expr: &ast::Expr,\n                      str_lit: @str,\n                      dest: Dest)\n-                  -> @Block {\n+                     -> &'a Block<'a> {\n     //!\n     //\n     // Literal strings translate to slices into static memory.  This is\n@@ -282,8 +300,12 @@ pub fn trans_lit_str(bcx: @Block,\n }\n \n \n-pub fn trans_uniq_or_managed_vstore(bcx: @Block, heap: heap, vstore_expr: &ast::Expr,\n-                                    content_expr: &ast::Expr) -> DatumBlock {\n+pub fn trans_uniq_or_managed_vstore<'a>(\n+                                    bcx: &'a Block<'a>,\n+                                    heap: heap,\n+                                    vstore_expr: &ast::Expr,\n+                                    content_expr: &ast::Expr)\n+                                    -> DatumBlock<'a> {\n     //!\n     //\n     // @[...] or ~[...] (also @\"...\" or ~\"...\") allocate boxes in the\n@@ -343,12 +365,13 @@ pub fn trans_uniq_or_managed_vstore(bcx: @Block, heap: heap, vstore_expr: &ast::\n     return immediate_rvalue_bcx(bcx, val, vt.vec_ty);\n }\n \n-pub fn write_content(bcx: @Block,\n+pub fn write_content<'a>(\n+                     bcx: &'a Block<'a>,\n                      vt: &VecTypes,\n                      vstore_expr: &ast::Expr,\n                      content_expr: &ast::Expr,\n                      dest: Dest)\n-                  -> @Block {\n+                     -> &'a Block<'a> {\n     let _icx = push_ctxt(\"tvec::write_content\");\n     let mut bcx = bcx;\n \n@@ -433,12 +456,12 @@ pub fn write_content(bcx: @Block,\n     }\n }\n \n-pub fn vec_types_from_expr(bcx: @Block, vec_expr: &ast::Expr) -> VecTypes {\n+pub fn vec_types_from_expr(bcx: &Block, vec_expr: &ast::Expr) -> VecTypes {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n     vec_types(bcx, vec_ty)\n }\n \n-pub fn vec_types(bcx: @Block, vec_ty: ty::t) -> VecTypes {\n+pub fn vec_types(bcx: &Block, vec_ty: ty::t) -> VecTypes {\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunit_ty = type_of::type_of(ccx, unit_ty);\n@@ -452,7 +475,7 @@ pub fn vec_types(bcx: @Block, vec_ty: ty::t) -> VecTypes {\n               llunit_alloc_size: llunit_alloc_size}\n }\n \n-pub fn elements_required(bcx: @Block, content_expr: &ast::Expr) -> uint {\n+pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n@@ -468,8 +491,8 @@ pub fn elements_required(bcx: @Block, content_expr: &ast::Expr) -> uint {\n     }\n }\n \n-pub fn get_base_and_byte_len(bcx: @Block, llval: ValueRef,\n-                        vec_ty: ty::t) -> (ValueRef, ValueRef) {\n+pub fn get_base_and_byte_len(bcx: &Block, llval: ValueRef, vec_ty: ty::t)\n+                             -> (ValueRef, ValueRef) {\n     //!\n     //\n     // Converts a vector into the slice pair.  The vector should be stored in\n@@ -505,7 +528,8 @@ pub fn get_base_and_byte_len(bcx: @Block, llval: ValueRef,\n     }\n }\n \n-pub fn get_base_and_len(bcx: @Block, llval: ValueRef, vec_ty: ty::t) -> (ValueRef, ValueRef) {\n+pub fn get_base_and_len(bcx: &Block, llval: ValueRef, vec_ty: ty::t)\n+                        -> (ValueRef, ValueRef) {\n     //!\n     //\n     // Converts a vector into the slice pair.  The vector should be stored in\n@@ -539,15 +563,17 @@ pub fn get_base_and_len(bcx: @Block, llval: ValueRef, vec_ty: ty::t) -> (ValueRe\n     }\n }\n \n-pub type iter_vec_block<'a> = 'a |@Block, ValueRef, ty::t|\n-                                        -> @Block;\n+pub type iter_vec_block<'r,'b> =\n+    'r |&'b Block<'b>, ValueRef, ty::t| -> &'b Block<'b>;\n \n-pub fn iter_vec_loop(bcx: @Block,\n+pub fn iter_vec_loop<'r,\n+                     'b>(\n+                     bcx: &'b Block<'b>,\n                      data_ptr: ValueRef,\n                      vt: &VecTypes,\n                      count: ValueRef,\n-                     f: iter_vec_block\n-                     ) -> @Block {\n+                     f: iter_vec_block<'r,'b>)\n+                     -> &'b Block<'b> {\n     let _icx = push_ctxt(\"tvec::iter_vec_loop\");\n \n     let next_bcx = sub_block(bcx, \"iter_vec_loop: while next\");\n@@ -597,8 +623,14 @@ pub fn iter_vec_loop(bcx: @Block,\n     next_bcx\n }\n \n-pub fn iter_vec_raw(bcx: @Block, data_ptr: ValueRef, vec_ty: ty::t,\n-                    fill: ValueRef, f: iter_vec_block) -> @Block {\n+pub fn iter_vec_raw<'r,\n+                    'b>(\n+                    bcx: &'b Block<'b>,\n+                    data_ptr: ValueRef,\n+                    vec_ty: ty::t,\n+                    fill: ValueRef,\n+                    f: iter_vec_block<'r,'b>)\n+                    -> &'b Block<'b> {\n     let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n \n     let vt = vec_types(bcx, vec_ty);\n@@ -632,15 +664,26 @@ pub fn iter_vec_raw(bcx: @Block, data_ptr: ValueRef, vec_ty: ty::t,\n     }\n }\n \n-pub fn iter_vec_uniq(bcx: @Block, vptr: ValueRef, vec_ty: ty::t,\n-                     fill: ValueRef, f: iter_vec_block) -> @Block {\n+pub fn iter_vec_uniq<'r,\n+                     'b>(\n+                     bcx: &'b Block<'b>,\n+                     vptr: ValueRef,\n+                     vec_ty: ty::t,\n+                     fill: ValueRef,\n+                     f: iter_vec_block<'r,'b>)\n+                     -> &'b Block<'b> {\n     let _icx = push_ctxt(\"tvec::iter_vec_uniq\");\n     let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr, vec_ty));\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n-pub fn iter_vec_unboxed(bcx: @Block, body_ptr: ValueRef, vec_ty: ty::t,\n-                        f: iter_vec_block) -> @Block {\n+pub fn iter_vec_unboxed<'r,\n+                        'b>(\n+                        bcx: &'b Block<'b>,\n+                        body_ptr: ValueRef,\n+                        vec_ty: ty::t,\n+                        f: iter_vec_block<'r,'b>)\n+                        -> &'b Block<'b> {\n     let _icx = push_ctxt(\"tvec::iter_vec_unboxed\");\n     let fill = get_fill(bcx, body_ptr);\n     let dataptr = get_dataptr(bcx, body_ptr);"}, {"sha": "91ac5f9f3b4d32d50106c0f15e0c642d05bc0c7b", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -17,8 +17,11 @@ use middle::trans::datum::immediate_rvalue;\n use middle::trans::glue;\n use middle::ty;\n \n-pub fn make_free_glue(bcx: @Block, vptrptr: ValueRef, box_ty: ty::t)\n-    -> @Block {\n+pub fn make_free_glue<'a>(\n+                      bcx: &'a Block<'a>,\n+                      vptrptr: ValueRef,\n+                      box_ty: ty::t)\n+                      -> &'a Block<'a> {\n     let _icx = push_ctxt(\"uniq::make_free_glue\");\n     let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n "}, {"sha": "b3d467661e8d361e0a0b4061d54eafd7c95e2dcb", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e637a890ce4bf5204872f322c101aa113d2ca8c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=5e637a890ce4bf5204872f322c101aa113d2ca8c", "patch": "@@ -22,11 +22,13 @@ use middle::trans::datum::*;\n use syntax::codemap::Span;\n use syntax::ast;\n \n-pub fn root_and_write_guard(datum: &Datum,\n-                            bcx: @Block,\n+pub fn root_and_write_guard<'a>(\n+                            datum: &Datum,\n+                            bcx: &'a Block<'a>,\n                             span: Span,\n                             expr_id: ast::NodeId,\n-                            derefs: uint) -> @Block {\n+                            derefs: uint)\n+                            -> &'a Block<'a> {\n     let key = root_map_key { id: expr_id, derefs: derefs };\n     debug!(\"write_guard::root_and_write_guard(key={:?})\", key);\n \n@@ -41,11 +43,13 @@ pub fn root_and_write_guard(datum: &Datum,\n     }\n }\n \n-fn root(datum: &Datum,\n-        bcx: @Block,\n+fn root<'a>(\n+        datum: &Datum,\n+        bcx: &'a Block<'a>,\n         _: Span,\n         root_key: root_map_key,\n-        root_info: RootInfo) -> @Block {\n+        root_info: RootInfo)\n+        -> &'a Block<'a> {\n     //! In some cases, borrowck will decide that an @T/@[]/@str\n     //! value must be rooted for the program to be safe.  In that\n     //! case, we will call this function, which will stash a copy"}]}