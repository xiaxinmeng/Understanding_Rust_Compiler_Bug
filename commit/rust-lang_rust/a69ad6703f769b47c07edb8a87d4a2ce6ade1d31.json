{"sha": "a69ad6703f769b47c07edb8a87d4a2ce6ade1d31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2OWFkNjcwM2Y3NjliNDdjMDdlZGI4YTg3ZDRhMmNlNmFkZTFkMzE=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-10T01:31:53Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-10T01:31:53Z"}, "message": "Store AllocIds directly in allocation map.", "tree": {"sha": "614f0dde2c0323b1986cef390135a1d5b7a4e439", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/614f0dde2c0323b1986cef390135a1d5b7a4e439"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a69ad6703f769b47c07edb8a87d4a2ce6ade1d31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a69ad6703f769b47c07edb8a87d4a2ce6ade1d31", "html_url": "https://github.com/rust-lang/rust/commit/a69ad6703f769b47c07edb8a87d4a2ce6ade1d31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a69ad6703f769b47c07edb8a87d4a2ce6ade1d31/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "438eabbba4c4540b4c28aa20c863f05e90d0b18c", "url": "https://api.github.com/repos/rust-lang/rust/commits/438eabbba4c4540b4c28aa20c863f05e90d0b18c", "html_url": "https://github.com/rust-lang/rust/commit/438eabbba4c4540b4c28aa20c863f05e90d0b18c"}], "stats": {"total": 40, "additions": 23, "deletions": 17}, "files": [{"sha": "21ab8e36c563fd0ad3f887bf9b799d77a44d43ce", "filename": "src/memory.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a69ad6703f769b47c07edb8a87d4a2ce6ade1d31/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a69ad6703f769b47c07edb8a87d4a2ce6ade1d31/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=a69ad6703f769b47c07edb8a87d4a2ce6ade1d31", "patch": "@@ -1,7 +1,7 @@\n use byteorder::{ByteOrder, NativeEndian, ReadBytesExt, WriteBytesExt};\n use std::collections::Bound::{Included, Excluded};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n-use std::{iter, mem, ptr};\n+use std::{fmt, iter, mem, ptr};\n \n use error::{EvalError, EvalResult};\n use primval::PrimVal;\n@@ -58,9 +58,15 @@ impl Repr {\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]\n pub struct AllocId(u64);\n \n+impl fmt::Display for AllocId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.0)\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct Allocation {\n     pub bytes: Vec<u8>,\n@@ -85,31 +91,31 @@ impl Pointer {\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct Memory {\n-    alloc_map: HashMap<u64, Allocation>,\n-    next_id: u64,\n+    alloc_map: HashMap<AllocId, Allocation>,\n+    next_id: AllocId,\n     pub pointer_size: usize,\n }\n \n impl Memory {\n     pub fn new() -> Self {\n         Memory {\n             alloc_map: HashMap::new(),\n-            next_id: 0,\n+            next_id: AllocId(0),\n \n             // TODO(tsion): Should this be host's or target's usize?\n             pointer_size: mem::size_of::<usize>(),\n         }\n     }\n \n     pub fn allocate(&mut self, size: usize) -> Pointer {\n-        let id = AllocId(self.next_id);\n         let alloc = Allocation {\n             bytes: vec![0; size],\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(size),\n         };\n-        self.alloc_map.insert(self.next_id, alloc);\n-        self.next_id += 1;\n+        let id = self.next_id;\n+        self.next_id.0 += 1;\n+        self.alloc_map.insert(id, alloc);\n         Pointer {\n             alloc_id: id,\n             offset: 0,\n@@ -147,7 +153,7 @@ impl Memory {\n             panic!()\n         }\n \n-        if self.alloc_map.remove(&ptr.alloc_id.0).is_none() {\n+        if self.alloc_map.remove(&ptr.alloc_id).is_none() {\n             // TODO(tsion): Report error about erroneous free. This is blocked on properly tracking\n             // already-dropped state since this if-statement is entered even in safe code without\n             // it.\n@@ -161,11 +167,11 @@ impl Memory {\n     ////////////////////////////////////////////////////////////////////////////////\n \n     pub fn get(&self, id: AllocId) -> EvalResult<&Allocation> {\n-        self.alloc_map.get(&id.0).ok_or(EvalError::DanglingPointerDeref)\n+        self.alloc_map.get(&id).ok_or(EvalError::DanglingPointerDeref)\n     }\n \n     pub fn get_mut(&mut self, id: AllocId) -> EvalResult<&mut Allocation> {\n-        self.alloc_map.get_mut(&id.0).ok_or(EvalError::DanglingPointerDeref)\n+        self.alloc_map.get_mut(&id).ok_or(EvalError::DanglingPointerDeref)\n     }\n \n     /// Print an allocation and all allocations it points to, recursively.\n@@ -175,12 +181,12 @@ impl Memory {\n         allocs_to_print.push_back(id);\n \n         while let Some(id) = allocs_to_print.pop_front() {\n-            allocs_seen.insert(id.0);\n-            let prefix = format!(\"Alloc {:<5} \", format!(\"{}:\", id.0));\n+            allocs_seen.insert(id);\n+            let prefix = format!(\"Alloc {:<5} \", format!(\"{}:\", id));\n             print!(\"{}\", prefix);\n             let mut relocations = vec![];\n \n-            let alloc = match self.alloc_map.get(&id.0) {\n+            let alloc = match self.alloc_map.get(&id) {\n                 Some(a) => a,\n                 None => {\n                     println!(\"(deallocated)\");\n@@ -190,12 +196,12 @@ impl Memory {\n \n             for i in 0..alloc.bytes.len() {\n                 if let Some(&target_id) = alloc.relocations.get(&i) {\n-                    if !allocs_seen.contains(&target_id.0) {\n+                    if !allocs_seen.contains(&target_id) {\n                         allocs_to_print.push_back(target_id);\n                     }\n-                    relocations.push((i, target_id.0));\n+                    relocations.push((i, target_id));\n                 }\n-                if alloc.undef_mask.is_range_defined(i, i+1) {\n+                if alloc.undef_mask.is_range_defined(i, i + 1) {\n                     print!(\"{:02x} \", alloc.bytes[i]);\n                 } else {\n                     print!(\"__ \");"}]}