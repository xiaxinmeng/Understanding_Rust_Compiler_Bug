{"sha": "a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZjk5MGRjMDg0MzdlY2Y2M2Y1ZTE1ZThlYzZhY2I5Y2JlZGJjMTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-01T14:28:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-01T14:28:11Z"}, "message": "Auto merge of #45472 - michaelwoerister:incr-comp-caching-base, r=nikomatsakis\n\nincr.comp.: Implement compiler diagnostic persistence.\n\nThis PR implements storing and loading diagnostics that the compiler generates and thus allows for emitting warnings during incremental compilation without actually re-evaluating the thing the warning originally came from. It also lays some groundwork for storing and loading type information and MIR in the incr. comp. cache.\n\n~~It is still work in progress:~~\n- ~~There's still some documentation to be added.~~\n- ~~The way anonymous queries are handled might lead to duplicated emissions of warnings. Not sure if there is a better way or how frequent such duplication would be in practice.~~\n\nDiagnostic message duplication is addressed separately in #45519.\n\nr? @nikomatsakis", "tree": {"sha": "0b6229e15b82955e5e75d7ad382158a02f5f69e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b6229e15b82955e5e75d7ad382158a02f5f69e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "html_url": "https://github.com/rust-lang/rust/commit/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f581cf9d692781847bede5d966b098a5d09b5e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f581cf9d692781847bede5d966b098a5d09b5e4", "html_url": "https://github.com/rust-lang/rust/commit/2f581cf9d692781847bede5d966b098a5d09b5e4"}, {"sha": "6faba5bf8d19de75249280c200399d1cef9abe2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6faba5bf8d19de75249280c200399d1cef9abe2b", "html_url": "https://github.com/rust-lang/rust/commit/6faba5bf8d19de75249280c200399d1cef9abe2b"}], "stats": {"total": 857, "additions": 707, "deletions": 150}, "files": [{"sha": "7913ea51df5a923bbf265bd2a611e31beab37426", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use errors::DiagnosticBuilder;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHashingContextProvider};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -600,6 +601,24 @@ impl DepGraph {\n                       \"DepGraph::try_mark_green() - Duplicate fingerprint \\\n                       insertion for {:?}\", dep_node);\n \n+        // ... emitting any stored diagnostic ...\n+        {\n+            let diagnostics = tcx.on_disk_query_result_cache\n+                                 .load_diagnostics(prev_dep_node_index);\n+\n+            if diagnostics.len() > 0 {\n+                let handle = tcx.sess.diagnostic();\n+\n+                // Promote the previous diagnostics to the current session.\n+                tcx.on_disk_query_result_cache\n+                   .store_diagnostics(dep_node_index, diagnostics.clone());\n+\n+                for diagnostic in diagnostics {\n+                    DiagnosticBuilder::new_diagnostic(handle, diagnostic).emit();\n+                }\n+            }\n+        }\n+\n         // ... and finally storing a \"Green\" entry in the color map.\n         let old_color = data.colors\n                             .borrow_mut()"}, {"sha": "a472183698abf5bf205efd69a32062d25dfb5c0a", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -26,4 +26,4 @@ pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;\n-pub use self::serialized::SerializedDepGraph;\n+pub use self::serialized::{SerializedDepGraph, SerializedDepNodeIndex};"}, {"sha": "498e1aa3520d5bf45489fe352637a4de51aa2c24", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -46,6 +46,7 @@\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(i128_type)]\n+#![feature(inclusive_range_syntax)]\n #![cfg_attr(windows, feature(libc))]\n #![feature(macro_vis_matcher)]\n #![feature(never_type)]"}, {"sha": "1c793920bf2e4de8a5f30bfab4c5f20739db1364", "filename": "src/librustc/ty/codec.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -0,0 +1,243 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This module contains some shared code for encoding and decoding various\n+// things from the `ty` module, and in particular implements support for\n+// \"shorthands\" which allow to have pointers back into the already encoded\n+// stream instead of re-encoding the same thing twice.\n+//\n+// The functionality in here is shared between persisting to crate metadata and\n+// persisting to incr. comp. caches.\n+\n+use hir::def_id::{DefId, CrateNum};\n+use middle::const_val::ByteArray;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_serialize::{Decodable, Decoder, Encoder, Encodable};\n+use std::hash::Hash;\n+use std::intrinsics;\n+use ty::{self, Ty, TyCtxt};\n+use ty::subst::Substs;\n+\n+/// The shorthand encoding uses an enum's variant index `usize`\n+/// and is offset by this value so it never matches a real variant.\n+/// This offset is also chosen so that the first byte is never < 0x80.\n+pub const SHORTHAND_OFFSET: usize = 0x80;\n+\n+pub trait EncodableWithShorthand: Clone + Eq + Hash {\n+    type Variant: Encodable;\n+    fn variant(&self) -> &Self::Variant;\n+}\n+\n+impl<'tcx> EncodableWithShorthand for Ty<'tcx> {\n+    type Variant = ty::TypeVariants<'tcx>;\n+    fn variant(&self) -> &Self::Variant {\n+        &self.sty\n+    }\n+}\n+\n+impl<'tcx> EncodableWithShorthand for ty::Predicate<'tcx> {\n+    type Variant = ty::Predicate<'tcx>;\n+    fn variant(&self) -> &Self::Variant {\n+        self\n+    }\n+}\n+\n+pub trait TyEncoder: Encoder {\n+    fn position(&self) -> usize;\n+}\n+\n+/// Encode the given value or a previously cached shorthand.\n+pub fn encode_with_shorthand<E, T, M>(encoder: &mut E,\n+                                      value: &T,\n+                                      cache: M)\n+                                      -> Result<(), E::Error>\n+    where E: TyEncoder,\n+          M: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<T, usize>,\n+          T: EncodableWithShorthand,\n+{\n+    let existing_shorthand = cache(encoder).get(value).cloned();\n+    if let Some(shorthand) = existing_shorthand {\n+        return encoder.emit_usize(shorthand);\n+    }\n+\n+    let variant = value.variant();\n+\n+    let start = encoder.position();\n+    variant.encode(encoder)?;\n+    let len = encoder.position() - start;\n+\n+    // The shorthand encoding uses the same usize as the\n+    // discriminant, with an offset so they can't conflict.\n+    let discriminant = unsafe { intrinsics::discriminant_value(variant) };\n+    assert!(discriminant < SHORTHAND_OFFSET as u64);\n+    let shorthand = start + SHORTHAND_OFFSET;\n+\n+    // Get the number of bits that leb128 could fit\n+    // in the same space as the fully encoded type.\n+    let leb128_bits = len * 7;\n+\n+    // Check that the shorthand is a not longer than the\n+    // full encoding itself, i.e. it's an obvious win.\n+    if leb128_bits >= 64 || (shorthand as u64) < (1 << leb128_bits) {\n+        cache(encoder).insert(value.clone(), shorthand);\n+    }\n+\n+    Ok(())\n+}\n+\n+pub fn encode_predicates<'tcx, E, C>(encoder: &mut E,\n+                                     predicates: &ty::GenericPredicates<'tcx>,\n+                                     cache: C)\n+                                     -> Result<(), E::Error>\n+    where E: TyEncoder,\n+          C: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<ty::Predicate<'tcx>, usize>,\n+{\n+    predicates.parent.encode(encoder)?;\n+    predicates.predicates.len().encode(encoder)?;\n+    for predicate in &predicates.predicates {\n+        encode_with_shorthand(encoder, predicate, &cache)?\n+    }\n+    Ok(())\n+}\n+\n+pub trait TyDecoder<'a, 'tcx: 'a>: Decoder {\n+\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+\n+    fn peek_byte(&self) -> u8;\n+\n+    fn cached_ty_for_shorthand<F>(&mut self,\n+                                  shorthand: usize,\n+                                  or_insert_with: F)\n+                                  -> Result<Ty<'tcx>, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<Ty<'tcx>, Self::Error>;\n+\n+    fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n+        where F: FnOnce(&mut Self) -> R;\n+\n+    fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum;\n+\n+    fn positioned_at_shorthand(&self) -> bool {\n+        (self.peek_byte() & (SHORTHAND_OFFSET as u8)) != 0\n+    }\n+}\n+\n+pub fn decode_cnum<'a, 'tcx, D>(decoder: &mut D) -> Result<CrateNum, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let cnum = CrateNum::from_u32(u32::decode(decoder)?);\n+    Ok(decoder.map_encoded_cnum_to_current(cnum))\n+}\n+\n+pub fn decode_ty<'a, 'tcx, D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    // Handle shorthands first, if we have an usize > 0x80.\n+    // if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n+    if decoder.positioned_at_shorthand() {\n+        let pos = decoder.read_usize()?;\n+        assert!(pos >= SHORTHAND_OFFSET);\n+        let shorthand = pos - SHORTHAND_OFFSET;\n+\n+        decoder.cached_ty_for_shorthand(shorthand, |decoder| {\n+            decoder.with_position(shorthand, Ty::decode)\n+        })\n+    } else {\n+        let tcx = decoder.tcx();\n+        Ok(tcx.mk_ty(ty::TypeVariants::decode(decoder)?))\n+    }\n+}\n+\n+pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n+                                      -> Result<ty::GenericPredicates<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    Ok(ty::GenericPredicates {\n+        parent: Decodable::decode(decoder)?,\n+        predicates: (0..decoder.read_usize()?).map(|_| {\n+                // Handle shorthands first, if we have an usize > 0x80.\n+                if decoder.positioned_at_shorthand() {\n+                    let pos = decoder.read_usize()?;\n+                    assert!(pos >= SHORTHAND_OFFSET);\n+                    let shorthand = pos - SHORTHAND_OFFSET;\n+\n+                    decoder.with_position(shorthand, ty::Predicate::decode)\n+                } else {\n+                    ty::Predicate::decode(decoder)\n+                }\n+            })\n+            .collect::<Result<Vec<_>, _>>()?,\n+    })\n+}\n+\n+pub fn decode_substs<'a, 'tcx, D>(decoder: &mut D) -> Result<&'tcx Substs<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let len = decoder.read_usize()?;\n+    let tcx = decoder.tcx();\n+    Ok(tcx.mk_substs((0..len).map(|_| Decodable::decode(decoder)))?)\n+}\n+\n+pub fn decode_region<'a, 'tcx, D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    Ok(decoder.tcx().mk_region(Decodable::decode(decoder)?))\n+}\n+\n+pub fn decode_ty_slice<'a, 'tcx, D>(decoder: &mut D)\n+                                    -> Result<&'tcx ty::Slice<Ty<'tcx>>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let len = decoder.read_usize()?;\n+    Ok(decoder.tcx().mk_type_list((0..len).map(|_| Decodable::decode(decoder)))?)\n+}\n+\n+pub fn decode_adt_def<'a, 'tcx, D>(decoder: &mut D)\n+                                   -> Result<&'tcx ty::AdtDef, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let def_id = DefId::decode(decoder)?;\n+    Ok(decoder.tcx().adt_def(def_id))\n+}\n+\n+pub fn decode_existential_predicate_slice<'a, 'tcx, D>(decoder: &mut D)\n+    -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let len = decoder.read_usize()?;\n+    Ok(decoder.tcx()\n+              .mk_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n+}\n+\n+pub fn decode_byte_array<'a, 'tcx, D>(decoder: &mut D)\n+                                      -> Result<ByteArray<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    Ok(ByteArray {\n+        data: decoder.tcx().alloc_byte_array(&Vec::decode(decoder)?)\n+    })\n+}\n+\n+pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n+                                 -> Result<&'tcx ty::Const<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n+}"}, {"sha": "37c4346a7dc936c645e67e8274bfce0b3de9f440", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -855,6 +855,11 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub dep_graph: DepGraph,\n \n+    /// This provides access to the incr. comp. on-disk cache for query results.\n+    /// Do not access this directly. It is only meant to be used by\n+    /// `DepGraph::try_mark_green()` and the query infrastructure in `ty::maps`.\n+    pub(crate) on_disk_query_result_cache: maps::OnDiskCache<'tcx>,\n+\n     /// Common types, pre-interned for your convenience.\n     pub types: CommonTypes<'tcx>,\n \n@@ -1056,6 +1061,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   resolutions: ty::Resolutions,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   hir: hir_map::Map<'tcx>,\n+                                  on_disk_query_result_cache: maps::OnDiskCache<'tcx>,\n                                   crate_name: &str,\n                                   tx: mpsc::Sender<Box<Any + Send>>,\n                                   output_filenames: &OutputFilenames,\n@@ -1139,6 +1145,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             global_arenas: arenas,\n             global_interners: interners,\n             dep_graph: dep_graph.clone(),\n+            on_disk_query_result_cache,\n             types: common_types,\n             named_region_map: NamedRegionMap {\n                 defs,\n@@ -1300,6 +1307,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.in_scope_traits_map(def_index);\n         }\n     }\n+\n+    pub fn serialize_query_result_cache<E>(self,\n+                                           encoder: &mut E)\n+                                           -> Result<(), E::Error>\n+        where E: ::rustc_serialize::Encoder\n+    {\n+        self.on_disk_query_result_cache.serialize(encoder)\n+    }\n+\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {"}, {"sha": "c77175bbbdcc9663fcb51a71d0e044806d2ccc04", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -70,6 +70,9 @@ mod config;\n pub use self::config::QueryConfig;\n use self::config::QueryDescription;\n \n+mod on_disk_cache;\n+pub use self::on_disk_cache::OnDiskCache;\n+\n // Each of these maps also corresponds to a method on a\n // `Provider` trait for requesting a value of that type,\n // and a method on `Maps` itself for doing that in a"}, {"sha": "26581501234af1b67f0449861d52e408e7db4bc2", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n+use errors::Diagnostic;\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n+                      SpecializedDecoder};\n+use session::Session;\n+use std::borrow::Cow;\n+use std::cell::RefCell;\n+use std::collections::BTreeMap;\n+use std::mem;\n+use syntax::codemap::{CodeMap, StableFilemapId};\n+use syntax_pos::{BytePos, Span, NO_EXPANSION, DUMMY_SP};\n+\n+/// `OnDiskCache` provides an interface to incr. comp. data cached from the\n+/// previous compilation session. This data will eventually include the results\n+/// of a few selected queries (like `typeck_tables_of` and `mir_optimized`) and\n+/// any diagnostics that have been emitted during a query.\n+pub struct OnDiskCache<'sess> {\n+    // The diagnostics emitted during the previous compilation session.\n+    prev_diagnostics: FxHashMap<SerializedDepNodeIndex, Vec<Diagnostic>>,\n+\n+    // This field collects all Diagnostics emitted during the current\n+    // compilation session.\n+    current_diagnostics: RefCell<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n+\n+    // This will eventually be needed for creating Decoders that can rebase\n+    // spans.\n+    _prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n+    codemap: &'sess CodeMap,\n+}\n+\n+// This type is used only for (de-)serialization.\n+#[derive(RustcEncodable, RustcDecodable)]\n+struct Header {\n+    prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n+}\n+\n+// This type is used only for (de-)serialization.\n+#[derive(RustcEncodable, RustcDecodable)]\n+struct Body {\n+    diagnostics: Vec<(SerializedDepNodeIndex, Vec<Diagnostic>)>,\n+}\n+\n+impl<'sess> OnDiskCache<'sess> {\n+    /// Create a new OnDiskCache instance from the serialized data in `data`.\n+    /// Note that the current implementation (which only deals with diagnostics\n+    /// so far) will eagerly deserialize the complete cache. Once we are\n+    /// dealing with larger amounts of data (i.e. cached query results),\n+    /// deserialization will need to happen lazily.\n+    pub fn new(sess: &'sess Session, data: &[u8]) -> OnDiskCache<'sess> {\n+        debug_assert!(sess.opts.incremental.is_some());\n+\n+        let mut decoder = opaque::Decoder::new(&data[..], 0);\n+        let header = Header::decode(&mut decoder).unwrap();\n+\n+        let prev_diagnostics: FxHashMap<_, _> = {\n+            let mut decoder = CacheDecoder {\n+                opaque: decoder,\n+                codemap: sess.codemap(),\n+                prev_filemap_starts: &header.prev_filemap_starts,\n+            };\n+            let body = Body::decode(&mut decoder).unwrap();\n+            body.diagnostics.into_iter().collect()\n+        };\n+\n+        OnDiskCache {\n+            prev_diagnostics,\n+            _prev_filemap_starts: header.prev_filemap_starts,\n+            codemap: sess.codemap(),\n+            current_diagnostics: RefCell::new(FxHashMap()),\n+        }\n+    }\n+\n+    pub fn new_empty(codemap: &'sess CodeMap) -> OnDiskCache<'sess> {\n+        OnDiskCache {\n+            prev_diagnostics: FxHashMap(),\n+            _prev_filemap_starts: BTreeMap::new(),\n+            codemap,\n+            current_diagnostics: RefCell::new(FxHashMap()),\n+        }\n+    }\n+\n+    pub fn serialize<'a, 'tcx, E>(&self,\n+                                  encoder: &mut E)\n+                                  -> Result<(), E::Error>\n+        where E: Encoder\n+    {\n+        let prev_filemap_starts: BTreeMap<_, _> = self\n+            .codemap\n+            .files()\n+            .iter()\n+            .map(|fm| (fm.start_pos, StableFilemapId::new(fm)))\n+            .collect();\n+\n+        Header { prev_filemap_starts }.encode(encoder)?;\n+\n+        let diagnostics: Vec<(SerializedDepNodeIndex, Vec<Diagnostic>)> =\n+            self.current_diagnostics\n+                .borrow()\n+                .iter()\n+                .map(|(k, v)| (SerializedDepNodeIndex::new(k.index()), v.clone()))\n+                .collect();\n+\n+        Body { diagnostics }.encode(encoder)?;\n+\n+        Ok(())\n+    }\n+\n+    /// Load a diagnostic emitted during the previous compilation session.\n+    pub fn load_diagnostics(&self,\n+                            dep_node_index: SerializedDepNodeIndex)\n+                            -> Vec<Diagnostic> {\n+        self.prev_diagnostics.get(&dep_node_index).cloned().unwrap_or(vec![])\n+    }\n+\n+    /// Store a diagnostic emitted during the current compilation session.\n+    /// Anything stored like this will be available via `load_diagnostics` in\n+    /// the next compilation session.\n+    pub fn store_diagnostics(&self,\n+                             dep_node_index: DepNodeIndex,\n+                             diagnostics: Vec<Diagnostic>) {\n+        let mut current_diagnostics = self.current_diagnostics.borrow_mut();\n+        let prev = current_diagnostics.insert(dep_node_index, diagnostics);\n+        debug_assert!(prev.is_none());\n+    }\n+\n+    /// Store a diagnostic emitted during computation of an anonymous query.\n+    /// Since many anonymous queries can share the same `DepNode`, we aggregate\n+    /// them -- as opposed to regular queries where we assume that there is a\n+    /// 1:1 relationship between query-key and `DepNode`.\n+    pub fn store_diagnostics_for_anon_node(&self,\n+                                           dep_node_index: DepNodeIndex,\n+                                           mut diagnostics: Vec<Diagnostic>) {\n+        let mut current_diagnostics = self.current_diagnostics.borrow_mut();\n+\n+        let x = current_diagnostics.entry(dep_node_index).or_insert_with(|| {\n+            mem::replace(&mut diagnostics, Vec::new())\n+        });\n+\n+        x.extend(diagnostics.into_iter());\n+    }\n+}\n+\n+/// A decoder that can read the incr. comp. cache. It is similar to the one\n+/// we use for crate metadata decoding in that it can rebase spans and\n+/// eventually will also handle things that contain `Ty` instances.\n+struct CacheDecoder<'a> {\n+    opaque: opaque::Decoder<'a>,\n+    codemap: &'a CodeMap,\n+    prev_filemap_starts: &'a BTreeMap<BytePos, StableFilemapId>,\n+}\n+\n+impl<'a> CacheDecoder<'a> {\n+    fn find_filemap_prev_bytepos(&self,\n+                                 prev_bytepos: BytePos)\n+                                 -> Option<(BytePos, StableFilemapId)> {\n+        for (start, id) in self.prev_filemap_starts.range(BytePos(0) ... prev_bytepos).rev() {\n+            return Some((*start, *id))\n+        }\n+\n+        None\n+    }\n+}\n+\n+macro_rules! decoder_methods {\n+    ($($name:ident -> $ty:ty;)*) => {\n+        $(fn $name(&mut self) -> Result<$ty, Self::Error> {\n+            self.opaque.$name()\n+        })*\n+    }\n+}\n+\n+impl<'sess> Decoder for CacheDecoder<'sess> {\n+    type Error = String;\n+\n+    decoder_methods! {\n+        read_nil -> ();\n+\n+        read_u128 -> u128;\n+        read_u64 -> u64;\n+        read_u32 -> u32;\n+        read_u16 -> u16;\n+        read_u8 -> u8;\n+        read_usize -> usize;\n+\n+        read_i128 -> i128;\n+        read_i64 -> i64;\n+        read_i32 -> i32;\n+        read_i16 -> i16;\n+        read_i8 -> i8;\n+        read_isize -> isize;\n+\n+        read_bool -> bool;\n+        read_f64 -> f64;\n+        read_f32 -> f32;\n+        read_char -> char;\n+        read_str -> Cow<str>;\n+    }\n+\n+    fn error(&mut self, err: &str) -> Self::Error {\n+        self.opaque.error(err)\n+    }\n+}\n+\n+impl<'a> SpecializedDecoder<Span> for CacheDecoder<'a> {\n+    fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n+        let lo = BytePos::decode(self)?;\n+        let hi = BytePos::decode(self)?;\n+\n+        if let Some((prev_filemap_start, filemap_id)) = self.find_filemap_prev_bytepos(lo) {\n+            if let Some(current_filemap) = self.codemap.filemap_by_stable_id(filemap_id) {\n+                let lo = (lo + current_filemap.start_pos) - prev_filemap_start;\n+                let hi = (hi + current_filemap.start_pos) - prev_filemap_start;\n+                return Ok(Span::new(lo, hi, NO_EXPANSION));\n+            }\n+        }\n+\n+        Ok(DUMMY_SP)\n+    }\n+}"}, {"sha": "2f10b9e8b9a833729da1f712a0e7aa28d54ef79b", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -13,14 +13,14 @@\n //! provider, manage the caches, and so forth.\n \n use dep_graph::{DepNodeIndex, DepNode, DepKind, DepNodeColor};\n-use errors::{Diagnostic, DiagnosticBuilder};\n+use errors::DiagnosticBuilder;\n use ty::{TyCtxt};\n use ty::maps::Query; // NB: actually generated by the macros in this file\n use ty::maps::config::QueryDescription;\n use ty::item_path;\n \n use rustc_data_structures::fx::{FxHashMap};\n-use std::cell::{RefMut, Cell};\n+use std::cell::RefMut;\n use std::marker::PhantomData;\n use std::mem;\n use syntax_pos::Span;\n@@ -33,34 +33,19 @@ pub(super) struct QueryMap<D: QueryDescription> {\n pub(super) struct QueryValue<T> {\n     pub(super) value: T,\n     pub(super) index: DepNodeIndex,\n-    pub(super) diagnostics: Option<Box<QueryDiagnostics>>,\n }\n \n impl<T> QueryValue<T> {\n     pub(super) fn new(value: T,\n-                      dep_node_index: DepNodeIndex,\n-                      diagnostics: Vec<Diagnostic>)\n+                      dep_node_index: DepNodeIndex)\n                       -> QueryValue<T> {\n         QueryValue {\n             value,\n             index: dep_node_index,\n-            diagnostics: if diagnostics.len() == 0 {\n-                None\n-            } else {\n-                Some(Box::new(QueryDiagnostics {\n-                    diagnostics,\n-                    emitted_diagnostics: Cell::new(true),\n-                }))\n-            },\n         }\n     }\n }\n \n-pub(super) struct QueryDiagnostics {\n-    pub(super) diagnostics: Vec<Diagnostic>,\n-    pub(super) emitted_diagnostics: Cell<bool>,\n-}\n-\n impl<M: QueryDescription> QueryMap<M> {\n     pub(super) fn new() -> QueryMap<M> {\n         QueryMap {\n@@ -284,16 +269,6 @@ macro_rules! define_maps {\n                 );\n \n                 if let Some(value) = tcx.maps.$name.borrow().map.get(&key) {\n-                    if let Some(ref d) = value.diagnostics {\n-                        if !d.emitted_diagnostics.get() {\n-                            d.emitted_diagnostics.set(true);\n-                            let handle = tcx.sess.diagnostic();\n-                            for diagnostic in d.diagnostics.iter() {\n-                                DiagnosticBuilder::new_diagnostic(handle, diagnostic.clone())\n-                                    .emit();\n-                            }\n-                        }\n-                    }\n                     profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                     tcx.dep_graph.read_index(value.index);\n                     return Ok((&value.value).clone());\n@@ -331,7 +306,11 @@ macro_rules! define_maps {\n                     let ((result, dep_node_index), diagnostics) = res;\n \n                     tcx.dep_graph.read_index(dep_node_index);\n-                    let value = QueryValue::new(result, dep_node_index, diagnostics);\n+\n+                    tcx.on_disk_query_result_cache\n+                       .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+\n+                    let value = QueryValue::new(result, dep_node_index);\n \n                     return Ok((&tcx.maps\n                                     .$name\n@@ -398,8 +377,11 @@ macro_rules! define_maps {\n             {\n                 debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n \n-                // We don't do any caching yet, so recompute\n-                let (result, diagnostics) = tcx.cycle_check(span, Query::$name(key), || {\n+                // We don't do any caching yet, so recompute.\n+                // The diagnostics for this query have already been promoted to\n+                // the current session during try_mark_green(), so we can ignore\n+                // them here.\n+                let (result, _) = tcx.cycle_check(span, Query::$name(key), || {\n                     tcx.sess.diagnostic().track_diagnostics(|| {\n                         // The dep-graph for this computation is already in place\n                         tcx.dep_graph.with_ignore(|| {\n@@ -412,7 +394,7 @@ macro_rules! define_maps {\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n                 }\n \n-                let value = QueryValue::new(result, dep_node_index, diagnostics);\n+                let value = QueryValue::new(result, dep_node_index);\n \n                 Ok((&tcx.maps\n                          .$name\n@@ -454,7 +436,12 @@ macro_rules! define_maps {\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n                 }\n \n-                let value = QueryValue::new(result, dep_node_index, diagnostics);\n+                if dep_node.kind != ::dep_graph::DepKind::Null {\n+                    tcx.on_disk_query_result_cache\n+                       .store_diagnostics(dep_node_index, diagnostics);\n+                }\n+\n+                let value = QueryValue::new(result, dep_node_index);\n \n                 Ok(((&tcx.maps\n                          .$name"}, {"sha": "ee1668d6fa25f6616d9f7eb9fec21eac4dde0e6b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -89,6 +89,7 @@ pub use self::maps::queries;\n pub mod adjustment;\n pub mod binding;\n pub mod cast;\n+pub mod codec;\n pub mod error;\n mod erase_regions;\n pub mod fast_reject;"}, {"sha": "1cbc1aa72340ae1734480547055c294b201e77e9", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -940,6 +940,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let time_passes = sess.time_passes();\n \n+    let query_result_on_disk_cache = time(time_passes,\n+        \"load query result cache\",\n+        || rustc_incremental::load_query_result_cache(sess));\n+\n     let named_region_map = time(time_passes,\n                                 \"lifetime resolution\",\n                                 || middle::resolve_lifetime::krate(sess, cstore, &hir_map))?;\n@@ -1048,6 +1052,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                              resolutions,\n                              named_region_map,\n                              hir_map,\n+                             query_result_on_disk_cache,\n                              name,\n                              tx,\n                              output_filenames,"}, {"sha": "d86d51f3747225da74988678638d1021e8317918", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -23,6 +23,7 @@ use rustc::middle::resolve_lifetime;\n use rustc::ty::subst::{Kind, Subst};\n use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::maps::OnDiskCache;\n use rustc::infer::{self, InferOk, InferResult};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc_metadata::cstore::CStore;\n@@ -156,6 +157,7 @@ fn test_env<F>(source_string: &str,\n                              resolutions,\n                              named_region_map.unwrap(),\n                              hir_map,\n+                             OnDiskCache::new_empty(sess.codemap()),\n                              \"test_crate\",\n                              tx,\n                              &outputs,"}, {"sha": "e82c2897d21325da73b07d053c8b89c6e5a45660", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -17,6 +17,9 @@\n \n #![feature(rand)]\n #![feature(conservative_impl_trait)]\n+#![feature(i128_type)]\n+#![feature(inclusive_range_syntax)]\n+#![feature(specialization)]\n \n extern crate graphviz;\n #[macro_use] extern crate rustc;\n@@ -31,8 +34,9 @@ mod assert_dep_graph;\n mod persist;\n \n pub use assert_dep_graph::assert_dep_graph;\n-pub use persist::load_dep_graph;\n pub use persist::dep_graph_tcx_init;\n+pub use persist::load_dep_graph;\n+pub use persist::load_query_result_cache;\n pub use persist::save_dep_graph;\n pub use persist::save_trans_partition;\n pub use persist::save_work_products;"}, {"sha": "458f47a1602c7454c4b421a4baa20b2a7581fcd4", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -131,6 +131,7 @@ const LOCK_FILE_EXT: &'static str = \".lock\";\n const DEP_GRAPH_FILENAME: &'static str = \"dep-graph.bin\";\n const WORK_PRODUCTS_FILENAME: &'static str = \"work-products.bin\";\n const METADATA_HASHES_FILENAME: &'static str = \"metadata.bin\";\n+const QUERY_CACHE_FILENAME: &'static str = \"query-cache.bin\";\n \n // We encode integers using the following base, so they are shorter than decimal\n // or hexadecimal numbers (we want short file and directory names). Since these\n@@ -150,6 +151,10 @@ pub fn metadata_hash_export_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, METADATA_HASHES_FILENAME)\n }\n \n+pub fn query_cache_path(sess: &Session) -> PathBuf {\n+    in_incr_comp_dir_sess(sess, QUERY_CACHE_FILENAME)\n+}\n+\n pub fn lock_file_path(session_dir: &Path) -> PathBuf {\n     let crate_dir = session_dir.parent().unwrap();\n "}, {"sha": "158e9f2677a72b851e1fa7f5c6b467b70acbedd8", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -15,6 +15,7 @@ use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n+use rustc::ty::maps::OnDiskCache;\n use rustc::util::nodemap::DefIdMap;\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n@@ -195,3 +196,15 @@ pub fn load_dep_graph(sess: &Session) -> PreviousDepGraph {\n         empty\n     }\n }\n+\n+pub fn load_query_result_cache<'sess>(sess: &'sess Session) -> OnDiskCache<'sess> {\n+    if sess.opts.incremental.is_none() {\n+        return OnDiskCache::new_empty(sess.codemap());\n+    }\n+\n+    if let Some(bytes) = load_data(sess, &query_cache_path(sess)) {\n+        OnDiskCache::new(sess, &bytes[..])\n+    } else {\n+        OnDiskCache::new_empty(sess.codemap())\n+    }\n+}"}, {"sha": "82a43d85bc6082dcb2f5a55034d3a8a834091b1a", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -23,8 +23,9 @@ mod file_format;\n pub use self::fs::prepare_session_directory;\n pub use self::fs::finalize_session_directory;\n pub use self::fs::in_incr_comp_dir;\n-pub use self::load::load_dep_graph;\n pub use self::load::dep_graph_tcx_init;\n+pub use self::load::load_dep_graph;\n+pub use self::load::load_query_result_cache;\n pub use self::save::save_dep_graph;\n pub use self::save::save_work_products;\n pub use self::work_product::save_trans_partition;"}, {"sha": "711550c27d16ff916350a2399f776fb2872d6f0b", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -63,6 +63,12 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            e));\n     }\n \n+    time(sess.time_passes(), \"persist query result cache\", || {\n+        save_in(sess,\n+                query_cache_path(sess),\n+                |e| encode_query_cache(tcx, e));\n+    });\n+\n     time(sess.time_passes(), \"persist dep-graph\", || {\n         save_in(sess,\n                 dep_graph_path(sess),\n@@ -298,3 +304,9 @@ fn encode_work_products(dep_graph: &DepGraph,\n \n     work_products.encode(encoder)\n }\n+\n+fn encode_query_cache(tcx: TyCtxt,\n+                      encoder: &mut Encoder)\n+                      -> io::Result<()> {\n+    tcx.serialize_query_result_cache(encoder)\n+}"}, {"sha": "b45196191249d869c673270d2942100f015c05ec", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 64, "deletions": 58, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -25,6 +25,7 @@ use rustc::ich::Fingerprint;\n use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::codec::{self as ty_codec, TyDecoder};\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::DefIdSet;\n \n@@ -143,16 +144,6 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n \n-    fn with_position<F: FnOnce(&mut Self) -> R, R>(&mut self, pos: usize, f: F) -> R {\n-        let new_opaque = opaque::Decoder::new(self.opaque.data, pos);\n-        let old_opaque = mem::replace(&mut self.opaque, new_opaque);\n-        let old_state = mem::replace(&mut self.lazy_state, LazyState::NoNode);\n-        let r = f(self);\n-        self.opaque = old_opaque;\n-        self.lazy_state = old_state;\n-        r\n-    }\n-\n     fn read_lazy_distance(&mut self, min_size: usize) -> Result<usize, <Self as Decoder>::Error> {\n         let distance = self.read_usize()?;\n         let position = match self.lazy_state {\n@@ -208,6 +199,60 @@ impl<'doc, 'tcx> Decoder for DecodeContext<'doc, 'tcx> {\n     }\n }\n \n+\n+impl<'a, 'tcx: 'a> TyDecoder<'a, 'tcx> for DecodeContext<'a, 'tcx> {\n+\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n+    }\n+\n+    fn peek_byte(&self) -> u8 {\n+        self.opaque.data[self.opaque.position()]\n+    }\n+\n+    fn cached_ty_for_shorthand<F>(&mut self,\n+                                  shorthand: usize,\n+                                  or_insert_with: F)\n+                                  -> Result<Ty<'tcx>, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<Ty<'tcx>, Self::Error>\n+    {\n+        let tcx = self.tcx();\n+\n+        let key = ty::CReaderCacheKey {\n+            cnum: self.cdata().cnum,\n+            pos: shorthand,\n+        };\n+\n+        if let Some(&ty) = tcx.rcache.borrow().get(&key) {\n+            return Ok(ty);\n+        }\n+\n+        let ty = or_insert_with(self)?;\n+        tcx.rcache.borrow_mut().insert(key, ty);\n+        Ok(ty)\n+    }\n+\n+    fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n+        where F: FnOnce(&mut Self) -> R\n+    {\n+        let new_opaque = opaque::Decoder::new(self.opaque.data, pos);\n+        let old_opaque = mem::replace(&mut self.opaque, new_opaque);\n+        let old_state = mem::replace(&mut self.lazy_state, LazyState::NoNode);\n+        let r = f(self);\n+        self.opaque = old_opaque;\n+        self.lazy_state = old_state;\n+        r\n+    }\n+\n+    fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n+        if cnum == LOCAL_CRATE {\n+            self.cdata().cnum\n+        } else {\n+            self.cdata().cnum_map.borrow()[cnum]\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n         Ok(Lazy::with_position(self.read_lazy_distance(Lazy::<T>::min_size())?))\n@@ -302,96 +347,57 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Ty<'tcx>, Self::Error> {\n-        let tcx = self.tcx();\n-\n-        // Handle shorthands first, if we have an usize > 0x80.\n-        if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n-            let pos = self.read_usize()?;\n-            assert!(pos >= SHORTHAND_OFFSET);\n-            let key = ty::CReaderCacheKey {\n-                cnum: self.cdata().cnum,\n-                pos: pos - SHORTHAND_OFFSET,\n-            };\n-            if let Some(ty) = tcx.rcache.borrow().get(&key).cloned() {\n-                return Ok(ty);\n-            }\n-\n-            let ty = self.with_position(key.pos, Ty::decode)?;\n-            tcx.rcache.borrow_mut().insert(key, ty);\n-            Ok(ty)\n-        } else {\n-            Ok(tcx.mk_ty(ty::TypeVariants::decode(self)?))\n-        }\n+        ty_codec::decode_ty(self)\n     }\n }\n \n-\n impl<'a, 'tcx> SpecializedDecoder<ty::GenericPredicates<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<ty::GenericPredicates<'tcx>, Self::Error> {\n-        Ok(ty::GenericPredicates {\n-            parent: Decodable::decode(self)?,\n-            predicates: (0..self.read_usize()?).map(|_| {\n-                    // Handle shorthands first, if we have an usize > 0x80.\n-                    if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n-                        let pos = self.read_usize()?;\n-                        assert!(pos >= SHORTHAND_OFFSET);\n-                        let pos = pos - SHORTHAND_OFFSET;\n-\n-                        self.with_position(pos, ty::Predicate::decode)\n-                    } else {\n-                        ty::Predicate::decode(self)\n-                    }\n-                })\n-                .collect::<Result<Vec<_>, _>>()?,\n-        })\n+        ty_codec::decode_predicates(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx Substs<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx Substs<'tcx>, Self::Error> {\n-        Ok(self.tcx().mk_substs((0..self.read_usize()?).map(|_| Decodable::decode(self)))?)\n+        ty_codec::decode_substs(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<ty::Region<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<ty::Region<'tcx>, Self::Error> {\n-        Ok(self.tcx().mk_region(Decodable::decode(self)?))\n+        ty_codec::decode_region(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<Ty<'tcx>>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::Slice<Ty<'tcx>>, Self::Error> {\n-        Ok(self.tcx().mk_type_list((0..self.read_usize()?).map(|_| Decodable::decode(self)))?)\n+        ty_codec::decode_ty_slice(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::AdtDef> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::AdtDef, Self::Error> {\n-        let def_id = DefId::decode(self)?;\n-        Ok(self.tcx().adt_def(def_id))\n+        ty_codec::decode_adt_def(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>\n     for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self)\n         -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n-        Ok(self.tcx().mk_existential_predicates((0..self.read_usize()?)\n-                                                .map(|_| Decodable::decode(self)))?)\n+        ty_codec::decode_existential_predicate_slice(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<ByteArray<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<ByteArray<'tcx>, Self::Error> {\n-        Ok(ByteArray {\n-            data: self.tcx().alloc_byte_array(&Vec::decode(self)?)\n-        })\n+        ty_codec::decode_byte_array(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Const<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n-        Ok(self.tcx().mk_const(Decodable::decode(self)?))\n+        ty_codec::decode_const(self)\n     }\n }\n "}, {"sha": "725d6d8fad0e098bb422ffcac4c7841769554712", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 50, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -25,14 +25,13 @@ use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt, ReprOptions};\n+use rustc::ty::codec::{self as ty_codec, TyEncoder};\n \n use rustc::session::config::{self, CrateTypeProcMacro};\n use rustc::util::nodemap::{FxHashMap, NodeSet};\n \n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n \n-use std::hash::Hash;\n-use std::intrinsics;\n use std::io::prelude::*;\n use std::io::Cursor;\n use std::path::Path;\n@@ -119,28 +118,25 @@ impl<'a, 'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n-        self.encode_with_shorthand(ty, &ty.sty, |ecx| &mut ecx.type_shorthands)\n+        ty_codec::encode_with_shorthand(self, ty, |ecx| &mut ecx.type_shorthands)\n     }\n }\n \n impl<'a, 'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self,\n                           predicates: &ty::GenericPredicates<'tcx>)\n                           -> Result<(), Self::Error> {\n-        predicates.parent.encode(self)?;\n-        predicates.predicates.len().encode(self)?;\n-        for predicate in &predicates.predicates {\n-            self.encode_with_shorthand(predicate, predicate, |ecx| &mut ecx.predicate_shorthands)?\n-        }\n-        Ok(())\n+        ty_codec::encode_predicates(self, predicates, |ecx| &mut ecx.predicate_shorthands)\n     }\n }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-\n-    pub fn position(&self) -> usize {\n+impl<'a, 'tcx> TyEncoder for EncodeContext<'a, 'tcx> {\n+    fn position(&self) -> usize {\n         self.opaque.position()\n     }\n+}\n+\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn emit_node<F: FnOnce(&mut Self, usize) -> R, R>(&mut self, f: F) -> R {\n         assert_eq!(self.lazy_state, LazyState::NoNode);\n@@ -204,44 +200,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         })\n     }\n \n-    /// Encode the given value or a previously cached shorthand.\n-    fn encode_with_shorthand<T, U, M>(&mut self,\n-                                      value: &T,\n-                                      variant: &U,\n-                                      map: M)\n-                                      -> Result<(), <Self as Encoder>::Error>\n-        where M: for<'b> Fn(&'b mut Self) -> &'b mut FxHashMap<T, usize>,\n-              T: Clone + Eq + Hash,\n-              U: Encodable\n-    {\n-        let existing_shorthand = map(self).get(value).cloned();\n-        if let Some(shorthand) = existing_shorthand {\n-            return self.emit_usize(shorthand);\n-        }\n-\n-        let start = self.position();\n-        variant.encode(self)?;\n-        let len = self.position() - start;\n-\n-        // The shorthand encoding uses the same usize as the\n-        // discriminant, with an offset so they can't conflict.\n-        let discriminant = unsafe { intrinsics::discriminant_value(variant) };\n-        assert!(discriminant < SHORTHAND_OFFSET as u64);\n-        let shorthand = start + SHORTHAND_OFFSET;\n-\n-        // Get the number of bits that leb128 could fit\n-        // in the same space as the fully encoded type.\n-        let leb128_bits = len * 7;\n-\n-        // Check that the shorthand is a not longer than the\n-        // full encoding itself, i.e. it's an obvious win.\n-        if leb128_bits >= 64 || (shorthand as u64) < (1 << leb128_bits) {\n-            map(self).insert(value.clone(), shorthand);\n-        }\n-\n-        Ok(())\n-    }\n-\n     // Encodes something that corresponds to a single DepNode::GlobalMetaData\n     // and registers the Fingerprint in the `metadata_hashes` map.\n     pub fn tracked<'x, DATA, R>(&'x mut self,"}, {"sha": "20bdfaea0d0bbf0b294b00c4a0c0de510831f7c3", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -15,7 +15,6 @@\n \n #![feature(box_patterns)]\n #![feature(conservative_impl_trait)]\n-#![feature(core_intrinsics)]\n #![feature(i128_type)]\n #![feature(proc_macro_internals)]\n #![feature(quote)]"}, {"sha": "d85fdeb377cd30d43127c5729bfd71ccb10cfe78", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -54,11 +54,6 @@ pub const METADATA_VERSION: u8 = 4;\n pub const METADATA_HEADER: &'static [u8; 12] =\n     &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n-/// The shorthand encoding uses an enum's variant index `usize`\n-/// and is offset by this value so it never matches a real variant.\n-/// This offset is also chosen so that the first byte is never < 0x80.\n-pub const SHORTHAND_OFFSET: usize = 0x80;\n-\n /// A value of type T referred to by its absolute position\n /// in the metadata, and which can be decoded lazily.\n ///"}, {"sha": "ad78c550cf60e1b1be5f32c2a4559a4b67567b85", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -17,11 +17,15 @@\n //! within the CodeMap, which upon request can be converted to line and column\n //! information, source code snippets, etc.\n \n+\n pub use syntax_pos::*;\n pub use syntax_pos::hygiene::{ExpnFormat, ExpnInfo, NameAndSpan};\n pub use self::ExpnFormat::*;\n \n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::StableHasher;\n use std::cell::{RefCell, Ref};\n+use std::hash::Hash;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n \n@@ -98,6 +102,24 @@ impl FileLoader for RealFileLoader {\n     }\n }\n \n+// This is a FileMap identifier that is used to correlate FileMaps between\n+// subsequent compilation sessions (which is something we need to do during\n+// incremental compilation).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct StableFilemapId(u128);\n+\n+impl StableFilemapId {\n+    pub fn new(filemap: &FileMap) -> StableFilemapId {\n+        let mut hasher = StableHasher::new();\n+\n+        filemap.name.hash(&mut hasher);\n+        filemap.name_was_remapped.hash(&mut hasher);\n+        filemap.unmapped_path.hash(&mut hasher);\n+\n+        StableFilemapId(hasher.finish())\n+    }\n+}\n+\n // _____________________________________________________________________________\n // CodeMap\n //\n@@ -108,6 +130,7 @@ pub struct CodeMap {\n     // This is used to apply the file path remapping as specified via\n     // -Zremap-path-prefix to all FileMaps allocated within this CodeMap.\n     path_mapping: FilePathMapping,\n+    stable_id_to_filemap: RefCell<FxHashMap<StableFilemapId, Rc<FileMap>>>,\n }\n \n impl CodeMap {\n@@ -116,6 +139,7 @@ impl CodeMap {\n             files: RefCell::new(Vec::new()),\n             file_loader: Box::new(RealFileLoader),\n             path_mapping,\n+            stable_id_to_filemap: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -126,6 +150,7 @@ impl CodeMap {\n             files: RefCell::new(Vec::new()),\n             file_loader,\n             path_mapping,\n+            stable_id_to_filemap: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -146,6 +171,10 @@ impl CodeMap {\n         self.files.borrow()\n     }\n \n+    pub fn filemap_by_stable_id(&self, stable_id: StableFilemapId) -> Option<Rc<FileMap>> {\n+        self.stable_id_to_filemap.borrow().get(&stable_id).map(|fm| fm.clone())\n+    }\n+\n     fn next_start_pos(&self) -> usize {\n         let files = self.files.borrow();\n         match files.last() {\n@@ -180,6 +209,10 @@ impl CodeMap {\n \n         files.push(filemap.clone());\n \n+        self.stable_id_to_filemap\n+            .borrow_mut()\n+            .insert(StableFilemapId::new(&filemap), filemap.clone());\n+\n         filemap\n     }\n \n@@ -241,6 +274,10 @@ impl CodeMap {\n \n         files.push(filemap.clone());\n \n+        self.stable_id_to_filemap\n+            .borrow_mut()\n+            .insert(StableFilemapId::new(&filemap), filemap.clone());\n+\n         filemap\n     }\n "}, {"sha": "bf66ac7829c2e9f5bcfe86b8e1993fb029b797e8", "filename": "src/test/incremental/warnings-reemitted.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Ftest%2Fincremental%2Fwarnings-reemitted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14/src%2Ftest%2Fincremental%2Fwarnings-reemitted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fwarnings-reemitted.rs?ref=a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Coverflow-checks=on\n+// must-compile-successfully\n+\n+#![allow(warnings)]\n+\n+fn main() {\n+    255u8 + 1; //~ WARNING this expression will panic at run-time\n+}"}]}