{"sha": "56d415aa60b41e171890cb76a323cb95d617b077", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZDQxNWFhNjBiNDFlMTcxODkwY2I3NmEzMjNjYjk1ZDYxN2IwNzc=", "commit": {"author": {"name": "Branimir", "email": "branimir@volomp.com", "date": "2013-09-25T21:55:38Z"}, "committer": {"name": "Branimir", "email": "branimir@volomp.com", "date": "2013-09-26T09:14:18Z"}, "message": "    fix for issue #9394\n\n    This solves problem of incorrect indexing into vtable\n    when method from super trait was called through pointer\n    to derived trait.\n    Problem was that offset of super trait vtables\n    was not calculated at all.\n    Now it works, correct offset is calculated by\n    traversing all super traits up to super trait\n    where method belongs. That is how it is\n    intended to work.", "tree": {"sha": "37e9897a8b88371b809fe1a3d226c0e83656c8c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37e9897a8b88371b809fe1a3d226c0e83656c8c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56d415aa60b41e171890cb76a323cb95d617b077", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56d415aa60b41e171890cb76a323cb95d617b077", "html_url": "https://github.com/rust-lang/rust/commit/56d415aa60b41e171890cb76a323cb95d617b077", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56d415aa60b41e171890cb76a323cb95d617b077/comments", "author": null, "committer": null, "parents": [{"sha": "af25f58ac3da45899ed65b3af965150c8a90dcda", "url": "https://api.github.com/repos/rust-lang/rust/commits/af25f58ac3da45899ed65b3af965150c8a90dcda", "html_url": "https://github.com/rust-lang/rust/commit/af25f58ac3da45899ed65b3af965150c8a90dcda"}], "stats": {"total": 72, "additions": 66, "deletions": 6}, "files": [{"sha": "60712769de5b89164e599fa98648114d18556bc7", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/56d415aa60b41e171890cb76a323cb95d617b077/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56d415aa60b41e171890cb76a323cb95d617b077/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=56d415aa60b41e171890cb76a323cb95d617b077", "patch": "@@ -372,7 +372,7 @@ impl<'self> LookupContext<'self> {\n     // to a trait and its supertraits.\n     fn get_method_index(&self,\n                         trait_ref: @TraitRef,\n-                        subtrait_id: ast::DefId,\n+                        subtrait: @TraitRef,\n                         n_method: uint) -> uint {\n         let tcx = self.tcx();\n \n@@ -382,15 +382,14 @@ impl<'self> LookupContext<'self> {\n         // we find the trait the method came from, counting up the\n         // methods from them.\n         let mut method_count = 0;\n-        do ty::each_bound_trait_and_supertraits(tcx, &[trait_ref])\n+        do ty::each_bound_trait_and_supertraits(tcx, &[subtrait])\n             |bound_ref| {\n-            if bound_ref.def_id == subtrait_id { false }\n+            if bound_ref.def_id == trait_ref.def_id { false }\n                 else {\n                 method_count += ty::trait_methods(tcx, bound_ref.def_id).len();\n                 true\n             }\n         };\n-\n         return method_count + n_method;\n     }\n \n@@ -418,9 +417,9 @@ impl<'self> LookupContext<'self> {\n         let trait_ref = @TraitRef { def_id: did, substs: rcvr_substs.clone() };\n \n         do self.push_inherent_candidates_from_bounds_inner(&[trait_ref])\n-            |trait_ref, m, method_num, _bound_num| {\n+            |new_trait_ref, m, method_num, _bound_num| {\n             let vtable_index =\n-                self.get_method_index(trait_ref, trait_ref.def_id, method_num);\n+                self.get_method_index(new_trait_ref, trait_ref, method_num);\n             // We need to fix up the transformed self type.\n             let transformed_self_ty =\n                 self.construct_transformed_self_ty_for_object("}, {"sha": "e60f8d4c88895fdc52d2eee4efe75e7c64a9dda6", "filename": "src/test/run-pass/issue-9394-inherited-trait-calls.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/56d415aa60b41e171890cb76a323cb95d617b077/src%2Ftest%2Frun-pass%2Fissue-9394-inherited-trait-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56d415aa60b41e171890cb76a323cb95d617b077/src%2Ftest%2Frun-pass%2Fissue-9394-inherited-trait-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9394-inherited-trait-calls.rs?ref=56d415aa60b41e171890cb76a323cb95d617b077", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Base: Base2 + Base3{\n+    fn foo(&self) -> ~str;\n+}\n+\n+trait Base2: Base3{\n+    fn baz(&self) -> ~str;\n+}\n+\n+trait Base3{\n+    fn root(&self) -> ~str;\n+}\n+\n+trait Super: Base{\n+    fn bar(&self) -> ~str;\n+}\n+\n+struct X;\n+\n+impl Base for X {\n+    fn foo(&self) -> ~str{\n+        ~\"base foo\"\n+    }\n+\n+}\n+\n+impl Base2 for X {\n+    fn baz(&self) -> ~str{\n+        ~\"base2 baz\"\n+    }\n+}\n+\n+impl Base3 for X {\n+    fn root(&self) -> ~str{\n+        ~\"base3 root\"\n+    }\n+}\n+\n+impl Super for X {\n+    fn bar(&self) -> ~str{\n+        ~\"super bar\"\n+    }\n+}\n+\n+pub fn main() {\n+    let n = X;\n+    let s = &n as &Super;\n+    assert_eq!(s.bar(),~\"super bar\");\n+    assert_eq!(s.foo(),~\"base foo\");\n+    assert_eq!(s.baz(),~\"base2 baz\");\n+    assert_eq!(s.root(),~\"base3 root\");\n+}"}]}