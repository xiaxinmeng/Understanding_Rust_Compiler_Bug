{"sha": "e468a1af350f344067f7c44aae060e2977798dbb", "node_id": "C_kwDOAAsO6NoAKGU0NjhhMWFmMzUwZjM0NDA2N2Y3YzQ0YWFlMDYwZTI5Nzc3OThkYmI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-11-04T23:27:03Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-11-05T09:59:46Z"}, "message": "internal: Optimize `apply_document_changes` a bit", "tree": {"sha": "6074e7f357c28b53c881bb1ce5b92073da02e9d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6074e7f357c28b53c881bb1ce5b92073da02e9d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e468a1af350f344067f7c44aae060e2977798dbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e468a1af350f344067f7c44aae060e2977798dbb", "html_url": "https://github.com/rust-lang/rust/commit/e468a1af350f344067f7c44aae060e2977798dbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e468a1af350f344067f7c44aae060e2977798dbb/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd2603299c4ea2a82511e4dc4a876ff2a05fe26e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd2603299c4ea2a82511e4dc4a876ff2a05fe26e", "html_url": "https://github.com/rust-lang/rust/commit/cd2603299c4ea2a82511e4dc4a876ff2a05fe26e"}], "stats": {"total": 124, "additions": 68, "deletions": 56}, "files": [{"sha": "1b8f56187a02bf78f214fc0dacb7087ba16fc45d", "filename": "crates/ide-db/src/line_index.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e468a1af350f344067f7c44aae060e2977798dbb/crates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e468a1af350f344067f7c44aae060e2977798dbb/crates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fline_index.rs?ref=e468a1af350f344067f7c44aae060e2977798dbb", "patch": "@@ -58,8 +58,11 @@ impl LineIndex {\n         let mut utf16_lines = NoHashHashMap::default();\n         let mut utf16_chars = Vec::new();\n \n-        let mut newlines = vec![0.into()];\n-        let mut curr_row @ mut curr_col = 0.into();\n+        let mut newlines = Vec::with_capacity(16);\n+        newlines.push(TextSize::from(0));\n+\n+        let mut curr_row = 0.into();\n+        let mut curr_col = 0.into();\n         let mut line = 0;\n         for c in text.chars() {\n             let c_len = TextSize::of(c);"}, {"sha": "0971dc36f3a5c84ef1f1ab34ae0da88c4ce70edc", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e468a1af350f344067f7c44aae060e2977798dbb/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e468a1af350f344067f7c44aae060e2977798dbb/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=e468a1af350f344067f7c44aae060e2977798dbb", "patch": "@@ -1,5 +1,5 @@\n //! Utilities for LSP-related boilerplate code.\n-use std::{ops::Range, sync::Arc};\n+use std::{mem, ops::Range, sync::Arc};\n \n use lsp_server::Notification;\n \n@@ -133,11 +133,37 @@ impl GlobalState {\n }\n \n pub(crate) fn apply_document_changes(\n-    old_text: &mut String,\n-    content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n-) {\n+    file_contents: impl FnOnce() -> String,\n+    mut content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n+) -> String {\n+    // Skip to the last full document change, as it invalidates all previous changes anyways.\n+    let mut start = content_changes\n+        .iter()\n+        .rev()\n+        .position(|change| change.range.is_none())\n+        .map(|idx| content_changes.len() - idx - 1)\n+        .unwrap_or(0);\n+\n+    let mut text: String = match content_changes.get_mut(start) {\n+        // peek at the first content change as an optimization\n+        Some(lsp_types::TextDocumentContentChangeEvent { range: None, text, .. }) => {\n+            let text = mem::take(text);\n+            start += 1;\n+\n+            // The only change is a full document update\n+            if start == content_changes.len() {\n+                return text;\n+            }\n+            text\n+        }\n+        Some(_) => file_contents(),\n+        // we received no content changes\n+        None => return file_contents(),\n+    };\n+\n     let mut line_index = LineIndex {\n-        index: Arc::new(ide::LineIndex::new(old_text)),\n+        // the index will be overwritten in the bottom loop's first iteration\n+        index: Arc::new(ide::LineIndex::new(&text)),\n         // We don't care about line endings or offset encoding here.\n         endings: LineEndings::Unix,\n         encoding: PositionEncoding::Utf16,\n@@ -148,38 +174,20 @@ pub(crate) fn apply_document_changes(\n     // Some clients (e.g. Code) sort the ranges in reverse. As an optimization, we\n     // remember the last valid line in the index and only rebuild it if needed.\n     // The VFS will normalize the end of lines to `\\n`.\n-    enum IndexValid {\n-        All,\n-        UpToLineExclusive(u32),\n-    }\n-\n-    impl IndexValid {\n-        fn covers(&self, line: u32) -> bool {\n-            match *self {\n-                IndexValid::UpToLineExclusive(to) => to > line,\n-                _ => true,\n-            }\n-        }\n-    }\n-\n-    let mut index_valid = IndexValid::All;\n+    let mut index_valid = !0u32;\n     for change in content_changes {\n-        match change.range {\n-            Some(range) => {\n-                if !index_valid.covers(range.end.line) {\n-                    line_index.index = Arc::new(ide::LineIndex::new(old_text));\n-                }\n-                index_valid = IndexValid::UpToLineExclusive(range.start.line);\n-                if let Ok(range) = from_proto::text_range(&line_index, range) {\n-                    old_text.replace_range(Range::<usize>::from(range), &change.text);\n-                }\n+        // The None case can't happen as we have handled it above already\n+        if let Some(range) = change.range {\n+            if index_valid <= range.end.line {\n+                *Arc::make_mut(&mut line_index.index) = ide::LineIndex::new(&text);\n             }\n-            None => {\n-                *old_text = change.text;\n-                index_valid = IndexValid::UpToLineExclusive(0);\n+            index_valid = range.start.line;\n+            if let Ok(range) = from_proto::text_range(&line_index, range) {\n+                text.replace_range(Range::<usize>::from(range), &change.text);\n             }\n         }\n     }\n+    text\n }\n \n /// Checks that the edits inside the completion and the additional edits do not overlap.\n@@ -242,51 +250,50 @@ mod tests {\n             };\n         }\n \n-        let mut text = String::new();\n-        apply_document_changes(&mut text, vec![]);\n+        let text = apply_document_changes(|| String::new(), vec![]);\n         assert_eq!(text, \"\");\n-        apply_document_changes(\n-            &mut text,\n+        let text = apply_document_changes(\n+            || text,\n             vec![TextDocumentContentChangeEvent {\n                 range: None,\n                 range_length: None,\n                 text: String::from(\"the\"),\n             }],\n         );\n         assert_eq!(text, \"the\");\n-        apply_document_changes(&mut text, c![0, 3; 0, 3 => \" quick\"]);\n+        let text = apply_document_changes(|| text, c![0, 3; 0, 3 => \" quick\"]);\n         assert_eq!(text, \"the quick\");\n-        apply_document_changes(&mut text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n+        let text = apply_document_changes(|| text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n         assert_eq!(text, \"quick foxes\");\n-        apply_document_changes(&mut text, c![0, 11; 0, 11 => \"\\ndream\"]);\n+        let text = apply_document_changes(|| text, c![0, 11; 0, 11 => \"\\ndream\"]);\n         assert_eq!(text, \"quick foxes\\ndream\");\n-        apply_document_changes(&mut text, c![1, 0; 1, 0 => \"have \"]);\n+        let text = apply_document_changes(|| text, c![1, 0; 1, 0 => \"have \"]);\n         assert_eq!(text, \"quick foxes\\nhave dream\");\n-        apply_document_changes(\n-            &mut text,\n+        let text = apply_document_changes(\n+            || text,\n             c![0, 0; 0, 0 => \"the \", 1, 4; 1, 4 => \" quiet\", 1, 16; 1, 16 => \"s\\n\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nhave quiet dreams\\n\");\n-        apply_document_changes(&mut text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n+        let text = apply_document_changes(|| text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n         assert_eq!(text, \"the quick foxes\\n\\nhave quiet dreams\\n\\n\");\n-        apply_document_changes(\n-            &mut text,\n+        let text = apply_document_changes(\n+            || text,\n             c![1, 0; 1, 0 => \"DREAM\", 2, 0; 2, 0 => \"they \", 3, 0; 3, 0 => \"DON'T THEY?\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nDREAM\\nthey have quiet dreams\\nDON'T THEY?\\n\");\n-        apply_document_changes(&mut text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n+        let text = apply_document_changes(|| text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n         assert_eq!(text, \"the quick \\nthey have quiet dreams\\n\");\n \n-        text = String::from(\"\u2764\ufe0f\");\n-        apply_document_changes(&mut text, c![0, 0; 0, 0 => \"a\"]);\n+        let text = String::from(\"\u2764\ufe0f\");\n+        let text = apply_document_changes(|| text, c![0, 0; 0, 0 => \"a\"]);\n         assert_eq!(text, \"a\u2764\ufe0f\");\n \n-        text = String::from(\"a\\nb\");\n-        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n+        let text = String::from(\"a\\nb\");\n+        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n         assert_eq!(text, \"adcb\");\n \n-        text = String::from(\"a\\nb\");\n-        apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n+        let text = String::from(\"a\\nb\");\n+        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n         assert_eq!(text, \"a\u021bc\\ncb\");\n     }\n "}, {"sha": "6e5da58fe372af1fa1c07b89d309b741c5404aff", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e468a1af350f344067f7c44aae060e2977798dbb/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e468a1af350f344067f7c44aae060e2977798dbb/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=e468a1af350f344067f7c44aae060e2977798dbb", "patch": "@@ -759,8 +759,10 @@ impl GlobalState {\n \n                     let vfs = &mut this.vfs.write().0;\n                     let file_id = vfs.file_id(&path).unwrap();\n-                    let mut text = String::from_utf8(vfs.file_contents(file_id).to_vec()).unwrap();\n-                    apply_document_changes(&mut text, params.content_changes);\n+                    let text = apply_document_changes(\n+                        || std::str::from_utf8(vfs.file_contents(file_id)).unwrap().into(),\n+                        params.content_changes,\n+                    );\n \n                     vfs.set_file_contents(path, Some(text.into_bytes()));\n                 }"}]}