{"sha": "972f2e585528515eaab4bee7270acda7f7375398", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MmYyZTU4NTUyODUxNWVhYWI0YmVlNzI3MGFjZGE3ZjczNzUzOTg=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-03-25T06:22:23Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-14T01:45:20Z"}, "message": "io: Add .read_at_least() to Reader\n\nReader.read_at_least() ensures that at least a given number of bytes\nhave been read. The most common use-case for this is ensuring at least 1\nbyte has been read. If the reader returns 0 enough times in a row, a new\nerror kind NoProgress will be returned instead of looping infinitely.\n\nThis change is necessary in order to properly support Readers that\nrepeatedly return 0, either because they're broken, or because they're\nattempting to do a non-blocking read on some resource that never becomes\navailable.\n\nAlso add .push() and .push_at_least() methods. push() is like read() but\nthe results are appended to the passed Vec.\n\nRemove Reader.fill() and Reader.push_exact() as they end up being thin\nwrappers around read_at_least() and push_at_least().\n\n[breaking-change]", "tree": {"sha": "6a0f342014cfd7f5dc03c469dd754c19d7e81e78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a0f342014cfd7f5dc03c469dd754c19d7e81e78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/972f2e585528515eaab4bee7270acda7f7375398", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/972f2e585528515eaab4bee7270acda7f7375398", "html_url": "https://github.com/rust-lang/rust/commit/972f2e585528515eaab4bee7270acda7f7375398", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/972f2e585528515eaab4bee7270acda7f7375398/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb115ac2d4f57d8b590c8d46d8f9e2958ed9a527", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb115ac2d4f57d8b590c8d46d8f9e2958ed9a527", "html_url": "https://github.com/rust-lang/rust/commit/cb115ac2d4f57d8b590c8d46d8f9e2958ed9a527"}], "stats": {"total": 337, "additions": 253, "deletions": 84}, "files": [{"sha": "e800f64463b4e271df70150c7bf8d2a59acc09e5", "filename": "src/librand/reader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/972f2e585528515eaab4bee7270acda7f7375398/src%2Flibrand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972f2e585528515eaab4bee7270acda7f7375398/src%2Flibrand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freader.rs?ref=972f2e585528515eaab4bee7270acda7f7375398", "patch": "@@ -60,8 +60,8 @@ impl<R: Reader> Rng for ReaderRng<R> {\n     }\n     fn fill_bytes(&mut self, v: &mut [u8]) {\n         if v.len() == 0 { return }\n-        match self.reader.fill(v) {\n-            Ok(()) => {}\n+        match self.reader.read_at_least(v.len(), v) {\n+            Ok(_) => {}\n             Err(e) => fail!(\"ReaderRng.fill_bytes error: {}\", e)\n         }\n     }"}, {"sha": "29afd2b1d9b2b95c5d97ca2ee9379bfdb9a972d9", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/972f2e585528515eaab4bee7270acda7f7375398/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972f2e585528515eaab4bee7270acda7f7375398/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=972f2e585528515eaab4bee7270acda7f7375398", "patch": "@@ -342,39 +342,39 @@ mod test {\n     }\n \n     #[test]\n-    fn push_exact() {\n-        let mut reader = MemReader::new(vec!(10, 11, 12, 13));\n-        let mut buf = vec!(8, 9);\n-        reader.push_exact(&mut buf, 4).unwrap();\n-        assert!(buf == vec!(8, 9, 10, 11, 12, 13));\n+    fn push_at_least() {\n+        let mut reader = MemReader::new(vec![10, 11, 12, 13]);\n+        let mut buf = vec![8, 9];\n+        assert!(reader.push_at_least(4, 4, &mut buf).is_ok());\n+        assert!(buf == vec![8, 9, 10, 11, 12, 13]);\n     }\n \n     #[test]\n-    fn push_exact_partial() {\n+    fn push_at_least_partial() {\n         let mut reader = PartialReader {\n             count: 0,\n         };\n-        let mut buf = vec!(8, 9);\n-        reader.push_exact(&mut buf, 4).unwrap();\n-        assert!(buf == vec!(8, 9, 10, 11, 12, 13));\n+        let mut buf = vec![8, 9];\n+        assert!(reader.push_at_least(4, 4, &mut buf).is_ok());\n+        assert!(buf == vec![8, 9, 10, 11, 12, 13]);\n     }\n \n     #[test]\n-    fn push_exact_eof() {\n-        let mut reader = MemReader::new(vec!(10, 11));\n-        let mut buf = vec!(8, 9);\n-        assert!(reader.push_exact(&mut buf, 4).is_err());\n-        assert!(buf == vec!(8, 9, 10, 11));\n+    fn push_at_least_eof() {\n+        let mut reader = MemReader::new(vec![10, 11]);\n+        let mut buf = vec![8, 9];\n+        assert!(reader.push_at_least(4, 4, &mut buf).is_err());\n+        assert!(buf == vec![8, 9, 10, 11]);\n     }\n \n     #[test]\n-    fn push_exact_error() {\n+    fn push_at_least_error() {\n         let mut reader = ErroringLaterReader {\n             count: 0,\n         };\n-        let mut buf = vec!(8, 9);\n-        assert!(reader.push_exact(&mut buf, 4).is_err());\n-        assert!(buf == vec!(8, 9, 10));\n+        let mut buf = vec![8, 9];\n+        assert!(reader.push_at_least(4, 4, &mut buf).is_err());\n+        assert!(buf == vec![8, 9, 10]);\n     }\n \n     #[test]"}, {"sha": "291b4f948416fb9d7c9494c97adf9d47c1918e09", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/972f2e585528515eaab4bee7270acda7f7375398/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972f2e585528515eaab4bee7270acda7f7375398/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=972f2e585528515eaab4bee7270acda7f7375398", "patch": "@@ -559,16 +559,16 @@ mod test {\n     }\n \n     #[test]\n-    fn io_fill() {\n-        let mut r = MemReader::new(vec!(1, 2, 3, 4, 5, 6, 7, 8));\n+    fn io_read_at_least() {\n+        let mut r = MemReader::new(vec![1, 2, 3, 4, 5, 6, 7, 8]);\n         let mut buf = [0, ..3];\n-        assert_eq!(r.fill(buf), Ok(()));\n+        assert!(r.read_at_least(buf.len(), buf).is_ok());\n         assert_eq!(buf.as_slice(), &[1, 2, 3]);\n-        assert_eq!(r.fill(buf.mut_slice_to(0)), Ok(()));\n+        assert!(r.read_at_least(0, buf.mut_slice_to(0)).is_ok());\n         assert_eq!(buf.as_slice(), &[1, 2, 3]);\n-        assert_eq!(r.fill(buf), Ok(()));\n+        assert!(r.read_at_least(buf.len(), buf).is_ok());\n         assert_eq!(buf.as_slice(), &[4, 5, 6]);\n-        assert!(r.fill(buf).is_err());\n+        assert!(r.read_at_least(buf.len(), buf).is_err());\n         assert_eq!(buf.as_slice(), &[7, 8, 6]);\n     }\n }"}, {"sha": "b654e278c3f8c6efd48613cd20fc7f50ce75d0af", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 227, "deletions": 58, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/972f2e585528515eaab4bee7270acda7f7375398/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972f2e585528515eaab4bee7270acda7f7375398/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=972f2e585528515eaab4bee7270acda7f7375398", "patch": "@@ -229,7 +229,6 @@ use slice::{Vector, MutableVector, ImmutableVector};\n use str::{StrSlice, StrAllocating};\n use str;\n use uint;\n-use unstable::finally::try_finally;\n use vec::Vec;\n \n // Reexports\n@@ -442,8 +441,12 @@ pub enum IoErrorKind {\n     /// The payload contained as part of this variant is the number of bytes\n     /// which are known to have been successfully written.\n     ShortWrite(uint),\n+    /// The Reader returned 0 bytes from `read()` too many times.\n+    NoProgress,\n }\n \n+static NO_PROGRESS_LIMIT: uint = 1000;\n+\n /// A trait for objects which are byte-oriented streams. Readers are defined by\n /// one method, `read`. This function will block until data is available,\n /// filling in the provided buffer with any data read.\n@@ -456,7 +459,7 @@ pub trait Reader {\n     // Only method which need to get implemented for this trait\n \n     /// Read bytes, up to the length of `buf` and place them in `buf`.\n-    /// Returns the number of bytes read. The number of bytes read my\n+    /// Returns the number of bytes read. The number of bytes read may\n     /// be less than the number requested, even 0. Returns `Err` on EOF.\n     ///\n     /// # Error\n@@ -465,74 +468,113 @@ pub trait Reader {\n     /// `Err(IoError)`. Note that end-of-file is considered an error, and can be\n     /// inspected for in the error's `kind` field. Also note that reading 0\n     /// bytes is not considered an error in all circumstances\n+    ///\n+    /// # Implementaton Note\n+    ///\n+    /// When implementing this method on a new Reader, you are strongly encouraged\n+    /// not to return 0 if you can avoid it.\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n \n     // Convenient helper methods based on the above methods\n \n-    /// Reads a single byte. Returns `Err` on EOF.\n-    fn read_byte(&mut self) -> IoResult<u8> {\n-        let mut buf = [0];\n-        loop {\n-            match self.read(buf) {\n-                Ok(0) => {}\n-                Ok(1) => return Ok(buf[0]),\n-                Ok(_) => unreachable!(),\n-                Err(e) => return Err(e)\n-            }\n-        }\n-    }\n-\n-    /// Fills the provided slice with bytes from this reader\n+    /// Reads at least `min` bytes and places them in `buf`.\n+    /// Returns the number of bytes read.\n     ///\n-    /// This will continue to call `read` until the slice has been completely\n-    /// filled with bytes.\n+    /// This will continue to call `read` until at least `min` bytes have been\n+    /// read. If `read` returns 0 too many times, `NoProgress` will be\n+    /// returned.\n     ///\n     /// # Error\n     ///\n     /// If an error occurs at any point, that error is returned, and no further\n     /// bytes are read.\n-    fn fill(&mut self, buf: &mut [u8]) -> IoResult<()> {\n+    fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n+        if min > buf.len() {\n+            return Err(IoError { detail: Some(\"the buffer is too short\".to_owned()),\n+                                 ..standard_error(InvalidInput) });\n+        }\n         let mut read = 0;\n-        while read < buf.len() {\n-            read += try!(self.read(buf.mut_slice_from(read)));\n+        while read < min {\n+            let mut zeroes = 0;\n+            loop {\n+                match self.read(buf.mut_slice_from(read)) {\n+                    Ok(0) => {\n+                        zeroes += 1;\n+                        if zeroes >= NO_PROGRESS_LIMIT {\n+                            return Err(standard_error(NoProgress));\n+                        }\n+                    }\n+                    Ok(n) => {\n+                        read += n;\n+                        break;\n+                    }\n+                    err@Err(_) => return err\n+                }\n+            }\n         }\n-        Ok(())\n+        Ok(read)\n+    }\n+\n+    /// Reads a single byte. Returns `Err` on EOF.\n+    fn read_byte(&mut self) -> IoResult<u8> {\n+        let mut buf = [0];\n+        try!(self.read_at_least(1, buf));\n+        Ok(buf[0])\n     }\n \n-    /// Reads exactly `len` bytes and appends them to a vector.\n+    /// Reads up to `len` bytes and appends them to a vector.\n+    /// Returns the number of bytes read. The number of bytes read may be\n+    /// less than the number requested, even 0. Returns Err on EOF.\n+    ///\n+    /// # Error\n     ///\n-    /// May push fewer than the requested number of bytes on error\n-    /// or EOF. If `Ok(())` is returned, then all of the requested bytes were\n-    /// pushed on to the vector, otherwise the amount `len` bytes couldn't be\n-    /// read (an error was encountered), and the error is returned.\n-    fn push_exact(&mut self, buf: &mut Vec<u8>, len: uint) -> IoResult<()> {\n-        struct State<'a> {\n-            buf: &'a mut Vec<u8>,\n-            total_read: uint\n+    /// If an error occurs during this I/O operation, then it is returned\n+    /// as `Err(IoError)`. See `read()` for more details.\n+    fn push(&mut self, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n+        let start_len = buf.len();\n+        buf.reserve_additional(len);\n+\n+        let n = {\n+            let s = unsafe { slice_vec_capacity(buf, start_len, start_len + len) };\n+            try!(self.read(s))\n+        };\n+        unsafe { buf.set_len(start_len + n) };\n+        Ok(n)\n+    }\n+\n+    /// Reads at least `min` bytes, but no more than `len`, and appends them to\n+    /// a vector.\n+    /// Returns the number of bytes read.\n+    ///\n+    /// This will continue to call `read` until at least `min` bytes have been\n+    /// read. If `read` returns 0 too many times, `NoProgress` will be\n+    /// returned.\n+    ///\n+    /// # Error\n+    ///\n+    /// If an error occurs at any point, that error is returned, and no further\n+    /// bytes are read.\n+    fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n+        if min > len {\n+            return Err(IoError { detail: Some(\"the buffer is too short\".to_owned()),\n+                                 ..standard_error(InvalidInput) });\n         }\n \n         let start_len = buf.len();\n-        let mut s = State { buf: buf, total_read: 0 };\n-\n-        s.buf.reserve_additional(len);\n-        unsafe { s.buf.set_len(start_len + len); }\n-\n-        try_finally(\n-            &mut s, (),\n-            |s, _| {\n-                while s.total_read < len {\n-                    let len = s.buf.len();\n-                    let slice = s.buf.mut_slice(start_len + s.total_read, len);\n-                    match self.read(slice) {\n-                        Ok(nread) => {\n-                            s.total_read += nread;\n-                        }\n-                        Err(e) => return Err(e)\n-                    }\n-                }\n-                Ok(())\n-            },\n-            |s| unsafe { s.buf.set_len(start_len + s.total_read) })\n+        buf.reserve_additional(len);\n+\n+        // we can't just use self.read_at_least(min, slice) because we need to push\n+        // successful reads onto the vector before any returned errors.\n+\n+        let mut read = 0;\n+        while read < min {\n+            read += {\n+                let s = unsafe { slice_vec_capacity(buf, start_len + read, start_len + len) };\n+                try!(self.read_at_least(1, s))\n+            };\n+            unsafe { buf.set_len(start_len + read) };\n+        }\n+        Ok(read)\n     }\n \n     /// Reads exactly `len` bytes and gives you back a new vector of length\n@@ -544,11 +586,11 @@ pub trait Reader {\n     /// on EOF. Note that if an error is returned, then some number of bytes may\n     /// have already been consumed from the underlying reader, and they are lost\n     /// (not returned as part of the error). If this is unacceptable, then it is\n-    /// recommended to use the `push_exact` or `read` methods.\n+    /// recommended to use the `push_at_least` or `read` methods.\n     fn read_exact(&mut self, len: uint) -> IoResult<Vec<u8>> {\n         let mut buf = Vec::with_capacity(len);\n-        match self.push_exact(&mut buf, len) {\n-            Ok(()) => Ok(buf),\n+        match self.push_at_least(len, len, &mut buf) {\n+            Ok(_) => Ok(buf),\n             Err(e) => Err(e),\n         }\n     }\n@@ -564,8 +606,8 @@ pub trait Reader {\n     fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n         let mut buf = Vec::with_capacity(DEFAULT_BUF_SIZE);\n         loop {\n-            match self.push_exact(&mut buf, DEFAULT_BUF_SIZE) {\n-                Ok(()) => {}\n+            match self.push_at_least(1, DEFAULT_BUF_SIZE, &mut buf) {\n+                Ok(_) => {}\n                 Err(ref e) if e.kind == EndOfFile => break,\n                 Err(e) => return Err(e)\n             }\n@@ -828,6 +870,29 @@ impl<'a> Reader for &'a mut Reader {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.read(buf) }\n }\n \n+/// Returns a slice of `v` between `start` and `end`.\n+///\n+/// Similar to `slice()` except this function only bounds the sclie on the\n+/// capacity of `v`, not the length.\n+///\n+/// # Failure\n+///\n+/// Fails when `start` or `end` point outside the capacity of `v`, or when\n+/// `start` > `end`.\n+// Private function here because we aren't sure if we want to expose this as\n+// API yet. If so, it should be a method on Vec.\n+unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -> &'a mut [T] {\n+    use raw::Slice;\n+    use ptr::RawPtr;\n+\n+    assert!(start <= end);\n+    assert!(end <= v.capacity());\n+    transmute(Slice {\n+        data: v.as_ptr().offset(start as int),\n+        len: end - start\n+    })\n+}\n+\n /// A `RefReader` is a struct implementing `Reader` which contains a reference\n /// to another reader. This is often useful when composing streams.\n ///\n@@ -1192,7 +1257,7 @@ pub trait Buffer: Reader {\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]>;\n \n     /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n-    /// so they should no longer be returned in calls to `fill` or `read`.\n+    /// so they should no longer be returned in calls to `read`.\n     fn consume(&mut self, amt: uint);\n \n     /// Reads the next line of input, interpreted as a sequence of UTF-8\n@@ -1439,6 +1504,7 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n         ResourceUnavailable => \"resource unavailable\",\n         TimedOut => \"operation timed out\",\n         ShortWrite(..) => \"short write\",\n+        NoProgress => \"no progress\",\n     };\n     IoError {\n         kind: kind,\n@@ -1608,3 +1674,106 @@ on unix-like systems.\"]\n         static AllPermissions = UserRWX.bits | GroupRWX.bits | OtherRWX.bits\n     }\n )\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{IoResult, Reader, MemReader, NoProgress, InvalidInput};\n+    use prelude::*;\n+    use uint;\n+\n+    #[deriving(Clone, Eq, Show)]\n+    enum BadReaderBehavior {\n+        GoodBehavior(uint),\n+        BadBehavior(uint)\n+    }\n+\n+    struct BadReader<T> {\n+        r: T,\n+        behavior: Vec<BadReaderBehavior>,\n+    }\n+\n+    impl<T: Reader> BadReader<T> {\n+        fn new(r: T, behavior: Vec<BadReaderBehavior>) -> BadReader<T> {\n+            BadReader { behavior: behavior, r: r }\n+        }\n+    }\n+\n+    impl<T: Reader> Reader for BadReader<T> {\n+        fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+            let BadReader { ref mut behavior, ref mut r } = *self;\n+            loop {\n+                if behavior.is_empty() {\n+                    // fall back on good\n+                    return r.read(buf);\n+                }\n+                match behavior.as_mut_slice()[0] {\n+                    GoodBehavior(0) => (),\n+                    GoodBehavior(ref mut x) => {\n+                        *x -= 1;\n+                        return r.read(buf);\n+                    }\n+                    BadBehavior(0) => (),\n+                    BadBehavior(ref mut x) => {\n+                        *x -= 1;\n+                        return Ok(0);\n+                    }\n+                };\n+                behavior.shift();\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_at_least() {\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+                                   Vec::from_slice([GoodBehavior(uint::MAX)]));\n+        let mut buf = [0u8, ..5];\n+        assert!(r.read_at_least(1, buf).unwrap() >= 1);\n+        assert!(r.read_exact(5).unwrap().len() == 5); // read_exact uses read_at_least\n+        assert!(r.read_at_least(0, buf).is_ok());\n+\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+                                   Vec::from_slice([BadBehavior(50), GoodBehavior(uint::MAX)]));\n+        assert!(r.read_at_least(1, buf).unwrap() >= 1);\n+\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+                                   Vec::from_slice([BadBehavior(1), GoodBehavior(1),\n+                                                    BadBehavior(50), GoodBehavior(uint::MAX)]));\n+        assert!(r.read_at_least(1, buf).unwrap() >= 1);\n+        assert!(r.read_at_least(1, buf).unwrap() >= 1);\n+\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+                                   Vec::from_slice([BadBehavior(uint::MAX)]));\n+        assert_eq!(r.read_at_least(1, buf).unwrap_err().kind, NoProgress);\n+\n+        let mut r = MemReader::new(Vec::from_slice(bytes!(\"hello, world!\")));\n+        assert_eq!(r.read_at_least(5, buf).unwrap(), 5);\n+        assert_eq!(r.read_at_least(6, buf).unwrap_err().kind, InvalidInput);\n+    }\n+\n+    #[test]\n+    fn test_push_at_least() {\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+                                   Vec::from_slice([GoodBehavior(uint::MAX)]));\n+        let mut buf = Vec::new();\n+        assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n+        assert!(r.push_at_least(0, 5, &mut buf).is_ok());\n+\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+                                   Vec::from_slice([BadBehavior(50), GoodBehavior(uint::MAX)]));\n+        assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n+\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+                                   Vec::from_slice([BadBehavior(1), GoodBehavior(1),\n+                                                    BadBehavior(50), GoodBehavior(uint::MAX)]));\n+        assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n+        assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n+\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+                                   Vec::from_slice([BadBehavior(uint::MAX)]));\n+        assert_eq!(r.push_at_least(1, 5, &mut buf).unwrap_err().kind, NoProgress);\n+\n+        let mut r = MemReader::new(Vec::from_slice(bytes!(\"hello, world!\")));\n+        assert_eq!(r.push_at_least(5, 1, &mut buf).unwrap_err().kind, InvalidInput);\n+    }\n+}"}]}