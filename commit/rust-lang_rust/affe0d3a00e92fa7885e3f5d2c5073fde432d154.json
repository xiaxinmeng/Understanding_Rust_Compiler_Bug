{"sha": "affe0d3a00e92fa7885e3f5d2c5073fde432d154", "node_id": "C_kwDOAAsO6NoAKGFmZmUwZDNhMDBlOTJmYTc4ODVlM2Y1ZDJjNTA3M2ZkZTQzMmQxNTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-05T16:35:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-05T16:35:15Z"}, "message": "Auto merge of #100174 - Dylan-DPC:rollup-wnskbk6, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #99835 (Suggest adding/removing `ref` for binding patterns)\n - #100155 (Use `node_type_opt` to skip over generics that were not expected)\n - #100157 (rustdoc: use `collect()` instead of repeatedly pushing)\n - #100158 (kmc-solid: Add a stub implementation of #98246 (`File::set_times`))\n - #100166 (Remove more Clean trait implementations)\n - #100168 (Improve diagnostics for `const a: = expr;`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "bb7a9c8dd3aed7b5f7a4040105d0ca15e31915e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb7a9c8dd3aed7b5f7a4040105d0ca15e31915e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/affe0d3a00e92fa7885e3f5d2c5073fde432d154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/affe0d3a00e92fa7885e3f5d2c5073fde432d154", "html_url": "https://github.com/rust-lang/rust/commit/affe0d3a00e92fa7885e3f5d2c5073fde432d154", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/affe0d3a00e92fa7885e3f5d2c5073fde432d154/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d77da9da84fc89908ad01578c33c2dca8f597ffe", "url": "https://api.github.com/repos/rust-lang/rust/commits/d77da9da84fc89908ad01578c33c2dca8f597ffe", "html_url": "https://github.com/rust-lang/rust/commit/d77da9da84fc89908ad01578c33c2dca8f597ffe"}, {"sha": "e7ed8443eab1902432df5864a0fe7adae851d5ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7ed8443eab1902432df5864a0fe7adae851d5ea", "html_url": "https://github.com/rust-lang/rust/commit/e7ed8443eab1902432df5864a0fe7adae851d5ea"}], "stats": {"total": 576, "additions": 414, "deletions": 162}, "files": [{"sha": "fb92ce41252fe5b4392803998703eaa6119a437f", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -1179,39 +1179,47 @@ impl<'a> Parser<'a> {\n \n         // Parse the type of a `const` or `static mut?` item.\n         // That is, the `\":\" $ty` fragment.\n-        let ty = if self.eat(&token::Colon) {\n-            self.parse_ty()?\n-        } else {\n-            self.recover_missing_const_type(id, m)\n+        let ty = match (self.eat(&token::Colon), self.check(&token::Eq) | self.check(&token::Semi))\n+        {\n+            // If there wasn't a `:` or the colon was followed by a `=` or `;` recover a missing type.\n+            (true, false) => self.parse_ty()?,\n+            (colon, _) => self.recover_missing_const_type(colon, m),\n         };\n \n         let expr = if self.eat(&token::Eq) { Some(self.parse_expr()?) } else { None };\n         self.expect_semi()?;\n         Ok((id, ty, expr))\n     }\n \n-    /// We were supposed to parse `:` but the `:` was missing.\n+    /// We were supposed to parse `\":\" $ty` but the `:` or the type was missing.\n     /// This means that the type is missing.\n-    fn recover_missing_const_type(&mut self, id: Ident, m: Option<Mutability>) -> P<Ty> {\n+    fn recover_missing_const_type(&mut self, colon_present: bool, m: Option<Mutability>) -> P<Ty> {\n         // Construct the error and stash it away with the hope\n         // that typeck will later enrich the error with a type.\n         let kind = match m {\n             Some(Mutability::Mut) => \"static mut\",\n             Some(Mutability::Not) => \"static\",\n             None => \"const\",\n         };\n-        let mut err = self.struct_span_err(id.span, &format!(\"missing type for `{kind}` item\"));\n+\n+        let colon = match colon_present {\n+            true => \"\",\n+            false => \":\",\n+        };\n+\n+        let span = self.prev_token.span.shrink_to_hi();\n+        let mut err = self.struct_span_err(span, &format!(\"missing type for `{kind}` item\"));\n         err.span_suggestion(\n-            id.span,\n+            span,\n             \"provide a type for the item\",\n-            format!(\"{id}: <type>\"),\n+            format!(\"{colon} <type>\"),\n             Applicability::HasPlaceholders,\n         );\n-        err.stash(id.span, StashKey::ItemNoType);\n+        err.stash(span, StashKey::ItemNoType);\n \n         // The user intended that the type be inferred,\n         // so treat this as if the user wrote e.g. `const A: _ = expr;`.\n-        P(Ty { kind: TyKind::Infer, span: id.span, id: ast::DUMMY_NODE_ID, tokens: None })\n+        P(Ty { kind: TyKind::Infer, span, id: ast::DUMMY_NODE_ID, tokens: None })\n     }\n \n     /// Parses an enum declaration."}, {"sha": "660e7e4e399317ddddf540beb1256eed3cc84a88", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -1761,13 +1761,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .filter_map(|seg| seg.args.as_ref())\n                             .flat_map(|a| a.args.iter())\n                         {\n-                            if let hir::GenericArg::Type(hir_ty) = &arg {\n-                                let ty = self.resolve_vars_if_possible(\n-                                    self.typeck_results.borrow().node_type(hir_ty.hir_id),\n-                                );\n-                                if ty == predicate.self_ty() {\n-                                    error.obligation.cause.span = hir_ty.span;\n-                                }\n+                            if let hir::GenericArg::Type(hir_ty) = &arg\n+                                && let Some(ty) =\n+                                    self.typeck_results.borrow().node_type_opt(hir_ty.hir_id)\n+                                && self.resolve_vars_if_possible(ty) == predicate.self_ty()\n+                            {\n+                                error.obligation.cause.span = hir_ty.span;\n+                                break;\n                             }\n                         }\n                     }"}, {"sha": "a13c7152582077defba80f87f24df6a44adc8c4e", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -600,7 +600,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // If there are multiple arms, make sure they all agree on\n         // what the type of the binding `x` ought to be.\n         if var_id != pat.hir_id {\n-            self.check_binding_alt_eq_ty(pat.span, var_id, local_ty, ti);\n+            self.check_binding_alt_eq_ty(ba, pat.span, var_id, local_ty, ti);\n         }\n \n         if let Some(p) = sub {\n@@ -610,7 +610,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         local_ty\n     }\n \n-    fn check_binding_alt_eq_ty(&self, span: Span, var_id: HirId, ty: Ty<'tcx>, ti: TopInfo<'tcx>) {\n+    fn check_binding_alt_eq_ty(\n+        &self,\n+        ba: hir::BindingAnnotation,\n+        span: Span,\n+        var_id: HirId,\n+        ty: Ty<'tcx>,\n+        ti: TopInfo<'tcx>,\n+    ) {\n         let var_ty = self.local_ty(span, var_id).decl_ty;\n         if let Some(mut err) = self.demand_eqtype_pat_diag(span, var_ty, ty, ti) {\n             let hir = self.tcx.hir();\n@@ -628,12 +635,50 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n             let pre = if in_match { \"in the same arm, \" } else { \"\" };\n             err.note(&format!(\"{}a binding must have the same type in all alternatives\", pre));\n-            // FIXME: check if `var_ty` and `ty` can be made the same type by adding or removing\n-            // `ref` or `&` to the pattern.\n+            self.suggest_adding_missing_ref_or_removing_ref(\n+                &mut err,\n+                span,\n+                var_ty,\n+                self.resolve_vars_with_obligations(ty),\n+                ba,\n+            );\n             err.emit();\n         }\n     }\n \n+    fn suggest_adding_missing_ref_or_removing_ref(\n+        &self,\n+        err: &mut Diagnostic,\n+        span: Span,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        ba: hir::BindingAnnotation,\n+    ) {\n+        match (expected.kind(), actual.kind(), ba) {\n+            (ty::Ref(_, inner_ty, _), _, hir::BindingAnnotation::Unannotated)\n+                if self.can_eq(self.param_env, *inner_ty, actual).is_ok() =>\n+            {\n+                err.span_suggestion_verbose(\n+                    span.shrink_to_lo(),\n+                    \"consider adding `ref`\",\n+                    \"ref \",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            (_, ty::Ref(_, inner_ty, _), hir::BindingAnnotation::Ref)\n+                if self.can_eq(self.param_env, expected, *inner_ty).is_ok() =>\n+            {\n+                err.span_suggestion_verbose(\n+                    span.with_hi(span.lo() + BytePos(4)),\n+                    \"consider removing `ref`\",\n+                    \"\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            _ => (),\n+        }\n+    }\n+\n     // Precondition: pat is a Ref(_) pattern\n     fn borrow_pat_suggestion(&self, err: &mut Diagnostic, pat: &Pat<'_>) {\n         let tcx = self.tcx;"}, {"sha": "f1dbe64f13abbb33e3cb4a323abb015be0288489", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -801,6 +801,9 @@ fn infer_placeholder_type<'a>(\n     match tcx.sess.diagnostic().steal_diagnostic(span, StashKey::ItemNoType) {\n         Some(mut err) => {\n             if !ty.references_error() {\n+                // Only suggest adding `:` if it was missing (and suggested by parsing diagnostic)\n+                let colon = if span == item_ident.span.shrink_to_hi() { \":\" } else { \"\" };\n+\n                 // The parser provided a sub-optimal `HasPlaceholders` suggestion for the type.\n                 // We are typeck and have the real type, so remove that and suggest the actual type.\n                 // FIXME(eddyb) this looks like it should be functionality on `Diagnostic`.\n@@ -816,7 +819,7 @@ fn infer_placeholder_type<'a>(\n                     err.span_suggestion(\n                         span,\n                         &format!(\"provide a type for the {item}\", item = kind),\n-                        format!(\"{}: {}\", item_ident, sugg_ty),\n+                        format!(\"{colon} {sugg_ty}\"),\n                         Applicability::MachineApplicable,\n                     );\n                 } else {"}, {"sha": "772b29f3a11a3a868afde58c582d802935ff68ab", "filename": "library/std/src/sys/solid/fs.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -77,6 +77,9 @@ pub struct OpenOptions {\n     custom_flags: i32,\n }\n \n+#[derive(Copy, Clone, Debug, Default)]\n+pub struct FileTimes {}\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct FilePermissions(c_short);\n \n@@ -126,6 +129,11 @@ impl FilePermissions {\n     }\n }\n \n+impl FileTimes {\n+    pub fn set_accessed(&mut self, _t: SystemTime) {}\n+    pub fn set_modified(&mut self, _t: SystemTime) {}\n+}\n+\n impl FileType {\n     pub fn is_dir(&self) -> bool {\n         self.is(abi::S_IFDIR)\n@@ -452,6 +460,10 @@ impl File {\n     pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n         unsupported()\n     }\n+\n+    pub fn set_times(&self, _times: FileTimes) -> io::Result<()> {\n+        unsupported()\n+    }\n }\n \n impl Drop for File {"}, {"sha": "2368a1f1c7ebfeb8e10512101480b3e2998d20db", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 82, "deletions": 81, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -156,7 +156,7 @@ impl<'tcx> Clean<'tcx, Option<GenericBound>> for hir::GenericBound<'tcx> {\n                     return None;\n                 }\n \n-                GenericBound::TraitBound(t.clean(cx), modifier)\n+                GenericBound::TraitBound(clean_poly_trait_ref(t, cx), modifier)\n             }\n         })\n     }\n@@ -1001,69 +1001,68 @@ fn clean_trait_ref<'tcx>(trait_ref: &hir::TraitRef<'tcx>, cx: &mut DocContext<'t\n     path\n }\n \n-impl<'tcx> Clean<'tcx, PolyTrait> for hir::PolyTraitRef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> PolyTrait {\n-        PolyTrait {\n-            trait_: clean_trait_ref(&self.trait_ref, cx),\n-            generic_params: self\n-                .bound_generic_params\n-                .iter()\n-                .filter(|p| !is_elided_lifetime(p))\n-                .map(|x| clean_generic_param(cx, None, x))\n-                .collect(),\n-        }\n+fn clean_poly_trait_ref<'tcx>(\n+    poly_trait_ref: &hir::PolyTraitRef<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> PolyTrait {\n+    PolyTrait {\n+        trait_: clean_trait_ref(&poly_trait_ref.trait_ref, cx),\n+        generic_params: poly_trait_ref\n+            .bound_generic_params\n+            .iter()\n+            .filter(|p| !is_elided_lifetime(p))\n+            .map(|x| clean_generic_param(cx, None, x))\n+            .collect(),\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        let local_did = self.def_id.to_def_id();\n-        cx.with_param_env(local_did, |cx| {\n-            let inner = match self.kind {\n-                hir::TraitItemKind::Const(ty, Some(default)) => AssocConstItem(\n-                    clean_ty(ty, cx),\n-                    ConstantKind::Local { def_id: local_did, body: default },\n-                ),\n-                hir::TraitItemKind::Const(ty, None) => TyAssocConstItem(clean_ty(ty, cx)),\n-                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                    let m = clean_function(cx, sig, self.generics, body);\n-                    MethodItem(m, None)\n-                }\n-                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n-                    let (generics, decl) = enter_impl_trait(cx, |cx| {\n-                        // NOTE: generics must be cleaned before args\n-                        let generics = self.generics.clean(cx);\n-                        let args = clean_args_from_types_and_names(cx, sig.decl.inputs, names);\n-                        let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n-                        (generics, decl)\n-                    });\n-                    TyMethodItem(Box::new(Function { decl, generics }))\n-                }\n-                hir::TraitItemKind::Type(bounds, Some(default)) => {\n-                    let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n-                    let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n-                    let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, default), cx, None);\n-                    AssocTypeItem(\n-                        Box::new(Typedef {\n-                            type_: clean_ty(default, cx),\n-                            generics,\n-                            item_type: Some(item_type),\n-                        }),\n-                        bounds,\n-                    )\n-                }\n-                hir::TraitItemKind::Type(bounds, None) => {\n-                    let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n-                    let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n-                    TyAssocTypeItem(Box::new(generics), bounds)\n-                }\n-            };\n-            let what_rustc_thinks =\n-                Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx);\n-            // Trait items always inherit the trait's visibility -- we don't want to show `pub`.\n-            Item { visibility: Inherited, ..what_rustc_thinks }\n-        })\n-    }\n+fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n+    let local_did = trait_item.def_id.to_def_id();\n+    cx.with_param_env(local_did, |cx| {\n+        let inner = match trait_item.kind {\n+            hir::TraitItemKind::Const(ty, Some(default)) => AssocConstItem(\n+                clean_ty(ty, cx),\n+                ConstantKind::Local { def_id: local_did, body: default },\n+            ),\n+            hir::TraitItemKind::Const(ty, None) => TyAssocConstItem(clean_ty(ty, cx)),\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n+                let m = clean_function(cx, sig, trait_item.generics, body);\n+                MethodItem(m, None)\n+            }\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n+                let (generics, decl) = enter_impl_trait(cx, |cx| {\n+                    // NOTE: generics must be cleaned before args\n+                    let generics = trait_item.generics.clean(cx);\n+                    let args = clean_args_from_types_and_names(cx, sig.decl.inputs, names);\n+                    let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n+                    (generics, decl)\n+                });\n+                TyMethodItem(Box::new(Function { decl, generics }))\n+            }\n+            hir::TraitItemKind::Type(bounds, Some(default)) => {\n+                let generics = enter_impl_trait(cx, |cx| trait_item.generics.clean(cx));\n+                let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n+                let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, default), cx, None);\n+                AssocTypeItem(\n+                    Box::new(Typedef {\n+                        type_: clean_ty(default, cx),\n+                        generics,\n+                        item_type: Some(item_type),\n+                    }),\n+                    bounds,\n+                )\n+            }\n+            hir::TraitItemKind::Type(bounds, None) => {\n+                let generics = enter_impl_trait(cx, |cx| trait_item.generics.clean(cx));\n+                let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n+                TyAssocTypeItem(Box::new(generics), bounds)\n+            }\n+        };\n+        let what_rustc_thinks =\n+            Item::from_def_id_and_parts(local_did, Some(trait_item.ident.name), inner, cx);\n+        // Trait items always inherit the trait's visibility -- we don't want to show `pub`.\n+        Item { visibility: Inherited, ..what_rustc_thinks }\n+    })\n }\n \n impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n@@ -1515,7 +1514,7 @@ pub(crate) fn clean_ty<'tcx>(ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> T\n         }\n         TyKind::Path(_) => clean_qpath(ty, cx),\n         TyKind::TraitObject(bounds, ref lifetime, _) => {\n-            let bounds = bounds.iter().map(|bound| bound.clean(cx)).collect();\n+            let bounds = bounds.iter().map(|bound| clean_poly_trait_ref(bound, cx)).collect();\n             let lifetime =\n                 if !lifetime.is_elided() { Some(clean_lifetime(*lifetime, cx)) } else { None };\n             DynTrait(bounds, lifetime)\n@@ -1617,9 +1616,10 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             // HACK: pick the first `did` as the `did` of the trait object. Someone\n             // might want to implement \"native\" support for marker-trait-only\n             // trait objects.\n-            let mut dids = obj.principal_def_id().into_iter().chain(obj.auto_traits());\n-            let did = dids\n-                .next()\n+            let mut dids = obj.auto_traits();\n+            let did = obj\n+                .principal_def_id()\n+                .or_else(|| dids.next())\n                 .unwrap_or_else(|| panic!(\"found trait object `{:?}` with no traits?\", this));\n             let substs = match obj.principal() {\n                 Some(principal) => principal.skip_binder().substs,\n@@ -1630,19 +1630,18 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             inline::record_extern_fqn(cx, did, ItemType::Trait);\n \n             let lifetime = clean_middle_region(*reg);\n-            let mut bounds = vec![];\n-\n-            for did in dids {\n-                let empty = cx.tcx.intern_substs(&[]);\n-                let path = external_path(cx, did, false, vec![], empty);\n-                inline::record_extern_fqn(cx, did, ItemType::Trait);\n-                let bound = PolyTrait { trait_: path, generic_params: Vec::new() };\n-                bounds.push(bound);\n-            }\n+            let mut bounds = dids\n+                .map(|did| {\n+                    let empty = cx.tcx.intern_substs(&[]);\n+                    let path = external_path(cx, did, false, vec![], empty);\n+                    inline::record_extern_fqn(cx, did, ItemType::Trait);\n+                    PolyTrait { trait_: path, generic_params: Vec::new() }\n+                })\n+                .collect::<Vec<_>>();\n \n-            let mut bindings = vec![];\n-            for pb in obj.projection_bounds() {\n-                bindings.push(TypeBinding {\n+            let bindings = obj\n+                .projection_bounds()\n+                .map(|pb| TypeBinding {\n                     assoc: projection_to_path_segment(\n                         pb.skip_binder()\n                             .lift_to_tcx(cx.tcx)\n@@ -1656,8 +1655,8 @@ pub(crate) fn clean_middle_ty<'tcx>(\n                     kind: TypeBindingKind::Equality {\n                         term: clean_middle_term(pb.skip_binder().term, cx),\n                     },\n-                });\n-            }\n+                })\n+                .collect();\n \n             let path = external_path(cx, did, false, bindings, substs);\n             bounds.insert(0, PolyTrait { trait_: path, generic_params: Vec::new() });\n@@ -1953,8 +1952,10 @@ fn clean_maybe_renamed_item<'tcx>(\n                 })\n             }\n             ItemKind::Trait(_, _, generics, bounds, item_ids) => {\n-                let items =\n-                    item_ids.iter().map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx)).collect();\n+                let items = item_ids\n+                    .iter()\n+                    .map(|ti| clean_trait_item(cx.tcx.hir().trait_item(ti.id), cx))\n+                    .collect();\n \n                 TraitItem(Trait {\n                     def_id,"}, {"sha": "4446b4bc2fcf341435ba0e13e78f0beea0a4c3e4", "filename": "src/test/ui/argument-suggestions/issue-100154.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-100154.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-100154.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-100154.rs?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -0,0 +1,7 @@\n+fn foo(i: impl std::fmt::Display) {}\n+\n+fn main() {\n+    foo::<()>(());\n+    //~^ ERROR this function takes 0 generic arguments but 1 generic argument was supplied\n+    //~| ERROR `()` doesn't implement `std::fmt::Display`\n+}"}, {"sha": "1499229c3ced26cd2a974fbe686073f2e23ccc4f", "filename": "src/test/ui/argument-suggestions/issue-100154.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-100154.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-100154.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-100154.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -0,0 +1,35 @@\n+error[E0107]: this function takes 0 generic arguments but 1 generic argument was supplied\n+  --> $DIR/issue-100154.rs:4:5\n+   |\n+LL |     foo::<()>(());\n+   |     ^^^------ help: remove these generics\n+   |     |\n+   |     expected 0 generic arguments\n+   |\n+note: function defined here, with 0 generic parameters\n+  --> $DIR/issue-100154.rs:1:4\n+   |\n+LL | fn foo(i: impl std::fmt::Display) {}\n+   |    ^^^\n+   = note: `impl Trait` cannot be explicitly specified as a generic argument\n+\n+error[E0277]: `()` doesn't implement `std::fmt::Display`\n+  --> $DIR/issue-100154.rs:4:15\n+   |\n+LL |     foo::<()>(());\n+   |     --------- ^^ `()` cannot be formatted with the default formatter\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `std::fmt::Display` is not implemented for `()`\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+note: required by a bound in `foo`\n+  --> $DIR/issue-100154.rs:1:16\n+   |\n+LL | fn foo(i: impl std::fmt::Display) {}\n+   |                ^^^^^^^^^^^^^^^^^ required by this bound in `foo`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0107, E0277.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "894ec8341f8e0aac35a4806c4b3b9da05fb0fbcd", "filename": "src/test/ui/attributes/issue-90873.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fattributes%2Fissue-90873.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fattributes%2Fissue-90873.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fissue-90873.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -34,10 +34,10 @@ LL | #![a={impl std::ops::Neg for i8 {}}]\n    |                                     ^ consider adding a `main` function to `$DIR/issue-90873.rs`\n \n error: missing type for `static` item\n-  --> $DIR/issue-90873.rs:1:16\n+  --> $DIR/issue-90873.rs:1:17\n    |\n LL | #![u=||{static d=||1;}]\n-   |                ^ help: provide a type for the item: `d: <type>`\n+   |                 ^ help: provide a type for the item: `: <type>`\n \n error: aborting due to 6 previous errors\n "}, {"sha": "f581429a281540cf6242a6c4708beac4ccacee3f", "filename": "src/test/ui/issues/issue-69396-const-no-type-in-macro.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -17,10 +17,10 @@ LL | | }\n    = note: this error originates in the macro `suite` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: missing type for `const` item\n-  --> $DIR/issue-69396-const-no-type-in-macro.rs:4:19\n+  --> $DIR/issue-69396-const-no-type-in-macro.rs:4:20\n    |\n LL |               const A = \"A\".$fn();\n-   |                     ^ help: provide a type for the constant: `A: usize`\n+   |                      ^ help: provide a type for the constant: `: usize`\n ...\n LL | / suite! {\n LL | |     len;\n@@ -31,13 +31,13 @@ LL | | }\n    = note: this error originates in the macro `suite` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n-  --> $DIR/issue-69396-const-no-type-in-macro.rs:4:19\n+  --> $DIR/issue-69396-const-no-type-in-macro.rs:4:20\n    |\n LL |               const A = \"A\".$fn();\n-   |                     ^\n-   |                     |\n-   |                     not allowed in type signatures\n-   |                     help: replace with the correct type: `bool`\n+   |                      ^\n+   |                      |\n+   |                      not allowed in type signatures\n+   |                      help: replace with the correct type: `bool`\n ...\n LL | / suite! {\n LL | |     len;"}, {"sha": "7fec6ecd72573727ba2829869da3d4f6192d44ca", "filename": "src/test/ui/mismatched_types/E0409.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -17,6 +17,10 @@ LL |         (0, ref y) | (y, 0) => {}\n    |             first introduced with type `&{integer}` here\n    |\n    = note: in the same arm, a binding must have the same type in all alternatives\n+help: consider adding `ref`\n+   |\n+LL |         (0, ref y) | (ref y, 0) => {}\n+   |                       +++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "56f93cfbfdcbec4789a0b8317009370fcd49ce13", "filename": "src/test/ui/mismatched_types/suggest-adding-or-removing-ref-for-binding-pattern.fixed", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-adding-or-removing-ref-for-binding-pattern.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-adding-or-removing-ref-for-binding-pattern.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-adding-or-removing-ref-for-binding-pattern.fixed?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+#![allow(dead_code, unused_variables)]\n+\n+fn main() {\n+    enum Blah {\n+        A(isize, isize, usize),\n+        B(isize, usize),\n+    }\n+\n+    match Blah::A(1, 1, 2) {\n+        Blah::A(_, x, ref y) | Blah::B(x, ref y) => {}\n+        //~^ ERROR mismatched types\n+        //~| ERROR variable `y` is bound inconsistently across alternatives separated by `|`\n+    }\n+\n+    match Blah::A(1, 1, 2) {\n+        Blah::A(_, x, y) | Blah::B(x, y) => {}\n+        //~^ ERROR mismatched types\n+        //~| variable `y` is bound inconsistently across alternatives separated by `|`\n+    }\n+}"}, {"sha": "0c33f99a42e8bba011e25b48090d0eb82313f8bd", "filename": "src/test/ui/mismatched_types/suggest-adding-or-removing-ref-for-binding-pattern.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-adding-or-removing-ref-for-binding-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-adding-or-removing-ref-for-binding-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-adding-or-removing-ref-for-binding-pattern.rs?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+#![allow(dead_code, unused_variables)]\n+\n+fn main() {\n+    enum Blah {\n+        A(isize, isize, usize),\n+        B(isize, usize),\n+    }\n+\n+    match Blah::A(1, 1, 2) {\n+        Blah::A(_, x, ref y) | Blah::B(x, y) => {}\n+        //~^ ERROR mismatched types\n+        //~| ERROR variable `y` is bound inconsistently across alternatives separated by `|`\n+    }\n+\n+    match Blah::A(1, 1, 2) {\n+        Blah::A(_, x, y) | Blah::B(x, ref y) => {}\n+        //~^ ERROR mismatched types\n+        //~| variable `y` is bound inconsistently across alternatives separated by `|`\n+    }\n+}"}, {"sha": "e8357f9a37f8ce915bd7531eb7fa9d6bb6997a17", "filename": "src/test/ui/mismatched_types/suggest-adding-or-removing-ref-for-binding-pattern.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-adding-or-removing-ref-for-binding-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-adding-or-removing-ref-for-binding-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-adding-or-removing-ref-for-binding-pattern.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -0,0 +1,49 @@\n+error[E0409]: variable `y` is bound inconsistently across alternatives separated by `|`\n+  --> $DIR/suggest-adding-or-removing-ref-for-binding-pattern.rs:11:43\n+   |\n+LL |         Blah::A(_, x, ref y) | Blah::B(x, y) => {}\n+   |                           - first binding ^ bound in different ways\n+\n+error[E0409]: variable `y` is bound inconsistently across alternatives separated by `|`\n+  --> $DIR/suggest-adding-or-removing-ref-for-binding-pattern.rs:17:43\n+   |\n+LL |         Blah::A(_, x, y) | Blah::B(x, ref y) => {}\n+   |                       - first binding     ^ bound in different ways\n+\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-adding-or-removing-ref-for-binding-pattern.rs:11:43\n+   |\n+LL |     match Blah::A(1, 1, 2) {\n+   |           ---------------- this expression has type `Blah`\n+LL |         Blah::A(_, x, ref y) | Blah::B(x, y) => {}\n+   |                       -----               ^ expected `&usize`, found `usize`\n+   |                       |\n+   |                       first introduced with type `&usize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n+help: consider adding `ref`\n+   |\n+LL |         Blah::A(_, x, ref y) | Blah::B(x, ref y) => {}\n+   |                                           +++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-adding-or-removing-ref-for-binding-pattern.rs:17:39\n+   |\n+LL |     match Blah::A(1, 1, 2) {\n+   |           ---------------- this expression has type `Blah`\n+LL |         Blah::A(_, x, y) | Blah::B(x, ref y) => {}\n+   |                       -               ^^^^^ expected `usize`, found `&usize`\n+   |                       |\n+   |                       first introduced with type `usize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n+help: consider removing `ref`\n+   |\n+LL -         Blah::A(_, x, y) | Blah::B(x, ref y) => {}\n+LL +         Blah::A(_, x, y) | Blah::B(x, y) => {}\n+   |\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0308, E0409.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "fb1312c782aab95fe0d3ad607486324c38311bec", "filename": "src/test/ui/parser/issues/issue-89574.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-89574.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-89574.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-89574.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -1,8 +1,8 @@\n error: missing type for `const` item\n-  --> $DIR/issue-89574.rs:2:11\n+  --> $DIR/issue-89574.rs:2:22\n    |\n LL |     const EMPTY_ARRAY = [];\n-   |           ^^^^^^^^^^^ help: provide a type for the item: `EMPTY_ARRAY: <type>`\n+   |                      ^ help: provide a type for the item: `: <type>`\n \n error: aborting due to previous error\n "}, {"sha": "5365b0a1f824264dcc5179720ea00b2e9863b25e", "filename": "src/test/ui/parser/item-free-const-no-body-semantic-fail.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -15,10 +15,10 @@ LL | const B;\n    |        help: provide a definition for the constant: `= <expr>;`\n \n error: missing type for `const` item\n-  --> $DIR/item-free-const-no-body-semantic-fail.rs:6:7\n+  --> $DIR/item-free-const-no-body-semantic-fail.rs:6:8\n    |\n LL | const B;\n-   |       ^ help: provide a type for the item: `B: <type>`\n+   |        ^ help: provide a type for the item: `: <type>`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "1b61e430546e0de76e4a53c27209740de9af8ab0", "filename": "src/test/ui/parser/item-free-static-no-body-semantic-fail.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -31,16 +31,16 @@ LL | static mut D;\n    |             help: provide a definition for the static: `= <expr>;`\n \n error: missing type for `static` item\n-  --> $DIR/item-free-static-no-body-semantic-fail.rs:6:8\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:6:9\n    |\n LL | static B;\n-   |        ^ help: provide a type for the item: `B: <type>`\n+   |         ^ help: provide a type for the item: `: <type>`\n \n error: missing type for `static mut` item\n-  --> $DIR/item-free-static-no-body-semantic-fail.rs:10:12\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:10:13\n    |\n LL | static mut D;\n-   |            ^ help: provide a type for the item: `D: <type>`\n+   |             ^ help: provide a type for the item: `: <type>`\n \n error: aborting due to 6 previous errors\n "}, {"sha": "52e0658949d3dd64e5144f392de1cc68a6089e9c", "filename": "src/test/ui/parser/removed-syntax-static-fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -16,10 +16,10 @@ LL | }\n    | - the item list ends here\n \n error: missing type for `static` item\n-  --> $DIR/removed-syntax-static-fn.rs:4:12\n+  --> $DIR/removed-syntax-static-fn.rs:4:14\n    |\n LL |     static fn f() {}\n-   |            ^^ help: provide a type for the item: `r#fn: <type>`\n+   |              ^ help: provide a type for the item: `: <type>`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "c805c9eb125c882638b94eb3c7d7b20ee7072ff0", "filename": "src/test/ui/resolve/resolve-inconsistent-binding-mode.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -31,6 +31,10 @@ LL |         Opts::A(ref i) | Opts::B(i) => {}\n    |                 first introduced with type `&isize` here\n    |\n    = note: in the same arm, a binding must have the same type in all alternatives\n+help: consider adding `ref`\n+   |\n+LL |         Opts::A(ref i) | Opts::B(ref i) => {}\n+   |                                  +++\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:18:34\n@@ -43,6 +47,10 @@ LL |         Opts::A(ref i) | Opts::B(i) => {}\n    |                 first introduced with type `&isize` here\n    |\n    = note: in the same arm, a binding must have the same type in all alternatives\n+help: consider adding `ref`\n+   |\n+LL |         Opts::A(ref i) | Opts::B(ref i) => {}\n+   |                                  +++\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:27:38"}, {"sha": "9a40b20346c95e78539e07793260769e3a9f6f48", "filename": "src/test/ui/resolve/resolve-inconsistent-names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -23,6 +23,7 @@ fn main() {\n         //~| ERROR mismatched types\n         //~| ERROR variable `c` is not bound in all patterns\n         //~| HELP if you meant to match on unit variant `E::A`, use the full path in the pattern\n+        //~| HELP consider removing `ref`\n     }\n \n     let z = (10, 20);"}, {"sha": "773c9f6cd1114800768a1c43b55f97210b5ff78b", "filename": "src/test/ui/resolve/resolve-inconsistent-names.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -55,7 +55,7 @@ LL |         (A, B) | (ref B, c) | (c, A) => ()\n    |             first binding\n \n error[E0408]: variable `CONST1` is not bound in all patterns\n-  --> $DIR/resolve-inconsistent-names.rs:30:23\n+  --> $DIR/resolve-inconsistent-names.rs:31:23\n    |\n LL |         (CONST1, _) | (_, Const2) => ()\n    |          ------       ^^^^^^^^^^^ pattern doesn't bind `CONST1`\n@@ -69,7 +69,7 @@ LL |     const CONST1: usize = 10;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\n \n error[E0408]: variable `Const2` is not bound in all patterns\n-  --> $DIR/resolve-inconsistent-names.rs:30:9\n+  --> $DIR/resolve-inconsistent-names.rs:31:9\n    |\n LL |         (CONST1, _) | (_, Const2) => ()\n    |         ^^^^^^^^^^^       ------ variable not in all patterns\n@@ -92,6 +92,11 @@ LL |         (A, B) | (ref B, c) | (c, A) => ()\n    |             first introduced with type `E` here\n    |\n    = note: in the same arm, a binding must have the same type in all alternatives\n+help: consider removing `ref`\n+   |\n+LL -         (A, B) | (ref B, c) | (c, A) => ()\n+LL +         (A, B) | (B, c) | (c, A) => ()\n+   |\n \n error: aborting due to 9 previous errors\n "}, {"sha": "c6fdcdadbeafc22822019764337289151c68180f", "filename": "src/test/ui/suggestions/const-no-type.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.rs?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -14,38 +14,38 @@ fn main() {}\n const C2 = 42;\n //~^ ERROR missing type for `const` item\n //~| HELP provide a type for the item\n-//~| SUGGESTION C2: <type>\n+//~| SUGGESTION : <type>\n \n #[cfg(FALSE)]\n static S2 = \"abc\";\n //~^ ERROR missing type for `static` item\n //~| HELP provide a type for the item\n-//~| SUGGESTION S2: <type>\n+//~| SUGGESTION : <type>\n \n #[cfg(FALSE)]\n static mut SM2 = \"abc\";\n //~^ ERROR missing type for `static mut` item\n //~| HELP provide a type for the item\n-//~| SUGGESTION SM2: <type>\n+//~| SUGGESTION : <type>\n \n // These will, so the diagnostics should be stolen by typeck:\n \n const C = 42;\n //~^ ERROR missing type for `const` item\n //~| HELP provide a type for the constant\n-//~| SUGGESTION C: i32\n+//~| SUGGESTION : i32\n \n const D = &&42;\n //~^ ERROR missing type for `const` item\n //~| HELP provide a type for the constant\n-//~| SUGGESTION D: &&i32\n+//~| SUGGESTION : &&i32\n \n static S = Vec::<String>::new();\n //~^ ERROR missing type for `static` item\n //~| HELP provide a type for the static variable\n-//~| SUGGESTION S: Vec<String>\n+//~| SUGGESTION : Vec<String>\n \n static mut SM = \"abc\";\n //~^ ERROR missing type for `static mut` item\n //~| HELP provide a type for the static variable\n-//~| SUGGESTION &str\n+//~| SUGGESTION : &str"}, {"sha": "bd703992fd4a623445a62f9e2c26b8c585ec223a", "filename": "src/test/ui/suggestions/const-no-type.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -1,44 +1,44 @@\n error: missing type for `const` item\n-  --> $DIR/const-no-type.rs:33:7\n+  --> $DIR/const-no-type.rs:33:8\n    |\n LL | const C = 42;\n-   |       ^ help: provide a type for the constant: `C: i32`\n+   |        ^ help: provide a type for the constant: `: i32`\n \n error: missing type for `const` item\n-  --> $DIR/const-no-type.rs:38:7\n+  --> $DIR/const-no-type.rs:38:8\n    |\n LL | const D = &&42;\n-   |       ^ help: provide a type for the constant: `D: &&i32`\n+   |        ^ help: provide a type for the constant: `: &&i32`\n \n error: missing type for `static` item\n-  --> $DIR/const-no-type.rs:43:8\n+  --> $DIR/const-no-type.rs:43:9\n    |\n LL | static S = Vec::<String>::new();\n-   |        ^ help: provide a type for the static variable: `S: Vec<String>`\n+   |         ^ help: provide a type for the static variable: `: Vec<String>`\n \n error: missing type for `static mut` item\n-  --> $DIR/const-no-type.rs:48:12\n+  --> $DIR/const-no-type.rs:48:14\n    |\n LL | static mut SM = \"abc\";\n-   |            ^^ help: provide a type for the static variable: `SM: &str`\n+   |              ^ help: provide a type for the static variable: `: &str`\n \n error: missing type for `const` item\n-  --> $DIR/const-no-type.rs:14:7\n+  --> $DIR/const-no-type.rs:14:9\n    |\n LL | const C2 = 42;\n-   |       ^^ help: provide a type for the item: `C2: <type>`\n+   |         ^ help: provide a type for the item: `: <type>`\n \n error: missing type for `static` item\n-  --> $DIR/const-no-type.rs:20:8\n+  --> $DIR/const-no-type.rs:20:10\n    |\n LL | static S2 = \"abc\";\n-   |        ^^ help: provide a type for the item: `S2: <type>`\n+   |          ^ help: provide a type for the item: `: <type>`\n \n error: missing type for `static mut` item\n-  --> $DIR/const-no-type.rs:26:12\n+  --> $DIR/const-no-type.rs:26:15\n    |\n LL | static mut SM2 = \"abc\";\n-   |            ^^^ help: provide a type for the item: `SM2: <type>`\n+   |               ^ help: provide a type for the item: `: <type>`\n \n error: aborting due to 7 previous errors\n "}, {"sha": "ede3ebfa739c4f3ce3ca5e584799f62652aac022", "filename": "src/test/ui/suggestions/unnamable-types.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -1,8 +1,8 @@\n error: missing type for `const` item\n-  --> $DIR/unnamable-types.rs:6:7\n+  --> $DIR/unnamable-types.rs:6:8\n    |\n LL | const A = 5;\n-   |       ^ help: provide a type for the constant: `A: i32`\n+   |        ^ help: provide a type for the constant: `: i32`\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/unnamable-types.rs:10:11\n@@ -26,10 +26,10 @@ LL | const C: _ = || 42;\n    |              ^^^^^\n \n error: missing type for `const` item\n-  --> $DIR/unnamable-types.rs:23:7\n+  --> $DIR/unnamable-types.rs:23:8\n    |\n LL | const D = S { t: { let i = 0; move || -> i32 { i } } };\n-   |       ^\n+   |        ^\n    |\n note: however, the inferred type `S<[closure@$DIR/unnamable-types.rs:23:31: 23:45]>` cannot be named\n   --> $DIR/unnamable-types.rs:23:11\n@@ -38,22 +38,22 @@ LL | const D = S { t: { let i = 0; move || -> i32 { i } } };\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing type for `const` item\n-  --> $DIR/unnamable-types.rs:29:7\n+  --> $DIR/unnamable-types.rs:29:8\n    |\n LL | const E = foo;\n-   |       ^ help: provide a type for the constant: `E: fn() -> i32`\n+   |        ^ help: provide a type for the constant: `: fn() -> i32`\n \n error: missing type for `const` item\n-  --> $DIR/unnamable-types.rs:32:7\n+  --> $DIR/unnamable-types.rs:32:8\n    |\n LL | const F = S { t: foo };\n-   |       ^ help: provide a type for the constant: `F: S<fn() -> i32>`\n+   |        ^ help: provide a type for the constant: `: S<fn() -> i32>`\n \n error: missing type for `const` item\n-  --> $DIR/unnamable-types.rs:37:7\n+  --> $DIR/unnamable-types.rs:37:8\n    |\n LL | const G = || -> i32 { yield 0; return 1; };\n-   |       ^\n+   |        ^\n    |\n note: however, the inferred type `[generator@$DIR/unnamable-types.rs:37:11: 37:20]` cannot be named\n   --> $DIR/unnamable-types.rs:37:11"}, {"sha": "b1359ea586583be07c55190e2a5efb0a2c946cfe", "filename": "src/test/ui/transmutability/references.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Ftransmutability%2Freferences.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Ftransmutability%2Freferences.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmutability%2Freferences.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: `&'static Unit` cannot be safely transmuted into `&'static Unit` in the defining scope of `assert::Context`.\n-  --> $DIR/references.rs:19:52\n+  --> $DIR/references.rs:19:37\n    |\n LL |     assert::is_maybe_transmutable::<&'static Unit, &'static Unit>();\n-   |                                                    ^^^^^^^^^^^^^ `&'static Unit` cannot be safely transmuted into `&'static Unit` in the defining scope of `assert::Context`.\n+   |                                     ^^^^^^^^^^^^^ `&'static Unit` cannot be safely transmuted into `&'static Unit` in the defining scope of `assert::Context`.\n    |\n    = help: the trait `BikeshedIntrinsicFrom<&'static Unit, assert::Context, true, true, true, true>` is not implemented for `&'static Unit`\n note: required by a bound in `is_maybe_transmutable`"}, {"sha": "a5f68beb1d5229031d146dfc74e6c8a1435bff45", "filename": "src/test/ui/typeck/issue-100164.fixed", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Ftypeck%2Fissue-100164.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Ftypeck%2Fissue-100164.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-100164.fixed?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -0,0 +1,9 @@\n+// run-rustfix\n+\n+const _A: i32 = 123;\n+//~^ ERROR: missing type for `const` item\n+\n+fn main() {\n+    const _B: i32 = 123;\n+    //~^ ERROR: missing type for `const` item\n+}"}, {"sha": "7efb9ac624042fb03f346351cac4abda6e472b53", "filename": "src/test/ui/typeck/issue-100164.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Ftypeck%2Fissue-100164.rs", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Ftypeck%2Fissue-100164.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-100164.rs?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -0,0 +1,9 @@\n+// run-rustfix\n+\n+const _A: = 123;\n+//~^ ERROR: missing type for `const` item\n+\n+fn main() {\n+    const _B: = 123;\n+    //~^ ERROR: missing type for `const` item\n+}"}, {"sha": "06a132d6514293c6e74b775f30bdac996105bda1", "filename": "src/test/ui/typeck/issue-100164.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Ftypeck%2Fissue-100164.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Ftypeck%2Fissue-100164.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-100164.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -0,0 +1,14 @@\n+error: missing type for `const` item\n+  --> $DIR/issue-100164.rs:3:10\n+   |\n+LL | const _A: = 123;\n+   |          ^ help: provide a type for the constant: `i32`\n+\n+error: missing type for `const` item\n+  --> $DIR/issue-100164.rs:7:14\n+   |\n+LL |     const _B: = 123;\n+   |              ^ help: provide a type for the constant: `i32`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "c820d1e08c4adbd2abb9f040739eee8415827e26", "filename": "src/test/ui/typeck/issue-79040.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Ftypeck%2Fissue-79040.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Ftypeck%2Fissue-79040.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-79040.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -7,10 +7,10 @@ LL |     const FOO = \"hello\" + 1;\n    |                 &str\n \n error: missing type for `const` item\n-  --> $DIR/issue-79040.rs:2:11\n+  --> $DIR/issue-79040.rs:2:14\n    |\n LL |     const FOO = \"hello\" + 1;\n-   |           ^^^ help: provide a type for the item: `FOO: <type>`\n+   |              ^ help: provide a type for the item: `: <type>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c57f71b8057a956a93c67ea818679891ee4d9b85", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/affe0d3a00e92fa7885e3f5d2c5073fde432d154/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr?ref=affe0d3a00e92fa7885e3f5d2c5073fde432d154", "patch": "@@ -189,10 +189,10 @@ LL ~     b: (T, T),\n    |\n \n error: missing type for `static` item\n-  --> $DIR/typeck_type_placeholder_item.rs:73:12\n+  --> $DIR/typeck_type_placeholder_item.rs:73:13\n    |\n LL |     static A = 42;\n-   |            ^ help: provide a type for the static variable: `A: i32`\n+   |             ^ help: provide a type for the static variable: `: i32`\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/typeck_type_placeholder_item.rs:75:15"}]}