{"sha": "29bc9c632eda71c6b4a8b35db637971953b58d03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YmM5YzYzMmVkYTcxYzZiNGE4YjM1ZGI2Mzc5NzE5NTNiNThkMDM=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-15T04:52:00Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-16T01:41:55Z"}, "message": "Move FromStr to core::str", "tree": {"sha": "95e8ff15586d9733b6bfd8be5438579049f1622c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95e8ff15586d9733b6bfd8be5438579049f1622c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29bc9c632eda71c6b4a8b35db637971953b58d03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29bc9c632eda71c6b4a8b35db637971953b58d03", "html_url": "https://github.com/rust-lang/rust/commit/29bc9c632eda71c6b4a8b35db637971953b58d03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29bc9c632eda71c6b4a8b35db637971953b58d03/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e43f419cb98c9035d30e5cf0e0be7944dbc0371", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e43f419cb98c9035d30e5cf0e0be7944dbc0371", "html_url": "https://github.com/rust-lang/rust/commit/7e43f419cb98c9035d30e5cf0e0be7944dbc0371"}], "stats": {"total": 1315, "additions": 644, "deletions": 671}, "files": [{"sha": "b7d4596b0febf528302f049be36cc40cc49a1888", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::from_str::FromStr;\n use std::fmt;\n+use std::str::FromStr;\n use regex::Regex;\n \n #[deriving(Clone, PartialEq)]"}, {"sha": "d49ff0258ab02917a6599986adbd28448bb4bd9e", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -22,7 +22,7 @@ extern crate regex;\n use std::os;\n use std::io;\n use std::io::fs;\n-use std::from_str::FromStr;\n+use std::str::FromStr;\n use getopts::{optopt, optflag, reqopt};\n use common::Config;\n use common::{Pretty, DebugInfoGdb, DebugInfoLldb, Codegen};"}, {"sha": "60ef76528e849cee43367fd53a7211d200c4ad00", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -12,8 +12,6 @@ use common::Config;\n use common;\n use util;\n \n-use std::from_str::FromStr;\n-\n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n     pub error_patterns: Vec<String> ,\n@@ -353,8 +351,8 @@ pub fn gdb_version_to_int(version_string: &str) -> int {\n         panic!(\"{}\", error_string);\n     }\n \n-    let major: int = FromStr::from_str(components[0]).expect(error_string);\n-    let minor: int = FromStr::from_str(components[1]).expect(error_string);\n+    let major: int = from_str(components[0]).expect(error_string);\n+    let minor: int = from_str(components[1]).expect(error_string);\n \n     return major * 1000 + minor;\n }\n@@ -364,6 +362,6 @@ pub fn lldb_version_to_int(version_string: &str) -> int {\n         \"Encountered LLDB version string with unexpected format: {}\",\n         version_string);\n     let error_string = error_string.as_slice();\n-    let major: int = FromStr::from_str(version_string).expect(error_string);\n+    let major: int = from_str(version_string).expect(error_string);\n     return major;\n }"}, {"sha": "b3bf554f30c0f1f299099b502a7414f8c9e0f401", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -3108,11 +3108,10 @@ then the expression completes.\n Some examples of call expressions:\n \n ```\n-# use std::from_str::FromStr;\n # fn add(x: int, y: int) -> int { 0 }\n \n let x: int = add(1, 2);\n-let pi: Option<f32> = FromStr::from_str(\"3.14\");\n+let pi: Option<f32> = from_str(\"3.14\");\n ```\n \n ### Lambda expressions"}, {"sha": "a2f89dfecbc1370bd6239e6770466a98fb554af9", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -73,6 +73,7 @@ pub use core::str::{CharSplitsN, AnyLines, MatchIndices, StrSplits};\n pub use core::str::{Utf16CodeUnits, eq_slice, is_utf8, is_utf16, Utf16Items};\n pub use core::str::{Utf16Item, ScalarValue, LoneSurrogate, utf16_items};\n pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n+pub use core::str::{FromStr, from_str};\n pub use core::str::{Str, StrPrelude};\n pub use unicode::str::{UnicodeStrPrelude, Words, Graphemes, GraphemeIndices};\n "}, {"sha": "c1e093436c3bb484e6b28d42a48d0a9e9d44d92e", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -25,7 +25,7 @@ use core::raw::Slice as RawSlice;\n use hash;\n use slice::CloneSliceAllocPrelude;\n use str;\n-use str::{CharRange, StrAllocating, MaybeOwned, Owned};\n+use str::{CharRange, FromStr, StrAllocating, MaybeOwned, Owned};\n use str::Slice as MaybeOwnedSlice; // So many `Slice`s...\n use vec::{DerefVec, Vec, as_vec};\n \n@@ -795,6 +795,13 @@ pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }\n \n+impl FromStr for String {\n+    #[inline]\n+    fn from_str(s: &str) -> Option<String> {\n+        Some(String::from_str(s))\n+    }\n+}\n+\n /// Unsafe operations\n #[unstable = \"waiting on raw module conventions\"]\n pub mod raw {"}, {"sha": "c674a806836ac75b0898fa3d460a7b4ab4630fb8", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -17,7 +17,9 @@\n use intrinsics;\n use mem;\n use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n-use num::Float;\n+use num::{Float, FromStrRadix};\n+use num::strconv;\n+use str::FromStr;\n use option::Option;\n \n pub const RADIX: uint = 2u;\n@@ -424,3 +426,66 @@ impl Float for f32 {\n         self * (value / 180.0f32)\n     }\n }\n+\n+#[inline]\n+#[allow(missing_docs)]\n+#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n+pub fn from_str_hex(src: &str) -> Option<f32> {\n+    strconv::from_str_radix_float(src, 16)\n+}\n+\n+impl FromStr for f32 {\n+    /// Convert a string in base 10 to a float.\n+    /// Accepts an optional decimal exponent.\n+    ///\n+    /// This function accepts strings such as\n+    ///\n+    /// * '3.14'\n+    /// * '+3.14', equivalent to '3.14'\n+    /// * '-3.14'\n+    /// * '2.5E10', or equivalently, '2.5e10'\n+    /// * '2.5E-10'\n+    /// * '.' (understood as 0)\n+    /// * '5.'\n+    /// * '.5', or, equivalently,  '0.5'\n+    /// * '+inf', 'inf', '-inf', 'NaN'\n+    ///\n+    /// Leading and trailing whitespace represent an error.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * src - A string\n+    ///\n+    /// # Return value\n+    ///\n+    /// `None` if the string did not represent a valid number.  Otherwise,\n+    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n+    #[inline]\n+    fn from_str(src: &str) -> Option<f32> {\n+        strconv::from_str_radix_float(src, 10u)\n+    }\n+}\n+\n+impl FromStrRadix for f32 {\n+    /// Convert a string in a given base to a float.\n+    ///\n+    /// Due to possible conflicts, this function does **not** accept\n+    /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+    /// does it recognize exponents of any kind.\n+    ///\n+    /// Leading and trailing whitespace represent an error.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * src - A string\n+    /// * radix - The base to use. Must lie in the range [2 .. 36]\n+    ///\n+    /// # Return value\n+    ///\n+    /// `None` if the string did not represent a valid number. Otherwise,\n+    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n+    #[inline]\n+    fn from_str_radix(src: &str, radix: uint) -> Option<f32> {\n+        strconv::from_str_radix_float(src, radix)\n+    }\n+}"}, {"sha": "2abd6c237c868be582442a2f8621530edee1bd6a", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -17,7 +17,9 @@\n use intrinsics;\n use mem;\n use num::{FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n-use num::Float;\n+use num::{Float, FromStrRadix};\n+use num::strconv;\n+use str::FromStr;\n use option::Option;\n \n // FIXME(#5527): These constants should be deprecated once associated\n@@ -430,3 +432,61 @@ impl Float for f64 {\n         self * (value / 180.0)\n     }\n }\n+\n+#[inline]\n+#[allow(missing_docs)]\n+#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n+pub fn from_str_hex(src: &str) -> Option<f64> {\n+    strconv::from_str_radix_float(src, 16)\n+}\n+\n+impl FromStr for f64 {\n+    /// Convert a string in base 10 to a float.\n+    /// Accepts an optional decimal exponent.\n+    ///\n+    /// This function accepts strings such as:\n+    ///\n+    /// * '3.14'\n+    /// * '-3.14'\n+    /// * '2.5E10', or equivalently, '2.5e10'\n+    /// * '2.5E-10'\n+    /// * '.' (understood as 0)\n+    /// * '5.'\n+    /// * '.5', or, equivalently,  '0.5'\n+    /// * inf', '-inf', 'NaN'\n+    ///\n+    /// Leading and trailing whitespace represent an error.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * src - A string\n+    ///\n+    /// # Return value\n+    ///\n+    /// `none` if the string did not represent a valid number.  Otherwise,\n+    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n+    #[inline]\n+    fn from_str(src: &str) -> Option<f64> {\n+        strconv::from_str_radix_float(src, 10u)\n+    }\n+}\n+\n+impl FromStrRadix for f64 {\n+    /// Convert a string in a given base to a float.\n+    ///\n+    /// Leading and trailing whitespace represent an error.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * src - A string\n+    /// * radix - The base to use. Must lie in the range [2 .. 36]\n+    ///\n+    /// # Return value\n+    ///\n+    /// `None` if the string did not represent a valid number. Otherwise,\n+    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n+    #[inline]\n+    fn from_str_radix(src: &str, radix: uint) -> Option<f64> {\n+        strconv::from_str_radix_float(src, radix)\n+    }\n+}"}, {"sha": "dc60a0c9764bcccc701d62c5153b120aeb0a7f4f", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -32,4 +32,20 @@ pub const MIN: $T = (-1 as $T) << (BITS - 1);\n #[unstable]\n pub const MAX: $T = !MIN;\n \n+#[experimental = \"might need to return Result\"]\n+impl ::str::FromStr for $T {\n+    #[inline]\n+    fn from_str(s: &str) -> ::option::Option<$T> {\n+        ::num::strconv::from_str_radix_int(s, 10)\n+    }\n+}\n+\n+#[experimental = \"might need to return Result\"]\n+impl ::num::FromStrRadix for $T {\n+    #[inline]\n+    fn from_str_radix(s: &str, radix: uint) -> ::option::Option<$T> {\n+        ::num::strconv::from_str_radix_int(s, radix)\n+    }\n+}\n+\n ))"}, {"sha": "391ccce568bb9afe68185d6ad9877b799577e1d8", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -27,6 +27,8 @@ use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::{Option, Some, None};\n \n+pub mod strconv;\n+\n /// Simultaneous division and remainder\n #[inline]\n pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n@@ -1372,6 +1374,18 @@ pub trait Float\n     fn to_radians(self) -> Self;\n }\n \n+/// A generic trait for converting a string with a radix (base) to a value\n+#[experimental = \"might need to return Result\"]\n+pub trait FromStrRadix {\n+    fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n+}\n+\n+/// A utility function that just calls FromStrRadix::from_str_radix.\n+#[experimental = \"might need to return Result\"]\n+pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n+    FromStrRadix::from_str_radix(str, radix)\n+}\n+\n // DEPRECATED\n \n macro_rules! trait_impl {"}, {"sha": "daa2a8e234318f5f26cfa7bd2d265392453c8c39", "filename": "src/libcore/num/strconv.rs", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -0,0 +1,259 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// ignore-lexer-test FIXME #15679\n+\n+#![allow(missing_docs)]\n+\n+use char::Char;\n+use iter::Iterator;\n+use num;\n+use num::{Int, Float};\n+use option::{None, Option, Some};\n+use str::{from_str, StrPrelude};\n+\n+pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T> {\n+   assert!(radix >= 2 && radix <= 36,\n+           \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n+           radix);\n+\n+    let _0: T = Float::zero();\n+    let _1: T = Float::one();\n+    let radix_t: T = num::cast(radix as int).unwrap();\n+\n+    // Special values\n+    match src {\n+        \"inf\"   => return Some(Float::infinity()),\n+        \"-inf\"  => return Some(Float::neg_infinity()),\n+        \"NaN\"   => return Some(Float::nan()),\n+        _       => {},\n+    }\n+\n+    let (is_positive, src) =  match src.slice_shift_char() {\n+        (None, _)        => return None,\n+        (Some('-'), \"\")  => return None,\n+        (Some('-'), src) => (false, src),\n+        (Some(_), _)     => (true,  src),\n+    };\n+\n+    // The significand to accumulate\n+    let mut sig = if is_positive { _0 } else { -_0 };\n+    // Necessary to detect overflow\n+    let mut prev_sig = sig;\n+    let mut cs = src.chars().enumerate();\n+    // Exponent prefix and exponent index offset\n+    let mut exp_info = None::<(char, uint)>;\n+\n+    // Parse the integer part of the significand\n+    for (i, c) in cs {\n+        match c.to_digit(radix) {\n+            Some(digit) => {\n+                // shift significand one digit left\n+                sig = sig * radix_t;\n+\n+                // add/subtract current digit depending on sign\n+                if is_positive {\n+                    sig = sig + num::cast(digit as int).unwrap();\n+                } else {\n+                    sig = sig - num::cast(digit as int).unwrap();\n+                }\n+\n+                // Detect overflow by comparing to last value, except\n+                // if we've not seen any non-zero digits.\n+                if prev_sig != _0 {\n+                    if is_positive && sig <= prev_sig\n+                        { return Some(Float::infinity()); }\n+                    if !is_positive && sig >= prev_sig\n+                        { return Some(Float::neg_infinity()); }\n+\n+                    // Detect overflow by reversing the shift-and-add process\n+                    let digit: T = num::cast(digit as int).unwrap();\n+                    if is_positive && (prev_sig != ((sig - digit) / radix_t))\n+                        { return Some(Float::infinity()); }\n+                    if !is_positive && (prev_sig != ((sig + digit) / radix_t))\n+                        { return Some(Float::neg_infinity()); }\n+                }\n+                prev_sig = sig;\n+            },\n+            None => match c {\n+                'e' | 'E' | 'p' | 'P' => {\n+                    exp_info = Some((c, i + 1));\n+                    break;  // start of exponent\n+                },\n+                '.' => {\n+                    break;  // start of fractional part\n+                },\n+                _ => {\n+                    return None;\n+                },\n+            },\n+        }\n+    }\n+\n+    // If we are not yet at the exponent parse the fractional\n+    // part of the significand\n+    if exp_info.is_none() {\n+        let mut power = _1;\n+        for (i, c) in cs {\n+            match c.to_digit(radix) {\n+                Some(digit) => {\n+                    let digit: T = num::cast(digit).unwrap();\n+                    // Decrease power one order of magnitude\n+                    power = power / radix_t;\n+                    // add/subtract current digit depending on sign\n+                    sig = if is_positive {\n+                        sig + digit * power\n+                    } else {\n+                        sig - digit * power\n+                    };\n+                    // Detect overflow by comparing to last value\n+                    if is_positive && sig < prev_sig\n+                        { return Some(Float::infinity()); }\n+                    if !is_positive && sig > prev_sig\n+                        { return Some(Float::neg_infinity()); }\n+                    prev_sig = sig;\n+                },\n+                None => match c {\n+                    'e' | 'E' | 'p' | 'P' => {\n+                        exp_info = Some((c, i + 1));\n+                        break; // start of exponent\n+                    },\n+                    _ => {\n+                        return None; // invalid number\n+                    },\n+                },\n+            }\n+        }\n+    }\n+\n+    // Parse and calculate the exponent\n+    let exp = match exp_info {\n+        Some((c, offset)) => {\n+            let base: T = match c {\n+                'E' | 'e' if radix == 10 => num::cast(10u).unwrap(),\n+                'P' | 'p' if radix == 16 => num::cast(2u).unwrap(),\n+                _ => return None,\n+            };\n+\n+            // Parse the exponent as decimal integer\n+            let src = src[offset..];\n+            let (is_positive, exp) = match src.slice_shift_char() {\n+                (Some('-'), src) => (false, from_str::<uint>(src)),\n+                (Some('+'), src) => (true,  from_str::<uint>(src)),\n+                (Some(_), _)     => (true,  from_str::<uint>(src)),\n+                (None, _)        => return None,\n+            };\n+\n+            match (is_positive, exp) {\n+                (true,  Some(exp)) => base.powi(exp as i32),\n+                (false, Some(exp)) => _1 / base.powi(exp as i32),\n+                (_, None)          => return None,\n+            }\n+        },\n+        None => _1, // no exponent\n+    };\n+\n+    Some(sig * exp)\n+}\n+\n+pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n+   assert!(radix >= 2 && radix <= 36,\n+           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n+           radix);\n+\n+    fn cast<T: Int>(x: uint) -> T {\n+        num::cast(x).unwrap()\n+    }\n+\n+    let _0: T = Int::zero();\n+    let _1: T = Int::one();\n+    let is_signed = _0 > Int::min_value();\n+\n+    let (is_positive, src) =  match src.slice_shift_char() {\n+        (Some('-'), src) if is_signed => (false, src),\n+        (Some(_), _) => (true, src),\n+        (None, _) => return None,\n+    };\n+\n+    let mut xs = src.chars().map(|c| {\n+        c.to_digit(radix).map(cast)\n+    });\n+    let radix = cast(radix);\n+    let mut result = _0;\n+\n+    if is_positive {\n+        for x in xs {\n+            let x = match x {\n+                Some(x) => x,\n+                None => return None,\n+            };\n+            result = match result.checked_mul(radix) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+            result = match result.checked_add(x) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+        }\n+    } else {\n+        for x in xs {\n+            let x = match x {\n+                Some(x) => x,\n+                None => return None,\n+            };\n+            result = match result.checked_mul(radix) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+            result = match result.checked_sub(x) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+        }\n+    }\n+\n+    Some(result)\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use option::*;\n+    use num::Float;\n+\n+    #[test]\n+    fn from_str_issue7588() {\n+        let u : Option<u8> = from_str_radix_int(\"1000\", 10);\n+        assert_eq!(u, None);\n+        let s : Option<i16> = from_str_radix_int(\"80000\", 10);\n+        assert_eq!(s, None);\n+        let f : Option<f32> = from_str_radix_float(\"10000000000000000000000000000000000000000\", 10);\n+        assert_eq!(f, Some(Float::infinity()))\n+        let fe : Option<f32> = from_str_radix_float(\"1e40\", 10);\n+        assert_eq!(fe, Some(Float::infinity()))\n+    }\n+\n+    #[test]\n+    fn test_from_str_radix_float() {\n+        let x1 : Option<f64> = from_str_radix_float(\"-123.456\", 10);\n+        assert_eq!(x1, Some(-123.456));\n+        let x2 : Option<f32> = from_str_radix_float(\"123.456\", 10);\n+        assert_eq!(x2, Some(123.456));\n+        let x3 : Option<f32> = from_str_radix_float(\"-0.0\", 10);\n+        assert_eq!(x3, Some(-0.0));\n+        let x4 : Option<f32> = from_str_radix_float(\"0.0\", 10);\n+        assert_eq!(x4, Some(0.0));\n+        let x4 : Option<f32> = from_str_radix_float(\"1.0\", 10);\n+        assert_eq!(x4, Some(1.0));\n+        let x5 : Option<f32> = from_str_radix_float(\"-1.0\", 10);\n+        assert_eq!(x5, Some(-1.0));\n+    }\n+}"}, {"sha": "4977e5d6680bdaae470b8204c446521bdf5991dd", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -23,4 +23,20 @@ pub const MIN: $T = 0 as $T;\n #[unstable]\n pub const MAX: $T = 0 as $T - 1 as $T;\n \n+#[experimental = \"might need to return Result\"]\n+impl ::str::FromStr for $T {\n+    #[inline]\n+    fn from_str(s: &str) -> ::option::Option<$T> {\n+        ::num::strconv::from_str_radix_int(s, 10)\n+    }\n+}\n+\n+#[experimental = \"might need to return Result\"]\n+impl ::num::FromStrRadix for $T {\n+    #[inline]\n+    fn from_str_radix(s: &str, radix: uint) -> ::option::Option<$T> {\n+        ::num::strconv::from_str_radix_int(s, radix)\n+    }\n+}\n+\n ))"}, {"sha": "101eb7ac74cdbdf4208742bacd194c87c95ea1c6", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -41,6 +41,7 @@ pub use ops::{Fn, FnMut, FnOnce};\n // Reexported functions\n pub use iter::{range, repeat};\n pub use mem::drop;\n+pub use str::from_str;\n \n // Reexported types and traits\n "}, {"sha": "ab4e50c58d9a45a87ad462a9c287178052c02a49", "filename": "src/libcore/str.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -31,6 +31,42 @@ use raw::Repr;\n use slice::{mod, SlicePrelude};\n use uint;\n \n+/// A trait to abstract the idea of creating a new instance of a type from a\n+/// string.\n+#[experimental = \"might need to return Result\"]\n+pub trait FromStr {\n+    /// Parses a string `s` to return an optional value of this type. If the\n+    /// string is ill-formatted, the None is returned.\n+    fn from_str(s: &str) -> Option<Self>;\n+}\n+\n+/// A utility function that just calls FromStr::from_str\n+pub fn from_str<A: FromStr>(s: &str) -> Option<A> {\n+    FromStr::from_str(s)\n+}\n+\n+impl FromStr for bool {\n+    /// Parse a `bool` from a string.\n+    ///\n+    /// Yields an `Option<bool>`, because `s` may or may not actually be parseable.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(from_str::<bool>(\"true\"), Some(true));\n+    /// assert_eq!(from_str::<bool>(\"false\"), Some(false));\n+    /// assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+    /// ```\n+    #[inline]\n+    fn from_str(s: &str) -> Option<bool> {\n+        match s {\n+            \"true\"  => Some(true),\n+            \"false\" => Some(false),\n+            _       => None,\n+        }\n+    }\n+}\n+\n /*\n Section: Creating a string\n */"}, {"sha": "e25f10bd0dad531b0df7590bca75ff5ed9788776", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -15,7 +15,8 @@ macro_rules! int_module (($T:ty, $T_i:ident) => (\n mod tests {\n     use core::$T_i::*;\n     use core::int;\n-    use core::num::{Int, SignedInt};\n+    use core::num::{FromStrRadix, Int, SignedInt};\n+    use core::str::from_str;\n     use num;\n \n     #[test]\n@@ -156,6 +157,49 @@ mod tests {\n         assert!(5i.checked_div(0) == None);\n         assert!(int::MIN.checked_div(-1) == None);\n     }\n+\n+    #[test]\n+    fn test_from_str() {\n+        assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n+        assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n+        assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n+        assert_eq!(from_str::<i32>(\"123456789\"), Some(123456789 as i32));\n+        assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n+\n+        assert_eq!(from_str::<$T>(\"-1\"), Some(-1 as $T));\n+        assert_eq!(from_str::<$T>(\"-3\"), Some(-3 as $T));\n+        assert_eq!(from_str::<$T>(\"-10\"), Some(-10 as $T));\n+        assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n+        assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n+\n+        assert_eq!(from_str::<$T>(\"\"), None);\n+        assert_eq!(from_str::<$T>(\" \"), None);\n+        assert_eq!(from_str::<$T>(\"x\"), None);\n+    }\n+\n+    #[test]\n+    fn test_from_str_radix() {\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Some(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Some(35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Some(-123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Some(-9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Some(-83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Some(-291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Some(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Some(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Some(-35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Some(-35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2), None::<$T>);\n+    }\n }\n \n ))"}, {"sha": "0cd1ded21d6c6cdd269a12e5b3c6209ff0bae9a4", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -45,3 +45,73 @@ pub fn test_num<T>(ten: T, two: T) where\n     assert_eq!(ten.div(&two),  ten / two);\n     assert_eq!(ten.rem(&two),  ten % two);\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use core::option::{Option, Some, None};\n+    use core::num::Float;\n+    use core::num::from_str_radix;\n+\n+    #[test]\n+    fn from_str_issue7588() {\n+        let u : Option<u8> = from_str_radix(\"1000\", 10);\n+        assert_eq!(u, None);\n+        let s : Option<i16> = from_str_radix(\"80000\", 10);\n+        assert_eq!(s, None);\n+        let f : Option<f32> = from_str_radix(\"10000000000000000000000000000000000000000\", 10);\n+        assert_eq!(f, Some(Float::infinity()))\n+        let fe : Option<f32> = from_str_radix(\"1e40\", 10);\n+        assert_eq!(fe, Some(Float::infinity()))\n+    }\n+\n+    #[test]\n+    fn test_from_str_radix_float() {\n+        let x1 : Option<f64> = from_str_radix(\"-123.456\", 10);\n+        assert_eq!(x1, Some(-123.456));\n+        let x2 : Option<f32> = from_str_radix(\"123.456\", 10);\n+        assert_eq!(x2, Some(123.456));\n+        let x3 : Option<f32> = from_str_radix(\"-0.0\", 10);\n+        assert_eq!(x3, Some(-0.0));\n+        let x4 : Option<f32> = from_str_radix(\"0.0\", 10);\n+        assert_eq!(x4, Some(0.0));\n+        let x4 : Option<f32> = from_str_radix(\"1.0\", 10);\n+        assert_eq!(x4, Some(1.0));\n+        let x5 : Option<f32> = from_str_radix(\"-1.0\", 10);\n+        assert_eq!(x5, Some(-1.0));\n+    }\n+\n+    #[test]\n+    fn test_int_from_str_overflow() {\n+        let mut i8_val: i8 = 127_i8;\n+        assert_eq!(from_str::<i8>(\"127\"), Some(i8_val));\n+        assert_eq!(from_str::<i8>(\"128\"), None);\n+\n+        i8_val += 1 as i8;\n+        assert_eq!(from_str::<i8>(\"-128\"), Some(i8_val));\n+        assert_eq!(from_str::<i8>(\"-129\"), None);\n+\n+        let mut i16_val: i16 = 32_767_i16;\n+        assert_eq!(from_str::<i16>(\"32767\"), Some(i16_val));\n+        assert_eq!(from_str::<i16>(\"32768\"), None);\n+\n+        i16_val += 1 as i16;\n+        assert_eq!(from_str::<i16>(\"-32768\"), Some(i16_val));\n+        assert_eq!(from_str::<i16>(\"-32769\"), None);\n+\n+        let mut i32_val: i32 = 2_147_483_647_i32;\n+        assert_eq!(from_str::<i32>(\"2147483647\"), Some(i32_val));\n+        assert_eq!(from_str::<i32>(\"2147483648\"), None);\n+\n+        i32_val += 1 as i32;\n+        assert_eq!(from_str::<i32>(\"-2147483648\"), Some(i32_val));\n+        assert_eq!(from_str::<i32>(\"-2147483649\"), None);\n+\n+        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n+        assert_eq!(from_str::<i64>(\"9223372036854775807\"), Some(i64_val));\n+        assert_eq!(from_str::<i64>(\"9223372036854775808\"), None);\n+\n+        i64_val += 1 as i64;\n+        assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n+        assert_eq!(from_str::<i64>(\"-9223372036854775809\"), None);\n+    }\n+}"}, {"sha": "5f44fd807ccae726d3ecf852129b9f777565dbc6", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -8,6 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[test]\n+fn test_bool_from_str() {\n+    assert_eq!(from_str::<bool>(\"true\"), Some(true));\n+    assert_eq!(from_str::<bool>(\"false\"), Some(false));\n+    assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+}\n+\n fn check_contains_all_substrings(s: &str) {\n     assert!(s.contains(\"\"));\n     for i in range(0, s.len()) {"}, {"sha": "c7540852970d8ca9a2ea42636fa1e2a324ddb9df", "filename": "src/libregex/re.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -10,7 +10,6 @@\n \n use std::collections::HashMap;\n use std::fmt;\n-use std::from_str::from_str;\n use std::str::{MaybeOwned, Owned, Slice};\n \n use compile::Program;"}, {"sha": "10cf92e32c3aa07516f05788033b313635f3f542", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -334,8 +334,7 @@ macro_rules! cgoptions(\n         }\n \n         fn parse_uint(slot: &mut uint, v: Option<&str>) -> bool {\n-            use std::from_str::FromStr;\n-            match v.and_then(FromStr::from_str) {\n+            match v.and_then(from_str) {\n                 Some(i) => { *slot = i; true },\n                 None => false\n             }"}, {"sha": "7b6de088319f4fcc3bab7fcc7241e66b4ea30276", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -31,8 +31,8 @@ use syntax::print::{pp, pprust};\n use graphviz as dot;\n \n use std::io::{mod, MemReader};\n-use std::from_str::FromStr;\n use std::option;\n+use std::str::FromStr;\n use arena::TypedArena;\n \n #[deriving(PartialEq, Show)]"}, {"sha": "56e90da533cffff5655df6c60affaffacffd1ffa", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -200,7 +200,7 @@ use std::{char, f64, fmt, io, num, str};\n use std::io::MemWriter;\n use std::mem::{swap, transmute};\n use std::num::{Float, FPNaN, FPInfinite, Int};\n-use std::str::ScalarValue;\n+use std::str::{FromStr, ScalarValue};\n use std::string;\n use std::vec::Vec;\n use std::ops;\n@@ -1988,7 +1988,7 @@ macro_rules! read_primitive {\n                 String(s) => {\n                     // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                     // is going to have a string here, as per JSON spec.\n-                    match std::from_str::from_str(s.as_slice()) {\n+                    match std::str::from_str(s.as_slice()) {\n                         Some(f) => Ok(f),\n                         None => Err(ExpectedError(\"Number\".to_string(), s)),\n                     }\n@@ -2027,7 +2027,7 @@ impl ::Decoder<DecoderError> for Decoder {\n             String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n-                match std::from_str::from_str(s.as_slice()) {\n+                match std::str::from_str(s.as_slice()) {\n                     Some(f) => Ok(f),\n                     None => Err(ExpectedError(\"Number\".to_string(), s)),\n                 }\n@@ -2395,7 +2395,7 @@ impl fmt::Show for Json {\n     }\n }\n \n-impl std::from_str::FromStr for Json {\n+impl FromStr for Json {\n     fn from_str(s: &str) -> Option<Json> {\n         from_str(s).ok()\n     }\n@@ -2480,7 +2480,7 @@ mod tests {\n     #[test]\n     fn test_from_str_trait() {\n         let s = \"null\";\n-        assert!(::std::from_str::from_str::<Json>(s).unwrap() == from_str(s).unwrap());\n+        assert!(::std::str::from_str::<Json>(s).unwrap() == from_str(s).unwrap());\n     }\n \n     #[test]"}, {"sha": "21b1e0560a5dba49ff6d0b715196d0f4d91ba957", "filename": "src/libstd/from_str.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7e43f419cb98c9035d30e5cf0e0be7944dbc0371/src%2Flibstd%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e43f419cb98c9035d30e5cf0e0be7944dbc0371/src%2Flibstd%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffrom_str.rs?ref=7e43f419cb98c9035d30e5cf0e0be7944dbc0371", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The `FromStr` trait for types that can be created from strings\n-\n-#![experimental]\n-\n-use option::{Option, Some, None};\n-use string::String;\n-\n-/// A trait to abstract the idea of creating a new instance of a type from a\n-/// string.\n-#[experimental = \"might need to return Result\"]\n-pub trait FromStr {\n-    /// Parses a string `s` to return an optional value of this type. If the\n-    /// string is ill-formatted, the None is returned.\n-    fn from_str(s: &str) -> Option<Self>;\n-}\n-\n-/// A utility function that just calls FromStr::from_str\n-pub fn from_str<A: FromStr>(s: &str) -> Option<A> {\n-    FromStr::from_str(s)\n-}\n-\n-impl FromStr for bool {\n-    /// Parse a `bool` from a string.\n-    ///\n-    /// Yields an `Option<bool>`, because `s` may or may not actually be parseable.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-    /// assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-    /// assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n-    /// ```\n-    #[inline]\n-    fn from_str(s: &str) -> Option<bool> {\n-        match s {\n-            \"true\"  => Some(true),\n-            \"false\" => Some(false),\n-            _       => None,\n-        }\n-    }\n-}\n-\n-impl FromStr for String {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<String> {\n-        Some(String::from_str(s))\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-\n-    #[test]\n-    fn test_bool_from_str() {\n-        assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-        assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-        assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n-    }\n-}"}, {"sha": "7ba5e173182e165c8061357365200849c66183df", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -16,13 +16,12 @@\n #![allow(missing_docs)]\n \n use fmt;\n-use from_str::FromStr;\n use io::{mod, IoResult, IoError};\n use io::net;\n use iter::Iterator;\n use option::{Option, None, Some};\n use result::{Ok, Err};\n-use str::StrPrelude;\n+use str::{FromStr, StrPrelude};\n use slice::{CloneSlicePrelude, SlicePrelude};\n use vec::Vec;\n \n@@ -540,7 +539,7 @@ impl<'a> ToSocketAddr for &'a str {\n mod test {\n     use prelude::*;\n     use super::*;\n-    use from_str::FromStr;\n+    use str::FromStr;\n \n     #[test]\n     fn test_from_str_ipv4() {"}, {"sha": "4e063223329e6c2eaa2b6f0512fe0f30e44b160a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -54,7 +54,7 @@\n //!\n //! For converting to strings use the [`format!`](fmt/index.html)\n //! macro, and for converting from strings use the\n-//! [`FromStr`](from_str/index.html) trait.\n+//! [`FromStr`](str/trait.FromStr.html) trait.\n //!\n //! ## Platform abstractions\n //!\n@@ -219,7 +219,6 @@ pub mod time;\n /* Common traits */\n \n pub mod error;\n-pub mod from_str;\n pub mod num;\n pub mod to_string;\n "}, {"sha": "207fa6499309c43ceac08ae53569aa1e7df7e9e4", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -17,12 +17,10 @@\n \n use prelude::*;\n \n-use from_str::FromStr;\n use intrinsics;\n use libc::c_int;\n use num::{Float, FloatMath};\n use num::strconv;\n-use num;\n \n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -339,68 +337,6 @@ pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     r\n }\n \n-#[inline]\n-#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n-pub fn from_str_hex(src: &str) -> Option<f32> {\n-    strconv::from_str_radix_float(src, 16)\n-}\n-\n-impl FromStr for f32 {\n-    /// Convert a string in base 10 to a float.\n-    /// Accepts an optional decimal exponent.\n-    ///\n-    /// This function accepts strings such as\n-    ///\n-    /// * '3.14'\n-    /// * '+3.14', equivalent to '3.14'\n-    /// * '-3.14'\n-    /// * '2.5E10', or equivalently, '2.5e10'\n-    /// * '2.5E-10'\n-    /// * '.' (understood as 0)\n-    /// * '5.'\n-    /// * '.5', or, equivalently,  '0.5'\n-    /// * '+inf', 'inf', '-inf', 'NaN'\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    ///\n-    /// # Return value\n-    ///\n-    /// `None` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str(src: &str) -> Option<f32> {\n-        strconv::from_str_radix_float(src, 10u)\n-    }\n-}\n-\n-impl num::FromStrRadix for f32 {\n-    /// Convert a string in a given base to a float.\n-    ///\n-    /// Due to possible conflicts, this function does **not** accept\n-    /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n-    /// does it recognize exponents of any kind.\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    /// * radix - The base to use. Must lie in the range [2 .. 36]\n-    ///\n-    /// # Return value\n-    ///\n-    /// `None` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str_radix(src: &str, radix: uint) -> Option<f32> {\n-        strconv::from_str_radix_float(src, radix)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use f32::*;"}, {"sha": "543d50596e8ce00402a5d287ecf2e062ad273c42", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -16,12 +16,10 @@\n \n use prelude::*;\n \n-use from_str::FromStr;\n use intrinsics;\n use libc::c_int;\n use num::{Float, FloatMath};\n use num::strconv;\n-use num;\n \n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -347,63 +345,6 @@ pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     r\n }\n \n-#[inline]\n-#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n-pub fn from_str_hex(src: &str) -> Option<f64> {\n-    strconv::from_str_radix_float(src, 16)\n-}\n-\n-impl FromStr for f64 {\n-    /// Convert a string in base 10 to a float.\n-    /// Accepts an optional decimal exponent.\n-    ///\n-    /// This function accepts strings such as:\n-    ///\n-    /// * '3.14'\n-    /// * '-3.14'\n-    /// * '2.5E10', or equivalently, '2.5e10'\n-    /// * '2.5E-10'\n-    /// * '.' (understood as 0)\n-    /// * '5.'\n-    /// * '.5', or, equivalently,  '0.5'\n-    /// * inf', '-inf', 'NaN'\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    ///\n-    /// # Return value\n-    ///\n-    /// `none` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str(src: &str) -> Option<f64> {\n-        strconv::from_str_radix_float(src, 10u)\n-    }\n-}\n-\n-impl num::FromStrRadix for f64 {\n-    /// Convert a string in a given base to a float.\n-    ///\n-    /// Leading and trailing whitespace represent an error.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A string\n-    /// * radix - The base to use. Must lie in the range [2 .. 36]\n-    ///\n-    /// # Return value\n-    ///\n-    /// `None` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-    #[inline]\n-    fn from_str_radix(src: &str, radix: uint) -> Option<f64> {\n-        strconv::from_str_radix_float(src, radix)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use f64::*;"}, {"sha": "6455c10736a3fe8dc1beda48341339d60041d7aa", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"i16\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::i16::{BITS, BYTES, MIN, MAX};\n \n int_module!(i16)"}, {"sha": "39b179c8274eb01c07efc2c8e47cfaececfc636f", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"i32\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::i32::{BITS, BYTES, MIN, MAX};\n \n int_module!(i32)"}, {"sha": "a0c474c479ae409e6d1abf0d36bd9e2524e4e887", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"i64\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::i64::{BITS, BYTES, MIN, MAX};\n \n int_module!(i64)"}, {"sha": "e911ed1de9ac4e29a8eb2319bdb862375048461b", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"i8\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::i8::{BITS, BYTES, MIN, MAX};\n \n int_module!(i8)"}, {"sha": "36c021efe0a3978f29389520c2c2d29b3763b220", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"int\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::int::{BITS, BYTES, MIN, MAX};\n \n int_module!(int)"}, {"sha": "2f1162d28e558797a0c4be6239f39a808263e7c6", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -14,131 +14,4 @@\n \n macro_rules! int_module (($T:ty) => (\n \n-#[experimental = \"might need to return Result\"]\n-impl FromStr for $T {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<$T> {\n-        strconv::from_str_radix_int(s, 10)\n-    }\n-}\n-\n-#[experimental = \"might need to return Result\"]\n-impl FromStrRadix for $T {\n-    #[inline]\n-    fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        strconv::from_str_radix_int(s, radix)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use num::FromStrRadix;\n-\n-    #[test]\n-    fn test_from_str() {\n-        assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n-        assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n-        assert_eq!(from_str::<$T>(\"10\"), Some(10 as $T));\n-        assert_eq!(from_str::<i32>(\"123456789\"), Some(123456789 as i32));\n-        assert_eq!(from_str::<$T>(\"00100\"), Some(100 as $T));\n-\n-        assert_eq!(from_str::<$T>(\"-1\"), Some(-1 as $T));\n-        assert_eq!(from_str::<$T>(\"-3\"), Some(-3 as $T));\n-        assert_eq!(from_str::<$T>(\"-10\"), Some(-10 as $T));\n-        assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n-        assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n-\n-        assert_eq!(from_str::<$T>(\"\"), None);\n-        assert_eq!(from_str::<$T>(\" \"), None);\n-        assert_eq!(from_str::<$T>(\"x\"), None);\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Some(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Some(35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Some(-123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Some(-9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Some(-83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Some(-291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Some(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Some(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Some(-35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Some(-35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2), None::<$T>);\n-    }\n-\n-    #[test]\n-    fn test_int_to_str_overflow() {\n-        let mut i8_val: i8 = 127_i8;\n-        assert_eq!(i8_val.to_string(), \"127\".to_string());\n-\n-        i8_val += 1 as i8;\n-        assert_eq!(i8_val.to_string(), \"-128\".to_string());\n-\n-        let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(i16_val.to_string(), \"32767\".to_string());\n-\n-        i16_val += 1 as i16;\n-        assert_eq!(i16_val.to_string(), \"-32768\".to_string());\n-\n-        let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(i32_val.to_string(), \"2147483647\".to_string());\n-\n-        i32_val += 1 as i32;\n-        assert_eq!(i32_val.to_string(), \"-2147483648\".to_string());\n-\n-        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(i64_val.to_string(), \"9223372036854775807\".to_string());\n-\n-        i64_val += 1 as i64;\n-        assert_eq!(i64_val.to_string(), \"-9223372036854775808\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_int_from_str_overflow() {\n-        let mut i8_val: i8 = 127_i8;\n-        assert_eq!(from_str::<i8>(\"127\"), Some(i8_val));\n-        assert_eq!(from_str::<i8>(\"128\"), None);\n-\n-        i8_val += 1 as i8;\n-        assert_eq!(from_str::<i8>(\"-128\"), Some(i8_val));\n-        assert_eq!(from_str::<i8>(\"-129\"), None);\n-\n-        let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(from_str::<i16>(\"32767\"), Some(i16_val));\n-        assert_eq!(from_str::<i16>(\"32768\"), None);\n-\n-        i16_val += 1 as i16;\n-        assert_eq!(from_str::<i16>(\"-32768\"), Some(i16_val));\n-        assert_eq!(from_str::<i16>(\"-32769\"), None);\n-\n-        let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(from_str::<i32>(\"2147483647\"), Some(i32_val));\n-        assert_eq!(from_str::<i32>(\"2147483648\"), None);\n-\n-        i32_val += 1 as i32;\n-        assert_eq!(from_str::<i32>(\"-2147483648\"), Some(i32_val));\n-        assert_eq!(from_str::<i32>(\"-2147483649\"), None);\n-\n-        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(from_str::<i64>(\"9223372036854775807\"), Some(i64_val));\n-        assert_eq!(from_str::<i64>(\"9223372036854775808\"), None);\n-\n-        i64_val += 1 as i64;\n-        assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n-        assert_eq!(from_str::<i64>(\"-9223372036854775809\"), None);\n-    }\n-}\n-\n ))"}, {"sha": "73fd2ccd2d3c7a1e74ddd95ed52b4d8972fd06ad", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -16,8 +16,6 @@\n #![experimental]\n #![allow(missing_docs)]\n \n-use option::Option;\n-\n #[cfg(test)] use cmp::PartialEq;\n #[cfg(test)] use fmt::Show;\n #[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n@@ -31,6 +29,7 @@ pub use core::num::{checked_next_power_of_two};\n pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n+pub use core::num::{FromStrRadix, from_str_radix};\n pub use core::num::{FPCategory, FPNaN, FPInfinite, FPZero, FPSubnormal};\n pub use core::num::{FPNormal, Float};\n \n@@ -115,18 +114,6 @@ pub trait FloatMath: Float {\n     fn atanh(self) -> Self;\n }\n \n-/// A generic trait for converting a string with a radix (base) to a value\n-#[experimental = \"might need to return Result\"]\n-pub trait FromStrRadix {\n-    fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n-}\n-\n-/// A utility function that just calls FromStrRadix::from_str_radix.\n-#[experimental = \"might need to return Result\"]\n-pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n-    FromStrRadix::from_str_radix(str, radix)\n-}\n-\n // DEPRECATED\n \n #[deprecated = \"Use `FloatMath::abs_sub`\"]"}, {"sha": "31096c0aa467b69b676505f7760d2a9b91d56588", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 21, "deletions": 232, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -13,12 +13,8 @@\n #![allow(missing_docs)]\n \n use char;\n-use char::Char;\n-use from_str::from_str;\n-use iter::Iterator;\n use num;\n use num::{Int, Float, FPNaN, FPInfinite, ToPrimitive};\n-use option::{None, Option, Some};\n use slice::{SlicePrelude, CloneSliceAllocPrelude};\n use str::StrPrelude;\n use string::String;\n@@ -425,242 +421,35 @@ pub fn float_to_str_common<T: Float>(\n static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n \n-pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T> {\n-   assert!(radix >= 2 && radix <= 36,\n-           \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n-           radix);\n-\n-    let _0: T = Float::zero();\n-    let _1: T = Float::one();\n-    let radix_t: T = num::cast(radix as int).unwrap();\n-\n-    // Special values\n-    match src {\n-        \"inf\"   => return Some(Float::infinity()),\n-        \"-inf\"  => return Some(Float::neg_infinity()),\n-        \"NaN\"   => return Some(Float::nan()),\n-        _       => {},\n-    }\n-\n-    let (is_positive, src) =  match src.slice_shift_char() {\n-        (None, _)        => return None,\n-        (Some('-'), \"\")  => return None,\n-        (Some('-'), src) => (false, src),\n-        (Some(_), _)     => (true,  src),\n-    };\n-\n-    // The significand to accumulate\n-    let mut sig = if is_positive { _0 } else { -_0 };\n-    // Necessary to detect overflow\n-    let mut prev_sig = sig;\n-    let mut cs = src.chars().enumerate();\n-    // Exponent prefix and exponent index offset\n-    let mut exp_info = None::<(char, uint)>;\n-\n-    // Parse the integer part of the significand\n-    for (i, c) in cs {\n-        match c.to_digit(radix) {\n-            Some(digit) => {\n-                // shift significand one digit left\n-                sig = sig * radix_t;\n-\n-                // add/subtract current digit depending on sign\n-                if is_positive {\n-                    sig = sig + num::cast(digit as int).unwrap();\n-                } else {\n-                    sig = sig - num::cast(digit as int).unwrap();\n-                }\n-\n-                // Detect overflow by comparing to last value, except\n-                // if we've not seen any non-zero digits.\n-                if prev_sig != _0 {\n-                    if is_positive && sig <= prev_sig\n-                        { return Some(Float::infinity()); }\n-                    if !is_positive && sig >= prev_sig\n-                        { return Some(Float::neg_infinity()); }\n-\n-                    // Detect overflow by reversing the shift-and-add process\n-                    let digit: T = num::cast(digit as int).unwrap();\n-                    if is_positive && (prev_sig != ((sig - digit) / radix_t))\n-                        { return Some(Float::infinity()); }\n-                    if !is_positive && (prev_sig != ((sig + digit) / radix_t))\n-                        { return Some(Float::neg_infinity()); }\n-                }\n-                prev_sig = sig;\n-            },\n-            None => match c {\n-                'e' | 'E' | 'p' | 'P' => {\n-                    exp_info = Some((c, i + 1));\n-                    break;  // start of exponent\n-                },\n-                '.' => {\n-                    break;  // start of fractional part\n-                },\n-                _ => {\n-                    return None;\n-                },\n-            },\n-        }\n-    }\n-\n-    // If we are not yet at the exponent parse the fractional\n-    // part of the significand\n-    if exp_info.is_none() {\n-        let mut power = _1;\n-        for (i, c) in cs {\n-            match c.to_digit(radix) {\n-                Some(digit) => {\n-                    let digit: T = num::cast(digit).unwrap();\n-                    // Decrease power one order of magnitude\n-                    power = power / radix_t;\n-                    // add/subtract current digit depending on sign\n-                    sig = if is_positive {\n-                        sig + digit * power\n-                    } else {\n-                        sig - digit * power\n-                    };\n-                    // Detect overflow by comparing to last value\n-                    if is_positive && sig < prev_sig\n-                        { return Some(Float::infinity()); }\n-                    if !is_positive && sig > prev_sig\n-                        { return Some(Float::neg_infinity()); }\n-                    prev_sig = sig;\n-                },\n-                None => match c {\n-                    'e' | 'E' | 'p' | 'P' => {\n-                        exp_info = Some((c, i + 1));\n-                        break; // start of exponent\n-                    },\n-                    _ => {\n-                        return None; // invalid number\n-                    },\n-                },\n-            }\n-        }\n-    }\n-\n-    // Parse and calculate the exponent\n-    let exp = match exp_info {\n-        Some((c, offset)) => {\n-            let base: T = match c {\n-                'E' | 'e' if radix == 10 => num::cast(10u).unwrap(),\n-                'P' | 'p' if radix == 16 => num::cast(2u).unwrap(),\n-                _ => return None,\n-            };\n-\n-            // Parse the exponent as decimal integer\n-            let src = src[offset..];\n-            let (is_positive, exp) = match src.slice_shift_char() {\n-                (Some('-'), src) => (false, from_str::<uint>(src)),\n-                (Some('+'), src) => (true,  from_str::<uint>(src)),\n-                (Some(_), _)     => (true,  from_str::<uint>(src)),\n-                (None, _)        => return None,\n-            };\n-\n-            match (is_positive, exp) {\n-                (true,  Some(exp)) => base.powi(exp as i32),\n-                (false, Some(exp)) => _1 / base.powi(exp as i32),\n-                (_, None)          => return None,\n-            }\n-        },\n-        None => _1, // no exponent\n-    };\n+#[cfg(test)]\n+mod tests {\n+    use to_string::ToString;\n \n-    Some(sig * exp)\n-}\n+    #[test]\n+    fn test_int_to_str_overflow() {\n+        let mut i8_val: i8 = 127_i8;\n+        assert_eq!(i8_val.to_string(), \"127\".to_string());\n \n-pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n-   assert!(radix >= 2 && radix <= 36,\n-           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n-           radix);\n+        i8_val += 1 as i8;\n+        assert_eq!(i8_val.to_string(), \"-128\".to_string());\n \n-    fn cast<T: Int>(x: uint) -> T {\n-        num::cast(x).unwrap()\n-    }\n+        let mut i16_val: i16 = 32_767_i16;\n+        assert_eq!(i16_val.to_string(), \"32767\".to_string());\n \n-    let _0: T = Int::zero();\n-    let _1: T = Int::one();\n-    let is_signed = _0 > Int::min_value();\n+        i16_val += 1 as i16;\n+        assert_eq!(i16_val.to_string(), \"-32768\".to_string());\n \n-    let (is_positive, src) =  match src.slice_shift_char() {\n-        (Some('-'), src) if is_signed => (false, src),\n-        (Some(_), _) => (true, src),\n-        (None, _) => return None,\n-    };\n+        let mut i32_val: i32 = 2_147_483_647_i32;\n+        assert_eq!(i32_val.to_string(), \"2147483647\".to_string());\n \n-    let mut xs = src.chars().map(|c| {\n-        c.to_digit(radix).map(cast)\n-    });\n-    let radix = cast(radix);\n-    let mut result = _0;\n-\n-    if is_positive {\n-        for x in xs {\n-            let x = match x {\n-                Some(x) => x,\n-                None => return None,\n-            };\n-            result = match result.checked_mul(radix) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-            result = match result.checked_add(x) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-        }\n-    } else {\n-        for x in xs {\n-            let x = match x {\n-                Some(x) => x,\n-                None => return None,\n-            };\n-            result = match result.checked_mul(radix) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-            result = match result.checked_sub(x) {\n-                Some(result) => result,\n-                None => return None,\n-            };\n-        }\n-    }\n+        i32_val += 1 as i32;\n+        assert_eq!(i32_val.to_string(), \"-2147483648\".to_string());\n \n-    Some(result)\n-}\n+        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n+        assert_eq!(i64_val.to_string(), \"9223372036854775807\".to_string());\n \n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use option::*;\n-    use num::Float;\n-\n-    #[test]\n-    fn from_str_issue7588() {\n-        let u : Option<u8> = from_str_radix_int(\"1000\", 10);\n-        assert_eq!(u, None);\n-        let s : Option<i16> = from_str_radix_int(\"80000\", 10);\n-        assert_eq!(s, None);\n-        let f : Option<f32> = from_str_radix_float(\"10000000000000000000000000000000000000000\", 10);\n-        assert_eq!(f, Some(Float::infinity()))\n-        let fe : Option<f32> = from_str_radix_float(\"1e40\", 10);\n-        assert_eq!(fe, Some(Float::infinity()))\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix_float() {\n-        let x1 : Option<f64> = from_str_radix_float(\"-123.456\", 10);\n-        assert_eq!(x1, Some(-123.456));\n-        let x2 : Option<f32> = from_str_radix_float(\"123.456\", 10);\n-        assert_eq!(x2, Some(123.456));\n-        let x3 : Option<f32> = from_str_radix_float(\"-0.0\", 10);\n-        assert_eq!(x3, Some(-0.0));\n-        let x4 : Option<f32> = from_str_radix_float(\"0.0\", 10);\n-        assert_eq!(x4, Some(0.0));\n-        let x4 : Option<f32> = from_str_radix_float(\"1.0\", 10);\n-        assert_eq!(x4, Some(1.0));\n-        let x5 : Option<f32> = from_str_radix_float(\"-1.0\", 10);\n-        assert_eq!(x5, Some(-1.0));\n+        i64_val += 1 as i64;\n+        assert_eq!(i64_val.to_string(), \"-9223372036854775808\".to_string());\n     }\n }\n "}, {"sha": "246224ddb2b4eff7c3b98987f10d8dc57485bca9", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"u16\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::u16::{BITS, BYTES, MIN, MAX};\n \n uint_module!(u16)"}, {"sha": "143b45010c2548f3552e51acc91f4c398b3498b4", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"u32\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::u32::{BITS, BYTES, MIN, MAX};\n \n uint_module!(u32)"}, {"sha": "92c5380f980ea0d991a37150c801ec05a9dd6f8e", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"u64\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::u64::{BITS, BYTES, MIN, MAX};\n \n uint_module!(u64)"}, {"sha": "faa6d167065ce26a1de0bcf7e25b441293ba0906", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"u8\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::u8::{BITS, BYTES, MIN, MAX};\n \n uint_module!(u8)"}, {"sha": "a425aab3aa10c5529380d530eab152cebc010fcb", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -13,11 +13,6 @@\n #![unstable]\n #![doc(primitive = \"uint\")]\n \n-use from_str::FromStr;\n-use num::FromStrRadix;\n-use num::strconv;\n-use option::Option;\n-\n pub use core::uint::{BITS, BYTES, MIN, MAX};\n \n uint_module!(uint)"}, {"sha": "ef9e809ed2bcc3fbff2eee6c104ce5833ac0b2fb", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -15,22 +15,6 @@\n \n macro_rules! uint_module (($T:ty) => (\n \n-#[experimental = \"might need to return Result\"]\n-impl FromStr for $T {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<$T> {\n-        strconv::from_str_radix_int(s, 10)\n-    }\n-}\n-\n-#[experimental = \"might need to return Result\"]\n-impl FromStrRadix for $T {\n-    #[inline]\n-    fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        strconv::from_str_radix_int(s, radix)\n-    }\n-}\n-\n // String conversion functions and impl num -> str\n \n /// Convert to a string as a byte slice in a given base."}, {"sha": "e2ff824a7c98fb5010d585f58b264711d572060b", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -13,12 +13,11 @@\n use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n-use from_str::FromStr;\n use hash;\n use io::Writer;\n use iter::{DoubleEndedIterator, AdditiveIterator, Extend, Iterator, Map};\n use option::{Option, None, Some};\n-use str::Str;\n+use str::{FromStr, Str};\n use str;\n use slice::{CloneSliceAllocPrelude, Splits, AsSlice, VectorVector,\n             PartialEqSlicePrelude, SlicePrelude};"}, {"sha": "b8016e3e8f453b2fbcf41024e2b451fcfe54f74c", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -16,14 +16,13 @@ use ascii::AsciiCast;\n use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n-use from_str::FromStr;\n use hash;\n use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extend, Iterator, Map};\n use mem;\n use option::{Option, Some, None};\n use slice::{AsSlice, SlicePrelude};\n-use str::{CharSplits, Str, StrAllocating, StrVector, StrPrelude};\n+use str::{CharSplits, FromStr, Str, StrAllocating, StrVector, StrPrelude};\n use string::String;\n use unicode::char::UnicodeChar;\n use vec::Vec;"}, {"sha": "4ab09a2a8641f0f4b60714e273e90396fb548126", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -50,9 +50,9 @@\n #[doc(no_inline)] pub use ops::{Fn, FnMut, FnOnce};\n \n // Reexported functions\n-#[doc(no_inline)] pub use from_str::from_str;\n #[doc(no_inline)] pub use iter::{range, repeat};\n #[doc(no_inline)] pub use mem::drop;\n+#[doc(no_inline)] pub use str::from_str;\n \n // Reexported types and traits\n "}, {"sha": "8b457d1639dc43857199b21f9c90fa413e3a6a6a", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -12,13 +12,12 @@\n \n #![allow(non_camel_case_types)]\n \n-use from_str::from_str;\n use io::{IoResult, Writer};\n use iter::Iterator;\n use option::{Some, None};\n use os;\n use result::{Ok, Err};\n-use str::StrPrelude;\n+use str::{StrPrelude, from_str};\n use sync::atomic;\n use unicode::char::UnicodeChar;\n "}, {"sha": "92657d1b59bee8723bcdbb57fdc363d08912ec0d", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use from_str::FromStr;\n-use from_str::from_str;\n use libc::uintptr_t;\n use option::{Some, None, Option};\n use os;\n-use str::Str;\n+use str::{FromStr, from_str, Str};\n use sync::atomic;\n \n /// Dynamically inquire about whether we're running under V."}, {"sha": "ff96f806faccb336cb8a16f86247c3f6c50d4a4e", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29bc9c632eda71c6b4a8b35db637971953b58d03/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=29bc9c632eda71c6b4a8b35db637971953b58d03", "patch": "@@ -53,13 +53,13 @@ use std::cmp;\n use std::f64;\n use std::fmt::Show;\n use std::fmt;\n-use std::from_str::FromStr;\n use std::io::fs::PathExtensions;\n use std::io::stdio::StdWriter;\n use std::io::{File, ChanReader, ChanWriter};\n use std::io;\n use std::num::{Float, FloatMath, Int};\n use std::os;\n+use std::str::FromStr;\n use std::string::String;\n use std::task::TaskBuilder;\n use std::time::Duration;"}]}