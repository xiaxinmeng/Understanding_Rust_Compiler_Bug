{"sha": "29c0ab77ba4e3a196227ee1d61a2ae57e35625c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YzBhYjc3YmE0ZTNhMTk2MjI3ZWUxZDYxYTJhZTU3ZTM1NjI1YzA=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-05-21T10:56:13Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-05-23T03:45:09Z"}, "message": "Implement combining openings and closings", "tree": {"sha": "7d4ea7f9734d0a5bcb98c49d0d6d76110f98ae77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d4ea7f9734d0a5bcb98c49d0d6d76110f98ae77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29c0ab77ba4e3a196227ee1d61a2ae57e35625c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29c0ab77ba4e3a196227ee1d61a2ae57e35625c0", "html_url": "https://github.com/rust-lang/rust/commit/29c0ab77ba4e3a196227ee1d61a2ae57e35625c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29c0ab77ba4e3a196227ee1d61a2ae57e35625c0/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb8d67196ca91205fd98f498485c6679f7a26324", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb8d67196ca91205fd98f498485c6679f7a26324", "html_url": "https://github.com/rust-lang/rust/commit/eb8d67196ca91205fd98f498485c6679f7a26324"}], "stats": {"total": 83, "additions": 58, "deletions": 25}, "files": [{"sha": "f0db88ae56679a216018b2cb82bc1b9ae8ce6cc8", "filename": "src/expr.rs", "status": "modified", "additions": 58, "deletions": 25, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/29c0ab77ba4e3a196227ee1d61a2ae57e35625c0/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c0ab77ba4e3a196227ee1d61a2ae57e35625c0/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=29c0ab77ba4e3a196227ee1d61a2ae57e35625c0", "patch": "@@ -1334,18 +1334,21 @@ impl Rewrite for ast::Arm {\n \n         let pats_str = format!(\"{}{}\", pats_str, guard_str);\n \n-        let body = match body.node {\n+        let (mut extend, body) = match body.node {\n             ast::ExprKind::Block(ref block) if !is_unsafe_block(block) &&\n                                                is_simple_block(block, context.codemap) &&\n                                                context.config.wrap_match_arms() => {\n                 if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n-                    expr\n+                    (false, &**expr)\n                 } else {\n-                    &**body\n+                    (false, &**body)\n                 }\n             }\n-            _ => &**body,\n+            ast::ExprKind::Call(_, ref args) => (args.len() == 1, &**body),\n+            ast::ExprKind::Closure(..) => (true, &**body),\n+            _ => (false, &**body),\n         };\n+        extend &= context.config.fn_call_style == IndentStyle::Block;\n \n         let comma = arm_comma(&context.config, body);\n         let alt_block_sep = String::from(\"\\n\") +\n@@ -1371,6 +1374,7 @@ impl Rewrite for ast::Arm {\n                 Some(ref body_str) if (!body_str.contains('\\n') &&\n                                        body_str.len() <= arm_shape.width) ||\n                                       !context.config.wrap_match_arms() ||\n+                                      (extend && first_line_width(body_str) <= arm_shape.width) ||\n                                       is_block => {\n                     let block_sep = match context.config.control_brace_style() {\n                         ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep.as_str(),\n@@ -1611,9 +1615,7 @@ pub fn rewrite_call<R>(context: &RewriteContext,\n     let closure =\n         |callee_max_width| rewrite_call_inner(context, callee, callee_max_width, args, span, shape);\n \n-    // 2 is for parens\n-    let max_width = try_opt!(shape.width.checked_sub(2));\n-    binary_search(1, max_width, closure)\n+    binary_search(1, shape.width, closure)\n }\n \n fn rewrite_call_inner<R>(context: &RewriteContext,\n@@ -1635,25 +1637,43 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n         .rewrite(context, callee_shape)\n         .ok_or(Ordering::Greater)?;\n \n-    // 4 = `(  )`, 2 = `()`\n+    // 2 = `( `, 1 = `(`\n     let paren_overhead = if context.config.spaces_within_parens() {\n-        4\n-    } else {\n         2\n+    } else {\n+        1\n     };\n     let used_width = extra_offset(&callee_str, shape);\n     let one_line_width = shape\n         .width\n-        .checked_sub(used_width + paren_overhead)\n+        .checked_sub(used_width + 2 * paren_overhead)\n         .ok_or(Ordering::Greater)?;\n \n+    // Try combining openings and closings\n+    if args.len() == 1 && context.config.fn_call_style() == IndentStyle::Block {\n+        let expr = &*args[0];\n+        match expr.node {\n+            ast::ExprKind::Struct(..) |\n+            ast::ExprKind::Call(..) |\n+            ast::ExprKind::Closure(..) => {\n+                let max_width = min(one_line_width, context.config.fn_call_width());\n+                let shape = Shape::legacy(max_width, shape.block().indent);\n+                if let Some(expr_str) = expr.rewrite(context, shape) {\n+                    if first_line_width(&expr_str) <= max_width {\n+                        return Ok(format!(\"{}({})\", callee_str, expr_str));\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+\n     let nested_shape = match context.config.fn_call_style() {\n             IndentStyle::Block => shape.block().block_left(context.config.tab_spaces()),\n-            // 1 = (\n             IndentStyle::Visual => {\n                 shape\n-                    .visual_indent(used_width + 1)\n-                    .sub_width(used_width + paren_overhead)\n+                    .visual_indent(used_width + paren_overhead)\n+                    .sub_width(used_width + 2 * paren_overhead)\n             }\n         }\n         .ok_or(Ordering::Greater)?;\n@@ -1664,8 +1684,12 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     let list_str = rewrite_call_args(context, args, span, nested_shape, one_line_width)\n         .ok_or(Ordering::Less)?;\n \n+    let arg_one_line_budget = min(one_line_width, context.config.fn_call_width());\n     let result = if context.config.fn_call_style() == IndentStyle::Visual ||\n-                    (!list_str.contains('\\n') && list_str.chars().last().unwrap_or(' ') != ',') {\n+                    (((can_be_overflowed(args) &&\n+                       first_line_width(&list_str) <= arg_one_line_budget) ||\n+                      !list_str.contains('\\n')) &&\n+                     list_str.chars().last().unwrap_or(' ') != ',') {\n         if context.config.spaces_within_parens() && list_str.len() > 0 {\n             format!(\"{}( {} )\", callee_str, list_str)\n         } else {\n@@ -1682,6 +1706,15 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     Ok(result)\n }\n \n+fn can_be_overflowed(args: &[ptr::P<ast::Expr>]) -> bool {\n+    match args.last().map(|x| &x.node) {\n+        Some(&ast::ExprKind::Closure(..)) |\n+        Some(&ast::ExprKind::Block(..)) |\n+        Some(&ast::ExprKind::Match(..)) if args.len() > 1 => true,\n+        _ => false,\n+    }\n+}\n+\n fn rewrite_call_args(context: &RewriteContext,\n                      args: &[ptr::P<ast::Expr>],\n                      span: Span,\n@@ -1703,24 +1736,24 @@ fn rewrite_call_args(context: &RewriteContext,\n     // Try letting the last argument overflow to the next line with block\n     // indentation. If its first line fits on one line with the other arguments,\n     // we format the function arguments horizontally.\n-    let overflow_last = match args.last().map(|x| &x.node) {\n-        Some(&ast::ExprKind::Closure(..)) |\n-        Some(&ast::ExprKind::Block(..)) |\n-        Some(&ast::ExprKind::Match(..)) if arg_count > 1 => true,\n-        _ => false,\n-    };\n+    let overflow_last = can_be_overflowed(args);\n \n     let mut orig_last = None;\n     let mut placeholder = None;\n \n     // Replace the last item with its first line to see if it fits with\n     // first arguments.\n     if overflow_last {\n-        let nested_shape = Shape {\n-            indent: shape.indent.block_only(),\n-            ..shape\n+        let last_arg = args.last().unwrap();\n+        let arg_shape = match last_arg.node {\n+            ast::ExprKind::Closure(..) if context.config.fn_call_style == IndentStyle::Block => {\n+                let mut arg_shape = shape.block();\n+                arg_shape.indent.block_indent -= context.config.tab_spaces;\n+                arg_shape\n+            }\n+            _ => shape.block(),\n         };\n-        let rewrite = args.last().unwrap().rewrite(context, nested_shape);\n+        let rewrite = args.last().unwrap().rewrite(context, arg_shape);\n \n         if let Some(rewrite) = rewrite {\n             let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());"}]}