{"sha": "23e5ed1288018a9b17b0b741dd6c36b98c9a415e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzZTVlZDEyODgwMThhOWIxN2IwYjc0MWRkNmMzNmI5OGM5YTQxNWU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-06-08T14:06:33Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-06-23T19:32:37Z"}, "message": "Check if error code is used", "tree": {"sha": "1c87929faa859f515c725843dcce8c223a07fd84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c87929faa859f515c725843dcce8c223a07fd84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23e5ed1288018a9b17b0b741dd6c36b98c9a415e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23e5ed1288018a9b17b0b741dd6c36b98c9a415e", "html_url": "https://github.com/rust-lang/rust/commit/23e5ed1288018a9b17b0b741dd6c36b98c9a415e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23e5ed1288018a9b17b0b741dd6c36b98c9a415e/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6f3cb9502b1910f6af32f426fdb78e813b390ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f3cb9502b1910f6af32f426fdb78e813b390ef", "html_url": "https://github.com/rust-lang/rust/commit/b6f3cb9502b1910f6af32f426fdb78e813b390ef"}], "stats": {"total": 115, "additions": 99, "deletions": 16}, "files": [{"sha": "b8e0042948f01703e37aa075fbfc2097ae7411c5", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 99, "deletions": 16, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/23e5ed1288018a9b17b0b741dd6c36b98c9a415e/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e5ed1288018a9b17b0b741dd6c36b98c9a415e/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=23e5ed1288018a9b17b0b741dd6c36b98c9a415e", "patch": "@@ -1,11 +1,14 @@\n //! Checks that all error codes have at least one test to prevent having error\n //! codes that are silently not thrown by the compiler anymore.\n \n+use std::collections::hash_map::Entry;\n use std::collections::HashMap;\n use std::ffi::OsStr;\n use std::fs::read_to_string;\n use std::path::Path;\n \n+use regex::Regex;\n+\n // A few of those error codes can't be tested but all the others can and *should* be tested!\n const EXEMPTED_FROM_TEST: &[&str] = &[\n     \"E0227\", \"E0279\", \"E0280\", \"E0313\", \"E0314\", \"E0315\", \"E0377\", \"E0461\", \"E0462\", \"E0464\",\n@@ -17,9 +20,16 @@ const EXEMPTED_FROM_TEST: &[&str] = &[\n // Some error codes don't have any tests apparently...\n const IGNORE_EXPLANATION_CHECK: &[&str] = &[\"E0570\", \"E0601\", \"E0602\", \"E0729\"];\n \n+#[derive(Default, Debug)]\n+struct ErrorCodeStatus {\n+    has_test: bool,\n+    has_explanation: bool,\n+    is_used: bool,\n+}\n+\n fn check_error_code_explanation(\n     f: &str,\n-    error_codes: &mut HashMap<String, bool>,\n+    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n     err_code: String,\n ) -> bool {\n     let mut invalid_compile_fail_format = false;\n@@ -30,15 +40,15 @@ fn check_error_code_explanation(\n         if s.starts_with(\"```\") {\n             if s.contains(\"compile_fail\") && s.contains('E') {\n                 if !found_error_code {\n-                    error_codes.insert(err_code.clone(), true);\n+                    error_codes.get_mut(&err_code).map(|x| x.has_test = true);\n                     found_error_code = true;\n                 }\n             } else if s.contains(\"compile-fail\") {\n                 invalid_compile_fail_format = true;\n             }\n         } else if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n             if !found_error_code {\n-                error_codes.get_mut(&err_code).map(|x| *x = true);\n+                error_codes.get_mut(&err_code).map(|x| x.has_test = true);\n                 found_error_code = true;\n             }\n         }\n@@ -77,7 +87,7 @@ macro_rules! some_or_continue {\n \n fn extract_error_codes(\n     f: &str,\n-    error_codes: &mut HashMap<String, bool>,\n+    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n     path: &Path,\n     errors: &mut Vec<String>,\n ) {\n@@ -90,14 +100,26 @@ fn extract_error_codes(\n                 .split_once(':')\n                 .expect(\n                     format!(\n-                        \"Expected a line with the format `E0xxx: include_str!(\\\"..\\\")`, but got {} without a `:` delimiter\",\n+                        \"Expected a line with the format `E0xxx: include_str!(\\\"..\\\")`, but got {} \\\n+                         without a `:` delimiter\",\n                         s,\n-                    ).as_str()\n+                    )\n+                    .as_str(),\n                 )\n                 .0\n                 .to_owned();\n-            if !error_codes.contains_key(&err_code) {\n-                error_codes.insert(err_code.clone(), false);\n+            match error_codes.entry(err_code.clone()) {\n+                Entry::Occupied(mut e) => {\n+                    let mut entry = e.get_mut();\n+                    entry.has_explanation = true\n+                }\n+                Entry::Vacant(e) => {\n+                    e.insert(ErrorCodeStatus {\n+                        has_test: false,\n+                        is_used: false,\n+                        has_explanation: true,\n+                    });\n+                }\n             }\n             // Now we extract the tests from the markdown file!\n             let md_file_name = match s.split_once(\"include_str!(\\\"\") {\n@@ -145,15 +167,15 @@ fn extract_error_codes(\n             .to_string();\n             if !error_codes.contains_key(&err_code) {\n                 // this check should *never* fail!\n-                error_codes.insert(err_code, false);\n+                error_codes.insert(err_code, ErrorCodeStatus::default());\n             }\n         } else if s == \";\" {\n             reached_no_explanation = true;\n         }\n     }\n }\n \n-fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, bool>) {\n+fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, ErrorCodeStatus>) {\n     for line in f.lines() {\n         let s = line.trim();\n         if s.starts_with(\"error[E\") || s.starts_with(\"warning[E\") {\n@@ -164,8 +186,48 @@ fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, boo\n                     Some((_, err_code)) => err_code,\n                 },\n             };\n-            let nb = error_codes.entry(err_code.to_owned()).or_insert(false);\n-            *nb = true;\n+            match error_codes.entry(err_code.to_owned()) {\n+                Entry::Occupied(mut e) => {\n+                    let mut entry = e.get_mut();\n+                    entry.has_test = true\n+                }\n+                Entry::Vacant(e) => {\n+                    e.insert(ErrorCodeStatus {\n+                        has_test: true,\n+                        is_used: false,\n+                        has_explanation: false,\n+                    });\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn extract_error_codes_from_source(\n+    f: &str,\n+    error_codes: &mut HashMap<String, ErrorCodeStatus>,\n+    regex: &Regex,\n+) {\n+    for line in f.lines() {\n+        if line.trim_start().starts_with(\"//\") {\n+            continue;\n+        }\n+        for cap in regex.captures_iter(line) {\n+            if let Some(error_code) = cap.get(1) {\n+                match error_codes.entry(error_code.as_str().to_owned()) {\n+                    Entry::Occupied(mut e) => {\n+                        let mut entry = e.get_mut();\n+                        entry.is_used = true\n+                    }\n+                    Entry::Vacant(e) => {\n+                        e.insert(ErrorCodeStatus {\n+                            has_test: false,\n+                            is_used: true,\n+                            has_explanation: false,\n+                        });\n+                    }\n+                }\n+            }\n         }\n     }\n }\n@@ -174,8 +236,17 @@ pub fn check(paths: &[&Path], bad: &mut bool) {\n     let mut errors = Vec::new();\n     let mut found_explanations = 0;\n     let mut found_tests = 0;\n+    let mut error_codes: HashMap<String, ErrorCodeStatus> = HashMap::new();\n+    // We want error codes which match the following cases:\n+    //\n+    // * foo(a, E0111, a)\n+    // * foo(a, E0111)\n+    // * foo(E0111, a)\n+    // * #[error = \"E0111\"]\n+    let regex = Regex::new(r#\"[(,\"\\s](E\\d{4})[,)\"]\"#).unwrap();\n+\n     println!(\"Checking which error codes lack tests...\");\n-    let mut error_codes: HashMap<String, bool> = HashMap::new();\n+\n     for path in paths {\n         super::walk(path, &mut |path| super::filter_dirs(path), &mut |entry, contents| {\n             let file_name = entry.file_name();\n@@ -185,6 +256,11 @@ pub fn check(paths: &[&Path], bad: &mut bool) {\n             } else if entry.path().extension() == Some(OsStr::new(\"stderr\")) {\n                 extract_error_codes_from_tests(contents, &mut error_codes);\n                 found_tests += 1;\n+            } else if entry.path().extension() == Some(OsStr::new(\"rs\")) {\n+                let path = entry.path().to_string_lossy();\n+                if [\"src/test/\", \"src/doc/\", \"src/tools/\"].iter().all(|c| !path.contains(c)) {\n+                    extract_error_codes_from_source(contents, &mut error_codes, &regex);\n+                }\n             }\n         });\n     }\n@@ -199,15 +275,22 @@ pub fn check(paths: &[&Path], bad: &mut bool) {\n     if errors.is_empty() {\n         println!(\"Found {} error codes\", error_codes.len());\n \n-        for (err_code, nb) in &error_codes {\n-            if !*nb && !EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n+        for (err_code, error_status) in &error_codes {\n+            if !error_status.has_test && !EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n                 errors.push(format!(\"Error code {} needs to have at least one UI test!\", err_code));\n-            } else if *nb && EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n+            } else if error_status.has_test && EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n                 errors.push(format!(\n                     \"Error code {} has a UI test, it shouldn't be listed into EXEMPTED_FROM_TEST!\",\n                     err_code\n                 ));\n             }\n+            if !error_status.is_used && !error_status.has_explanation {\n+                errors.push(format!(\n+                    \"Error code {} isn't used and doesn't have an error explanation, it should be \\\n+                     commented in error_codes.rs file\",\n+                    err_code\n+                ));\n+            }\n         }\n     }\n     errors.sort();"}]}