{"sha": "074972150f5bf88152349279cb17f161c2f05988", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NDk3MjE1MGY1YmY4ODE1MjM0OTI3OWNiMTdmMTYxYzJmMDU5ODg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-04-16T09:59:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-04-16T11:03:41Z"}, "message": "compute SCCs in dependency order", "tree": {"sha": "5bbb08d7b6e22a63012b57454d71fc1500a02328", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bbb08d7b6e22a63012b57454d71fc1500a02328"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/074972150f5bf88152349279cb17f161c2f05988", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/074972150f5bf88152349279cb17f161c2f05988", "html_url": "https://github.com/rust-lang/rust/commit/074972150f5bf88152349279cb17f161c2f05988", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/074972150f5bf88152349279cb17f161c2f05988/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8caef423d8aaef7afe228c75cb5228431e459f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8caef423d8aaef7afe228c75cb5228431e459f9", "html_url": "https://github.com/rust-lang/rust/commit/b8caef423d8aaef7afe228c75cb5228431e459f9"}], "stats": {"total": 93, "additions": 60, "deletions": 33}, "files": [{"sha": "880edf706a5d4bae01c712ffde10dc773653b38c", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 60, "deletions": 33, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/074972150f5bf88152349279cb17f161c2f05988/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074972150f5bf88152349279cb17f161c2f05988/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=074972150f5bf88152349279cb17f161c2f05988", "patch": "@@ -67,6 +67,12 @@ pub struct RegionInferenceContext<'tcx> {\n     /// compute the values of each region.\n     constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n+    /// SCCs in \"dependency order\" (or \"post order\"), meaning that if S1 -> S2,\n+    /// then S2 appears first. If you process the SCCs in this order, then you\n+    /// are always ensured that when you proces a given SCC, all of its\n+    /// successors have been processed.\n+    scc_dependency_order: Vec<ConstraintSccIndex>,\n+\n     /// Reverse of the SCC constraint graph --  i.e., an edge `A -> B` exists if\n     /// `B: A`. This is used to compute the universal regions that are required\n     /// to outlive a given SCC. Computed lazily.\n@@ -277,7 +283,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             scc_values.merge_liveness(scc, region, &liveness_constraints);\n         }\n \n-        let scc_universes = Self::compute_scc_universes(&constraint_sccs, &definitions);\n+        let scc_dependency_order = Self::compute_scc_dependency_order(&constraint_sccs);\n+\n+        let scc_universes =\n+            Self::compute_scc_universes(&constraint_sccs, &scc_dependency_order, &definitions);\n \n         let scc_representatives = Self::compute_scc_representatives(&constraint_sccs, &definitions);\n \n@@ -290,6 +299,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n+            scc_dependency_order,\n             rev_scc_graph: None,\n             member_constraints,\n             member_constraints_applied: Vec::new(),\n@@ -307,6 +317,43 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         result\n     }\n \n+    /// Returns a vector of all scc-ids in \"dependency\" or \"post order\". See the\n+    /// `scc_dependency_order` field for more details.\n+    fn compute_scc_dependency_order(\n+        constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n+    ) -> Vec<ConstraintSccIndex> {\n+        let mut visited = &mut BitSet::new_empty(constraints_scc.num_sccs());\n+        let mut output = vec![];\n+\n+        for scc in constraints_scc.all_sccs() {\n+            Self::compute_scc_dependency_order_if_new(\n+                constraints_scc,\n+                scc,\n+                &mut visited,\n+                &mut output,\n+            );\n+        }\n+\n+        output\n+    }\n+\n+    fn compute_scc_dependency_order_if_new(\n+        constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n+        index: ConstraintSccIndex,\n+        visited: &mut BitSet<ConstraintSccIndex>,\n+        output: &mut Vec<ConstraintSccIndex>,\n+    ) {\n+        if !visited.insert(index) {\n+            return;\n+        }\n+\n+        for &succ in constraints_scc.successors(index) {\n+            Self::compute_scc_dependency_order_if_new(constraints_scc, succ, visited, output);\n+        }\n+\n+        output.push(index);\n+    }\n+\n     /// Each SCC is the combination of many region variables which\n     /// have been equated. Therefore, we can associate a universe with\n     /// each SCC which is minimum of all the universes of its\n@@ -315,10 +362,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// SCC could have as well. This implies that the SCC must have\n     /// the minimum, or narrowest, universe.\n     fn compute_scc_universes(\n-        constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n+        constraint_sccs: &Sccs<RegionVid, ConstraintSccIndex>,\n+        scc_dependency_order: &[ConstraintSccIndex],\n         definitions: &IndexVec<RegionVid, RegionDefinition<'tcx>>,\n     ) -> IndexVec<ConstraintSccIndex, ty::UniverseIndex> {\n-        let num_sccs = constraints_scc.num_sccs();\n+        let num_sccs = constraint_sccs.num_sccs();\n         let mut scc_universes = IndexVec::from_elem_n(ty::UniverseIndex::MAX, num_sccs);\n \n         debug!(\"compute_scc_universes()\");\n@@ -327,7 +375,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // that contains R is \"no bigger\" than U. This effectively sets the universe\n         // for each SCC to be the minimum of the regions within.\n         for (region_vid, region_definition) in definitions.iter_enumerated() {\n-            let scc = constraints_scc.scc(region_vid);\n+            let scc = constraint_sccs.scc(region_vid);\n             let scc_universe = &mut scc_universes[scc];\n             let scc_min = std::cmp::min(region_definition.universe, *scc_universe);\n             if scc_min != *scc_universe {\n@@ -372,8 +420,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // constraint lowers the universe of `R1` to `U0`, which in turn\n         // means that the `R1: !1` constraint will (later) cause\n         // `R1` to become `'static`.\n-        for scc_a in constraints_scc.all_sccs() {\n-            for &scc_b in constraints_scc.successors(scc_a) {\n+        for &scc_a in scc_dependency_order {\n+            for &scc_b in constraint_sccs.successors(scc_a) {\n                 let scc_universe_a = scc_universes[scc_a];\n                 let scc_universe_b = scc_universes[scc_b];\n                 let scc_universe_min = std::cmp::min(scc_universe_a, scc_universe_b);\n@@ -616,47 +664,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // SCC. For each SCC, we visit its successors and compute\n         // their values, then we union all those values to get our\n         // own.\n-        let visited = &mut BitSet::new_empty(self.constraint_sccs.num_sccs());\n-        for scc_index in self.constraint_sccs.all_sccs() {\n-            self.propagate_constraint_sccs_if_new(scc_index, visited);\n+        for i in 0..self.scc_dependency_order.len() {\n+            self.compute_value_for_scc(self.scc_dependency_order[i]);\n         }\n \n         // Sort the applied member constraints so we can binary search\n         // through them later.\n         self.member_constraints_applied.sort_by_key(|applied| applied.member_region_scc);\n     }\n \n-    /// Computes the value of the SCC `scc_a` if it has not already\n-    /// been computed. The `visited` parameter is a bitset\n-    #[inline]\n-    fn propagate_constraint_sccs_if_new(\n-        &mut self,\n-        scc_a: ConstraintSccIndex,\n-        visited: &mut BitSet<ConstraintSccIndex>,\n-    ) {\n-        if visited.insert(scc_a) {\n-            self.propagate_constraint_sccs_new(scc_a, visited);\n-        }\n-    }\n-\n     /// Computes the value of the SCC `scc_a`, which has not yet been\n-    /// computed. This works by first computing all successors of the\n-    /// SCC (if they haven't been computed already) and then unioning\n-    /// together their elements.\n-    fn propagate_constraint_sccs_new(\n-        &mut self,\n-        scc_a: ConstraintSccIndex,\n-        visited: &mut BitSet<ConstraintSccIndex>,\n-    ) {\n+    /// computed, by unioning the values of its successors.\n+    /// Assumes that all successors have been computed already\n+    /// (which is assured by iterating over SCCs in dependency order).\n+    fn compute_value_for_scc(&mut self, scc_a: ConstraintSccIndex) {\n         let constraint_sccs = self.constraint_sccs.clone();\n \n         // Walk each SCC `B` such that `A: B`...\n         for &scc_b in constraint_sccs.successors(scc_a) {\n             debug!(\"propagate_constraint_sccs: scc_a = {:?} scc_b = {:?}\", scc_a, scc_b);\n \n-            // ...compute the value of `B`...\n-            self.propagate_constraint_sccs_if_new(scc_b, visited);\n-\n             // ...and add elements from `B` into `A`. One complication\n             // arises because of universes: If `B` contains something\n             // that `A` cannot name, then `A` can only contain `B` if"}]}