{"sha": "d93c1b320c1dc6d38165c70e5f1c13dba895c179", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5M2MxYjMyMGMxZGM2ZDM4MTY1YzcwZTVmMWMxM2RiYTg5NWMxNzk=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-16T16:05:32Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-16T16:43:20Z"}, "message": "Introduce new FixedLenSlice constructor\n\nIt is used in the case where a variable-length slice pattern is used to\nmatch on an array of known size. This allows considering only those\nentries in the array that are captured by one of the patterns.\nAs a side-effect, diagnostics improve a bit for those cases.", "tree": {"sha": "c4a7dce0178274e24328590860474bf726a9d18d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4a7dce0178274e24328590860474bf726a9d18d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d93c1b320c1dc6d38165c70e5f1c13dba895c179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d93c1b320c1dc6d38165c70e5f1c13dba895c179", "html_url": "https://github.com/rust-lang/rust/commit/d93c1b320c1dc6d38165c70e5f1c13dba895c179", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d93c1b320c1dc6d38165c70e5f1c13dba895c179/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c00ecfa8d268ad34c90667a249384618a19ea39b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c00ecfa8d268ad34c90667a249384618a19ea39b", "html_url": "https://github.com/rust-lang/rust/commit/c00ecfa8d268ad34c90667a249384618a19ea39b"}], "stats": {"total": 129, "additions": 92, "deletions": 37}, "files": [{"sha": "fdee2ffee983ce3fbb09afe956f9c95d394881d0", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 81, "deletions": 26, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d93c1b320c1dc6d38165c70e5f1c13dba895c179/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d93c1b320c1dc6d38165c70e5f1c13dba895c179/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=d93c1b320c1dc6d38165c70e5f1c13dba895c179", "patch": "@@ -597,6 +597,14 @@ enum Constructor<'tcx> {\n     FloatRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n     /// Array patterns of length `n`.\n     FixedLenSlice(u64),\n+    /// Array patterns of length `len`, but for which we only care about the `prefix` first values\n+    /// and the `suffix` last values. This avoids unnecessarily going through values we know to be\n+    /// uninteresting, which can be a major problem for large arrays.\n+    LazyFixedLenSlice {\n+        len: u64, // The actual length of the array\n+        prefix: u64,\n+        suffix: u64,\n+    },\n     /// Slice patterns. Captures any array constructor of `length >= i + j`.\n     VarLenSlice(u64, u64),\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n@@ -606,7 +614,7 @@ enum Constructor<'tcx> {\n impl<'tcx> Constructor<'tcx> {\n     fn is_slice(&self) -> bool {\n         match self {\n-            FixedLenSlice { .. } | VarLenSlice { .. } => true,\n+            FixedLenSlice { .. } | LazyFixedLenSlice { .. } | VarLenSlice { .. } => true,\n             _ => false,\n         }\n     }\n@@ -635,9 +643,9 @@ impl<'tcx> Constructor<'tcx> {\n             Single | Variant(_) | ConstantValue(..) | FloatRange(..) => {\n                 if other_ctors.iter().any(|c| c == self) { vec![] } else { vec![self.clone()] }\n             }\n-            &FixedLenSlice(self_len) => {\n+            &FixedLenSlice(self_len) | &LazyFixedLenSlice { len: self_len, .. } => {\n                 let overlaps = |c: &Constructor<'_>| match *c {\n-                    FixedLenSlice(other_len) => other_len == self_len,\n+                    FixedLenSlice(len) | LazyFixedLenSlice { len, .. } => len == self_len,\n                     VarLenSlice(prefix, suffix) => prefix + suffix <= self_len,\n                     _ => false,\n                 };\n@@ -657,7 +665,12 @@ impl<'tcx> Constructor<'tcx> {\n                             // Compute `pos_ctor \\ neg_ctor`.\n                             match pos_ctor {\n                                 FixedLenSlice(pos_len) => match *neg_ctor {\n-                                    FixedLenSlice(neg_len) if neg_len == pos_len => smallvec![],\n+                                    FixedLenSlice(neg_len)\n+                                    | LazyFixedLenSlice { len: neg_len, .. }\n+                                        if neg_len == pos_len =>\n+                                    {\n+                                        smallvec![]\n+                                    }\n                                     VarLenSlice(neg_prefix, neg_suffix)\n                                         if neg_prefix + neg_suffix <= pos_len =>\n                                     {\n@@ -668,7 +681,10 @@ impl<'tcx> Constructor<'tcx> {\n                                 VarLenSlice(pos_prefix, pos_suffix) => {\n                                     let pos_len = pos_prefix + pos_suffix;\n                                     match *neg_ctor {\n-                                        FixedLenSlice(neg_len) if neg_len >= pos_len => {\n+                                        FixedLenSlice(neg_len)\n+                                        | LazyFixedLenSlice { len: neg_len, .. }\n+                                            if neg_len >= pos_len =>\n+                                        {\n                                             (pos_len..neg_len)\n                                                 .map(FixedLenSlice)\n                                                 // We know that `neg_len + 1 >= pos_len >=\n@@ -799,7 +815,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n                 _ => vec![],\n             },\n-            FixedLenSlice(_) | VarLenSlice(..) => match ty.kind {\n+            FixedLenSlice(_) | LazyFixedLenSlice { .. } | VarLenSlice(..) => match ty.kind {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = self.arity(cx, ty);\n                     (0..arity).map(|_| Pat::wildcard_from_ty(ty)).collect()\n@@ -830,7 +846,9 @@ impl<'tcx> Constructor<'tcx> {\n                 _ => 0,\n             },\n             FixedLenSlice(length) => *length,\n-            VarLenSlice(prefix, suffix) => prefix + suffix,\n+            VarLenSlice(prefix, suffix) | LazyFixedLenSlice { prefix, suffix, .. } => {\n+                prefix + suffix\n+            }\n             ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => 0,\n         }\n     }\n@@ -888,8 +906,11 @@ impl<'tcx> Constructor<'tcx> {\n             FixedLenSlice(_) => {\n                 PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n             }\n-            &VarLenSlice(prefix_len, _) => {\n-                let prefix = subpatterns.by_ref().take(prefix_len as usize).collect();\n+            LazyFixedLenSlice { len, prefix, suffix } if prefix + suffix == *len => {\n+                PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n+            }\n+            VarLenSlice(prefix, _) | LazyFixedLenSlice { prefix, .. } => {\n+                let prefix = subpatterns.by_ref().take(*prefix as usize).collect();\n                 let suffix = subpatterns.collect();\n                 let wild = Pat::wildcard_from_ty(ty);\n                 PatKind::Slice { prefix, slice: Some(wild), suffix }\n@@ -1106,7 +1127,11 @@ fn all_constructors<'a, 'tcx>(\n         }\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n-            if len != 0 && cx.is_uninhabited(sub_ty) { vec![] } else { vec![FixedLenSlice(len)] }\n+            if len != 0 && cx.is_uninhabited(sub_ty) {\n+                vec![]\n+            } else {\n+                vec![LazyFixedLenSlice { len, prefix: 0, suffix: 0 }]\n+            }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n         ty::Array(ref sub_ty, _) | ty::Slice(ref sub_ty) => {\n@@ -1694,10 +1719,19 @@ fn pat_constructor<'tcx>(\n                 Some(FloatRange(lo, hi, end))\n             }\n         }\n-        PatKind::Array { .. } => match pat.ty.kind {\n-            ty::Array(_, length) => Some(FixedLenSlice(length.eval_usize(tcx, param_env))),\n-            _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pat.ty),\n-        },\n+        PatKind::Array { ref prefix, ref slice, ref suffix } => {\n+            let len = match pat.ty.kind {\n+                ty::Array(_, length) => length.eval_usize(tcx, param_env),\n+                _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pat.ty),\n+            };\n+            let prefix = prefix.len() as u64;\n+            let suffix = suffix.len() as u64;\n+            if slice.is_some() {\n+                Some(LazyFixedLenSlice { len, prefix, suffix })\n+            } else {\n+                Some(FixedLenSlice(len))\n+            }\n+        }\n         PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n             let prefix = prefix.len() as u64;\n             let suffix = suffix.len() as u64;\n@@ -1833,6 +1867,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n ) -> Vec<Constructor<'tcx>> {\n     let ty = pcx.ty;\n     let mut split_ctors = Vec::with_capacity(ctors.len());\n+    debug!(\"split_grouped_constructors({:#?}, {:#?})\", matrix, ctors);\n \n     for ctor in ctors.into_iter() {\n         match ctor {\n@@ -1920,7 +1955,8 @@ fn split_grouped_constructors<'p, 'tcx>(\n                         .map(IntRange),\n                 );\n             }\n-            VarLenSlice(self_prefix, self_suffix) => {\n+            VarLenSlice(self_prefix, self_suffix)\n+            | LazyFixedLenSlice { prefix: self_prefix, suffix: self_suffix, .. } => {\n                 // The exhaustiveness-checking paper does not include any details on\n                 // checking variable-length slice patterns. However, they are matched\n                 // by an infinite collection of fixed-length array patterns.\n@@ -2005,11 +2041,13 @@ fn split_grouped_constructors<'p, 'tcx>(\n                                 _ => {}\n                             }\n                         }\n-                        PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n+                        PatKind::Slice { ref prefix, slice: None, ref suffix }\n+                        | PatKind::Array { ref prefix, slice: None, ref suffix } => {\n                             let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n                             max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n                         }\n-                        PatKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n+                        PatKind::Slice { ref prefix, slice: Some(_), ref suffix }\n+                        | PatKind::Array { ref prefix, slice: Some(_), ref suffix } => {\n                             max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n                             max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n                         }\n@@ -2027,20 +2065,37 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     max_prefix_len = max_fixed_len + 1 - max_suffix_len;\n                 }\n \n-                // `ctor` originally covered the range `(self_prefix + self_suffix..infinity)`. We\n-                // now split it into two: lengths smaller than `max_prefix_len + max_suffix_len`\n-                // are treated independently as fixed-lengths slices, and lengths above are\n-                // captured by a final VarLenSlice constructor.\n-                split_ctors.extend(\n-                    (self_prefix + self_suffix..max_prefix_len + max_suffix_len).map(FixedLenSlice),\n-                );\n-                split_ctors.push(VarLenSlice(max_prefix_len, max_suffix_len));\n+                match ctor {\n+                    LazyFixedLenSlice { len, .. } => {\n+                        if max_prefix_len + max_suffix_len < len {\n+                            split_ctors.push(LazyFixedLenSlice {\n+                                len,\n+                                prefix: max_prefix_len,\n+                                suffix: max_suffix_len,\n+                            });\n+                        } else {\n+                            split_ctors.push(FixedLenSlice(len));\n+                        }\n+                    }\n+                    _ => {\n+                        // `ctor` originally covered the range `(self_prefix + self_suffix..infinity)`. We\n+                        // now split it into two: lengths smaller than `max_prefix_len + max_suffix_len`\n+                        // are treated independently as fixed-lengths slices, and lengths above are\n+                        // captured by a final VarLenSlice constructor.\n+                        split_ctors.extend(\n+                            (self_prefix + self_suffix..max_prefix_len + max_suffix_len)\n+                                .map(FixedLenSlice),\n+                        );\n+                        split_ctors.push(VarLenSlice(max_prefix_len, max_suffix_len));\n+                    }\n+                }\n             }\n             // Any other constructor can be used unchanged.\n             _ => split_ctors.push(ctor),\n         }\n     }\n \n+    debug!(\"split_grouped_constructors(..)={:#?}\", split_ctors);\n     split_ctors\n }\n \n@@ -2252,7 +2307,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n \n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n-            FixedLenSlice(..) | VarLenSlice(..) => {\n+            FixedLenSlice(..) | LazyFixedLenSlice { .. } | VarLenSlice(..) => {\n                 let pat_len = prefix.len() + suffix.len();\n                 if let Some(slice_count) = ctor_wild_subpatterns.len().checked_sub(pat_len) {\n                     if slice_count == 0 || slice.is_some() {"}, {"sha": "63ed49094fc50547a48d7d252536bb1b2897724f", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d93c1b320c1dc6d38165c70e5f1c13dba895c179/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d93c1b320c1dc6d38165c70e5f1c13dba895c179/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=d93c1b320c1dc6d38165c70e5f1c13dba895c179", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `&[_, _, _, _]` not covered\n+error[E0004]: non-exhaustive patterns: `&[..]` not covered\n   --> $DIR/match-byte-array-patterns-2.rs:4:11\n    |\n LL |     match buf {\n-   |           ^^^ pattern `&[_, _, _, _]` not covered\n+   |           ^^^ pattern `&[..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "5881c35d356b92d27317d6a073548952c75a1b24", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d93c1b320c1dc6d38165c70e5f1c13dba895c179/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d93c1b320c1dc6d38165c70e5f1c13dba895c179/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs?ref=d93c1b320c1dc6d38165c70e5f1c13dba895c179", "patch": "@@ -12,11 +12,11 @@ fn main() {\n         [true, .., true] => {}\n     }\n     match s3 {\n-    //~^ ERROR `&[false, _, _]` not covered\n+    //~^ ERROR `&[false, .., _]` not covered\n         [true, .., true] => {}\n     }\n     match s10 {\n-    //~^ ERROR `&[false, _, _, _, _, _, _, _, _, _]` not covered\n+    //~^ ERROR `&[false, .., _]` not covered\n         [true, .., true] => {}\n     }\n \n@@ -30,7 +30,7 @@ fn main() {\n         [.., false] => {}\n     }\n     match s3 {\n-    //~^ ERROR `&[false, _, true]` not covered\n+    //~^ ERROR `&[false, .., true]` not covered\n         [true, ..] => {}\n         [.., false] => {}\n     }"}, {"sha": "9a711f2a441dcdd5eca0938fc1d7368c9ef75ecb", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d93c1b320c1dc6d38165c70e5f1c13dba895c179/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d93c1b320c1dc6d38165c70e5f1c13dba895c179/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr?ref=d93c1b320c1dc6d38165c70e5f1c13dba895c179", "patch": "@@ -6,19 +6,19 @@ LL |     match s2 {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `&[false, _, _]` not covered\n+error[E0004]: non-exhaustive patterns: `&[false, .., _]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:14:11\n    |\n LL |     match s3 {\n-   |           ^^ pattern `&[false, _, _]` not covered\n+   |           ^^ pattern `&[false, .., _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `&[false, _, _, _, _, _, _, _, _, _]` not covered\n+error[E0004]: non-exhaustive patterns: `&[false, .., _]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:18:11\n    |\n LL |     match s10 {\n-   |           ^^^ pattern `&[false, _, _, _, _, _, _, _, _, _]` not covered\n+   |           ^^^ pattern `&[false, .., _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n@@ -30,11 +30,11 @@ LL |     match s2 {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `&[false, _, true]` not covered\n+error[E0004]: non-exhaustive patterns: `&[false, .., true]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:32:11\n    |\n LL |     match s3 {\n-   |           ^^ pattern `&[false, _, true]` not covered\n+   |           ^^ pattern `&[false, .., true]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}]}