{"sha": "4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiODAzMWNmMmNiNmU3ZWJkNzM4YTY4ZWNkNzk1MDFkZWU3OTFkYTc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-27T15:40:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-27T15:40:45Z"}, "message": "Rollup merge of #62423 - Aaron1011:fix/existential-cycle, r=oli-obk\n\nFix cycle error with existential types\n\nFixes #61863\n\nWe now allow uses of `existential type`'s that aren't defining uses - that is, uses which don't constrain the underlying concrete type.\n\nTo make this work correctly, we also modify `eq_opaque_type_and_type` to not try to apply additional constraints to an opaque type. If we have code like this:\n\n```rust\nexistential type Foo;\nfn foo1() -> Foo { ... }\nfn foo2() -> Foo { foo1() }\n```\n\nthen `foo2` doesn't end up constraining `Foo`, which means that `foo2` will end up using the type `Foo` internally - that is, an actual `TyKind::Opaque`. We don't want to equate this to the underlying concrete type - we just need to enforce the basic equality constraint between the two types (here, the return type of `foo1` and the return type of `foo2`)", "tree": {"sha": "79f1676edc419040604e8eda2653096dc1585b7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79f1676edc419040604e8eda2653096dc1585b7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdPHB9CRBK7hj4Ov3rIwAAdHIIAHuYkOcV2LWEZdDuFaXFbqjE\nuFhc6VnDGTB4nilxPxVtMOlcjDaOXTuLAcg72VAI8PvPLxmrLv/ZjC1dqvbTSsem\nL1Z2gl2zN7l0Myi18TYyNDGitr0YFpK8kfS4LFGtwPnuNFgNnkCk+GfJENEso3YD\nI+EBRa6dgNVrygIQtnhCN/xtLQ59aPGlWqZCRf1bPpHjACSaoKZBIlr+T/NzzmTf\nmXtHLLDwliytezfcO3SDYGT8gaSGlnUlRZJqZ30jx0SYieJz2lUE1nA1vLsfkRMN\n5FFNeUmXfZL7Qvax1rRqhhlhkH84MKmPKqzMN7XZUDuylU2HNqmuMpk//NjyRmw=\n=5MBI\n-----END PGP SIGNATURE-----\n", "payload": "tree 79f1676edc419040604e8eda2653096dc1585b7c\nparent 0e9b465d729d07101b29b4d096d83edf9be82df0\nparent 2f4196205336df8550a4bfb3045d3d1c350f02bf\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564242045 +0200\ncommitter GitHub <noreply@github.com> 1564242045 +0200\n\nRollup merge of #62423 - Aaron1011:fix/existential-cycle, r=oli-obk\n\nFix cycle error with existential types\n\nFixes #61863\n\nWe now allow uses of `existential type`'s that aren't defining uses - that is, uses which don't constrain the underlying concrete type.\n\nTo make this work correctly, we also modify `eq_opaque_type_and_type` to not try to apply additional constraints to an opaque type. If we have code like this:\n\n```rust\nexistential type Foo;\nfn foo1() -> Foo { ... }\nfn foo2() -> Foo { foo1() }\n```\n\nthen `foo2` doesn't end up constraining `Foo`, which means that `foo2` will end up using the type `Foo` internally - that is, an actual `TyKind::Opaque`. We don't want to equate this to the underlying concrete type - we just need to enforce the basic equality constraint between the two types (here, the return type of `foo1` and the return type of `foo2`)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "html_url": "https://github.com/rust-lang/rust/commit/4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e9b465d729d07101b29b4d096d83edf9be82df0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e9b465d729d07101b29b4d096d83edf9be82df0", "html_url": "https://github.com/rust-lang/rust/commit/0e9b465d729d07101b29b4d096d83edf9be82df0"}, {"sha": "2f4196205336df8550a4bfb3045d3d1c350f02bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f4196205336df8550a4bfb3045d3d1c350f02bf", "html_url": "https://github.com/rust-lang/rust/commit/2f4196205336df8550a4bfb3045d3d1c350f02bf"}], "stats": {"total": 258, "additions": 158, "deletions": 100}, "files": [{"sha": "45b806bd286d8286c8d77fd0f2497a0e53b4a373", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "patch": "@@ -1281,15 +1281,43 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let opaque_defn_ty = tcx.type_of(opaque_def_id);\n                         let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n                         let opaque_defn_ty = renumber::renumber_regions(infcx, &opaque_defn_ty);\n+                        let concrete_is_opaque = infcx\n+                            .resolve_vars_if_possible(&opaque_decl.concrete_ty).is_impl_trait();\n+\n                         debug!(\n-                            \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n+                            \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?} \\\n+                            concrete_is_opaque={}\",\n                             opaque_decl.concrete_ty,\n                             infcx.resolve_vars_if_possible(&opaque_decl.concrete_ty),\n-                            opaque_defn_ty\n+                            opaque_defn_ty,\n+                            concrete_is_opaque\n                         );\n-                        obligations.add(infcx\n-                            .at(&ObligationCause::dummy(), param_env)\n-                            .eq(opaque_decl.concrete_ty, opaque_defn_ty)?);\n+\n+                        // concrete_is_opaque is `true` when we're using an existential\n+                        // type without 'revealing' it. For example, code like this:\n+                        //\n+                        // existential type Foo: Debug;\n+                        // fn foo1() -> Foo { ... }\n+                        // fn foo2() -> Foo { foo1() }\n+                        //\n+                        // In `foo2`, we're not revealing the type of `Foo` - we're\n+                        // just treating it as the opaque type.\n+                        //\n+                        // When this occurs, we do *not* want to try to equate\n+                        // the concrete type with the underlying defining type\n+                        // of the existential type - this will always fail, since\n+                        // the defining type of an existential type is always\n+                        // some other type (e.g. not itself)\n+                        // Essentially, none of the normal obligations apply here -\n+                        // we're just passing around some unknown opaque type,\n+                        // without actually looking at the underlying type it\n+                        // gets 'revealed' into\n+\n+                        if !concrete_is_opaque {\n+                            obligations.add(infcx\n+                                .at(&ObligationCause::dummy(), param_env)\n+                                .eq(opaque_decl.concrete_ty, opaque_defn_ty)?);\n+                        }\n                     }\n \n                     debug!(\"eq_opaque_type_and_type: equated\");"}, {"sha": "cfafdd02a6ad9fe962a553a446145012f0e0d0a5", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "patch": "@@ -453,36 +453,43 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n                 def_id, opaque_defn, instantiated_ty, span);\n \n+            let mut skip_add = false;\n+\n             if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.sty {\n                 if def_id == defin_ty_def_id {\n-                    // Concrete type resolved to the existential type itself.\n-                    // Force a cycle error.\n-                    // FIXME(oli-obk): we could just not insert it into `concrete_existential_types`\n-                    // which simply would make this use not a defining use.\n-                    self.tcx().at(span).type_of(defin_ty_def_id);\n+                    debug!(\"Skipping adding concrete definition for opaque type {:?} {:?}\",\n+                           opaque_defn, defin_ty_def_id);\n+                    skip_add = true;\n                 }\n             }\n \n             if !opaque_defn.substs.has_local_value() {\n-                let new = ty::ResolvedOpaqueTy {\n-                    concrete_type: definition_ty,\n-                    substs: opaque_defn.substs,\n-                };\n-\n-                let old = self.tables\n-                    .concrete_existential_types\n-                    .insert(def_id, new);\n-                if let Some(old) = old {\n-                    if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n-                        span_bug!(\n-                            span,\n-                            \"visit_opaque_types tried to write \\\n-                            different types for the same existential type: {:?}, {:?}, {:?}, {:?}\",\n-                            def_id,\n-                            definition_ty,\n-                            opaque_defn,\n-                            old,\n-                        );\n+                // We only want to add an entry into `concrete_existential_types`\n+                // if we actually found a defining usage of this existential type.\n+                // Otherwise, we do nothing - we'll either find a defining usage\n+                // in some other location, or we'll end up emitting an error due\n+                // to the lack of defining usage\n+                if !skip_add {\n+                    let new = ty::ResolvedOpaqueTy {\n+                        concrete_type: definition_ty,\n+                        substs: opaque_defn.substs,\n+                    };\n+\n+                    let old = self.tables\n+                        .concrete_existential_types\n+                        .insert(def_id, new);\n+                    if let Some(old) = old {\n+                        if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n+                            span_bug!(\n+                                span,\n+                                \"visit_opaque_types tried to write different types for the same \\\n+                                existential type: {:?}, {:?}, {:?}, {:?}\",\n+                                def_id,\n+                                definition_ty,\n+                                opaque_defn,\n+                                old,\n+                            );\n+                        }\n                     }\n                 }\n             } else {"}, {"sha": "38fcabb5cc170fc360b8de518de23a80b10b5dba", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.rs?ref=4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "patch": "@@ -1,7 +1,7 @@\n #![feature(existential_type)]\n \n existential type Foo: Fn() -> Foo;\n-//~^ ERROR: cycle detected when processing `Foo`\n+//~^ ERROR: could not find defining uses\n \n fn crash(x: Foo) -> Foo {\n     x"}, {"sha": "98a269d5271a222691209e55992755f9e9990967", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error.stderr", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr?ref=4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "patch": "@@ -1,30 +1,8 @@\n-error[E0391]: cycle detected when processing `Foo`\n+error: could not find defining uses\n   --> $DIR/existential-types-with-cycle-error.rs:3:1\n    |\n LL | existential type Foo: Fn() -> Foo;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires processing `crash`...\n-  --> $DIR/existential-types-with-cycle-error.rs:6:25\n-   |\n-LL |   fn crash(x: Foo) -> Foo {\n-   |  _________________________^\n-LL | |     x\n-LL | | }\n-   | |_^\n-   = note: ...which again requires processing `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/existential-types-with-cycle-error.rs:1:1\n-   |\n-LL | / #![feature(existential_type)]\n-LL | |\n-LL | | existential type Foo: Fn() -> Foo;\n-LL | |\n-...  |\n-LL | |\n-LL | | }\n-   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "f9e6bdb67d4dec6e1a0e94e6ff8b7e6fcb7c6f02", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.rs?ref=4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "patch": "@@ -5,7 +5,7 @@ pub trait Bar<T> {\n }\n \n existential type Foo: Bar<Foo, Item = Foo>;\n-//~^ ERROR: cycle detected when processing `Foo`\n+//~^ ERROR: could not find defining uses\n \n fn crash(x: Foo) -> Foo {\n     x"}, {"sha": "830305d863119bc8d1e085e8b0fa9b1900c0c328", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error2.stderr", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr?ref=4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "patch": "@@ -1,30 +1,8 @@\n-error[E0391]: cycle detected when processing `Foo`\n+error: could not find defining uses\n   --> $DIR/existential-types-with-cycle-error2.rs:7:1\n    |\n LL | existential type Foo: Bar<Foo, Item = Foo>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires processing `crash`...\n-  --> $DIR/existential-types-with-cycle-error2.rs:10:25\n-   |\n-LL |   fn crash(x: Foo) -> Foo {\n-   |  _________________________^\n-LL | |     x\n-LL | | }\n-   | |_^\n-   = note: ...which again requires processing `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/existential-types-with-cycle-error2.rs:1:1\n-   |\n-LL | / #![feature(existential_type)]\n-LL | |\n-LL | | pub trait Bar<T> {\n-LL | |     type Item;\n-...  |\n-LL | |\n-LL | | }\n-   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "646e9a734244e2cd95da86bb9a41a6c4326818ab", "filename": "src/test/ui/existential_types/existential_type_const.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_const.rs?ref=4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+\n+#![feature(existential_type)]\n+// Currently, the `existential_type` feature implicitly\n+// depends on `impl_trait_in_bindings` in order to work properly.\n+// Specifically, this line requires `impl_trait_in_bindings` to be enabled:\n+// https://github.com/rust-lang/rust/blob/481068a707679257e2a738b40987246e0420e787/src/librustc_typeck/check/mod.rs#L856\n+#![feature(impl_trait_in_bindings)]\n+//~^ WARN the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+\n+// Ensures that `const` items can constrain an `existential type`.\n+\n+use std::fmt::Debug;\n+\n+pub existential type Foo: Debug;\n+\n+const _FOO: Foo = 5;\n+\n+fn main() {\n+}"}, {"sha": "049b4f75dd204ff84bc63714a8298fe9f91df7de", "filename": "src/test/ui/existential_types/existential_type_const.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_const.stderr?ref=4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+  --> $DIR/existential_type_const.rs:8:12\n+   |\n+LL | #![feature(impl_trait_in_bindings)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+"}, {"sha": "6f22eef2849855f21a362bc8d136c6e102be0d31", "filename": "src/test/ui/existential_types/existential_type_fns.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_fns.rs?ref=4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+\n+#![feature(existential_type)]\n+\n+// Regression test for issue #61863\n+\n+pub trait MyTrait {}\n+\n+#[derive(Debug)]\n+pub struct MyStruct {\n+  v: u64\n+}\n+\n+impl MyTrait for MyStruct {}\n+\n+pub fn bla() -> TE {\n+    return MyStruct {v:1}\n+}\n+\n+pub fn bla2() -> TE {\n+    bla()\n+}\n+\n+\n+existential type TE: MyTrait;\n+\n+fn main() {}"}, {"sha": "0f134a528979c41a0ac411bacd35797a4f63ae5f", "filename": "src/test/ui/existential_types/existential_type_tuple.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type_tuple.rs?ref=4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "patch": "@@ -0,0 +1,33 @@\n+// check-pass\n+\n+#![feature(existential_type)]\n+#![allow(dead_code)]\n+\n+pub trait MyTrait {}\n+\n+impl MyTrait for bool {}\n+\n+struct Blah {\n+    my_foo: Foo,\n+    my_u8: u8\n+}\n+\n+impl Blah {\n+    fn new() -> Blah {\n+        Blah {\n+            my_foo: make_foo(),\n+            my_u8: 12\n+        }\n+    }\n+    fn into_inner(self) -> (Foo, u8) {\n+        (self.my_foo, self.my_u8)\n+    }\n+}\n+\n+fn make_foo() -> Foo {\n+    true\n+}\n+\n+existential type Foo: MyTrait;\n+\n+fn main() {}"}, {"sha": "eec8a4be63d9808bebca26c107b73c1c52b91489", "filename": "src/test/ui/existential_types/no_inferrable_concrete_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.rs?ref=4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "patch": "@@ -1,9 +1,9 @@\n-// Issue 52985: Cause cycle error if user code provides no use case that allows an existential type\n-// to be inferred to a concrete type. This results in an infinite cycle during type normalization.\n+// Issue 52985: user code provides no use case that allows an existential type\n+// We now emit a 'could not find defining uses' error\n \n #![feature(existential_type)]\n \n-existential type Foo: Copy; //~ cycle detected\n+existential type Foo: Copy; //~ could not find defining uses\n \n // make compiler happy about using 'Foo'\n fn bar(x: Foo) -> Foo { x }"}, {"sha": "bc9a883c8365c7b120531f3b7f504bddc9d35261", "filename": "src/test/ui/existential_types/no_inferrable_concrete_type.stderr", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b8031cf2cb6e7ebd738a68ecd79501dee791da7/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.stderr?ref=4b8031cf2cb6e7ebd738a68ecd79501dee791da7", "patch": "@@ -1,27 +1,8 @@\n-error[E0391]: cycle detected when processing `Foo`\n+error: could not find defining uses\n   --> $DIR/no_inferrable_concrete_type.rs:6:1\n    |\n LL | existential type Foo: Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires processing `bar`...\n-  --> $DIR/no_inferrable_concrete_type.rs:9:23\n-   |\n-LL | fn bar(x: Foo) -> Foo { x }\n-   |                       ^^^^^\n-   = note: ...which again requires processing `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/no_inferrable_concrete_type.rs:4:1\n-   |\n-LL | / #![feature(existential_type)]\n-LL | |\n-LL | | existential type Foo: Copy;\n-LL | |\n-...  |\n-LL | |     let _: Foo = std::mem::transmute(0u8);\n-LL | | }\n-   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0391`."}]}