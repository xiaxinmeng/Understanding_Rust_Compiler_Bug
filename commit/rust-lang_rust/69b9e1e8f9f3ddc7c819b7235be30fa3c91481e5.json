{"sha": "69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5YjllMWU4ZjlmM2RkYzdjODE5YjcyMzViZTMwZmEzYzkxNDgxZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-05T09:40:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-05T09:40:08Z"}, "message": "Auto merge of #51967 - varkor:const-body-break-continue, r=estebank\n\nFix various issues with control-flow statements inside anonymous constants\n\nFixes #51761.\nFixes #51963 (and the host of other reported issues there).\n(Might be easiest to review per commit, as they should be standalone.)\n\nr? @estebank", "tree": {"sha": "e1be5c077505d02a6179977e7dd4cbf8a5af8b1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1be5c077505d02a6179977e7dd4cbf8a5af8b1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "html_url": "https://github.com/rust-lang/rust/commit/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fc21e55766bbcdb0279e6f8a63bdc9859b6e0fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc21e55766bbcdb0279e6f8a63bdc9859b6e0fc", "html_url": "https://github.com/rust-lang/rust/commit/6fc21e55766bbcdb0279e6f8a63bdc9859b6e0fc"}, {"sha": "adf4ef7b98212e1295e7cbc68a7133e67f9af846", "url": "https://api.github.com/repos/rust-lang/rust/commits/adf4ef7b98212e1295e7cbc68a7133e67f9af846", "html_url": "https://github.com/rust-lang/rust/commit/adf4ef7b98212e1295e7cbc68a7133e67f9af846"}], "stats": {"total": 444, "additions": 288, "deletions": 156}, "files": [{"sha": "56df95336072ac6772656100516236eb316ba9f6", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -103,6 +103,7 @@ pub struct LoweringContext<'a> {\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n     is_in_trait_impl: bool,\n+    is_in_anon_const: bool,\n \n     /// What to do when we encounter either an \"anonymous lifetime\n     /// reference\". The term \"anonymous\" is meant to encompass both\n@@ -230,6 +231,7 @@ pub fn lower_crate(\n         node_id_to_hir_id: IndexVec::new(),\n         is_generator: false,\n         is_in_trait_impl: false,\n+        is_in_anon_const: false,\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n         in_scope_lifetimes: Vec::new(),\n@@ -968,31 +970,30 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_loop_destination(&mut self, destination: Option<(NodeId, Label)>) -> hir::Destination {\n-        match destination {\n-            Some((id, label)) => {\n-                let target_id = if let Def::Label(loop_id) = self.expect_full_def(id) {\n-                    Ok(self.lower_node_id(loop_id).node_id)\n-                } else {\n-                    Err(hir::LoopIdError::UnresolvedLabel)\n-                };\n-                hir::Destination {\n-                    label: self.lower_label(Some(label)),\n-                    target_id,\n+        let target_id = if self.is_in_anon_const {\n+            Err(hir::LoopIdError::OutsideLoopScope)\n+        } else {\n+            match destination {\n+                Some((id, _)) => {\n+                    if let Def::Label(loop_id) = self.expect_full_def(id) {\n+                        Ok(self.lower_node_id(loop_id).node_id)\n+                    } else {\n+                        Err(hir::LoopIdError::UnresolvedLabel)\n+                    }\n                 }\n-            }\n-            None => {\n-                let target_id = self.loop_scopes\n-                    .last()\n-                    .map(|innermost_loop_id| *innermost_loop_id)\n-                    .map(|id| Ok(self.lower_node_id(id).node_id))\n-                    .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope))\n-                    .into();\n-\n-                hir::Destination {\n-                    label: None,\n-                    target_id,\n+                None => {\n+                    self.loop_scopes\n+                        .last()\n+                        .map(|innermost_loop_id| *innermost_loop_id)\n+                        .map(|id| Ok(self.lower_node_id(id).node_id))\n+                        .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope))\n+                        .into()\n                 }\n             }\n+        };\n+        hir::Destination {\n+            label: self.lower_label(destination.map(|(_, label)| label)),\n+            target_id,\n         }\n     }\n \n@@ -3447,13 +3448,22 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_anon_const(&mut self, c: &AnonConst) -> hir::AnonConst {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(c.id);\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = false;\n+        let was_in_anon_const = self.is_in_anon_const;\n+        self.is_in_anon_const = true;\n \n-        hir::AnonConst {\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(c.id);\n+        let anon_const = hir::AnonConst {\n             id: node_id,\n             hir_id,\n             body: self.lower_body(None, |this| this.lower_expr(&c.value)),\n-        }\n+        };\n+\n+        self.is_in_anon_const = was_in_anon_const;\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n+        anon_const\n     }\n \n     fn lower_expr(&mut self, e: &Expr) -> hir::Expr {"}, {"sha": "a83aa47fd4f13ff2826715f7a0e46f19ee38488c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -840,6 +840,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n         debug!(\"walk_pat(cmt_discr={:?}, pat={:?})\", cmt_discr, pat);\n \n+        let tcx = self.tcx();\n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.node {\n@@ -849,34 +850,36 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     pat,\n                     match_mode,\n                 );\n-                let bm = *mc.tables.pat_binding_modes().get(pat.hir_id)\n-                                                     .expect(\"missing binding mode\");\n-                debug!(\"walk_pat: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n-\n-                // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(mc.node_ty(pat.hir_id));\n-                debug!(\"walk_pat: pat_ty={:?}\", pat_ty);\n-\n-                // Each match binding is effectively an assignment to the\n-                // binding being produced.\n-                let def = Def::Local(canonical_id);\n-                if let Ok(ref binding_cmt) = mc.cat_def(pat.hir_id, pat.span, pat_ty, def) {\n-                    delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n-                }\n+                if let Some(&bm) = mc.tables.pat_binding_modes().get(pat.hir_id) {\n+                    debug!(\"walk_pat: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n+\n+                    // pat_ty: the type of the binding being produced.\n+                    let pat_ty = return_if_err!(mc.node_ty(pat.hir_id));\n+                    debug!(\"walk_pat: pat_ty={:?}\", pat_ty);\n+\n+                    // Each match binding is effectively an assignment to the\n+                    // binding being produced.\n+                    let def = Def::Local(canonical_id);\n+                    if let Ok(ref binding_cmt) = mc.cat_def(pat.hir_id, pat.span, pat_ty, def) {\n+                        delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n+                    }\n \n-                // It is also a borrow or copy/move of the value being matched.\n-                match bm {\n-                    ty::BindByReference(m) => {\n-                        if let ty::TyRef(r, _, _) = pat_ty.sty {\n-                            let bk = ty::BorrowKind::from_mutbl(m);\n-                            delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n+                    // It is also a borrow or copy/move of the value being matched.\n+                    match bm {\n+                        ty::BindByReference(m) => {\n+                            if let ty::TyRef(r, _, _) = pat_ty.sty {\n+                                let bk = ty::BorrowKind::from_mutbl(m);\n+                                delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n+                            }\n+                        }\n+                        ty::BindByValue(..) => {\n+                            let mode = copy_or_move(mc, param_env, &cmt_pat, PatBindingMove);\n+                            debug!(\"walk_pat binding consuming pat\");\n+                            delegate.consume_pat(pat, &cmt_pat, mode);\n                         }\n                     }\n-                    ty::BindByValue(..) => {\n-                        let mode = copy_or_move(mc, param_env, &cmt_pat, PatBindingMove);\n-                        debug!(\"walk_pat binding consuming pat\");\n-                        delegate.consume_pat(pat, &cmt_pat, mode);\n-                    }\n+                } else {\n+                    tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                 }\n             }\n         }));"}, {"sha": "a32fdbb285d12cdae128c30dcf4a80077589893b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -1115,12 +1115,12 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n                 tcx.layout_raw(param_env.and(normalized))?\n             }\n-            ty::TyParam(_) => {\n-                return Err(LayoutError::Unknown(ty));\n-            }\n-            ty::TyGeneratorWitness(..) | ty::TyInfer(_) | ty::TyError => {\n+            ty::TyGeneratorWitness(..) | ty::TyInfer(_) => {\n                 bug!(\"LayoutDetails::compute: unexpected type `{}`\", ty)\n             }\n+            ty::TyParam(_) | ty::TyError => {\n+                return Err(LayoutError::Unknown(ty));\n+            }\n         })\n     }\n "}, {"sha": "475ff0b744349abfb01cd4ef6f959705fe0f864f", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -54,16 +54,16 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n \n                 // Skip anything that looks like `&foo` or `&mut foo`, only look\n                 // for by-value bindings\n-                let bm = match self.bccx.tables.pat_binding_modes().get(hir_id) {\n-                    Some(&bm) => bm,\n-                    None => span_bug!(span, \"missing binding mode\"),\n-                };\n-                match bm {\n-                    ty::BindByValue(hir::MutMutable) => {}\n-                    _ => return,\n+                if let Some(&bm) = self.bccx.tables.pat_binding_modes().get(hir_id) {\n+                    match bm {\n+                        ty::BindByValue(hir::MutMutable) => {}\n+                        _ => return,\n+                    }\n+\n+                    mutables.entry(ident.name).or_insert(Vec::new()).push((hir_id, span));\n+                } else {\n+                    tcx.sess.delay_span_bug(span, \"missing binding mode\");\n                 }\n-\n-                mutables.entry(ident.name).or_insert(Vec::new()).push((hir_id, span));\n             });\n         }\n "}, {"sha": "8fb5b5c0fa4188e10450d6dfd689beb4722ed2d3", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -541,13 +541,14 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                     decl.debug_name = ident.name;\n \n-                    let bm = *hir.tables.pat_binding_modes()\n-                                        .get(pat.hir_id)\n-                                        .expect(\"missing binding mode\");\n-                    if bm == ty::BindByValue(hir::MutMutable) {\n-                        decl.mutability = Mutability::Mut;\n+                    if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n+                        if bm == ty::BindByValue(hir::MutMutable) {\n+                            decl.mutability = Mutability::Mut;\n+                        } else {\n+                            decl.mutability = Mutability::Not;\n+                        }\n                     } else {\n-                        decl.mutability = Mutability::Not;\n+                        tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                     }\n                 }\n             }"}, {"sha": "502091e5192012872f41b15386ca76ae26ae4eba", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -541,9 +541,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Finds the breakable scope for a given label. This is used for\n     /// resolving `break` and `continue`.\n     pub fn find_breakable_scope(&self,\n-                           span: Span,\n-                           label: region::Scope)\n-                           -> &BreakableScope<'tcx> {\n+                                span: Span,\n+                                label: region::Scope)\n+                                -> &BreakableScope<'tcx> {\n         // find the loop-scope with the correct id\n         self.breakable_scopes.iter()\n             .rev()"}, {"sha": "18ae7c7745915ad4bab2c9cffceee4566089dc64", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -309,33 +309,32 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(_, _, ident, None) = p.node {\n-            let bm = *cx.tables\n-                        .pat_binding_modes()\n-                        .get(p.hir_id)\n-                        .expect(\"missing binding mode\");\n-\n-            if bm != ty::BindByValue(hir::MutImmutable) {\n-                // Nothing to check.\n-                return true;\n-            }\n-            let pat_ty = cx.tables.pat_ty(p);\n-            if let ty::TyAdt(edef, _) = pat_ty.sty {\n-                if edef.is_enum() && edef.variants.iter().any(|variant| {\n-                    variant.name == ident.name && variant.ctor_kind == CtorKind::Const\n-                }) {\n-                    let ty_path = cx.tcx.item_path_str(edef.did);\n-                    let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n-                        \"pattern binding `{}` is named the same as one \\\n-                         of the variants of the type `{}`\",\n-                        ident, ty_path);\n-                    err.span_suggestion_with_applicability(\n-                        p.span,\n-                        \"to match on the variant, qualify the path\",\n-                        format!(\"{}::{}\", ty_path, ident),\n-                        Applicability::MachineApplicable\n-                    );\n-                    err.emit();\n+            if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n+                if bm != ty::BindByValue(hir::MutImmutable) {\n+                    // Nothing to check.\n+                    return true;\n                 }\n+                let pat_ty = cx.tables.pat_ty(p);\n+                if let ty::TyAdt(edef, _) = pat_ty.sty {\n+                    if edef.is_enum() && edef.variants.iter().any(|variant| {\n+                        variant.name == ident.name && variant.ctor_kind == CtorKind::Const\n+                    }) {\n+                        let ty_path = cx.tcx.item_path_str(edef.did);\n+                        let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n+                            \"pattern binding `{}` is named the same as one \\\n+                            of the variants of the type `{}`\",\n+                            ident, ty_path);\n+                        err.span_suggestion_with_applicability(\n+                            p.span,\n+                            \"to match on the variant, qualify the path\",\n+                            format!(\"{}::{}\", ty_path, ident),\n+                            Applicability::MachineApplicable\n+                        );\n+                        err.emit();\n+                    }\n+                }\n+            } else {\n+                cx.tcx.sess.delay_span_bug(p.span, \"missing binding mode\");\n             }\n         }\n         true\n@@ -517,12 +516,12 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     let mut by_ref_span = None;\n     for pat in pats {\n         pat.each_binding(|_, hir_id, span, _path| {\n-            let bm = *cx.tables\n-                        .pat_binding_modes()\n-                        .get(hir_id)\n-                        .expect(\"missing binding mode\");\n-            if let ty::BindByReference(..) = bm {\n-                by_ref_span = Some(span);\n+            if let Some(&bm) = cx.tables.pat_binding_modes().get(hir_id) {\n+                if let ty::BindByReference(..) = bm {\n+                    by_ref_span = Some(span);\n+                }\n+            } else {\n+                cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n             }\n         })\n     }\n@@ -553,18 +552,18 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     for pat in pats {\n         pat.walk(|p| {\n             if let PatKind::Binding(_, _, _, ref sub) = p.node {\n-                let bm = *cx.tables\n-                            .pat_binding_modes()\n-                            .get(p.hir_id)\n-                            .expect(\"missing binding mode\");\n-                match bm {\n-                    ty::BindByValue(..) => {\n-                        let pat_ty = cx.tables.node_id_to_type(p.hir_id);\n-                        if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n-                            check_move(p, sub.as_ref().map(|p| &**p));\n+                if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n+                    match bm {\n+                        ty::BindByValue(..) => {\n+                            let pat_ty = cx.tables.node_id_to_type(p.hir_id);\n+                            if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n+                                check_move(p, sub.as_ref().map(|p| &**p));\n+                            }\n                         }\n+                        _ => {}\n                     }\n-                    _ => {}\n+                } else {\n+                    cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                 }\n             }\n             true"}, {"sha": "636969e263222d81e942aa9ea847babf0a062343", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -743,8 +743,10 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         *self.const_to_pat(instance, val, expr.hir_id, lit.span).kind\n                     },\n-                    Err(()) => {\n-                        self.errors.push(PatternError::FloatBug);\n+                    Err(e) => {\n+                        if e == LitToConstError::UnparseableFloat {\n+                            self.errors.push(PatternError::FloatBug);\n+                        }\n                         PatternKind::Wild\n                     },\n                 }\n@@ -764,8 +766,10 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         *self.const_to_pat(instance, val, expr.hir_id, lit.span).kind\n                     },\n-                    Err(()) => {\n-                        self.errors.push(PatternError::FloatBug);\n+                    Err(e) => {\n+                        if e == LitToConstError::UnparseableFloat {\n+                            self.errors.push(PatternError::FloatBug);\n+                        }\n                         PatternKind::Wild\n                     },\n                 }\n@@ -1118,12 +1122,18 @@ pub fn compare_const_vals<'a, 'tcx>(\n     fallback()\n }\n \n+#[derive(PartialEq)]\n+enum LitToConstError {\n+    UnparseableFloat,\n+    Propagated,\n+}\n+\n // FIXME: Combine with rustc_mir::hair::cx::const_eval_literal\n fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           ty: Ty<'tcx>,\n                           neg: bool)\n-                          -> Result<&'tcx ty::Const<'tcx>, ()> {\n+                          -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n     use syntax::ast::*;\n \n     use rustc::mir::interpret::*;\n@@ -1152,7 +1162,10 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                 ty::TyInt(other) => Int::Signed(other),\n                 ty::TyUint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n                 ty::TyUint(other) => Int::Unsigned(other),\n-                _ => bug!(),\n+                ty::TyError => { // Avoid ICE (#51963)\n+                    return Err(LitToConstError::Propagated);\n+                }\n+                _ => bug!(\"literal integer type with bad type ({:?})\", ty.sty),\n             };\n             // This converts from LitKind::Int (which is sign extended) to\n             // Scalar::Bytes (which is zero extended)\n@@ -1182,14 +1195,14 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             })\n         },\n         LitKind::Float(n, fty) => {\n-            parse_float(n, fty, neg)?\n+            parse_float(n, fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?\n         }\n         LitKind::FloatUnsuffixed(n) => {\n             let fty = match ty.sty {\n                 ty::TyFloat(fty) => fty,\n                 _ => bug!()\n             };\n-            parse_float(n, fty, neg)?\n+            parse_float(n, fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?\n         }\n         LitKind::Bool(b) => ConstValue::Scalar(Scalar::Bits {\n             bits: b as u128,"}, {"sha": "eff0dbe1235ff85d75cd7cb43b7c585ca12efc13", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::{self, Destination};\n use syntax::ast;\n use syntax_pos::Span;\n \n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n enum LoopKind {\n     Loop(hir::LoopSource),\n     WhileLoop,\n@@ -34,12 +34,13 @@ impl LoopKind {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n enum Context {\n     Normal,\n     Loop(LoopKind),\n     Closure,\n     LabeledBlock,\n+    AnonConst,\n }\n \n #[derive(Copy, Clone)]\n@@ -71,6 +72,10 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n         self.with_context(Normal, |v| intravisit::walk_impl_item(v, i));\n     }\n \n+    fn visit_anon_const(&mut self, c: &'hir hir::AnonConst) {\n+        self.with_context(AnonConst, |v| intravisit::walk_anon_const(v, c));\n+    }\n+\n     fn visit_expr(&mut self, e: &'hir hir::Expr) {\n         match e.node {\n             hir::ExprWhile(ref e, ref b, _) => {\n@@ -194,7 +199,7 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n                 .span_label(span, \"cannot break inside of a closure\")\n                 .emit();\n             }\n-            Normal => {\n+            Normal | AnonConst => {\n                 struct_span_err!(self.sess, span, E0268, \"`{}` outside of loop\", name)\n                 .span_label(span, \"cannot break outside of a loop\")\n                 .emit();"}, {"sha": "646c4f17568f05c3aab5e20b309d7ff14c58b7ff", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -3827,7 +3827,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // this can only happen if the `break` was not\n                     // inside a loop at all, which is caught by the\n                     // loop-checking pass.\n-                    assert!(self.tcx.sess.err_count() > 0);\n+                    if self.tcx.sess.err_count() == 0 {\n+                        self.tcx.sess.delay_span_bug(expr.span,\n+                            \"break was outside loop, but no error was emitted\");\n+                    }\n \n                     // We still need to assign a type to the inner expression to\n                     // prevent the ICE in #43162.\n@@ -3960,7 +3963,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // is nil. This makes sense because infinite loops\n                 // (which would have type !) are only possible iff we\n                 // permit break with a value [1].\n-                assert!(ctxt.coerce.is_some() || ctxt.may_break); // [1]\n+                if ctxt.coerce.is_none() && !ctxt.may_break {\n+                    // [1]\n+                    self.tcx.sess.delay_span_bug(body.span, \"no coercion, but loop may not break\");\n+                }\n                 ctxt.coerce.map(|c| c.complete(self)).unwrap_or(self.tcx.mk_nil())\n             }\n             hir::ExprMatch(ref discrim, ref arms, match_src) => {"}, {"sha": "68fcde0b1657aa5ed983e7fb371eec3fd1bb0b49", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -1039,11 +1039,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(..) => {\n-                        let bm = *mc.tables.pat_binding_modes().get(sub_pat.hir_id)\n-                                                               .expect(\"missing binding mode\");\n-                        if let ty::BindByReference(mutbl) = bm {\n-                            self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n-                                                            mutbl, &sub_cmt);\n+                        if let Some(&bm) = mc.tables.pat_binding_modes().get(sub_pat.hir_id) {\n+                            if let ty::BindByReference(mutbl) = bm {\n+                                self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n+                                                                mutbl, &sub_cmt);\n+                            }\n+                        } else {\n+                            self.tcx.sess.delay_span_bug(sub_pat.span, \"missing binding mode\");\n                         }\n                     }\n                     _ => {}"}, {"sha": "2445cae98607ae4a93bd01a65b8892782bcbfb85", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -257,13 +257,11 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n         match p.node {\n             hir::PatKind::Binding(..) => {\n-                let bm = *self.fcx\n-                    .tables\n-                    .borrow()\n-                    .pat_binding_modes()\n-                    .get(p.hir_id)\n-                    .expect(\"missing binding mode\");\n-                self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n+                if let Some(&bm) = self.fcx.tables.borrow().pat_binding_modes().get(p.hir_id) {\n+                    self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n+                } else {\n+                    self.tcx().sess.delay_span_bug(p.span, \"missing binding mode\");\n+                }\n             }\n             hir::PatKind::Struct(_, ref fields, _) => {\n                 for field in fields {"}, {"sha": "c3cfff0e1f642915fa30df8340c4b3e6bfdf3082", "filename": "src/test/ui/array-break-length.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Farray-break-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Farray-break-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-break-length.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    loop {\n+        |_: [_; break]| {} //~ ERROR: `break` outside of loop\n+    }\n+\n+    loop {\n+        |_: [_; continue]| {} //~ ERROR: `continue` outside of loop\n+    }\n+}"}, {"sha": "114245b9cc77b607c1951231ab2b412f9e7e88e6", "filename": "src/test/ui/array-break-length.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Farray-break-length.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Farray-break-length.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-break-length.stderr?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -0,0 +1,15 @@\n+error[E0268]: `break` outside of loop\n+  --> $DIR/array-break-length.rs:13:17\n+   |\n+LL |         |_: [_; break]| {} //~ ERROR: `break` outside of loop\n+   |                 ^^^^^ cannot break outside of a loop\n+\n+error[E0268]: `continue` outside of loop\n+  --> $DIR/array-break-length.rs:17:17\n+   |\n+LL |         |_: [_; continue]| {} //~ ERROR: `continue` outside of loop\n+   |                 ^^^^^^^^ cannot break outside of a loop\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0268`."}, {"sha": "8be5b925a399e35bf86d8f2cd068a581aad72cba", "filename": "src/test/ui/closure-array-break-length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Fclosure-array-break-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Fclosure-array-break-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-array-break-length.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     |_: [_; continue]| {}; //~ ERROR: `continue` outside of loop\n \n-    while |_: [_; continue]| {} {} //~ ERROR: `break` or `continue` with no label\n+    while |_: [_; continue]| {} {} //~ ERROR: `continue` outside of loop\n \n-    while |_: [_; break]| {} {} //~ ERROR: `break` or `continue` with no label\n+    while |_: [_; break]| {} {} //~ ERROR: `break` outside of loop\n }"}, {"sha": "f62b1354370929bbb065ff54b0b4ff99152ce8a0", "filename": "src/test/ui/closure-array-break-length.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Fclosure-array-break-length.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Fclosure-array-break-length.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-array-break-length.stderr?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -4,19 +4,18 @@ error[E0268]: `continue` outside of loop\n LL |     |_: [_; continue]| {}; //~ ERROR: `continue` outside of loop\n    |             ^^^^^^^^ cannot break outside of a loop\n \n-error[E0590]: `break` or `continue` with no label in the condition of a `while` loop\n+error[E0268]: `continue` outside of loop\n   --> $DIR/closure-array-break-length.rs:14:19\n    |\n-LL |     while |_: [_; continue]| {} {} //~ ERROR: `break` or `continue` with no label\n-   |                   ^^^^^^^^ unlabeled `continue` in the condition of a `while` loop\n+LL |     while |_: [_; continue]| {} {} //~ ERROR: `continue` outside of loop\n+   |                   ^^^^^^^^ cannot break outside of a loop\n \n-error[E0590]: `break` or `continue` with no label in the condition of a `while` loop\n+error[E0268]: `break` outside of loop\n   --> $DIR/closure-array-break-length.rs:16:19\n    |\n-LL |     while |_: [_; break]| {} {} //~ ERROR: `break` or `continue` with no label\n-   |                   ^^^^^ unlabeled `break` in the condition of a `while` loop\n+LL |     while |_: [_; break]| {} {} //~ ERROR: `break` outside of loop\n+   |                   ^^^^^ cannot break outside of a loop\n \n error: aborting due to 3 previous errors\n \n-Some errors occurred: E0268, E0590.\n-For more information about an error, try `rustc --explain E0268`.\n+For more information about this error, try `rustc --explain E0268`."}, {"sha": "2b9d51f81b9886d1da007d5cbc987277202e7acd", "filename": "src/test/ui/issue-51714.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Fissue-51714.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Fissue-51714.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-51714.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -9,11 +9,16 @@\n // except according to those terms.\n \n fn main() {\n-    |_:  [_; return || {}] | {}\n+    |_:  [_; return || {}] | {};\n     //~^ ERROR return statement outside of function body\n-}\n \n-fn foo() {\n     [(); return || {}];\n     //~^ ERROR return statement outside of function body\n+\n+    [(); return |ice| {}];\n+    //~^ ERROR return statement outside of function body\n+\n+    [(); return while let Some(n) = Some(0) {}];\n+    //~^ ERROR return statement outside of function body\n+    //~^^ ERROR irrefutable while-let pattern\n }"}, {"sha": "ddc70bfb38e0127244d7ef2c82999722c42a493b", "filename": "src/test/ui/issue-51714.stderr", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Fissue-51714.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Fissue-51714.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-51714.stderr?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -1,15 +1,34 @@\n error[E0572]: return statement outside of function body\n   --> $DIR/issue-51714.rs:12:14\n    |\n-LL |     |_:  [_; return || {}] | {}\n+LL |     |_:  [_; return || {}] | {};\n    |              ^^^^^^^^^^^^\n \n error[E0572]: return statement outside of function body\n-  --> $DIR/issue-51714.rs:17:10\n+  --> $DIR/issue-51714.rs:15:10\n    |\n LL |     [(); return || {}];\n    |          ^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error[E0572]: return statement outside of function body\n+  --> $DIR/issue-51714.rs:18:10\n+   |\n+LL |     [(); return |ice| {}];\n+   |          ^^^^^^^^^^^^^^^\n+\n+error[E0572]: return statement outside of function body\n+  --> $DIR/issue-51714.rs:21:10\n+   |\n+LL |     [(); return while let Some(n) = Some(0) {}];\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0165]: irrefutable while-let pattern\n+  --> $DIR/issue-51714.rs:21:27\n+   |\n+LL |     [(); return while let Some(n) = Some(0) {}];\n+   |                           ^^^^^^^ irrefutable pattern\n+\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0572`.\n+Some errors occurred: E0165, E0572.\n+For more information about an error, try `rustc --explain E0165`."}, {"sha": "45fc571d79d56e8a83ebfc762a3793598932452f", "filename": "src/test/ui/return-match-array-const.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Freturn-match-array-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Freturn-match-array-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn-match-array-const.rs?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    [(); return match 0 { n => n }]; //~ ERROR: return statement outside of function body\n+\n+    [(); return match 0 { 0 => 0 }]; //~ ERROR: return statement outside of function body\n+\n+    [(); return match () { 'a' => 0, _ => 0 }]; //~ ERROR: return statement outside of function body\n+}"}, {"sha": "044dc8f51455f80d50b53e417ca12d4ad6efa525", "filename": "src/test/ui/return-match-array-const.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Freturn-match-array-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5/src%2Ftest%2Fui%2Freturn-match-array-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn-match-array-const.stderr?ref=69b9e1e8f9f3ddc7c819b7235be30fa3c91481e5", "patch": "@@ -0,0 +1,21 @@\n+error[E0572]: return statement outside of function body\n+  --> $DIR/return-match-array-const.rs:12:10\n+   |\n+LL |     [(); return match 0 { n => n }]; //~ ERROR: return statement outside of function body\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0572]: return statement outside of function body\n+  --> $DIR/return-match-array-const.rs:14:10\n+   |\n+LL |     [(); return match 0 { 0 => 0 }]; //~ ERROR: return statement outside of function body\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0572]: return statement outside of function body\n+  --> $DIR/return-match-array-const.rs:16:10\n+   |\n+LL |     [(); return match () { 'a' => 0, _ => 0 }]; //~ ERROR: return statement outside of function body\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0572`."}]}