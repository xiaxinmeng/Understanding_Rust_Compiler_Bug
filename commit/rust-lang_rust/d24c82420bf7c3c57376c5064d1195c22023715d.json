{"sha": "d24c82420bf7c3c57376c5064d1195c22023715d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNGM4MjQyMGJmN2MzYzU3Mzc2YzUwNjRkMTE5NWMyMjAyMzcxNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-11T18:50:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-11T18:50:41Z"}, "message": "auto merge of #17154 : steveklabnik/rust/array_clarification, r=huonw\n\nfixes #17148", "tree": {"sha": "5e34df4c372e4316dd8bd4becb6935299141aeae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e34df4c372e4316dd8bd4becb6935299141aeae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d24c82420bf7c3c57376c5064d1195c22023715d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d24c82420bf7c3c57376c5064d1195c22023715d", "html_url": "https://github.com/rust-lang/rust/commit/d24c82420bf7c3c57376c5064d1195c22023715d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d24c82420bf7c3c57376c5064d1195c22023715d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dc31953e7d1df1560ea43a13d19973a1374730d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc31953e7d1df1560ea43a13d19973a1374730d", "html_url": "https://github.com/rust-lang/rust/commit/1dc31953e7d1df1560ea43a13d19973a1374730d"}, {"sha": "faf14ae63308fc75ee59448f215a38db73dae645", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf14ae63308fc75ee59448f215a38db73dae645", "html_url": "https://github.com/rust-lang/rust/commit/faf14ae63308fc75ee59448f215a38db73dae645"}], "stats": {"total": 41, "additions": 21, "deletions": 20}, "files": [{"sha": "2ef595a06524e99aacb2bf11a3d53b9a9dd46216", "filename": "src/doc/rust.md", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d24c82420bf7c3c57376c5064d1195c22023715d/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d24c82420bf7c3c57376c5064d1195c22023715d/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=d24c82420bf7c3c57376c5064d1195c22023715d", "patch": "@@ -349,7 +349,7 @@ enclosed within two `U+0022` (double-quote) characters,\n with the exception of `U+0022` itself,\n which must be _escaped_ by a preceding `U+005C` character (`\\`),\n or a _raw byte string literal_.\n-It is equivalent to a `&'static [u8]` borrowed vector of unsigned 8-bit integers.\n+It is equivalent to a `&'static [u8]` borrowed array of unsigned 8-bit integers.\n \n Some additional _escapes_ are available in either byte or non-raw byte string\n literals. An escape starts with a `U+005C` (`\\`) and continues with one of\n@@ -2811,16 +2811,17 @@ When the type providing the field inherits mutabilty, it can be [assigned](#assi\n Also, if the type of the expression to the left of the dot is a pointer,\n it is automatically dereferenced to make the field access possible.\n \n-### Vector expressions\n+### Array expressions\n \n ~~~~ {.ebnf .gram}\n-vec_expr : '[' \"mut\" ? vec_elems? ']' ;\n+array_expr : '[' \"mut\" ? vec_elems? ']' ;\n \n-vec_elems : [expr [',' expr]*] | [expr ',' \"..\" expr] ;\n+array_elems : [expr [',' expr]*] | [expr ',' \"..\" expr] ;\n ~~~~\n \n-A [_vector_](#vector-types) _expression_ is written by enclosing zero or\n-more comma-separated expressions of uniform type in square brackets.\n+An [array](#vector,-array,-and-slice-types) _expression_ is written by\n+enclosing zero or more comma-separated expressions of uniform type in square\n+brackets.\n \n In the `[expr ',' \"..\" expr]` form, the expression after the `\"..\"`\n must be a constant expression that can be evaluated at compile time, such\n@@ -2829,7 +2830,7 @@ as a [literal](#literals) or a [static item](#static-items).\n ~~~~\n [1i, 2, 3, 4];\n [\"a\", \"b\", \"c\", \"d\"];\n-[0i, ..128];             // vector with 128 zeros\n+[0i, ..128];             // array with 128 zeros\n [0u8, 0u8, 0u8, 0u8];\n ~~~~\n \n@@ -2839,9 +2840,9 @@ as a [literal](#literals) or a [static item](#static-items).\n idx_expr : expr '[' expr ']' ;\n ~~~~\n \n-[Vector](#vector-types)-typed expressions can be indexed by writing a\n+[Array](#vector,-array,-and-slice-types)-typed expressions can be indexed by writing a\n square-bracket-enclosed expression (the index) after them. When the\n-vector is mutable, the resulting [lvalue](#lvalues,-rvalues-and-temporaries) can be assigned to.\n+array is mutable, the resulting [lvalue](#lvalues,-rvalues-and-temporaries) can be assigned to.\n \n Indices are zero-based, and may be of any integral type. Vector access\n is bounds-checked at run-time. When the check fails, it will put the\n@@ -2902,7 +2903,7 @@ This means that arithmetic operators can be overridden for user-defined types.\n The default meaning of the operators on standard types is given here.\n \n * `+`\n-  : Addition and vector/string concatenation.\n+  : Addition and array/string concatenation.\n     Calls the `add` method on the `std::ops::Add` trait.\n * `-`\n   : Subtraction.\n@@ -3205,7 +3206,7 @@ for_expr : \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n A `for` expression is a syntactic construct for looping over elements\n provided by an implementation of `std::iter::Iterator`.\n \n-An example of a for loop over the contents of a vector:\n+An example of a for loop over the contents of an array:\n \n ~~~~\n # type Foo = int;\n@@ -3263,7 +3264,7 @@ match_pat : pat [ '|' pat ] * [ \"if\" expr ] ? ;\n \n A `match` expression branches on a *pattern*. The exact form of matching that\n occurs depends on the pattern. Patterns consist of some combination of\n-literals, destructured vectors or enum constructors, structures and\n+literals, destructured arrays or enum constructors, structures and\n tuples, variable binding specifications, wildcards (`..`), and placeholders\n (`_`). A `match` expression has a *head expression*, which is the value to\n compare to the patterns. The type of the patterns must equal the type of the\n@@ -3292,11 +3293,11 @@ between `_` and `..` is that the pattern `C(_)` is only type-correct if `C` has\n exactly one argument, while the pattern `C(..)` is type-correct for any enum\n variant `C`, regardless of how many arguments `C` has.\n \n-Used inside a vector pattern, `..` stands for any number of elements, when the\n+Used inside a array pattern, `..` stands for any number of elements, when the\n `advanced_slice_patterns` feature gate is turned on. This wildcard can be used\n-at most once for a given vector, which implies that it cannot be used to\n+at most once for a given array, which implies that it cannot be used to\n specifically match elements that are at an unknown distance from both ends of a\n-vector, like `[.., 42, ..]`.  If followed by a variable name, it will bind the\n+array, like `[.., 42, ..]`.  If followed by a variable name, it will bind the\n corresponding slice to the variable.  Example:\n \n ~~~~\n@@ -3429,7 +3430,7 @@ let message = match x {\n ~~~~\n \n Range patterns only work on scalar types\n-(like integers and characters; not like vectors and structs, which have sub-components).\n+(like integers and characters; not like arrays and structs, which have sub-components).\n A range pattern may not be a sub-range of another range pattern inside the same `match`.\n \n Finally, match patterns can accept *pattern guards* to further refine the\n@@ -3537,10 +3538,10 @@ http://www.unicode.org/glossary/#unicode_scalar_value)\n (ie. a code point that is not a surrogate),\n represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF\n or 0xE000 to 0x10FFFF range.\n-A `[char]` vector is effectively an UCS-4 / UTF-32 string.\n+A `[char]` array is effectively an UCS-4 / UTF-32 string.\n \n A value of type `str` is a Unicode string,\n-represented as a vector of 8-bit unsigned bytes holding a sequence of UTF-8 codepoints.\n+represented as a array of 8-bit unsigned bytes holding a sequence of UTF-8 codepoints.\n Since `str` is of unknown size, it is not a _first class_ type,\n but can only be instantiated through a pointer type,\n such as `&str` or `String`.\n@@ -3651,7 +3652,7 @@ Such recursion has restrictions:\n \n * Recursive types must include a nominal type in the recursion\n   (not mere [type definitions](#type-definitions),\n-   or other structural types such as [vectors](#vector-types) or [tuples](#tuple-types)).\n+   or other structural types such as [arrays](#vector,-array,-and-slice-types) or [tuples](#tuple-types)).\n * A recursive `enum` item must have at least one non-recursive constructor\n   (in order to give the recursion a basis case).\n * The size of a recursive type must be finite;\n@@ -4155,7 +4156,7 @@ heap data.\n ### Built in types\n \n The runtime provides C and Rust code to assist with various built-in types,\n-such as vectors, strings, and the low level communication system (ports,\n+such as arrays, strings, and the low level communication system (ports,\n channels, tasks).\n \n Support for other built-in types such as simple types, tuples and"}]}