{"sha": "df3652b663dbeb19d7353e6e789024951a0589af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMzY1MmI2NjNkYmViMTlkNzM1M2U2ZTc4OTAyNDk1MWEwNTg5YWY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-19T14:25:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-19T14:25:33Z"}, "message": "Merge #6948\n\n6948: Add API for mapping `Attr` back to its syntax node r=jonas-schievink a=jonas-schievink\n\nThis will be useful for emitting diagnostics pertaining to a specific attribute\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "a654c79e11f98970fa8374cf3e8305d401ce684f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a654c79e11f98970fa8374cf3e8305d401ce684f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df3652b663dbeb19d7353e6e789024951a0589af", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf3g1dCRBK7hj4Ov3rIwAAdHIIAGHWfYRNO9YSnFYaGyPrAU1/\nQkdfgCTBqQ4GZ8wwQx5hpZx3oXVyHux3vHLP84AjOBjBn+eifB4i9AK8Oa1rDJ0i\nNtgg/TlxofNcUSqpZC6ixTthfjfhdz5H78gG9ZKlPAJvkYxueN2UaHnrIVeKDA0c\nJ2jK0s0A8ayTI0wFUkjSTPiIuiuOCInREpdACHuH9j+sRLaajWD0/+KoSK4BjaJX\n93Ma3PScYL46xiI3trNGyI+z9XUe9G36bor8ZYYL4TjQPpWC294fELY+kYVQDbxe\nMygASXyVX0+IZJ+t/KLscrg/3NH36eMEnk9YvMCapGyTm3o4WD76bv8XRoX7wmM=\n=vmYM\n-----END PGP SIGNATURE-----\n", "payload": "tree a654c79e11f98970fa8374cf3e8305d401ce684f\nparent e9440f598d7ad3758594d4c5ab44f467395170c5\nparent 218e88ab552086754818e56e488e26d5ad60ea52\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1608387933 +0000\ncommitter GitHub <noreply@github.com> 1608387933 +0000\n\nMerge #6948\n\n6948: Add API for mapping `Attr` back to its syntax node r=jonas-schievink a=jonas-schievink\n\nThis will be useful for emitting diagnostics pertaining to a specific attribute\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df3652b663dbeb19d7353e6e789024951a0589af", "html_url": "https://github.com/rust-lang/rust/commit/df3652b663dbeb19d7353e6e789024951a0589af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df3652b663dbeb19d7353e6e789024951a0589af/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9440f598d7ad3758594d4c5ab44f467395170c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9440f598d7ad3758594d4c5ab44f467395170c5", "html_url": "https://github.com/rust-lang/rust/commit/e9440f598d7ad3758594d4c5ab44f467395170c5"}, {"sha": "218e88ab552086754818e56e488e26d5ad60ea52", "url": "https://api.github.com/repos/rust-lang/rust/commits/218e88ab552086754818e56e488e26d5ad60ea52", "html_url": "https://github.com/rust-lang/rust/commit/218e88ab552086754818e56e488e26d5ad60ea52"}], "stats": {"total": 78, "additions": 55, "deletions": 23}, "files": [{"sha": "042e119b12e35fd5f25757b016817e3b62c36f3e", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/df3652b663dbeb19d7353e6e789024951a0589af/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df3652b663dbeb19d7353e6e789024951a0589af/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=df3652b663dbeb19d7353e6e789024951a0589af", "patch": "@@ -75,32 +75,31 @@ impl RawAttrs {\n     pub(crate) const EMPTY: Self = Self { entries: None };\n \n     pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Self {\n-        let (inner_attrs, inner_docs) = inner_attributes(owner.syntax())\n-            .map_or((None, None), |(attrs, docs)| ((Some(attrs), Some(docs))));\n-\n-        let outer_attrs = owner.attrs().filter(|attr| attr.excl_token().is_none());\n-        let attrs = outer_attrs\n-            .chain(inner_attrs.into_iter().flatten())\n-            .map(|attr| (attr.syntax().text_range().start(), Attr::from_src(attr, hygiene)));\n-\n-        let outer_docs =\n-            ast::CommentIter::from_syntax_node(owner.syntax()).filter(ast::Comment::is_outer);\n-        let docs = outer_docs.chain(inner_docs.into_iter().flatten()).map(|docs_text| {\n-            (\n-                docs_text.syntax().text_range().start(),\n-                docs_text.doc_comment().map(|doc| Attr {\n-                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n-                    path: ModPath::from(hir_expand::name!(doc)),\n-                }),\n-            )\n-        });\n-        // sort here by syntax node offset because the source can have doc attributes and doc strings be interleaved\n-        let attrs: Vec<_> = docs.chain(attrs).sorted_by_key(|&(offset, _)| offset).collect();\n+        let attrs: Vec<_> = collect_attrs(owner).collect();\n         let entries = if attrs.is_empty() {\n             // Avoid heap allocation\n             None\n         } else {\n-            Some(attrs.into_iter().flat_map(|(_, attr)| attr).collect())\n+            Some(\n+                attrs\n+                    .into_iter()\n+                    .enumerate()\n+                    .flat_map(|(i, attr)| match attr {\n+                        Either::Left(attr) => Attr::from_src(attr, hygiene).map(|attr| (i, attr)),\n+                        Either::Right(comment) => comment.doc_comment().map(|doc| {\n+                            (\n+                                i,\n+                                Attr {\n+                                    index: 0,\n+                                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n+                                    path: ModPath::from(hir_expand::name!(doc)),\n+                                },\n+                            )\n+                        }),\n+                    })\n+                    .map(|(i, attr)| Attr { index: i as u32, ..attr })\n+                    .collect(),\n+            )\n         };\n         Self { entries }\n     }\n@@ -316,6 +315,7 @@ fn inner_attributes(\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Attr {\n+    index: u32,\n     pub(crate) path: ModPath,\n     pub(crate) input: Option<AttrInput>,\n }\n@@ -342,7 +342,19 @@ impl Attr {\n         } else {\n             None\n         };\n-        Some(Attr { path, input })\n+        Some(Attr { index: 0, path, input })\n+    }\n+\n+    /// Maps this lowered `Attr` back to its original syntax node.\n+    ///\n+    /// `owner` must be the original owner of the attribute.\n+    ///\n+    /// Note that the returned syntax node might be a `#[cfg_attr]`, or a doc comment, instead of\n+    /// the attribute represented by `Attr`.\n+    pub fn to_src(&self, owner: &dyn AttrsOwner) -> Either<ast::Attr, ast::Comment> {\n+        collect_attrs(owner).nth(self.index as usize).unwrap_or_else(|| {\n+            panic!(\"cannot find `Attr` at index {} in {}\", self.index, owner.syntax())\n+        })\n     }\n \n     /// Parses this attribute as a `#[derive]`, returns an iterator that yields all contained paths\n@@ -432,3 +444,23 @@ fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase\n     let mod_item = N::id_to_mod_item(id.value);\n     tree.raw_attrs(mod_item.into()).clone()\n }\n+\n+fn collect_attrs(owner: &dyn AttrsOwner) -> impl Iterator<Item = Either<ast::Attr, ast::Comment>> {\n+    let (inner_attrs, inner_docs) = inner_attributes(owner.syntax())\n+        .map_or((None, None), |(attrs, docs)| ((Some(attrs), Some(docs))));\n+\n+    let outer_attrs = owner.attrs().filter(|attr| attr.excl_token().is_none());\n+    let attrs = outer_attrs\n+        .chain(inner_attrs.into_iter().flatten())\n+        .map(|attr| (attr.syntax().text_range().start(), Either::Left(attr)));\n+\n+    let outer_docs =\n+        ast::CommentIter::from_syntax_node(owner.syntax()).filter(ast::Comment::is_outer);\n+    let docs = outer_docs\n+        .chain(inner_docs.into_iter().flatten())\n+        .map(|docs_text| (docs_text.syntax().text_range().start(), Either::Right(docs_text)));\n+    // sort here by syntax node offset because the source can have doc attributes and doc strings be interleaved\n+    let attrs: Vec<_> = docs.chain(attrs).sorted_by_key(|&(offset, _)| offset).collect();\n+\n+    attrs.into_iter().map(|(_, attr)| attr)\n+}"}]}