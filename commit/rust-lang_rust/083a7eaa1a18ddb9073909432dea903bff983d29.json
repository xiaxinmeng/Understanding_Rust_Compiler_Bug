{"sha": "083a7eaa1a18ddb9073909432dea903bff983d29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4M2E3ZWFhMWExOGRkYjkwNzM5MDk0MzJkZWE5MDNiZmY5ODNkMjk=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-06-22T05:24:24Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-06-22T05:38:06Z"}, "message": "Add path parameters to std_path", "tree": {"sha": "d131f1b470d0feac7744966c6ad47c7fdc13b9f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d131f1b470d0feac7744966c6ad47c7fdc13b9f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/083a7eaa1a18ddb9073909432dea903bff983d29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/083a7eaa1a18ddb9073909432dea903bff983d29", "html_url": "https://github.com/rust-lang/rust/commit/083a7eaa1a18ddb9073909432dea903bff983d29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/083a7eaa1a18ddb9073909432dea903bff983d29/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d814160d8253adfdb21d5157241851f34003e0e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d814160d8253adfdb21d5157241851f34003e0e1", "html_url": "https://github.com/rust-lang/rust/commit/d814160d8253adfdb21d5157241851f34003e0e1"}], "stats": {"total": 98, "additions": 63, "deletions": 35}, "files": [{"sha": "a849466ababe82da1851a53d4f67d526ce4102db", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/083a7eaa1a18ddb9073909432dea903bff983d29/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a7eaa1a18ddb9073909432dea903bff983d29/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=083a7eaa1a18ddb9073909432dea903bff983d29", "patch": "@@ -168,6 +168,7 @@ pub trait Resolver {\n         span: Span,\n         crate_root: Option<&str>,\n         components: &[&str],\n+        params: Option<P<hir::PathParameters>>\n         is_value: bool,\n     ) -> hir::Path;\n }\n@@ -876,7 +877,7 @@ impl<'a> LoweringContext<'a> {\n \n         let unstable_span = self.allow_internal_unstable(CompilerDesugaringKind::Async, span);\n         let gen_future = self.expr_std_path(\n-            unstable_span, &[\"raw\", \"future_from_generator\"], ThinVec::new());\n+            unstable_span, &[\"raw\", \"future_from_generator\"], None, ThinVec::new());\n         hir::ExprCall(P(gen_future), hir_vec![generator])\n     }\n \n@@ -2115,24 +2116,21 @@ impl<'a> LoweringContext<'a> {\n                 }\n             };\n \n-            let hir::Path { def, segments, .. } = this.std_path(span, &[\"future\", \"Future\"], false);\n-            let future_path = hir::Path {\n-                segments: segments.map_slice(|mut v| {\n-                    v.last_mut().unwrap().parameters = Some(P(hir::PathParameters {\n-                        lifetimes: hir_vec![],\n-                        types: hir_vec![],\n-                        bindings: hir_vec![hir::TypeBinding {\n-                            name: Symbol::intern(FN_OUTPUT_NAME),\n-                            ty: output_ty,\n-                            id: this.next_id().node_id,\n-                            span,\n-                        }],\n-                        parenthesized: false,\n-                    }));\n-                    v\n-                }),\n-                def, span\n-            };\n+            // \"<Output = T>\"\n+            let future_params = P(hir::PathParameters {\n+                lifetimes: hir_vec![],\n+                types: hir_vec![],\n+                bindings: hir_vec![hir::TypeBinding {\n+                    name: Symbol::intern(FN_OUTPUT_NAME),\n+                    ty: output_ty,\n+                    id: this.next_id().node_id,\n+                    span,\n+                }],\n+                parenthesized: false,\n+            });\n+\n+            let let future_path =\n+                this.std_path(span, &[\"future\", \"Future\"], Some(future_params), false);\n \n             // FIXME(cramertj) collect input lifetimes to function and add them to\n             // the output `impl Trait` type here.\n@@ -3665,7 +3663,7 @@ impl<'a> LoweringContext<'a> {\n                 let id = self.next_id();\n                 let e1 = self.lower_expr(e1);\n                 let e2 = self.lower_expr(e2);\n-                let ty_path = P(self.std_path(span, &[\"ops\", \"RangeInclusive\"], false));\n+                let ty_path = P(self.std_path(span, &[\"ops\", \"RangeInclusive\"], None, false));\n                 let ty = self.ty_path(id, span, hir::QPath::Resolved(None, ty_path));\n                 let new_seg = P(hir::PathSegment::from_name(Symbol::intern(\"new\")));\n                 let new_path = hir::QPath::TypeRelative(ty, new_seg);\n@@ -3705,7 +3703,7 @@ impl<'a> LoweringContext<'a> {\n                 let struct_path = iter::once(\"ops\")\n                     .chain(iter::once(path))\n                     .collect::<Vec<_>>();\n-                let struct_path = self.std_path(unstable_span, &struct_path, is_unit);\n+                let struct_path = self.std_path(unstable_span, &struct_path, None, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));\n \n                 let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n@@ -3982,7 +3980,7 @@ impl<'a> LoweringContext<'a> {\n                     let iter = P(self.expr_ident(head_sp, iter, iter_pat.id));\n                     let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n                     let next_path = &[\"iter\", \"Iterator\", \"next\"];\n-                    let next_path = P(self.expr_std_path(head_sp, next_path, ThinVec::new()));\n+                    let next_path = P(self.expr_std_path(head_sp, next_path, None, ThinVec::new()));\n                     let next_expr = P(self.expr_call(head_sp, next_path, hir_vec![ref_mut_iter]));\n                     let arms = hir_vec![pat_arm, break_arm];\n \n@@ -4040,7 +4038,8 @@ impl<'a> LoweringContext<'a> {\n                 // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                 let into_iter_expr = {\n                     let into_iter_path = &[\"iter\", \"IntoIterator\", \"into_iter\"];\n-                    let into_iter = P(self.expr_std_path(head_sp, into_iter_path, ThinVec::new()));\n+                    let into_iter = P(self.expr_std_path(\n+                            head_sp, into_iter_path, None, ThinVec::new()));\n                     P(self.expr_call(head_sp, into_iter, hir_vec![head]))\n                 };\n \n@@ -4086,7 +4085,8 @@ impl<'a> LoweringContext<'a> {\n                     let sub_expr = self.lower_expr(sub_expr);\n \n                     let path = &[\"ops\", \"Try\", \"into_result\"];\n-                    let path = P(self.expr_std_path(unstable_span, path, ThinVec::new()));\n+                    let path = P(self.expr_std_path(\n+                            unstable_span, path, None, ThinVec::new()));\n                     P(self.expr_call(e.span, path, hir_vec![sub_expr]))\n                 };\n \n@@ -4125,7 +4125,8 @@ impl<'a> LoweringContext<'a> {\n                     let err_local = self.pat_ident(e.span, err_ident);\n                     let from_expr = {\n                         let path = &[\"convert\", \"From\", \"from\"];\n-                        let from = P(self.expr_std_path(e.span, path, ThinVec::new()));\n+                        let from = P(self.expr_std_path(\n+                                e.span, path, None, ThinVec::new()));\n                         let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n \n                         self.expr_call(e.span, from, hir_vec![err_expr])\n@@ -4365,9 +4366,10 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         span: Span,\n         components: &[&str],\n+        params: Option<P<hir::PathParameters>>,\n         attrs: ThinVec<Attribute>,\n     ) -> hir::Expr {\n-        let path = self.std_path(span, components, true);\n+        let path = self.std_path(span, components, params, true);\n         self.expr(\n             span,\n             hir::ExprPath(hir::QPath::Resolved(None, P(path))),\n@@ -4492,7 +4494,7 @@ impl<'a> LoweringContext<'a> {\n         components: &[&str],\n         subpats: hir::HirVec<P<hir::Pat>>,\n     ) -> P<hir::Pat> {\n-        let path = self.std_path(span, components, true);\n+        let path = self.std_path(span, components, None, true);\n         let qpath = hir::QPath::Resolved(None, P(path));\n         let pt = if subpats.is_empty() {\n             hir::PatKind::Path(qpath)\n@@ -4539,9 +4541,15 @@ impl<'a> LoweringContext<'a> {\n     /// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n     /// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n     /// The path is also resolved according to `is_value`.\n-    fn std_path(&mut self, span: Span, components: &[&str], is_value: bool) -> hir::Path {\n+    fn std_path(\n+        &mut self,\n+        span: Span,\n+        components: &[&str],\n+        params: Option<P<hir::PathParameters>>,\n+        is_value: bool\n+    ) -> hir::Path {\n         self.resolver\n-            .resolve_str_path(span, self.crate_root, components, is_value)\n+            .resolve_str_path(span, self.crate_root, components, params, is_value)\n     }\n \n     fn ty_path(&mut self, id: LoweredNodeId, span: Span, qpath: hir::QPath) -> P<hir::Ty> {\n@@ -4673,7 +4681,7 @@ impl<'a> LoweringContext<'a> {\n         unstable_span: Span,\n     ) -> P<hir::Expr> {\n         let path = &[\"ops\", \"Try\", method];\n-        let from_err = P(self.expr_std_path(unstable_span, path,\n+        let from_err = P(self.expr_std_path(unstable_span, path, None,\n                                             ThinVec::new()));\n         P(self.expr_call(e.span, from_err, hir_vec![e]))\n     }"}, {"sha": "822439752b5dd5185d6c7cee2ab409cf1013268e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/083a7eaa1a18ddb9073909432dea903bff983d29/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083a7eaa1a18ddb9073909432dea903bff983d29/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=083a7eaa1a18ddb9073909432dea903bff983d29", "patch": "@@ -1489,14 +1489,34 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n                                  |resolver, span, error| resolve_error(resolver, span, error))\n     }\n \n-    fn resolve_str_path(&mut self, span: Span, crate_root: Option<&str>,\n-                        components: &[&str], is_value: bool) -> hir::Path {\n+    fn resolve_str_path(\n+        &mut self,\n+        span: Span,\n+        crate_root: Option<&str>,\n+        components: &[&str],\n+        params: Option<hir::PathParameters>,\n+        is_value: bool\n+    ) -> hir::Path {\n+        let mut segments = iter::once(keywords::CrateRoot.name())\n+            .chain(\n+                crate_root.into_iter()\n+                    .chain(components.iter().cloned())\n+                    .map(Symbol::intern)\n+            ).map(hir::PathSegment::from_name).collect::<Vec<_>>();\n+\n+        if let Some(parameters) = params {\n+            let last_name = segments.last().unwrap().name;\n+            *segments.last_mut().unwrap() = hir::PathSegment {\n+                name,\n+                parameters,\n+                infer_types: true,\n+            };\n+        }\n+\n         let mut path = hir::Path {\n             span,\n             def: Def::Err,\n-            segments: iter::once(keywords::CrateRoot.name()).chain({\n-                crate_root.into_iter().chain(components.iter().cloned()).map(Symbol::intern)\n-            }).map(hir::PathSegment::from_name).collect(),\n+            segments: segments.into(),\n         };\n \n         self.resolve_hir_path(&mut path, is_value);"}]}