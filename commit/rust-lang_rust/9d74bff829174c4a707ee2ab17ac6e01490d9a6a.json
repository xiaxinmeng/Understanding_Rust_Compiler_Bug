{"sha": "9d74bff829174c4a707ee2ab17ac6e01490d9a6a", "node_id": "C_kwDOAAsO6NoAKDlkNzRiZmY4MjkxNzRjNGE3MDdlZTJhYjE3YWM2ZTAxNDkwZDlhNmE", "commit": {"author": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2023-03-03T03:25:52Z"}, "committer": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2023-03-03T11:10:25Z"}, "message": "smarter algorithm for finding an equal region\n\nSmarter and simpler!", "tree": {"sha": "f85af9a80e86e72987b53df08e71a6daeee617af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f85af9a80e86e72987b53df08e71a6daeee617af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d74bff829174c4a707ee2ab17ac6e01490d9a6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d74bff829174c4a707ee2ab17ac6e01490d9a6a", "html_url": "https://github.com/rust-lang/rust/commit/9d74bff829174c4a707ee2ab17ac6e01490d9a6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d74bff829174c4a707ee2ab17ac6e01490d9a6a/comments", "author": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09524bfd5ace53bfecddd669a5d90e5495eaa3de", "url": "https://api.github.com/repos/rust-lang/rust/commits/09524bfd5ace53bfecddd669a5d90e5495eaa3de", "html_url": "https://github.com/rust-lang/rust/commit/09524bfd5ace53bfecddd669a5d90e5495eaa3de"}], "stats": {"total": 117, "additions": 11, "deletions": 106}, "files": [{"sha": "e526ccd71ca9e7152ac2fb5e84fb87e5b8089b8e", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 9, "deletions": 67, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9d74bff829174c4a707ee2ab17ac6e01490d9a6a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d74bff829174c4a707ee2ab17ac6e01490d9a6a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=9d74bff829174c4a707ee2ab17ac6e01490d9a6a", "patch": "@@ -1098,51 +1098,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let tcx = infcx.tcx;\n \n         let ty = tcx.fold_regions(ty, |r, _depth| {\n-            let region_vid = self.to_region_vid(r);\n+            let r_vid = self.to_region_vid(r);\n+            let r_scc = self.constraint_sccs.scc(r_vid);\n \n             // The challenge if this. We have some region variable `r`\n             // whose value is a set of CFG points and universal\n             // regions. We want to find if that set is *equivalent* to\n             // any of the named regions found in the closure.\n-            //\n-            // To do so, we compute the\n-            // `non_local_universal_upper_bound`. This will be a\n-            // non-local, universal region that is greater than `r`.\n-            // However, it might not be *contained* within `r`, so\n-            // then we further check whether this bound is contained\n-            // in `r`. If so, we can say that `r` is equivalent to the\n-            // bound.\n-            //\n-            // Let's work through a few examples. For these, imagine\n-            // that we have 3 non-local regions (I'll denote them as\n-            // `'static`, `'a`, and `'b`, though of course in the code\n-            // they would be represented with indices) where:\n-            //\n-            // - `'static: 'a`\n-            // - `'static: 'b`\n-            //\n-            // First, let's assume that `r` is some existential\n-            // variable with an inferred value `{'a, 'static}` (plus\n-            // some CFG nodes). In this case, the non-local upper\n-            // bound is `'static`, since that outlives `'a`. `'static`\n-            // is also a member of `r` and hence we consider `r`\n-            // equivalent to `'static` (and replace it with\n-            // `'static`).\n-            //\n-            // Now let's consider the inferred value `{'a, 'b}`. This\n-            // means `r` is effectively `'a | 'b`. I'm not sure if\n-            // this can come about, actually, but assuming it did, we\n-            // would get a non-local upper bound of `'static`. Since\n-            // `'static` is not contained in `r`, we would fail to\n-            // find an equivalent.\n-            let upper_bound = self.non_local_universal_upper_bound(region_vid);\n-            if self.region_contains(region_vid, upper_bound) {\n-                tcx.mk_re_var(upper_bound)\n-            } else {\n+            // To do so, we simply check every candidate `u_r` for equality.\n+            self.scc_values\n+                .universal_regions_outlived_by(r_scc)\n+                .filter(|&u_r| !self.universal_regions.is_local_free_region(u_r))\n+                .find(|&u_r| self.eval_equal(u_r, r_vid))\n+                .map(|u_r| tcx.mk_re_var(u_r))\n                 // In the case of a failure, use `ReErased`. We will eventually\n                 // return `None` in this case.\n-                tcx.lifetimes.re_erased\n-            }\n+                .unwrap_or(tcx.lifetimes.re_erased)\n         });\n \n         debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n@@ -1155,35 +1126,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         Some(ClosureOutlivesSubject::Ty(ClosureOutlivesSubjectTy::new(tcx, ty)))\n     }\n \n-    /// Given some universal or existential region `r`, finds a\n-    /// non-local, universal region `r+` that outlives `r` at entry to (and\n-    /// exit from) the closure. In the worst case, this will be\n-    /// `'static`.\n-    ///\n-    /// This is used for two purposes. First, if we are propagated\n-    /// some requirement `T: r`, we can use this method to enlarge `r`\n-    /// to something we can encode for our creator (which only knows\n-    /// about non-local, universal regions). It is also used when\n-    /// encoding `T` as part of `try_promote_type_test_subject` (see\n-    /// that fn for details).\n-    ///\n-    /// This is based on the result `'y` of `universal_upper_bound`,\n-    /// except that it converts further takes the non-local upper\n-    /// bound of `'y`, so that the final result is non-local.\n-    fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\"non_local_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n-\n-        let lub = self.universal_upper_bound(r);\n-\n-        // Grow further to get smallest universal region known to\n-        // creator.\n-        let non_local_lub = self.universal_region_relations.non_local_upper_bound(lub);\n-\n-        debug!(\"non_local_universal_upper_bound: non_local_lub={:?}\", non_local_lub);\n-\n-        non_local_lub\n-    }\n-\n     /// Returns a universally quantified region that outlives the\n     /// value of `r` (`r` may be existentially or universally\n     /// quantified)."}, {"sha": "4004966c40a77bc9d561432427b0b25ab7fe5eed", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9d74bff829174c4a707ee2ab17ac6e01490d9a6a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d74bff829174c4a707ee2ab17ac6e01490d9a6a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=9d74bff829174c4a707ee2ab17ac6e01490d9a6a", "patch": "@@ -93,31 +93,6 @@ impl UniversalRegionRelations<'_> {\n         res\n     }\n \n-    /// Returns the \"postdominating\" bound of the set of\n-    /// `non_local_upper_bounds` for the given region.\n-    pub(crate) fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n-        let upper_bounds = self.non_local_upper_bounds(fr);\n-\n-        // In case we find more than one, reduce to one for\n-        // convenience. This is to prevent us from generating more\n-        // complex constraints, but it will cause spurious errors.\n-        let post_dom = self.inverse_outlives.mutual_immediate_postdominator(upper_bounds);\n-\n-        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n-\n-        post_dom\n-            .and_then(|post_dom| {\n-                // If the mutual immediate postdom is not local, then\n-                // there is no non-local result we can return.\n-                if !self.universal_regions.is_local_free_region(post_dom) {\n-                    Some(post_dom)\n-                } else {\n-                    None\n-                }\n-            })\n-            .unwrap_or(self.universal_regions.fr_static)\n-    }\n-\n     /// Finds a \"lower bound\" for `fr` that is not local. In other\n     /// words, returns the largest (*) known region `fr1` that (a) is\n     /// outlived by `fr` and (b) is not local."}, {"sha": "d8772e86894dffac4b06347d40b88f828c0c021b", "filename": "tests/ui/nll/closure-requirements/type-test-subject-non-trivial-region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d74bff829174c4a707ee2ab17ac6e01490d9a6a/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-non-trivial-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d74bff829174c4a707ee2ab17ac6e01490d9a6a/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-non-trivial-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-non-trivial-region.rs?ref=9d74bff829174c4a707ee2ab17ac6e01490d9a6a", "patch": "@@ -1,5 +1,5 @@\n-// chek-fail\n-// known-bug: #108639\n+// See #108639 for description.\n+// check-pass\n \n trait Trait {\n     type Item<'a>: 'a;"}, {"sha": "83f0b64d5a7373773fc397c433d66aec85922184", "filename": "tests/ui/nll/closure-requirements/type-test-subject-non-trivial-region.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09524bfd5ace53bfecddd669a5d90e5495eaa3de/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-non-trivial-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09524bfd5ace53bfecddd669a5d90e5495eaa3de/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-non-trivial-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fclosure-requirements%2Ftype-test-subject-non-trivial-region.stderr?ref=09524bfd5ace53bfecddd669a5d90e5495eaa3de", "patch": "@@ -1,12 +0,0 @@\n-error[E0310]: the associated type `<I as Trait>::Item<'_>` may not live long enough\n-  --> $DIR/type-test-subject-non-trivial-region.rs:14:9\n-   |\n-LL |         assert_static(a);\n-   |         ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `<I as Trait>::Item<'_>: 'static`...\n-   = note: ...so that the type `<I as Trait>::Item<'_>` will meet its required lifetime bounds\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0310`."}]}