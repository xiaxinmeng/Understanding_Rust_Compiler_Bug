{"sha": "e92d740b3586de0d0b476257b3539847f2db21e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MmQ3NDBiMzU4NmRlMGQwYjQ3NjI1N2IzNTM5ODQ3ZjJkYjIxZTM=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-02-08T10:52:14Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-03-28T22:30:43Z"}, "message": "BTreeMap testing: introduce symbolic constants and refer to height consistently.", "tree": {"sha": "fc5eb43938da88de73eca8d08ae16b34393cd0ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc5eb43938da88de73eca8d08ae16b34393cd0ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e92d740b3586de0d0b476257b3539847f2db21e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e92d740b3586de0d0b476257b3539847f2db21e3", "html_url": "https://github.com/rust-lang/rust/commit/e92d740b3586de0d0b476257b3539847f2db21e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e92d740b3586de0d0b476257b3539847f2db21e3/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c52cee172fcd2e223100d8bdd5e105dc37aaca23", "url": "https://api.github.com/repos/rust-lang/rust/commits/c52cee172fcd2e223100d8bdd5e105dc37aaca23", "html_url": "https://github.com/rust-lang/rust/commit/c52cee172fcd2e223100d8bdd5e105dc37aaca23"}], "stats": {"total": 90, "additions": 49, "deletions": 41}, "files": [{"sha": "535b6a9c31451c9fd69f22ff4ec82e5f0bac4ed6", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e92d740b3586de0d0b476257b3539847f2db21e3/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e92d740b3586de0d0b476257b3539847f2db21e3/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=e92d740b3586de0d0b476257b3539847f2db21e3", "patch": "@@ -7,17 +7,31 @@ use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n use std::panic::catch_unwind;\n use std::rc::Rc;\n-use std::sync::atomic::{AtomicU32, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n use super::DeterministicRng;\n \n+// Value of node::CAPACITY, thus capacity of a tree with a single level,\n+// i.e. a tree who's root is a leaf node at height 0.\n+const NODE_CAPACITY: usize = 11;\n+\n+// Minimum number of elements to insert in order to guarantee a tree with 2 levels,\n+// i.e. a tree who's root is an internal node at height 1, with edges to leaf nodes.\n+// It's not the minimum size: removing an element from such a tree does not always reduce height.\n+const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n+\n+// Minimum number of elements to insert in order to guarantee a tree with 3 levels,\n+// i.e. a tree who's root is an internal node at height 2, with edges to more internal nodes.\n+// It's not the minimum size: removing an element from such a tree does not always reduce height.\n+const MIN_INSERTS_HEIGHT_2: usize = NODE_CAPACITY + (NODE_CAPACITY + 1) * NODE_CAPACITY + 1;\n+\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n     #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n     #[cfg(miri)]\n-    let size = 144; // to obtain height 3 tree (having edges to both kinds of nodes)\n+    let size = MIN_INSERTS_HEIGHT_2;\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -237,30 +251,26 @@ impl TryFrom<usize> for Align32 {\n \n #[test]\n fn test_iter_mut_mutation() {\n-    // Check many alignments because various fields precede array in NodeHeader.\n-    // Check with size 0 which should not iterate at all.\n-    // Check with size 1 for a tree with one kind of node (root = leaf).\n-    // Check with size 12 for a tree with two kinds of nodes (root and leaves).\n-    // Check with size 144 for a tree with all kinds of nodes (root, internals and leaves).\n+    // Check many alignments and trees with roots at various heights.\n     do_test_iter_mut_mutation::<u8>(0);\n     do_test_iter_mut_mutation::<u8>(1);\n-    do_test_iter_mut_mutation::<u8>(12);\n-    do_test_iter_mut_mutation::<u8>(127); // not enough unique values to test 144\n+    do_test_iter_mut_mutation::<u8>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u8>(127); // not enough unique values to test MIN_INSERTS_HEIGHT_2\n     do_test_iter_mut_mutation::<u16>(1);\n-    do_test_iter_mut_mutation::<u16>(12);\n-    do_test_iter_mut_mutation::<u16>(144);\n+    do_test_iter_mut_mutation::<u16>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u16>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u32>(1);\n-    do_test_iter_mut_mutation::<u32>(12);\n-    do_test_iter_mut_mutation::<u32>(144);\n+    do_test_iter_mut_mutation::<u32>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u32>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u64>(1);\n-    do_test_iter_mut_mutation::<u64>(12);\n-    do_test_iter_mut_mutation::<u64>(144);\n+    do_test_iter_mut_mutation::<u64>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u64>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u128>(1);\n-    do_test_iter_mut_mutation::<u128>(12);\n-    do_test_iter_mut_mutation::<u128>(144);\n+    do_test_iter_mut_mutation::<u128>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u128>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<Align32>(1);\n-    do_test_iter_mut_mutation::<Align32>(12);\n-    do_test_iter_mut_mutation::<Align32>(144);\n+    do_test_iter_mut_mutation::<Align32>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<Align32>(MIN_INSERTS_HEIGHT_2);\n }\n \n #[test]\n@@ -376,12 +386,11 @@ fn test_range_small() {\n }\n \n #[test]\n-fn test_range_height_2() {\n-    // Assuming that node.CAPACITY is 11, having 12 pairs implies a height 2 tree\n-    // with 2 leaves. Depending on details we don't want or need to rely upon,\n-    // the single key at the root will be 6 or 7.\n+fn test_range_height_1() {\n+    // Tests tree with a root and 2 leaves. Depending on details we don't want or need\n+    // to rely upon, the single key at the root will be 6 or 7.\n \n-    let map: BTreeMap<_, _> = (1..=12).map(|i| (i, i)).collect();\n+    let map: BTreeMap<_, _> = (1..=MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)).collect();\n     for &root in &[6, 7] {\n         assert_eq!(range_keys(&map, (Excluded(root), Excluded(root + 1))), vec![]);\n         assert_eq!(range_keys(&map, (Excluded(root), Included(root + 1))), vec![root + 1]);\n@@ -519,7 +528,7 @@ fn test_range_1000() {\n     #[cfg(not(miri))] // Miri is too slow\n     let size = 1000;\n     #[cfg(miri)]\n-    let size = 144; // to obtain height 3 tree (having edges to both kinds of nodes)\n+    let size = MIN_INSERTS_HEIGHT_2;\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n@@ -755,7 +764,7 @@ fn test_bad_zst() {\n #[test]\n fn test_clone() {\n     let mut map = BTreeMap::new();\n-    let size = 12; // to obtain height 2 tree (having edges to leaf nodes)\n+    let size = MIN_INSERTS_HEIGHT_1;\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -783,20 +792,19 @@ fn test_clone() {\n         assert_eq!(map, map.clone());\n     }\n \n-    // Full 2-level and minimal 3-level tree (sizes 143, 144 -- the only ones we clone for).\n-    for i in 1..=144 {\n-        assert_eq!(map.insert(i, i), None);\n-        assert_eq!(map.len(), i);\n-        if i >= 143 {\n-            assert_eq!(map, map.clone());\n-        }\n-    }\n+    // Test a tree with 2 chock-full levels and a tree with 3 levels.\n+    map = (1..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n+    assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+    assert_eq!(map, map.clone());\n+    map.insert(0, 0);\n+    assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2);\n+    assert_eq!(map, map.clone());\n }\n \n #[test]\n fn test_clone_from() {\n     let mut map1 = BTreeMap::new();\n-    let max_size = 12; // to obtain height 2 tree (having edges to leaf nodes)\n+    let max_size = MIN_INSERTS_HEIGHT_1;\n \n     // Range to max_size inclusive, because i is the size of map1 being tested.\n     for i in 0..=max_size {\n@@ -1014,8 +1022,8 @@ fn test_split_off_large_random_sorted() {\n }\n \n #[test]\n-fn test_into_iter_drop_leak_1() {\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n+fn test_into_iter_drop_leak_height_0() {\n+    static DROPS: AtomicUsize = AtomicUsize::new(0);\n \n     struct D;\n \n@@ -1040,10 +1048,10 @@ fn test_into_iter_drop_leak_1() {\n }\n \n #[test]\n-fn test_into_iter_drop_leak_2() {\n-    let size = 12; // to obtain tree with 2 levels (having edges to leaf nodes)\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n-    static PANIC_POINT: AtomicU32 = AtomicU32::new(0);\n+fn test_into_iter_drop_leak_height_1() {\n+    let size = MIN_INSERTS_HEIGHT_1;\n+    static DROPS: AtomicUsize = AtomicUsize::new(0);\n+    static PANIC_POINT: AtomicUsize = AtomicUsize::new(0);\n \n     struct D;\n     impl Drop for D {"}]}