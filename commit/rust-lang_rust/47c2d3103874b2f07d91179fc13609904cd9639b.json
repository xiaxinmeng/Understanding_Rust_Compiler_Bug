{"sha": "47c2d3103874b2f07d91179fc13609904cd9639b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YzJkMzEwMzg3NGIyZjA3ZDkxMTc5ZmMxMzYwOTkwNGNkOTYzOWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-12T15:19:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-28T10:15:24Z"}, "message": "Extract expectations from the projection obligation, which includes\nall relevant information.", "tree": {"sha": "fa61a2da7a4a5e5bf5bfb5bec661d57ba99919d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa61a2da7a4a5e5bf5bfb5bec661d57ba99919d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47c2d3103874b2f07d91179fc13609904cd9639b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47c2d3103874b2f07d91179fc13609904cd9639b", "html_url": "https://github.com/rust-lang/rust/commit/47c2d3103874b2f07d91179fc13609904cd9639b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47c2d3103874b2f07d91179fc13609904cd9639b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25a27977fa1cbaddd4c2275881bee358eeaeb8a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/25a27977fa1cbaddd4c2275881bee358eeaeb8a1", "html_url": "https://github.com/rust-lang/rust/commit/25a27977fa1cbaddd4c2275881bee358eeaeb8a1"}], "stats": {"total": 88, "additions": 49, "deletions": 39}, "files": [{"sha": "bdae34e7878504e5709d59f1288cbef36455b131", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/47c2d3103874b2f07d91179fc13609904cd9639b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c2d3103874b2f07d91179fc13609904cd9639b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=47c2d3103874b2f07d91179fc13609904cd9639b", "patch": "@@ -34,7 +34,7 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n            expected.repr(fcx.tcx()));\n \n     let expected_sig_and_kind = expected.to_option(fcx).and_then(|ty| {\n-        deduce_closure_expectations_from_expected_type(fcx, ty)\n+        deduce_expectations_from_expected_type(fcx, ty)\n     });\n \n     match opt_kind {\n@@ -137,36 +137,73 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     fcx.inh.closures.borrow_mut().insert(expr_def_id, closure);\n }\n \n-fn deduce_closure_expectations_from_expected_type<'a,'tcx>(\n+fn deduce_expectations_from_expected_type<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     expected_ty: Ty<'tcx>)\n     -> Option<(ty::FnSig<'tcx>,ty::ClosureKind)>\n {\n     match expected_ty.sty {\n         ty::ty_trait(ref object_type) => {\n-            let trait_ref =\n-                object_type.principal_trait_ref_with_self_ty(fcx.tcx(),\n-                                                             fcx.tcx().types.err);\n-            deduce_closure_expectations_from_trait_ref(fcx, &trait_ref)\n+            let proj_bounds = object_type.projection_bounds_with_self_ty(fcx.tcx(),\n+                                                                         fcx.tcx().types.err);\n+            proj_bounds.iter()\n+                       .filter_map(|pb| deduce_expectations_from_projection(fcx, pb))\n+                       .next()\n         }\n         ty::ty_infer(ty::TyVar(vid)) => {\n-            deduce_closure_expectations_from_obligations(fcx, vid)\n+            deduce_expectations_from_obligations(fcx, vid)\n         }\n         _ => {\n             None\n         }\n     }\n }\n \n-fn deduce_closure_expectations_from_trait_ref<'a,'tcx>(\n+fn deduce_expectations_from_obligations<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n-    trait_ref: &ty::PolyTraitRef<'tcx>)\n+    expected_vid: ty::TyVid)\n+    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n+{\n+    let fulfillment_cx = fcx.inh.fulfillment_cx.borrow();\n+    // Here `expected_ty` is known to be a type inference variable.\n+\n+    fulfillment_cx.pending_obligations()\n+                  .iter()\n+                  .filter_map(|obligation| {\n+                      match obligation.predicate {\n+                          ty::Predicate::Projection(ref proj_predicate) => {\n+                              let trait_ref = proj_predicate.to_poly_trait_ref();\n+                              let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n+                              match self_ty.sty {\n+                                  ty::ty_infer(ty::TyVar(v)) if expected_vid == v => {\n+                                      deduce_expectations_from_projection(fcx, proj_predicate)\n+                                  }\n+                                  _ => {\n+                                      None\n+                                  }\n+                              }\n+                          }\n+                          _ => {\n+                              None\n+                          }\n+                      }\n+                  })\n+                  .next()\n+}\n+\n+/// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n+/// everything we need to know about a closure.\n+fn deduce_expectations_from_projection<'a,'tcx>(\n+    fcx: &FnCtxt<'a,'tcx>,\n+    projection: &ty::PolyProjectionPredicate<'tcx>)\n     -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n {\n     let tcx = fcx.tcx();\n \n-    debug!(\"deduce_closure_expectations_from_object_type({})\",\n-           trait_ref.repr(tcx));\n+    debug!(\"deduce_expectations_from_projection({})\",\n+           projection.repr(tcx));\n+\n+    let trait_ref = projection.to_poly_trait_ref();\n \n     let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id()) {\n         Some(k) => k,\n@@ -185,7 +222,7 @@ fn deduce_closure_expectations_from_trait_ref<'a,'tcx>(\n     };\n     debug!(\"input_tys {}\", input_tys.repr(tcx));\n \n-    let ret_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 1);\n+    let ret_param_ty = projection.0.ty;\n     let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n     debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n \n@@ -199,30 +236,3 @@ fn deduce_closure_expectations_from_trait_ref<'a,'tcx>(\n     return Some((fn_sig, kind));\n }\n \n-fn deduce_closure_expectations_from_obligations<'a,'tcx>(\n-    fcx: &FnCtxt<'a,'tcx>,\n-    expected_vid: ty::TyVid)\n-    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n-{\n-    // Here `expected_ty` is known to be a type inference variable.\n-    for obligation in fcx.inh.fulfillment_cx.borrow().pending_obligations().iter() {\n-        match obligation.predicate {\n-            ty::Predicate::Trait(ref trait_predicate) => {\n-                let trait_ref = trait_predicate.to_poly_trait_ref();\n-                let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n-                match self_ty.sty {\n-                    ty::ty_infer(ty::TyVar(v)) if expected_vid == v => { }\n-                    _ => { continue; }\n-                }\n-\n-                match deduce_closure_expectations_from_trait_ref(fcx, &trait_ref) {\n-                    Some(e) => { return Some(e); }\n-                    None => { }\n-                }\n-            }\n-            _ => { }\n-        }\n-    }\n-\n-    None\n-}"}]}