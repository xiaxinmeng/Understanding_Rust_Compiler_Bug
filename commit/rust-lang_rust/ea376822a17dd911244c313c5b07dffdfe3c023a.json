{"sha": "ea376822a17dd911244c313c5b07dffdfe3c023a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMzc2ODIyYTE3ZGQ5MTEyNDRjMzEzYzViMDdkZmZkZmUzYzAyM2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-13T17:32:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-13T17:32:22Z"}, "message": "Auto merge of #41277 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 3 pull requests\n\n- Successful merges: #41240, #41250, #41266\n- Failed merges:", "tree": {"sha": "1057c6802616a73b772a164a706aa8b8a0a7cbca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1057c6802616a73b772a164a706aa8b8a0a7cbca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea376822a17dd911244c313c5b07dffdfe3c023a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea376822a17dd911244c313c5b07dffdfe3c023a", "html_url": "https://github.com/rust-lang/rust/commit/ea376822a17dd911244c313c5b07dffdfe3c023a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea376822a17dd911244c313c5b07dffdfe3c023a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43ef63d5b4279ef97ed921338a69b0d62101ca83", "url": "https://api.github.com/repos/rust-lang/rust/commits/43ef63d5b4279ef97ed921338a69b0d62101ca83", "html_url": "https://github.com/rust-lang/rust/commit/43ef63d5b4279ef97ed921338a69b0d62101ca83"}, {"sha": "6afb2c48d94255d73532f8b9d0dd028bf2112c12", "url": "https://api.github.com/repos/rust-lang/rust/commits/6afb2c48d94255d73532f8b9d0dd028bf2112c12", "html_url": "https://github.com/rust-lang/rust/commit/6afb2c48d94255d73532f8b9d0dd028bf2112c12"}], "stats": {"total": 184, "additions": 117, "deletions": 67}, "files": [{"sha": "182a107e3f76915b24151ecda567306c012d42f4", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ea376822a17dd911244c313c5b07dffdfe3c023a/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea376822a17dd911244c313c5b07dffdfe3c023a/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=ea376822a17dd911244c313c5b07dffdfe3c023a", "patch": "@@ -165,18 +165,29 @@ unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n \n-/// A weak version of [`Arc`][arc].\n+/// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n+/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// pointer, which returns an [`Option`]`<`[`Arc`]`<T>>`.\n ///\n-/// `Weak` pointers do not count towards determining if the inner value\n-/// should be dropped.\n+/// Since a `Weak` reference does not count towards ownership, it will not\n+/// prevent the inner value from being dropped, and `Weak` itself makes no\n+/// guarantees about the value still being present and may return [`None`]\n+/// when [`upgrade`]d.\n ///\n-/// The typical way to obtain a `Weak` pointer is to call\n-/// [`Arc::downgrade`][downgrade].\n+/// A `Weak` pointer is useful for keeping a temporary reference to the value\n+/// within [`Arc`] without extending its lifetime. It is also used to prevent\n+/// circular references between [`Arc`] pointers, since mutual owning references\n+/// would never allow either [`Arc`] to be dropped. For example, a tree could\n+/// have strong [`Arc`] pointers from parent nodes to children, and `Weak`\n+/// pointers from children back to their parents.\n ///\n-/// See the [`Arc`][arc] documentation for more details.\n+/// The typical way to obtain a `Weak` pointer is to call [`Arc::downgrade`].\n ///\n-/// [arc]: struct.Arc.html\n-/// [downgrade]: struct.Arc.html#method.downgrade\n+/// [`Arc`]: struct.Arc.html\n+/// [`Arc::downgrade`]: struct.Arc.html#method.downgrade\n+/// [`upgrade`]: struct.Weak.html#method.upgrade\n+/// [`Option`]: ../../std/option/enum.Option.html\n+/// [`None`]: ../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     ptr: Shared<ArcInner<T>>,\n@@ -766,14 +777,11 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n }\n \n impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n-    ///\n-    /// This allocates memory for `T`, but does not initialize it. Calling\n-    /// [`upgrade`][upgrade] on the return value always gives\n-    /// [`None`][option].\n+    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n+    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n-    /// [upgrade]: struct.Weak.html#method.upgrade\n-    /// [option]: ../../std/option/enum.Option.html\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -798,13 +806,13 @@ impl<T> Weak<T> {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Upgrades the `Weak` pointer to an [`Arc`][arc], if possible.\n+    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], extending\n+    /// the lifetime of the value if successful.\n     ///\n-    /// Returns [`None`][option] if the strong count has reached zero and the\n-    /// inner value was destroyed.\n+    /// Returns [`None`] if the value has since been dropped.\n     ///\n-    /// [arc]: struct.Arc.html\n-    /// [option]: ../../std/option/enum.Option.html\n+    /// [`Arc`]: struct.Arc.html\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -865,10 +873,7 @@ impl<T: ?Sized> Weak<T> {\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer.\n-    ///\n-    /// This creates another pointer to the same inner value, increasing the\n-    /// weak reference count.\n+    /// Makes a clone of the `Weak` pointer that points to the same value.\n     ///\n     /// # Examples\n     ///\n@@ -900,14 +905,11 @@ impl<T: ?Sized> Clone for Weak<T> {\n \n #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n impl<T> Default for Weak<T> {\n-    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n+    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n+    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n-    /// This allocates memory for `T`, but does not initialize it. Calling\n-    /// [`upgrade`][upgrade] on the return value always gives\n-    /// [`None`][option].\n-    ///\n-    /// [upgrade]: struct.Weak.html#method.upgrade\n-    /// [option]: ../../std/option/enum.Option.html\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -926,8 +928,6 @@ impl<T> Default for Weak<T> {\n impl<T: ?Sized> Drop for Weak<T> {\n     /// Drops the `Weak` pointer.\n     ///\n-    /// This will decrement the weak reference count.\n-    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "fed718e9be4c6aa6ec5eba5c7b184a23c34e47dc", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ea376822a17dd911244c313c5b07dffdfe3c023a/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea376822a17dd911244c313c5b07dffdfe3c023a/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=ea376822a17dd911244c313c5b07dffdfe3c023a", "patch": "@@ -922,18 +922,29 @@ impl<T> From<T> for Rc<T> {\n     }\n }\n \n-/// A weak version of [`Rc`][rc].\n+/// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n+/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n ///\n-/// `Weak` pointers do not count towards determining if the inner value\n-/// should be dropped.\n+/// Since a `Weak` reference does not count towards ownership, it will not\n+/// prevent the inner value from being dropped, and `Weak` itself makes no\n+/// guarantees about the value still being present and may return [`None`]\n+/// when [`upgrade`]d.\n ///\n-/// The typical way to obtain a `Weak` pointer is to call\n-/// [`Rc::downgrade`][downgrade].\n+/// A `Weak` pointer is useful for keeping a temporary reference to the value\n+/// within [`Rc`] without extending its lifetime. It is also used to prevent\n+/// circular references between [`Rc`] pointers, since mutual owning references\n+/// would never allow either [`Arc`] to be dropped. For example, a tree could\n+/// have strong [`Rc`] pointers from parent nodes to children, and `Weak`\n+/// pointers from children back to their parents.\n ///\n-/// See the [module-level documentation](./index.html) for more details.\n+/// The typical way to obtain a `Weak` pointer is to call [`Rc::downgrade`].\n ///\n-/// [rc]: struct.Rc.html\n-/// [downgrade]: struct.Rc.html#method.downgrade\n+/// [`Rc`]: struct.Rc.html\n+/// [`Rc::downgrade`]: struct.Rc.html#method.downgrade\n+/// [`upgrade`]: struct.Weak.html#method.upgrade\n+/// [`Option`]: ../../std/option/enum.Option.html\n+/// [`None`]: ../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     ptr: Shared<RcBox<T>>,\n@@ -948,14 +959,11 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n-    ///\n-    /// This allocates memory for `T`, but does not initialize it. Calling\n-    /// [`upgrade`][upgrade] on the return value always gives\n-    /// [`None`][option].\n+    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n+    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n-    /// [upgrade]: struct.Weak.html#method.upgrade\n-    /// [option]: ../../std/option/enum.Option.html\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`None`]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n@@ -980,13 +988,13 @@ impl<T> Weak<T> {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Upgrades the `Weak` pointer to an [`Rc`][rc], if possible.\n+    /// Attempts to upgrade the `Weak` pointer to an [`Rc`], extending\n+    /// the lifetime of the value if successful.\n     ///\n-    /// Returns [`None`][option] if the strong count has reached zero and the\n-    /// inner value was destroyed.\n+    /// Returns [`None`] if the value has since been dropped.\n     ///\n-    /// [rc]: struct.Rc.html\n-    /// [option]: ../../std/option/enum.Option.html\n+    /// [`Rc`]: struct.Rc.html\n+    /// [`None`]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n@@ -1021,8 +1029,6 @@ impl<T: ?Sized> Weak<T> {\n impl<T: ?Sized> Drop for Weak<T> {\n     /// Drops the `Weak` pointer.\n     ///\n-    /// This will decrement the weak reference count.\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1061,10 +1067,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer.\n-    ///\n-    /// This creates another pointer to the same inner value, increasing the\n-    /// weak reference count.\n+    /// Makes a clone of the `Weak` pointer that points to the same value.\n     ///\n     /// # Examples\n     ///\n@@ -1091,14 +1094,11 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n \n #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n impl<T> Default for Weak<T> {\n-    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n-    ///\n-    /// This allocates memory for `T`, but does not initialize it. Calling\n-    /// [`upgrade`][upgrade] on the return value always gives\n-    /// [`None`][option].\n+    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n+    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n-    /// [upgrade]: struct.Weak.html#method.upgrade\n-    /// [option]: ../../std/option/enum.Option.html\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`None`]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "09b3d63950705001ed439d06d5c7a85d73d2ff75", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea376822a17dd911244c313c5b07dffdfe3c023a/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea376822a17dd911244c313c5b07dffdfe3c023a/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=ea376822a17dd911244c313c5b07dffdfe3c023a", "patch": "@@ -180,7 +180,7 @@ pub mod reimpls {\n             sr = sr.wrapping_add(1);\n \n             // 1 <= sr <= u64::bits() - 1\n-            q = n.wrapping_shl(64u32.wrapping_sub(sr));\n+            q = n.wrapping_shl(128u32.wrapping_sub(sr));\n             r = n.wrapping_shr(sr);\n         } else {\n             if d.high() == 0 {"}, {"sha": "c5057f70c065ae1dc784b4c6fe36f57e3835d023", "filename": "src/test/run-pass/i128.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ea376822a17dd911244c313c5b07dffdfe3c023a/src%2Ftest%2Frun-pass%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea376822a17dd911244c313c5b07dffdfe3c023a/src%2Ftest%2Frun-pass%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi128.rs?ref=ea376822a17dd911244c313c5b07dffdfe3c023a", "patch": "@@ -104,4 +104,9 @@ fn main() {\n     assert_eq!(l.checked_sub(l), Some(0));\n     assert_eq!(b(1u128).checked_shl(b(127)), Some(1 << 127));\n     assert_eq!(o.checked_shl(b(128)), None);\n+\n+    // https://github.com/rust-lang/rust/issues/41228\n+    assert_eq!(b(-87559967289969187895646876466835277875_i128) /\n+               b(84285771033834995895337664386045050880_i128),\n+               -1i128);\n }"}, {"sha": "cfd616c56b4f02ed18e42a4170d8207d0586a9fe", "filename": "src/test/run-pass/u128.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ea376822a17dd911244c313c5b07dffdfe3c023a/src%2Ftest%2Frun-pass%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea376822a17dd911244c313c5b07dffdfe3c023a/src%2Ftest%2Frun-pass%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu128.rs?ref=ea376822a17dd911244c313c5b07dffdfe3c023a", "patch": "@@ -77,4 +77,49 @@ fn main() {\n     assert_eq!(o.checked_sub(b(18)), None);\n     assert_eq!(b(1u128).checked_shl(b(127)), Some(1 << 127));\n     assert_eq!(o.checked_shl(b(128)), None);\n+\n+    // Test cases for all udivmodti4 branches.\n+    // case \"0X/0X\"\n+    assert_eq!(b(0x69545bd57727c050_u128) /\n+               b(0x3283527a3350d88c_u128),\n+               2u128);\n+    // case \"0X/KX\"\n+    assert_eq!(b(0x0_8003c9c50b473ae6_u128) /\n+               b(0x1_283e8838c30fa8f4_u128),\n+               0u128);\n+    // case \"K0/K0\"\n+    assert_eq!(b(0xc43f42a207978720_u128 << 64) /\n+               b(0x098e62b74c23cf1a_u128 << 64),\n+               20u128);\n+    // case \"KK/K0\" for power-of-two D.\n+    assert_eq!(b(0xa9008fb6c9d81e42_0e25730562a601c8_u128) /\n+               b(1u128 << 120),\n+               169u128);\n+    // case \"KK/K0\" with N >= D (https://github.com/rust-lang/rust/issues/41228).\n+    assert_eq!(b(0xe4d26e59f0640328_06da5b06efe83a41_u128) /\n+               b(0x330fcb030ea4447c_u128 << 64),\n+               4u128);\n+    assert_eq!(b(3u128 << 64 | 1) /\n+               b(3u128 << 64),\n+               1u128);\n+    // case \"KK/K0\" with N < D.\n+    assert_eq!(b(0x6655c9fb66ca2884_e2d1dfd470158c62_u128) /\n+               b(0xb35b667cab7e355b_u128 << 64),\n+               0u128);\n+    // case \"KX/0K\" for power-of-two D.\n+    assert_eq!(b(0x3e49dd84feb2df59_7b2f97d93a253969_u128) /\n+               b(1u128 << 4),\n+               0x03e49dd84feb2df5_97b2f97d93a25396_u128);\n+    // case \"KX/0K\" in general.\n+    assert_eq!(b(0x299692b3a1dae5bd_6162e6f489d2620e_u128) /\n+               b(0x900b6f027571d6f7_u128),\n+               0x49e95f54b0442578_u128);\n+    // case \"KX/KK\" with N >= D.\n+    assert_eq!(b(0xc7b889180b67b07d_bc1a3c88783d35b5_u128) /\n+               b(0x1d7e69f53160b9e2_60074771e852f244_u128),\n+               6u128);\n+    // case \"KX/KK\" with N < D.\n+    assert_eq!(b(0x679289ac23bb334f_36144401cf882172_u128) /\n+               b(0x7b0b271b64865f05_f54a7b72746c062f_u128),\n+               0u128);\n }"}]}