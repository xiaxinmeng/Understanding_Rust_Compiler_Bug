{"sha": "336a3c6121edf54a19728dbbd880f62bc835d7c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzNmEzYzYxMjFlZGY1NGExOTcyOGRiYmQ4ODBmNjJiYzgzNWQ3Yzg=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-01T13:31:35Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-01T13:31:35Z"}, "message": "Fix #3373\n\nBasically, we need to allow variables in the caller self type to unify with the\nimpl's declared self type. That requires some more contortions in the variable\nhandling. I'm looking forward to (hopefully) handling this in a cleaner way when\nwe switch to Chalk's types and unification code.", "tree": {"sha": "7cfbf56ccaf53e8e008798a3569c70e21516c5c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cfbf56ccaf53e8e008798a3569c70e21516c5c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/336a3c6121edf54a19728dbbd880f62bc835d7c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/336a3c6121edf54a19728dbbd880f62bc835d7c8", "html_url": "https://github.com/rust-lang/rust/commit/336a3c6121edf54a19728dbbd880f62bc835d7c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/336a3c6121edf54a19728dbbd880f62bc835d7c8/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6db2da4993d3956fc7c8ebf152963a132611426a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6db2da4993d3956fc7c8ebf152963a132611426a", "html_url": "https://github.com/rust-lang/rust/commit/6db2da4993d3956fc7c8ebf152963a132611426a"}], "stats": {"total": 51, "additions": 45, "deletions": 6}, "files": [{"sha": "82b85d57067a2d13264c716b725c2c2db59ea249", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/336a3c6121edf54a19728dbbd880f62bc835d7c8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336a3c6121edf54a19728dbbd880f62bc835d7c8/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=336a3c6121edf54a19728dbbd880f62bc835d7c8", "patch": "@@ -142,12 +142,21 @@ impl<T> Canonicalized<T> {\n \n pub fn unify(ty1: &Canonical<Ty>, ty2: &Canonical<Ty>) -> Option<Substs> {\n     let mut table = InferenceTable::new();\n+    let num_vars = ty1.num_vars.max(ty2.num_vars);\n     let vars =\n-        Substs::builder(ty1.num_vars).fill(std::iter::repeat_with(|| table.new_type_var())).build();\n-    let ty_with_vars = ty1.value.clone().subst_bound_vars(&vars);\n-    if !table.unify(&ty_with_vars, &ty2.value) {\n+        Substs::builder(num_vars).fill(std::iter::repeat_with(|| table.new_type_var())).build();\n+    let ty1_with_vars = ty1.value.clone().subst_bound_vars(&vars);\n+    let ty2_with_vars = ty2.value.clone().subst_bound_vars(&vars);\n+    if !table.unify(&ty1_with_vars, &ty2_with_vars) {\n         return None;\n     }\n+    // default any type vars that weren't unified back to their original bound vars\n+    // (kind of hacky)\n+    for (i, var) in vars.iter().enumerate() {\n+        if &*table.resolve_ty_shallow(var) == var {\n+            table.unify(var, &Ty::Bound(i as u32));\n+        }\n+    }\n     Some(\n         Substs::builder(ty1.num_vars)\n             .fill(vars.iter().map(|v| table.resolve_ty_completely(v.clone())))"}, {"sha": "ca194f806f92c8e62fcc57081d38f08c2c9b7f10", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/336a3c6121edf54a19728dbbd880f62bc835d7c8/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336a3c6121edf54a19728dbbd880f62bc835d7c8/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=336a3c6121edf54a19728dbbd880f62bc835d7c8", "patch": "@@ -355,6 +355,10 @@ impl Substs {\n         Substs(self.0[..std::cmp::min(self.0.len(), n)].into())\n     }\n \n+    pub fn suffix(&self, n: usize) -> Substs {\n+        Substs(self.0[self.0.len() - std::cmp::min(self.0.len(), n)..].into())\n+    }\n+\n     pub fn as_single(&self) -> &Ty {\n         if self.0.len() != 1 {\n             panic!(\"expected substs of len 1, got {:?}\", self);"}, {"sha": "b7e8855fbd20135fc92107acf6f03d750b39e65c", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/336a3c6121edf54a19728dbbd880f62bc835d7c8/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336a3c6121edf54a19728dbbd880f62bc835d7c8/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=336a3c6121edf54a19728dbbd880f62bc835d7c8", "patch": "@@ -508,10 +508,17 @@ pub(crate) fn inherent_impl_substs(\n     impl_id: ImplId,\n     self_ty: &Canonical<Ty>,\n ) -> Option<Substs> {\n-    let vars = Substs::build_for_def(db, impl_id).fill_with_bound_vars(0).build();\n+    // we create a var for each type parameter of the impl; we need to keep in\n+    // mind here that `self_ty` might have vars of its own\n+    let vars =\n+        Substs::build_for_def(db, impl_id).fill_with_bound_vars(self_ty.num_vars as u32).build();\n     let self_ty_with_vars = db.impl_self_ty(impl_id).subst(&vars);\n-    let self_ty_with_vars = Canonical { num_vars: vars.len(), value: self_ty_with_vars };\n-    super::infer::unify(&self_ty_with_vars, self_ty)\n+    let self_ty_with_vars =\n+        Canonical { num_vars: vars.len() + self_ty.num_vars, value: self_ty_with_vars };\n+    let substs = super::infer::unify(&self_ty_with_vars, self_ty);\n+    // we only want the substs for the vars we added, not the ones from self_ty\n+    let result = substs.map(|s| s.suffix(vars.len()));\n+    result\n }\n \n fn transform_receiver_ty("}, {"sha": "af3e5b12cbaddfdb9324a7774a879f7dfcb4f793", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/336a3c6121edf54a19728dbbd880f62bc835d7c8/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336a3c6121edf54a19728dbbd880f62bc835d7c8/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=336a3c6121edf54a19728dbbd880f62bc835d7c8", "patch": "@@ -1048,6 +1048,25 @@ where\n     assert_eq!(t, \"{unknown}\");\n }\n \n+#[test]\n+fn method_resolution_3373() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+struct A<T>(T);\n+\n+impl A<i32> {\n+    fn from(v: i32) -> A<i32> { A(v) }\n+}\n+\n+fn main() {\n+    A::from(3)<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"A<i32>\");\n+}\n+\n #[test]\n fn method_resolution_slow() {\n     // this can get quite slow if we set the solver size limit too high"}]}