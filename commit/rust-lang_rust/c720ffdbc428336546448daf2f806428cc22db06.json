{"sha": "c720ffdbc428336546448daf2f806428cc22db06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MjBmZmRiYzQyODMzNjU0NjQ0OGRhZjJmODA2NDI4Y2MyMmRiMDY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-04-11T01:33:20Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-04-11T19:07:19Z"}, "message": "Improve region code surrounding slice types.", "tree": {"sha": "77581b33368c5986398575e53593c0ef7ce1ac87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77581b33368c5986398575e53593c0ef7ce1ac87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c720ffdbc428336546448daf2f806428cc22db06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c720ffdbc428336546448daf2f806428cc22db06", "html_url": "https://github.com/rust-lang/rust/commit/c720ffdbc428336546448daf2f806428cc22db06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c720ffdbc428336546448daf2f806428cc22db06/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d7e4aefee194e3d6f0cf15d6adf1f41c7cb3935", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d7e4aefee194e3d6f0cf15d6adf1f41c7cb3935", "html_url": "https://github.com/rust-lang/rust/commit/9d7e4aefee194e3d6f0cf15d6adf1f41c7cb3935"}], "stats": {"total": 160, "additions": 78, "deletions": 82}, "files": [{"sha": "ce836221d7c59e0ae23b4867b1c4ca652cd0d0ab", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c720ffdbc428336546448daf2f806428cc22db06/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c720ffdbc428336546448daf2f806428cc22db06/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=c720ffdbc428336546448daf2f806428cc22db06", "patch": "@@ -908,6 +908,15 @@ fn super_tys<C:combine>(\n         }\n       }\n \n+      (ty::ty_evec(a_mt, ty::vstore_slice(a_r)),\n+       ty::ty_evec(b_mt, ty::vstore_slice(b_r))) {\n+        self.contraregions(a_r, b_r).chain {|r|\n+            self.mts(a_mt, b_mt).chain {|mt|\n+                ok(ty::mk_evec(tcx, mt, ty::vstore_slice(r)))\n+            }\n+        }\n+      }\n+\n       (ty::ty_res(a_id, a_t, a_tps), ty::ty_res(b_id, b_t, b_tps))\n       if a_id == b_id {\n         self.tys(a_t, b_t).chain {|t|"}, {"sha": "bc662738ba42bc5e5be42194ee0202dd4aaf1679", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c720ffdbc428336546448daf2f806428cc22db06/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c720ffdbc428336546448daf2f806428cc22db06/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=c720ffdbc428336546448daf2f806428cc22db06", "patch": "@@ -168,9 +168,10 @@ type region_map = {\n     ast_type_to_inferred_region: hashmap<ast::node_id,ty::region>,\n     /*\n      * Mapping from an address-of operator or alt expression to its containing\n-     * block. This is used as the region if the operand is an rvalue.\n+     * region (usually ty::region_scope(block). This is used as the region if\n+     * the operand is an rvalue.\n      */\n-    rvalue_to_block: hashmap<ast::node_id,ast::node_id>\n+    rvalue_to_region: hashmap<ast::node_id,ty::region>\n };\n \n type region_scope = @{\n@@ -366,41 +367,26 @@ fn get_inferred_region(cx: ctxt, sp: syntax::codemap::span) -> ty::region {\n     }\n }\n \n-fn resolve_region_binding(cx: ctxt, span: span, region: ast::region) {\n-\n-    let id = region.id;\n-    let rm = cx.region_map;\n+fn resolve_region_binding(cx: ctxt, span: span,\n+                          region: ast::region) -> ty::region {\n     alt region.node {\n-      ast::re_inferred {\n-        // option::may(cx.scope.resolve_anon()) {|r|\n-        //     rm.ast_type_to_region.insert(id, r);\n-        // }\n-      }\n-\n-      ast::re_static { /* fallthrough */ }\n-\n+      ast::re_inferred { ty::re_default }\n+      ast::re_static { ty::re_static }\n       ast::re_named(ident) {\n         alt cx.scope.resolve_ident(ident) {\n-          some(r) {\n-            rm.ast_type_to_region.insert(id, r);\n-          }\n-\n+          some(r) { r }\n           none {\n-            cx.sess.span_err(\n+            cx.sess.span_fatal(\n                 span,\n                 #fmt[\"the region `%s` is not declared\", ident]);\n           }\n         }\n       }\n-\n       ast::re_self {\n         alt cx.scope.resolve_self() {\n-          some(r) {\n-            rm.ast_type_to_region.insert(id, r);\n-          }\n-\n+          some(r) { r }\n           none {\n-            cx.sess.span_err(\n+            cx.sess.span_fatal(\n                 span,\n                 \"the `self` region is not allowed here\");\n           }\n@@ -416,7 +402,8 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n     alt ty.node {\n       ast::ty_vstore(_, ast::vstore_slice(r)) |\n       ast::ty_rptr(r, _) {\n-        resolve_region_binding(cx, ty.span, r);\n+        let region = resolve_region_binding(cx, ty.span, r);\n+        cx.region_map.ast_type_to_region.insert(ty.id, region);\n       }\n       _ { /* nothing to do */ }\n     }\n@@ -504,12 +491,17 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n                           in_alt: false with cx};\n             visit::visit_expr(expr, new_cx, visitor);\n         }\n+        ast::expr_vstore(e, ast::vstore_slice(r)) {\n+          let region = resolve_region_binding(cx, e.span, r);\n+          cx.region_map.rvalue_to_region.insert(e.id, region);\n+        }\n         ast::expr_addr_of(_, subexpr) | ast::expr_alt(subexpr, _, _) {\n             // Record the block that this expression appears in, in case the\n             // operand is an rvalue.\n             alt cx.parent {\n                 pa_block(blk_id) {\n-                    cx.region_map.rvalue_to_block.insert(subexpr.id, blk_id);\n+                  let region = ty::re_scope(blk_id);\n+                  cx.region_map.rvalue_to_region.insert(subexpr.id, region);\n                 }\n                 _ { cx.sess.span_bug(expr.span, \"expr outside of block?!\"); }\n             }\n@@ -522,7 +514,8 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n     alt cx.parent {\n         pa_block(blk_id) {\n-            cx.region_map.rvalue_to_block.insert(local.node.id, blk_id);\n+          let region = ty::re_scope(blk_id);\n+          cx.region_map.rvalue_to_region.insert(local.node.id, region);\n         }\n         _ { cx.sess.span_bug(local.span, \"local outside of block?!\"); }\n     }\n@@ -566,7 +559,7 @@ fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n                                   local_blocks: map::int_hash(),\n                                   ast_type_to_inferred_region:\n                                     map::int_hash(),\n-                                  rvalue_to_block: map::int_hash()},\n+                                  rvalue_to_region: map::int_hash()},\n                     scope: root_scope(0),\n                     mut queued_locals: [],\n                     parent: pa_crate,"}, {"sha": "a5affba6becd96fe0fbdbaada3be1491685ec152", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 47, "deletions": 53, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c720ffdbc428336546448daf2f806428cc22db06/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c720ffdbc428336546448daf2f806428cc22db06/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=c720ffdbc428336546448daf2f806428cc22db06", "patch": "@@ -276,49 +276,39 @@ fn type_is_c_like_enum(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n \n enum mode { m_collect, m_check, m_check_tyvar(@fn_ctxt), }\n \n-fn ast_region_to_region(tcx: ty::ctxt,\n-                        region: ast::region) -> ty::region {\n-    alt region.node {\n-      ast::re_inferred {\n-        // this must be replaced later by a fixup_regions() pass\n-        ty::re_default\n+fn ast_ty_vstore_to_vstore(tcx: ty::ctxt, ty: @ast::ty,\n+                           v: ast::vstore) -> ty::vstore {\n+    alt v {\n+      ast::vstore_fixed(none) {\n+        tcx.sess.span_bug(ty.span,\n+                          \"implied fixed length in ast_ty_vstore_to_vstore\");\n       }\n-      ast::re_self | ast::re_named(_) {\n-        tcx.region_map.ast_type_to_region.get(region.id)\n+      ast::vstore_fixed(some(u)) {\n+        ty::vstore_fixed(u)\n       }\n-      ast::re_static {\n-        ty::re_static\n+      ast::vstore_uniq { ty::vstore_uniq }\n+      ast::vstore_box { ty::vstore_box }\n+      ast::vstore_slice(r) {\n+        ty::vstore_slice(tcx.region_map.ast_type_to_region.get(ty.id))\n       }\n     }\n }\n \n-fn ast_vstore_to_vstore(tcx: ty::ctxt, span: span, n: option<uint>,\n-                        v: ast::vstore) -> ty::vstore {\n+fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n+                             v: ast::vstore) -> ty::vstore {\n     alt v {\n-      ast::vstore_fixed(none) {\n-        alt n {\n-          some(n) { ty::vstore_fixed(n) }\n-          none {\n-            tcx.sess.bug(\"implied fixed length in ast_vstore_to_vstore with \\\n-                          no default length\")\n-          }\n-        }\n-      }\n+      ast::vstore_fixed(none) { ty::vstore_fixed(n) }\n       ast::vstore_fixed(some(u)) {\n-        alt n {\n-          some(n) if n != u {\n-            tcx.sess.span_err(span,\n-                              #fmt(\"fixed-size sequence mismatch: %u vs. %u\",\n-                                   u, n));\n-          }\n-          _ { }\n+        if n != u {\n+            let s = #fmt(\"fixed-size sequence mismatch: %u vs. %u\",u, n);\n+            fcx.ccx.tcx.sess.span_err(e.span,s);\n         }\n         ty::vstore_fixed(u)\n       }\n       ast::vstore_uniq { ty::vstore_uniq }\n       ast::vstore_box { ty::vstore_box }\n-      ast::vstore_slice(region) {\n-        ty::vstore_slice(ast_region_to_region(tcx, region))\n+      ast::vstore_slice(r) {\n+        ty::vstore_slice(region_of(fcx, e))\n       }\n     }\n }\n@@ -408,7 +398,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n             ty::mk_ptr(tcx, ast_mt_to_mt(tcx, mode, mt))\n           }\n           ast::ty_rptr(region, mt) {\n-            let region = ast_region_to_region(tcx, region);\n+            let region = tcx.region_map.ast_type_to_region.get(ast_ty.id);\n             ty::mk_rptr(tcx, region, ast_mt_to_mt(tcx, mode, mt))\n           }\n           ast::ty_tup(fields) {\n@@ -473,16 +463,17 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n             }\n           }\n           ast::ty_vstore(t, vst) {\n-            let vst = ast_vstore_to_vstore(tcx, ast_ty.span, none, vst);\n-            alt ty::get(do_ast_ty_to_ty(tcx, mode, t)).struct {\n+            let vst = ast_ty_vstore_to_vstore(tcx, ast_ty, vst);\n+            let ty = alt ty::get(do_ast_ty_to_ty(tcx, mode, t)).struct {\n               ty::ty_vec(mt) { ty::mk_evec(tcx, mt, vst) }\n               ty::ty_str { ty::mk_estr(tcx, vst) }\n               _ {\n                 tcx.sess.span_fatal(ast_ty.span,\n                                     \"found sequence storage modifier \\\n                                      on non-sequence type\");\n               }\n-            }\n+            };\n+            fixup_regions_to_block(tcx, ty, ast_ty)\n           }\n           ast::ty_constr(t, cs) {\n             let mut out_cs = [];\n@@ -2512,8 +2503,7 @@ fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n             }\n         }\n         _ {\n-            let blk_id = fcx.ccx.tcx.region_map.rvalue_to_block.get(expr.id);\n-            ret ty::re_scope(blk_id);\n+            ret fcx.ccx.tcx.region_map.rvalue_to_region.get(expr.id);\n         }\n     }\n }\n@@ -2849,27 +2839,32 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     alt expr.node {\n \n       ast::expr_vstore(ev, vst) {\n-        alt ev.node {\n+        let mut typ = alt ev.node {\n           ast::expr_lit(@{node: ast::lit_str(s), span:_}) {\n-            let tt = ast_vstore_to_vstore(tcx, expr.span,\n-                                          some(str::len(s)), vst);\n-            let typ = ty::mk_estr(tcx, tt);\n-            fcx.write_ty(ev.id, typ);\n-            fcx.write_ty(id, typ);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev,\n+                                               str::len(s), vst);\n+            ty::mk_estr(tcx, tt)\n           }\n           ast::expr_vec(args, mutbl) {\n-            let tt = ast_vstore_to_vstore(tcx, expr.span,\n-                                          some(vec::len(args)), vst);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev,\n+                                               vec::len(args), vst);\n             let t: ty::t = next_ty_var(fcx);\n             for args.each {|e| bot |= check_expr_with(fcx, e, t); }\n-            let typ = ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt);\n-            fcx.write_ty(ev.id, typ);\n-            fcx.write_ty(id, typ);\n+            ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n           }\n           _ {\n-            tcx.sess.span_err(expr.span, \"vstore modifier on non-sequence\");\n+            tcx.sess.span_bug(expr.span, \"vstore modifier on non-sequence\")\n+          }\n+        };\n+        alt vst {\n+          ast::vstore_slice(_) {\n+            let region = fcx.ccx.tcx.region_map.rvalue_to_region.get(ev.id);\n+            typ = replace_default_region(tcx, region, typ);\n           }\n+          _ { }\n         }\n+        fcx.write_ty(ev.id, typ);\n+        fcx.write_ty(id, typ);\n       }\n \n       ast::expr_lit(lit) {\n@@ -3075,7 +3070,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let pattern_ty = next_ty_var(fcx);\n         bot = check_expr_with(fcx, discrim, pattern_ty);\n \n-        let parent_block = tcx.region_map.rvalue_to_block.get(discrim.id);\n+        let parent_region = tcx.region_map.rvalue_to_region.get(discrim.id);\n \n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n@@ -3084,9 +3079,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             let pcx = {\n                 fcx: fcx,\n                 map: pat_util::pat_id_map(tcx.def_map, arm.pats[0]),\n-                alt_region: ty::re_scope(parent_block),\n+                alt_region: parent_region,\n                 block_region: ty::re_scope(arm.body.node.id),\n-                pat_region: ty::re_scope(parent_block)\n+                pat_region: parent_region\n             };\n \n             for arm.pats.each {|p| check_pat(pcx, p, pattern_ty);}\n@@ -3529,8 +3524,7 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n       _ {/* fall through */ }\n     }\n \n-    let block_id = fcx.ccx.tcx.region_map.rvalue_to_block.get(local.node.id);\n-    let region = ty::re_scope(block_id);\n+    let region = fcx.ccx.tcx.region_map.rvalue_to_region.get(local.node.id);\n     let pcx = {\n         fcx: fcx,\n         map: pat_util::pat_id_map(fcx.ccx.tcx.def_map, local.node.pat),"}]}