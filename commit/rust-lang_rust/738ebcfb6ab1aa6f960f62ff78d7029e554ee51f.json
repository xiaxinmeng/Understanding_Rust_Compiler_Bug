{"sha": "738ebcfb6ab1aa6f960f62ff78d7029e554ee51f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczOGViY2ZiNmFiMWFhNmY5NjBmNjJmZjc4ZDcwMjllNTU0ZWU1MWY=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-15T21:05:14Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-15T21:05:14Z"}, "message": "Remove now unnecessary resolve_maybe_global_alloc.", "tree": {"sha": "6b7d8c6f9e4143cbc023ca9980f7d7adae748d1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b7d8c6f9e4143cbc023ca9980f7d7adae748d1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/738ebcfb6ab1aa6f960f62ff78d7029e554ee51f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/738ebcfb6ab1aa6f960f62ff78d7029e554ee51f", "html_url": "https://github.com/rust-lang/rust/commit/738ebcfb6ab1aa6f960f62ff78d7029e554ee51f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/738ebcfb6ab1aa6f960f62ff78d7029e554ee51f/comments", "author": null, "committer": null, "parents": [{"sha": "9e46807cff0f59616b277a3ecebd70a85b5175c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e46807cff0f59616b277a3ecebd70a85b5175c5", "html_url": "https://github.com/rust-lang/rust/commit/9e46807cff0f59616b277a3ecebd70a85b5175c5"}], "stats": {"total": 60, "additions": 17, "deletions": 43}, "files": [{"sha": "376ce3b239f914e2f310f26d1e510cba9d4b46ea", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/738ebcfb6ab1aa6f960f62ff78d7029e554ee51f/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/738ebcfb6ab1aa6f960f62ff78d7029e554ee51f/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=738ebcfb6ab1aa6f960f62ff78d7029e554ee51f", "patch": "@@ -6,7 +6,7 @@ use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n \n use rustc_middle::mir;\n-use rustc_middle::ty::{self, query::TyCtxtAt, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::def_id::DefId;\n \n use super::{\n@@ -230,10 +230,11 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         id\n     }\n \n-    /// Called when converting a `ty::Const` to an operand.\n+    /// Called when converting a `ty::Const` to an operand (in\n+    /// `eval_const_to_op`).\n     ///\n-    /// Miri uses this callback for creating unique allocation ids for thread\n-    /// locals. In Rust, one way for creating a thread local is by marking a\n+    /// Miri uses this callback for creating per thread allocations for thread\n+    /// locals. In Rust, one way of creating a thread local is by marking a\n     /// static with `#[thread_local]`. On supported platforms this gets\n     /// translated to a LLVM thread local for which LLVM automatically ensures\n     /// that each thread gets its own copy. Since LLVM automatically handles\n@@ -243,11 +244,12 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// plan is to change MIR to make accesses to thread locals explicit\n     /// (https://github.com/rust-lang/rust/issues/70685). While the issue 70685\n     /// is not fixed, our current workaround in Miri is to use this function to\n-    /// reserve fresh allocation ids for each thread. Please note that here we\n-    /// only **reserve** the allocation ids; the actual allocation for the\n-    /// thread local statics is done in `Memory::get_global_alloc`, which uses\n-    /// `resolve_maybe_global_alloc` to retrieve information about the\n-    /// allocation id we generated.\n+    /// make per-thread copies of thread locals. Please note that we cannot make\n+    /// these copies in `canonical_alloc_id` because that is too late: for\n+    /// example, if one created a pointer in thread `t1` to a thread local and\n+    /// sent it to another thread `t2`, resolving the access in\n+    /// `canonical_alloc_id` would result in pointer pointing to `t2`'s thread\n+    /// local and not `t1` as it should.\n     #[inline]\n     fn eval_maybe_thread_local_static_const(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n@@ -256,22 +258,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(val)\n     }\n \n-    /// Called to obtain the `GlobalAlloc` associated with the allocation id.\n-    ///\n-    /// Miri uses this callback to resolve the information about the original\n-    /// thread local static for which `canonical_alloc_id` reserved a fresh\n-    /// allocation id. Since `canonical_alloc_id` does not create the actual\n-    /// allocation and the reserved allocation id has no reference to its\n-    /// parent, we need to ask Miri to retrieve information for us.\n-    #[inline(always)]\n-    fn resolve_maybe_global_alloc(\n-        tcx: TyCtxtAt<'tcx>,\n-        _memory_extra: &Self::MemoryExtra,\n-        id: AllocId,\n-    ) -> Option<mir::interpret::GlobalAlloc<'tcx>> {\n-        tcx.alloc_map.lock().get(id)\n-    }\n-\n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n     /// to always first construct it without extra and then add the extra."}, {"sha": "bcad7855c373690963870560eda95850fdee620e", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/738ebcfb6ab1aa6f960f62ff78d7029e554ee51f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/738ebcfb6ab1aa6f960f62ff78d7029e554ee51f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=738ebcfb6ab1aa6f960f62ff78d7029e554ee51f", "patch": "@@ -429,16 +429,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n-        // The call to `resolve_maybe_global_alloc` is needed to enable Miri to\n-        // support thread local statics. In\n-        // `M::eval_maybe_thread_local_static_const`, for a thread local static,\n-        // Miri reserves a fresh allocation id, but the actual allocation is\n-        // left to the code that handles statics which calls this function\n-        // (`get_global_alloc`). Since the allocation id is fresh, it has no\n-        // information about the original static. The call to\n-        // `resolve_maybe_global_alloc` allows Miri to retrieve this information\n-        // for us.\n-        let (alloc, def_id) = match M::resolve_maybe_global_alloc(tcx, memory_extra, id) {\n+        let alloc = tcx.alloc_map.lock().get(id);\n+        let (alloc, def_id) = match alloc {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n                 (mem, None)\n@@ -598,14 +590,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n \n         // # Statics\n-        // The call to `resolve_maybe_global_alloc` is needed here because Miri\n-        // via the callback to `eval_maybe_thread_local_static_const` in\n-        // `eval_const_to_op` reserves fresh allocation ids for thread local\n-        // statics. However, the actual allocation is done not in\n-        // `resolve_maybe_global_alloc`, but in `get_raw` and `get_raw_mut`.\n-        // Since this function may get called before `get_raw`, we need to allow\n-        // Miri to retrieve the information about the static for us.\n-        match M::resolve_maybe_global_alloc(self.tcx, &self.extra, id) {\n+        // Can't do this in the match argument, we may get cycle errors since the lock would\n+        // be held throughout the match.\n+        let alloc = self.tcx.alloc_map.lock().get(id);\n+        match alloc {\n             Some(GlobalAlloc::Static(did)) => {\n                 // Use size and align of the type.\n                 let ty = self.tcx.type_of(did);"}]}