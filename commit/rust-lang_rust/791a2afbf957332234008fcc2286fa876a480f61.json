{"sha": "791a2afbf957332234008fcc2286fa876a480f61", "node_id": "C_kwDOAAsO6NoAKDc5MWEyYWZiZjk1NzMzMjIzNDAwOGZjYzIyODZmYTg3NmE0ODBmNjE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-17T08:59:06Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-17T08:59:06Z"}, "message": "Don't turn local names into strings in CompletionContext", "tree": {"sha": "65d2a5720b3c87247028321bda51e2c9411d5d13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65d2a5720b3c87247028321bda51e2c9411d5d13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/791a2afbf957332234008fcc2286fa876a480f61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/791a2afbf957332234008fcc2286fa876a480f61", "html_url": "https://github.com/rust-lang/rust/commit/791a2afbf957332234008fcc2286fa876a480f61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/791a2afbf957332234008fcc2286fa876a480f61/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81ccebf1f2ce237418ac15676bd72f46f8d59b01", "url": "https://api.github.com/repos/rust-lang/rust/commits/81ccebf1f2ce237418ac15676bd72f46f8d59b01", "html_url": "https://github.com/rust-lang/rust/commit/81ccebf1f2ce237418ac15676bd72f46f8d59b01"}], "stats": {"total": 158, "additions": 97, "deletions": 61}, "files": [{"sha": "2962b02e51b91fdf5b59fdb03d1474d75013d1d5", "filename": "crates/hir_expand/src/name.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/791a2afbf957332234008fcc2286fa876a480f61/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791a2afbf957332234008fcc2286fa876a480f61/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=791a2afbf957332234008fcc2286fa876a480f61", "patch": "@@ -67,12 +67,30 @@ impl Name {\n         Name::new_text(\"[missing name]\".into())\n     }\n \n+    /// Returns the tuple index this name represents if it is a tuple field.\n     pub fn as_tuple_index(&self) -> Option<usize> {\n         match self.0 {\n             Repr::TupleField(idx) => Some(idx),\n             _ => None,\n         }\n     }\n+\n+    /// Returns the text this name represents if it isn't a tuple field.\n+    pub fn as_text(&self) -> Option<SmolStr> {\n+        match &self.0 {\n+            Repr::Text(it) => Some(it.clone()),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Returns the textual representation of this name as a [`SmolStr`].\n+    /// Prefer using this over [`ToString::to_string`] if possible as this conversion is cheaper.\n+    pub fn to_smol_str(&self) -> SmolStr {\n+        match &self.0 {\n+            Repr::Text(it) => it.clone(),\n+            Repr::TupleField(it) => SmolStr::new(&it.to_string()),\n+        }\n+    }\n }\n \n pub trait AsName {"}, {"sha": "c30e6e4002014e66ee6c29aa43732397f7141812", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/791a2afbf957332234008fcc2286fa876a480f61/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791a2afbf957332234008fcc2286fa876a480f61/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=791a2afbf957332234008fcc2286fa876a480f61", "patch": "@@ -102,7 +102,9 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) function_def: Option<ast::Fn>,\n     /// The parent impl of the cursor position if it exists.\n     pub(super) impl_def: Option<ast::Impl>,\n+    /// The NameLike under the cursor in the original file if it exists.\n     pub(super) name_syntax: Option<ast::NameLike>,\n+    pub(super) incomplete_let: bool,\n \n     pub(super) completion_location: Option<ImmediateLocation>,\n     pub(super) prev_sibling: Option<ImmediatePrevSibling>,\n@@ -112,9 +114,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) lifetime_ctx: Option<LifetimeContext>,\n     pub(super) pattern_ctx: Option<PatternContext>,\n     pub(super) path_context: Option<PathCompletionContext>,\n-    pub(super) locals: Vec<(String, Local)>,\n-\n-    pub(super) incomplete_let: bool,\n+    pub(super) locals: Vec<(Name, Local)>,\n \n     no_completion_required: bool,\n }\n@@ -148,7 +148,7 @@ impl<'a> CompletionContext<'a> {\n         let mut locals = vec![];\n         scope.process_all_names(&mut |name, scope| {\n             if let ScopeDef::Local(local) = scope {\n-                locals.push((name.to_string(), local));\n+                locals.push((name, local));\n             }\n         });\n         let mut ctx = CompletionContext {\n@@ -492,14 +492,6 @@ impl<'a> CompletionContext<'a> {\n         false\n     }\n \n-    fn fill_impl_def(&mut self) {\n-        self.impl_def = self\n-            .sema\n-            .token_ancestors_with_macros(self.token.clone())\n-            .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-            .find_map(ast::Impl::cast);\n-    }\n-\n     fn expected_type_and_name(&self) -> (Option<Type>, Option<NameOrNameRef>) {\n         let mut node = match self.token.parent() {\n             Some(it) => it,\n@@ -654,6 +646,16 @@ impl<'a> CompletionContext<'a> {\n         self.prev_sibling = determine_prev_sibling(&name_like);\n         self.name_syntax =\n             find_node_at_offset(original_file, name_like.syntax().text_range().start());\n+        self.impl_def = self\n+            .sema\n+            .token_ancestors_with_macros(self.token.clone())\n+            .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n+            .find_map(ast::Impl::cast);\n+        self.function_def = self\n+            .sema\n+            .token_ancestors_with_macros(self.token.clone())\n+            .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n+            .find_map(ast::Fn::cast);\n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n                 self.classify_lifetime(original_file, lifetime, offset);\n@@ -691,8 +693,6 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn classify_name(&mut self, name: ast::Name) {\n-        self.fill_impl_def();\n-\n         if let Some(bind_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n             let is_name_in_field_pat = bind_pat\n                 .syntax()\n@@ -740,14 +740,6 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn classify_name_ref(&mut self, original_file: &SyntaxNode, name_ref: ast::NameRef) {\n-        self.fill_impl_def();\n-\n-        self.function_def = self\n-            .sema\n-            .token_ancestors_with_macros(self.token.clone())\n-            .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-            .find_map(ast::Fn::cast);\n-\n         let parent = match name_ref.syntax().parent() {\n             Some(it) => it,\n             None => return,"}, {"sha": "ea8222f76a7909ebdc8b1f82b89ea09101b18045", "filename": "crates/ide_completion/src/render/builder_ext.rs", "status": "modified", "additions": 53, "deletions": 5, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/791a2afbf957332234008fcc2286fa876a480f61/crates%2Fide_completion%2Fsrc%2Frender%2Fbuilder_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791a2afbf957332234008fcc2286fa876a480f61/crates%2Fide_completion%2Fsrc%2Frender%2Fbuilder_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fbuilder_ext.rs?ref=791a2afbf957332234008fcc2286fa876a480f61", "patch": "@@ -1,12 +1,14 @@\n //! Extensions for `Builder` structure required for item rendering.\n \n+use either::Either;\n use itertools::Itertools;\n+use syntax::ast::{self, HasName};\n \n use crate::{context::CallKind, item::Builder, patterns::ImmediateLocation, CompletionContext};\n \n #[derive(Debug)]\n pub(super) enum Params {\n-    Named(Vec<String>),\n+    Named(Vec<(Either<ast::SelfParam, ast::Param>, hir::Param)>),\n     Anonymous(usize),\n }\n \n@@ -76,10 +78,46 @@ impl Builder {\n             self.trigger_call_info();\n             let snippet = match (ctx.config.add_call_argument_snippets, params) {\n                 (true, Params::Named(params)) => {\n-                    let function_params_snippet =\n-                        params.iter().enumerate().format_with(\", \", |(index, param_name), f| {\n-                            f(&format_args!(\"${{{}:{}}}\", index + 1, param_name))\n-                        });\n+                    let function_params_snippet = params.iter().enumerate().format_with(\n+                        \", \",\n+                        |(index, (param_source, param)), f| {\n+                            let name;\n+                            let text;\n+                            let (ref_, name) = match param_source {\n+                                Either::Left(self_param) => (\n+                                    match self_param.kind() {\n+                                        ast::SelfParamKind::Owned => \"\",\n+                                        ast::SelfParamKind::Ref => \"&\",\n+                                        ast::SelfParamKind::MutRef => \"&mut \",\n+                                    },\n+                                    \"self\",\n+                                ),\n+                                Either::Right(it) => {\n+                                    let n = (|| {\n+                                        let mut pat = it.pat()?;\n+                                        loop {\n+                                            match pat {\n+                                                ast::Pat::IdentPat(pat) => break pat.name(),\n+                                                ast::Pat::RefPat(it) => pat = it.pat()?,\n+                                                _ => return None,\n+                                            }\n+                                        }\n+                                    })();\n+                                    match n {\n+                                        Some(n) => {\n+                                            name = n;\n+                                            text = name.text();\n+                                            let text = text.as_str().trim_start_matches('_');\n+                                            let ref_ = ref_of_param(ctx, text, param.ty());\n+                                            (ref_, text)\n+                                        }\n+                                        None => (\"\", \"_\"),\n+                                    }\n+                                }\n+                            };\n+                            f(&format_args!(\"${{{}:{}{}}}\", index + 1, ref_, name))\n+                        },\n+                    );\n                     format!(\"{}({})$0\", name, function_params_snippet)\n                 }\n                 _ => {\n@@ -93,3 +131,13 @@ impl Builder {\n         self.lookup_by(name).label(label).insert_snippet(cap, snippet)\n     }\n }\n+fn ref_of_param(ctx: &CompletionContext, arg: &str, ty: &hir::Type) -> &'static str {\n+    if let Some(derefed_ty) = ty.remove_ref() {\n+        for (name, local) in ctx.locals.iter() {\n+            if name.as_text().as_deref() == Some(arg) && local.ty(ctx.db) == derefed_ty {\n+                return if ty.is_mutable_reference() { \"&mut \" } else { \"&\" };\n+            }\n+        }\n+    }\n+    \"\"\n+}"}, {"sha": "769a0ed21f53fff8ed4c556ad839b9268b460088", "filename": "crates/ide_completion/src/render/function.rs", "status": "modified", "additions": 12, "deletions": 34, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/791a2afbf957332234008fcc2286fa876a480f61/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791a2afbf957332234008fcc2286fa876a480f61/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs?ref=791a2afbf957332234008fcc2286fa876a480f61", "patch": "@@ -1,5 +1,6 @@\n //! Renderer for function calls.\n \n+use either::Either;\n use hir::{AsAssocItem, HasSource, HirDisplay};\n use ide_db::SymbolKind;\n use itertools::Itertools;\n@@ -160,47 +161,25 @@ impl<'a> FunctionRender<'a> {\n         format!(\"-> {}\", ret_ty.display(self.ctx.db()))\n     }\n \n-    fn add_arg(&self, arg: &str, ty: &hir::Type) -> String {\n-        if let Some(derefed_ty) = ty.remove_ref() {\n-            for (name, local) in self.ctx.completion.locals.iter() {\n-                if name == arg && local.ty(self.ctx.db()) == derefed_ty {\n-                    let mutability = if ty.is_mutable_reference() { \"&mut \" } else { \"&\" };\n-                    return format!(\"{}{}\", mutability, arg);\n-                }\n-            }\n-        }\n-        arg.to_string()\n-    }\n-\n     fn params(&self) -> Params {\n         let ast_params = match self.ast_node.param_list() {\n             Some(it) => it,\n             None => return Params::Named(Vec::new()),\n         };\n+        let params = ast_params.params().map(Either::Right);\n \n-        let mut params_pats = Vec::new();\n-        let params_ty = if self.ctx.completion.has_dot_receiver() || self.receiver.is_some() {\n-            self.func.method_params(self.ctx.db()).unwrap_or_default()\n+        let params = if self.ctx.completion.has_dot_receiver() || self.receiver.is_some() {\n+            params.zip(self.func.method_params(self.ctx.db()).unwrap_or_default()).collect()\n         } else {\n-            if let Some(s) = ast_params.self_param() {\n-                cov_mark::hit!(parens_for_method_call_as_assoc_fn);\n-                params_pats.push(Some(s.to_string()));\n-            }\n-            self.func.assoc_fn_params(self.ctx.db())\n+            ast_params\n+                .self_param()\n+                .map(Either::Left)\n+                .into_iter()\n+                .chain(params)\n+                .zip(self.func.assoc_fn_params(self.ctx.db()))\n+                .collect()\n         };\n-        params_pats\n-            .extend(ast_params.params().into_iter().map(|it| it.pat().map(|it| it.to_string())));\n-\n-        let params = params_pats\n-            .into_iter()\n-            .zip(params_ty)\n-            .flat_map(|(pat, param_ty)| {\n-                let pat = pat?;\n-                let name = pat;\n-                let arg = name.trim_start_matches(\"mut \").trim_start_matches('_');\n-                Some(self.add_arg(arg, param_ty.ty()))\n-            })\n-            .collect();\n+\n         Params::Named(params)\n     }\n \n@@ -310,7 +289,6 @@ impl S {\n \n     #[test]\n     fn parens_for_method_call_as_assoc_fn() {\n-        cov_mark::check!(parens_for_method_call_as_assoc_fn);\n         check_edit(\n             \"foo\",\n             r#\""}]}