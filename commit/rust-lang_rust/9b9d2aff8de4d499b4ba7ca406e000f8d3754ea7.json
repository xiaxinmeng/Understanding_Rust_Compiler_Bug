{"sha": "9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliOWQyYWZmOGRlNGQ0OTliNGJhN2NhNDA2ZTAwMGY4ZDM3NTRlYTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-19T06:53:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-19T06:53:54Z"}, "message": "Auto merge of #64545 - nnethercote:ObligForest-more, r=nmatsakis\n\nMore `ObligationForest` improvements\n\nFollowing on from #64500, these commits alsomake the code both nicer and faster.\n\nr? @nikomatsakis", "tree": {"sha": "f38784726c530c78eb38684343435d85db7d2b1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f38784726c530c78eb38684343435d85db7d2b1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7", "html_url": "https://github.com/rust-lang/rust/commit/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19d070393c05da7dfa1948f17872e55603a8c359", "url": "https://api.github.com/repos/rust-lang/rust/commits/19d070393c05da7dfa1948f17872e55603a8c359", "html_url": "https://github.com/rust-lang/rust/commit/19d070393c05da7dfa1948f17872e55603a8c359"}, {"sha": "3b85597d22dc9dc9226445a95e275b8130880e63", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b85597d22dc9dc9226445a95e275b8130880e63", "html_url": "https://github.com/rust-lang/rust/commit/3b85597d22dc9dc9226445a95e275b8130880e63"}], "stats": {"total": 257, "additions": 139, "deletions": 118}, "files": [{"sha": "c5712cc9941a9d84d32dae63876a813360716607", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7", "patch": "@@ -1562,11 +1562,7 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n         ShallowResolver { infcx }\n     }\n \n-    // We have this force-inlined variant of `shallow_resolve` for the one\n-    // callsite that is extremely hot. All other callsites use the normal\n-    // variant.\n-    #[inline(always)]\n-    pub fn inlined_shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match typ.sty {\n             ty::Infer(ty::TyVar(v)) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n@@ -1601,6 +1597,42 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n             _ => typ,\n         }\n     }\n+\n+    // `resolver.shallow_resolve_changed(ty)` is equivalent to\n+    // `resolver.shallow_resolve(ty) != ty`, but more efficient. It's always\n+    // inlined, despite being large, because it has a single call site that is\n+    // extremely hot.\n+    #[inline(always)]\n+    pub fn shallow_resolve_changed(&mut self, typ: Ty<'tcx>) -> bool {\n+        match typ.sty {\n+            ty::Infer(ty::TyVar(v)) => {\n+                use self::type_variable::TypeVariableValue;\n+\n+                // See the comment in `shallow_resolve()`.\n+                match self.infcx.type_variables.borrow_mut().probe(v) {\n+                    TypeVariableValue::Known { value: t } => self.fold_ty(t) != typ,\n+                    TypeVariableValue::Unknown { .. } => false,\n+                }\n+            }\n+\n+            ty::Infer(ty::IntVar(v)) => {\n+                match self.infcx.int_unification_table.borrow_mut().probe_value(v) {\n+                    Some(v) => v.to_type(self.infcx.tcx) != typ,\n+                    None => false,\n+                }\n+            }\n+\n+            ty::Infer(ty::FloatVar(v)) => {\n+                match self.infcx.float_unification_table.borrow_mut().probe_value(v) {\n+                    Some(v) => v.to_type(self.infcx.tcx) != typ,\n+                    None => false,\n+                }\n+            }\n+\n+            _ => false,\n+        }\n+    }\n+\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n@@ -1609,7 +1641,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.inlined_shallow_resolve(ty)\n+        self.shallow_resolve(ty)\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {"}, {"sha": "805727b6ce0d72c0711065f284f07d2bf9af9d30", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7", "patch": "@@ -256,15 +256,20 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n         &mut self,\n         pending_obligation: &mut Self::Obligation,\n     ) -> ProcessResult<Self::Obligation, Self::Error> {\n-        // if we were stalled on some unresolved variables, first check\n+        // If we were stalled on some unresolved variables, first check\n         // whether any of them have been resolved; if not, don't bother\n         // doing more work yet\n         if !pending_obligation.stalled_on.is_empty() {\n-            if pending_obligation.stalled_on.iter().all(|&ty| {\n-                // Use the force-inlined variant of shallow_resolve() because this code is hot.\n-                let resolved = ShallowResolver::new(self.selcx.infcx()).inlined_shallow_resolve(ty);\n-                resolved == ty // nothing changed here\n-            }) {\n+            let mut changed = false;\n+            // This `for` loop was once a call to `all()`, but this lower-level\n+            // form was a perf win. See #64545 for details.\n+            for &ty in &pending_obligation.stalled_on {\n+                if ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(ty) {\n+                    changed = true;\n+                    break;\n+                }\n+            }\n+            if !changed {\n                 debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n                        self.selcx.infcx()\n                            .resolve_vars_if_possible(&pending_obligation.obligation),"}, {"sha": "ddf89d99621cabccc5be65cef79e1d048888bd70", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7", "patch": "@@ -74,9 +74,7 @@ impl<'a, O: ForestObligation + 'a> dot::GraphWalk<'a> for &'a ObligationForest<O\n             .flat_map(|i| {\n                 let node = &self.nodes[i];\n \n-                node.parent.iter()\n-                    .chain(node.dependents.iter())\n-                    .map(move |p| (p.index(), i))\n+                node.dependents.iter().map(move |&d| (d, i))\n             })\n             .collect()\n     }"}, {"sha": "98ae1a58324476c5c1731d32a20b1d13f97a0bb3", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 89, "deletions": 103, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=9b9d2aff8de4d499b4ba7ca406e000f8d3754ea7", "patch": "@@ -73,8 +73,6 @@\n //! aren't needed anymore.\n \n use crate::fx::{FxHashMap, FxHashSet};\n-use crate::indexed_vec::Idx;\n-use crate::newtype_index;\n \n use std::cell::{Cell, RefCell};\n use std::collections::hash_map::Entry;\n@@ -87,10 +85,6 @@ mod graphviz;\n #[cfg(test)]\n mod tests;\n \n-newtype_index! {\n-    pub struct NodeIndex { .. }\n-}\n-\n pub trait ForestObligation : Clone + Debug {\n     type Predicate : Clone + hash::Hash + Eq + Debug;\n \n@@ -143,9 +137,10 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// At the end of processing, those nodes will be removed by a\n     /// call to `compress`.\n     ///\n-    /// Ideally, this would be an `IndexVec<NodeIndex, Node<O>>`. But that is\n-    /// slower, because this vector is accessed so often that the\n-    /// `u32`-to-`usize` conversions required for accesses are significant.\n+    /// `usize` indices are used here and throughout this module, rather than\n+    /// `newtype_index!` indices, because this code is hot enough that the\n+    /// `u32`-to-`usize` conversions that would be required are significant,\n+    /// and space considerations are not important.\n     nodes: Vec<Node<O>>,\n \n     /// A cache of predicates that have been successfully completed.\n@@ -154,7 +149,7 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// A cache of the nodes in `nodes`, indexed by predicate. Unfortunately,\n     /// its contents are not guaranteed to match those of `nodes`. See the\n     /// comments in `process_obligation` for details.\n-    waiting_cache: FxHashMap<O::Predicate, NodeIndex>,\n+    waiting_cache: FxHashMap<O::Predicate, usize>,\n \n     /// A scratch vector reused in various operations, to avoid allocating new\n     /// vectors.\n@@ -177,36 +172,37 @@ struct Node<O> {\n     obligation: O,\n     state: Cell<NodeState>,\n \n-    /// The parent of a node - the original obligation of which it is a\n-    /// subobligation. Except for error reporting, it is just like any member\n-    /// of `dependents`.\n-    ///\n-    /// Unlike `ObligationForest::nodes`, this uses `NodeIndex` rather than\n-    /// `usize` for the index, because keeping the size down is more important\n-    /// than the cost of converting to a `usize` for indexing.\n-    parent: Option<NodeIndex>,\n-\n     /// Obligations that depend on this obligation for their completion. They\n     /// must all be in a non-pending state.\n-    ///\n-    /// This uses `NodeIndex` for the same reason as `parent`.\n-    dependents: Vec<NodeIndex>,\n+    dependents: Vec<usize>,\n+\n+    /// If true, dependents[0] points to a \"parent\" node, which requires\n+    /// special treatment upon error but is otherwise treated the same.\n+    /// (It would be more idiomatic to store the parent node in a separate\n+    /// `Option<usize>` field, but that slows down the common case of\n+    /// iterating over the parent and other descendants together.)\n+    has_parent: bool,\n \n     /// Identifier of the obligation tree to which this node belongs.\n     obligation_tree_id: ObligationTreeId,\n }\n \n impl<O> Node<O> {\n     fn new(\n-        parent: Option<NodeIndex>,\n+        parent: Option<usize>,\n         obligation: O,\n         obligation_tree_id: ObligationTreeId\n     ) -> Node<O> {\n         Node {\n             obligation,\n             state: Cell::new(NodeState::Pending),\n-            parent,\n-            dependents: vec![],\n+            dependents:\n+                if let Some(parent_index) = parent {\n+                    vec![parent_index]\n+                } else {\n+                    vec![]\n+                },\n+            has_parent: parent.is_some(),\n             obligation_tree_id,\n         }\n     }\n@@ -302,9 +298,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n     }\n \n     // Returns Err(()) if we already know this obligation failed.\n-    fn register_obligation_at(&mut self, obligation: O, parent: Option<NodeIndex>)\n-                              -> Result<(), ()>\n-    {\n+    fn register_obligation_at(&mut self, obligation: O, parent: Option<usize>) -> Result<(), ()> {\n         if self.done_cache.contains(obligation.as_predicate()) {\n             return Ok(());\n         }\n@@ -313,15 +307,13 @@ impl<O: ForestObligation> ObligationForest<O> {\n             Entry::Occupied(o) => {\n                 debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n                        obligation, parent, o.get());\n-                let node = &mut self.nodes[o.get().index()];\n+                let node = &mut self.nodes[*o.get()];\n                 if let Some(parent_index) = parent {\n-                    // If the node is already in `waiting_cache`, it's already\n-                    // been marked with a parent. (It's possible that parent\n-                    // has been cleared by `apply_rewrites`, though.) So just\n-                    // dump `parent` into `node.dependents`... unless it's\n-                    // already in `node.dependents` or `node.parent`.\n-                    if !node.dependents.contains(&parent_index) &&\n-                       Some(parent_index) != node.parent {\n+                    // If the node is already in `waiting_cache`, it has\n+                    // already had its chance to be marked with a parent. So if\n+                    // it's not already present, just dump `parent` into the\n+                    // dependents as a non-parent.\n+                    if !node.dependents.contains(&parent_index) {\n                         node.dependents.push(parent_index);\n                     }\n                 }\n@@ -336,10 +328,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n                        obligation, parent, self.nodes.len());\n \n                 let obligation_tree_id = match parent {\n-                    Some(parent_index) => {\n-                        self.nodes[parent_index.index()].obligation_tree_id\n-                    }\n-                    None => self.obligation_tree_id_generator.next().unwrap()\n+                    Some(parent_index) => self.nodes[parent_index].obligation_tree_id,\n+                    None => self.obligation_tree_id_generator.next().unwrap(),\n                 };\n \n                 let already_failed =\n@@ -352,7 +342,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 if already_failed {\n                     Err(())\n                 } else {\n-                    v.insert(NodeIndex::new(self.nodes.len()));\n+                    v.insert(self.nodes.len());\n                     self.nodes.push(Node::new(parent, obligation, obligation_tree_id));\n                     Ok(())\n                 }\n@@ -363,9 +353,9 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// Converts all remaining obligations to the given error.\n     pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n         let mut errors = vec![];\n-        for (i, node) in self.nodes.iter().enumerate() {\n+        for (index, node) in self.nodes.iter().enumerate() {\n             if let NodeState::Pending = node.state.get() {\n-                let backtrace = self.error_at(i);\n+                let backtrace = self.error_at(index);\n                 errors.push(Error {\n                     error: error.clone(),\n                     backtrace,\n@@ -409,10 +399,10 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let mut errors = vec![];\n         let mut stalled = true;\n \n-        for i in 0..self.nodes.len() {\n-            let node = &mut self.nodes[i];\n+        for index in 0..self.nodes.len() {\n+            let node = &mut self.nodes[index];\n \n-            debug!(\"process_obligations: node {} == {:?}\", i, node);\n+            debug!(\"process_obligations: node {} == {:?}\", index, node);\n \n             // `processor.process_obligation` can modify the predicate within\n             // `node.obligation`, and that predicate is the key used for\n@@ -424,7 +414,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 _ => continue\n             };\n \n-            debug!(\"process_obligations: node {} got result {:?}\", i, result);\n+            debug!(\"process_obligations: node {} got result {:?}\", index, result);\n \n             match result {\n                 ProcessResult::Unchanged => {\n@@ -438,18 +428,18 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     for child in children {\n                         let st = self.register_obligation_at(\n                             child,\n-                            Some(NodeIndex::new(i))\n+                            Some(index)\n                         );\n                         if let Err(()) = st {\n                             // Error already reported - propagate it\n                             // to our node.\n-                            self.error_at(i);\n+                            self.error_at(index);\n                         }\n                     }\n                 }\n                 ProcessResult::Error(err) => {\n                     stalled = false;\n-                    let backtrace = self.error_at(i);\n+                    let backtrace = self.error_at(index);\n                     errors.push(Error {\n                         error: err,\n                         backtrace,\n@@ -493,14 +483,14 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         debug!(\"process_cycles()\");\n \n-        for (i, node) in self.nodes.iter().enumerate() {\n+        for (index, node) in self.nodes.iter().enumerate() {\n             // For rustc-benchmarks/inflate-0.1.0 this state test is extremely\n             // hot and the state is almost always `Pending` or `Waiting`. It's\n             // a win to handle the no-op cases immediately to avoid the cost of\n             // the function call.\n             match node.state.get() {\n                 NodeState::Waiting | NodeState::Pending | NodeState::Done | NodeState::Error => {},\n-                _ => self.find_cycles_from_node(&mut stack, processor, i),\n+                _ => self.find_cycles_from_node(&mut stack, processor, index),\n             }\n         }\n \n@@ -510,21 +500,21 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.scratch.replace(stack);\n     }\n \n-    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, i: usize)\n+    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, index: usize)\n         where P: ObligationProcessor<Obligation=O>\n     {\n-        let node = &self.nodes[i];\n+        let node = &self.nodes[index];\n         match node.state.get() {\n             NodeState::OnDfsStack => {\n-                let i = stack.iter().rposition(|n| *n == i).unwrap();\n-                processor.process_backedge(stack[i..].iter().map(GetObligation(&self.nodes)),\n+                let index = stack.iter().rposition(|&n| n == index).unwrap();\n+                processor.process_backedge(stack[index..].iter().map(GetObligation(&self.nodes)),\n                                            PhantomData);\n             }\n             NodeState::Success => {\n                 node.state.set(NodeState::OnDfsStack);\n-                stack.push(i);\n-                for index in node.parent.iter().chain(node.dependents.iter()) {\n-                    self.find_cycles_from_node(stack, processor, index.index());\n+                stack.push(index);\n+                for &index in node.dependents.iter() {\n+                    self.find_cycles_from_node(stack, processor, index);\n                 }\n                 stack.pop();\n                 node.state.set(NodeState::Done);\n@@ -541,33 +531,34 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     /// Returns a vector of obligations for `p` and all of its\n     /// ancestors, putting them into the error state in the process.\n-    fn error_at(&self, mut i: usize) -> Vec<O> {\n+    fn error_at(&self, mut index: usize) -> Vec<O> {\n         let mut error_stack = self.scratch.replace(vec![]);\n         let mut trace = vec![];\n \n         loop {\n-            let node = &self.nodes[i];\n+            let node = &self.nodes[index];\n             node.state.set(NodeState::Error);\n             trace.push(node.obligation.clone());\n-            error_stack.extend(node.dependents.iter().map(|index| index.index()));\n-\n-            // Loop to the parent.\n-            match node.parent {\n-                Some(parent_index) => i = parent_index.index(),\n-                None => break\n+            if node.has_parent {\n+                // The first dependent is the parent, which is treated\n+                // specially.\n+                error_stack.extend(node.dependents.iter().skip(1));\n+                index = node.dependents[0];\n+            } else {\n+                // No parent; treat all dependents non-specially.\n+                error_stack.extend(node.dependents.iter());\n+                break;\n             }\n         }\n \n-        while let Some(i) = error_stack.pop() {\n-            let node = &self.nodes[i];\n+        while let Some(index) = error_stack.pop() {\n+            let node = &self.nodes[index];\n             match node.state.get() {\n                 NodeState::Error => continue,\n                 _ => node.state.set(NodeState::Error),\n             }\n \n-            error_stack.extend(\n-                node.parent.iter().chain(node.dependents.iter()).map(|index| index.index())\n-            );\n+            error_stack.extend(node.dependents.iter());\n         }\n \n         self.scratch.replace(error_stack);\n@@ -577,8 +568,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n     fn inlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n-        for dependent in node.parent.iter().chain(node.dependents.iter()) {\n-            self.mark_as_waiting_from(&self.nodes[dependent.index()]);\n+        for &index in node.dependents.iter() {\n+            self.mark_as_waiting_from(&self.nodes[index]);\n         }\n     }\n \n@@ -631,16 +622,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n         // Now move all popped nodes to the end. Try to keep the order.\n         //\n         // LOOP INVARIANT:\n-        //     self.nodes[0..i - dead_nodes] are the first remaining nodes\n-        //     self.nodes[i - dead_nodes..i] are all dead\n-        //     self.nodes[i..] are unchanged\n-        for i in 0..self.nodes.len() {\n-            let node = &self.nodes[i];\n+        //     self.nodes[0..index - dead_nodes] are the first remaining nodes\n+        //     self.nodes[index - dead_nodes..index] are all dead\n+        //     self.nodes[index..] are unchanged\n+        for index in 0..self.nodes.len() {\n+            let node = &self.nodes[index];\n             match node.state.get() {\n                 NodeState::Pending | NodeState::Waiting => {\n                     if dead_nodes > 0 {\n-                        self.nodes.swap(i, i - dead_nodes);\n-                        node_rewrites[i] -= dead_nodes;\n+                        self.nodes.swap(index, index - dead_nodes);\n+                        node_rewrites[index] -= dead_nodes;\n                     }\n                 }\n                 NodeState::Done => {\n@@ -655,17 +646,17 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     } else {\n                         self.done_cache.insert(node.obligation.as_predicate().clone());\n                     }\n-                    node_rewrites[i] = nodes_len;\n+                    node_rewrites[index] = nodes_len;\n                     dead_nodes += 1;\n                 }\n                 NodeState::Error => {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n                     self.waiting_cache.remove(node.obligation.as_predicate());\n-                    node_rewrites[i] = nodes_len;\n+                    node_rewrites[index] = nodes_len;\n                     dead_nodes += 1;\n-                    self.insert_into_error_cache(i);\n+                    self.insert_into_error_cache(index);\n                 }\n                 NodeState::OnDfsStack | NodeState::Success => unreachable!()\n             }\n@@ -706,35 +697,30 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let nodes_len = node_rewrites.len();\n \n         for node in &mut self.nodes {\n-            if let Some(index) = node.parent {\n-                let new_i = node_rewrites[index.index()];\n-                if new_i >= nodes_len {\n-                    node.parent = None;\n-                } else {\n-                    node.parent = Some(NodeIndex::new(new_i));\n-                }\n-            }\n-\n-            let mut i = 0;\n-            while i < node.dependents.len() {\n-                let new_i = node_rewrites[node.dependents[i].index()];\n-                if new_i >= nodes_len {\n-                    node.dependents.swap_remove(i);\n+            let mut index = 0;\n+            while index < node.dependents.len() {\n+                let new_index = node_rewrites[node.dependents[index]];\n+                if new_index >= nodes_len {\n+                    node.dependents.swap_remove(index);\n+                    if index == 0 && node.has_parent {\n+                        // We just removed the parent.\n+                        node.has_parent = false;\n+                    }\n                 } else {\n-                    node.dependents[i] = NodeIndex::new(new_i);\n-                    i += 1;\n+                    node.dependents[index] = new_index;\n+                    index += 1;\n                 }\n             }\n         }\n \n         // This updating of `self.waiting_cache` is necessary because the\n         // removal of nodes within `compress` can fail. See above.\n         self.waiting_cache.retain(|_predicate, index| {\n-            let new_i = node_rewrites[index.index()];\n-            if new_i >= nodes_len {\n+            let new_index = node_rewrites[*index];\n+            if new_index >= nodes_len {\n                 false\n             } else {\n-                *index = NodeIndex::new(new_i);\n+                *index = new_index;\n                 true\n             }\n         });"}]}