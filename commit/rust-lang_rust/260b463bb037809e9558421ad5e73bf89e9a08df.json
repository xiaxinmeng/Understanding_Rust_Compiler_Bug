{"sha": "260b463bb037809e9558421ad5e73bf89e9a08df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MGI0NjNiYjAzNzgwOWU5NTU4NDIxYWQ1ZTczYmY4OWU5YTA4ZGY=", "commit": {"author": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-10-24T13:44:13Z"}, "committer": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-10-24T14:34:48Z"}, "message": "Clean file handling functions", "tree": {"sha": "80e44c545ffbb06ca7737d9482dfa6bffef45194", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80e44c545ffbb06ca7737d9482dfa6bffef45194"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/260b463bb037809e9558421ad5e73bf89e9a08df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/260b463bb037809e9558421ad5e73bf89e9a08df", "html_url": "https://github.com/rust-lang/rust/commit/260b463bb037809e9558421ad5e73bf89e9a08df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/260b463bb037809e9558421ad5e73bf89e9a08df/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bf282ff09d10ee88c4fa43ce0820a9bcc2441e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bf282ff09d10ee88c4fa43ce0820a9bcc2441e4", "html_url": "https://github.com/rust-lang/rust/commit/1bf282ff09d10ee88c4fa43ce0820a9bcc2441e4"}], "stats": {"total": 120, "additions": 46, "deletions": 74}, "files": [{"sha": "760fc1daff1fbebf829f0569924ef5ad880b2aeb", "filename": "src/shims/fs.rs", "status": "modified", "additions": 46, "deletions": 74, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/260b463bb037809e9558421ad5e73bf89e9a08df/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260b463bb037809e9558421ad5e73bf89e9a08df/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=260b463bb037809e9558421ad5e73bf89e9a08df", "patch": "@@ -1,5 +1,5 @@\n use std::collections::HashMap;\n-use std::fs::{File, OpenOptions, remove_file};\n+use std::fs::{remove_file, File, OpenOptions};\n use std::io::{Read, Write};\n \n use rustc::ty::layout::Size;\n@@ -125,8 +125,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // `FD_CLOEXEC` value without checking if the flag is set for the file because `std`\n             // always sets this flag when opening a file. However we still need to check that the\n             // file itself is open.\n-            let fd_cloexec = this.eval_libc_i32(\"FD_CLOEXEC\")?;\n-            this.get_handle_and(fd, |_| Ok(fd_cloexec))\n+            if this.machine.file_handler.handles.contains_key(&fd) {\n+                Ok(this.eval_libc_i32(\"FD_CLOEXEC\")?)\n+            } else {\n+                this.handle_not_found()\n+            }\n         } else {\n             throw_unsup_format!(\"The {:#x} command is not supported for `fcntl`)\", cmd);\n         }\n@@ -139,9 +142,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n \n-        this.remove_handle_and(fd, |handle, this| {\n+        if let Some(handle) = this.machine.file_handler.handles.remove(&fd) {\n             this.try_unwrap_io_result(handle.file.sync_all().map(|_| 0i32))\n-        })\n+        } else {\n+            this.handle_not_found()\n+        }\n     }\n \n     fn read(\n@@ -160,20 +165,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(0);\n         }\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n-        let buf_scalar = this.read_scalar(buf_op)?.not_undef()?;\n-\n-        // Remove the file handle to avoid borrowing issues.\n-        this.remove_handle_and(fd, |mut handle, this| {\n-            // Don't use `?` to avoid returning before reinserting the handle.\n-            let bytes = this.force_ptr(buf_scalar).and_then(|buf| {\n-                this.memory\n-                    .get_mut(buf.alloc_id)?\n-                    .get_bytes_mut(&*this.tcx, buf, Size::from_bytes(count))\n-                    .map(|buffer| handle.file.read(buffer))\n-            });\n-            this.machine.file_handler.handles.insert(fd, handle).unwrap_none();\n-            this.try_unwrap_io_result(bytes?.map(|bytes| bytes as i64))\n-        })\n+        let buf = this.read_scalar(buf_op)?.not_undef()?;\n+\n+        if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n+            // We want to read at most `count` bytes\n+            let mut bytes = vec![0; count as usize];\n+            let result = handle.file.read(&mut bytes).map(|c| c as i64);\n+            let written_count = this.try_unwrap_io_result(result)?;\n+            // `try_unwrap_io_result` returns Ok(`-1`) if `result` is an error. There is no other\n+            // way of returning `-1` because the `Ok` variant of `result` contains the number of\n+            // written bytes, which is a possitive value.\n+            if written_count != -1 {\n+                // If reading to `bytes` did not fail, we write those bytes to the buffer.\n+                this.memory.write_bytes(buf, bytes)?;\n+            }\n+            Ok(written_count)\n+        } else {\n+            this.handle_not_found()\n+        }\n     }\n \n     fn write(\n@@ -192,20 +201,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(0);\n         }\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n-        let buf = this.force_ptr(this.read_scalar(buf_op)?.not_undef()?)?;\n-\n-        this.remove_handle_and(fd, |mut handle, this| {\n-            let bytes = this.memory.get(buf.alloc_id).and_then(|alloc| {\n-                alloc\n-                    .get_bytes(&*this.tcx, buf, Size::from_bytes(count))\n-                    .map(|bytes| handle.file.write(bytes).map(|bytes| bytes as i64))\n-            });\n-            this.machine.file_handler.handles.insert(fd, handle).unwrap_none();\n-            this.try_unwrap_io_result(bytes?)\n-        })\n+        let buf = this.read_scalar(buf_op)?.not_undef()?;\n+\n+        if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n+            let bytes = this.memory.read_bytes(buf, Size::from_bytes(count))?;\n+            let result = handle.file.write(&bytes).map(|c| c as i64);\n+            this.try_unwrap_io_result(result)\n+        } else {\n+            this.handle_not_found()\n+        }\n     }\n \n-    fn unlink( &mut self, path_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn unlink(&mut self, path_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.check_no_isolation(\"unlink\")?;\n@@ -217,49 +224,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.try_unwrap_io_result(result)\n     }\n \n-    /// Helper function that gets a `FileHandle` immutable reference and allows to manipulate it\n-    /// using the `f` closure.\n-    ///\n-    /// If the `fd` file descriptor does not correspond to a file, this functions returns `Ok(-1)`\n-    /// and sets `Evaluator::last_error` to `libc::EBADF` (invalid file descriptor).\n-    ///\n-    /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n-    /// functions return different integer types (like `read`, that returns an `i64`).\n-    fn get_handle_and<F, T: From<i32>>(&mut self, fd: i32, f: F) -> InterpResult<'tcx, T>\n-    where\n-        F: Fn(&FileHandle) -> InterpResult<'tcx, T>,\n-    {\n+    /// Function used when a handle is not found inside `FileHandler`. It returns `Ok(-1)`and sets\n+    /// the last OS error to `libc::EBADF` (invalid file descriptor). This function uses\n+    /// `T: From<i32>` instead of `i32` directly because some fs functions return different integer\n+    /// types (like `read`, that returns an `i64`).\n+    fn handle_not_found<T: From<i32>>(&mut self) -> InterpResult<'tcx, T> {\n         let this = self.eval_context_mut();\n-        if let Some(handle) = this.machine.file_handler.handles.get(&fd) {\n-            f(handle)\n-        } else {\n-            let ebadf = this.eval_libc(\"EBADF\")?;\n-            this.set_last_error(ebadf)?;\n-            Ok((-1).into())\n-        }\n-    }\n-\n-    /// Helper function that removes a `FileHandle` and allows to manipulate it using the `f`\n-    /// closure. This function is quite useful when you need to modify a `FileHandle` but you need\n-    /// to modify `MiriEvalContext` at the same time, so you can modify the handle and reinsert it\n-    /// using `f`.\n-    ///\n-    /// If the `fd` file descriptor does not correspond to a file, this functions returns `Ok(-1)`\n-    /// and sets `Evaluator::last_error` to `libc::EBADF` (invalid file descriptor).\n-    ///\n-    /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n-    /// functions return different integer types (like `read`, that returns an `i64`).\n-    fn remove_handle_and<F, T: From<i32>>(&mut self, fd: i32, mut f: F) -> InterpResult<'tcx, T>\n-    where\n-        F: FnMut(FileHandle, &mut MiriEvalContext<'mir, 'tcx>) -> InterpResult<'tcx, T>,\n-    {\n-        let this = self.eval_context_mut();\n-        if let Some(handle) = this.machine.file_handler.handles.remove(&fd) {\n-            f(handle, this)\n-        } else {\n-            let ebadf = this.eval_libc(\"EBADF\")?;\n-            this.set_last_error(ebadf)?;\n-            Ok((-1).into())\n-        }\n+        let ebadf = this.eval_libc(\"EBADF\")?;\n+        this.set_last_error(ebadf)?;\n+        Ok((-1).into())\n     }\n }"}]}