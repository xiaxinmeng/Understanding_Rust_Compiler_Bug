{"sha": "7b86c6f21e407e5da617a55aa172e85327b473db", "node_id": "C_kwDOAAsO6NoAKDdiODZjNmYyMWU0MDdlNWRhNjE3YTU1YWExNzJlODUzMjdiNDczZGI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-12T20:29:04Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-29T10:16:09Z"}, "message": "Fortify check for number of generic parameters.", "tree": {"sha": "1f06dde1de7e034318da0ea9399612abaa743a68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f06dde1de7e034318da0ea9399612abaa743a68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b86c6f21e407e5da617a55aa172e85327b473db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b86c6f21e407e5da617a55aa172e85327b473db", "html_url": "https://github.com/rust-lang/rust/commit/7b86c6f21e407e5da617a55aa172e85327b473db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b86c6f21e407e5da617a55aa172e85327b473db/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da175c743c3dbf7fc371534acbbd6a1bf0b17d50", "url": "https://api.github.com/repos/rust-lang/rust/commits/da175c743c3dbf7fc371534acbbd6a1bf0b17d50", "html_url": "https://github.com/rust-lang/rust/commit/da175c743c3dbf7fc371534acbbd6a1bf0b17d50"}], "stats": {"total": 203, "additions": 127, "deletions": 76}, "files": [{"sha": "c513f7d49a1c1c8220ef9e449507b3ffae524059", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 107, "deletions": 70, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/7b86c6f21e407e5da617a55aa172e85327b473db/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b86c6f21e407e5da617a55aa172e85327b473db/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=7b86c6f21e407e5da617a55aa172e85327b473db", "patch": "@@ -8,10 +8,11 @@ use super::*;\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{def::Res, ItemKind, Node, PathSegment};\n+use rustc_hir::{ItemKind, Node, PathSegment};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n@@ -29,7 +30,6 @@ use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_ty_utils::representability::{self, Representability};\n \n-use rustc_hir::def::DefKind;\n use std::iter;\n use std::ops::ControlFlow;\n \n@@ -93,7 +93,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n     fcx.return_type_pre_known = return_type_pre_known;\n \n     let tcx = fcx.tcx;\n-    let sess = tcx.sess;\n     let hir = tcx.hir();\n \n     let declared_ret_ty = fn_sig.output();\n@@ -260,85 +259,123 @@ pub(super) fn check_fn<'a, 'tcx>(\n     if let Some(panic_impl_did) = tcx.lang_items().panic_impl()\n         && panic_impl_did == hir.local_def_id(fn_id).to_def_id()\n     {\n-        if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n-            if *declared_ret_ty.kind() != ty::Never {\n-                sess.span_err(decl.output.span(), \"return type should be `!`\");\n-            }\n-\n-            let inputs = fn_sig.inputs();\n-            let span = hir.span(fn_id);\n-            if inputs.len() == 1 {\n-                let arg_is_panic_info = match *inputs[0].kind() {\n-                    ty::Ref(region, ty, mutbl) => match *ty.kind() {\n-                        ty::Adt(ref adt, _) => {\n-                            adt.did() == panic_info_did\n-                                && mutbl == hir::Mutability::Not\n-                                && !region.is_static()\n-                        }\n-                        _ => false,\n-                    },\n-                    _ => false,\n-                };\n-\n-                if !arg_is_panic_info {\n-                    sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n-                }\n-\n-                if let Node::Item(item) = hir.get(fn_id)\n-                    && let ItemKind::Fn(_, ref generics, _) = item.kind\n-                    && !generics.params.is_empty()\n-                {\n-                            sess.span_err(span, \"should have no type parameters\");\n-                        }\n-            } else {\n-                let span = sess.source_map().guess_head_span(span);\n-                sess.span_err(span, \"function should have one argument\");\n-            }\n-        } else {\n-            sess.err(\"language item required, but not found: `panic_info`\");\n-        }\n+        check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n     }\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n     if let Some(alloc_error_handler_did) = tcx.lang_items().oom()\n         && alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id()\n     {\n-        if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n-            if *declared_ret_ty.kind() != ty::Never {\n-                sess.span_err(decl.output.span(), \"return type should be `!`\");\n-            }\n+        check_alloc_error_fn(tcx, alloc_error_handler_did.expect_local(), fn_sig, decl, declared_ret_ty);\n+    }\n \n-            let inputs = fn_sig.inputs();\n-            let span = hir.span(fn_id);\n-            if inputs.len() == 1 {\n-                let arg_is_alloc_layout = match inputs[0].kind() {\n-                    ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n-                    _ => false,\n-                };\n+    (fcx, gen_ty)\n+}\n \n-                if !arg_is_alloc_layout {\n-                    sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n-                }\n+fn check_panic_info_fn(\n+    tcx: TyCtxt<'_>,\n+    fn_id: LocalDefId,\n+    fn_sig: ty::FnSig<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    declared_ret_ty: Ty<'_>,\n+) {\n+    let Some(panic_info_did) = tcx.lang_items().panic_info() else {\n+        tcx.sess.err(\"language item required, but not found: `panic_info`\");\n+        return;\n+    };\n \n-                if let Node::Item(item) = hir.get(fn_id)\n-                    && let ItemKind::Fn(_, ref generics, _) = item.kind\n-                    && !generics.params.is_empty()\n-                {\n-                            sess.span_err(\n-                                span,\n-                        \"`#[alloc_error_handler]` function should have no type parameters\",\n-                            );\n-                        }\n-            } else {\n-                let span = sess.source_map().guess_head_span(span);\n-                sess.span_err(span, \"function should have one argument\");\n+    if *declared_ret_ty.kind() != ty::Never {\n+        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+    }\n+\n+    let span = tcx.def_span(fn_id);\n+    let inputs = fn_sig.inputs();\n+    if inputs.len() != 1 {\n+        let span = tcx.sess.source_map().guess_head_span(span);\n+        tcx.sess.span_err(span, \"function should have one argument\");\n+        return;\n+    }\n+\n+    let arg_is_panic_info = match *inputs[0].kind() {\n+        ty::Ref(region, ty, mutbl) => match *ty.kind() {\n+            ty::Adt(ref adt, _) => {\n+                adt.did() == panic_info_did && mutbl == hir::Mutability::Not && !region.is_static()\n             }\n-        } else {\n-            sess.err(\"language item required, but not found: `alloc_layout`\");\n-        }\n+            _ => false,\n+        },\n+        _ => false,\n+    };\n+\n+    if !arg_is_panic_info {\n+        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n     }\n \n-    (fcx, gen_ty)\n+    let DefKind::Fn = tcx.def_kind(fn_id) else {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should be a function\");\n+        return;\n+    };\n+\n+    let generic_counts = tcx.generics_of(fn_id).own_counts();\n+    if generic_counts.types != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should have no type parameters\");\n+    }\n+    if generic_counts.consts != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should have no const parameters\");\n+    }\n+}\n+\n+fn check_alloc_error_fn(\n+    tcx: TyCtxt<'_>,\n+    fn_id: LocalDefId,\n+    fn_sig: ty::FnSig<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    declared_ret_ty: Ty<'_>,\n+) {\n+    let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() else {\n+        tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n+        return;\n+    };\n+\n+    if *declared_ret_ty.kind() != ty::Never {\n+        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+    }\n+\n+    let inputs = fn_sig.inputs();\n+    if inputs.len() != 1 {\n+        let span = tcx.def_span(fn_id);\n+        let span = tcx.sess.source_map().guess_head_span(span);\n+        tcx.sess.span_err(span, \"function should have one argument\");\n+        return;\n+    }\n+\n+    let arg_is_alloc_layout = match inputs[0].kind() {\n+        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n+        _ => false,\n+    };\n+\n+    if !arg_is_alloc_layout {\n+        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n+    }\n+\n+    let DefKind::Fn = tcx.def_kind(fn_id) else {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"`#[alloc_error_handler]` should be a function\");\n+        return;\n+    };\n+\n+    let generic_counts = tcx.generics_of(fn_id).own_counts();\n+    if generic_counts.types != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"`#[alloc_error_handler]` function should have no type parameters\");\n+    }\n+    if generic_counts.consts != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess\n+            .span_err(span, \"`#[alloc_error_handler]` function should have no const parameters\");\n+    }\n }\n \n fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) {"}, {"sha": "4d17307ddb968bd72993d422bdea2dbfba07be3f", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b86c6f21e407e5da617a55aa172e85327b473db/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b86c6f21e407e5da617a55aa172e85327b473db/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=7b86c6f21e407e5da617a55aa172e85327b473db", "patch": "@@ -660,8 +660,24 @@ fn compare_number_of_generics<'tcx>(\n                     _ => None,\n                 })\n                 .collect();\n-            let spans = impl_item.generics.spans();\n-            let span = spans.primary_span();\n+            let spans = if impl_item.generics.params.is_empty() {\n+                vec![impl_item.generics.span]\n+            } else {\n+                impl_item\n+                    .generics\n+                    .params\n+                    .iter()\n+                    .filter(|p| {\n+                        matches!(\n+                            p.kind,\n+                            hir::GenericParamKind::Type { .. }\n+                                | hir::GenericParamKind::Const { .. }\n+                        )\n+                    })\n+                    .map(|p| p.span)\n+                    .collect::<Vec<Span>>()\n+            };\n+            let span = spans.first().copied();\n \n             let mut err = tcx.sess.struct_span_err_with_code(\n                 spans,"}, {"sha": "76d39c88b61c3e38863642186da8178524577030", "filename": "src/test/ui/generic-associated-types/parameter_number_and_kind_impl.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b86c6f21e407e5da617a55aa172e85327b473db/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b86c6f21e407e5da617a55aa172e85327b473db/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr?ref=7b86c6f21e407e5da617a55aa172e85327b473db", "patch": "@@ -8,17 +8,15 @@ LL |     type A = u32;\n    |           ^ lifetimes do not match type in trait\n \n error[E0049]: type `B` has 1 type parameter but its trait declaration has 0 type parameters\n-  --> $DIR/parameter_number_and_kind_impl.rs:17:12\n+  --> $DIR/parameter_number_and_kind_impl.rs:17:16\n    |\n LL |     type B<'a, 'b>;\n    |            --  --\n    |            |\n    |            expected 0 type parameters\n ...\n LL |     type B<'a, T> = Vec<T>;\n-   |            ^^  ^\n-   |            |\n-   |            found 1 type parameter\n+   |                ^ found 1 type parameter\n \n error[E0195]: lifetime parameters or bounds on type `C` do not match the trait declaration\n   --> $DIR/parameter_number_and_kind_impl.rs:19:11"}]}