{"sha": "ff369236a3895e144ef2ba1d8a24727e27e61f1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMzY5MjM2YTM4OTVlMTQ0ZWYyYmExZDhhMjQ3MjdlMjdlNjFmMWM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-26T11:49:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-11T22:09:22Z"}, "message": "Move lang_items definitions to librustc_lang_items.", "tree": {"sha": "937bc4eb8e2b7d0bfa64954dccc2999e8fe064ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/937bc4eb8e2b7d0bfa64954dccc2999e8fe064ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff369236a3895e144ef2ba1d8a24727e27e61f1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff369236a3895e144ef2ba1d8a24727e27e61f1c", "html_url": "https://github.com/rust-lang/rust/commit/ff369236a3895e144ef2ba1d8a24727e27e61f1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff369236a3895e144ef2ba1d8a24727e27e61f1c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a056817aaed18914b43980bc0f5645202a0b7bad", "url": "https://api.github.com/repos/rust-lang/rust/commits/a056817aaed18914b43980bc0f5645202a0b7bad", "html_url": "https://github.com/rust-lang/rust/commit/a056817aaed18914b43980bc0f5645202a0b7bad"}], "stats": {"total": 660, "additions": 372, "deletions": 288}, "files": [{"sha": "fa50632e9db82defc0d48a0b439524e57ba0d5fa", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=ff369236a3895e144ef2ba1d8a24727e27e61f1c", "patch": "@@ -107,6 +107,8 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n     }\n }\n \n+impl<'ctx> rustc_lang_items::HashStableContext for StableHashingContext<'ctx> {}\n+\n impl<'a> ToStableHashKey<StableHashingContext<'a>> for DefId {\n     type KeyType = DefPathHash;\n \n@@ -251,12 +253,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::def_id::DefIndex {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::LangItem {\n-    fn hash_stable(&self, _: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        ::std::hash::Hash::hash(self, hasher);\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {"}, {"sha": "aa235f545b537e6c30417f7a80a832b8508ee2ec", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 56, "deletions": 268, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=ff369236a3895e144ef2ba1d8a24727e27e61f1c", "patch": "@@ -13,139 +13,64 @@ use crate::middle::cstore::ExternCrate;\n use crate::middle::weak_lang_items;\n use crate::ty::{self, TyCtxt};\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_lang_items::lang_items::ITEM_REFS;\n use rustc_lang_items::Target;\n-use rustc_macros::HashStable;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use syntax::ast;\n \n-// The actual lang items defined come at the end of this file in one handy table.\n-// So you probably just want to nip down to the end.\n-macro_rules! language_item_table {\n-    (\n-        $( $variant:ident, $name:expr, $method:ident, $target:path; )*\n-    ) => {\n-\n-enum_from_u32! {\n-    /// A representation of all the valid language items in Rust.\n-    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-    pub enum LangItem {\n-        $($variant,)*\n-    }\n-}\n-\n-impl LangItem {\n-    /// Returns the `name` in `#[lang = \"$name\"]`.\n-    /// For example, `LangItem::EqTraitLangItem`,\n-    /// that is `#[lang = \"eq\"]` would result in `\"eq\"`.\n-    fn name(self) -> &'static str {\n-        match self {\n-            $( $variant => $name, )*\n-        }\n-    }\n-}\n-\n-#[derive(HashStable)]\n-pub struct LanguageItems {\n-    /// Mappings from lang items to their possibly found `DefId`s.\n-    /// The index corresponds to the order in `LangItem`.\n-    pub items: Vec<Option<DefId>>,\n-    /// Lang items that were not found during collection.\n-    pub missing: Vec<LangItem>,\n-}\n-\n-impl LanguageItems {\n-    /// Construct an empty collection of lang items and no missing ones.\n-    pub fn new() -> Self {\n-        fn init_none(_: LangItem) -> Option<DefId> { None }\n-\n-        Self {\n-            items: vec![$(init_none($variant)),*],\n-            missing: Vec::new(),\n-        }\n-    }\n-\n-    /// Returns the mappings to the possibly found `DefId`s for each lang item.\n-    pub fn items(&self) -> &[Option<DefId>] {\n-        &*self.items\n-    }\n-\n-    /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n-    /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n-    /// returns an error message as a string.\n-    pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n-        self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n-    }\n-\n-    /// Returns the kind of closure that `id`, which is one of the `Fn*` traits, corresponds to.\n-    /// If `id` is not one of the `Fn*` traits, `None` is returned.\n-    pub fn fn_trait_kind(&self, id: DefId) -> Option<ty::ClosureKind> {\n-        match Some(id) {\n-            x if x == self.fn_trait() => Some(ty::ClosureKind::Fn),\n-            x if x == self.fn_mut_trait() => Some(ty::ClosureKind::FnMut),\n-            x if x == self.fn_once_trait() => Some(ty::ClosureKind::FnOnce),\n-            _ => None\n-        }\n-    }\n-\n-    $(\n-        /// Returns the corresponding `DefId` for the lang item\n-        #[doc = $name]\n-        /// if it exists.\n-        #[allow(dead_code)]\n-        pub fn $method(&self) -> Option<DefId> {\n-            self.items[$variant as usize]\n-        }\n-    )*\n-}\n+pub use rustc_lang_items::{LangItem, LanguageItems};\n \n struct LanguageItemCollector<'tcx> {\n     items: LanguageItems,\n     tcx: TyCtxt<'tcx>,\n-    /// A mapping from the name of the lang item to its order and the form it must be of.\n-    item_refs: FxHashMap<&'static str, (usize, Target)>,\n }\n \n impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let Some((value, span)) = extract(&item.attrs) {\n             let actual_target = Target::from_item(item);\n-            match self.item_refs.get(&*value.as_str()).cloned() {\n+            match ITEM_REFS.get(&*value.as_str()).cloned() {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {\n                     let def_id = self.tcx.hir().local_def_id(item.hir_id);\n                     self.collect_item(item_index, def_id);\n-                },\n+                }\n                 // Known lang item with attribute on incorrect target.\n                 Some((_, expected_target)) => {\n                     struct_span_err!(\n-                        self.tcx.sess, span, E0718,\n+                        self.tcx.sess,\n+                        span,\n+                        E0718,\n                         \"`{}` language item must be applied to a {}\",\n-                        value, expected_target,\n-                    ).span_label(\n+                        value,\n+                        expected_target,\n+                    )\n+                    .span_label(\n                         span,\n                         format!(\n                             \"attribute should be applied to a {}, not a {}\",\n                             expected_target, actual_target,\n                         ),\n-                    ).emit();\n-                },\n+                    )\n+                    .emit();\n+                }\n                 // Unknown lang item.\n                 _ => {\n                     struct_span_err!(\n-                        self.tcx.sess, span, E0522,\n+                        self.tcx.sess,\n+                        span,\n+                        E0522,\n                         \"definition of an unknown language item: `{}`\",\n                         value\n-                    ).span_label(\n-                        span,\n-                        format!(\"definition of unknown language item `{}`\", value)\n-                    ).emit();\n-                },\n+                    )\n+                    .span_label(span, format!(\"definition of unknown language item `{}`\", value))\n+                    .emit();\n+                }\n             }\n         }\n     }\n@@ -161,15 +86,7 @@ impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n \n impl LanguageItemCollector<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> LanguageItemCollector<'tcx> {\n-        let mut item_refs = FxHashMap::default();\n-\n-        $( item_refs.insert($name, ($variant as usize, $target)); )*\n-\n-        LanguageItemCollector {\n-            tcx,\n-            items: LanguageItems::new(),\n-            item_refs,\n-        }\n+        LanguageItemCollector { tcx, items: LanguageItems::new() }\n     }\n \n     fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n@@ -185,37 +102,37 @@ impl LanguageItemCollector<'tcx> {\n                         \"found duplicate lang item `{}`\",\n                         name\n                     ),\n-                    None => {\n-                        match self.tcx.extern_crate(item_def_id) {\n-                            Some(ExternCrate {dependency_of, ..}) => {\n-                                self.tcx.sess.struct_err(&format!(\n+                    None => match self.tcx.extern_crate(item_def_id) {\n+                        Some(ExternCrate { dependency_of, .. }) => {\n+                            self.tcx.sess.struct_err(&format!(\n                                 \"duplicate lang item in crate `{}` (which `{}` depends on): `{}`.\",\n                                 self.tcx.crate_name(item_def_id.krate),\n                                 self.tcx.crate_name(*dependency_of),\n-                                name))\n-                            },\n-                            _ => {\n-                                self.tcx.sess.struct_err(&format!(\n-                                \"duplicate lang item in crate `{}`: `{}`.\",\n-                                self.tcx.crate_name(item_def_id.krate),\n-                                name))\n-                            }\n+                                name\n+                            ))\n                         }\n+                        _ => self.tcx.sess.struct_err(&format!(\n+                            \"duplicate lang item in crate `{}`: `{}`.\",\n+                            self.tcx.crate_name(item_def_id.krate),\n+                            name\n+                        )),\n                     },\n                 };\n                 if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n                     err.span_note(span, \"the lang item is first defined here\");\n                 } else {\n                     match self.tcx.extern_crate(original_def_id) {\n-                        Some(ExternCrate {dependency_of, ..}) => {\n+                        Some(ExternCrate { dependency_of, .. }) => {\n                             err.note(&format!(\n                             \"the lang item is first defined in crate `{}` (which `{}` depends on)\",\n                                       self.tcx.crate_name(original_def_id.krate),\n                                       self.tcx.crate_name(*dependency_of)));\n-                        },\n+                        }\n                         _ => {\n-                            err.note(&format!(\"the lang item is first defined in crate `{}`.\",\n-                                      self.tcx.crate_name(original_def_id.krate)));\n+                            err.note(&format!(\n+                                \"the lang item is first defined in crate `{}`.\",\n+                                self.tcx.crate_name(original_def_id.krate)\n+                            ));\n                         }\n                     }\n                 }\n@@ -232,12 +149,14 @@ impl LanguageItemCollector<'tcx> {\n /// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n /// are also extracted out when found.\n pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n-    attrs.iter().find_map(|attr| Some(match attr {\n-        _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n-        _ if attr.check_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n-        _ if attr.check_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n-        _ => return None,\n-    }))\n+    attrs.iter().find_map(|attr| {\n+        Some(match attr {\n+            _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n+            _ if attr.check_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n+            _ if attr.check_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n+            _ => return None,\n+        })\n+    })\n }\n \n /// Traverses and collects all the lang items in all crates.\n@@ -264,147 +183,6 @@ pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n     items\n }\n \n-// End of the macro\n-    }\n-}\n-\n-language_item_table! {\n-//  Variant name,                Name,                 Method name,             Target;\n-    BoolImplItem,                \"bool\",               bool_impl,               Target::Impl;\n-    CharImplItem,                \"char\",               char_impl,               Target::Impl;\n-    StrImplItem,                 \"str\",                str_impl,                Target::Impl;\n-    SliceImplItem,               \"slice\",              slice_impl,              Target::Impl;\n-    SliceU8ImplItem,             \"slice_u8\",           slice_u8_impl,           Target::Impl;\n-    StrAllocImplItem,            \"str_alloc\",          str_alloc_impl,          Target::Impl;\n-    SliceAllocImplItem,          \"slice_alloc\",        slice_alloc_impl,        Target::Impl;\n-    SliceU8AllocImplItem,        \"slice_u8_alloc\",     slice_u8_alloc_impl,     Target::Impl;\n-    ConstPtrImplItem,            \"const_ptr\",          const_ptr_impl,          Target::Impl;\n-    MutPtrImplItem,              \"mut_ptr\",            mut_ptr_impl,            Target::Impl;\n-    I8ImplItem,                  \"i8\",                 i8_impl,                 Target::Impl;\n-    I16ImplItem,                 \"i16\",                i16_impl,                Target::Impl;\n-    I32ImplItem,                 \"i32\",                i32_impl,                Target::Impl;\n-    I64ImplItem,                 \"i64\",                i64_impl,                Target::Impl;\n-    I128ImplItem,                \"i128\",               i128_impl,               Target::Impl;\n-    IsizeImplItem,               \"isize\",              isize_impl,              Target::Impl;\n-    U8ImplItem,                  \"u8\",                 u8_impl,                 Target::Impl;\n-    U16ImplItem,                 \"u16\",                u16_impl,                Target::Impl;\n-    U32ImplItem,                 \"u32\",                u32_impl,                Target::Impl;\n-    U64ImplItem,                 \"u64\",                u64_impl,                Target::Impl;\n-    U128ImplItem,                \"u128\",               u128_impl,               Target::Impl;\n-    UsizeImplItem,               \"usize\",              usize_impl,              Target::Impl;\n-    F32ImplItem,                 \"f32\",                f32_impl,                Target::Impl;\n-    F64ImplItem,                 \"f64\",                f64_impl,                Target::Impl;\n-    F32RuntimeImplItem,          \"f32_runtime\",        f32_runtime_impl,        Target::Impl;\n-    F64RuntimeImplItem,          \"f64_runtime\",        f64_runtime_impl,        Target::Impl;\n-\n-    SizedTraitLangItem,          \"sized\",              sized_trait,             Target::Trait;\n-    UnsizeTraitLangItem,         \"unsize\",             unsize_trait,            Target::Trait;\n-    // trait injected by #[derive(PartialEq)], (i.e. \"Partial EQ\").\n-    StructuralPeqTraitLangItem,  \"structural_peq\",     structural_peq_trait,    Target::Trait;\n-    // trait injected by #[derive(Eq)], (i.e. \"Total EQ\"; no, I will not apologize).\n-    StructuralTeqTraitLangItem,  \"structural_teq\",     structural_teq_trait,    Target::Trait;\n-    CopyTraitLangItem,           \"copy\",               copy_trait,              Target::Trait;\n-    CloneTraitLangItem,          \"clone\",              clone_trait,             Target::Trait;\n-    SyncTraitLangItem,           \"sync\",               sync_trait,              Target::Trait;\n-    FreezeTraitLangItem,         \"freeze\",             freeze_trait,            Target::Trait;\n-\n-    DropTraitLangItem,           \"drop\",               drop_trait,              Target::Trait;\n-\n-    CoerceUnsizedTraitLangItem,  \"coerce_unsized\",     coerce_unsized_trait,    Target::Trait;\n-    DispatchFromDynTraitLangItem,\"dispatch_from_dyn\",  dispatch_from_dyn_trait, Target::Trait;\n-\n-    AddTraitLangItem,            \"add\",                add_trait,               Target::Trait;\n-    SubTraitLangItem,            \"sub\",                sub_trait,               Target::Trait;\n-    MulTraitLangItem,            \"mul\",                mul_trait,               Target::Trait;\n-    DivTraitLangItem,            \"div\",                div_trait,               Target::Trait;\n-    RemTraitLangItem,            \"rem\",                rem_trait,               Target::Trait;\n-    NegTraitLangItem,            \"neg\",                neg_trait,               Target::Trait;\n-    NotTraitLangItem,            \"not\",                not_trait,               Target::Trait;\n-    BitXorTraitLangItem,         \"bitxor\",             bitxor_trait,            Target::Trait;\n-    BitAndTraitLangItem,         \"bitand\",             bitand_trait,            Target::Trait;\n-    BitOrTraitLangItem,          \"bitor\",              bitor_trait,             Target::Trait;\n-    ShlTraitLangItem,            \"shl\",                shl_trait,               Target::Trait;\n-    ShrTraitLangItem,            \"shr\",                shr_trait,               Target::Trait;\n-    AddAssignTraitLangItem,      \"add_assign\",         add_assign_trait,        Target::Trait;\n-    SubAssignTraitLangItem,      \"sub_assign\",         sub_assign_trait,        Target::Trait;\n-    MulAssignTraitLangItem,      \"mul_assign\",         mul_assign_trait,        Target::Trait;\n-    DivAssignTraitLangItem,      \"div_assign\",         div_assign_trait,        Target::Trait;\n-    RemAssignTraitLangItem,      \"rem_assign\",         rem_assign_trait,        Target::Trait;\n-    BitXorAssignTraitLangItem,   \"bitxor_assign\",      bitxor_assign_trait,     Target::Trait;\n-    BitAndAssignTraitLangItem,   \"bitand_assign\",      bitand_assign_trait,     Target::Trait;\n-    BitOrAssignTraitLangItem,    \"bitor_assign\",       bitor_assign_trait,      Target::Trait;\n-    ShlAssignTraitLangItem,      \"shl_assign\",         shl_assign_trait,        Target::Trait;\n-    ShrAssignTraitLangItem,      \"shr_assign\",         shr_assign_trait,        Target::Trait;\n-    IndexTraitLangItem,          \"index\",              index_trait,             Target::Trait;\n-    IndexMutTraitLangItem,       \"index_mut\",          index_mut_trait,         Target::Trait;\n-\n-    UnsafeCellTypeLangItem,      \"unsafe_cell\",        unsafe_cell_type,        Target::Struct;\n-    VaListTypeLangItem,          \"va_list\",            va_list,                 Target::Struct;\n-\n-    DerefTraitLangItem,          \"deref\",              deref_trait,             Target::Trait;\n-    DerefMutTraitLangItem,       \"deref_mut\",          deref_mut_trait,         Target::Trait;\n-    ReceiverTraitLangItem,       \"receiver\",           receiver_trait,          Target::Trait;\n-\n-    FnTraitLangItem,             \"fn\",                 fn_trait,                Target::Trait;\n-    FnMutTraitLangItem,          \"fn_mut\",             fn_mut_trait,            Target::Trait;\n-    FnOnceTraitLangItem,         \"fn_once\",            fn_once_trait,           Target::Trait;\n-\n-    FutureTraitLangItem,         \"future_trait\",       future_trait,            Target::Trait;\n-    GeneratorStateLangItem,      \"generator_state\",    gen_state,               Target::Enum;\n-    GeneratorTraitLangItem,      \"generator\",          gen_trait,               Target::Trait;\n-    UnpinTraitLangItem,          \"unpin\",              unpin_trait,             Target::Trait;\n-    PinTypeLangItem,             \"pin\",                pin_type,                Target::Struct;\n-\n-    // Don't be fooled by the naming here: this lang item denotes `PartialEq`, not `Eq`.\n-    EqTraitLangItem,             \"eq\",                 eq_trait,                Target::Trait;\n-    PartialOrdTraitLangItem,     \"partial_ord\",        partial_ord_trait,       Target::Trait;\n-\n-    // A number of panic-related lang items. The `panic` item corresponds to\n-    // divide-by-zero and various panic cases with `match`. The\n-    // `panic_bounds_check` item is for indexing arrays.\n-    //\n-    // The `begin_unwind` lang item has a predefined symbol name and is sort of\n-    // a \"weak lang item\" in the sense that a crate is not required to have it\n-    // defined to use it, but a final product is required to define it\n-    // somewhere. Additionally, there are restrictions on crates that use a weak\n-    // lang item, but do not have it defined.\n-    PanicFnLangItem,             \"panic\",              panic_fn,                Target::Fn;\n-    PanicBoundsCheckFnLangItem,  \"panic_bounds_check\", panic_bounds_check_fn,   Target::Fn;\n-    PanicInfoLangItem,           \"panic_info\",         panic_info,              Target::Struct;\n-    PanicLocationLangItem,       \"panic_location\",     panic_location,          Target::Struct;\n-    PanicImplLangItem,           \"panic_impl\",         panic_impl,              Target::Fn;\n-    // Libstd panic entry point. Necessary for const eval to be able to catch it\n-    BeginPanicFnLangItem,        \"begin_panic\",        begin_panic_fn,          Target::Fn;\n-\n-    ExchangeMallocFnLangItem,    \"exchange_malloc\",    exchange_malloc_fn,      Target::Fn;\n-    BoxFreeFnLangItem,           \"box_free\",           box_free_fn,             Target::Fn;\n-    DropInPlaceFnLangItem,       \"drop_in_place\",      drop_in_place_fn,        Target::Fn;\n-    OomLangItem,                 \"oom\",                oom,                     Target::Fn;\n-    AllocLayoutLangItem,         \"alloc_layout\",       alloc_layout,            Target::Struct;\n-\n-    StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n-\n-    EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n-    EhUnwindResumeLangItem,      \"eh_unwind_resume\",   eh_unwind_resume,        Target::Fn;\n-    EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n-\n-    OwnedBoxLangItem,            \"owned_box\",          owned_box,               Target::Struct;\n-\n-    PhantomDataItem,             \"phantom_data\",       phantom_data,            Target::Struct;\n-\n-    ManuallyDropItem,            \"manually_drop\",      manually_drop,           Target::Struct;\n-\n-    MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n-\n-    // Align offset for stride != 1; must not panic.\n-    AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n-\n-    TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n-\n-    Arc,                         \"arc\",                arc,                     Target::Struct;\n-    Rc,                          \"rc\",                 rc,                      Target::Struct;\n-}\n-\n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n     /// If not found, fatally aborts compilation.\n@@ -417,4 +195,14 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         })\n     }\n+\n+    pub fn fn_trait_lang_item(&self, id: DefId) -> Option<ty::ClosureKind> {\n+        let items = self.lang_items();\n+        match Some(id) {\n+            x if x == items.fn_trait() => Some(ty::ClosureKind::Fn),\n+            x if x == items.fn_mut_trait() => Some(ty::ClosureKind::FnMut),\n+            x if x == items.fn_once_trait() => Some(ty::ClosureKind::FnOnce),\n+            _ => None,\n+        }\n+    }\n }"}, {"sha": "82bf0d200d75f49c0408531ac122c1395cf81f37", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=ff369236a3895e144ef2ba1d8a24727e27e61f1c", "patch": "@@ -46,7 +46,7 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>,\n }\n \n pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n-    lang_items::extract(attrs).and_then(|(name, _)| {\n+    rustc_lang_items::lang_items::extract(attrs).and_then(|(name, _)| {\n         $(if name == sym::$name {\n             Some(sym::$sym)\n         } else)* {"}, {"sha": "4c4947d134fcc6e1c471d64ff835e40b434058d1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=ff369236a3895e144ef2ba1d8a24727e27e61f1c", "patch": "@@ -1634,7 +1634,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n-        let kind = match self.tcx().lang_items().fn_trait_kind(obligation.predicate.def_id()) {\n+        let kind = match self.tcx().fn_trait_lang_item(obligation.predicate.def_id()) {\n             Some(k) => k,\n             None => {\n                 return Ok(());\n@@ -1677,7 +1677,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n         // We provide impl of all fn traits for fn pointers.\n-        if self.tcx().lang_items().fn_trait_kind(obligation.predicate.def_id()).is_none() {\n+        if self.tcx().fn_trait_lang_item(obligation.predicate.def_id()).is_none() {\n             return Ok(());\n         }\n \n@@ -2889,8 +2889,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let kind = self\n             .tcx()\n-            .lang_items()\n-            .fn_trait_kind(obligation.predicate.def_id())\n+            .fn_trait_lang_item(obligation.predicate.def_id())\n             .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n \n         // Okay to skip binder because the substs on closure types never"}, {"sha": "b175de6e0e88c007310b50b7dbc035155a64782f", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=ff369236a3895e144ef2ba1d8a24727e27e61f1c", "patch": "@@ -450,7 +450,7 @@ fn resolve_associated_item<'tcx>(\n             substs: generator_data.substs,\n         }),\n         traits::VtableClosure(closure_data) => {\n-            let trait_closure_kind = tcx.lang_items().fn_trait_kind(trait_id).unwrap();\n+            let trait_closure_kind = tcx.fn_trait_lang_item(trait_id).unwrap();\n             Some(Instance::resolve_closure(\n                 tcx,\n                 closure_data.closure_def_id,"}, {"sha": "2a43d0486d06b57b41748004e4416e2c4be4c26a", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=ff369236a3895e144ef2ba1d8a24727e27e61f1c", "patch": "@@ -724,7 +724,7 @@ pub trait PrettyPrinter<'tcx>:\n             let mut resugared = false;\n \n             // Special-case `Fn(...) -> ...` and resugar it.\n-            let fn_trait_kind = self.tcx().lang_items().fn_trait_kind(principal.def_id);\n+            let fn_trait_kind = self.tcx().fn_trait_lang_item(principal.def_id);\n             if !self.tcx().sess.verbose() && fn_trait_kind.is_some() {\n                 if let ty::Tuple(ref args) = principal.substs.type_at(0).kind {\n                     let mut projections = predicates.projection_bounds();"}, {"sha": "6cccad73fcbad8730c99acf5633f8406ca9aa1f9", "filename": "src/librustc_lang_items/lang_items.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc_lang_items%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc_lang_items%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lang_items%2Flang_items.rs?ref=ff369236a3895e144ef2ba1d8a24727e27e61f1c", "patch": "@@ -0,0 +1,261 @@\n+//! Detecting language items.\n+//!\n+//! Language items are items that represent concepts intrinsic to the language\n+//! itself. Examples are:\n+//!\n+//! * Traits that specify \"kinds\"; e.g., `Sync`, `Send`.\n+//! * Traits that represent operators; e.g., `Add`, `Sub`, `Index`.\n+//! * Functions called by the compiler itself.\n+\n+pub use self::LangItem::*;\n+\n+use crate::Target;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_hir::def_id::DefId;\n+use rustc_macros::HashStable_Generic;\n+use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::Span;\n+use syntax::ast;\n+\n+use lazy_static::lazy_static;\n+\n+// The actual lang items defined come at the end of this file in one handy table.\n+// So you probably just want to nip down to the end.\n+macro_rules! language_item_table {\n+    (\n+        $( $variant:ident, $name:expr, $method:ident, $target:path; )*\n+    ) => {\n+\n+enum_from_u32! {\n+    /// A representation of all the valid language items in Rust.\n+    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+    pub enum LangItem {\n+        $($variant,)*\n+    }\n+}\n+\n+impl LangItem {\n+    /// Returns the `name` in `#[lang = \"$name\"]`.\n+    /// For example, `LangItem::EqTraitLangItem`,\n+    /// that is `#[lang = \"eq\"]` would result in `\"eq\"`.\n+    pub fn name(self) -> &'static str {\n+        match self {\n+            $( $variant => $name, )*\n+        }\n+    }\n+}\n+\n+#[derive(HashStable_Generic)]\n+pub struct LanguageItems {\n+    /// Mappings from lang items to their possibly found `DefId`s.\n+    /// The index corresponds to the order in `LangItem`.\n+    pub items: Vec<Option<DefId>>,\n+    /// Lang items that were not found during collection.\n+    pub missing: Vec<LangItem>,\n+}\n+\n+impl LanguageItems {\n+    /// Construct an empty collection of lang items and no missing ones.\n+    pub fn new() -> Self {\n+        fn init_none(_: LangItem) -> Option<DefId> { None }\n+\n+        Self {\n+            items: vec![$(init_none($variant)),*],\n+            missing: Vec::new(),\n+        }\n+    }\n+\n+    /// Returns the mappings to the possibly found `DefId`s for each lang item.\n+    pub fn items(&self) -> &[Option<DefId>] {\n+        &*self.items\n+    }\n+\n+    /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n+    /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n+    /// returns an error message as a string.\n+    pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n+        self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n+    }\n+\n+    $(\n+        /// Returns the corresponding `DefId` for the lang item\n+        #[doc = $name]\n+        /// if it exists.\n+        #[allow(dead_code)]\n+        pub fn $method(&self) -> Option<DefId> {\n+            self.items[$variant as usize]\n+        }\n+    )*\n+}\n+\n+lazy_static! {\n+    /// A mapping from the name of the lang item to its order and the form it must be of.\n+    pub static ref ITEM_REFS: FxHashMap<&'static str, (usize, Target)> = {\n+        let mut item_refs = FxHashMap::default();\n+        $( item_refs.insert($name, ($variant as usize, $target)); )*\n+        item_refs\n+    };\n+}\n+\n+// End of the macro\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for LangItem {\n+    fn hash_stable(&self, _: &mut CTX, hasher: &mut StableHasher) {\n+        ::std::hash::Hash::hash(self, hasher);\n+    }\n+}\n+\n+/// Extracts the first `lang = \"$name\"` out of a list of attributes.\n+/// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n+/// are also extracted out when found.\n+pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n+    attrs.iter().find_map(|attr| {\n+        Some(match attr {\n+            _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n+            _ if attr.check_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n+            _ if attr.check_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n+            _ => return None,\n+        })\n+    })\n+}\n+\n+language_item_table! {\n+//  Variant name,                Name,                 Method name,             Target;\n+    BoolImplItem,                \"bool\",               bool_impl,               Target::Impl;\n+    CharImplItem,                \"char\",               char_impl,               Target::Impl;\n+    StrImplItem,                 \"str\",                str_impl,                Target::Impl;\n+    SliceImplItem,               \"slice\",              slice_impl,              Target::Impl;\n+    SliceU8ImplItem,             \"slice_u8\",           slice_u8_impl,           Target::Impl;\n+    StrAllocImplItem,            \"str_alloc\",          str_alloc_impl,          Target::Impl;\n+    SliceAllocImplItem,          \"slice_alloc\",        slice_alloc_impl,        Target::Impl;\n+    SliceU8AllocImplItem,        \"slice_u8_alloc\",     slice_u8_alloc_impl,     Target::Impl;\n+    ConstPtrImplItem,            \"const_ptr\",          const_ptr_impl,          Target::Impl;\n+    MutPtrImplItem,              \"mut_ptr\",            mut_ptr_impl,            Target::Impl;\n+    I8ImplItem,                  \"i8\",                 i8_impl,                 Target::Impl;\n+    I16ImplItem,                 \"i16\",                i16_impl,                Target::Impl;\n+    I32ImplItem,                 \"i32\",                i32_impl,                Target::Impl;\n+    I64ImplItem,                 \"i64\",                i64_impl,                Target::Impl;\n+    I128ImplItem,                \"i128\",               i128_impl,               Target::Impl;\n+    IsizeImplItem,               \"isize\",              isize_impl,              Target::Impl;\n+    U8ImplItem,                  \"u8\",                 u8_impl,                 Target::Impl;\n+    U16ImplItem,                 \"u16\",                u16_impl,                Target::Impl;\n+    U32ImplItem,                 \"u32\",                u32_impl,                Target::Impl;\n+    U64ImplItem,                 \"u64\",                u64_impl,                Target::Impl;\n+    U128ImplItem,                \"u128\",               u128_impl,               Target::Impl;\n+    UsizeImplItem,               \"usize\",              usize_impl,              Target::Impl;\n+    F32ImplItem,                 \"f32\",                f32_impl,                Target::Impl;\n+    F64ImplItem,                 \"f64\",                f64_impl,                Target::Impl;\n+    F32RuntimeImplItem,          \"f32_runtime\",        f32_runtime_impl,        Target::Impl;\n+    F64RuntimeImplItem,          \"f64_runtime\",        f64_runtime_impl,        Target::Impl;\n+\n+    SizedTraitLangItem,          \"sized\",              sized_trait,             Target::Trait;\n+    UnsizeTraitLangItem,         \"unsize\",             unsize_trait,            Target::Trait;\n+    // trait injected by #[derive(PartialEq)], (i.e. \"Partial EQ\").\n+    StructuralPeqTraitLangItem,  \"structural_peq\",     structural_peq_trait,    Target::Trait;\n+    // trait injected by #[derive(Eq)], (i.e. \"Total EQ\"; no, I will not apologize).\n+    StructuralTeqTraitLangItem,  \"structural_teq\",     structural_teq_trait,    Target::Trait;\n+    CopyTraitLangItem,           \"copy\",               copy_trait,              Target::Trait;\n+    CloneTraitLangItem,          \"clone\",              clone_trait,             Target::Trait;\n+    SyncTraitLangItem,           \"sync\",               sync_trait,              Target::Trait;\n+    FreezeTraitLangItem,         \"freeze\",             freeze_trait,            Target::Trait;\n+\n+    DropTraitLangItem,           \"drop\",               drop_trait,              Target::Trait;\n+\n+    CoerceUnsizedTraitLangItem,  \"coerce_unsized\",     coerce_unsized_trait,    Target::Trait;\n+    DispatchFromDynTraitLangItem,\"dispatch_from_dyn\",  dispatch_from_dyn_trait, Target::Trait;\n+\n+    AddTraitLangItem,            \"add\",                add_trait,               Target::Trait;\n+    SubTraitLangItem,            \"sub\",                sub_trait,               Target::Trait;\n+    MulTraitLangItem,            \"mul\",                mul_trait,               Target::Trait;\n+    DivTraitLangItem,            \"div\",                div_trait,               Target::Trait;\n+    RemTraitLangItem,            \"rem\",                rem_trait,               Target::Trait;\n+    NegTraitLangItem,            \"neg\",                neg_trait,               Target::Trait;\n+    NotTraitLangItem,            \"not\",                not_trait,               Target::Trait;\n+    BitXorTraitLangItem,         \"bitxor\",             bitxor_trait,            Target::Trait;\n+    BitAndTraitLangItem,         \"bitand\",             bitand_trait,            Target::Trait;\n+    BitOrTraitLangItem,          \"bitor\",              bitor_trait,             Target::Trait;\n+    ShlTraitLangItem,            \"shl\",                shl_trait,               Target::Trait;\n+    ShrTraitLangItem,            \"shr\",                shr_trait,               Target::Trait;\n+    AddAssignTraitLangItem,      \"add_assign\",         add_assign_trait,        Target::Trait;\n+    SubAssignTraitLangItem,      \"sub_assign\",         sub_assign_trait,        Target::Trait;\n+    MulAssignTraitLangItem,      \"mul_assign\",         mul_assign_trait,        Target::Trait;\n+    DivAssignTraitLangItem,      \"div_assign\",         div_assign_trait,        Target::Trait;\n+    RemAssignTraitLangItem,      \"rem_assign\",         rem_assign_trait,        Target::Trait;\n+    BitXorAssignTraitLangItem,   \"bitxor_assign\",      bitxor_assign_trait,     Target::Trait;\n+    BitAndAssignTraitLangItem,   \"bitand_assign\",      bitand_assign_trait,     Target::Trait;\n+    BitOrAssignTraitLangItem,    \"bitor_assign\",       bitor_assign_trait,      Target::Trait;\n+    ShlAssignTraitLangItem,      \"shl_assign\",         shl_assign_trait,        Target::Trait;\n+    ShrAssignTraitLangItem,      \"shr_assign\",         shr_assign_trait,        Target::Trait;\n+    IndexTraitLangItem,          \"index\",              index_trait,             Target::Trait;\n+    IndexMutTraitLangItem,       \"index_mut\",          index_mut_trait,         Target::Trait;\n+\n+    UnsafeCellTypeLangItem,      \"unsafe_cell\",        unsafe_cell_type,        Target::Struct;\n+    VaListTypeLangItem,          \"va_list\",            va_list,                 Target::Struct;\n+\n+    DerefTraitLangItem,          \"deref\",              deref_trait,             Target::Trait;\n+    DerefMutTraitLangItem,       \"deref_mut\",          deref_mut_trait,         Target::Trait;\n+    ReceiverTraitLangItem,       \"receiver\",           receiver_trait,          Target::Trait;\n+\n+    FnTraitLangItem,             \"fn\",                 fn_trait,                Target::Trait;\n+    FnMutTraitLangItem,          \"fn_mut\",             fn_mut_trait,            Target::Trait;\n+    FnOnceTraitLangItem,         \"fn_once\",            fn_once_trait,           Target::Trait;\n+\n+    FutureTraitLangItem,         \"future_trait\",       future_trait,            Target::Trait;\n+    GeneratorStateLangItem,      \"generator_state\",    gen_state,               Target::Enum;\n+    GeneratorTraitLangItem,      \"generator\",          gen_trait,               Target::Trait;\n+    UnpinTraitLangItem,          \"unpin\",              unpin_trait,             Target::Trait;\n+    PinTypeLangItem,             \"pin\",                pin_type,                Target::Struct;\n+\n+    // Don't be fooled by the naming here: this lang item denotes `PartialEq`, not `Eq`.\n+    EqTraitLangItem,             \"eq\",                 eq_trait,                Target::Trait;\n+    PartialOrdTraitLangItem,     \"partial_ord\",        partial_ord_trait,       Target::Trait;\n+\n+    // A number of panic-related lang items. The `panic` item corresponds to\n+    // divide-by-zero and various panic cases with `match`. The\n+    // `panic_bounds_check` item is for indexing arrays.\n+    //\n+    // The `begin_unwind` lang item has a predefined symbol name and is sort of\n+    // a \"weak lang item\" in the sense that a crate is not required to have it\n+    // defined to use it, but a final product is required to define it\n+    // somewhere. Additionally, there are restrictions on crates that use a weak\n+    // lang item, but do not have it defined.\n+    PanicFnLangItem,             \"panic\",              panic_fn,                Target::Fn;\n+    PanicBoundsCheckFnLangItem,  \"panic_bounds_check\", panic_bounds_check_fn,   Target::Fn;\n+    PanicInfoLangItem,           \"panic_info\",         panic_info,              Target::Struct;\n+    PanicLocationLangItem,       \"panic_location\",     panic_location,          Target::Struct;\n+    PanicImplLangItem,           \"panic_impl\",         panic_impl,              Target::Fn;\n+    // Libstd panic entry point. Necessary for const eval to be able to catch it\n+    BeginPanicFnLangItem,        \"begin_panic\",        begin_panic_fn,          Target::Fn;\n+\n+    ExchangeMallocFnLangItem,    \"exchange_malloc\",    exchange_malloc_fn,      Target::Fn;\n+    BoxFreeFnLangItem,           \"box_free\",           box_free_fn,             Target::Fn;\n+    DropInPlaceFnLangItem,       \"drop_in_place\",      drop_in_place_fn,        Target::Fn;\n+    OomLangItem,                 \"oom\",                oom,                     Target::Fn;\n+    AllocLayoutLangItem,         \"alloc_layout\",       alloc_layout,            Target::Struct;\n+\n+    StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n+\n+    EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n+    EhUnwindResumeLangItem,      \"eh_unwind_resume\",   eh_unwind_resume,        Target::Fn;\n+    EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n+\n+    OwnedBoxLangItem,            \"owned_box\",          owned_box,               Target::Struct;\n+\n+    PhantomDataItem,             \"phantom_data\",       phantom_data,            Target::Struct;\n+\n+    ManuallyDropItem,            \"manually_drop\",      manually_drop,           Target::Struct;\n+\n+    MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n+\n+    // Align offset for stride != 1; must not panic.\n+    AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n+\n+    TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n+\n+    Arc,                         \"arc\",                arc,                     Target::Struct;\n+    Rc,                          \"rc\",                 rc,                      Target::Struct;\n+}"}, {"sha": "90d090e6f61a19de1c9dcef4cc370bfe7df4759a", "filename": "src/librustc_lang_items/lib.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc_lang_items%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc_lang_items%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lang_items%2Flib.rs?ref=ff369236a3895e144ef2ba1d8a24727e27e61f1c", "patch": "@@ -1,3 +1,44 @@\n+macro_rules! enum_from_u32 {\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident = $e:expr,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant = $e),*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant,)*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+pub mod lang_items;\n mod target;\n \n+pub use lang_items::{LangItem, LanguageItems};\n pub use target::{MethodKind, Target};\n+\n+pub trait HashStableContext: rustc_hir::HashStableContext {}"}, {"sha": "cc5e142351d4f0f86f8b3439cf7183bc210634e5", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=ff369236a3895e144ef2ba1d8a24727e27e61f1c", "patch": "@@ -40,7 +40,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n         ),\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n-            let adjustment = match tcx.lang_items().fn_trait_kind(trait_) {\n+            let adjustment = match tcx.fn_trait_lang_item(trait_) {\n                 Some(ty::ClosureKind::FnOnce) => Adjustment::Identity,\n                 Some(ty::ClosureKind::FnMut) | Some(ty::ClosureKind::Fn) => Adjustment::Deref,\n                 None => bug!(\"fn pointer {:?} is not an fn\", ty),"}, {"sha": "f601a0e8253c1378b843ff73551a56d419913a9b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=ff369236a3895e144ef2ba1d8a24727e27e61f1c", "patch": "@@ -174,9 +174,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.deduce_sig_from_projection(None, &pb)\n                     })\n                     .next();\n-                let kind = object_type\n-                    .principal_def_id()\n-                    .and_then(|did| self.tcx.lang_items().fn_trait_kind(did));\n+                let kind =\n+                    object_type.principal_def_id().and_then(|did| self.tcx.fn_trait_lang_item(did));\n                 (sig, kind)\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n@@ -214,7 +213,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // many viable options, so pick the most restrictive.\n         let expected_kind = self\n             .obligations_for_self_ty(expected_vid)\n-            .filter_map(|(tr, _)| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n+            .filter_map(|(tr, _)| self.tcx.fn_trait_lang_item(tr.def_id()))\n             .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n \n         (expected_sig, expected_kind)\n@@ -237,7 +236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let trait_ref = projection.to_poly_trait_ref(tcx);\n \n-        let is_fn = tcx.lang_items().fn_trait_kind(trait_ref.def_id()).is_some();\n+        let is_fn = tcx.fn_trait_lang_item(trait_ref.def_id()).is_some();\n         let gen_trait = tcx.require_lang_item(lang_items::GeneratorTraitLangItem, cause_span);\n         let is_gen = gen_trait == trait_ref.def_id();\n         if !is_fn && !is_gen {"}, {"sha": "c179674432332c24b9559e5b27ba1718c814b256", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff369236a3895e144ef2ba1d8a24727e27e61f1c/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=ff369236a3895e144ef2ba1d8a24727e27e61f1c", "patch": "@@ -138,7 +138,7 @@ pub fn external_generic_args(\n \n     match trait_did {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n+        Some(did) if cx.tcx.fn_trait_lang_item(did).is_some() => {\n             assert!(ty_kind.is_some());\n             let inputs = match ty_kind {\n                 Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),"}]}