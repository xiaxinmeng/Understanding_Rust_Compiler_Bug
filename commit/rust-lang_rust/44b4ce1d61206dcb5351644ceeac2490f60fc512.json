{"sha": "44b4ce1d61206dcb5351644ceeac2490f60fc512", "node_id": "C_kwDOAAsO6NoAKDQ0YjRjZTFkNjEyMDZkY2I1MzUxNjQ0Y2VlYWMyNDkwZjYwZmM1MTI", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-09-23T06:12:29Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-09-23T06:12:29Z"}, "message": "Make ZST checks in core/alloc more readable\n\nThere's a bunch of these checks because of special handing for ZSTs in various unsafe implementations of stuff.\n\nThis lets them be `T::IS_ZST` instead of `mem::size_of::<T>() == 0` every time, making them both more readable and more terse.\n\n*Not* proposed for stabilization at this time.  Would be `pub(crate)` except `alloc` wants to use it too.\n\n(And while it doesn't matter now, if we ever get something like 85836 making it a const can help codegen be simpler.)", "tree": {"sha": "b9cd50ef8396422394a8d46eb1af5f3cb8ff7cee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9cd50ef8396422394a8d46eb1af5f3cb8ff7cee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44b4ce1d61206dcb5351644ceeac2490f60fc512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44b4ce1d61206dcb5351644ceeac2490f60fc512", "html_url": "https://github.com/rust-lang/rust/commit/44b4ce1d61206dcb5351644ceeac2490f60fc512", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44b4ce1d61206dcb5351644ceeac2490f60fc512/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c773c134c949661874d76313280e76cc3dd60975", "url": "https://api.github.com/repos/rust-lang/rust/commits/c773c134c949661874d76313280e76cc3dd60975", "html_url": "https://github.com/rust-lang/rust/commit/c773c134c949661874d76313280e76cc3dd60975"}], "stats": {"total": 106, "additions": 60, "deletions": 46}, "files": [{"sha": "5546c9383de9cad4b9a50ab296fc2324695345f2", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -12,7 +12,7 @@ use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::iter::{repeat_with, FromIterator};\n use core::marker::PhantomData;\n-use core::mem::{self, ManuallyDrop, MaybeUninit};\n+use core::mem::{ManuallyDrop, MaybeUninit, SizedTypeProperties};\n use core::ops::{Index, IndexMut, Range, RangeBounds};\n use core::ptr::{self, NonNull};\n use core::slice;\n@@ -177,7 +177,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// Marginally more convenient\n     #[inline]\n     fn cap(&self) -> usize {\n-        if mem::size_of::<T>() == 0 {\n+        if T::IS_ZST {\n             // For zero sized types, we are always at maximum capacity\n             MAXIMUM_ZST_CAPACITY\n         } else {\n@@ -3038,7 +3038,7 @@ impl<T, A: Allocator> From<Vec<T, A>> for VecDeque<T, A> {\n     /// `Vec<T>` came from `From<VecDeque<T>>` and hasn't been reallocated.\n     fn from(mut other: Vec<T, A>) -> Self {\n         let len = other.len();\n-        if mem::size_of::<T>() == 0 {\n+        if T::IS_ZST {\n             // There's no actual allocation for ZSTs to worry about capacity,\n             // but `VecDeque` can't handle as much length as `Vec`.\n             assert!(len < MAXIMUM_ZST_CAPACITY, \"capacity overflow\");\n@@ -3124,7 +3124,7 @@ impl<T, const N: usize> From<[T; N]> for VecDeque<T> {\n     fn from(arr: [T; N]) -> Self {\n         let mut deq = VecDeque::with_capacity(N);\n         let arr = ManuallyDrop::new(arr);\n-        if mem::size_of::<T>() != 0 {\n+        if !<T>::IS_ZST {\n             // SAFETY: VecDeque::with_capacity ensures that there is enough capacity.\n             unsafe {\n                 ptr::copy_nonoverlapping(arr.as_ptr(), deq.ptr(), N);"}, {"sha": "2641942f962ce6ea94346c13132da3d60595d335", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -136,6 +136,7 @@\n #![feature(receiver_trait)]\n #![feature(saturating_int_impl)]\n #![feature(set_ptr_value)]\n+#![feature(sized_type_properties)]\n #![feature(slice_from_ptr_range)]\n #![feature(slice_group_by)]\n #![feature(slice_ptr_get)]"}, {"sha": "5a10121bbbe4b0f2a9014e3ce50a19c8bd3fc650", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -3,7 +3,7 @@\n use core::alloc::LayoutError;\n use core::cmp;\n use core::intrinsics;\n-use core::mem::{self, ManuallyDrop, MaybeUninit};\n+use core::mem::{self, ManuallyDrop, MaybeUninit, SizedTypeProperties};\n use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n@@ -168,7 +168,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n     #[cfg(not(no_global_oom_handling))]\n     fn allocate_in(capacity: usize, init: AllocInit, alloc: A) -> Self {\n         // Don't allocate here because `Drop` will not deallocate when `capacity` is 0.\n-        if mem::size_of::<T>() == 0 || capacity == 0 {\n+        if T::IS_ZST || capacity == 0 {\n             Self::new_in(alloc)\n         } else {\n             // We avoid `unwrap_or_else` here because it bloats the amount of\n@@ -229,7 +229,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n     /// This will always be `usize::MAX` if `T` is zero-sized.\n     #[inline(always)]\n     pub fn capacity(&self) -> usize {\n-        if mem::size_of::<T>() == 0 { usize::MAX } else { self.cap }\n+        if T::IS_ZST { usize::MAX } else { self.cap }\n     }\n \n     /// Returns a shared reference to the allocator backing this `RawVec`.\n@@ -238,7 +238,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n     }\n \n     fn current_memory(&self) -> Option<(NonNull<u8>, Layout)> {\n-        if mem::size_of::<T>() == 0 || self.cap == 0 {\n+        if T::IS_ZST || self.cap == 0 {\n             None\n         } else {\n             // We have an allocated chunk of memory, so we can bypass runtime\n@@ -380,7 +380,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n         // This is ensured by the calling contexts.\n         debug_assert!(additional > 0);\n \n-        if mem::size_of::<T>() == 0 {\n+        if T::IS_ZST {\n             // Since we return a capacity of `usize::MAX` when `elem_size` is\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             return Err(CapacityOverflow.into());\n@@ -406,7 +406,7 @@ impl<T, A: Allocator> RawVec<T, A> {\n     // `grow_amortized`, but this method is usually instantiated less often so\n     // it's less critical.\n     fn grow_exact(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {\n-        if mem::size_of::<T>() == 0 {\n+        if T::IS_ZST {\n             // Since we return a capacity of `usize::MAX` when the type size is\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             return Err(CapacityOverflow.into());"}, {"sha": "2e24c3c652d1158ac8ee7cd27bc012138b39b700", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -16,9 +16,7 @@ use core::borrow::{Borrow, BorrowMut};\n #[cfg(not(no_global_oom_handling))]\n use core::cmp::Ordering::{self, Less};\n #[cfg(not(no_global_oom_handling))]\n-use core::mem;\n-#[cfg(not(no_global_oom_handling))]\n-use core::mem::size_of;\n+use core::mem::{self, SizedTypeProperties};\n #[cfg(not(no_global_oom_handling))]\n use core::ptr;\n \n@@ -1018,7 +1016,7 @@ where\n     const MIN_RUN: usize = 10;\n \n     // Sorting has no meaningful behavior on zero-sized types.\n-    if size_of::<T>() == 0 {\n+    if T::IS_ZST {\n         return;\n     }\n "}, {"sha": "541f99bcfaba4582ad801dc81de5075c5830aed3", "filename": "library/alloc/src/vec/drain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -1,7 +1,7 @@\n use crate::alloc::{Allocator, Global};\n use core::fmt;\n use core::iter::{FusedIterator, TrustedLen};\n-use core::mem::{self, ManuallyDrop};\n+use core::mem::{self, ManuallyDrop, SizedTypeProperties};\n use core::ptr::{self, NonNull};\n use core::slice::{self};\n \n@@ -202,7 +202,7 @@ impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n \n         let mut vec = self.vec;\n \n-        if mem::size_of::<T>() == 0 {\n+        if T::IS_ZST {\n             // ZSTs have no identity, so we don't need to move them around, we only need to drop the correct amount.\n             // this can be achieved by manipulating the Vec length instead of moving values out from `iter`.\n             unsafe {"}, {"sha": "a3f8fe40fd5cebb560f8fd11203c2d3f9845be32", "filename": "library/alloc/src/vec/in_place_collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -135,7 +135,7 @@\n //! vec.truncate(write_idx);\n //! ```\n use core::iter::{InPlaceIterable, SourceIter, TrustedRandomAccessNoCoerce};\n-use core::mem::{self, ManuallyDrop};\n+use core::mem::{self, ManuallyDrop, SizedTypeProperties};\n use core::ptr::{self};\n \n use super::{InPlaceDrop, SpecFromIter, SpecFromIterNested, Vec};\n@@ -154,7 +154,7 @@ where\n     default fn from_iter(mut iterator: I) -> Self {\n         // See \"Layout constraints\" section in the module documentation. We rely on const\n         // optimization here since these conditions currently cannot be expressed as trait bounds\n-        if mem::size_of::<T>() == 0\n+        if T::IS_ZST\n             || mem::size_of::<T>()\n                 != mem::size_of::<<<I as SourceIter>::Source as AsVecIntoIter>::Item>()\n             || mem::align_of::<T>()"}, {"sha": "d74e77637bdc4972f48cc942618c8ed018704494", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -8,7 +8,7 @@ use core::iter::{\n     FusedIterator, InPlaceIterable, SourceIter, TrustedLen, TrustedRandomAccessNoCoerce,\n };\n use core::marker::PhantomData;\n-use core::mem::{self, ManuallyDrop, MaybeUninit};\n+use core::mem::{self, ManuallyDrop, MaybeUninit, SizedTypeProperties};\n #[cfg(not(no_global_oom_handling))]\n use core::ops::Deref;\n use core::ptr::{self, NonNull};\n@@ -149,7 +149,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n     fn next(&mut self) -> Option<T> {\n         if self.ptr == self.end {\n             None\n-        } else if mem::size_of::<T>() == 0 {\n+        } else if T::IS_ZST {\n             // purposefully don't use 'ptr.offset' because for\n             // vectors with 0-size elements this would return the\n             // same pointer.\n@@ -167,7 +167,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let exact = if mem::size_of::<T>() == 0 {\n+        let exact = if T::IS_ZST {\n             self.end.addr().wrapping_sub(self.ptr.addr())\n         } else {\n             unsafe { self.end.sub_ptr(self.ptr) }\n@@ -179,7 +179,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n     fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n         let step_size = self.len().min(n);\n         let to_drop = ptr::slice_from_raw_parts_mut(self.ptr as *mut T, step_size);\n-        if mem::size_of::<T>() == 0 {\n+        if T::IS_ZST {\n             // SAFETY: due to unchecked casts of unsigned amounts to signed offsets the wraparound\n             // effectively results in unsigned pointers representing positions 0..usize::MAX,\n             // which is valid for ZSTs.\n@@ -209,7 +209,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n \n         let len = self.len();\n \n-        if mem::size_of::<T>() == 0 {\n+        if T::IS_ZST {\n             if len < N {\n                 self.forget_remaining_elements();\n                 // Safety: ZSTs can be conjured ex nihilo, only the amount has to be correct\n@@ -253,7 +253,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n         // that `T: Copy` so reading elements from the buffer doesn't invalidate\n         // them for `Drop`.\n         unsafe {\n-            if mem::size_of::<T>() == 0 { mem::zeroed() } else { ptr::read(self.ptr.add(i)) }\n+            if T::IS_ZST { mem::zeroed() } else { ptr::read(self.ptr.add(i)) }\n         }\n     }\n }\n@@ -264,7 +264,7 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n     fn next_back(&mut self) -> Option<T> {\n         if self.end == self.ptr {\n             None\n-        } else if mem::size_of::<T>() == 0 {\n+        } else if T::IS_ZST {\n             // See above for why 'ptr.offset' isn't used\n             self.end = self.end.wrapping_byte_sub(1);\n \n@@ -280,7 +280,7 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n     #[inline]\n     fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n         let step_size = self.len().min(n);\n-        if mem::size_of::<T>() == 0 {\n+        if T::IS_ZST {\n             // SAFETY: same as for advance_by()\n             self.end = self.end.wrapping_byte_sub(step_size);\n         } else {"}, {"sha": "d6d986905e6c150d7c26b12ee18a00e5ece81b72", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -64,7 +64,7 @@ use core::iter;\n #[cfg(not(no_global_oom_handling))]\n use core::iter::FromIterator;\n use core::marker::PhantomData;\n-use core::mem::{self, ManuallyDrop, MaybeUninit};\n+use core::mem::{self, ManuallyDrop, MaybeUninit, SizedTypeProperties};\n use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n use core::ptr::{self, NonNull};\n use core::slice::{self, SliceIndex};\n@@ -2347,7 +2347,7 @@ impl<T, A: Allocator, const N: usize> Vec<[T; N], A> {\n     #[unstable(feature = \"slice_flatten\", issue = \"95629\")]\n     pub fn into_flattened(self) -> Vec<T, A> {\n         let (ptr, len, cap, alloc) = self.into_raw_parts_with_alloc();\n-        let (new_len, new_cap) = if mem::size_of::<T>() == 0 {\n+        let (new_len, new_cap) = if T::IS_ZST {\n             (len.checked_mul(N).expect(\"vec len overflow\"), usize::MAX)\n         } else {\n             // SAFETY:\n@@ -2677,7 +2677,7 @@ impl<T, A: Allocator> IntoIterator for Vec<T, A> {\n             let mut me = ManuallyDrop::new(self);\n             let alloc = ManuallyDrop::new(ptr::read(me.allocator()));\n             let begin = me.as_mut_ptr();\n-            let end = if mem::size_of::<T>() == 0 {\n+            let end = if T::IS_ZST {\n                 begin.wrapping_byte_add(me.len())\n             } else {\n                 begin.add(me.len()) as *const T"}, {"sha": "cd92ea24b6171732ebb3614101c7117f002c0d44", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -1178,3 +1178,18 @@ pub const fn discriminant<T>(v: &T) -> Discriminant<T> {\n pub const fn variant_count<T>() -> usize {\n     intrinsics::variant_count::<T>()\n }\n+\n+/// This is here only to simplify all the ZST checks we need in the library.\n+/// It's not on a stabilization track right now.\n+#[doc(hidden)]\n+#[unstable(feature = \"sized_type_properties\", issue = \"none\")]\n+pub trait SizedTypeProperties: Sized {\n+    /// `true` if this type requires no storage.\n+    /// `false` if its [size](size_of) is greater than zero.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"sized_type_properties\", issue = \"none\")]\n+    const IS_ZST: bool = size_of::<Self>() == 0;\n+}\n+#[doc(hidden)]\n+#[unstable(feature = \"sized_type_properties\", issue = \"none\")]\n+impl<T> SizedTypeProperties for T {}"}, {"sha": "d9dfc56ab6347da42de3684c03de980dc6a74297", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -9,7 +9,7 @@ use crate::fmt;\n use crate::intrinsics::{assume, exact_div, unchecked_sub};\n use crate::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n use crate::marker::{PhantomData, Send, Sized, Sync};\n-use crate::mem;\n+use crate::mem::{self, SizedTypeProperties};\n use crate::num::NonZeroUsize;\n use crate::ptr::NonNull;\n \n@@ -91,7 +91,7 @@ impl<'a, T> Iter<'a, T> {\n         unsafe {\n             assume(!ptr.is_null());\n \n-            let end = if mem::size_of::<T>() == 0 {\n+            let end = if T::IS_ZST {\n                 ptr.wrapping_byte_add(slice.len())\n             } else {\n                 ptr.add(slice.len())\n@@ -227,7 +227,7 @@ impl<'a, T> IterMut<'a, T> {\n         unsafe {\n             assume(!ptr.is_null());\n \n-            let end = if mem::size_of::<T>() == 0 {\n+            let end = if T::IS_ZST {\n                 ptr.wrapping_byte_add(slice.len())\n             } else {\n                 ptr.add(slice.len())"}, {"sha": "ce51d48e3e551901457c3af8d9783f9c544e2af5", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -100,7 +100,7 @@ macro_rules! iterator {\n             // Unsafe because the offset must not exceed `self.len()`.\n             #[inline(always)]\n             unsafe fn pre_dec_end(&mut self, offset: usize) -> * $raw_mut T {\n-                if mem::size_of::<T>() == 0 {\n+                if T::IS_ZST {\n                     zst_shrink!(self, offset);\n                     self.ptr.as_ptr()\n                 } else {\n@@ -140,7 +140,7 @@ macro_rules! iterator {\n                 // since we check if the iterator is empty first.\n                 unsafe {\n                     assume(!self.ptr.as_ptr().is_null());\n-                    if mem::size_of::<T>() != 0 {\n+                    if !<T>::IS_ZST {\n                         assume(!self.end.is_null());\n                     }\n                     if is_empty!(self) {\n@@ -166,7 +166,7 @@ macro_rules! iterator {\n             fn nth(&mut self, n: usize) -> Option<$elem> {\n                 if n >= len!(self) {\n                     // This iterator is now empty.\n-                    if mem::size_of::<T>() == 0 {\n+                    if T::IS_ZST {\n                         // We have to do it this way as `ptr` may never be 0, but `end`\n                         // could be (due to wrapping).\n                         self.end = self.ptr.as_ptr();\n@@ -355,7 +355,7 @@ macro_rules! iterator {\n                 // empty first.\n                 unsafe {\n                     assume(!self.ptr.as_ptr().is_null());\n-                    if mem::size_of::<T>() != 0 {\n+                    if !<T>::IS_ZST {\n                         assume(!self.end.is_null());\n                     }\n                     if is_empty!(self) {"}, {"sha": "bf5c0cb46ae46bdf3e0879b8a10f85c449e8d078", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -9,7 +9,7 @@\n use crate::cmp::Ordering::{self, Greater, Less};\n use crate::intrinsics::{assert_unsafe_precondition, exact_div};\n use crate::marker::Copy;\n-use crate::mem;\n+use crate::mem::{self, SizedTypeProperties};\n use crate::num::NonZeroUsize;\n use crate::ops::{Bound, FnMut, OneSidedRange, Range, RangeBounds};\n use crate::option::Option;\n@@ -3459,7 +3459,7 @@ impl<T> [T] {\n     #[must_use]\n     pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n         // Note that most of this function will be constant-evaluated,\n-        if mem::size_of::<U>() == 0 || mem::size_of::<T>() == 0 {\n+        if U::IS_ZST || T::IS_ZST {\n             // handle ZSTs specially, which is \u2013 don't handle them at all.\n             return (self, &[], &[]);\n         }\n@@ -3520,7 +3520,7 @@ impl<T> [T] {\n     #[must_use]\n     pub unsafe fn align_to_mut<U>(&mut self) -> (&mut [T], &mut [U], &mut [T]) {\n         // Note that most of this function will be constant-evaluated,\n-        if mem::size_of::<U>() == 0 || mem::size_of::<T>() == 0 {\n+        if U::IS_ZST || T::IS_ZST {\n             // handle ZSTs specially, which is \u2013 don't handle them at all.\n             return (self, &mut [], &mut []);\n         }\n@@ -4066,7 +4066,7 @@ impl<T, const N: usize> [[T; N]] {\n     /// ```\n     #[unstable(feature = \"slice_flatten\", issue = \"95629\")]\n     pub fn flatten(&self) -> &[T] {\n-        let len = if crate::mem::size_of::<T>() == 0 {\n+        let len = if T::IS_ZST {\n             self.len().checked_mul(N).expect(\"slice len overflow\")\n         } else {\n             // SAFETY: `self.len() * N` cannot overflow because `self` is\n@@ -4104,7 +4104,7 @@ impl<T, const N: usize> [[T; N]] {\n     /// ```\n     #[unstable(feature = \"slice_flatten\", issue = \"95629\")]\n     pub fn flatten_mut(&mut self) -> &mut [T] {\n-        let len = if crate::mem::size_of::<T>() == 0 {\n+        let len = if T::IS_ZST {\n             self.len().checked_mul(N).expect(\"slice len overflow\")\n         } else {\n             // SAFETY: `self.len() * N` cannot overflow because `self` is"}, {"sha": "fa8c238f8e7a27bf9998bc188f173c30bb7948d4", "filename": "library/core/src/slice/rotate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Fcore%2Fsrc%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Fcore%2Fsrc%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Frotate.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -1,5 +1,5 @@\n use crate::cmp;\n-use crate::mem::{self, MaybeUninit};\n+use crate::mem::{self, MaybeUninit, SizedTypeProperties};\n use crate::ptr;\n \n /// Rotates the range `[mid-left, mid+right)` such that the element at `mid` becomes the first\n@@ -63,7 +63,7 @@ use crate::ptr;\n /// when `left < right` the swapping happens from the left instead.\n pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize) {\n     type BufType = [usize; 32];\n-    if mem::size_of::<T>() == 0 {\n+    if T::IS_ZST {\n         return;\n     }\n     loop {"}, {"sha": "87f77b7f21d62e8e64cda64c2dfd076107296338", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44b4ce1d61206dcb5351644ceeac2490f60fc512/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=44b4ce1d61206dcb5351644ceeac2490f60fc512", "patch": "@@ -7,7 +7,7 @@\n //! stable sorting implementation.\n \n use crate::cmp;\n-use crate::mem::{self, MaybeUninit};\n+use crate::mem::{self, MaybeUninit, SizedTypeProperties};\n use crate::ptr;\n \n /// When dropped, copies from `src` into `dest`.\n@@ -813,7 +813,7 @@ where\n     F: FnMut(&T, &T) -> bool,\n {\n     // Sorting has no meaningful behavior on zero-sized types.\n-    if mem::size_of::<T>() == 0 {\n+    if T::IS_ZST {\n         return;\n     }\n \n@@ -898,7 +898,7 @@ where\n         panic!(\"partition_at_index index {} greater than length of slice {}\", index, v.len());\n     }\n \n-    if mem::size_of::<T>() == 0 {\n+    if T::IS_ZST {\n         // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n     } else if index == v.len() - 1 {\n         // Find max element and place it in the last position of the array. We're free to use"}]}