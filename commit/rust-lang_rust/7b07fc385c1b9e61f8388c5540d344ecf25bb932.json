{"sha": "7b07fc385c1b9e61f8388c5540d344ecf25bb932", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMDdmYzM4NWMxYjllNjFmODM4OGM1NTQwZDM0NGVjZjI1YmI5MzI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-26T10:11:27Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-27T21:32:15Z"}, "message": "get_or_create_thread_local_alloc_id: share code with Memory::get_global_alloc", "tree": {"sha": "8dd606a4f25ddbc85d88443a722dd716151bee3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dd606a4f25ddbc85d88443a722dd716151bee3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b07fc385c1b9e61f8388c5540d344ecf25bb932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b07fc385c1b9e61f8388c5540d344ecf25bb932", "html_url": "https://github.com/rust-lang/rust/commit/7b07fc385c1b9e61f8388c5540d344ecf25bb932", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b07fc385c1b9e61f8388c5540d344ecf25bb932/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a4e8caa8c303e8a8b5459bb79c7474eb53619ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a4e8caa8c303e8a8b5459bb79c7474eb53619ae", "html_url": "https://github.com/rust-lang/rust/commit/0a4e8caa8c303e8a8b5459bb79c7474eb53619ae"}], "stats": {"total": 24, "additions": 3, "deletions": 21}, "files": [{"sha": "8d493ac8f3bde83faae4dfd389517b7a31870f0f", "filename": "src/thread.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7b07fc385c1b9e61f8388c5540d344ecf25bb932/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b07fc385c1b9e61f8388c5540d344ecf25bb932/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=7b07fc385c1b9e61f8388c5540d344ecf25bb932", "patch": "@@ -11,7 +11,6 @@ use log::trace;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::ty::{self, Instance};\n \n use crate::sync::SynchronizationState;\n use crate::*;\n@@ -497,9 +496,6 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     /// Get a thread-specific allocation id for the given thread-local static.\n     /// If needed, allocate a new one.\n-    ///\n-    /// FIXME: This method should be replaced as soon as\n-    /// https://github.com/rust-lang/rust/issues/70685 gets fixed.\n     fn get_or_create_thread_local_alloc_id(&self, def_id: DefId) -> InterpResult<'tcx, AllocId> {\n         let this = self.eval_context_ref();\n         let tcx = this.tcx;\n@@ -511,29 +507,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // We need to allocate a thread-specific allocation id for this\n             // thread-local static.\n             //\n-            // At first, we invoke the `const_eval_raw` query and extract the\n-            // allocation from it. Unfortunately, we have to duplicate the code\n-            // from `Memory::get_global_alloc` that does this.\n-            //\n+            // At first, we compute the initial value for this static.\n             // Then we store the retrieved allocation back into the `alloc_map`\n             // to get a fresh allocation id, which we can use as a\n             // thread-specific allocation id for the thread-local static.\n+            // On first access to that allocation, it will be copied over to the machine memory.\n             if tcx.is_foreign_item(def_id) {\n                 throw_unsup_format!(\"foreign thread-local statics are not supported\");\n             }\n-            // Invoke the `const_eval_raw` query.\n-            let instance = Instance::mono(tcx.tcx, def_id);\n-            let gid = GlobalId { instance, promoted: None };\n-            let raw_const =\n-                tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n-                    // no need to report anything, the const_eval call takes care of that\n-                    // for statics\n-                    assert!(tcx.is_static(def_id));\n-                    err\n-                })?;\n-            let id = raw_const.alloc_id;\n-            // Extract the allocation from the query result.\n-            let allocation = tcx.global_alloc(id).unwrap_memory();\n+            let allocation = interpret::get_static(*tcx, def_id)?;\n             // Create a new allocation id for the same allocation in this hacky\n             // way. Internally, `alloc_map` deduplicates allocations, but this\n             // is fine because Miri will make a copy before a first mutable"}]}