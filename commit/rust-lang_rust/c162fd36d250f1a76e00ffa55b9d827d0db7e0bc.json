{"sha": "c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "node_id": "C_kwDOAAsO6NoAKGMxNjJmZDM2ZDI1MGYxYTc2ZTAwZmZhNTViOWQ4MjdkMGRiN2UwYmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-29T16:12:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-29T16:12:23Z"}, "message": "Auto merge of #2636 - RalfJung:scalar-field-retag, r=oli-obk\n\nStacked Borrows: make scalar field retagging the default\n\nI think it is time to finally close this soundness gap. Any objections? :)\n\nUnfortunately the latest released versions of hashbrown and scopeguard can fail under full field retagging. The fixes have landed in the git repos but have not been released yet. I don't know if scalar field retagging as enabled by this PR is sufficient to cause problems with these crates, but it seems likely that this would be the case -- e.g. if both `value` and `dropfn` are scalars, the entire scopeguard struct will be a `ScalarPair` and thus get field retagging.\n\nHowever, given that we actually generate LLVM `noalias` for these cases, it seems prudent to inform users of this risk. They can easily set `-Zmiri-field-retag=none` to opt-out of this change.\n\nCc https://github.com/rust-lang/miri/issues/2528", "tree": {"sha": "fe3478b4a2f6d4698860242bce914c5b9c67065b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe3478b4a2f6d4698860242bce914c5b9c67065b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "html_url": "https://github.com/rust-lang/rust/commit/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79a48ce71686a5a82cb000062915157170e16d61", "url": "https://api.github.com/repos/rust-lang/rust/commits/79a48ce71686a5a82cb000062915157170e16d61", "html_url": "https://github.com/rust-lang/rust/commit/79a48ce71686a5a82cb000062915157170e16d61"}, {"sha": "1470e9924460b299ce597ef9001e5e3f7549a8b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1470e9924460b299ce597ef9001e5e3f7549a8b8", "html_url": "https://github.com/rust-lang/rust/commit/1470e9924460b299ce597ef9001e5e3f7549a8b8"}], "stats": {"total": 118, "additions": 76, "deletions": 42}, "files": [{"sha": "7b684d5df1370bfd6717ad7a887abdbe14b2f1e2", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -374,14 +374,15 @@ to Miri failing to detect cases of undefined behavior in a program.\n   application instead of raising an error within the context of Miri (and halting\n   execution). Note that code might not expect these operations to ever panic, so\n   this flag can lead to strange (mis)behavior.\n-* `-Zmiri-retag-fields` changes Stacked Borrows retagging to recurse into fields.\n+* `-Zmiri-retag-fields` changes Stacked Borrows retagging to recurse into *all* fields.\n   This means that references in fields of structs/enums/tuples/arrays/... are retagged,\n   and in particular, they are protected when passed as function arguments.\n+  (The default is to recurse only in cases where rustc would actually emit a `noalias` attribute.)\n * `-Zmiri-retag-fields=<all|none|scalar>` controls when Stacked Borrows retagging recurses into\n   fields. `all` means it always recurses (like `-Zmiri-retag-fields`), `none` means it never\n-  recurses (the default), `scalar` means it only recurses for types where we would also emit\n+  recurses, `scalar` (the default) means it only recurses for types where we would also emit\n   `noalias` annotations in the generated LLVM IR (types passed as indivudal scalars or pairs of\n-  scalars).\n+  scalars). Setting this to `none` is **unsound**.\n * `-Zmiri-tag-gc=<blocks>` configures how often the pointer tag garbage collector runs. The default\n   is to search for and remove unreachable tags once every `10000` basic blocks. Setting this to\n   `0` disables the garbage collector, which causes some programs to have explosive memory usage"}, {"sha": "81132db94cf181ff1583031304e4535d47099dbc", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -163,7 +163,7 @@ impl Default for MiriConfig {\n             mute_stdout_stderr: false,\n             preemption_rate: 0.01, // 1%\n             report_progress: None,\n-            retag_fields: RetagFields::No,\n+            retag_fields: RetagFields::OnlyScalar,\n             external_so_file: None,\n             gc_interval: 10_000,\n             num_cpus: 1,"}, {"sha": "cc774500a3c69d69351c32d542743fe8f1f81730", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.rs?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,4 +1,3 @@\n-//@compile-flags: -Zmiri-retag-fields=scalar\n //@error-pattern: which is protected\n struct Newtype<'a>(&'a mut i32, i32);\n "}, {"sha": "1aa6e240e30f1699f5122d42d0b7a281092b7354", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_retagging.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,4 +1,3 @@\n-//@compile-flags: -Zmiri-retag-fields=scalar\n //@error-pattern: which is protected\n struct Newtype<'a>(&'a mut i32);\n "}, {"sha": "5a9dc6afba8da9e85617915b52a0ecf2729eb232", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_option.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,16 +1,15 @@\n // Make sure that we cannot return a `&mut` that got already invalidated, not even in an `Option`.\n-// Due to shallow reborrowing, the error only surfaces when we look into the `Option`.\n fn foo(x: &mut (i32, i32)) -> Option<&mut i32> {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 }; // let-bind to avoid 2phase\n     let ret = Some(ret);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {\n     match foo(&mut (1, 2)) {\n-        Some(_x) => {} //~ ERROR: /retag .* tag does not exist in the borrow stack/\n+        Some(_x) => {}\n         None => {}\n     }\n }"}, {"sha": "c0ff35ebcde307aa39834ff5a11314ee51345033", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_option.stderr", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,26 +1,31 @@\n error: Undefined Behavior: trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_mut_option.rs:LL:CC\n    |\n-LL |         Some(_x) => {}\n-   |              ^^\n-   |              |\n-   |              trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |              this error occurs as part of retag at ALLOC[0x4..0x8]\n+LL |     ret\n+   |     ^^^\n+   |     |\n+   |     trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |     this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a Unique retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_mut_option.rs:LL:CC\n    |\n LL |     let ret = Some(ret);\n-   |                    ^^^\n+   |               ^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x8] by a read access\n   --> $DIR/return_invalid_mut_option.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref\n    |                         ^^^^^\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/return_invalid_mut_option.rs:LL:CC\n+   = note: inside `foo` at $DIR/return_invalid_mut_option.rs:LL:CC\n+note: inside `main` at $DIR/return_invalid_mut_option.rs:LL:CC\n+  --> $DIR/return_invalid_mut_option.rs:LL:CC\n+   |\n+LL |     match foo(&mut (1, 2)) {\n+   |           ^^^^^^^^^^^^^^^^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "8fe7f15cab0c12c2f7b5df8d71fe90e059c6c26b", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_tuple.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,12 +1,11 @@\n // Make sure that we cannot return a `&mut` that got already invalidated, not even in a tuple.\n-// Due to shallow reborrowing, the error only surfaces when we look into the tuple.\n fn foo(x: &mut (i32, i32)) -> (&mut i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &mut (*xraw).1 },);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {\n-    foo(&mut (1, 2)).0; //~ ERROR: /retag .* tag does not exist in the borrow stack/\n+    foo(&mut (1, 2)).0;\n }"}, {"sha": "9abf43c29f08fb3e44601d09e248eeff7288fe9c", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_tuple.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n    |\n-LL |     foo(&mut (1, 2)).0;\n-   |     ^^^^^^^^^^^^^^^^^^\n+LL |     ret\n+   |     ^^^\n    |     |\n    |     trying to retag from <TAG> for Unique permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n    |     this error occurs as part of retag at ALLOC[0x4..0x8]\n@@ -13,14 +13,19 @@ help: <TAG> was created by a Unique retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n    |\n LL |     let ret = (unsafe { &mut (*xraw).1 },);\n-   |                         ^^^^^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x8] by a read access\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref\n    |                         ^^^^^\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/return_invalid_mut_tuple.rs:LL:CC\n+   = note: inside `foo` at $DIR/return_invalid_mut_tuple.rs:LL:CC\n+note: inside `main` at $DIR/return_invalid_mut_tuple.rs:LL:CC\n+  --> $DIR/return_invalid_mut_tuple.rs:LL:CC\n+   |\n+LL |     foo(&mut (1, 2)).0;\n+   |     ^^^^^^^^^^^^^^^^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "094ce33b9c1f73c9540a20e66417ed8fcc990f1f", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_option.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.rs?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,15 +1,14 @@\n // Make sure that we cannot return a `&` that got already invalidated, not even in an `Option`.\n-// Due to shallow reborrowing, the error only surfaces when we look into the `Option`.\n fn foo(x: &mut (i32, i32)) -> Option<&i32> {\n     let xraw = x as *mut (i32, i32);\n     let ret = Some(unsafe { &(*xraw).1 });\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {\n     match foo(&mut (1, 2)) {\n-        Some(_x) => {} //~ ERROR: /retag .* tag does not exist in the borrow stack/\n+        Some(_x) => {}\n         None => {}\n     }\n }"}, {"sha": "6066bf89f5d095806cab091431260eebca461801", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_option.stderr", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,26 +1,31 @@\n error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_shr_option.rs:LL:CC\n    |\n-LL |         Some(_x) => {}\n-   |              ^^\n-   |              |\n-   |              trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n-   |              this error occurs as part of retag at ALLOC[0x4..0x8]\n+LL |     ret\n+   |     ^^^\n+   |     |\n+   |     trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n+   |     this error occurs as part of retag at ALLOC[0x4..0x8]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a SharedReadOnly retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_shr_option.rs:LL:CC\n    |\n LL |     let ret = Some(unsafe { &(*xraw).1 });\n-   |                             ^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x8] by a write access\n   --> $DIR/return_invalid_shr_option.rs:LL:CC\n    |\n LL |     unsafe { *xraw = (42, 23) }; // unfreeze\n    |              ^^^^^^^^^^^^^^^^\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/return_invalid_shr_option.rs:LL:CC\n+   = note: inside `foo` at $DIR/return_invalid_shr_option.rs:LL:CC\n+note: inside `main` at $DIR/return_invalid_shr_option.rs:LL:CC\n+  --> $DIR/return_invalid_shr_option.rs:LL:CC\n+   |\n+LL |     match foo(&mut (1, 2)) {\n+   |           ^^^^^^^^^^^^^^^^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "d0fd53e06aa2624fa88ee8b3f4f85de319e1632c", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_tuple.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,12 +1,11 @@\n // Make sure that we cannot return a `&` that got already invalidated, not even in a tuple.\n-// Due to shallow reborrowing, the error only surfaces when we look into the tuple.\n fn foo(x: &mut (i32, i32)) -> (&i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &(*xraw).1 },);\n     unsafe { *xraw = (42, 23) }; // unfreeze\n-    ret\n+    ret //~ ERROR: /retag .* tag does not exist in the borrow stack/\n }\n \n fn main() {\n-    foo(&mut (1, 2)).0; //~ ERROR: /retag .* tag does not exist in the borrow stack/\n+    foo(&mut (1, 2)).0;\n }"}, {"sha": "52d365246a74441852bee7c4f2912844c3933159", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_tuple.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n    |\n-LL |     foo(&mut (1, 2)).0;\n-   |     ^^^^^^^^^^^^^^^^^^\n+LL |     ret\n+   |     ^^^\n    |     |\n    |     trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x4], but that tag does not exist in the borrow stack for this location\n    |     this error occurs as part of retag at ALLOC[0x4..0x8]\n@@ -13,14 +13,19 @@ help: <TAG> was created by a SharedReadOnly retag at offsets [0x4..0x8]\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n    |\n LL |     let ret = (unsafe { &(*xraw).1 },);\n-   |                         ^^^^^^^^^^\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x8] by a write access\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n    |\n LL |     unsafe { *xraw = (42, 23) }; // unfreeze\n    |              ^^^^^^^^^^^^^^^^\n    = note: BACKTRACE:\n-   = note: inside `main` at $DIR/return_invalid_shr_tuple.rs:LL:CC\n+   = note: inside `foo` at $DIR/return_invalid_shr_tuple.rs:LL:CC\n+note: inside `main` at $DIR/return_invalid_shr_tuple.rs:LL:CC\n+  --> $DIR/return_invalid_shr_tuple.rs:LL:CC\n+   |\n+LL |     foo(&mut (1, 2)).0;\n+   |     ^^^^^^^^^^^^^^^^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "48fc8e8668ce041a37a9754ce3d706a04f137674", "filename": "src/tools/miri/tests/pass/stacked-borrows/no_field_retagging.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fno_field_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fno_field_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fno_field_retagging.rs?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -0,0 +1,19 @@\n+//@compile-flags: -Zmiri-retag-fields=none\n+\n+struct Newtype<'a>(&'a mut i32);\n+\n+fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n+    dealloc();\n+}\n+\n+// Make sure that we do *not* retag the fields of `Newtype`.\n+fn main() {\n+    let ptr = Box::into_raw(Box::new(0i32));\n+    #[rustfmt::skip] // I like my newlines\n+    unsafe {\n+        dealloc_while_running(\n+            Newtype(&mut *ptr),\n+            || drop(Box::from_raw(ptr)),\n+        )\n+    };\n+}"}, {"sha": "296339e73845576ccc72d3c8912ac0984f7fc320", "filename": "src/tools/miri/tests/pass/stacked-borrows/stack-printing.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.stdout?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,6 +1,6 @@\n 0..1: [ SharedReadWrite<TAG> ]\n 0..1: [ SharedReadWrite<TAG> ]\n 0..1: [ SharedReadWrite<TAG> ]\n-0..1: [ SharedReadWrite<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> ]\n-0..1: [ SharedReadWrite<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> SharedReadOnly<TAG> ]\n+0..1: [ SharedReadWrite<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> Unique<TAG> ]\n+0..1: [ SharedReadWrite<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> Disabled<TAG> SharedReadOnly<TAG> ]\n 0..1: [ unknown-bottom(..<TAG>) ]"}]}