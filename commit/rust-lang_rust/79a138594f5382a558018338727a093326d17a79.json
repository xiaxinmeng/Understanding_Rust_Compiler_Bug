{"sha": "79a138594f5382a558018338727a093326d17a79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5YTEzODU5NGY1MzgyYTU1ODAxODMzODcyN2EwOTMzMjZkMTdhNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-18T03:11:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-18T03:11:18Z"}, "message": "Auto merge of #45989 - davidtwco:issue-45360, r=nikomatsakis\n\nMIR-borrowck: emit \"`foo` does not live long enough\" instead of borrow errors\n\nFixes #45360. As of writing, contains deduplication of existing errors.\n\nr? @nikomatsakis", "tree": {"sha": "8873858fa7442856bd9cde78bb0ffa3f015ae0f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8873858fa7442856bd9cde78bb0ffa3f015ae0f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79a138594f5382a558018338727a093326d17a79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79a138594f5382a558018338727a093326d17a79", "html_url": "https://github.com/rust-lang/rust/commit/79a138594f5382a558018338727a093326d17a79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79a138594f5382a558018338727a093326d17a79/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8752aeed3a7c8c14dbea790733ed9937ac005efb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8752aeed3a7c8c14dbea790733ed9937ac005efb", "html_url": "https://github.com/rust-lang/rust/commit/8752aeed3a7c8c14dbea790733ed9937ac005efb"}, {"sha": "a1d55be3e1014095880d17e2b9a13baca33351bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1d55be3e1014095880d17e2b9a13baca33351bf", "html_url": "https://github.com/rust-lang/rust/commit/a1d55be3e1014095880d17e2b9a13baca33351bf"}], "stats": {"total": 144, "additions": 119, "deletions": 25}, "files": [{"sha": "0ff6c8622a58501ce32287fba74ddf1ee7a8b1e2", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 101, "deletions": 20, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/79a138594f5382a558018338727a093326d17a79/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79a138594f5382a558018338727a093326d17a79/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=79a138594f5382a558018338727a093326d17a79", "patch": "@@ -20,6 +20,7 @@ use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n use rustc::mir::{Statement, StatementKind, Terminator, TerminatorKind};\n use transform::nll;\n \n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n use rustc_data_structures::indexed_vec::{Idx};\n \n@@ -136,6 +137,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n         node_id: id,\n         move_data: &mdpe.move_data,\n         param_env: param_env,\n+        storage_drop_or_dead_error_reported: FxHashSet(),\n     };\n \n     let mut state = InProgress::new(flow_borrows,\n@@ -153,6 +155,10 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     node_id: ast::NodeId,\n     move_data: &'cx MoveData<'tcx>,\n     param_env: ParamEnv<'gcx>,\n+    /// This field keeps track of when storage drop or dead errors are reported\n+    /// in order to stop duplicate error reporting and identify the conditions required\n+    /// for a \"temporary value dropped here while still borrowed\" error. See #45360.\n+    storage_drop_or_dead_error_reported: FxHashSet<Local>,\n }\n \n // (forced to be `pub` due to its use as an associated type below.)\n@@ -281,10 +287,15 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             }\n \n             StatementKind::StorageDead(local) => {\n-                self.access_lvalue(ContextKind::StorageDead.new(location),\n-                                   (&Lvalue::Local(local), span),\n-                                   (Shallow(None), Write(WriteKind::StorageDead)),\n-                                   flow_state);\n+                if !self.storage_drop_or_dead_error_reported.contains(&local) {\n+                    let error_reported = self.access_lvalue(ContextKind::StorageDead.new(location),\n+                        (&Lvalue::Local(local), span),\n+                        (Shallow(None), Write(WriteKind::StorageDeadOrDrop)), flow_state);\n+\n+                    if error_reported {\n+                        self.storage_drop_or_dead_error_reported.insert(local);\n+                    }\n+                }\n             }\n         }\n     }\n@@ -427,24 +438,30 @@ enum ReadKind {\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum WriteKind {\n-    StorageDead,\n+    StorageDeadOrDrop,\n     MutableBorrow(BorrowKind),\n     Mutate,\n     Move,\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    /// Checks an access to the given lvalue to see if it is allowed. Examines the set of borrows\n+    /// that are in scope, as well as which paths have been initialized, to ensure that (a) the\n+    /// lvalue is initialized and (b) it is not borrowed in some way that would prevent this\n+    /// access.\n+    ///\n+    /// Returns true if an error is reported, false otherwise.\n     fn access_lvalue(&mut self,\n                      context: Context,\n                      lvalue_span: (&Lvalue<'tcx>, Span),\n                      kind: (ShallowOrDeep, ReadOrWrite),\n-                     flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n-\n+                     flow_state: &InProgress<'cx, 'gcx, 'tcx>) -> bool {\n         let (sd, rw) = kind;\n \n         // Check permissions\n         self.check_access_permissions(lvalue_span, rw);\n \n+        let mut error_reported = false;\n         self.each_borrow_involving_path(\n             context, (sd, lvalue_span.0), flow_state, |this, _index, borrow, common_prefix| {\n                 match (rw, borrow.kind) {\n@@ -454,13 +471,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     (Read(kind), BorrowKind::Unique) |\n                     (Read(kind), BorrowKind::Mut) => {\n                         match kind {\n-                            ReadKind::Copy =>\n+                            ReadKind::Copy => {\n+                                error_reported = true;\n                                 this.report_use_while_mutably_borrowed(\n-                                    context, lvalue_span, borrow),\n+                                    context, lvalue_span, borrow)\n+                            },\n                             ReadKind::Borrow(bk) => {\n                                 let end_issued_loan_span =\n                                     flow_state.borrows.base_results.operator().opt_region_end_span(\n                                         &borrow.region);\n+                                error_reported = true;\n                                 this.report_conflicting_borrow(\n                                     context, common_prefix, lvalue_span, bk,\n                                     &borrow, end_issued_loan_span)\n@@ -474,22 +494,35 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 let end_issued_loan_span =\n                                     flow_state.borrows.base_results.operator().opt_region_end_span(\n                                         &borrow.region);\n+                                error_reported = true;\n                                 this.report_conflicting_borrow(\n                                     context, common_prefix, lvalue_span, bk,\n                                     &borrow, end_issued_loan_span)\n                             }\n-                            WriteKind::StorageDead |\n-                            WriteKind::Mutate =>\n+                             WriteKind::StorageDeadOrDrop => {\n+                                let end_span =\n+                                    flow_state.borrows.base_results.operator().opt_region_end_span(\n+                                        &borrow.region);\n+                                error_reported = true;\n+                                this.report_borrowed_value_does_not_live_long_enough(\n+                                    context, lvalue_span, end_span)\n+                            },\n+                            WriteKind::Mutate => {\n+                                error_reported = true;\n                                 this.report_illegal_mutation_of_borrowed(\n-                                    context, lvalue_span, borrow),\n-                            WriteKind::Move =>\n+                                    context, lvalue_span, borrow)\n+                            },\n+                            WriteKind::Move => {\n+                                error_reported = true;\n                                 this.report_move_out_while_borrowed(\n-                                    context, lvalue_span, &borrow),\n+                                    context, lvalue_span, &borrow)\n+                            },\n                         }\n                         Control::Break\n                     }\n                 }\n             });\n+        error_reported\n     }\n \n     fn mutate_lvalue(&mut self,\n@@ -604,12 +637,39 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let erased_ty = gcx.lift(&self.tcx.erase_regions(&ty)).unwrap();\n         let moves_by_default = erased_ty.moves_by_default(gcx, self.param_env, DUMMY_SP);\n \n-        if moves_by_default {\n-            // move of lvalue: check if this is move of already borrowed path\n-            self.access_lvalue(context, lvalue_span, (Deep, Write(WriteKind::Move)), flow_state);\n-        } else {\n-            // copy of lvalue: check if this is \"copy of frozen path\" (FIXME: see check_loans.rs)\n-            self.access_lvalue(context, lvalue_span, (Deep, Read(ReadKind::Copy)), flow_state);\n+        // Check if error has already been reported to stop duplicate reporting.\n+        let has_storage_drop_or_dead_error_reported = match *lvalue {\n+            Lvalue::Local(local) => self.storage_drop_or_dead_error_reported.contains(&local),\n+            _ => false,\n+        };\n+\n+        // If the error has been reported already, then we don't need the access_lvalue call.\n+        if !has_storage_drop_or_dead_error_reported || consume_via_drop != ConsumeKind::Drop {\n+            let error_reported;\n+\n+            if moves_by_default {\n+                let kind = match consume_via_drop {\n+                    ConsumeKind::Drop => WriteKind::StorageDeadOrDrop,\n+                    _ => WriteKind::Move,\n+                };\n+\n+                // move of lvalue: check if this is move of already borrowed path\n+                error_reported = self.access_lvalue(context, lvalue_span,\n+                                                    (Deep, Write(kind)), flow_state);\n+            } else {\n+                // copy of lvalue: check if this is \"copy of frozen path\"\n+                // (FIXME: see check_loans.rs)\n+                error_reported = self.access_lvalue(context, lvalue_span,\n+                                                    (Deep, Read(ReadKind::Copy)), flow_state);\n+            }\n+\n+            // If there was an error, then we keep track of it so as to deduplicate it.\n+            // We only do this on ConsumeKind::Drop.\n+            if error_reported && consume_via_drop == ConsumeKind::Drop {\n+                if let Lvalue::Local(local) = *lvalue {\n+                    self.storage_drop_or_dead_error_reported.insert(local);\n+                }\n+            }\n         }\n \n         // Finally, check if path was already moved.\n@@ -1458,6 +1518,27 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n+    fn report_borrowed_value_does_not_live_long_enough(&mut self,\n+                                                       _: Context,\n+                                                       (lvalue, span): (&Lvalue, Span),\n+                                                       end_span: Option<Span>) {\n+        let proper_span = match *lvalue {\n+            Lvalue::Local(local) => self.mir.local_decls[local].source_info.span,\n+            _ => span\n+        };\n+\n+        let mut err = self.tcx.path_does_not_live_long_enough(span, \"borrowed value\", Origin::Mir);\n+        err.span_label(proper_span, \"temporary value created here\");\n+        err.span_label(span, \"temporary value dropped here while still borrowed\");\n+        err.note(\"consider using a `let` binding to increase its lifetime\");\n+\n+        if let Some(end) = end_span {\n+            err.span_label(end, \"temporary value needs to live until here\");\n+        }\n+\n+        err.emit();\n+    }\n+\n     fn report_illegal_mutation_of_borrowed(&mut self,\n                                            _: Context,\n                                            (lvalue, span): (&Lvalue<'tcx>, Span),"}, {"sha": "1596d9cc84e0596f77dcdbbdf84614fc443dd4e4", "filename": "src/test/compile-fail/issue-36082.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/79a138594f5382a558018338727a093326d17a79/src%2Ftest%2Fcompile-fail%2Fissue-36082.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79a138594f5382a558018338727a093326d17a79/src%2Ftest%2Fcompile-fail%2Fissue-36082.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-36082.rs?ref=79a138594f5382a558018338727a093326d17a79", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n use std::cell::RefCell;\n \n fn main() {\n@@ -16,10 +19,20 @@ fn main() {\n     let x = RefCell::new((&mut r,s));\n \n     let val: &_ = x.borrow().0;\n-    //~^ ERROR borrowed value does not live long enough\n-    //~| temporary value dropped here while still borrowed\n-    //~| temporary value created here\n-    //~| consider using a `let` binding to increase its lifetime\n+    //[ast]~^ ERROR borrowed value does not live long enough [E0597]\n+    //[ast]~| NOTE temporary value dropped here while still borrowed\n+    //[ast]~| NOTE temporary value created here\n+    //[ast]~| NOTE consider using a `let` binding to increase its lifetime\n+    //[mir]~^^^^^ ERROR borrowed value does not live long enough (Ast) [E0597]\n+    //[mir]~| NOTE temporary value dropped here while still borrowed\n+    //[mir]~| NOTE temporary value created here\n+    //[mir]~| NOTE consider using a `let` binding to increase its lifetime\n+    //[mir]~| ERROR borrowed value does not live long enough (Mir) [E0597]\n+    //[mir]~| NOTE temporary value dropped here while still borrowed\n+    //[mir]~| NOTE temporary value created here\n+    //[mir]~| NOTE consider using a `let` binding to increase its lifetime\n     println!(\"{}\", val);\n }\n-//~^ temporary value needs to live until here\n+//[ast]~^ NOTE temporary value needs to live until here\n+//[mir]~^^ NOTE temporary value needs to live until here\n+//[mir]~| NOTE temporary value needs to live until here"}]}