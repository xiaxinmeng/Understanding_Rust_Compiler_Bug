{"sha": "6983091d6d255bcfd17c4f8c14015d8abc77928d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ODMwOTFkNmQyNTViY2ZkMTdjNGY4YzE0MDE1ZDhhYmM3NzkyOGQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-07-30T11:06:22Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-07-30T11:06:22Z"}, "message": "Cleanup tools", "tree": {"sha": "153359a05ca3fd887b59fe47ee84a60be0e6dfaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/153359a05ca3fd887b59fe47ee84a60be0e6dfaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6983091d6d255bcfd17c4f8c14015d8abc77928d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6983091d6d255bcfd17c4f8c14015d8abc77928d", "html_url": "https://github.com/rust-lang/rust/commit/6983091d6d255bcfd17c4f8c14015d8abc77928d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6983091d6d255bcfd17c4f8c14015d8abc77928d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a4957d143397256dc04f715660f758a65fcb9d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a4957d143397256dc04f715660f758a65fcb9d1", "html_url": "https://github.com/rust-lang/rust/commit/9a4957d143397256dc04f715660f758a65fcb9d1"}], "stats": {"total": 590, "additions": 290, "deletions": 300}, "files": [{"sha": "1898d28d389ce77b11a72a37e68901aef7969246", "filename": ".cargo/config", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6983091d6d255bcfd17c4f8c14015d8abc77928d/.cargo%2Fconfig", "raw_url": "https://github.com/rust-lang/rust/raw/6983091d6d255bcfd17c4f8c14015d8abc77928d/.cargo%2Fconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.cargo%2Fconfig?ref=6983091d6d255bcfd17c4f8c14015d8abc77928d", "patch": "@@ -1,4 +1,4 @@\n [alias]\n parse = \"run --package tools --bin parse\"\n-gen = \"run --package tools --bin gen\"\n-collect-tests = \"run --package tools --bin collect-tests --\"\n+gen-kinds = \"run --package tools -- gen-kinds\"\n+gen-tests = \"run --package tools -- gen-tests\""}, {"sha": "f4ee048f409525e141bf329f114eca949af35aed", "filename": ".travis.yml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6983091d6d255bcfd17c4f8c14015d8abc77928d/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/6983091d6d255bcfd17c4f8c14015d8abc77928d/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=6983091d6d255bcfd17c4f8c14015d8abc77928d", "patch": "@@ -8,6 +8,8 @@ matrix:\n       script:\n         - cargo fmt --all -- --write-mode=diff\n         - cargo test\n+        - cargo gen-kinds --verify\n+        - cargo gen-tests --verify\n     - rust: nightly\n       before_script:\n         - rustup component add clippy-preview"}, {"sha": "563ea92f6a5132dbab37db80438ed9a882cd8446", "filename": "src/bin/cli/parse.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6983091d6d255bcfd17c4f8c14015d8abc77928d/src%2Fbin%2Fcli%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6983091d6d255bcfd17c4f8c14015d8abc77928d/src%2Fbin%2Fcli%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcli%2Fparse.rs?ref=6983091d6d255bcfd17c4f8c14015d8abc77928d", "patch": "@@ -2,8 +2,9 @@ extern crate libsyntax2;\n \n use std::io::Read;\n \n-use libsyntax2::{parse};\n-use libsyntax2::utils::dump_tree_green;\n+use libsyntax2::{\n+    parse, utils::dump_tree_green\n+};\n \n fn main() {\n     let text = read_input();", "previous_filename": "tools/src/bin/parse.rs"}, {"sha": "029972bb3a6d1298fd5fc522d2bdd1d8e4fcfa8c", "filename": "src/syntax_kinds/generated.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6983091d6d255bcfd17c4f8c14015d8abc77928d/src%2Fsyntax_kinds%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6983091d6d255bcfd17c4f8c14015d8abc77928d/src%2Fsyntax_kinds%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntax_kinds%2Fgenerated.rs?ref=6983091d6d255bcfd17c4f8c14015d8abc77928d", "patch": "@@ -1,6 +1,5 @@\n #![allow(bad_style, missing_docs, unreachable_pub)]\n #![cfg_attr(rustfmt, rustfmt_skip)]\n-//! Generated from grammar.ron\n use super::SyntaxInfo;\n \n /// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.\n@@ -138,15 +137,14 @@ pub enum SyntaxKind {\n     VALUE_PARAMETER,\n     BLOCK,\n     LET_STMT,\n-\n     // Technical SyntaxKinds: they appear temporally during parsing,\n     // but never end up in the final tree\n     #[doc(hidden)]\n     TOMBSTONE,\n     #[doc(hidden)]\n     EOF,\n }\n-pub(crate) use self::SyntaxKind::*;\n+use self::SyntaxKind::*;\n \n impl SyntaxKind {\n     pub(crate) fn info(self) -> &'static SyntaxInfo {\n@@ -289,38 +287,39 @@ impl SyntaxKind {\n         }\n     }\n     pub(crate) fn from_keyword(ident: &str) -> Option<SyntaxKind> {\n-        match ident {\n-            \"use\" => Some(USE_KW),\n-            \"fn\" => Some(FN_KW),\n-            \"struct\" => Some(STRUCT_KW),\n-            \"enum\" => Some(ENUM_KW),\n-            \"trait\" => Some(TRAIT_KW),\n-            \"impl\" => Some(IMPL_KW),\n-            \"true\" => Some(TRUE_KW),\n-            \"false\" => Some(FALSE_KW),\n-            \"as\" => Some(AS_KW),\n-            \"extern\" => Some(EXTERN_KW),\n-            \"crate\" => Some(CRATE_KW),\n-            \"mod\" => Some(MOD_KW),\n-            \"pub\" => Some(PUB_KW),\n-            \"self\" => Some(SELF_KW),\n-            \"super\" => Some(SUPER_KW),\n-            \"in\" => Some(IN_KW),\n-            \"where\" => Some(WHERE_KW),\n-            \"for\" => Some(FOR_KW),\n-            \"loop\" => Some(LOOP_KW),\n-            \"while\" => Some(WHILE_KW),\n-            \"if\" => Some(IF_KW),\n-            \"match\" => Some(MATCH_KW),\n-            \"const\" => Some(CONST_KW),\n-            \"static\" => Some(STATIC_KW),\n-            \"mut\" => Some(MUT_KW),\n-            \"unsafe\" => Some(UNSAFE_KW),\n-            \"type\" => Some(TYPE_KW),\n-            \"ref\" => Some(REF_KW),\n-            \"let\" => Some(LET_KW),\n-            _ => None,\n-        }\n+        let kw = match ident {\n+            \"use\" => USE_KW,\n+            \"fn\" => FN_KW,\n+            \"struct\" => STRUCT_KW,\n+            \"enum\" => ENUM_KW,\n+            \"trait\" => TRAIT_KW,\n+            \"impl\" => IMPL_KW,\n+            \"true\" => TRUE_KW,\n+            \"false\" => FALSE_KW,\n+            \"as\" => AS_KW,\n+            \"extern\" => EXTERN_KW,\n+            \"crate\" => CRATE_KW,\n+            \"mod\" => MOD_KW,\n+            \"pub\" => PUB_KW,\n+            \"self\" => SELF_KW,\n+            \"super\" => SUPER_KW,\n+            \"in\" => IN_KW,\n+            \"where\" => WHERE_KW,\n+            \"for\" => FOR_KW,\n+            \"loop\" => LOOP_KW,\n+            \"while\" => WHILE_KW,\n+            \"if\" => IF_KW,\n+            \"match\" => MATCH_KW,\n+            \"const\" => CONST_KW,\n+            \"static\" => STATIC_KW,\n+            \"mut\" => MUT_KW,\n+            \"unsafe\" => UNSAFE_KW,\n+            \"type\" => TYPE_KW,\n+            \"ref\" => REF_KW,\n+            \"let\" => LET_KW,\n+            _ => return None,\n+        };\n+        Some(kw)\n     }\n }\n "}, {"sha": "aa672d89ab9fcdee6327b31cc254caf79bb3ae11", "filename": "src/syntax_kinds/generated.rs.tera", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6983091d6d255bcfd17c4f8c14015d8abc77928d/src%2Fsyntax_kinds%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/6983091d6d255bcfd17c4f8c14015d8abc77928d/src%2Fsyntax_kinds%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntax_kinds%2Fgenerated.rs.tera?ref=6983091d6d255bcfd17c4f8c14015d8abc77928d", "patch": "@@ -0,0 +1,59 @@\n+#![allow(bad_style, missing_docs, unreachable_pub)]\n+#![cfg_attr(rustfmt, rustfmt_skip)]\n+use super::SyntaxInfo;\n+\n+/// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum SyntaxKind {\n+{%- for t in tokens %}\n+    {{t}},\n+{%- endfor -%}\n+{% for kw in keywords %}\n+    {{kw | upper}}_KW,\n+{%- endfor -%}\n+{% for kw in contextual_keywords %}\n+    {{kw | upper}}_KW,\n+{%- endfor -%}\n+{% for node in nodes %}\n+    {{node}},\n+{%- endfor %}\n+    // Technical SyntaxKinds: they appear temporally during parsing,\n+    // but never end up in the final tree\n+    #[doc(hidden)]\n+    TOMBSTONE,\n+    #[doc(hidden)]\n+    EOF,\n+}\n+use self::SyntaxKind::*;\n+\n+impl SyntaxKind {\n+    pub(crate) fn info(self) -> &'static SyntaxInfo {\n+        match self {\n+{%- for t in tokens %}\n+            {{t}} => &SyntaxInfo { name: \"{{t}}\" },\n+{%- endfor -%}\n+{% for kw in keywords %}\n+            {{kw | upper}}_KW => &SyntaxInfo { name: \"{{kw | upper}}_KW\" },\n+{%- endfor -%}\n+{% for kw in contextual_keywords %}\n+            {{kw | upper}}_KW => &SyntaxInfo { name: \"{{kw | upper}}_KW\" },\n+{%- endfor -%}\n+{% for node in nodes %}\n+            {{node}} => &SyntaxInfo { name: \"{{node}}\" },\n+{%- endfor %}\n+\n+            TOMBSTONE => &SyntaxInfo { name: \"TOMBSTONE\" },\n+            EOF => &SyntaxInfo { name: \"EOF\" },\n+        }\n+    }\n+    pub(crate) fn from_keyword(ident: &str) -> Option<SyntaxKind> {\n+        let kw = match ident {\n+{%- for kw in keywords %}\n+            \"{{kw}}\" => {{kw | upper}}_KW,\n+{%- endfor %}\n+            _ => return None,\n+        };\n+        Some(kw)\n+    }\n+}\n+"}, {"sha": "4fcddebf024198a5142d7796bfcb793a075debf5", "filename": "tools/Cargo.toml", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6983091d6d255bcfd17c4f8c14015d8abc77928d/tools%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6983091d6d255bcfd17c4f8c14015d8abc77928d/tools%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tools%2FCargo.toml?ref=6983091d6d255bcfd17c4f8c14015d8abc77928d", "patch": "@@ -5,10 +5,9 @@ authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n publish = false\n \n [dependencies]\n-serde = \"1.0.26\"\n-serde_derive = \"1.0.26\"\n-file = \"1.1.1\"\n-ron = \"0.1.5\"\n-walkdir = \"2\"\n-itertools = \"0.7\"\n-libsyntax2 = { path = \"../\" }\n+ron = \"0.1.7\"\n+walkdir = \"2.1.3\"\n+itertools = \"0.7.8\"\n+tera = \"0.11\"\n+clap = \"2.32.0\"\n+failure = \"0.1.1\""}, {"sha": "a52e7b1193ca30c80c30e1a1ccb80f9c9f1ad8ca", "filename": "tools/src/bin/collect-tests.rs", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9a4957d143397256dc04f715660f758a65fcb9d1/tools%2Fsrc%2Fbin%2Fcollect-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4957d143397256dc04f715660f758a65fcb9d1/tools%2Fsrc%2Fbin%2Fcollect-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tools%2Fsrc%2Fbin%2Fcollect-tests.rs?ref=9a4957d143397256dc04f715660f758a65fcb9d1", "patch": "@@ -1,133 +0,0 @@\n-extern crate file;\n-extern crate itertools;\n-extern crate walkdir;\n-\n-use walkdir::WalkDir;\n-use itertools::Itertools;\n-\n-use std::path::{Path, PathBuf};\n-use std::collections::HashSet;\n-use std::fs;\n-\n-fn main() {\n-    let verify = ::std::env::args().any(|arg| arg == \"--verify\");\n-\n-    let d = grammar_dir();\n-    let tests = tests_from_dir(&d);\n-    let existing = existing_tests();\n-\n-    for t in existing.difference(&tests) {\n-        panic!(\"Test is deleted: {}\\n{}\", t.name, t.text);\n-    }\n-\n-    let new_tests = tests.difference(&existing);\n-    for (i, t) in new_tests.enumerate() {\n-        if verify {\n-            panic!(\"Inline test is not recorded: {}\", t.name);\n-        }\n-\n-        let name = format!(\"{:04}_{}.rs\", existing.len() + i + 1, t.name);\n-        println!(\"Creating {}\", name);\n-        let path = inline_tests_dir().join(name);\n-        file::put_text(&path, &t.text).unwrap();\n-    }\n-}\n-\n-#[derive(Debug, Eq)]\n-struct Test {\n-    name: String,\n-    text: String,\n-}\n-\n-impl PartialEq for Test {\n-    fn eq(&self, other: &Test) -> bool {\n-        self.name.eq(&other.name)\n-    }\n-}\n-\n-impl ::std::hash::Hash for Test {\n-    fn hash<H: ::std::hash::Hasher>(&self, state: &mut H) {\n-        self.name.hash(state)\n-    }\n-}\n-\n-fn tests_from_dir(dir: &Path) -> HashSet<Test> {\n-    let mut res = HashSet::new();\n-    for entry in WalkDir::new(dir) {\n-        let entry = entry.unwrap();\n-        if !entry.file_type().is_file() {\n-            continue;\n-        }\n-        if entry.path().extension().unwrap_or_default() != \"rs\" {\n-            continue;\n-        }\n-        let text = file::get_text(entry.path()).unwrap();\n-\n-        for test in collect_tests(&text) {\n-            if let Some(old_test) = res.replace(test) {\n-                panic!(\"Duplicate test: {}\", old_test.name)\n-            }\n-        }\n-    }\n-    res\n-}\n-\n-fn collect_tests(s: &str) -> Vec<Test> {\n-    let mut res = vec![];\n-    let prefix = \"// \";\n-    let comment_blocks = s.lines()\n-        .map(str::trim_left)\n-        .group_by(|line| line.starts_with(prefix));\n-\n-    'outer: for (is_comment, block) in comment_blocks.into_iter() {\n-        if !is_comment {\n-            continue;\n-        }\n-        let mut block = block.map(|line| &line[prefix.len()..]);\n-\n-        let name = loop {\n-            match block.next() {\n-                Some(line) if line.starts_with(\"test \") => break line[\"test \".len()..].to_string(),\n-                Some(_) => (),\n-                None => continue 'outer,\n-            }\n-        };\n-        let text: String = itertools::join(block.chain(::std::iter::once(\"\")), \"\\n\");\n-        assert!(!text.trim().is_empty() && text.ends_with(\"\\n\"));\n-        res.push(Test { name, text })\n-    }\n-    res\n-}\n-\n-fn existing_tests() -> HashSet<Test> {\n-    let mut res = HashSet::new();\n-    for file in fs::read_dir(&inline_tests_dir()).unwrap() {\n-        let file = file.unwrap();\n-        let path = file.path();\n-        if path.extension().unwrap_or_default() != \"rs\" {\n-            continue;\n-        }\n-        let name = path.file_name().unwrap().to_str().unwrap();\n-        let name = name[\"0000_\".len()..name.len() - 3].to_string();\n-        let text = file::get_text(&path).unwrap();\n-        res.insert(Test { name, text });\n-    }\n-    res\n-}\n-\n-fn inline_tests_dir() -> PathBuf {\n-    let res = base_dir().join(\"tests/data/parser/inline\");\n-    if !res.is_dir() {\n-        fs::create_dir_all(&res).unwrap();\n-    }\n-    res\n-}\n-\n-fn grammar_dir() -> PathBuf {\n-    base_dir().join(\"src/parser/grammar\")\n-}\n-\n-fn base_dir() -> PathBuf {\n-    let dir = env!(\"CARGO_MANIFEST_DIR\");\n-    PathBuf::from(dir).parent().unwrap().to_owned()\n-}"}, {"sha": "2d3cd422d38342052c5c6831f8fb0f901ab7687d", "filename": "tools/src/bin/gen.rs", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/9a4957d143397256dc04f715660f758a65fcb9d1/tools%2Fsrc%2Fbin%2Fgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4957d143397256dc04f715660f758a65fcb9d1/tools%2Fsrc%2Fbin%2Fgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tools%2Fsrc%2Fbin%2Fgen.rs?ref=9a4957d143397256dc04f715660f758a65fcb9d1", "patch": "@@ -1,121 +0,0 @@\n-extern crate serde;\n-#[macro_use]\n-extern crate serde_derive;\n-\n-extern crate file;\n-extern crate ron;\n-\n-use std::path::PathBuf;\n-use std::fmt::Write;\n-\n-fn main() {\n-    let grammar = Grammar::read();\n-    let text = grammar.to_syntax_kinds();\n-    let target = generated_file();\n-    if text != file::get_text(&target).unwrap_or_default() {\n-        file::put_text(&target, &text).unwrap();\n-    }\n-}\n-\n-#[derive(Deserialize)]\n-struct Grammar {\n-    keywords: Vec<String>,\n-    contextual_keywords: Vec<String>,\n-    tokens: Vec<String>,\n-    nodes: Vec<String>,\n-}\n-\n-impl Grammar {\n-    fn read() -> Grammar {\n-        let text = file::get_text(&grammar_file()).unwrap();\n-        ron::de::from_str(&text).unwrap()\n-    }\n-\n-    fn to_syntax_kinds(&self) -> String {\n-        let mut acc = String::new();\n-        acc.push_str(\"#![allow(bad_style, missing_docs, unreachable_pub)]\\n\");\n-        acc.push_str(\"#![cfg_attr(rustfmt, rustfmt_skip)]\\n\");\n-        acc.push_str(\"//! Generated from grammar.ron\\n\");\n-        acc.push_str(\"use super::SyntaxInfo;\\n\");\n-        acc.push_str(\"\\n\");\n-\n-        let syntax_kinds: Vec<String> = self.tokens\n-            .iter()\n-            .cloned()\n-            .chain(self.keywords.iter().map(|kw| kw_token(kw)))\n-            .chain(self.contextual_keywords.iter().map(|kw| kw_token(kw)))\n-            .chain(self.nodes.iter().cloned())\n-            .collect();\n-\n-        // enum SyntaxKind\n-        acc.push_str(\"/// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.\\n\");\n-        acc.push_str(\"#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\\n\");\n-        acc.push_str(\"pub enum SyntaxKind {\\n\");\n-        for kind in syntax_kinds.iter() {\n-            write!(acc, \"    {},\\n\", scream(kind)).unwrap();\n-        }\n-        acc.push_str(\"\\n\");\n-        acc.push_str(\"    // Technical SyntaxKinds: they appear temporally during parsing,\\n\");\n-        acc.push_str(\"    // but never end up in the final tree\\n\");\n-        acc.push_str(\"    #[doc(hidden)]\\n\");\n-        acc.push_str(\"    TOMBSTONE,\\n\");\n-        acc.push_str(\"    #[doc(hidden)]\\n\");\n-        acc.push_str(\"    EOF,\\n\");\n-        acc.push_str(\"}\\n\");\n-        acc.push_str(\"pub(crate) use self::SyntaxKind::*;\\n\");\n-        acc.push_str(\"\\n\");\n-\n-        // fn info\n-        acc.push_str(\"impl SyntaxKind {\\n\");\n-        acc.push_str(\"    pub(crate) fn info(self) -> &'static SyntaxInfo {\\n\");\n-        acc.push_str(\"        match self {\\n\");\n-        for kind in syntax_kinds.iter() {\n-            let sname = scream(kind);\n-            write!(\n-                acc,\n-                \"            {sname} => &SyntaxInfo {{ name: \\\"{sname}\\\" }},\\n\",\n-                sname = sname\n-            ).unwrap();\n-        }\n-        acc.push_str(\"\\n\");\n-        acc.push_str(\"            TOMBSTONE => &SyntaxInfo { name: \\\"TOMBSTONE\\\" },\\n\");\n-        acc.push_str(\"            EOF => &SyntaxInfo { name: \\\"EOF\\\" },\\n\");\n-        acc.push_str(\"        }\\n\");\n-        acc.push_str(\"    }\\n\");\n-\n-        // fn from_keyword\n-        acc.push_str(\"    pub(crate) fn from_keyword(ident: &str) -> Option<SyntaxKind> {\\n\");\n-        acc.push_str(\"        match ident {\\n\");\n-        // NB: no contextual_keywords here!\n-        for kw in self.keywords.iter() {\n-            write!(acc, \"            {:?} => Some({}),\\n\", kw, kw_token(kw)).unwrap();\n-        }\n-        acc.push_str(\"            _ => None,\\n\");\n-        acc.push_str(\"        }\\n\");\n-        acc.push_str(\"    }\\n\");\n-        acc.push_str(\"}\\n\");\n-        acc.push_str(\"\\n\");\n-        acc\n-    }\n-}\n-\n-fn grammar_file() -> PathBuf {\n-    base_dir().join(\"src/grammar.ron\")\n-}\n-\n-fn generated_file() -> PathBuf {\n-    base_dir().join(\"src/syntax_kinds/generated.rs\")\n-}\n-\n-fn scream(word: &str) -> String {\n-    word.chars().map(|c| c.to_ascii_uppercase()).collect()\n-}\n-\n-fn kw_token(keyword: &str) -> String {\n-    format!(\"{}_KW\", scream(keyword))\n-}\n-\n-fn base_dir() -> PathBuf {\n-    let dir = env!(\"CARGO_MANIFEST_DIR\");\n-    PathBuf::from(dir).parent().unwrap().to_owned()\n-}"}, {"sha": "6a9793fff10d77bb1f2fcc11a28ac685930a4d27", "filename": "tools/src/bin/main.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/6983091d6d255bcfd17c4f8c14015d8abc77928d/tools%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6983091d6d255bcfd17c4f8c14015d8abc77928d/tools%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tools%2Fsrc%2Fbin%2Fmain.rs?ref=6983091d6d255bcfd17c4f8c14015d8abc77928d", "patch": "@@ -0,0 +1,184 @@\n+extern crate clap;\n+#[macro_use]\n+extern crate failure;\n+extern crate tera;\n+extern crate ron;\n+extern crate walkdir;\n+extern crate itertools;\n+\n+use std::{\n+    fs,\n+    path::{Path},\n+    collections::HashSet,\n+};\n+use clap::{App, Arg, SubCommand};\n+use itertools::Itertools;\n+\n+type Result<T> = ::std::result::Result<T, failure::Error>;\n+\n+const GRAMMAR_DIR: &str = \"./src/parser/grammar\";\n+const INLINE_TESTS_DIR: &str = \"tests/data/parser/inline\";\n+const GRAMMAR: &str = \"./src/grammar.ron\";\n+const SYNTAX_KINDS: &str = \"./src/syntax_kinds/generated.rs\";\n+const SYNTAX_KINDS_TEMPLATE: &str = \"./src/syntax_kinds/generated.rs.tera\";\n+\n+fn main() -> Result<()> {\n+    let matches = App::new(\"tasks\")\n+        .setting(clap::AppSettings::SubcommandRequiredElseHelp)\n+        .arg(\n+            Arg::with_name(\"verify\")\n+                .long(\"--verify\")\n+                .help(\"Verify that generated code is up-to-date\")\n+                .global(true)\n+        )\n+        .subcommand(SubCommand::with_name(\"gen-kinds\"))\n+        .subcommand(SubCommand::with_name(\"gen-tests\"))\n+        .get_matches();\n+    match matches.subcommand() {\n+        (name, Some(matches)) => run_gen_command(name, matches.is_present(\"verify\"))?,\n+        _ => unreachable!(),\n+    }\n+    Ok(())\n+}\n+\n+fn run_gen_command(name: &str, verify: bool) -> Result<()> {\n+    match name {\n+        \"gen-kinds\" => update(Path::new(SYNTAX_KINDS), &get_kinds()?, verify),\n+        \"gen-tests\" => gen_tests(verify),\n+        _ => unreachable!(),\n+    }\n+}\n+\n+fn update(path: &Path, contents: &str, verify: bool) -> Result<()> {\n+    match fs::read_to_string(path) {\n+        Ok(ref old_contents) if old_contents == contents => {\n+            return Ok(());\n+        }\n+        _ => (),\n+    }\n+    if verify {\n+        bail!(\"`{}` is not up-to-date\", path.display());\n+    }\n+    fs::write(path, contents)?;\n+    Ok(())\n+}\n+\n+fn get_kinds() -> Result<String> {\n+    let grammar = grammar()?;\n+    let template = fs::read_to_string(SYNTAX_KINDS_TEMPLATE)?;\n+    let ret = tera::Tera::one_off(&template, &grammar, false).map_err(|e| {\n+        format_err!(\"template error: {}\", e)\n+    })?;\n+    Ok(ret)\n+}\n+\n+fn grammar() -> Result<ron::value::Value> {\n+    let text = fs::read_to_string(GRAMMAR)?;\n+    let ret = ron::de::from_str(&text)?;\n+    Ok(ret)\n+}\n+\n+fn gen_tests(verify: bool) -> Result<()> {\n+    let tests = tests_from_dir(Path::new(GRAMMAR_DIR))?;\n+\n+    let inline_tests_dir = Path::new(INLINE_TESTS_DIR);\n+    if !inline_tests_dir.is_dir() {\n+        fs::create_dir_all(inline_tests_dir)?;\n+    }\n+    let existing = existing_tests(inline_tests_dir)?;\n+\n+    for t in existing.difference(&tests) {\n+        panic!(\"Test is deleted: {}\\n{}\", t.name, t.text);\n+    }\n+\n+    let new_tests = tests.difference(&existing);\n+    for (i, t) in new_tests.enumerate() {\n+        let name = format!(\"{:04}_{}.rs\", existing.len() + i + 1, t.name);\n+        let path = inline_tests_dir.join(name);\n+        update(&path, &t.text, verify)?;\n+    }\n+    Ok(())\n+}\n+\n+#[derive(Debug, Eq)]\n+struct Test {\n+    name: String,\n+    text: String,\n+}\n+\n+impl PartialEq for Test {\n+    fn eq(&self, other: &Test) -> bool {\n+        self.name.eq(&other.name)\n+    }\n+}\n+\n+impl ::std::hash::Hash for Test {\n+    fn hash<H: ::std::hash::Hasher>(&self, state: &mut H) {\n+        self.name.hash(state)\n+    }\n+}\n+\n+fn tests_from_dir(dir: &Path) -> Result<HashSet<Test>> {\n+    let mut res = HashSet::new();\n+    for entry in ::walkdir::WalkDir::new(dir) {\n+        let entry = entry.unwrap();\n+        if !entry.file_type().is_file() {\n+            continue;\n+        }\n+        if entry.path().extension().unwrap_or_default() != \"rs\" {\n+            continue;\n+        }\n+        let text = fs::read_to_string(entry.path())?;\n+\n+        for test in collect_tests(&text) {\n+            if let Some(old_test) = res.replace(test) {\n+                bail!(\"Duplicate test: {}\", old_test.name)\n+            }\n+        }\n+    }\n+    Ok(res)\n+}\n+\n+fn collect_tests(s: &str) -> Vec<Test> {\n+    let mut res = vec![];\n+    let prefix = \"// \";\n+    let comment_blocks = s.lines()\n+        .map(str::trim_left)\n+        .group_by(|line| line.starts_with(prefix));\n+\n+    'outer: for (is_comment, block) in comment_blocks.into_iter() {\n+        if !is_comment {\n+            continue;\n+        }\n+        let mut block = block.map(|line| &line[prefix.len()..]);\n+\n+        let name = loop {\n+            match block.next() {\n+                Some(line) if line.starts_with(\"test \") => break line[\"test \".len()..].to_string(),\n+                Some(_) => (),\n+                None => continue 'outer,\n+            }\n+        };\n+        let text: String = itertools::join(block.chain(::std::iter::once(\"\")), \"\\n\");\n+        assert!(!text.trim().is_empty() && text.ends_with(\"\\n\"));\n+        res.push(Test { name, text })\n+    }\n+    res\n+}\n+\n+fn existing_tests(dir: &Path) -> Result<HashSet<Test>> {\n+    let mut res = HashSet::new();\n+    for file in fs::read_dir(dir)? {\n+        let file = file?;\n+        let path = file.path();\n+        if path.extension().unwrap_or_default() != \"rs\" {\n+            continue;\n+        }\n+        let name = path.file_name().unwrap().to_str().unwrap();\n+        let name = name[\"0000_\".len()..name.len() - 3].to_string();\n+        let text = fs::read_to_string(&path)?;\n+        res.insert(Test { name, text });\n+    }\n+    Ok(res)\n+}\n+"}]}