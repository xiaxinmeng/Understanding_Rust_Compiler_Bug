{"sha": "2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlZDk4MGZlMjUzZDBiNzEwM2ZmMGIxNmNlMmFlZWNiMDNmMDkyMDM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T04:57:17Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T15:59:03Z"}, "message": "std,extra: remove use of & support for @[].", "tree": {"sha": "7c4892e371519a81effee35d982f4caaf0b23453", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c4892e371519a81effee35d982f4caaf0b23453"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "html_url": "https://github.com/rust-lang/rust/commit/2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0c1707560d02bb5805b33cb17e8abfc339eb16b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0c1707560d02bb5805b33cb17e8abfc339eb16b", "html_url": "https://github.com/rust-lang/rust/commit/e0c1707560d02bb5805b33cb17e8abfc339eb16b"}], "stats": {"total": 568, "additions": 2, "deletions": 566}, "files": [{"sha": "cea899b18c01a112ddc9ff46a536c82f037e68af", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -80,7 +80,7 @@ pub mod BigDigit {\n /**\n A big unsigned integer type.\n \n-A `BigUint`-typed value `BigUint { data: @[a, b, c] }` represents a number\n+A `BigUint`-typed value `BigUint { data: ~[a, b, c] }` represents a number\n `(a + b * BigDigit::base + c * BigDigit::base^2)`.\n */\n #[deriving(Clone)]"}, {"sha": "9b1b1e0548e0727dd059cfc30413a4f8190c7022", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -18,7 +18,6 @@ Core encoding and decoding interfaces.\n #[forbid(non_camel_case_types)];\n \n \n-use std::at_vec;\n use std::hashmap::{HashMap, HashSet};\n use std::rc::Rc;\n use std::trie::{TrieMap, TrieSet};\n@@ -444,26 +443,6 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))\n-            }\n-        })\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n-    fn decode(d: &mut D) -> @[T] {\n-        d.read_seq(|d, len| {\n-            at_vec::from_fn(len, |i| {\n-                d.read_seq_elt(i, |d| Decodable::decode(d))\n-            })\n-        })\n-    }\n-}\n-\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &mut S) {\n         s.emit_option(|s| {"}, {"sha": "6a3c74482d35c978f8d388c9a722d3044be9a5d6", "filename": "src/libstd/at_vec.rs", "status": "removed", "additions": 0, "deletions": 423, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/e0c1707560d02bb5805b33cb17e8abfc339eb16b/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0c1707560d02bb5805b33cb17e8abfc339eb16b/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=e0c1707560d02bb5805b33cb17e8abfc339eb16b", "patch": "@@ -1,423 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations on managed vectors (`@[T]` type)\n-\n-use clone::Clone;\n-use container::Container;\n-use iter::{Iterator, FromIterator};\n-use option::{Option, Some, None};\n-use mem;\n-use unstable::raw::Repr;\n-use vec::{ImmutableVector, OwnedVector};\n-\n-/// Code for dealing with @-vectors. This is pretty incomplete, and\n-/// contains a bunch of duplication from the code for ~-vectors.\n-\n-/// Returns the number of elements the vector can hold without reallocating\n-#[inline]\n-pub fn capacity<T>(v: @[T]) -> uint {\n-    unsafe {\n-        let managed_box = v.repr();\n-        (*managed_box).data.alloc / mem::size_of::<T>()\n-    }\n-}\n-\n-/**\n- * Builds a vector by calling a provided function with an argument\n- * function that pushes an element to the back of a vector.\n- * The initial size for the vector may optionally be specified\n- *\n- * # Arguments\n- *\n- * * size - An option, maybe containing initial size of the vector to reserve\n- * * builder - A function that will construct the vector. It receives\n- *             as an argument a function that will push an element\n- *             onto the vector being constructed.\n- */\n-#[inline]\n-pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> @[A] {\n-    let mut vec = @[];\n-    unsafe { raw::reserve(&mut vec, size.unwrap_or(4)); }\n-    builder(|x| unsafe { raw::push(&mut vec, x) });\n-    vec\n-}\n-\n-// Appending\n-\n-/// Iterates over the `rhs` vector, copying each element and appending it to the\n-/// `lhs`. Afterwards, the `lhs` is then returned for use again.\n-#[inline]\n-pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n-    build(Some(lhs.len() + rhs.len()), |push| {\n-        for x in lhs.iter() {\n-            push((*x).clone());\n-        }\n-        for elt in rhs.iter() {\n-            push(elt.clone());\n-        }\n-    })\n-}\n-\n-\n-/// Apply a function to each element of a vector and return the results\n-#[inline]\n-pub fn map<T, U>(v: &[T], f: |x: &T| -> U) -> @[U] {\n-    build(Some(v.len()), |push| {\n-        for elem in v.iter() {\n-            push(f(elem));\n-        }\n-    })\n-}\n-\n-/**\n- * Creates and initializes an immutable vector.\n- *\n- * Creates an immutable vector of size `n_elts` and initializes the elements\n- * to the value returned by the function `op`.\n- */\n-#[inline]\n-pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> @[T] {\n-    build(Some(n_elts), |push| {\n-        let mut i: uint = 0u;\n-        while i < n_elts { push(op(i)); i += 1u; }\n-    })\n-}\n-\n-/**\n- * Creates and initializes an immutable vector.\n- *\n- * Creates an immutable vector of size `n_elts` and initializes the elements\n- * to the value `t`.\n- */\n-#[inline]\n-pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> @[T] {\n-    build(Some(n_elts), |push| {\n-        let mut i: uint = 0u;\n-        while i < n_elts {\n-            push(t.clone());\n-            i += 1u;\n-        }\n-    })\n-}\n-\n-/**\n- * Creates and initializes an immutable managed vector by moving all the\n- * elements from an owned vector.\n- */\n-#[inline]\n-pub fn to_managed_move<T>(v: ~[T]) -> @[T] {\n-    let mut av = @[];\n-    unsafe {\n-        raw::reserve(&mut av, v.len());\n-        for x in v.move_iter() {\n-            raw::push(&mut av, x);\n-        }\n-        av\n-    }\n-}\n-\n-/**\n- * Creates and initializes an immutable managed vector by copying all the\n- * elements of a slice.\n- */\n-#[inline]\n-pub fn to_managed<T:Clone>(v: &[T]) -> @[T] {\n-    from_fn(v.len(), |i| v[i].clone())\n-}\n-\n-impl<T> Clone for @[T] {\n-    fn clone(&self) -> @[T] {\n-        *self\n-    }\n-}\n-\n-impl<A> FromIterator<A> for @[A] {\n-    #[inline]\n-    fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> @[A] {\n-        let (lower, _) = iterator.size_hint();\n-        build(Some(lower), |push| {\n-            for x in *iterator {\n-                push(x);\n-            }\n-        })\n-    }\n-}\n-\n-#[cfg(not(test))]\n-#[allow(missing_doc)]\n-pub mod traits {\n-    use at_vec::append;\n-    use clone::Clone;\n-    use ops::Add;\n-    use vec::Vector;\n-\n-    impl<'a,T:Clone, V: Vector<T>> Add<V,@[T]> for @[T] {\n-        #[inline]\n-        fn add(&self, rhs: &V) -> @[T] {\n-            append(*self, rhs.as_slice())\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-pub mod traits {}\n-\n-#[allow(missing_doc)]\n-pub mod raw {\n-    use at_vec::capacity;\n-    use cast;\n-    use cast::{transmute, transmute_copy};\n-    use container::Container;\n-    use option::None;\n-    use mem;\n-    use num::next_power_of_two;\n-    use ptr;\n-    use unstable::intrinsics::{move_val_init, TyDesc};\n-    use unstable::intrinsics;\n-    use unstable::raw::{Box, Vec};\n-\n-    /**\n-     * Sets the length of a vector\n-     *\n-     * This will explicitly set the size of the vector, without actually\n-     * modifying its buffers, so it is up to the caller to ensure that\n-     * the vector is actually the specified size.\n-     */\n-    #[inline]\n-    pub unsafe fn set_len<T>(v: &mut @[T], new_len: uint) {\n-        let repr: *mut Box<Vec<T>> = cast::transmute_copy(v);\n-        (*repr).data.fill = new_len * mem::size_of::<T>();\n-    }\n-\n-    /**\n-     * Pushes a new value onto this vector.\n-     */\n-    #[inline]\n-    pub unsafe fn push<T>(v: &mut @[T], initval: T) {\n-        let full = {\n-            let repr: *Box<Vec<T>> = cast::transmute_copy(v);\n-            (*repr).data.alloc > (*repr).data.fill\n-        };\n-        if full {\n-            push_fast(v, initval);\n-        } else {\n-            push_slow(v, initval);\n-        }\n-    }\n-\n-    #[inline] // really pretty please\n-    unsafe fn push_fast<T>(v: &mut @[T], initval: T) {\n-        let repr: *mut Box<Vec<T>> = cast::transmute_copy(v);\n-        let amt = v.len();\n-        (*repr).data.fill += mem::size_of::<T>();\n-        let p = ptr::offset(&(*repr).data.data as *T, amt as int) as *mut T;\n-        move_val_init(&mut(*p), initval);\n-    }\n-\n-    #[inline]\n-    unsafe fn push_slow<T>(v: &mut @[T], initval: T) {\n-        reserve_at_least(v, v.len() + 1u);\n-        push_fast(v, initval);\n-    }\n-\n-    /**\n-     * Reserves capacity for exactly `n` elements in the given vector.\n-     *\n-     * If the capacity for `v` is already equal to or greater than the\n-     * requested capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * v - A vector\n-     * * n - The number of elements to reserve space for\n-     */\n-    #[inline]\n-    pub unsafe fn reserve<T>(v: &mut @[T], n: uint) {\n-        // Only make the (slow) call into the runtime if we have to\n-        if capacity(*v) < n {\n-            let ptr: *mut *mut Box<Vec<()>> = transmute(v);\n-            let ty = intrinsics::get_tydesc::<T>();\n-            return reserve_raw(ty, ptr, n);\n-        }\n-    }\n-\n-    // Implementation detail. Shouldn't be public\n-    #[allow(missing_doc)]\n-    #[inline]\n-    pub fn reserve_raw(ty: *TyDesc, ptr: *mut *mut Box<Vec<()>>, n: uint) {\n-        // check for `uint` overflow\n-        unsafe {\n-            if n > (**ptr).data.alloc / (*ty).size {\n-                let alloc = n * (*ty).size;\n-                let total_size = alloc + mem::size_of::<Vec<()>>();\n-                if alloc / (*ty).size != n || total_size < alloc {\n-                    fail!(\"vector size is too large: {}\", n);\n-                }\n-                (*ptr) = local_realloc(*ptr as *(), total_size) as *mut Box<Vec<()>>;\n-                (**ptr).data.alloc = alloc;\n-            }\n-        }\n-\n-        #[inline]\n-        fn local_realloc(ptr: *(), size: uint) -> *() {\n-            use rt::local::Local;\n-            use rt::task::Task;\n-\n-            let mut task = Local::borrow(None::<Task>);\n-            task.get().heap.realloc(ptr as *mut Box<()>, size) as *()\n-        }\n-    }\n-\n-    /**\n-     * Reserves capacity for at least `n` elements in the given vector.\n-     *\n-     * This function will over-allocate in order to amortize the\n-     * allocation costs in scenarios where the caller may need to\n-     * repeatedly reserve additional space.\n-     *\n-     * If the capacity for `v` is already equal to or greater than the\n-     * requested capacity, then no action is taken.\n-     *\n-     * # Arguments\n-     *\n-     * * v - A vector\n-     * * n - The number of elements to reserve space for\n-     */\n-    #[inline]\n-    pub unsafe fn reserve_at_least<T>(v: &mut @[T], n: uint) {\n-        reserve(v, next_power_of_two(n));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use prelude::*;\n-    use bh = extra::test::BenchHarness;\n-\n-    #[test]\n-    fn test() {\n-        // Some code that could use that, then:\n-        fn seq_range(lo: uint, hi: uint) -> @[uint] {\n-            build(None, |push| {\n-                for i in range(lo, hi) {\n-                    push(i);\n-                }\n-            })\n-        }\n-\n-        assert_eq!(seq_range(10, 15), @[10, 11, 12, 13, 14]);\n-        assert_eq!(from_fn(5, |x| x+1), @[1, 2, 3, 4, 5]);\n-        assert_eq!(from_elem(5, 3.14), @[3.14, 3.14, 3.14, 3.14, 3.14]);\n-    }\n-\n-    #[test]\n-    fn append_test() {\n-        assert_eq!(@[1,2,3] + &[4,5,6], @[1,2,3,4,5,6]);\n-    }\n-\n-    #[test]\n-    fn test_to_managed_move() {\n-        assert_eq!(to_managed_move::<int>(~[]), @[]);\n-        assert_eq!(to_managed_move(~[true]), @[true]);\n-        assert_eq!(to_managed_move(~[1, 2, 3, 4, 5]), @[1, 2, 3, 4, 5]);\n-        assert_eq!(to_managed_move(~[~\"abc\", ~\"123\"]), @[~\"abc\", ~\"123\"]);\n-        assert_eq!(to_managed_move(~[~[42]]), @[~[42]]);\n-    }\n-\n-    #[test]\n-    fn test_to_managed() {\n-        assert_eq!(to_managed::<int>([]), @[]);\n-        assert_eq!(to_managed([true]), @[true]);\n-        assert_eq!(to_managed([1, 2, 3, 4, 5]), @[1, 2, 3, 4, 5]);\n-        assert_eq!(to_managed([@[42]]), @[@[42]]);\n-    }\n-\n-    #[bench]\n-    fn bench_capacity(b: &mut bh) {\n-        let x = @[1, 2, 3];\n-        b.iter(|| {\n-            let _ = capacity(x);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_build_sized(b: &mut bh) {\n-        let len = 64;\n-        b.iter(|| {\n-            build(Some(len), |push| for i in range(0, 1024) { push(i) });\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_build(b: &mut bh) {\n-        b.iter(|| {\n-            for i in range(0, 95) {\n-                build(None, |push| push(i));\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_append(b: &mut bh) {\n-        let lhs = @[7, ..128];\n-        let rhs = range(0, 256).to_owned_vec();\n-        b.iter(|| {\n-            let _ = append(lhs, rhs);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_map(b: &mut bh) {\n-        let elts = range(0, 256).to_owned_vec();\n-        b.iter(|| {\n-            let _ = map(elts, |x| x*2);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_from_fn(b: &mut bh) {\n-        b.iter(|| {\n-            let _ = from_fn(1024, |x| x);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_from_elem(b: &mut bh) {\n-        b.iter(|| {\n-            let _ = from_elem(1024, 0u64);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_to_managed_move(b: &mut bh) {\n-        b.iter(|| {\n-            let elts = range(0, 1024).to_owned_vec(); // yikes! can't move out of capture, though\n-            to_managed_move(elts);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_to_managed(b: &mut bh) {\n-        let elts = range(0, 1024).to_owned_vec();\n-        b.iter(|| {\n-            let _ = to_managed(elts);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_clone(b: &mut bh) {\n-        let elts = to_managed(range(0, 1024).to_owned_vec());\n-        b.iter(|| {\n-            let _ = elts.clone();\n-        });\n-    }\n-}"}, {"sha": "adce11fed2dad9160249b176c2c85a90e2efca38", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -114,7 +114,6 @@ pub mod tuple;\n \n pub mod vec;\n pub mod vec_ng;\n-pub mod at_vec;\n pub mod str;\n \n pub mod ascii;"}, {"sha": "c5482811a94d60f51b9327bd52748cbb055aa595", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -622,13 +622,6 @@ impl BytesContainer for ~[u8] {\n     }\n }\n \n-impl BytesContainer for @[u8] {\n-    #[inline]\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        self.as_slice()\n-    }\n-}\n-\n impl BytesContainer for CString {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {"}, {"sha": "ba0cd0bb521dc4fc5245f8cd7c273cdf767560fe", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -807,8 +807,6 @@ mod tests {\n \n     #[test]\n     fn test_push_many() {\n-        use to_man = at_vec::to_managed_move;\n-\n         macro_rules! t(\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n@@ -833,8 +831,6 @@ mod tests {\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"/e\"), b!(\"f\")], b!(\"/e/f\"));\n         t!(v: b!(\"a/b/c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a/b/c/d/e\"));\n-        t!(v: b!(\"a/b/c\"), [to_man(b!(\"d\").to_owned()), to_man(b!(\"e\").to_owned())],\n-              b!(\"a/b/c/d/e\"));\n     }\n \n     #[test]\n@@ -916,8 +912,6 @@ mod tests {\n \n     #[test]\n     fn test_join_many() {\n-        use to_man = at_vec::to_managed_move;\n-\n         macro_rules! t(\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n@@ -941,8 +935,6 @@ mod tests {\n         t!(s: \"a/b/c\", [~\"d\", ~\"e\"], \"a/b/c/d/e\");\n         t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n         t!(v: b!(\"a/b/c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a/b/c/d/e\"));\n-        t!(v: b!(\"a/b/c\"), [to_man(b!(\"d\").to_owned()), to_man(b!(\"e\").to_owned())],\n-              b!(\"a/b/c/d/e\"));\n     }\n \n     #[test]"}, {"sha": "eec6f37b627a2da640c13df53f77b9692b9b6988", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -1587,8 +1587,6 @@ mod tests {\n \n     #[test]\n     fn test_push_many() {\n-        use to_man = at_vec::to_managed_move;\n-\n         macro_rules! t(\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n@@ -1613,8 +1611,6 @@ mod tests {\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"\\\\e\"), b!(\"f\")], b!(\"\\\\e\\\\f\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), [to_man(b!(\"d\").to_owned()), to_man(b!(\"e\").to_owned())],\n-              b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n     }\n \n     #[test]\n@@ -1731,8 +1727,6 @@ mod tests {\n \n     #[test]\n     fn test_join_many() {\n-        use to_man = at_vec::to_managed_move;\n-\n         macro_rules! t(\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n@@ -1756,8 +1750,6 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [~\"d\", ~\"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n         t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\").to_owned(), b!(\"e\").to_owned()], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), [to_man(b!(\"d\").to_owned()), to_man(b!(\"e\").to_owned())],\n-              b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n     }\n \n     #[test]"}, {"sha": "a7cea1c7e4afd8ff41d90094072d5ab4662738bf", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -251,9 +251,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@[u8]>();\n-        if ! self.inner.visit_evec_box(mtbl, inner) { return false; }\n-        self.bump_past::<@[u8]>();\n         true\n     }\n "}, {"sha": "41ddf02778768d1cd42e7c1ffeaed4ffadc64a93", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -637,12 +637,6 @@ fn test_repr() {\n     exact_test(&(0 as *mut ()), \"(0x0 as *mut ())\");\n \n     exact_test(&(1,), \"(1,)\");\n-    exact_test(&(@[1,2,3,4,5,6,7,8]),\n-               \"@[1, 2, 3, 4, 5, 6, 7, 8]\");\n-    exact_test(&(@[1u8,2u8,3u8,4u8]),\n-               \"@[1u8, 2u8, 3u8, 4u8]\");\n-    exact_test(&(@[\"hi\", \"there\"]),\n-               \"@[\\\"hi\\\", \\\"there\\\"]\");\n     exact_test(&(~[\"hi\", \"there\"]),\n                \"~[\\\"hi\\\", \\\"there\\\"]\");\n     exact_test(&(&[\"hi\", \"there\"]),"}, {"sha": "79936b4afad0afb473887e8dbbbf57fbd0c6170d", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -332,6 +332,6 @@ mod bench {\n \n     #[bench]\n     fn alloc_managed_big(bh: &mut BenchHarness) {\n-        bh.iter(|| { @[10, ..1000]; });\n+        bh.iter(|| { @([10, ..1000]); });\n     }\n }"}, {"sha": "4c545de73b48b23ad57304dfa8688e4aff46883a", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -266,13 +266,6 @@ impl<A:IterBytes> IterBytes for ~[A] {\n     }\n }\n \n-impl<A:IterBytes> IterBytes for @[A] {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        self.as_slice().iter_bytes(lsb0, f)\n-    }\n-}\n-\n impl<'a> IterBytes for &'a str {\n     #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {"}, {"sha": "87d59f0979194841bb28f827fc42c7bf8a45fc91", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -159,25 +159,6 @@ impl<A:ToStr> ToStr for ~[A] {\n     }\n }\n \n-impl<A:ToStr> ToStr for @[A] {\n-    #[inline]\n-    fn to_str(&self) -> ~str {\n-        let mut acc = ~\"[\";\n-        let mut first = true;\n-        for elt in self.iter() {\n-            if first {\n-                first = false;\n-            }\n-            else {\n-                acc.push_str(\", \");\n-            }\n-            acc.push_str(elt.to_str());\n-        }\n-        acc.push_char(']');\n-        acc\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use hashmap::HashMap;"}, {"sha": "63208b3f2d707a500f06ed76f16e21627c3a52ff", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -56,7 +56,6 @@ pub trait Repr<T> {\n impl<'a, T> Repr<Slice<T>> for &'a [T] {}\n impl<'a> Repr<Slice<u8>> for &'a str {}\n impl<T> Repr<*Box<T>> for @T {}\n-impl<T> Repr<*Box<Vec<T>>> for @[T] {}\n impl<T> Repr<*Vec<T>> for ~[T] {}\n impl Repr<*String> for ~str {}\n "}, {"sha": "2679ef0d46e8e1dcad347c538555ec9219f0c32d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed980fe253d0b7103ff0b16ce2aeecb03f09203/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=2ed980fe253d0b7103ff0b16ce2aeecb03f09203", "patch": "@@ -646,13 +646,6 @@ pub mod traits {\n         fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n     }\n \n-    impl<T:Eq> Eq for @[T] {\n-        #[inline]\n-        fn eq(&self, other: &@[T]) -> bool { self.as_slice() == *other }\n-        #[inline]\n-        fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n-    }\n-\n     impl<'a,T:TotalEq> TotalEq for &'a [T] {\n         fn equals(&self, other: & &'a [T]) -> bool {\n             self.len() == other.len() &&\n@@ -665,11 +658,6 @@ pub mod traits {\n         fn equals(&self, other: &~[T]) -> bool { self.as_slice().equals(&other.as_slice()) }\n     }\n \n-    impl<T:TotalEq> TotalEq for @[T] {\n-        #[inline]\n-        fn equals(&self, other: &@[T]) -> bool { self.as_slice().equals(&other.as_slice()) }\n-    }\n-\n     impl<'a,T:Eq, V: Vector<T>> Equiv<V> for &'a [T] {\n         #[inline]\n         fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n@@ -680,11 +668,6 @@ pub mod traits {\n         fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n     }\n \n-    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for @[T] {\n-        #[inline]\n-        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-    }\n-\n     impl<'a,T:TotalOrd> TotalOrd for &'a [T] {\n         fn cmp(&self, other: & &'a [T]) -> Ordering {\n             order::cmp(self.iter(), other.iter())\n@@ -696,11 +679,6 @@ pub mod traits {\n         fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n     }\n \n-    impl<T: TotalOrd> TotalOrd for @[T] {\n-        #[inline]\n-        fn cmp(&self, other: &@[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n-    }\n-\n     impl<'a, T: Eq + Ord> Ord for &'a [T] {\n         fn lt(&self, other: & &'a [T]) -> bool {\n             order::lt(self.iter(), other.iter())\n@@ -730,17 +708,6 @@ pub mod traits {\n         fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }\n     }\n \n-    impl<T: Eq + Ord> Ord for @[T] {\n-        #[inline]\n-        fn lt(&self, other: &@[T]) -> bool { self.as_slice() < other.as_slice() }\n-        #[inline]\n-        fn le(&self, other: &@[T]) -> bool { self.as_slice() <= other.as_slice() }\n-        #[inline]\n-        fn ge(&self, other: &@[T]) -> bool { self.as_slice() >= other.as_slice() }\n-        #[inline]\n-        fn gt(&self, other: &@[T]) -> bool { self.as_slice() > other.as_slice() }\n-    }\n-\n     impl<'a,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'a [T] {\n         #[inline]\n         fn add(&self, rhs: &V) -> ~[T] {\n@@ -778,11 +745,6 @@ impl<T> Vector<T> for ~[T] {\n     fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n }\n \n-impl<T> Vector<T> for @[T] {\n-    #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n-}\n-\n impl<'a, T> Container for &'a [T] {\n     /// Returns the length of a vector\n     #[inline]\n@@ -833,15 +795,6 @@ impl<T: Clone> CloneableVector<T> for ~[T] {\n     fn into_owned(self) -> ~[T] { self }\n }\n \n-/// Extension methods for managed vectors\n-impl<T: Clone> CloneableVector<T> for @[T] {\n-    #[inline]\n-    fn to_owned(&self) -> ~[T] { self.as_slice().to_owned() }\n-\n-    #[inline(always)]\n-    fn into_owned(self) -> ~[T] { self.to_owned() }\n-}\n-\n /// Extension methods for vectors\n pub trait ImmutableVector<'a, T> {\n     /**\n@@ -2629,10 +2582,6 @@ impl<A> Default for ~[A] {\n     fn default() -> ~[A] { ~[] }\n }\n \n-impl<A> Default for @[A] {\n-    fn default() -> @[A] { @[] }\n-}\n-\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n         /// An iterator for iterating over a vector.\n@@ -3109,14 +3058,6 @@ mod tests {\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n-        // Test on managed heap.\n-        let vec_managed = @[1, 2, 3, 4, 5];\n-        let v_c = vec_managed.slice(0u, 3u).to_owned();\n-        assert_eq!(v_c.len(), 3u);\n-        assert_eq!(v_c[0], 1);\n-        assert_eq!(v_c[1], 2);\n-        assert_eq!(v_c[2], 3);\n-\n         // Test on exchange heap.\n         let vec_unique = ~[1, 2, 3, 4, 5, 6];\n         let v_d = vec_unique.slice(1u, 6u).to_owned();\n@@ -4052,7 +3993,6 @@ mod tests {\n         );\n \n         t!(&[int]);\n-        t!(@[int]);\n         t!(~[int]);\n     }\n "}]}