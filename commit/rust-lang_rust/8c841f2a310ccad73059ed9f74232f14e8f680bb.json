{"sha": "8c841f2a310ccad73059ed9f74232f14e8f680bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjODQxZjJhMzEwY2NhZDczMDU5ZWQ5Zjc0MjMyZjE0ZThmNjgwYmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-12T17:42:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-18T15:24:55Z"}, "message": "Extend coherence check to understand subtyping.", "tree": {"sha": "e97b990a590a817274e426516fff9f55a7c691b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e97b990a590a817274e426516fff9f55a7c691b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c841f2a310ccad73059ed9f74232f14e8f680bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c841f2a310ccad73059ed9f74232f14e8f680bb", "html_url": "https://github.com/rust-lang/rust/commit/8c841f2a310ccad73059ed9f74232f14e8f680bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c841f2a310ccad73059ed9f74232f14e8f680bb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91eedfe18b9be80b69ef2f19f4b618b2968ba181", "url": "https://api.github.com/repos/rust-lang/rust/commits/91eedfe18b9be80b69ef2f19f4b618b2968ba181", "html_url": "https://github.com/rust-lang/rust/commit/91eedfe18b9be80b69ef2f19f4b618b2968ba181"}], "stats": {"total": 162, "additions": 123, "deletions": 39}, "files": [{"sha": "e199a60c370e30cf732f0dbb2d3a300f9276e3f8", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 72, "deletions": 29, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8c841f2a310ccad73059ed9f74232f14e8f680bb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c841f2a310ccad73059ed9f74232f14e8f680bb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=8c841f2a310ccad73059ed9f74232f14e8f680bb", "patch": "@@ -10,53 +10,96 @@\n \n //! See `doc.rs` for high-level documentation\n \n+use super::Normalized;\n use super::SelectionContext;\n-use super::{Obligation, ObligationCause};\n+use super::{ObligationCause};\n+use super::PredicateObligation;\n use super::project;\n use super::util;\n \n use middle::subst::{Subst, TypeSpace};\n-use middle::ty::{self, Ty};\n-use middle::infer::InferCtxt;\n+use middle::ty::{self, ToPolyTraitRef, Ty};\n+use middle::infer::{self, InferCtxt};\n use std::collections::HashSet;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n use util::ppaux::Repr;\n \n-pub fn impl_can_satisfy(infcx: &InferCtxt,\n-                        impl1_def_id: ast::DefId,\n-                        impl2_def_id: ast::DefId)\n-                        -> bool\n+/// True if there exist types that satisfy both of the two given impls.\n+pub fn overlapping_impls(infcx: &InferCtxt,\n+                         impl1_def_id: ast::DefId,\n+                         impl2_def_id: ast::DefId)\n+                         -> bool\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={}, \\\n            impl2_def_id={})\",\n            impl1_def_id.repr(infcx.tcx),\n            impl2_def_id.repr(infcx.tcx));\n \n-    let param_env = ty::empty_parameter_environment(infcx.tcx);\n-    let mut selcx = SelectionContext::intercrate(infcx, &param_env);\n-    let cause = ObligationCause::dummy();\n-\n-    // `impl1` provides an implementation of `Foo<X,Y> for Z`.\n-    let impl1_substs =\n-        util::fresh_substs_for_impl(infcx, DUMMY_SP, impl1_def_id);\n-    let impl1_trait_ref =\n-        (*ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()).subst(infcx.tcx, &impl1_substs);\n-    let impl1_trait_ref =\n-        project::normalize(&mut selcx, cause.clone(), &impl1_trait_ref);\n-\n-    // Determine whether `impl2` can provide an implementation for those\n-    // same types.\n-    let obligation = Obligation::new(cause,\n-                                     ty::Binder(ty::TraitPredicate {\n-                                         trait_ref: Rc::new(impl1_trait_ref.value),\n-                                     }));\n-    debug!(\"impl_can_satisfy(obligation={})\", obligation.repr(infcx.tcx));\n-    selcx.evaluate_impl(impl2_def_id, &obligation) &&\n-        impl1_trait_ref.obligations.iter().all(\n-            |o| selcx.evaluate_obligation(o))\n+    let param_env = &ty::empty_parameter_environment(infcx.tcx);\n+    let selcx = &mut SelectionContext::intercrate(infcx, param_env);\n+    infcx.probe(|_| {\n+        overlap(selcx, impl1_def_id, impl2_def_id) || overlap(selcx, impl2_def_id, impl1_def_id)\n+    })\n+}\n+\n+/// Can the types from impl `a` be used to satisfy impl `b`?\n+/// (Including all conditions)\n+fn overlap(selcx: &mut SelectionContext,\n+           a_def_id: ast::DefId,\n+           b_def_id: ast::DefId)\n+           -> bool\n+{\n+    let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx, a_def_id);\n+    let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx, b_def_id);\n+\n+    // Does `a <: b` hold? If not, no overlap.\n+    if let Err(_) = infer::mk_sub_poly_trait_refs(selcx.infcx(),\n+                                                  true,\n+                                                  infer::Misc(DUMMY_SP),\n+                                                  a_trait_ref.to_poly_trait_ref(),\n+                                                  b_trait_ref.to_poly_trait_ref()) {\n+        return false;\n+    }\n+\n+    // Are any of the obligations unsatisfiable? If so, no overlap.\n+    a_obligations.iter()\n+                 .chain(b_obligations.iter())\n+                 .all(|o| selcx.evaluate_obligation(o))\n+}\n+\n+/// Instantiate fresh variables for all bound parameters of the impl\n+/// and return the impl trait ref with those variables substituted.\n+fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                                     impl_def_id: ast::DefId)\n+                                     -> (Rc<ty::TraitRef<'tcx>>,\n+                                         Vec<PredicateObligation<'tcx>>)\n+{\n+    let impl_substs =\n+        &util::fresh_substs_for_impl(selcx.infcx(), DUMMY_SP, impl_def_id);\n+    let impl_trait_ref =\n+        ty::impl_trait_ref(selcx.tcx(), impl_def_id).unwrap();\n+    let impl_trait_ref =\n+        impl_trait_ref.subst(selcx.tcx(), impl_substs);\n+    let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n+        project::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n+\n+    let predicates = ty::lookup_predicates(selcx.tcx(), impl_def_id);\n+    let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n+    let Normalized { value: predicates, obligations: normalization_obligations2 } =\n+        project::normalize(selcx, ObligationCause::dummy(), &predicates);\n+    let impl_obligations =\n+        util::predicates_for_generics(selcx.tcx(), ObligationCause::dummy(), 0, &predicates);\n+\n+    let impl_obligations: Vec<_> =\n+        impl_obligations.into_iter()\n+        .chain(normalization_obligations1.into_iter())\n+        .chain(normalization_obligations2.into_iter())\n+        .collect();\n+\n+    (impl_trait_ref, impl_obligations)\n }\n \n pub enum OrphanCheckErr<'tcx> {"}, {"sha": "2e4bcdf0478cece6d8f64b1262c660fe254e9a4e", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c841f2a310ccad73059ed9f74232f14e8f680bb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c841f2a310ccad73059ed9f74232f14e8f680bb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=8c841f2a310ccad73059ed9f74232f14e8f680bb", "patch": "@@ -28,6 +28,7 @@ use util::ppaux::{Repr, UserString};\n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n+pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n@@ -270,16 +271,6 @@ pub struct VtableObjectData<'tcx> {\n     pub object_ty: Ty<'tcx>,\n }\n \n-/// True if there exist types that satisfy both of the two given impls.\n-pub fn overlapping_impls(infcx: &InferCtxt,\n-                         impl1_def_id: ast::DefId,\n-                         impl2_def_id: ast::DefId)\n-                         -> bool\n-{\n-    coherence::impl_can_satisfy(infcx, impl1_def_id, impl2_def_id) &&\n-    coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)\n-}\n-\n /// Creates predicate obligations from the generic bounds.\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,"}, {"sha": "897cb083f849d41d25a88a8cb530424098a63aa6", "filename": "src/test/compile-fail/coherence-subtyping.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8c841f2a310ccad73059ed9f74232f14e8f680bb/src%2Ftest%2Fcompile-fail%2Fcoherence-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c841f2a310ccad73059ed9f74232f14e8f680bb/src%2Ftest%2Fcompile-fail%2Fcoherence-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-subtyping.rs?ref=8c841f2a310ccad73059ed9f74232f14e8f680bb", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that two distinct impls which match subtypes of one another\n+// yield coherence errors (or not) depending on the variance.\n+\n+trait Contravariant {\n+    fn foo(&self) { }\n+}\n+\n+impl Contravariant for for<'a,'b> fn(&'a u8, &'b u8) {\n+    //~^ ERROR E0119\n+}\n+\n+impl Contravariant for for<'a> fn(&'a u8, &'a u8) {\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+trait Covariant {\n+    fn foo(&self) { }\n+}\n+\n+impl Covariant for for<'a,'b> fn(&'a u8, &'b u8) {\n+    //~^ ERROR E0119\n+}\n+\n+impl Covariant for for<'a> fn(&'a u8, &'a u8) {\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+trait Invariant {\n+    fn foo(&self) -> Self { }\n+}\n+\n+impl Invariant for for<'a,'b> fn(&'a u8, &'b u8) {\n+}\n+\n+impl Invariant for for<'a> fn(&'a u8, &'a u8) {\n+}\n+\n+fn main() { }"}]}