{"sha": "6c5b990c5f5e17f044d7c4673802a11d50bc709f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNWI5OTBjNWY1ZTE3ZjA0NGQ3YzQ2NzM4MDJhMTFkNTBiYzcwOWY=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-08-30T12:58:15Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "All CommonMethods now real methods (not static)", "tree": {"sha": "ba1493b8727b8b71a1b02cf1c78421b056c8f366", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba1493b8727b8b71a1b02cf1c78421b056c8f366"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c5b990c5f5e17f044d7c4673802a11d50bc709f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c5b990c5f5e17f044d7c4673802a11d50bc709f", "html_url": "https://github.com/rust-lang/rust/commit/6c5b990c5f5e17f044d7c4673802a11d50bc709f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c5b990c5f5e17f044d7c4673802a11d50bc709f/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33eee83737b399ccea5b916fc6249259ca618208", "url": "https://api.github.com/repos/rust-lang/rust/commits/33eee83737b399ccea5b916fc6249259ca618208", "html_url": "https://github.com/rust-lang/rust/commit/33eee83737b399ccea5b916fc6249259ca618208"}], "stats": {"total": 63, "additions": 31, "deletions": 32}, "files": [{"sha": "e13c488d2b74bb044272d5d4b23f64ad794e89f6", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=6c5b990c5f5e17f044d7c4673802a11d50bc709f", "patch": "@@ -1151,7 +1151,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if !cx.used_statics.borrow().is_empty() {\n                 let name = const_cstr!(\"llvm.used\");\n                 let section = const_cstr!(\"llvm.metadata\");\n-                let array = CodegenCx::c_array(Type::i8(&cx).ptr_to(), &*cx.used_statics.borrow());\n+                let array = cx.c_array(Type::i8(&cx).ptr_to(), &*cx.used_statics.borrow());\n \n                 unsafe {\n                     let g = llvm::LLVMAddGlobal(cx.llmod,"}, {"sha": "bd356047467317ac1bd2e9e3af3d1dc7e96de474", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=6c5b990c5f5e17f044d7c4673802a11d50bc709f", "patch": "@@ -321,13 +321,13 @@ impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n         &self.c_struct_in_context(&self.llcx, elts, packed)\n     }\n \n-    fn c_array(ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n+    fn c_array(&self, ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n         unsafe {\n             return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n         }\n     }\n \n-    fn c_vector(elts: &[&'ll Value]) -> &'ll Value {\n+    fn c_vector(&self, elts: &[&'ll Value]) -> &'ll Value {\n         unsafe {\n             return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n         }\n@@ -337,7 +337,7 @@ impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n         &self.c_bytes_in_context(&self.llcx, bytes)\n     }\n \n-    fn const_get_elt(v: &'ll Value, idx: u64) -> &'ll Value {\n+    fn const_get_elt(&self, v: &'ll Value, idx: u64) -> &'ll Value {\n         unsafe {\n             assert_eq!(idx as c_uint as u64, idx);\n             let us = &[idx as c_uint];\n@@ -350,9 +350,9 @@ impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn const_get_real(v: &'ll Value) -> Option<(f64, bool)> {\n+    fn const_get_real(&self, v: &'ll Value) -> Option<(f64, bool)> {\n         unsafe {\n-            if Self::is_const_real(v) {\n+            if self.is_const_real(v) {\n                 let mut loses_info: llvm::Bool = ::std::mem::uninitialized();\n                 let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info);\n                 let loses_info = if loses_info == 1 { true } else { false };\n@@ -363,27 +363,27 @@ impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn const_to_uint(v: &'ll Value) -> u64 {\n+    fn const_to_uint(&self, v: &'ll Value) -> u64 {\n         unsafe {\n             llvm::LLVMConstIntGetZExtValue(v)\n         }\n     }\n \n-    fn is_const_integral(v: &'ll Value) -> bool {\n+    fn is_const_integral(&self, v: &'ll Value) -> bool {\n         unsafe {\n             llvm::LLVMIsAConstantInt(v).is_some()\n         }\n     }\n \n-    fn is_const_real(v: &'ll Value) -> bool {\n+    fn is_const_real(&self, v: &'ll Value) -> bool {\n         unsafe {\n             llvm::LLVMIsAConstantFP(v).is_some()\n         }\n     }\n \n-    fn const_to_opt_u128(v: &'ll Value, sign_ext: bool) -> Option<u128> {\n+    fn const_to_opt_u128(&self, v: &'ll Value, sign_ext: bool) -> Option<u128> {\n         unsafe {\n-            if Self::is_const_integral(v) {\n+            if self.is_const_integral(v) {\n                 let (mut lo, mut hi) = (0u64, 0u64);\n                 let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n                                                            &mut hi, &mut lo);"}, {"sha": "09bd3ae264b401a6fa95eacdfa78ecb1a4396bc9", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=6c5b990c5f5e17f044d7c4673802a11d50bc709f", "patch": "@@ -34,8 +34,8 @@ pub fn size_and_align_of_dst(\n         let (size, align) = bx.cx().size_and_align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n                t, info, size, align);\n-        let size = CodegenCx::c_usize(bx.cx(), size.bytes());\n-        let align = CodegenCx::c_usize(bx.cx(), align.abi());\n+        let size = bx.cx().c_usize(size.bytes());\n+        let align = bx.cx().c_usize(align.abi());\n         return (size, align);\n     }\n     match t.sty {\n@@ -49,8 +49,8 @@ pub fn size_and_align_of_dst(\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             let (size, align) = bx.cx().size_and_align_of(unit);\n-            (bx.mul(info.unwrap(), CodegenCx::c_usize(bx.cx(), size.bytes())),\n-             CodegenCx::c_usize(bx.cx(), align.abi()))\n+            (bx.mul(info.unwrap(), bx.cx().c_usize(size.bytes())),\n+             bx.cx().c_usize(align.abi()))\n         }\n         _ => {\n             let cx = bx.cx();\n@@ -93,8 +93,8 @@ pub fn size_and_align_of_dst(\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n-            let align = match (CodegenCx::const_to_opt_u128(sized_align, false),\n-                               CodegenCx::const_to_opt_u128(unsized_align, false)) {\n+            let align = match (bx.cx().const_to_opt_u128(sized_align, false),\n+                               bx.cx().const_to_opt_u128(unsized_align, false)) {\n                 (Some(sized_align), Some(unsized_align)) => {\n                     // If both alignments are constant, (the sized_align should always be), then\n                     // pick the correct alignment statically."}, {"sha": "79fed084588d71b90c488b298090e8ca97c0d1f2", "filename": "src/librustc_codegen_llvm/interfaces/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs?ref=6c5b990c5f5e17f044d7c4673802a11d50bc709f", "patch": "@@ -40,16 +40,16 @@ pub trait CommonMethods : Backend + CommonWriteMethods {\n         elts: &[Self::Value],\n         packed: bool\n     ) -> Self::Value;\n-    fn c_array(ty: Self::Type, elts: &[Self::Value]) -> Self::Value;\n-    fn c_vector(elts: &[Self::Value]) -> Self::Value;\n+    fn c_array(&self, ty: Self::Type, elts: &[Self::Value]) -> Self::Value;\n+    fn c_vector(&self, elts: &[Self::Value]) -> Self::Value;\n     fn c_bytes(&self, bytes: &[u8]) -> Self::Value;\n \n-    fn const_get_elt(v: Self::Value, idx: u64) -> Self::Value;\n-    fn const_get_real(v: Self::Value) -> Option<(f64, bool)>;\n-    fn const_to_uint(v: Self::Value) -> u64;\n-    fn is_const_integral(v: Self::Value) -> bool;\n-    fn is_const_real(v: Self::Value) -> bool;\n-    fn const_to_opt_u128(v: Self::Value, sign_ext: bool) -> Option<u128>;\n+    fn const_get_elt(&self, v: Self::Value, idx: u64) -> Self::Value;\n+    fn const_get_real(&self, v: Self::Value) -> Option<(f64, bool)>;\n+    fn const_to_uint(&self, v: Self::Value) -> u64;\n+    fn is_const_integral(&self, v: Self::Value) -> bool;\n+    fn is_const_real(&self, v: Self::Value) -> bool;\n+    fn const_to_opt_u128(&self, v: Self::Value, sign_ext: bool) -> Option<u128>;\n }\n \n pub trait CommonWriteMethods : Backend {"}, {"sha": "90837a95c60c0f416c157e7e3c59e9e4600073ae", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=6c5b990c5f5e17f044d7c4673802a11d50bc709f", "patch": "@@ -1114,8 +1114,8 @@ fn generic_simd_intrinsic(\n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n-                let val = CodegenCx::const_get_elt(vector, i as u64);\n-                match CodegenCx::const_to_opt_u128(val, true) {\n+                let val = bx.cx().const_get_elt(vector, i as u64);\n+                match bx.cx().const_to_opt_u128(val, true) {\n                     None => {\n                         emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n                         None\n@@ -1136,7 +1136,7 @@ fn generic_simd_intrinsic(\n \n         return Ok(bx.shuffle_vector(args[0].immediate(),\n                                     args[1].immediate(),\n-                                    CodegenCx::c_vector(&indices)))\n+                                    bx.cx().c_vector(&indices)))\n     }\n \n     if name == \"simd_insert\" {\n@@ -1549,7 +1549,7 @@ fn generic_simd_intrinsic(\n                             //   code is generated\n                             // * if the accumulator of the fmul isn't 1, incorrect\n                             //   code is generated\n-                            match CodegenCx::const_get_real(acc) {\n+                            match bx.cx().const_get_real(acc) {\n                                 None => return_error!(\"accumulator of {} is not a constant\", $name),\n                                 Some((v, loses_info)) => {\n                                     if $name.contains(\"mul\") && v != 1.0_f64 {"}, {"sha": "b9599d505d330949703a83158d1aabd954975fdb", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=6c5b990c5f5e17f044d7c4673802a11d50bc709f", "patch": "@@ -324,7 +324,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n                 let cond = self.codegen_operand(&bx, cond).immediate();\n-                let mut const_cond = CodegenCx::const_to_opt_u128(cond, false).map(|c| c == 1);\n+                let mut const_cond = bx.cx().const_to_opt_u128(cond, false).map(|c| c == 1);\n \n                 // This case can currently arise only from functions marked\n                 // with #[rustc_inherit_overflow_checks] and inlined from"}, {"sha": "2496e10b74b1bed13bde4531cfd547610579e91c", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c5b990c5f5e17f044d7c4673802a11d50bc709f/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=6c5b990c5f5e17f044d7c4673802a11d50bc709f", "patch": "@@ -20,7 +20,6 @@ use base;\n use builder::Builder;\n use callee;\n use common::{self, IntPredicate, RealPredicate};\n-use context::CodegenCx;\n use consts;\n use monomorphize;\n use type_::Type;\n@@ -110,7 +109,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let size = bx.cx().c_usize(dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n-                    if CodegenCx::is_const_integral(v) && CodegenCx::const_to_uint(v) == 0 {\n+                    if bx.cx().is_const_integral(v) && bx.cx().const_to_uint(v) == 0 {\n                         let fill = bx.cx().c_u8(0);\n                         base::call_memset(&bx, start, fill, size, align, false);\n                         return bx;"}]}