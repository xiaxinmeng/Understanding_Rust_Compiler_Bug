{"sha": "ba3884dae6d34370c0841d61acefe8d4a3f8d05c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMzg4NGRhZTZkMzQzNzBjMDg0MWQ2MWFjZWZlOGQ0YTNmOGQwNWM=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-03-22T21:16:02Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-04-05T15:08:39Z"}, "message": "Use checked addition/subtraction on lock counts", "tree": {"sha": "005c11e1acfd7ac08a9b0d9665d123faa551a415", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/005c11e1acfd7ac08a9b0d9665d123faa551a415"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba3884dae6d34370c0841d61acefe8d4a3f8d05c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba3884dae6d34370c0841d61acefe8d4a3f8d05c", "html_url": "https://github.com/rust-lang/rust/commit/ba3884dae6d34370c0841d61acefe8d4a3f8d05c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba3884dae6d34370c0841d61acefe8d4a3f8d05c/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "141319a412ddca4a2b16f45eed459c4a735e8f8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/141319a412ddca4a2b16f45eed459c4a735e8f8f", "html_url": "https://github.com/rust-lang/rust/commit/141319a412ddca4a2b16f45eed459c4a735e8f8f"}], "stats": {"total": 54, "additions": 39, "deletions": 15}, "files": [{"sha": "987513d323ecb046a6844eecb8eb251d5218630e", "filename": "src/shims/sync.rs", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ba3884dae6d34370c0841d61acefe8d4a3f8d05c/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba3884dae6d34370c0841d61acefe8d4a3f8d05c/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=ba3884dae6d34370c0841d61acefe8d4a3f8d05c", "patch": "@@ -110,8 +110,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.eval_libc_i32(\"EDEADLK\")\n             }\n         } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n-            mutex_set_locked_count(this, mutex_op, Scalar::from_u32(locked_count + 1))?;\n-            Ok(0)\n+            match locked_count.checked_add(1) {\n+                Some(new_count) => {\n+                    mutex_set_locked_count(this, mutex_op, Scalar::from_u32(new_count))?;\n+                    Ok(0)\n+                }\n+                None => this.eval_libc_i32(\"EAGAIN\"),\n+            }\n         } else {\n             this.eval_libc_i32(\"EINVAL\")\n         }\n@@ -138,8 +143,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.eval_libc_i32(\"EBUSY\")\n             }\n         } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n-            mutex_set_locked_count(this, mutex_op, Scalar::from_u32(locked_count + 1))?;\n-            Ok(0)\n+            match locked_count.checked_add(1) {\n+                Some(new_count) => {\n+                    mutex_set_locked_count(this, mutex_op, Scalar::from_u32(new_count))?;\n+                    Ok(0)\n+                }\n+                None => this.eval_libc_i32(\"EAGAIN\"),\n+            }\n         } else {\n             this.eval_libc_i32(\"EINVAL\")\n         }\n@@ -173,11 +183,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.eval_libc_i32(\"EPERM\")\n             }\n         } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n-            if locked_count > 0 {\n-                mutex_set_locked_count(this, mutex_op, Scalar::from_u32(locked_count - 1))?;\n-                Ok(0)\n-            } else {\n-                this.eval_libc_i32(\"EPERM\")\n+            match locked_count.checked_sub(1) {\n+                Some(new_count) => {\n+                    mutex_set_locked_count(this, mutex_op, Scalar::from_u32(new_count))?;\n+                    Ok(0)\n+                }\n+                None => {\n+                    // locked_count was already zero\n+                    this.eval_libc_i32(\"EPERM\")\n+                }\n             }\n         } else {\n             this.eval_libc_i32(\"EINVAL\")\n@@ -217,8 +231,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 \"Deadlock due to read-locking a pthreads read-write lock while it is already write-locked\"\n             );\n         } else {\n-            rwlock_set_readers(this, rwlock_op, Scalar::from_u32(readers + 1))?;\n-            Ok(0)\n+            match readers.checked_add(1) {\n+                Some(new_readers) => {\n+                    rwlock_set_readers(this, rwlock_op, Scalar::from_u32(new_readers))?;\n+                    Ok(0)\n+                }\n+                None => this.eval_libc_i32(\"EAGAIN\"),\n+            }\n         }\n     }\n \n@@ -235,8 +254,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if writers != 0 {\n             this.eval_libc_i32(\"EBUSY\")\n         } else {\n-            rwlock_set_readers(this, rwlock_op, Scalar::from_u32(readers + 1))?;\n-            Ok(0)\n+            match readers.checked_add(1) {\n+                Some(new_readers) => {\n+                    rwlock_set_readers(this, rwlock_op, Scalar::from_u32(new_readers))?;\n+                    Ok(0)\n+                }\n+                None => this.eval_libc_i32(\"EAGAIN\"),\n+            }\n         }\n     }\n \n@@ -292,8 +316,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let readers = rwlock_get_readers(this, rwlock_op)?.to_u32()?;\n         let writers = rwlock_get_writers(this, rwlock_op)?.to_u32()?;\n-        if readers != 0 {\n-            rwlock_set_readers(this, rwlock_op, Scalar::from_u32(readers - 1))?;\n+        if let Some(new_readers) = readers.checked_sub(1) {\n+            rwlock_set_readers(this, rwlock_op, Scalar::from_u32(new_readers))?;\n             Ok(0)\n         } else if writers != 0 {\n             rwlock_set_writers(this, rwlock_op, Scalar::from_u32(0))?;"}]}