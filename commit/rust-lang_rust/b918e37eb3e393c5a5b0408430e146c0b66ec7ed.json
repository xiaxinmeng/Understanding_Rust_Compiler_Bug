{"sha": "b918e37eb3e393c5a5b0408430e146c0b66ec7ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MThlMzdlYjNlMzkzYzVhNWIwNDA4NDMwZTE0NmMwYjY2ZWM3ZWQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-23T19:08:12Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T15:51:58Z"}, "message": "metedata: Remove the unnecessary indirection to astencode.", "tree": {"sha": "2dee72b05ea4b728ee63a2c139743bc7b139bc91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dee72b05ea4b728ee63a2c139743bc7b139bc91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b918e37eb3e393c5a5b0408430e146c0b66ec7ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b918e37eb3e393c5a5b0408430e146c0b66ec7ed", "html_url": "https://github.com/rust-lang/rust/commit/b918e37eb3e393c5a5b0408430e146c0b66ec7ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b918e37eb3e393c5a5b0408430e146c0b66ec7ed/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9723a3bc379c208bd0d872cbf9d8b23888d404ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/9723a3bc379c208bd0d872cbf9d8b23888d404ee", "html_url": "https://github.com/rust-lang/rust/commit/9723a3bc379c208bd0d872cbf9d8b23888d404ee"}], "stats": {"total": 98, "additions": 18, "deletions": 80}, "files": [{"sha": "881e64f70471e1bec8fb40a3ecfb8c7082c130d5", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b918e37eb3e393c5a5b0408430e146c0b66ec7ed/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b918e37eb3e393c5a5b0408430e146c0b66ec7ed/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=b918e37eb3e393c5a5b0408430e146c0b66ec7ed", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use astencode;\n use cstore;\n use decoder;\n use encoder;\n@@ -439,8 +438,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                           -> FoundAst<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        let decode_inlined_item = Box::new(astencode::decode_inlined_item);\n-        decoder::maybe_get_item_ast(&cdata, tcx, def.index, decode_inlined_item)\n+        decoder::maybe_get_item_ast(&cdata, tcx, def.index)\n     }\n \n     fn maybe_get_item_mir(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n@@ -509,21 +507,18 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                        mir_map: &MirMap<'tcx>,\n                        krate: &hir::Crate) -> Vec<u8>\n     {\n-        let encode_inlined_item: encoder::EncodeInlinedItem =\n-            Box::new(|ecx, rbml_w, ii| astencode::encode_inlined_item(ecx, rbml_w, ii));\n-\n-        let encode_params = encoder::EncodeParams {\n+        let ecx = encoder::EncodeContext {\n             diag: tcx.sess.diagnostic(),\n             tcx: tcx,\n             reexports: reexports,\n             item_symbols: item_symbols,\n             link_meta: link_meta,\n             cstore: self,\n-            encode_inlined_item: encode_inlined_item,\n             reachable: reachable,\n             mir_map: mir_map,\n+            type_abbrevs: RefCell::new(FnvHashMap()),\n         };\n-        encoder::encode_metadata(encode_params, krate)\n+        encoder::encode_metadata(ecx, krate)\n \n     }\n "}, {"sha": "579996807d4cd4fe92014d4e7105edca1f698428", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b918e37eb3e393c5a5b0408430e146c0b66ec7ed/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b918e37eb3e393c5a5b0408430e146c0b66ec7ed/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b918e37eb3e393c5a5b0408430e146c0b66ec7ed", "patch": "@@ -14,6 +14,7 @@\n \n use self::Family::*;\n \n+use astencode::decode_inlined_item;\n use cstore::{self, crate_metadata};\n use common::*;\n use encoder::def_to_u64;\n@@ -797,20 +798,9 @@ pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Nam\n     item_name(intr, cdata.lookup_item(id))\n }\n \n-pub type DecodeInlinedItem<'a> =\n-    Box<for<'tcx> FnMut(Cmd,\n-                        &TyCtxt<'tcx>,\n-                        Vec<hir_map::PathElem>, // parent_path\n-                        hir_map::DefPath,       // parent_def_path\n-                        rbml::Doc,\n-                        DefId)\n-                        -> Result<&'tcx InlinedItem, (Vec<hir_map::PathElem>,\n-                                                      hir_map::DefPath)> + 'a>;\n-\n pub fn maybe_get_item_ast<'tcx>(cdata: Cmd,\n                                 tcx: &TyCtxt<'tcx>,\n                                 id: DefIndex,\n-                                mut decode_inlined_item: DecodeInlinedItem)\n                                 -> FoundAst<'tcx> {\n     debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);"}, {"sha": "e677ea962f9cf2f9bba5858c6fcdb6778e677a54", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 60, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b918e37eb3e393c5a5b0408430e146c0b66ec7ed/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b918e37eb3e393c5a5b0408430e146c0b66ec7ed/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b918e37eb3e393c5a5b0408430e146c0b66ec7ed", "patch": "@@ -13,6 +13,7 @@\n #![allow(unused_must_use)] // everything is just a MemWriter, can't fail\n #![allow(non_camel_case_types)]\n \n+use astencode::encode_inlined_item;\n use common::*;\n use cstore;\n use decoder;\n@@ -55,29 +56,13 @@ use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit::Visitor;\n use rustc_front::intravisit;\n \n-pub type EncodeInlinedItem<'a> =\n-    Box<FnMut(&EncodeContext, &mut Encoder, InlinedItemRef) + 'a>;\n-\n-pub struct EncodeParams<'a, 'tcx: 'a> {\n-    pub diag: &'a Handler,\n-    pub tcx: &'a TyCtxt<'tcx>,\n-    pub reexports: &'a def::ExportMap,\n-    pub item_symbols: &'a RefCell<NodeMap<String>>,\n-    pub link_meta: &'a LinkMeta,\n-    pub cstore: &'a cstore::CStore,\n-    pub encode_inlined_item: EncodeInlinedItem<'a>,\n-    pub reachable: &'a NodeSet,\n-    pub mir_map: &'a MirMap<'tcx>,\n-}\n-\n pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n     pub tcx: &'a TyCtxt<'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n-    pub encode_inlined_item: RefCell<EncodeInlinedItem<'a>>,\n     pub type_abbrevs: tyencode::abbrev_map<'tcx>,\n     pub reachable: &'a NodeSet,\n     pub mir_map: &'a MirMap<'tcx>,\n@@ -688,6 +673,7 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                             rbml_w,\n                             InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n                                                      ii));\n+        encode_mir(ecx, rbml_w, ii.id);\n     }\n \n     rbml_w.end_tag();\n@@ -733,6 +719,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     rbml_w,\n                                     InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n                                                              impl_item));\n+                encode_mir(ecx, rbml_w, impl_item.id);\n             }\n             encode_constness(rbml_w, sig.constness);\n             encode_defaultness(rbml_w, impl_item.defaultness);\n@@ -820,23 +807,6 @@ fn encode_repr_attrs(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_inlined_item(ecx: &EncodeContext,\n-                       rbml_w: &mut Encoder,\n-                       ii: InlinedItemRef) {\n-    let mut eii = ecx.encode_inlined_item.borrow_mut();\n-    let eii: &mut EncodeInlinedItem = &mut *eii;\n-    eii(ecx, rbml_w, ii);\n-\n-    let node_id = match ii {\n-        InlinedItemRef::Item(item) => item.id,\n-        InlinedItemRef::TraitItem(_, trait_item) => trait_item.id,\n-        InlinedItemRef::ImplItem(_, impl_item) => impl_item.id,\n-        InlinedItemRef::Foreign(foreign_item) => foreign_item.id\n-    };\n-\n-    encode_mir(ecx, rbml_w, node_id);\n-}\n-\n fn encode_mir(ecx: &EncodeContext, rbml_w: &mut Encoder, node_id: NodeId) {\n     if let Some(mir) = ecx.mir_map.map.get(&node_id) {\n         rbml_w.start_tag(tag_mir as usize);\n@@ -958,6 +928,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+        encode_mir(ecx, rbml_w, item.id);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n@@ -976,6 +947,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n         if needs_inline || constness == hir::Constness::Const {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+            encode_mir(ecx, rbml_w, item.id);\n         }\n         if tps_len == 0 {\n             encode_symbol(ecx, rbml_w, item.id);\n@@ -1044,6 +1016,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n         }\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+        encode_mir(ecx, rbml_w, item.id);\n         encode_path(rbml_w, path);\n \n         // Encode inherent implementations for this enumeration.\n@@ -1092,6 +1065,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_struct_fields(rbml_w, variant);\n \n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+        encode_mir(ecx, rbml_w, item.id);\n \n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n@@ -1374,6 +1348,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n                     encode_inlined_item(ecx, rbml_w,\n                                         InlinedItemRef::TraitItem(def_id, trait_item));\n+                    encode_mir(ecx, rbml_w, trait_item.id);\n                 }\n                 hir::MethodTraitItem(ref sig, ref body) => {\n                     // If this is a static method, we've already\n@@ -1389,6 +1364,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                         encode_item_sort(rbml_w, 'p');\n                         encode_inlined_item(ecx, rbml_w,\n                                             InlinedItemRef::TraitItem(def_id, trait_item));\n+                        encode_mir(ecx, rbml_w, trait_item.id);\n                     } else {\n                         encode_item_sort(rbml_w, 'r');\n                     }\n@@ -1426,13 +1402,15 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_name(rbml_w, nitem.name);\n         if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n+            encode_mir(ecx, rbml_w, nitem.id);\n+        } else {\n+            encode_symbol(ecx, rbml_w, nitem.id);\n         }\n         encode_attributes(rbml_w, &nitem.attrs);\n         let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n-        encode_symbol(ecx, rbml_w, nitem.id);\n         encode_method_argument_names(rbml_w, &fndecl);\n       }\n       hir::ForeignItemStatic(_, mutbl) => {\n@@ -1928,32 +1906,7 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n #[allow(non_upper_case_globals)]\n pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2 ];\n \n-pub fn encode_metadata(parms: EncodeParams, krate: &hir::Crate) -> Vec<u8> {\n-    let EncodeParams {\n-        item_symbols,\n-        diag,\n-        tcx,\n-        reexports,\n-        cstore,\n-        encode_inlined_item,\n-        link_meta,\n-        reachable,\n-        mir_map,\n-        ..\n-    } = parms;\n-    let ecx = EncodeContext {\n-        diag: diag,\n-        tcx: tcx,\n-        reexports: reexports,\n-        item_symbols: item_symbols,\n-        link_meta: link_meta,\n-        cstore: cstore,\n-        encode_inlined_item: RefCell::new(encode_inlined_item),\n-        type_abbrevs: RefCell::new(FnvHashMap()),\n-        reachable: reachable,\n-        mir_map: mir_map,\n-    };\n-\n+pub fn encode_metadata(ecx: EncodeContext, krate: &hir::Crate) -> Vec<u8> {\n     let mut wr = Cursor::new(Vec::new());\n \n     {"}]}