{"sha": "4bce639c3b98ceb9e8a8896f9d4a7f7d6db79ba1", "node_id": "C_kwDOAAsO6NoAKDRiY2U2MzljM2I5OGNlYjllOGE4ODk2ZjlkNGE3ZjdkNmRiNzliYTE", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-04-08T19:53:08Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-04-11T19:56:04Z"}, "message": "Add more clarifications in response to Ralf's comments", "tree": {"sha": "9ba1542ef54c644792a083e0148bb38e1d13c71e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ba1542ef54c644792a083e0148bb38e1d13c71e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bce639c3b98ceb9e8a8896f9d4a7f7d6db79ba1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bce639c3b98ceb9e8a8896f9d4a7f7d6db79ba1", "html_url": "https://github.com/rust-lang/rust/commit/4bce639c3b98ceb9e8a8896f9d4a7f7d6db79ba1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bce639c3b98ceb9e8a8896f9d4a7f7d6db79ba1/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "411ae6f5ad7d3b4488f280b7bea8498eb1b0d041", "url": "https://api.github.com/repos/rust-lang/rust/commits/411ae6f5ad7d3b4488f280b7bea8498eb1b0d041", "html_url": "https://github.com/rust-lang/rust/commit/411ae6f5ad7d3b4488f280b7bea8498eb1b0d041"}], "stats": {"total": 186, "additions": 84, "deletions": 102}, "files": [{"sha": "c690d2b9d334d4175d1a7bf76bfbb6b8a129731a", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 84, "deletions": 102, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/4bce639c3b98ceb9e8a8896f9d4a7f7d6db79ba1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bce639c3b98ceb9e8a8896f9d4a7f7d6db79ba1/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=4bce639c3b98ceb9e8a8896f9d4a7f7d6db79ba1", "patch": "@@ -1598,9 +1598,9 @@ pub enum StatementKind<'tcx> {\n     /// Assign statements roughly correspond to an assignment in Rust proper (`x = ...`) except\n     /// without the possibility of dropping the previous value (that must be done separately, if at\n     /// all). The *exact* way this works is undecided. It probably does something like evaluating\n-    /// the LHS and RHS, and then doing the inverse of a place to value conversion to write the\n-    /// resulting value into memory. Various parts of this may do type specific things that are more\n-    /// complicated than simply copying over the bytes depending on the types.\n+    /// the LHS to a place and the RHS to a value, and then storing the value to the place. Various\n+    /// parts of this may do type specific things that are more complicated than simply copying\n+    /// bytes.\n     ///\n     /// **Needs clarification**: The implication of the above idea would be that assignment implies\n     /// that the resulting value is initialized. I believe we could commit to this separately from\n@@ -1615,8 +1615,9 @@ pub enum StatementKind<'tcx> {\n     /// interesting for optimizations? Do we want to allow such optimizations?\n     ///\n     /// **Needs clarification**: We currently require that the LHS place not overlap with any place\n-    /// read as part of computation of the RHS. This requirement is under discussion in [#68364]. As\n-    /// a part of this discussion, it is also unclear in what order the components are evaluated.\n+    /// read as part of computation of the RHS for some rvalues (generally those not producing\n+    /// primitives). This requirement is under discussion in [#68364]. As a part of this discussion,\n+    /// it is also unclear in what order the components are evaluated.\n     ///\n     /// [#68364]: https://github.com/rust-lang/rust/issues/68364\n     ///\n@@ -1714,9 +1715,8 @@ pub enum StatementKind<'tcx> {\n     /// **Needs clarification**: In what order are operands computed and dereferenced? It should\n     /// probably match the order for assignment, but that is also undecided.\n     ///\n-    /// **Needs clarification**: Is this typed or not, ie is there a place to value and back\n-    /// conversion involved? I vaguely remember Ralf saying somewhere that he thought it should not\n-    /// be.\n+    /// **Needs clarification**: Is this typed or not, ie is there a typed load and store involved?\n+    /// I vaguely remember Ralf saying somewhere that he thought it should not be.\n     CopyNonOverlapping(Box<CopyNonOverlapping<'tcx>>),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n@@ -1868,41 +1868,55 @@ pub struct CopyNonOverlapping<'tcx> {\n \n /// Places roughly correspond to a \"location in memory.\" Places in MIR are the same mathematical\n /// object as places in Rust. This of course means that what exactly they are is undecided and part\n-/// of the Rust memory model. However, they will likely contain at least the following three pieces\n-/// of information in some form:\n+/// of the Rust memory model. However, they will likely contain at least the following pieces of\n+/// information in some form:\n ///\n-///  1. The part of memory that is referred to (see discussion below for details).\n-///  2. The type of the place and an optional variant index. See [`PlaceTy`][tcx::PlaceTy]\n-///  3. The provenance with which the place is being accessed.\n+///  1. The address in memory that the place refers to.\n+///  2. The provenance with which the place is being accessed.\n+///  3. The type of the place and an optional variant index. See [`PlaceTy`][tcx::PlaceTy].\n+///  4. Optionally, some metadata. This exists if and only if the type of the place is not `Sized`.\n ///\n-/// We'll give a description below of how the first two of these three properties are computed for a\n-/// place. We cannot give a description of the provenance, because that is part of the undecided\n-/// aliasing model - we only include it here at all to acknowledge its existence.\n+/// We'll give a description below of how all pieces of the place except for the provenance are\n+/// calculated. We cannot give a description of the provenance, because that is part of the\n+/// undecided aliasing model - we only include it here at all to acknowledge its existence.\n ///\n-/// For a place that has no projections, ie `Place { local, projection: [] }`, the part of memory is\n-/// the local's full allocation and the type is the type of the local. For any other place, we\n-/// define the values as a function of the parent place, that is the place with its last\n-/// [`ProjectionElem`] stripped. The way this is computed of course depends on the kind of that last\n-/// projection element:\n+/// Each local naturally corresponds to the place `Place { local, projection: [] }`. This place has\n+/// the address of the local's allocation and the type of the local.\n+///\n+/// **Needs clarification:** Unsized locals seem to present a bit of an issue. Their allocation\n+/// can't actually be created on `StorageLive`, because it's unclear how big to make the allocation.\n+/// Furthermore, MIR produces assignments to unsized locals, although that is not permitted under\n+/// `#![feature(unsized_locals)]` in Rust. Besides just putting \"unsized locals are special and\n+/// different\" in a bunch of places, I (JakobDegen) don't know how to incorporate this behavior into\n+/// the current MIR semantics in a clean way - possibly this needs some design work first.\n+///\n+/// For places that are not locals, ie they have a non-empty list of projections, we define the\n+/// values as a function of the parent place, that is the place with its last [`ProjectionElem`]\n+/// stripped. The way this is computed of course depends on the kind of that last projection\n+/// element:\n ///\n ///  - [`Downcast`](ProjectionElem::Downcast): This projection sets the place's variant index to the\n ///    given one, and makes no other changes. A `Downcast` projection on a place with its variant\n ///    index already set is not well-formed.\n ///  - [`Field`](ProjectionElem::Field): `Field` projections take their parent place and create a\n-///    place referring to one of the fields of the type. The referred to place in memory is where\n-///    the layout places the field. The type becomes the type of the field.\n+///    place referring to one of the fields of the type. The resulting address is the parent\n+///    address, plus the offset of the field. The type becomes the type of the field. If the parent\n+///    was unsized and so had metadata associated with it, then the metadata is retained if the\n+///    field is unsized and thrown out if it is sized.\n ///\n ///    These projections are only legal for tuples, ADTs, closures, and generators. If the ADT or\n ///    generator has more than one variant, the parent place's variant index must be set, indicating\n ///    which variant is being used. If it has just one variant, the variant index may or may not be\n ///    included - the single possible variant is inferred if it is not included.\n ///  - [`ConstantIndex`](ProjectionElem::ConstantIndex): Computes an offset in units of `T` into the\n-///    place as described in the documentation for the `ProjectionElem`. The resulting part of\n-///    memory is the location of that element of the array/slice, and the type is `T`. This is only\n-///    legal if the parent place has type `[T;  N]` or `[T]` (*not* `&[T]`).\n-///  - [`Subslice`](ProjectionElem::Subslice): Much like `ConstantIndex`. It is also only legal on\n-///    `[T; N]` and `[T]`. However, this yields a `Place` of type `[T]`, and may refer to more than\n-///    one element in the parent place.\n+///    place as described in the documentation for the `ProjectionElem`. The resulting address is\n+///    the parent's address plus that offset, and the type is `T`. This is only legal if the parent\n+///    place has type `[T;  N]` or `[T]` (*not* `&[T]`). Since such a `T` is always sized, any\n+///    resulting metadata is thrown out.\n+///  - [`Subslice`](ProjectionElem::Subslice): This projection calculates an offset and a new\n+///    address in a similar manner as `ConstantIndex`. It is also only legal on `[T; N]` and `[T]`.\n+///    However, this yields a `Place` of type `[T]`, and additionally sets the metadata to be the\n+///    length of the subslice.\n ///  - [`Index`](ProjectionElem::Index): Like `ConstantIndex`, only legal on `[T; N]` or `[T]`.\n ///    However, `Index` additionally takes a local from which the value of the index is computed at\n ///    runtime. Computing the value of the index involves interpreting the `Local` as a\n@@ -1911,53 +1925,23 @@ pub struct CopyNonOverlapping<'tcx> {\n ///    have type `usize`.\n ///  - [`Deref`](ProjectionElem::Deref): Derefs are the last type of projection, and the most\n ///    complicated. They are only legal on parent places that are references, pointers, or `Box`. A\n-///    `Deref` projection begins by creating a value from the parent place, as if by\n+///    `Deref` projection begins by loading a value from the parent place, as if by\n ///    [`Operand::Copy`]. It then dereferences the resulting pointer, creating a place of the\n-///    pointed to type.\n-///\n-/// **Needs clarification**: What about metadata resulting from dereferencing wide pointers (and\n-/// possibly from accessing unsized locals - not sure how those work)? That probably deserves to go\n-/// on the list above and be discussed too. It is also probably necessary for making the indexing\n-/// stuff less hand-wavey.\n-///\n-/// **Needs clarification**: When it says \"part of memory\" what does that mean precisely, and how\n-/// does it interact with the metadata?\n+///    pointee's type. The resulting address is the address that was stored in the pointer. If the\n+///    pointee type is unsized, the pointer additionally stored the value of the metadata.\n ///\n-/// One possible model that I believe makes sense is that \"part of memory\" is actually just the\n-/// address of the beginning of the referred to range of bytes. For sized types, the size of the\n-/// range is then stored in the type, and for unsized types it's stored (possibly indirectly,\n-/// through a vtable) in the metadata.\n+/// Computing a place may cause UB. One possibility is that the pointer used for a `Deref` may not\n+/// be suitably aligned. Another possibility is that the place is not in bouns, meaning it does not\n+/// point to an actual allocation.\n ///\n-/// Alternatively, the \"part of memory\" could be a whole range of bytes. Initially seemed more\n-/// natural to me, but seems like it falls apart after a little bit.\n-///\n-/// More likely though, we should call this detail a part of the Rust memory model and let that deal\n-/// with the precise definition of this part of a place. If we feel strongly, I don't think we *have\n-/// to* though. MIR places are more flexible than Rust places, and we might be able to make a\n-/// decision on the flexible parts without semi-stabilizing the source language. (end NC)\n-///\n-/// Computing a place may be UB - this is certainly the case with dereferencing, which requires\n-/// sufficient provenance, but it may additionally be the case for some of the other field\n-/// projections.\n-///\n-/// It is undecided when this UB kicks in. As best I can tell that is the question being discussed\n-/// in [UCG#319]. Summarizing from that thread, I believe the options are:\n+/// However, if this is actually UB and when the UB kicks in is undecided. This is being discussed\n+/// in [UCG#319]. The options include that every place must obey those rules, that only some places\n+/// must obey them, or that places impose no rules of their own.\n ///\n /// [UCG#319]: https://github.com/rust-lang/unsafe-code-guidelines/issues/319\n ///\n-///  1. Each intermediate place must have provenance for the whole part of memory it refers to. This\n-///     is the status quo.\n-///  2. Only for intermediate place where the last projection was *not* a deref. This corresponds to\n-///     \"Check inbounds on place projection\".\n-///  3. Only on place to value conversions, assignments, and referencing operation. This corresponds\n-///     to \"remove the restrictions from `*` entirely.\"\n-///  4. On each intermediate place if the place is used for a place to value conversion as part of\n-///     an assignment assignment or it is used for a referencing operation. For a raw pointer\n-///     computation, never. This corresponds to \"magic?\".\n-///\n-/// Hopefully I am not misrepresenting anyone's opinions - please let me know if I am. Currently,\n-/// Rust chooses option 1. This is checked by MIRI and taken advantage of by codegen (via `gep\n-/// inbounds`). That is possibly subject to change.\n+/// Rust currently requires that every place obey those two rules. This is checked by MIRI and taken\n+/// advantage of by codegen (via `gep inbounds`). That is possibly subject to change.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, HashStable)]\n pub struct Place<'tcx> {\n     pub local: Local,\n@@ -2331,32 +2315,30 @@ pub struct SourceScopeLocalData {\n ///\n /// [value-def]: https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\n ///\n-/// The most common way to create values is via a place to value conversion. A place to value\n-/// conversion is an operation which reads the memory of the place and converts it to a value. This\n-/// is a fundamentally *typed* operation. The nature of the value produced depends on the type of\n-/// the conversion. Furthermore, there may be other effects: if the type has a validity constraint\n-/// the place to value conversion might be UB if the validity constraint is not met.\n+/// The most common way to create values is via loading a place. Loading a place is an operation\n+/// which reads the memory of the place and converts it to a value. This is a fundamentally *typed*\n+/// operation. The nature of the value produced depends on the type of the conversion. Furthermore,\n+/// there may be other effects: if the type has a validity constraint loading the place might be UB\n+/// if the validity constraint is not met.\n ///\n-/// **Needs clarification:** Ralf proposes that place to value conversions not have side-effects.\n+/// **Needs clarification:** Ralf proposes that loading a place not have side-effects.\n /// This is what is implemented in miri today. Are these the semantics we want for MIR? Is this\n /// something we can even decide without knowing more about Rust's memory model?\n ///\n-/// A place to value conversion on a place that has its variant index set is not well-formed.\n-/// However, note that this rule only applies to places appearing in MIR bodies. Many functions,\n-/// such as [`Place::ty`], still accept such a place. If you write a function for which it might be\n-/// ambiguous whether such a thing is accepted, make sure to document your choice clearly.\n+/// Loading a place that has its variant index set is not well-formed. However, note that this rule\n+/// only applies to places appearing in MIR bodies. Many functions, such as [`Place::ty`], still\n+/// accept such a place. If you write a function for which it might be ambiguous whether such a\n+/// thing is accepted, make sure to document your choice clearly.\n #[derive(Clone, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub enum Operand<'tcx> {\n-    /// Creates a value by performing a place to value conversion at the given place. The type of\n-    /// the place must be `Copy`\n+    /// Creates a value by loading the given place. The type of the place must be `Copy`\n     Copy(Place<'tcx>),\n \n-    /// Creates a value by performing a place to value conversion for the place, just like the\n-    /// `Copy` operand.\n+    /// Creates a value by performing loading the place, just like the `Copy` operand.\n     ///\n     /// This *may* additionally overwrite the place with `uninit` bytes, depending on how we decide\n-    /// in [UCG#188]. You should not emit MIR that may attempt a subsequent second place to value\n-    /// conversion on this place without first re-initializing it.\n+    /// in [UCG#188]. You should not emit MIR that may attempt a subsequent second load of this\n+    /// place without first re-initializing it.\n     ///\n     /// [UCG#188]: https://github.com/rust-lang/unsafe-code-guidelines/issues/188\n     Move(Place<'tcx>),\n@@ -2473,7 +2455,7 @@ impl<'tcx> Operand<'tcx> {\n ///\n /// Computing any rvalue begins by evaluating the places and operands in some order (**Needs\n /// clarification**: Which order?). These are then used to produce a \"value\" - the same kind of\n-/// value that an [`Operand`] is.\n+/// value that an [`Operand`] produces.\n pub enum Rvalue<'tcx> {\n     /// Yields the operand unchanged\n     Use(Operand<'tcx>),\n@@ -2497,14 +2479,14 @@ pub enum Rvalue<'tcx> {\n     /// `Shallow` borrows are disallowed after drop lowering.\n     Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n \n-    /// Returns a pointer/reference to the given thread local.\n+    /// Creates a pointer/reference to the given thread local.\n     ///\n     /// The yielded type is a `*mut T` if the static is mutable, otherwise if the static is extern a\n     /// `*const T`, and if neither of those apply a `&T`.\n     ///\n     /// **Note:** This is a runtime operation that actually executes code and is in this sense more\n-    /// like a function call. Also, DSEing these causes `fn main() {}` to SIGILL for some reason\n-    /// that I never got a chance to look into.\n+    /// like a function call. Also, eliminating dead stores of this rvalue causes `fn main() {}` to\n+    /// SIGILL for some reason that I (JakobDegen) never got a chance to look into.\n     ///\n     /// **Needs clarification**: Are there weird additional semantics here related to the runtime\n     /// nature of this operation?\n@@ -2521,9 +2503,9 @@ pub enum Rvalue<'tcx> {\n \n     /// Yields the length of the place, as a `usize`.\n     ///\n-    /// If the type of the place is an array, this is the array length. This also works for slices\n-    /// (`[T]`, not `&[T]`) through some mechanism that depends on how exactly places work (see\n-    /// there for more details).\n+    /// If the type of the place is an array, this is the array length. For slices (`[T]`, not\n+    /// `&[T]`) this accesses the place's metadata to determine the length. This rvalue is\n+    /// ill-formed for places of other types.\n     Len(Place<'tcx>),\n \n     /// Performs essentially all of the casts that can be performed via `as`.\n@@ -2537,21 +2519,21 @@ pub enum Rvalue<'tcx> {\n     /// * `Offset` has the same semantics as [`offset`](pointer::offset), except that the second\n     ///   parameter may be a `usize` as well.\n     /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,\n-    ///   raw pointers, or function pointers and return a `bool`.\n+    ///   raw pointers, or function pointers of matching types and return a `bool`.\n     /// * Left and right shift operations accept signed or unsigned integers not necessarily of the\n-    ///   same type and return a value of the same type as their LHS. For all other operations, the\n-    ///   types of the operands must match. Like in Rust, the RHS is truncated as needed.\n-    /// * The `Bit*` operations accept signed integers, unsigned integers, or bools and return a\n-    ///   value of that type.\n-    /// * The remaining operations accept signed integers, unsigned integers, or floats of any\n-    ///   matching type and return a value of that type.\n+    ///   same type and return a value of the same type as their LHS. Like in Rust, the RHS is\n+    ///   truncated as needed.\n+    /// * The `Bit*` operations accept signed integers, unsigned integers, or bools with matching\n+    ///   types and return a value of that type.\n+    /// * The remaining operations accept signed integers, unsigned integers, or floats with\n+    ///   matching types and return a value of that type.\n     BinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n \n     /// Same as `BinaryOp`, but yields `(T, bool)` instead of `T`. In addition to performing the\n     /// same computation as the matching `BinaryOp`, checks if the infinite precison result would be\n     /// unequal to the actual result and sets the `bool` if this is the case.\n     ///\n-    /// This only supports addition, subtraction, multiplication, and shift operations.\n+    /// This only supports addition, subtraction, multiplication, and shift operations on integers.\n     CheckedBinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n \n     /// Computes a value as described by the operation.\n@@ -2592,7 +2574,7 @@ pub enum Rvalue<'tcx> {\n \n     /// Transmutes a `*mut u8` into shallow-initialized `Box<T>`.\n     ///\n-    /// This is different a normal transmute because dataflow analysis will treat the box as\n+    /// This is different from a normal transmute because dataflow analysis will treat the box as\n     /// initialized but its content as uninitialized. Like other pointer casts, this in general\n     /// affects alias analysis.\n     ///"}]}