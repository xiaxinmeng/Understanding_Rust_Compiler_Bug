{"sha": "5cd29225a5484d003f5acbeb5c5cc109bb15442f", "node_id": "C_kwDOAAsO6NoAKDVjZDI5MjI1YTU0ODRkMDAzZjVhY2JlYjVjNWNjMTA5YmIxNTQ0MmY", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-04T15:33:26Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-06-03T16:56:17Z"}, "message": "Remove all names from Encoder\n\nThey aren't used anymore now that the json format has been removed", "tree": {"sha": "decc5e926c87b6757af4f74ce136ce445ea5d0e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/decc5e926c87b6757af4f74ce136ce445ea5d0e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cd29225a5484d003f5acbeb5c5cc109bb15442f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cd29225a5484d003f5acbeb5c5cc109bb15442f", "html_url": "https://github.com/rust-lang/rust/commit/5cd29225a5484d003f5acbeb5c5cc109bb15442f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cd29225a5484d003f5acbeb5c5cc109bb15442f/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ede5ac251ce4189e580e754c4a8bc2a9d4b7cb3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ede5ac251ce4189e580e754c4a8bc2a9d4b7cb3a", "html_url": "https://github.com/rust-lang/rust/commit/ede5ac251ce4189e580e754c4a8bc2a9d4b7cb3a"}], "stats": {"total": 288, "additions": 120, "deletions": 168}, "files": [{"sha": "17dcc461e28a0a47059965b4b0e1b6d83a46b671", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5cd29225a5484d003f5acbeb5c5cc109bb15442f/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cd29225a5484d003f5acbeb5c5cc109bb15442f/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=5cd29225a5484d003f5acbeb5c5cc109bb15442f", "patch": "@@ -140,23 +140,14 @@ fn encodable_body(\n \n     let encode_body = match s.variants() {\n         [_] => {\n-            let mut field_idx = 0usize;\n             let encode_inner = s.each_variant(|vi| {\n                 vi.bindings()\n                     .iter()\n                     .map(|binding| {\n                         let bind_ident = &binding.binding;\n-                        let field_name = binding\n-                            .ast()\n-                            .ident\n-                            .as_ref()\n-                            .map_or_else(|| field_idx.to_string(), |i| i.to_string());\n-                        let first = field_idx == 0;\n                         let result = quote! {\n                             match ::rustc_serialize::Encoder::emit_struct_field(\n                                 __encoder,\n-                                #field_name,\n-                                #first,\n                                 |__encoder|\n                                 ::rustc_serialize::Encodable::<#encoder_ty>::encode(#bind_ident, __encoder),\n                             ) {\n@@ -165,34 +156,27 @@ fn encodable_body(\n                                     => return ::std::result::Result::Err(__err),\n                             }\n                         };\n-                        field_idx += 1;\n                         result\n                     })\n                     .collect::<TokenStream>()\n             });\n-            let no_fields = field_idx == 0;\n             quote! {\n-                ::rustc_serialize::Encoder::emit_struct(__encoder, #no_fields, |__encoder| {\n+                ::rustc_serialize::Encoder::emit_struct(__encoder, |__encoder| {\n                     ::std::result::Result::Ok(match *self { #encode_inner })\n                 })\n             }\n         }\n         _ => {\n             let mut variant_idx = 0usize;\n             let encode_inner = s.each_variant(|vi| {\n-                let variant_name = vi.ast().ident.to_string();\n-                let mut field_idx = 0usize;\n-\n                 let encode_fields: TokenStream = vi\n                     .bindings()\n                     .iter()\n                     .map(|binding| {\n                         let bind_ident = &binding.binding;\n-                        let first = field_idx == 0;\n                         let result = quote! {\n                             match ::rustc_serialize::Encoder::emit_enum_variant_arg(\n                                 __encoder,\n-                                #first,\n                                 |__encoder|\n                                 ::rustc_serialize::Encodable::<#encoder_ty>::encode(#bind_ident, __encoder),\n                             ) {\n@@ -201,26 +185,22 @@ fn encodable_body(\n                                     => return ::std::result::Result::Err(__err),\n                             }\n                         };\n-                        field_idx += 1;\n                         result\n                     })\n                     .collect();\n \n-                let result = if field_idx != 0 {\n+                let result = if !vi.bindings().is_empty() {\n                     quote! {\n                         ::rustc_serialize::Encoder::emit_enum_variant(\n                             __encoder,\n-                            #variant_name,\n                             #variant_idx,\n-                            #field_idx,\n                             |__encoder| { ::std::result::Result::Ok({ #encode_fields }) }\n                         )\n                     }\n                 } else {\n                     quote! {\n                         ::rustc_serialize::Encoder::emit_fieldless_enum_variant::<#variant_idx>(\n                             __encoder,\n-                            #variant_name,\n                         )\n                     }\n                 };"}, {"sha": "f4bf0a2397048e1d4e33695f223b89bcc3f7643a", "filename": "compiler/rustc_serialize/src/collection_impls.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5cd29225a5484d003f5acbeb5c5cc109bb15442f/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cd29225a5484d003f5acbeb5c5cc109bb15442f/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs?ref=5cd29225a5484d003f5acbeb5c5cc109bb15442f", "patch": "@@ -26,8 +26,8 @@ impl<D: Decoder, A: Array<Item: Decodable<D>>> Decodable<D> for SmallVec<A> {\n impl<S: Encoder, T: Encodable<S>> Encodable<S> for LinkedList<T> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?;\n+            for e in self.iter() {\n+                s.emit_seq_elt(|s| e.encode(s))?;\n             }\n             Ok(())\n         })\n@@ -44,8 +44,8 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for LinkedList<T> {\n impl<S: Encoder, T: Encodable<S>> Encodable<S> for VecDeque<T> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?;\n+            for e in self.iter() {\n+                s.emit_seq_elt(|s| e.encode(s))?;\n             }\n             Ok(())\n         })\n@@ -66,8 +66,8 @@ where\n {\n     fn encode(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n-            for (i, (key, val)) in self.iter().enumerate() {\n-                e.emit_map_elt_key(i, |e| key.encode(e))?;\n+            for (key, val) in self.iter() {\n+                e.emit_map_elt_key(|e| key.encode(e))?;\n                 e.emit_map_elt_val(|e| val.encode(e))?;\n             }\n             Ok(())\n@@ -98,8 +98,8 @@ where\n {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?;\n+            for e in self.iter() {\n+                s.emit_seq_elt(|s| e.encode(s))?;\n             }\n             Ok(())\n         })\n@@ -128,8 +128,8 @@ where\n {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n-            for (i, (key, val)) in self.iter().enumerate() {\n-                e.emit_map_elt_key(i, |e| key.encode(e))?;\n+            for (key, val) in self.iter() {\n+                e.emit_map_elt_key(|e| key.encode(e))?;\n                 e.emit_map_elt_val(|e| val.encode(e))?;\n             }\n             Ok(())\n@@ -163,8 +163,8 @@ where\n {\n     fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?;\n+            for e in self.iter() {\n+                s.emit_seq_elt(|s| e.encode(s))?;\n             }\n             Ok(())\n         })\n@@ -195,8 +195,8 @@ where\n {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n-            for (i, (key, val)) in self.iter().enumerate() {\n-                e.emit_map_elt_key(i, |e| key.encode(e))?;\n+            for (key, val) in self.iter() {\n+                e.emit_map_elt_key(|e| key.encode(e))?;\n                 e.emit_map_elt_val(|e| val.encode(e))?;\n             }\n             Ok(())\n@@ -230,8 +230,8 @@ where\n {\n     fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?;\n+            for e in self.iter() {\n+                s.emit_seq_elt(|s| e.encode(s))?;\n             }\n             Ok(())\n         })"}, {"sha": "84fd3b40e63deef18756a35abf516cfc7182eb13", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 17, "deletions": 44, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5cd29225a5484d003f5acbeb5c5cc109bb15442f/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cd29225a5484d003f5acbeb5c5cc109bb15442f/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=5cd29225a5484d003f5acbeb5c5cc109bb15442f", "patch": "@@ -44,13 +44,7 @@ pub trait Encoder {\n         f(self)\n     }\n \n-    fn emit_enum_variant<F>(\n-        &mut self,\n-        _v_name: &str,\n-        v_id: usize,\n-        _len: usize,\n-        f: F,\n-    ) -> Result<(), Self::Error>\n+    fn emit_enum_variant<F>(&mut self, v_id: usize, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n@@ -65,47 +59,44 @@ pub trait Encoder {\n     // optimization that would otherwise be necessary here, likely due to the\n     // multiple levels of inlining and const-prop that are needed.\n     #[inline]\n-    fn emit_fieldless_enum_variant<const ID: usize>(\n-        &mut self,\n-        _v_name: &str,\n-    ) -> Result<(), Self::Error> {\n+    fn emit_fieldless_enum_variant<const ID: usize>(&mut self) -> Result<(), Self::Error> {\n         self.emit_usize(ID)\n     }\n \n     #[inline]\n-    fn emit_enum_variant_arg<F>(&mut self, _first: bool, f: F) -> Result<(), Self::Error>\n+    fn emit_enum_variant_arg<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn emit_struct<F>(&mut self, _no_fields: bool, f: F) -> Result<(), Self::Error>\n+    fn emit_struct<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn emit_struct_field<F>(&mut self, _f_name: &str, _first: bool, f: F) -> Result<(), Self::Error>\n+    fn emit_struct_field<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn emit_tuple<F>(&mut self, _len: usize, f: F) -> Result<(), Self::Error>\n+    fn emit_tuple<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn emit_tuple_arg<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+    fn emit_tuple_arg<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n@@ -122,14 +113,14 @@ pub trait Encoder {\n \n     #[inline]\n     fn emit_option_none(&mut self) -> Result<(), Self::Error> {\n-        self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n+        self.emit_enum_variant(0, |_| Ok(()))\n     }\n \n     fn emit_option_some<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n-        self.emit_enum_variant(\"Some\", 1, 1, f)\n+        self.emit_enum_variant(1, f)\n     }\n \n     fn emit_seq<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n@@ -141,7 +132,7 @@ pub trait Encoder {\n     }\n \n     #[inline]\n-    fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+    fn emit_seq_elt<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n@@ -157,7 +148,7 @@ pub trait Encoder {\n     }\n \n     #[inline]\n-    fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+    fn emit_map_elt_key<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n@@ -363,8 +354,8 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<T> {\n impl<S: Encoder, T: Encodable<S>> Encodable<S> for [T] {\n     default fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?\n+            for e in self.iter() {\n+                s.emit_seq_elt(|s| e.encode(s))?\n             }\n             Ok(())\n         })\n@@ -470,12 +461,8 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Option<T> {\n impl<S: Encoder, T1: Encodable<S>, T2: Encodable<S>> Encodable<S> for Result<T1, T2> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_enum(|s| match *self {\n-            Ok(ref v) => {\n-                s.emit_enum_variant(\"Ok\", 0, 1, |s| s.emit_enum_variant_arg(true, |s| v.encode(s)))\n-            }\n-            Err(ref v) => {\n-                s.emit_enum_variant(\"Err\", 1, 1, |s| s.emit_enum_variant_arg(true, |s| v.encode(s)))\n-            }\n+            Ok(ref v) => s.emit_enum_variant(0, |s| s.emit_enum_variant_arg(|s| v.encode(s))),\n+            Err(ref v) => s.emit_enum_variant(1, |s| s.emit_enum_variant_arg(|s| v.encode(s))),\n         })\n     }\n }\n@@ -494,18 +481,6 @@ macro_rules! peel {\n     ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n }\n \n-/// Evaluates to the number of tokens passed to it.\n-///\n-/// Logarithmic counting: every one or two recursive expansions, the number of\n-/// tokens to count is divided by two, instead of being reduced by one.\n-/// Therefore, the recursion depth is the binary logarithm of the number of\n-/// tokens to count, and the expanded tree is likewise very small.\n-macro_rules! count {\n-    ($one:tt)              => (1usize);\n-    ($($pairs:tt $_p:tt)*) => (count!($($pairs)*) << 1usize);\n-    ($odd:tt $($rest:tt)*) => (count!($($rest)*) | 1usize);\n-}\n-\n macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n@@ -518,10 +493,8 @@ macro_rules! tuple {\n             #[allow(non_snake_case)]\n             fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n                 let ($(ref $name,)+) = *self;\n-                let len: usize = count!($($name)+);\n-                s.emit_tuple(len, |s| {\n-                    let mut i = 0;\n-                    $(s.emit_tuple_arg({ i+=1; i-1 }, |s| $name.encode(s))?;)+\n+                s.emit_tuple(|s| {\n+                    $(s.emit_tuple_arg(|s| $name.encode(s))?;)+\n                     Ok(())\n                 })\n             }"}, {"sha": "ccc59b5b647a47e724c41cc51b3f320e143132be", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cd29225a5484d003f5acbeb5c5cc109bb15442f/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cd29225a5484d003f5acbeb5c5cc109bb15442f/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=5cd29225a5484d003f5acbeb5c5cc109bb15442f", "patch": "@@ -307,10 +307,10 @@ impl DefId {\n \n impl<E: Encoder> Encodable<E> for DefId {\n     default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_struct(false, |s| {\n-            s.emit_struct_field(\"krate\", true, |s| self.krate.encode(s))?;\n+        s.emit_struct(|s| {\n+            s.emit_struct_field(|s| self.krate.encode(s))?;\n \n-            s.emit_struct_field(\"index\", false, |s| self.index.encode(s))\n+            s.emit_struct_field(|s| self.index.encode(s))\n         })\n     }\n }"}, {"sha": "4559a772e6b8db3b2e5d0c302587891e14655e75", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5cd29225a5484d003f5acbeb5c5cc109bb15442f/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cd29225a5484d003f5acbeb5c5cc109bb15442f/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=5cd29225a5484d003f5acbeb5c5cc109bb15442f", "patch": "@@ -197,20 +197,19 @@ impl Hash for RealFileName {\n impl<S: Encoder> Encodable<S> for RealFileName {\n     fn encode(&self, encoder: &mut S) -> Result<(), S::Error> {\n         encoder.emit_enum(|encoder| match *self {\n-            RealFileName::LocalPath(ref local_path) => {\n-                encoder.emit_enum_variant(\"LocalPath\", 0, 1, |encoder| {\n-                    encoder.emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;\n-                    Ok(())\n+            RealFileName::LocalPath(ref local_path) => encoder.emit_enum_variant(0, |encoder| {\n+                Ok({\n+                    encoder.emit_enum_variant_arg(|encoder| local_path.encode(encoder))?;\n                 })\n-            }\n+            }),\n \n             RealFileName::Remapped { ref local_path, ref virtual_name } => encoder\n-                .emit_enum_variant(\"Remapped\", 1, 2, |encoder| {\n+                .emit_enum_variant(1, |encoder| {\n                     // For privacy and build reproducibility, we must not embed host-dependant path in artifacts\n                     // if they have been remapped by --remap-path-prefix\n                     assert!(local_path.is_none());\n-                    encoder.emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;\n-                    encoder.emit_enum_variant_arg(false, |encoder| virtual_name.encode(encoder))?;\n+                    encoder.emit_enum_variant_arg(|encoder| local_path.encode(encoder))?;\n+                    encoder.emit_enum_variant_arg(|encoder| virtual_name.encode(encoder))?;\n                     Ok(())\n                 }),\n         })\n@@ -950,9 +949,9 @@ impl Default for Span {\n impl<E: Encoder> Encodable<E> for Span {\n     default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         let span = self.data();\n-        s.emit_struct(false, |s| {\n-            s.emit_struct_field(\"lo\", true, |s| span.lo.encode(s))?;\n-            s.emit_struct_field(\"hi\", false, |s| span.hi.encode(s))\n+        s.emit_struct(|s| {\n+            s.emit_struct_field(|s| span.lo.encode(s))?;\n+            s.emit_struct_field(|s| span.hi.encode(s))\n         })\n     }\n }\n@@ -1302,12 +1301,12 @@ pub struct SourceFile {\n \n impl<S: Encoder> Encodable<S> for SourceFile {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(false, |s| {\n-            s.emit_struct_field(\"name\", true, |s| self.name.encode(s))?;\n-            s.emit_struct_field(\"src_hash\", false, |s| self.src_hash.encode(s))?;\n-            s.emit_struct_field(\"start_pos\", false, |s| self.start_pos.encode(s))?;\n-            s.emit_struct_field(\"end_pos\", false, |s| self.end_pos.encode(s))?;\n-            s.emit_struct_field(\"lines\", false, |s| {\n+        s.emit_struct(|s| {\n+            s.emit_struct_field(|s| self.name.encode(s))?;\n+            s.emit_struct_field(|s| self.src_hash.encode(s))?;\n+            s.emit_struct_field(|s| self.start_pos.encode(s))?;\n+            s.emit_struct_field(|s| self.end_pos.encode(s))?;\n+            s.emit_struct_field(|s| {\n                 // We are always in `Lines` form by the time we reach here.\n                 assert!(self.lines.borrow().is_lines());\n                 self.lines(|lines| {\n@@ -1369,11 +1368,11 @@ impl<S: Encoder> Encodable<S> for SourceFile {\n                     Ok(())\n                 })\n             })?;\n-            s.emit_struct_field(\"multibyte_chars\", false, |s| self.multibyte_chars.encode(s))?;\n-            s.emit_struct_field(\"non_narrow_chars\", false, |s| self.non_narrow_chars.encode(s))?;\n-            s.emit_struct_field(\"name_hash\", false, |s| self.name_hash.encode(s))?;\n-            s.emit_struct_field(\"normalized_pos\", false, |s| self.normalized_pos.encode(s))?;\n-            s.emit_struct_field(\"cnum\", false, |s| self.cnum.encode(s))\n+            s.emit_struct_field(|s| self.multibyte_chars.encode(s))?;\n+            s.emit_struct_field(|s| self.non_narrow_chars.encode(s))?;\n+            s.emit_struct_field(|s| self.name_hash.encode(s))?;\n+            s.emit_struct_field(|s| self.normalized_pos.encode(s))?;\n+            s.emit_struct_field(|s| self.cnum.encode(s))\n         })\n     }\n }"}, {"sha": "8980f1babbbecbd15d6d60c08d2da1abd07c23f7", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/5cd29225a5484d003f5acbeb5c5cc109bb15442f/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cd29225a5484d003f5acbeb5c5cc109bb15442f/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=5cd29225a5484d003f5acbeb5c5cc109bb15442f", "patch": "@@ -719,111 +719,111 @@ where\n         rustc_serialize::Encoder::emit_enum(e, |e| {\n             let disc = discriminant(self);\n             match self {\n-                Bool => e.emit_enum_variant(\"Bool\", disc, 0, |_| Ok(())),\n-                Char => e.emit_enum_variant(\"Char\", disc, 0, |_| Ok(())),\n-                Int(i) => e.emit_enum_variant(\"Int\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| i.encode(e))?;\n+                Bool => e.emit_enum_variant(disc, |_| Ok(())),\n+                Char => e.emit_enum_variant(disc, |_| Ok(())),\n+                Int(i) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| i.encode(e))?;\n                     Ok(())\n                 }),\n-                Uint(u) => e.emit_enum_variant(\"Uint\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| u.encode(e))?;\n+                Uint(u) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| u.encode(e))?;\n                     Ok(())\n                 }),\n-                Float(f) => e.emit_enum_variant(\"Float\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| f.encode(e))?;\n+                Float(f) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| f.encode(e))?;\n                     Ok(())\n                 }),\n-                Adt(adt, substs) => e.emit_enum_variant(\"Adt\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| adt.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                Adt(adt, substs) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| adt.encode(e))?;\n+                    e.emit_enum_variant_arg(|e| substs.encode(e))?;\n                     Ok(())\n                 }),\n-                Foreign(def_id) => e.emit_enum_variant(\"Foreign\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n+                Foreign(def_id) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| def_id.encode(e))?;\n                     Ok(())\n                 }),\n-                Str => e.emit_enum_variant(\"Str\", disc, 0, |_| Ok(())),\n-                Array(t, c) => e.emit_enum_variant(\"Array\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| t.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| c.encode(e))?;\n+                Str => e.emit_enum_variant(disc, |_| Ok(())),\n+                Array(t, c) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| t.encode(e))?;\n+                    e.emit_enum_variant_arg(|e| c.encode(e))?;\n                     Ok(())\n                 }),\n-                Slice(t) => e.emit_enum_variant(\"Slice\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| t.encode(e))?;\n+                Slice(t) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| t.encode(e))?;\n                     Ok(())\n                 }),\n-                RawPtr(tam) => e.emit_enum_variant(\"RawPtr\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| tam.encode(e))?;\n+                RawPtr(tam) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| tam.encode(e))?;\n                     Ok(())\n                 }),\n-                Ref(r, t, m) => e.emit_enum_variant(\"Ref\", disc, 3, |e| {\n-                    e.emit_enum_variant_arg(true, |e| r.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| t.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| m.encode(e))?;\n+                Ref(r, t, m) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| r.encode(e))?;\n+                    e.emit_enum_variant_arg(|e| t.encode(e))?;\n+                    e.emit_enum_variant_arg(|e| m.encode(e))?;\n                     Ok(())\n                 }),\n-                FnDef(def_id, substs) => e.emit_enum_variant(\"FnDef\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                FnDef(def_id, substs) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| def_id.encode(e))?;\n+                    e.emit_enum_variant_arg(|e| substs.encode(e))?;\n                     Ok(())\n                 }),\n-                FnPtr(polyfnsig) => e.emit_enum_variant(\"FnPtr\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| polyfnsig.encode(e))?;\n+                FnPtr(polyfnsig) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| polyfnsig.encode(e))?;\n                     Ok(())\n                 }),\n-                Dynamic(l, r) => e.emit_enum_variant(\"Dynamic\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| l.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| r.encode(e))?;\n+                Dynamic(l, r) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| l.encode(e))?;\n+                    e.emit_enum_variant_arg(|e| r.encode(e))?;\n                     Ok(())\n                 }),\n-                Closure(def_id, substs) => e.emit_enum_variant(\"Closure\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                Closure(def_id, substs) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| def_id.encode(e))?;\n+                    e.emit_enum_variant_arg(|e| substs.encode(e))?;\n                     Ok(())\n                 }),\n-                Generator(def_id, substs, m) => e.emit_enum_variant(\"Generator\", disc, 3, |e| {\n-                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| m.encode(e))?;\n+                Generator(def_id, substs, m) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| def_id.encode(e))?;\n+                    e.emit_enum_variant_arg(|e| substs.encode(e))?;\n+                    e.emit_enum_variant_arg(|e| m.encode(e))?;\n                     Ok(())\n                 }),\n-                GeneratorWitness(b) => e.emit_enum_variant(\"GeneratorWitness\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| b.encode(e))?;\n+                GeneratorWitness(b) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| b.encode(e))?;\n                     Ok(())\n                 }),\n-                Never => e.emit_enum_variant(\"Never\", disc, 0, |_| Ok(())),\n-                Tuple(substs) => e.emit_enum_variant(\"Tuple\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| substs.encode(e))?;\n+                Never => e.emit_enum_variant(disc, |_| Ok(())),\n+                Tuple(substs) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| substs.encode(e))?;\n                     Ok(())\n                 }),\n-                Projection(p) => e.emit_enum_variant(\"Projection\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n+                Projection(p) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| p.encode(e))?;\n                     Ok(())\n                 }),\n-                Opaque(def_id, substs) => e.emit_enum_variant(\"Opaque\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                Opaque(def_id, substs) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| def_id.encode(e))?;\n+                    e.emit_enum_variant_arg(|e| substs.encode(e))?;\n                     Ok(())\n                 }),\n-                Param(p) => e.emit_enum_variant(\"Param\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n+                Param(p) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| p.encode(e))?;\n                     Ok(())\n                 }),\n-                Bound(d, b) => e.emit_enum_variant(\"Bound\", disc, 2, |e| {\n-                    e.emit_enum_variant_arg(true, |e| d.encode(e))?;\n-                    e.emit_enum_variant_arg(false, |e| b.encode(e))?;\n+                Bound(d, b) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| d.encode(e))?;\n+                    e.emit_enum_variant_arg(|e| b.encode(e))?;\n                     Ok(())\n                 }),\n-                Placeholder(p) => e.emit_enum_variant(\"Placeholder\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n+                Placeholder(p) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| p.encode(e))?;\n                     Ok(())\n                 }),\n-                Infer(i) => e.emit_enum_variant(\"Infer\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| i.encode(e))?;\n+                Infer(i) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| i.encode(e))?;\n                     Ok(())\n                 }),\n-                Error(d) => e.emit_enum_variant(\"Error\", disc, 1, |e| {\n-                    e.emit_enum_variant_arg(true, |e| d.encode(e))?;\n+                Error(d) => e.emit_enum_variant(disc, |e| {\n+                    e.emit_enum_variant_arg(|e| d.encode(e))?;\n                     Ok(())\n                 }),\n             }"}]}