{"sha": "1d9405fb6caa5eac18e5a28685e4f30dcbde6d45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkOTQwNWZiNmNhYTVlYWMxOGU1YTI4Njg1ZTRmMzBkY2JkZTZkNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-02T00:14:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-02T00:14:21Z"}, "message": "Auto merge of #52206 - RalfJung:zst-slices, r=alexcrichton\n\nslices: fix ZST slice iterators making up pointers; debug_assert alignment in from_raw_parts\n\nThis fixes the problem that we are fabricating pointers out of thin air. I also managed to share more code between the mutable and shared iterators, while reducing the amount of macros.\n\nI am not sure how useful it really is to add a `debug_assert!` in libcore. Everybody gets a release version of that anyway, right? Is there at least a CI job that runs the test suite with a debug version?\n\nFixes #42789", "tree": {"sha": "ce4c50b240bfafc9cfe665e533aed28fb8c0c7b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce4c50b240bfafc9cfe665e533aed28fb8c0c7b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d9405fb6caa5eac18e5a28685e4f30dcbde6d45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d9405fb6caa5eac18e5a28685e4f30dcbde6d45", "html_url": "https://github.com/rust-lang/rust/commit/1d9405fb6caa5eac18e5a28685e4f30dcbde6d45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d9405fb6caa5eac18e5a28685e4f30dcbde6d45/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97085f9fb0736b322dc216db3655da780b4d8041", "url": "https://api.github.com/repos/rust-lang/rust/commits/97085f9fb0736b322dc216db3655da780b4d8041", "html_url": "https://github.com/rust-lang/rust/commit/97085f9fb0736b322dc216db3655da780b4d8041"}, {"sha": "9fcf2c972663ab510417ba1df058f99f0b0d0abe", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fcf2c972663ab510417ba1df058f99f0b0d0abe", "html_url": "https://github.com/rust-lang/rust/commit/9fcf2c972663ab510417ba1df058f99f0b0d0abe"}], "stats": {"total": 489, "additions": 277, "deletions": 212}, "files": [{"sha": "a4dde38cb7bb636abb201cbd26c056a0b4cd21f5", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 151, "deletions": 212, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/1d9405fb6caa5eac18e5a28685e4f30dcbde6d45/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9405fb6caa5eac18e5a28685e4f30dcbde6d45/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=1d9405fb6caa5eac18e5a28685e4f30dcbde6d45", "patch": "@@ -75,44 +75,6 @@ struct FatPtr<T> {\n // Extension traits\n //\n \n-// Use macros to be generic over const/mut\n-macro_rules! slice_offset {\n-    ($ptr:expr, $by:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            (ptr as *mut i8).wrapping_offset($by) as _\n-        } else {\n-            ptr.offset($by)\n-        }\n-    }};\n-}\n-\n-// make a &T from a *const T\n-macro_rules! make_ref {\n-    ($ptr:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            // Use a non-null pointer value\n-            &*(1 as *mut _)\n-        } else {\n-            &*ptr\n-        }\n-    }};\n-}\n-\n-// make a &mut T from a *mut T\n-macro_rules! make_ref_mut {\n-    ($ptr:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            // Use a non-null pointer value\n-            &mut *(1 as *mut _)\n-        } else {\n-            &mut *ptr\n-        }\n-    }};\n-}\n-\n #[lang = \"slice\"]\n #[cfg(not(test))]\n impl<T> [T] {\n@@ -580,17 +542,18 @@ impl<T> [T] {\n     #[inline]\n     pub fn iter(&self) -> Iter<T> {\n         unsafe {\n-            let p = if mem::size_of::<T>() == 0 {\n-                1 as *const _\n+            let ptr = self.as_ptr();\n+            assume(!ptr.is_null());\n+\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as *const u8).wrapping_offset(self.len() as isize) as *const T\n             } else {\n-                let p = self.as_ptr();\n-                assume(!p.is_null());\n-                p\n+                ptr.offset(self.len() as isize)\n             };\n \n             Iter {\n-                ptr: p,\n-                end: slice_offset!(p, self.len() as isize),\n+                ptr,\n+                end,\n                 _marker: marker::PhantomData\n             }\n         }\n@@ -611,17 +574,18 @@ impl<T> [T] {\n     #[inline]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         unsafe {\n-            let p = if mem::size_of::<T>() == 0 {\n-                1 as *mut _\n+            let ptr = self.as_mut_ptr();\n+            assume(!ptr.is_null());\n+\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as *mut u8).wrapping_offset(self.len() as isize) as *mut T\n             } else {\n-                let p = self.as_mut_ptr();\n-                assume(!p.is_null());\n-                p\n+                ptr.offset(self.len() as isize)\n             };\n \n             IterMut {\n-                ptr: p,\n-                end: slice_offset!(p, self.len() as isize),\n+                ptr,\n+                end,\n                 _marker: marker::PhantomData\n             }\n         }\n@@ -2373,14 +2337,88 @@ impl<'a, T> IntoIterator for &'a mut [T] {\n     }\n }\n \n-#[inline]\n+// Macro helper functions\n+#[inline(always)]\n fn size_from_ptr<T>(_: *const T) -> usize {\n     mem::size_of::<T>()\n }\n \n+// Inlining is_empty and len makes a huge performance difference\n+macro_rules! is_empty {\n+    // The way we encode the length of a ZST iterator, this works both for ZST\n+    // and non-ZST.\n+    ($self: ident) => {$self.ptr == $self.end}\n+}\n+// To get rid of some bounds checks (see `position`), we compute the length in a somewhat\n+// unexpected way. (Tested by `codegen/slice-position-bounds-check`.)\n+macro_rules! len {\n+    ($self: ident) => {{\n+        let start = $self.ptr;\n+        let diff = ($self.end as usize).wrapping_sub(start as usize);\n+        let size = size_from_ptr(start);\n+        if size == 0 {\n+            diff\n+        } else {\n+            // Using division instead of `offset_from` helps LLVM remove bounds checks\n+            diff / size\n+        }\n+    }}\n+}\n+\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n-    (struct $name:ident -> $ptr:ty, $elem:ty, $mkref:ident) => {\n+    (struct $name:ident -> $ptr:ty, $elem:ty, $raw_mut:tt, $( $mut_:tt )*) => {\n+        impl<'a, T> $name<'a, T> {\n+            // Helper function for creating a slice from the iterator.\n+            #[inline(always)]\n+            fn make_slice(&self) -> &'a [T] {\n+                unsafe { from_raw_parts(self.ptr, len!(self)) }\n+            }\n+\n+            // Helper function for moving the start of the iterator forwards by `offset` elements,\n+            // returning the old start.\n+            // Unsafe because the offset must be in-bounds or one-past-the-end.\n+            #[inline(always)]\n+            unsafe fn post_inc_start(&mut self, offset: isize) -> * $raw_mut T {\n+                if mem::size_of::<T>() == 0 {\n+                    // This is *reducing* the length.  `ptr` never changes with ZST.\n+                    self.end = (self.end as * $raw_mut u8).wrapping_offset(-offset) as * $raw_mut T;\n+                    self.ptr\n+                } else {\n+                    let old = self.ptr;\n+                    self.ptr = self.ptr.offset(offset);\n+                    old\n+                }\n+            }\n+\n+            // Helper function for moving the end of the iterator backwards by `offset` elements,\n+            // returning the new end.\n+            // Unsafe because the offset must be in-bounds or one-past-the-end.\n+            #[inline(always)]\n+            unsafe fn pre_dec_end(&mut self, offset: isize) -> * $raw_mut T {\n+                if mem::size_of::<T>() == 0 {\n+                    self.end = (self.end as * $raw_mut u8).wrapping_offset(-offset) as * $raw_mut T;\n+                    self.ptr\n+                } else {\n+                    self.end = self.end.offset(-offset);\n+                    self.end\n+                }\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, T> ExactSizeIterator for $name<'a, T> {\n+            #[inline(always)]\n+            fn len(&self) -> usize {\n+                len!(self)\n+            }\n+\n+            #[inline(always)]\n+            fn is_empty(&self) -> bool {\n+                is_empty!(self)\n+            }\n+        }\n+\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<'a, T> Iterator for $name<'a, T> {\n             type Item = $elem;\n@@ -2389,33 +2427,48 @@ macro_rules! iterator {\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n+                    assume(!self.ptr.is_null());\n                     if mem::size_of::<T>() != 0 {\n-                        assume(!self.ptr.is_null());\n                         assume(!self.end.is_null());\n                     }\n-                    if self.ptr == self.end {\n+                    if is_empty!(self) {\n                         None\n                     } else {\n-                        Some($mkref!(self.ptr.post_inc()))\n+                        Some(& $( $mut_ )* *self.post_inc_start(1))\n                     }\n                 }\n             }\n \n             #[inline]\n             fn size_hint(&self) -> (usize, Option<usize>) {\n-                let exact = unsafe { ptrdistance(self.ptr, self.end) };\n+                let exact = len!(self);\n                 (exact, Some(exact))\n             }\n \n             #[inline]\n             fn count(self) -> usize {\n-                self.len()\n+                len!(self)\n             }\n \n             #[inline]\n             fn nth(&mut self, n: usize) -> Option<$elem> {\n-                // Call helper method. Can't put the definition here because mut versus const.\n-                self.iter_nth(n)\n+                if n >= len!(self) {\n+                    // This iterator is now empty.\n+                    if mem::size_of::<T>() == 0 {\n+                        // We have to do it this way as `ptr` may never be 0, but `end`\n+                        // could be (due to wrapping).\n+                        self.end = self.ptr;\n+                    } else {\n+                        self.ptr = self.end;\n+                    }\n+                    return None;\n+                }\n+                // We are in bounds. `offset` does the right thing even for ZSTs.\n+                unsafe {\n+                    let elem = Some(& $( $mut_ )* *self.ptr.offset(n as isize));\n+                    self.post_inc_start((n as isize).wrapping_add(1));\n+                    elem\n+                }\n             }\n \n             #[inline]\n@@ -2430,14 +2483,14 @@ macro_rules! iterator {\n                 // manual unrolling is needed when there are conditional exits from the loop\n                 let mut accum = init;\n                 unsafe {\n-                    while ptrdistance(self.ptr, self.end) >= 4 {\n-                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n-                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n-                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n-                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n+                    while len!(self) >= 4 {\n+                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n+                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n+                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n+                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n                     }\n-                    while self.ptr != self.end {\n-                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n+                    while !is_empty!(self) {\n+                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n                     }\n                 }\n                 Try::from_ok(accum)\n@@ -2462,9 +2515,8 @@ macro_rules! iterator {\n                 Self: Sized,\n                 P: FnMut(Self::Item) -> bool,\n             {\n-                // The addition might panic on overflow\n-                // Use the len of the slice to hint optimizer to remove result index bounds check.\n-                let n = make_slice!(self.ptr, self.end).len();\n+                // The addition might panic on overflow.\n+                let n = len!(self);\n                 self.try_fold(0, move |i, x| {\n                     if predicate(x) { Err(i) }\n                     else { Ok(i + 1) }\n@@ -2481,9 +2533,7 @@ macro_rules! iterator {\n                 Self: Sized + ExactSizeIterator + DoubleEndedIterator\n             {\n                 // No need for an overflow check here, because `ExactSizeIterator`\n-                // implies that the number of elements fits into a `usize`.\n-                // Use the len of the slice to hint optimizer to remove result index bounds check.\n-                let n = make_slice!(self.ptr, self.end).len();\n+                let n = len!(self);\n                 self.try_rfold(n, move |i, x| {\n                     let i = i - 1;\n                     if predicate(x) { Err(i) }\n@@ -2502,14 +2552,14 @@ macro_rules! iterator {\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n+                    assume(!self.ptr.is_null());\n                     if mem::size_of::<T>() != 0 {\n-                        assume(!self.ptr.is_null());\n                         assume(!self.end.is_null());\n                     }\n-                    if self.end == self.ptr {\n+                    if is_empty!(self) {\n                         None\n                     } else {\n-                        Some($mkref!(self.end.pre_dec()))\n+                        Some(& $( $mut_ )* *self.pre_dec_end(1))\n                     }\n                 }\n             }\n@@ -2521,14 +2571,15 @@ macro_rules! iterator {\n                 // manual unrolling is needed when there are conditional exits from the loop\n                 let mut accum = init;\n                 unsafe {\n-                    while ptrdistance(self.ptr, self.end) >= 4 {\n-                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n-                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n-                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n-                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n+                    while len!(self) >= 4 {\n+                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n+                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n+                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n+                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n                     }\n-                    while self.ptr != self.end {\n-                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n+                    // inlining is_empty everywhere makes a huge performance difference\n+                    while !is_empty!(self) {\n+                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n                     }\n                 }\n                 Try::from_ok(accum)\n@@ -2556,34 +2607,6 @@ macro_rules! iterator {\n     }\n }\n \n-macro_rules! make_slice {\n-    ($start: expr, $end: expr) => {{\n-        let start = $start;\n-        let diff = ($end as usize).wrapping_sub(start as usize);\n-        if size_from_ptr(start) == 0 {\n-            // use a non-null pointer value\n-            unsafe { from_raw_parts(1 as *const _, diff) }\n-        } else {\n-            let len = diff / size_from_ptr(start);\n-            unsafe { from_raw_parts(start, len) }\n-        }\n-    }}\n-}\n-\n-macro_rules! make_mut_slice {\n-    ($start: expr, $end: expr) => {{\n-        let start = $start;\n-        let diff = ($end as usize).wrapping_sub(start as usize);\n-        if size_from_ptr(start) == 0 {\n-            // use a non-null pointer value\n-            unsafe { from_raw_parts_mut(1 as *mut _, diff) }\n-        } else {\n-            let len = diff / size_from_ptr(start);\n-            unsafe { from_raw_parts_mut(start, len) }\n-        }\n-    }}\n-}\n-\n /// Immutable slice iterator\n ///\n /// This struct is created by the [`iter`] method on [slices].\n@@ -2607,7 +2630,9 @@ macro_rules! make_mut_slice {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     ptr: *const T,\n-    end: *const T,\n+    end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+                   // ptr == end is a quick test for the Iterator being empty, that works\n+                   // for both ZST and non-ZST.\n     _marker: marker::PhantomData<&'a T>,\n }\n \n@@ -2652,32 +2677,11 @@ impl<'a, T> Iter<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn as_slice(&self) -> &'a [T] {\n-        make_slice!(self.ptr, self.end)\n-    }\n-\n-    // Helper function for Iter::nth\n-    fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n-        match self.as_slice().get(n) {\n-            Some(elem_ref) => unsafe {\n-                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n-                Some(elem_ref)\n-            },\n-            None => {\n-                self.ptr = self.end;\n-                None\n-            }\n-        }\n+        self.make_slice()\n     }\n }\n \n-iterator!{struct Iter -> *const T, &'a T, make_ref}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n-    fn is_empty(&self) -> bool {\n-        self.ptr == self.end\n-    }\n-}\n+iterator!{struct Iter -> *const T, &'a T, const, /* no mut */}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n@@ -2718,15 +2722,17 @@ impl<'a, T> AsRef<[T]> for Iter<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     ptr: *mut T,\n-    end: *mut T,\n+    end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+                 // ptr == end is a quick test for the Iterator being empty, that works\n+                 // for both ZST and non-ZST.\n     _marker: marker::PhantomData<&'a mut T>,\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for IterMut<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"IterMut\")\n-            .field(&make_slice!(self.ptr, self.end))\n+            .field(&self.make_slice())\n             .finish()\n     }\n }\n@@ -2772,77 +2778,11 @@ impl<'a, T> IterMut<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n-        make_mut_slice!(self.ptr, self.end)\n-    }\n-\n-    // Helper function for IterMut::nth\n-    fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n-        match make_mut_slice!(self.ptr, self.end).get_mut(n) {\n-            Some(elem_ref) => unsafe {\n-                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n-                Some(elem_ref)\n-            },\n-            None => {\n-                self.ptr = self.end;\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-iterator!{struct IterMut -> *mut T, &'a mut T, make_ref_mut}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n-    fn is_empty(&self) -> bool {\n-        self.ptr == self.end\n+        unsafe { from_raw_parts_mut(self.ptr, len!(self)) }\n     }\n }\n \n-// Return the number of elements of `T` from `start` to `end`.\n-// Return the arithmetic difference if `T` is zero size.\n-#[inline(always)]\n-unsafe fn ptrdistance<T>(start: *const T, end: *const T) -> usize {\n-    if mem::size_of::<T>() == 0 {\n-        (end as usize).wrapping_sub(start as usize)\n-    } else {\n-        end.offset_from(start) as usize\n-    }\n-}\n-\n-// Extension methods for raw pointers, used by the iterators\n-trait PointerExt : Copy {\n-    unsafe fn slice_offset(self, i: isize) -> Self;\n-\n-    /// Increments `self` by 1, but returns the old value.\n-    #[inline(always)]\n-    unsafe fn post_inc(&mut self) -> Self {\n-        let current = *self;\n-        *self = self.slice_offset(1);\n-        current\n-    }\n-\n-    /// Decrements `self` by 1, and returns the new value.\n-    #[inline(always)]\n-    unsafe fn pre_dec(&mut self) -> Self {\n-        *self = self.slice_offset(-1);\n-        *self\n-    }\n-}\n-\n-impl<T> PointerExt for *const T {\n-    #[inline(always)]\n-    unsafe fn slice_offset(self, i: isize) -> Self {\n-        slice_offset!(self, i)\n-    }\n-}\n-\n-impl<T> PointerExt for *mut T {\n-    #[inline(always)]\n-    unsafe fn slice_offset(self, i: isize) -> Self {\n-        slice_offset!(self, i)\n-    }\n-}\n+iterator!{struct IterMut -> *mut T, &'a mut T, mut, mut}\n \n /// An internal abstraction over the splitting iterators, so that\n /// splitn, splitn_mut etc can be implemented once.\n@@ -3927,12 +3867,11 @@ unsafe impl<'a, T> TrustedRandomAccess for ExactChunksMut<'a, T> {\n /// ```\n /// use std::slice;\n ///\n-/// // manifest a slice out of thin air!\n-/// let ptr = 0x1234 as *const usize;\n-/// let amt = 10;\n-/// unsafe {\n-///     let slice = slice::from_raw_parts(ptr, amt);\n-/// }\n+/// // manifest a slice for a single element\n+/// let x = 42;\n+/// let ptr = &x as *const _;\n+/// let slice = unsafe { slice::from_raw_parts(ptr, 1) };\n+/// assert_eq!(slice[0], 42);\n /// ```\n ///\n /// [`NonNull::dangling()`]: ../../std/ptr/struct.NonNull.html#method.dangling"}, {"sha": "7968521f7b461ee841d5747a524cf2777c67413b", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/1d9405fb6caa5eac18e5a28685e4f30dcbde6d45/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9405fb6caa5eac18e5a28685e4f30dcbde6d45/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=1d9405fb6caa5eac18e5a28685e4f30dcbde6d45", "patch": "@@ -390,6 +390,132 @@ fn test_windows_zip() {\n     assert_eq!(res, [14, 18, 22, 26]);\n }\n \n+#[test]\n+#[allow(const_err)]\n+fn test_iter_ref_consistency() {\n+    use std::fmt::Debug;\n+\n+    fn test<T : Copy + Debug + PartialEq>(x : T) {\n+        let v : &[T] = &[x, x, x];\n+        let v_ptrs : [*const T; 3] = match v {\n+            [ref v1, ref v2, ref v3] => [v1 as *const _, v2 as *const _, v3 as *const _],\n+            _ => unreachable!()\n+        };\n+        let len = v.len();\n+\n+        // nth(i)\n+        for i in 0..len {\n+            assert_eq!(&v[i] as *const _, v_ptrs[i]); // check the v_ptrs array, just to be sure\n+            let nth = v.iter().nth(i).unwrap();\n+            assert_eq!(nth as *const _, v_ptrs[i]);\n+        }\n+        assert_eq!(v.iter().nth(len), None, \"nth(len) should return None\");\n+\n+        // stepping through with nth(0)\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len {\n+                let next = it.nth(0).unwrap();\n+                assert_eq!(next as *const _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.nth(0), None);\n+        }\n+\n+        // next()\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let next = it.next().unwrap();\n+                assert_eq!(next as *const _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next(), None, \"The final call to next() should return None\");\n+        }\n+\n+        // next_back()\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let prev = it.next_back().unwrap();\n+                assert_eq!(prev as *const _, v_ptrs[remaining-1]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n+        }\n+    }\n+\n+    fn test_mut<T : Copy + Debug + PartialEq>(x : T) {\n+        let v : &mut [T] = &mut [x, x, x];\n+        let v_ptrs : [*mut T; 3] = match v {\n+            [ref v1, ref v2, ref v3] =>\n+              [v1 as *const _ as *mut _, v2 as *const _ as *mut _, v3 as *const _ as *mut _],\n+            _ => unreachable!()\n+        };\n+        let len = v.len();\n+\n+        // nth(i)\n+        for i in 0..len {\n+            assert_eq!(&mut v[i] as *mut _, v_ptrs[i]); // check the v_ptrs array, just to be sure\n+            let nth = v.iter_mut().nth(i).unwrap();\n+            assert_eq!(nth as *mut _, v_ptrs[i]);\n+        }\n+        assert_eq!(v.iter().nth(len), None, \"nth(len) should return None\");\n+\n+        // stepping through with nth(0)\n+        {\n+            let mut it = v.iter();\n+            for i in 0..len {\n+                let next = it.nth(0).unwrap();\n+                assert_eq!(next as *const _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.nth(0), None);\n+        }\n+\n+        // next()\n+        {\n+            let mut it = v.iter_mut();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let next = it.next().unwrap();\n+                assert_eq!(next as *mut _, v_ptrs[i]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next(), None, \"The final call to next() should return None\");\n+        }\n+\n+        // next_back()\n+        {\n+            let mut it = v.iter_mut();\n+            for i in 0..len {\n+                let remaining = len - i;\n+                assert_eq!(it.size_hint(), (remaining, Some(remaining)));\n+\n+                let prev = it.next_back().unwrap();\n+                assert_eq!(prev as *mut _, v_ptrs[remaining-1]);\n+            }\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert_eq!(it.next_back(), None, \"The final call to next_back() should return None\");\n+        }\n+    }\n+\n+    // Make sure iterators and slice patterns yield consistent addresses for various types,\n+    // including ZSTs.\n+    test(0u32);\n+    test(());\n+    test([0u32; 0]); // ZST with alignment > 0\n+    test_mut(0u32);\n+    test_mut(());\n+    test_mut([0u32; 0]); // ZST with alignment > 0\n+}\n+\n // The current implementation of SliceIndex fails to handle methods\n // orthogonally from range types; therefore, it is worth testing\n // all of the indexing operations on each input."}]}