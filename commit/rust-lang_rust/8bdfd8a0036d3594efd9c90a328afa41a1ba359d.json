{"sha": "8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZGZkOGEwMDM2ZDM1OTRlZmQ5YzkwYTMyOGFmYTQxYTFiYTM1OWQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-31T18:37:38Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-01T20:27:48Z"}, "message": "rustc: rename CodeExtent to Scope and RegionMaps to ScopeTree.", "tree": {"sha": "dad9d89248dfae3927b2dff4884f13281b3046e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dad9d89248dfae3927b2dff4884f13281b3046e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "html_url": "https://github.com/rust-lang/rust/commit/8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f861b6ee46465097eec266c160ac53e230df7cf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f861b6ee46465097eec266c160ac53e230df7cf0", "html_url": "https://github.com/rust-lang/rust/commit/f861b6ee46465097eec266c160ac53e230df7cf0"}], "stats": {"total": 1332, "additions": 673, "deletions": 659}, "files": [{"sha": "ff2c36416bfd208aaa10a830e5cc38e57120619b", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -10,7 +10,7 @@\n \n use rustc_data_structures::graph;\n use cfg::*;\n-use middle::region::CodeExtent;\n+use middle::region;\n use ty::{self, TyCtxt};\n use syntax::ptr::P;\n \n@@ -579,14 +579,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn add_exiting_edge(&mut self,\n                         from_expr: &hir::Expr,\n                         from_index: CFGIndex,\n-                        target_scope: CodeExtent,\n+                        target_scope: region::Scope,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n-        let mut scope = CodeExtent::Misc(from_expr.hir_id.local_id);\n-        let region_maps = self.tcx.region_maps(self.owner_def_id);\n+        let mut scope = region::Scope::Node(from_expr.hir_id.local_id);\n+        let region_scope_tree = self.tcx.region_scope_tree(self.owner_def_id);\n         while scope != target_scope {\n             data.exiting_scopes.push(scope.item_local_id());\n-            scope = region_maps.encl_scope(scope);\n+            scope = region_scope_tree.encl_scope(scope);\n         }\n         self.graph.add_edge(from_index, to_index, data);\n     }\n@@ -606,14 +606,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn find_scope_edge(&self,\n                   expr: &hir::Expr,\n                   destination: hir::Destination,\n-                  scope_cf_kind: ScopeCfKind) -> (CodeExtent, CFGIndex) {\n+                  scope_cf_kind: ScopeCfKind) -> (region::Scope, CFGIndex) {\n \n         match destination.target_id {\n             hir::ScopeTarget::Block(block_expr_id) => {\n                 for b in &self.breakable_block_scopes {\n                     if b.block_expr_id == self.tcx.hir.node_to_hir_id(block_expr_id).local_id {\n                         let scope_id = self.tcx.hir.node_to_hir_id(block_expr_id).local_id;\n-                        return (CodeExtent::Misc(scope_id), match scope_cf_kind {\n+                        return (region::Scope::Node(scope_id), match scope_cf_kind {\n                             ScopeCfKind::Break => b.break_index,\n                             ScopeCfKind::Continue => bug!(\"can't continue to block\"),\n                         });\n@@ -625,7 +625,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 for l in &self.loop_scopes {\n                     if l.loop_id == self.tcx.hir.node_to_hir_id(loop_id).local_id {\n                         let scope_id = self.tcx.hir.node_to_hir_id(loop_id).local_id;\n-                        return (CodeExtent::Misc(scope_id), match scope_cf_kind {\n+                        return (region::Scope::Node(scope_id), match scope_cf_kind {\n                             ScopeCfKind::Break => l.break_index,\n                             ScopeCfKind::Continue => l.continue_index,\n                         });"}, {"sha": "c438944cf013117c4342857334174c968c77cc88", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -395,7 +395,7 @@ define_dep_nodes!( <'tcx>\n     [] WorkProduct(WorkProductId),\n \n     // Represents different phases in the compiler.\n-    [] RegionMaps(DefId),\n+    [] RegionScopeTree(DefId),\n     [] Coherence,\n     [] CoherenceInherentImplOverlapCheck,\n     [] Resolve,"}, {"sha": "9a061da177ebad8d3b1ab624e3b1e065dc66df0c", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -239,8 +239,8 @@ for mir::StatementKind<'gcx> {\n             mir::StatementKind::StorageDead(ref lvalue) => {\n                 lvalue.hash_stable(hcx, hasher);\n             }\n-            mir::StatementKind::EndRegion(ref extent) => {\n-                extent.hash_stable(hcx, hasher);\n+            mir::StatementKind::EndRegion(ref region_scope) => {\n+                region_scope.hash_stable(hcx, hasher);\n             }\n             mir::StatementKind::Validate(ref op, ref lvalues) => {\n                 op.hash_stable(hcx, hasher);\n@@ -271,7 +271,7 @@ impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n     }\n }\n \n-impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(extent) });\n+impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(region_scope) });\n \n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Lvalue<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "077905b3ac0ae740bc785fc2f47343a8ff3ab6e8", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -17,6 +17,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n use std::hash as std_hash;\n use std::mem;\n use syntax_pos::symbol::InternedString;\n+use middle::region;\n use ty;\n \n impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n@@ -65,8 +66,8 @@ for ty::RegionKind {\n                 index.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n-            ty::ReScope(code_extent) => {\n-                code_extent.hash_stable(hcx, hasher);\n+            ty::ReScope(scope) => {\n+                scope.hash_stable(hcx, hasher);\n             }\n             ty::ReFree(ref free_region) => {\n                 free_region.hash_stable(hcx, hasher);\n@@ -450,24 +451,22 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n });\n \n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n-for ::middle::region::CodeExtent\n+for region::Scope\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        use middle::region::CodeExtent;\n-\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            CodeExtent::Misc(node_id) |\n-            CodeExtent::DestructionScope(node_id) => {\n+            region::Scope::Node(node_id) |\n+            region::Scope::Destruction(node_id) => {\n                 node_id.hash_stable(hcx, hasher);\n             }\n-            CodeExtent::CallSiteScope(body_id) |\n-            CodeExtent::ParameterScope(body_id) => {\n+            region::Scope::CallSite(body_id) |\n+            region::Scope::Arguments(body_id) => {\n                 body_id.hash_stable(hcx, hasher);\n             }\n-            CodeExtent::Remainder(block_remainder) => {\n+            region::Scope::Remainder(block_remainder) => {\n                 block_remainder.hash_stable(hcx, hasher);\n             }\n         }"}, {"sha": "476bf94714268940f9163cdd3d27a1c0a170ec5c", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -64,7 +64,7 @@ use std::fmt;\n use hir;\n use hir::map as hir_map;\n use hir::def_id::DefId;\n-use middle::region::{self, RegionMaps};\n+use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, Region, TyCtxt, TypeFoldable};\n use ty::error::TypeError;\n@@ -83,7 +83,7 @@ mod anon_anon_conflict;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n-                                   region_maps: &RegionMaps,\n+                                   region_scope_tree: &region::ScopeTree,\n                                    err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n                                    region: ty::Region<'tcx>,\n@@ -131,8 +131,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n                             prefix, scope, suffix)\n                 };\n-                let span = scope.span(self, region_maps);\n-                let tag = match self.hir.find(scope.node_id(self, region_maps)) {\n+                let span = scope.span(self, region_scope_tree);\n+                let tag = match self.hir.find(scope.node_id(self, region_scope_tree)) {\n                     Some(hir_map::NodeBlock(_)) => \"block\",\n                     Some(hir_map::NodeExpr(expr)) => match expr.node {\n                         hir::ExprCall(..) => \"call\",\n@@ -153,18 +153,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 };\n                 let scope_decorated_tag = match scope {\n-                    region::CodeExtent::Misc(_) => tag,\n-                    region::CodeExtent::CallSiteScope(_) => {\n+                    region::Scope::Node(_) => tag,\n+                    region::Scope::CallSite(_) => {\n                         \"scope of call-site for function\"\n                     }\n-                    region::CodeExtent::ParameterScope(_) => {\n+                    region::Scope::Arguments(_) => {\n                         \"scope of function body\"\n                     }\n-                    region::CodeExtent::DestructionScope(_) => {\n+                    region::Scope::Destruction(_) => {\n                         new_string = format!(\"destruction scope surrounding {}\", tag);\n                         &new_string[..]\n                     }\n-                    region::CodeExtent::Remainder(r) => {\n+                    region::Scope::Remainder(r) => {\n                         new_string = format!(\"block suffix following statement {}\",\n                                              r.first_statement_index);\n                         &new_string[..]\n@@ -256,7 +256,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_region_errors(&self,\n-                                region_maps: &RegionMaps,\n+                                region_scope_tree: &region::ScopeTree,\n                                 errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n@@ -281,15 +281,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                   // the error. If all of these fails, we fall back to a rather\n                   // general bit of code that displays the error information\n                   ConcreteFailure(origin, sub, sup) => {\n-                      self.report_concrete_failure(region_maps, origin, sub, sup).emit();\n+                      self.report_concrete_failure(region_scope_tree, origin, sub, sup).emit();\n                   }\n \n                   GenericBoundFailure(kind, param_ty, sub) => {\n-                      self.report_generic_bound_failure(region_maps, kind, param_ty, sub);\n+                      self.report_generic_bound_failure(region_scope_tree, kind, param_ty, sub);\n                   }\n \n                   SubSupConflict(var_origin, sub_origin, sub_r, sup_origin, sup_r) => {\n-                        self.report_sub_sup_conflict(region_maps,\n+                        self.report_sub_sup_conflict(region_scope_tree,\n                                                      var_origin,\n                                                      sub_origin,\n                                                      sub_r,\n@@ -769,7 +769,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_generic_bound_failure(&self,\n-                                    region_maps: &RegionMaps,\n+                                    region_scope_tree: &region::ScopeTree,\n                                     origin: SubregionOrigin<'tcx>,\n                                     bound_kind: GenericKind<'tcx>,\n                                     sub: Region<'tcx>)\n@@ -837,7 +837,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.help(&format!(\"consider adding an explicit lifetime bound for `{}`\",\n                                   bound_kind));\n                 self.tcx.note_and_explain_region(\n-                    region_maps,\n+                    region_scope_tree,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n@@ -851,22 +851,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_sub_sup_conflict(&self,\n-                               region_maps: &RegionMaps,\n+                               region_scope_tree: &region::ScopeTree,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin<'tcx>,\n                                sub_region: Region<'tcx>,\n                                sup_origin: SubregionOrigin<'tcx>,\n                                sup_region: Region<'tcx>) {\n         let mut err = self.report_inference_failure(var_origin);\n \n-        self.tcx.note_and_explain_region(region_maps, &mut err,\n+        self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n             \"...\");\n \n         self.note_region_origin(&mut err, &sup_origin);\n \n-        self.tcx.note_and_explain_region(region_maps, &mut err,\n+        self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n             \"but, the lifetime must be valid for \",\n             sub_region,\n             \"...\");"}, {"sha": "68e8ccbc3d886695ff3ecc94f51fef9d4e7a0eaf", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use infer::{self, InferCtxt, SubregionOrigin};\n-use middle::region::RegionMaps;\n+use middle::region;\n use ty::{self, Region};\n use ty::error::TypeError;\n use errors::DiagnosticBuilder;\n@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub(super) fn report_concrete_failure(&self,\n-                                          region_maps: &RegionMaps,\n+                                          region_scope_tree: &region::ScopeTree,\n                                           origin: SubregionOrigin<'tcx>,\n                                           sub: Region<'tcx>,\n                                           sup: Region<'tcx>)\n@@ -154,8 +154,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::Subtype(trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 let mut err = self.report_and_explain_type_error(trace, &terr);\n-                self.tcx.note_and_explain_region(region_maps, &mut err, \"\", sup, \"...\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err, \"\", sup, \"...\");\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"...does not necessarily outlive \", sub, \"\");\n                 err\n             }\n@@ -165,11 +165,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0312,\n                                                \"lifetime of reference outlives lifetime of \\\n                                                 borrowed content...\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"...the reference is valid for \",\n                                                  sub,\n                                                  \"...\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"...but the borrowed content is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -183,12 +183,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                 of captured variable `{}`...\",\n                                                self.tcx\n                                                    .local_var_name_str_def_index(upvar_id.var_id));\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"...the borrowed pointer is valid for \",\n                                                  sub,\n                                                  \"...\");\n                 self.tcx.note_and_explain_region(\n-                    region_maps,\n+                    region_scope_tree,\n                     &mut err,\n                     &format!(\"...but `{}` is only valid for \",\n                         self.tcx.local_var_name_str_def_index(upvar_id.var_id)),\n@@ -199,11 +199,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::InfStackClosure(span) => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0314, \"closure outlives stack frame\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"...the closure must be valid for \",\n                                                  sub,\n                                                  \"...\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"...but the closure's stack frame is only valid \\\n                                                   for \",\n                                                  sup,\n@@ -215,7 +215,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                span,\n                                                E0315,\n                                                \"cannot invoke closure outside of its lifetime\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"the closure is only valid for \", sup, \"\");\n                 err\n             }\n@@ -224,7 +224,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                span,\n                                                E0473,\n                                                \"dereference of reference outside its lifetime\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"the reference is only valid for \", sup, \"\");\n                 err\n             }\n@@ -235,9 +235,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"captured variable `{}` does not outlive the \\\n                                                 enclosing closure\",\n                                                self.tcx.local_var_name_str(id));\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"captured variable is valid for \", sup, \"\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"closure is valid for \", sub, \"\");\n                 err\n             }\n@@ -246,7 +246,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                span,\n                                                E0475,\n                                                \"index of slice outside its lifetime\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"the slice is only valid for \", sup, \"\");\n                 err\n             }\n@@ -256,9 +256,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0476,\n                                                \"lifetime of the source pointer does not outlive \\\n                                                 lifetime bound of the object type\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"object type is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"source pointer is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -273,11 +273,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                self.ty_to_string(ty));\n                 match *sub {\n                     ty::ReStatic => {\n-                        self.tcx.note_and_explain_region(region_maps, &mut err,\n+                        self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                             \"type must satisfy \", sub, \"\")\n                     }\n                     _ => {\n-                        self.tcx.note_and_explain_region(region_maps, &mut err,\n+                        self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                             \"type must outlive \", sub, \"\")\n                     }\n                 }\n@@ -286,11 +286,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::RelateRegionParamBound(span) => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"lifetime parameter instantiated with \",\n                                                  sup,\n                                                  \"\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"but lifetime parameter must outlive \",\n                                                  sub,\n                                                  \"\");\n@@ -303,7 +303,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"the type `{}` (provided as the value of a type \\\n                                                 parameter) is not valid at this point\",\n                                                self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"type must outlive \", sub, \"\");\n                 err\n             }\n@@ -313,7 +313,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0480,\n                                                \"lifetime of method receiver does not outlive the \\\n                                                 method call\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                 \"the receiver is only valid for \", sup, \"\");\n                 err\n             }\n@@ -323,7 +323,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0481,\n                                                \"lifetime of function argument does not outlive \\\n                                                 the function call\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"the function argument is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -335,7 +335,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0482,\n                                                \"lifetime of return value does not outlive the \\\n                                                 function call\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"the return value is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -347,7 +347,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0483,\n                                                \"lifetime of operand does not outlive the \\\n                                                 operation\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"the operand is only valid for \", sup, \"\");\n                 err\n             }\n@@ -356,7 +356,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                span,\n                                                E0484,\n                                                \"reference is not valid at the time of borrow\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"the borrow is only valid for \", sup, \"\");\n                 err\n             }\n@@ -366,7 +366,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0485,\n                                                \"automatically reference is not valid at the time \\\n                                                 of borrow\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"the automatic borrow is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -379,7 +379,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"type of expression contains references that are \\\n                                                 not valid during the expression: `{}`\",\n                                                self.ty_to_string(t));\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"type is only valid for \", sup, \"\");\n                 err\n             }\n@@ -390,8 +390,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"unsafe use of destructor: destructor might be \\\n                                                 called while references are dead\");\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                self.tcx.note_and_explain_region(region_maps, &mut err, \"superregion: \", sup, \"\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err, \"subregion: \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n+                    \"superregion: \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n+                    \"subregion: \", sub, \"\");\n                 err\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n@@ -400,7 +402,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0488,\n                                                \"lifetime of variable does not enclose its \\\n                                                 declaration\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"the variable is only valid for \", sup, \"\");\n                 err\n             }\n@@ -409,7 +411,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                span,\n                                                E0489,\n                                                \"type/lifetime parameter not in scope here\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"the parameter is only valid for \", sub, \"\");\n                 err\n             }\n@@ -419,9 +421,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0490,\n                                                \"a value of type `{}` is borrowed for too long\",\n                                                self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"the type is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"but the borrow lasts for \", sup, \"\");\n                 err\n             }\n@@ -432,9 +434,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"in type `{}`, reference has a longer lifetime \\\n                                                 than the data it references\",\n                                                self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"the pointer is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                                                  \"but the referenced data is only valid for \",\n                                                  sup,\n                                                  \"\");"}, {"sha": "e85e8e2bdb8c9c287613a2259f24dd807f2fc4c9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -20,7 +20,7 @@ pub use self::region_inference::{GenericKind, VerifyBound};\n \n use hir::def_id::DefId;\n use middle::free_region::{FreeRegionMap, RegionRelations};\n-use middle::region::RegionMaps;\n+use middle::region;\n use middle::lang_items;\n use mir::tcx::LvalueTy;\n use ty::subst::{Kind, Subst, Substs};\n@@ -1070,7 +1070,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn resolve_regions_and_report_errors(&self,\n                                              region_context: DefId,\n-                                             region_map: &RegionMaps,\n+                                             region_map: &region::ScopeTree,\n                                              free_regions: &FreeRegionMap<'tcx>) {\n         let region_rels = RegionRelations::new(self.tcx,\n                                                region_context,"}, {"sha": "5cf6aa350bdd547b83d03ae2d3d0d9bb547510e8", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -21,7 +21,7 @@ use graphviz as dot;\n use hir::def_id::DefIndex;\n use ty;\n use middle::free_region::RegionRelations;\n-use middle::region::CodeExtent;\n+use middle::region;\n use super::Constraint;\n use infer::SubregionOrigin;\n use infer::region_inference::RegionVarBindings;\n@@ -136,7 +136,7 @@ enum Node {\n #[derive(Clone, PartialEq, Eq, Debug, Copy)]\n enum Edge<'tcx> {\n     Constraint(Constraint<'tcx>),\n-    EnclScope(CodeExtent, CodeExtent),\n+    EnclScope(region::Scope, region::Scope),\n }\n \n impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n@@ -159,7 +159,7 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n                 add_node(n2);\n             }\n \n-            region_rels.region_maps.each_encl_scope(|sub, sup| {\n+            region_rels.region_scope_tree.each_encl_scope(|sub, sup| {\n                 add_node(Node::Region(ty::ReScope(sub)));\n                 add_node(Node::Region(ty::ReScope(sup)));\n             });\n@@ -245,7 +245,9 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     fn edges(&self) -> dot::Edges<Edge<'tcx>> {\n         debug!(\"constraint graph has {} edges\", self.map.len());\n         let mut v: Vec<_> = self.map.keys().map(|e| Edge::Constraint(*e)).collect();\n-        self.region_rels.region_maps.each_encl_scope(|sub, sup| v.push(Edge::EnclScope(sub, sup)));\n+        self.region_rels.region_scope_tree.each_encl_scope(|sub, sup| {\n+            v.push(Edge::EnclScope(sub, sup))\n+        });\n         debug!(\"region graph has {} edges\", v.len());\n         Cow::Owned(v)\n     }"}, {"sha": "8351be490767ae100e44bfd40dc5465a9a435e58", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -935,14 +935,14 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 // reasonably compare free regions and scopes:\n                 let fr_scope = match (a, b) {\n                     (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n-                        region_rels.region_maps.early_free_extent(self.tcx, br)\n+                        region_rels.region_scope_tree.early_free_scope(self.tcx, br)\n                     }\n                     (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n-                        region_rels.region_maps.free_extent(self.tcx, fr)\n+                        region_rels.region_scope_tree.free_scope(self.tcx, fr)\n                     }\n                     _ => bug!()\n                 };\n-                let r_id = region_rels.region_maps.nearest_common_ancestor(fr_scope, s_id);\n+                let r_id = region_rels.region_scope_tree.nearest_common_ancestor(fr_scope, s_id);\n                 if r_id == fr_scope {\n                     // if the free region's scope `fr.scope` is bigger than\n                     // the scope region `s_id`, then the LUB is the free\n@@ -963,7 +963,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 // The region corresponding to an outer block is a\n                 // subtype of the region corresponding to an inner\n                 // block.\n-                let lub = region_rels.region_maps.nearest_common_ancestor(a_id, b_id);\n+                let lub = region_rels.region_scope_tree.nearest_common_ancestor(a_id, b_id);\n                 self.tcx.mk_region(ReScope(lub))\n             }\n "}, {"sha": "374b02125a1d0f2f7739ff84fef5a9e6035896d8", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -23,7 +23,7 @@ use hir::def::Def;\n use hir::def_id::{DefId};\n use infer::InferCtxt;\n use middle::mem_categorization as mc;\n-use middle::region::{CodeExtent, RegionMaps};\n+use middle::region;\n use ty::{self, TyCtxt, adjustment};\n \n use hir::{self, PatKind};\n@@ -265,12 +265,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                param_env: ty::ParamEnv<'tcx>,\n-               region_maps: &'a RegionMaps,\n+               region_scope_tree: &'a region::ScopeTree,\n                tables: &'a ty::TypeckTables<'tcx>)\n                -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::new(tcx, region_maps, tables),\n+            mc: mc::MemCategorizationContext::new(tcx, region_scope_tree, tables),\n             delegate,\n             param_env,\n         }\n@@ -281,12 +281,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn with_infer(delegate: &'a mut (Delegate<'tcx>+'a),\n                       infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n                       param_env: ty::ParamEnv<'tcx>,\n-                      region_maps: &'a RegionMaps,\n+                      region_scope_tree: &'a region::ScopeTree,\n                       tables: &'a ty::TypeckTables<'tcx>)\n                       -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::with_infer(infcx, region_maps, tables),\n+            mc: mc::MemCategorizationContext::with_infer(infcx, region_scope_tree, tables),\n             delegate,\n             param_env,\n         }\n@@ -299,7 +299,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             let arg_ty = return_if_err!(self.mc.node_ty(arg.pat.hir_id));\n \n             let fn_body_scope_r =\n-                self.tcx().mk_region(ty::ReScope(CodeExtent::Misc(body.value.hir_id.local_id)));\n+                self.tcx().mk_region(ty::ReScope(region::Scope::Node(body.value.hir_id.local_id)));\n             let arg_cmt = self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n@@ -543,7 +543,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             ty::TyError => { }\n             _ => {\n                 let def_id = self.mc.tables.type_dependent_defs()[call.hir_id].def_id();\n-                let call_scope = CodeExtent::Misc(call.hir_id.local_id);\n+                let call_scope = region::Scope::Node(call.hir_id.local_id);\n                 match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                     FnMutOverloadedCall => {\n                         let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n@@ -751,7 +751,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // Converting from a &T to *T (or &mut T to *mut T) is\n                 // treated as borrowing it for the enclosing temporary\n                 // scope.\n-                let r = self.tcx().mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n+                let r = self.tcx().mk_region(ty::ReScope(\n+                    region::Scope::Node(expr.hir_id.local_id)));\n \n                 self.delegate.borrow(expr.id,\n                                      expr.span,"}, {"sha": "d4cee25bb8fa299eca70ef2aa3b0069b28a4540b", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -16,11 +16,11 @@\n //! region outlives another and so forth.\n \n use hir::def_id::DefId;\n-use middle::region::RegionMaps;\n+use middle::region;\n use ty::{self, Lift, TyCtxt, Region};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n-/// Combines a `RegionMaps` (which governs relationships between\n+/// Combines a `region::ScopeTree` (which governs relationships between\n /// scopes) and a `FreeRegionMap` (which governs relationships between\n /// free regions) to yield a complete relation between concrete\n /// regions.\n@@ -34,7 +34,7 @@ pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub context: DefId,\n \n     /// region maps for the given context\n-    pub region_maps: &'a RegionMaps,\n+    pub region_scope_tree: &'a region::ScopeTree,\n \n     /// free-region relationships\n     pub free_regions: &'a FreeRegionMap<'tcx>,\n@@ -44,13 +44,13 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n     pub fn new(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         context: DefId,\n-        region_maps: &'a RegionMaps,\n+        region_scope_tree: &'a region::ScopeTree,\n         free_regions: &'a FreeRegionMap<'tcx>,\n     ) -> Self {\n         Self {\n             tcx,\n             context,\n-            region_maps,\n+            region_scope_tree,\n             free_regions,\n         }\n     }\n@@ -68,16 +68,16 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n                     true,\n \n                 (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n-                    self.region_maps.is_subscope_of(sub_scope, super_scope),\n+                    self.region_scope_tree.is_subscope_of(sub_scope, super_scope),\n \n                 (&ty::ReScope(sub_scope), &ty::ReEarlyBound(ref br)) => {\n-                    let fr_scope = self.region_maps.early_free_extent(self.tcx, br);\n-                    self.region_maps.is_subscope_of(sub_scope, fr_scope)\n+                    let fr_scope = self.region_scope_tree.early_free_scope(self.tcx, br);\n+                    self.region_scope_tree.is_subscope_of(sub_scope, fr_scope)\n                 }\n \n                 (&ty::ReScope(sub_scope), &ty::ReFree(ref fr)) => {\n-                    let fr_scope = self.region_maps.free_extent(self.tcx, fr);\n-                    self.region_maps.is_subscope_of(sub_scope, fr_scope)\n+                    let fr_scope = self.region_scope_tree.free_scope(self.tcx, fr);\n+                    self.region_scope_tree.is_subscope_of(sub_scope, fr_scope)\n                 }\n \n                 (&ty::ReEarlyBound(_), &ty::ReEarlyBound(_)) |"}, {"sha": "0b0fbad9fc39c2e8915a2716ca4f772237474670", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -69,7 +69,7 @@ pub use self::Note::*;\n \n use self::Aliasability::*;\n \n-use middle::region::RegionMaps;\n+use middle::region;\n use hir::def_id::{DefId, DefIndex};\n use hir::map as hir_map;\n use infer::InferCtxt;\n@@ -283,7 +283,7 @@ impl ast_node for hir::Pat {\n #[derive(Clone)]\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    pub region_maps: &'a RegionMaps,\n+    pub region_scope_tree: &'a region::ScopeTree,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n     infcx: Option<&'a InferCtxt<'a, 'gcx, 'tcx>>,\n }\n@@ -391,21 +391,21 @@ impl MutabilityCategory {\n \n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               region_maps: &'a RegionMaps,\n+               region_scope_tree: &'a region::ScopeTree,\n                tables: &'a ty::TypeckTables<'tcx>)\n                -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n-        MemCategorizationContext { tcx, region_maps, tables, infcx: None }\n+        MemCategorizationContext { tcx, region_scope_tree, tables, infcx: None }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn with_infer(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                      region_maps: &'a RegionMaps,\n+                      region_scope_tree: &'a region::ScopeTree,\n                       tables: &'a ty::TypeckTables<'tcx>)\n                       -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         MemCategorizationContext {\n             tcx: infcx.tcx,\n-            region_maps,\n+            region_scope_tree,\n             tables,\n             infcx: Some(infcx),\n         }\n@@ -862,7 +862,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     /// Returns the lifetime of a temporary created by expr with id `id`.\n     /// This could be `'static` if `id` is part of a constant expression.\n     pub fn temporary_scope(&self, id: hir::ItemLocalId) -> ty::Region<'tcx> {\n-        let scope = self.region_maps.temporary_scope(id);\n+        let scope = self.region_scope_tree.temporary_scope(id);\n         self.tcx.mk_region(match scope {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic"}, {"sha": "ae9866edc53b28842c9b8256b861fd44c6e689bb", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 151, "deletions": 154, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! This file actually contains two passes related to regions.  The first\n-//! pass builds up the `scope_map`, which describes the parent links in\n-//! the region hierarchy.  The second pass infers which types must be\n-//! region parameterized.\n+//! This file builds up the `ScopeTree`, which describes\n+//! the parent links in the region hierarchy.\n //!\n //! Most of the documentation on regions can be found in\n //! `middle/infer/region_inference/README.md`\n@@ -34,24 +32,24 @@ use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n use mir::transform::MirSource;\n \n-/// CodeExtent represents a statically-describable extent that can be\n+/// Scope represents a statically-describable scope that can be\n /// used to bound the lifetime/region for values.\n ///\n-/// `Misc(node_id)`: Any AST node that has any extent at all has the\n-/// `Misc(node_id)` extent. Other variants represent special cases not\n+/// `Node(node_id)`: Any AST node that has any scope at all has the\n+/// `Node(node_id)` scope. Other variants represent special cases not\n /// immediately derivable from the abstract syntax tree structure.\n ///\n-/// `DestructionScope(node_id)` represents the extent of destructors\n+/// `DestructionScope(node_id)` represents the scope of destructors\n /// implicitly-attached to `node_id` that run immediately after the\n /// expression for `node_id` itself. Not every AST node carries a\n /// `DestructionScope`, but those that are `terminating_scopes` do;\n-/// see discussion with `RegionMaps`.\n+/// see discussion with `ScopeTree`.\n ///\n /// `Remainder(BlockRemainder { block, statement_index })` represents\n-/// the extent of user code running immediately after the initializer\n+/// the scope of user code running immediately after the initializer\n /// expression for the indexed statement, until the end of the block.\n ///\n-/// So: the following code can be broken down into the extents beneath:\n+/// So: the following code can be broken down into the scopes beneath:\n /// ```\n /// let a = f().g( 'b: { let x = d(); let y = d(); x.h(y)  }   ) ;\n /// ```\n@@ -69,21 +67,21 @@ use mir::transform::MirSource;\n ///         +--+                                                      (M2.)\n /// +-----------------------------------------------------------+     (M1.)\n ///\n-///  (M1.): Misc extent of the whole `let a = ...;` statement.\n-///  (M2.): Misc extent of the `f()` expression.\n-///  (M3.): Misc extent of the `f().g(..)` expression.\n-///  (M4.): Misc extent of the block labeled `'b:`.\n-///  (M5.): Misc extent of the `let x = d();` statement\n+///  (M1.): Node scope of the whole `let a = ...;` statement.\n+///  (M2.): Node scope of the `f()` expression.\n+///  (M3.): Node scope of the `f().g(..)` expression.\n+///  (M4.): Node scope of the block labeled `'b:`.\n+///  (M5.): Node scope of the `let x = d();` statement\n ///  (D6.): DestructionScope for temporaries created during M5.\n-///  (R7.): Remainder extent for block `'b:`, stmt 0 (let x = ...).\n-///  (M8.): Misc Extent of the `let y = d();` statement.\n+///  (R7.): Remainder scope for block `'b:`, stmt 0 (let x = ...).\n+///  (M8.): Node scope of the `let y = d();` statement.\n ///  (D9.): DestructionScope for temporaries created during M8.\n-/// (R10.): Remainder extent for block `'b:`, stmt 1 (let y = ...).\n+/// (R10.): Remainder scope for block `'b:`, stmt 1 (let y = ...).\n /// (D11.): DestructionScope for temporaries and bindings from block `'b:`.\n /// (D12.): DestructionScope for temporaries created during M1 (e.g. f()).\n ///\n /// Note that while the above picture shows the destruction scopes\n-/// as following their corresponding misc extents, in the internal\n+/// as following their corresponding node scopes, in the internal\n /// data structures of the compiler the destruction scopes are\n /// represented as enclosing parents. This is sound because we use the\n /// enclosing parent relationship just to ensure that referenced\n@@ -96,21 +94,21 @@ use mir::transform::MirSource;\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n-pub enum CodeExtent {\n-    Misc(hir::ItemLocalId),\n+pub enum Scope {\n+    Node(hir::ItemLocalId),\n \n-    // extent of the call-site for a function or closure (outlives\n-    // the parameters as well as the body).\n-    CallSiteScope(hir::ItemLocalId),\n+    // Scope of the call-site for a function or closure\n+    // (outlives the arguments as well as the body).\n+    CallSite(hir::ItemLocalId),\n \n-    // extent of parameters passed to a function or closure (they\n-    // outlive its body)\n-    ParameterScope(hir::ItemLocalId),\n+    // Scope of arguments passed to a function or closure\n+    // (they outlive its body).\n+    Arguments(hir::ItemLocalId),\n \n-    // extent of destructors for temporaries of node-id\n-    DestructionScope(hir::ItemLocalId),\n+    // Scope of destructors for temporaries of node-id.\n+    Destruction(hir::ItemLocalId),\n \n-    // extent of code following a `let id = expr;` binding in a block\n+    // Scope following a `let id = expr;` binding in a block.\n     Remainder(BlockRemainder)\n }\n \n@@ -125,9 +123,9 @@ pub enum CodeExtent {\n /// * the subscope with `first_statement_index == 0` is scope of both\n ///   `a` and `b`; it does not include EXPR_1, but does include\n ///   everything after that first `let`. (If you want a scope that\n-///   includes EXPR_1 as well, then do not use `CodeExtent::Remainder`,\n-///   but instead another `CodeExtent` that encompasses the whole block,\n-///   e.g. `CodeExtent::Misc`.\n+///   includes EXPR_1 as well, then do not use `Scope::Remainder`,\n+///   but instead another `Scope` that encompasses the whole block,\n+///   e.g. `Scope::Node`.\n ///\n /// * the subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n@@ -138,26 +136,26 @@ pub struct BlockRemainder {\n     pub first_statement_index: u32,\n }\n \n-impl CodeExtent {\n+impl Scope {\n     /// Returns a item-local id associated with this scope.\n     ///\n     /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n     pub fn item_local_id(&self) -> hir::ItemLocalId {\n         match *self {\n-            CodeExtent::Misc(id) => id,\n+            Scope::Node(id) => id,\n \n             // These cases all return rough approximations to the\n-            // precise extent denoted by `self`.\n-            CodeExtent::Remainder(br) => br.block,\n-            CodeExtent::DestructionScope(id) |\n-            CodeExtent::CallSiteScope(id) |\n-            CodeExtent::ParameterScope(id) => id,\n+            // precise scope denoted by `self`.\n+            Scope::Remainder(br) => br.block,\n+            Scope::Destruction(id) |\n+            Scope::CallSite(id) |\n+            Scope::Arguments(id) => id,\n         }\n     }\n \n-    pub fn node_id(&self, tcx: TyCtxt, region_maps: &RegionMaps) -> ast::NodeId {\n-        match region_maps.root_body {\n+    pub fn node_id(&self, tcx: TyCtxt, scope_tree: &ScopeTree) -> ast::NodeId {\n+        match scope_tree.root_body {\n             Some(hir_id) => {\n                 tcx.hir.hir_to_node_id(hir::HirId {\n                     owner: hir_id.owner,\n@@ -168,18 +166,18 @@ impl CodeExtent {\n         }\n     }\n \n-    /// Returns the span of this CodeExtent.  Note that in general the\n+    /// Returns the span of this Scope.  Note that in general the\n     /// returned span may not correspond to the span of any node id in\n     /// the AST.\n-    pub fn span(&self, tcx: TyCtxt, region_maps: &RegionMaps) -> Span {\n-        let node_id = self.node_id(tcx, region_maps);\n+    pub fn span(&self, tcx: TyCtxt, scope_tree: &ScopeTree) -> Span {\n+        let node_id = self.node_id(tcx, scope_tree);\n         if node_id == ast::DUMMY_NODE_ID {\n             return DUMMY_SP;\n         }\n         let span = tcx.hir.span(node_id);\n-        if let CodeExtent::Remainder(r) = *self {\n+        if let Scope::Remainder(r) = *self {\n             if let hir::map::NodeBlock(ref blk) = tcx.hir.get(node_id) {\n-                // Want span for extent starting after the\n+                // Want span for scope starting after the\n                 // indexed statement and ending at end of\n                 // `blk`; reuse span of `blk` and shift `lo`\n                 // forward to end of indexed statement.\n@@ -200,9 +198,9 @@ impl CodeExtent {\n     }\n }\n \n-/// The region maps encode information about region relationships.\n+/// The region scope tree encodes information about region relationships.\n #[derive(Default)]\n-pub struct RegionMaps {\n+pub struct ScopeTree {\n     /// If not empty, this body is the root of this region hierarchy.\n     root_body: Option<hir::HirId>,\n \n@@ -211,20 +209,20 @@ pub struct RegionMaps {\n     /// have lifetime parameters free in this body.\n     root_parent: Option<ast::NodeId>,\n \n-    /// `scope_map` maps from a scope id to the enclosing scope id;\n+    /// `parent_map` maps from a scope id to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope id for the block associated with a closure is\n     /// the closure itself.)\n-    scope_map: FxHashMap<CodeExtent, CodeExtent>,\n+    parent_map: FxHashMap<Scope, Scope>,\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n-    var_map: FxHashMap<hir::ItemLocalId, CodeExtent>,\n+    var_map: FxHashMap<hir::ItemLocalId, Scope>,\n \n     /// maps from a node-id to the associated destruction scope (if any)\n-    destruction_scopes: FxHashMap<hir::ItemLocalId, CodeExtent>,\n+    destruction_scopes: FxHashMap<hir::ItemLocalId, Scope>,\n \n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n     /// larger than the default. The map goes from the expression id\n@@ -234,7 +232,7 @@ pub struct RegionMaps {\n     /// block (see `terminating_scopes`).\n     /// In constants, None is used to indicate that certain expressions\n     /// escape into 'static and should have no local cleanup scope.\n-    rvalue_scopes: FxHashMap<hir::ItemLocalId, Option<CodeExtent>>,\n+    rvalue_scopes: FxHashMap<hir::ItemLocalId, Option<Scope>>,\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n@@ -250,7 +248,7 @@ pub struct RegionMaps {\n \n     /// If there are any `yield` nested within a scope, this map\n     /// stores the `Span` of the first one.\n-    yield_in_scope: FxHashMap<CodeExtent, Span>,\n+    yield_in_scope: FxHashMap<Scope, Span>,\n }\n \n #[derive(Debug, Copy, Clone)]\n@@ -264,17 +262,17 @@ pub struct Context {\n     root_id: Option<hir::ItemLocalId>,\n \n     /// the scope that contains any new variables declared\n-    var_parent: Option<CodeExtent>,\n+    var_parent: Option<Scope>,\n \n     /// region parent of expressions etc\n-    parent: Option<CodeExtent>,\n+    parent: Option<Scope>,\n }\n \n struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n-    // Generated maps:\n-    region_maps: RegionMaps,\n+    // Generated scope tree:\n+    scope_tree: ScopeTree,\n \n     cx: Context,\n \n@@ -302,36 +300,34 @@ struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n }\n \n \n-impl<'tcx> RegionMaps {\n-    pub fn record_code_extent(&mut self,\n-                              child: CodeExtent,\n-                              parent: Option<CodeExtent>) {\n+impl<'tcx> ScopeTree {\n+    pub fn record_scope_parent(&mut self, child: Scope, parent: Option<Scope>) {\n         debug!(\"{:?}.parent = {:?}\", child, parent);\n \n         if let Some(p) = parent {\n-            let prev = self.scope_map.insert(child, p);\n+            let prev = self.parent_map.insert(child, p);\n             assert!(prev.is_none());\n         }\n \n         // record the destruction scopes for later so we can query them\n-        if let CodeExtent::DestructionScope(n) = child {\n+        if let Scope::Destruction(n) = child {\n             self.destruction_scopes.insert(n, child);\n         }\n     }\n \n-    pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(CodeExtent, CodeExtent) {\n-        for (&child, &parent) in &self.scope_map {\n+    pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(Scope, Scope) {\n+        for (&child, &parent) in &self.parent_map {\n             e(child, parent)\n         }\n     }\n \n-    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&hir::ItemLocalId, CodeExtent) {\n+    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&hir::ItemLocalId, Scope) {\n         for (child, &parent) in self.var_map.iter() {\n             e(child, parent)\n         }\n     }\n \n-    pub fn opt_destruction_extent(&self, n: hir::ItemLocalId) -> Option<CodeExtent> {\n+    pub fn opt_destruction_scope(&self, n: hir::ItemLocalId) -> Option<Scope> {\n         self.destruction_scopes.get(&n).cloned()\n     }\n \n@@ -360,40 +356,40 @@ impl<'tcx> RegionMaps {\n         }\n     }\n \n-    fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: CodeExtent) {\n+    fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: Scope) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.item_local_id());\n         self.var_map.insert(var, lifetime);\n     }\n \n-    fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<CodeExtent>) {\n+    fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<Scope>) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         if let Some(lifetime) = lifetime {\n             assert!(var != lifetime.item_local_id());\n         }\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n \n-    pub fn opt_encl_scope(&self, id: CodeExtent) -> Option<CodeExtent> {\n+    pub fn opt_encl_scope(&self, id: Scope) -> Option<Scope> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        self.scope_map.get(&id).cloned()\n+        self.parent_map.get(&id).cloned()\n     }\n \n     #[allow(dead_code)] // used in cfg\n-    pub fn encl_scope(&self, id: CodeExtent) -> CodeExtent {\n+    pub fn encl_scope(&self, id: Scope) -> Scope {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         self.opt_encl_scope(id).unwrap()\n     }\n \n     /// Returns the lifetime of the local variable `var_id`\n-    pub fn var_scope(&self, var_id: hir::ItemLocalId) -> CodeExtent {\n+    pub fn var_scope(&self, var_id: hir::ItemLocalId) -> Scope {\n         match self.var_map.get(&var_id) {\n             Some(&r) => r,\n             None => { bug!(\"no enclosing scope for id {:?}\", var_id); }\n         }\n     }\n \n-    pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<CodeExtent> {\n+    pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<Scope> {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n@@ -406,11 +402,11 @@ impl<'tcx> RegionMaps {\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n-        let mut id = CodeExtent::Misc(expr_id);\n+        let mut id = Scope::Node(expr_id);\n \n-        while let Some(&p) = self.scope_map.get(&id) {\n+        while let Some(&p) = self.parent_map.get(&id) {\n             match p {\n-                CodeExtent::DestructionScope(..) => {\n+                Scope::Destruction(..) => {\n                     debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n                            expr_id, id);\n                     return Some(id);\n@@ -431,7 +427,7 @@ impl<'tcx> RegionMaps {\n         scope\n     }\n \n-    pub fn scopes_intersect(&self, scope1: CodeExtent, scope2: CodeExtent)\n+    pub fn scopes_intersect(&self, scope1: Scope, scope2: Scope)\n                             -> bool {\n         self.is_subscope_of(scope1, scope2) ||\n         self.is_subscope_of(scope2, scope1)\n@@ -440,8 +436,8 @@ impl<'tcx> RegionMaps {\n     /// Returns true if `subscope` is equal to or is lexically nested inside `superscope` and false\n     /// otherwise.\n     pub fn is_subscope_of(&self,\n-                          subscope: CodeExtent,\n-                          superscope: CodeExtent)\n+                          subscope: Scope,\n+                          superscope: Scope)\n                           -> bool {\n         let mut s = subscope;\n         debug!(\"is_subscope_of({:?}, {:?})\", subscope, superscope);\n@@ -465,22 +461,22 @@ impl<'tcx> RegionMaps {\n     /// Finds the nearest common ancestor (if any) of two scopes.  That is, finds the smallest\n     /// scope which is greater than or equal to both `scope_a` and `scope_b`.\n     pub fn nearest_common_ancestor(&self,\n-                                   scope_a: CodeExtent,\n-                                   scope_b: CodeExtent)\n-                                   -> CodeExtent {\n+                                   scope_a: Scope,\n+                                   scope_b: Scope)\n+                                   -> Scope {\n         if scope_a == scope_b { return scope_a; }\n \n         // [1] The initial values for `a_buf` and `b_buf` are not used.\n         // The `ancestors_of` function will return some prefix that\n         // is re-initialized with new values (or else fallback to a\n         // heap-allocated vector).\n-        let mut a_buf: [CodeExtent; 32] = [scope_a /* [1] */; 32];\n-        let mut a_vec: Vec<CodeExtent> = vec![];\n-        let mut b_buf: [CodeExtent; 32] = [scope_b /* [1] */; 32];\n-        let mut b_vec: Vec<CodeExtent> = vec![];\n-        let scope_map = &self.scope_map;\n-        let a_ancestors = ancestors_of(scope_map, scope_a, &mut a_buf, &mut a_vec);\n-        let b_ancestors = ancestors_of(scope_map, scope_b, &mut b_buf, &mut b_vec);\n+        let mut a_buf: [Scope; 32] = [scope_a /* [1] */; 32];\n+        let mut a_vec: Vec<Scope> = vec![];\n+        let mut b_buf: [Scope; 32] = [scope_b /* [1] */; 32];\n+        let mut b_vec: Vec<Scope> = vec![];\n+        let parent_map = &self.parent_map;\n+        let a_ancestors = ancestors_of(parent_map, scope_a, &mut a_buf, &mut a_vec);\n+        let b_ancestors = ancestors_of(parent_map, scope_b, &mut b_buf, &mut b_vec);\n         let mut a_index = a_ancestors.len() - 1;\n         let mut b_index = b_ancestors.len() - 1;\n \n@@ -501,8 +497,8 @@ impl<'tcx> RegionMaps {\n             let a_root_scope = a_ancestors[a_index];\n             let b_root_scope = a_ancestors[a_index];\n             return match (a_root_scope, b_root_scope) {\n-                (CodeExtent::DestructionScope(a_root_id),\n-                 CodeExtent::DestructionScope(b_root_id)) => {\n+                (Scope::Destruction(a_root_id),\n+                 Scope::Destruction(b_root_id)) => {\n                     if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n                         // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n                         scope_b\n@@ -515,7 +511,7 @@ impl<'tcx> RegionMaps {\n                     }\n                 }\n                 _ => {\n-                    // root ids are always Misc right now\n+                    // root ids are always Node right now\n                     bug!()\n                 }\n             };\n@@ -533,18 +529,18 @@ impl<'tcx> RegionMaps {\n             }\n         }\n \n-        fn ancestors_of<'a, 'tcx>(scope_map: &FxHashMap<CodeExtent, CodeExtent>,\n-                                  scope: CodeExtent,\n-                                  buf: &'a mut [CodeExtent; 32],\n-                                  vec: &'a mut Vec<CodeExtent>)\n-                                  -> &'a [CodeExtent] {\n+        fn ancestors_of<'a, 'tcx>(parent_map: &FxHashMap<Scope, Scope>,\n+                                  scope: Scope,\n+                                  buf: &'a mut [Scope; 32],\n+                                  vec: &'a mut Vec<Scope>)\n+                                  -> &'a [Scope] {\n             // debug!(\"ancestors_of(scope={:?})\", scope);\n             let mut scope = scope;\n \n             let mut i = 0;\n             while i < 32 {\n                 buf[i] = scope;\n-                match scope_map.get(&scope) {\n+                match parent_map.get(&scope) {\n                     Some(&superscope) => scope = superscope,\n                     _ => return &buf[..i+1]\n                 }\n@@ -555,19 +551,19 @@ impl<'tcx> RegionMaps {\n             vec.extend_from_slice(buf);\n             loop {\n                 vec.push(scope);\n-                match scope_map.get(&scope) {\n+                match parent_map.get(&scope) {\n                     Some(&superscope) => scope = superscope,\n                     _ => return &*vec\n                 }\n             }\n         }\n     }\n \n-    /// Assuming that the provided region was defined within this `RegionMaps`,\n-    /// returns the outermost `CodeExtent` that the region outlives.\n-    pub fn early_free_extent<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    /// Assuming that the provided region was defined within this `ScopeTree`,\n+    /// returns the outermost `Scope` that the region outlives.\n+    pub fn early_free_scope<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                        br: &ty::EarlyBoundRegion)\n-                                       -> CodeExtent {\n+                                       -> Scope {\n         let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n@@ -578,7 +574,8 @@ impl<'tcx> RegionMaps {\n             // which in practice can only mean a trait or an impl, that\n             // is the parent of a method, and that is enforced below.\n             assert_eq!(Some(param_owner_id), self.root_parent,\n-                       \"free_extent: {:?} not recognized by the region maps for {:?} / {:?}\",\n+                       \"free_scope: {:?} not recognized by the \\\n+                        region scope tree for {:?} / {:?}\",\n                        param_owner,\n                        self.root_parent.map(|id| tcx.hir.local_def_id(id)),\n                        self.root_body.map(|hir_id| DefId::local(hir_id.owner)));\n@@ -587,13 +584,13 @@ impl<'tcx> RegionMaps {\n             self.root_body.unwrap().local_id\n         });\n \n-        CodeExtent::CallSiteScope(scope)\n+        Scope::CallSite(scope)\n     }\n \n-    /// Assuming that the provided region was defined within this `RegionMaps`,\n-    /// returns the outermost `CodeExtent` that the region outlives.\n-    pub fn free_extent<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, fr: &ty::FreeRegion)\n-                                 -> CodeExtent {\n+    /// Assuming that the provided region was defined within this `ScopeTree`,\n+    /// returns the outermost `Scope` that the region outlives.\n+    pub fn free_scope<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, fr: &ty::FreeRegion)\n+                                 -> Scope {\n         let param_owner = match fr.bound_region {\n             ty::BoundRegion::BrNamed(def_id, _) => {\n                 tcx.parent_def_id(def_id).unwrap()\n@@ -607,12 +604,12 @@ impl<'tcx> RegionMaps {\n \n         let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n         let body_id = tcx.hir.body_owned_by(param_owner_id);\n-        CodeExtent::CallSiteScope(tcx.hir.body(body_id).value.hir_id.local_id)\n+        Scope::CallSite(tcx.hir.body(body_id).value.hir_id.local_id)\n     }\n \n-    /// Checks whether the given code extent contains a `yield`. If so,\n+    /// Checks whether the given scope contains a `yield`. If so,\n     /// returns `Some(span)` with the span of a yield we found.\n-    pub fn yield_in_scope(&self, scope: CodeExtent) -> Option<Span> {\n+    pub fn yield_in_scope(&self, scope: Scope) -> Option<Span> {\n         self.yield_in_scope.get(&scope).cloned()\n     }\n }\n@@ -628,7 +625,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n             // extern fn isalnum(c: c_int) -> c_int\n         }\n         Some(parent_scope) =>\n-            visitor.region_maps.record_var_scope(var_id, parent_scope),\n+            visitor.scope_tree.record_var_scope(var_id, parent_scope),\n     }\n }\n \n@@ -662,7 +659,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n     // `other_argument()` has run and also the call to `quux(..)`\n     // itself has returned.\n \n-    visitor.enter_node_extent_with_dtor(blk.hir_id.local_id);\n+    visitor.enter_node_scope_with_dtor(blk.hir_id.local_id);\n     visitor.cx.var_parent = visitor.cx.parent;\n \n     {\n@@ -679,8 +676,8 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n                 // has the previous subscope in the block as a parent,\n                 // except for the first such subscope, which has the\n                 // block itself as a parent.\n-                visitor.enter_code_extent(\n-                    CodeExtent::Remainder(BlockRemainder {\n+                visitor.enter_scope(\n+                    Scope::Remainder(BlockRemainder {\n                         block: blk.hir_id.local_id,\n                         first_statement_index: i as u32\n                     })\n@@ -706,7 +703,7 @@ fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &\n }\n \n fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n-    visitor.record_code_extent(CodeExtent::Misc(pat.hir_id.local_id));\n+    visitor.record_child_scope(Scope::Node(pat.hir_id.local_id));\n \n     // If this is a binding then record the lifetime of that binding.\n     if let PatKind::Binding(..) = pat.node {\n@@ -722,13 +719,13 @@ fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt:\n \n     // Every statement will clean up the temporaries created during\n     // execution of that statement. Therefore each statement has an\n-    // associated destruction scope that represents the extent of the\n-    // statement plus its destructors, and thus the extent for which\n+    // associated destruction scope that represents the scope of the\n+    // statement plus its destructors, and thus the scope for which\n     // regions referenced by the destructors need to survive.\n     visitor.terminating_scopes.insert(stmt_id);\n \n     let prev_parent = visitor.cx.parent;\n-    visitor.enter_node_extent_with_dtor(stmt_id);\n+    visitor.enter_node_scope_with_dtor(stmt_id);\n \n     intravisit::walk_stmt(visitor, stmt);\n \n@@ -739,7 +736,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     let prev_cx = visitor.cx;\n-    visitor.enter_node_extent_with_dtor(expr.hir_id.local_id);\n+    visitor.enter_node_scope_with_dtor(expr.hir_id.local_id);\n \n     {\n         let terminating_scopes = &mut visitor.terminating_scopes;\n@@ -806,9 +803,9 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n \n             hir::ExprYield(..) => {\n                 // Mark this expr's scope and all parent scopes as containing `yield`.\n-                let mut scope = CodeExtent::Misc(expr.hir_id.local_id);\n+                let mut scope = Scope::Node(expr.hir_id.local_id);\n                 loop {\n-                    match visitor.region_maps.yield_in_scope.entry(scope) {\n+                    match visitor.scope_tree.yield_in_scope.entry(scope) {\n                         // Another `yield` has already been found.\n                         Entry::Occupied(_) => break,\n \n@@ -818,9 +815,9 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                     }\n \n                     // Keep traversing up while we can.\n-                    match visitor.region_maps.scope_map.get(&scope) {\n+                    match visitor.scope_tree.parent_map.get(&scope) {\n                         // Don't cross from closure bodies to their parent.\n-                        Some(&CodeExtent::CallSiteScope(_)) => break,\n+                        Some(&Scope::CallSite(_)) => break,\n                         Some(&superscope) => scope = superscope,\n                         None => break\n                     }\n@@ -999,7 +996,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     fn record_rvalue_scope_if_borrow_expr<'a, 'tcx>(\n         visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         expr: &hir::Expr,\n-        blk_id: Option<CodeExtent>)\n+        blk_id: Option<Scope>)\n     {\n         match expr.node {\n             hir::ExprAddrOf(_, ref subexpr) => {\n@@ -1049,15 +1046,15 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     /// Note: ET is intended to match \"rvalues or lvalues based on rvalues\".\n     fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                                      expr: &hir::Expr,\n-                                     blk_scope: Option<CodeExtent>) {\n+                                     blk_scope: Option<Scope>) {\n         let mut expr = expr;\n         loop {\n             // Note: give all the expressions matching `ET` with the\n             // extended temporary lifetime, not just the innermost rvalue,\n             // because in trans if we must compile e.g. `*rvalue()`\n             // into a temporary, we request the temporary scope of the\n             // outer expression.\n-            visitor.region_maps.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n+            visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n \n             match expr.node {\n                 hir::ExprAddrOf(_, ref subexpr) |\n@@ -1077,27 +1074,27 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n \n impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n     /// Records the current parent (if any) as the parent of `child_scope`.\n-    fn record_code_extent(&mut self, child_scope: CodeExtent) {\n+    fn record_child_scope(&mut self, child_scope: Scope) {\n         let parent = self.cx.parent;\n-        self.region_maps.record_code_extent(child_scope, parent);\n+        self.scope_tree.record_scope_parent(child_scope, parent);\n     }\n \n     /// Records the current parent (if any) as the parent of `child_scope`,\n     /// and sets `child_scope` as the new current parent.\n-    fn enter_code_extent(&mut self, child_scope: CodeExtent) {\n-        self.record_code_extent(child_scope);\n+    fn enter_scope(&mut self, child_scope: Scope) {\n+        self.record_child_scope(child_scope);\n         self.cx.parent = Some(child_scope);\n     }\n \n-    fn enter_node_extent_with_dtor(&mut self, id: hir::ItemLocalId) {\n+    fn enter_node_scope_with_dtor(&mut self, id: hir::ItemLocalId) {\n         // If node was previously marked as a terminating scope during the\n         // recursive visit of its parent node in the AST, then we need to\n-        // account for the destruction scope representing the extent of\n+        // account for the destruction scope representing the scope of\n         // the destructors that run immediately after it completes.\n         if self.terminating_scopes.contains(&id) {\n-            self.enter_code_extent(CodeExtent::DestructionScope(id));\n+            self.enter_scope(Scope::Destruction(id));\n         }\n-        self.enter_code_extent(CodeExtent::Misc(id));\n+        self.enter_scope(Scope::Node(id));\n     }\n }\n \n@@ -1125,12 +1122,12 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n         self.terminating_scopes.insert(body.value.hir_id.local_id);\n \n         if let Some(root_id) = self.cx.root_id {\n-            self.region_maps.record_closure_parent(body.value.hir_id.local_id, root_id);\n+            self.scope_tree.record_closure_parent(body.value.hir_id.local_id, root_id);\n         }\n         self.cx.root_id = Some(body.value.hir_id.local_id);\n \n-        self.enter_code_extent(CodeExtent::CallSiteScope(body.value.hir_id.local_id));\n-        self.enter_code_extent(CodeExtent::ParameterScope(body.value.hir_id.local_id));\n+        self.enter_scope(Scope::CallSite(body.value.hir_id.local_id));\n+        self.enter_scope(Scope::Arguments(body.value.hir_id.local_id));\n \n         // The arguments and `self` are parented to the fn.\n         self.cx.var_parent = self.cx.parent.take();\n@@ -1187,19 +1184,19 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n     }\n }\n \n-fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-    -> Rc<RegionMaps>\n+fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+    -> Rc<ScopeTree>\n {\n     let closure_base_def_id = tcx.closure_base_def_id(def_id);\n     if closure_base_def_id != def_id {\n-        return tcx.region_maps(closure_base_def_id);\n+        return tcx.region_scope_tree(closure_base_def_id);\n     }\n \n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let maps = if let Some(body_id) = tcx.hir.maybe_body_owned_by(id) {\n+    let scope_tree = if let Some(body_id) = tcx.hir.maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n-            region_maps: RegionMaps::default(),\n+            scope_tree: ScopeTree::default(),\n             cx: Context {\n                 root_id: None,\n                 parent: None,\n@@ -1209,32 +1206,32 @@ fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         };\n \n         let body = tcx.hir.body(body_id);\n-        visitor.region_maps.root_body = Some(body.value.hir_id);\n+        visitor.scope_tree.root_body = Some(body.value.hir_id);\n \n         // If the item is an associated const or a method,\n         // record its impl/trait parent, as it can also have\n         // lifetime parameters free in this body.\n         match tcx.hir.get(id) {\n             hir::map::NodeImplItem(_) |\n             hir::map::NodeTraitItem(_) => {\n-                visitor.region_maps.root_parent = Some(tcx.hir.get_parent(id));\n+                visitor.scope_tree.root_parent = Some(tcx.hir.get_parent(id));\n             }\n             _ => {}\n         }\n \n         visitor.visit_body(body);\n \n-        visitor.region_maps\n+        visitor.scope_tree\n     } else {\n-        RegionMaps::default()\n+        ScopeTree::default()\n     };\n \n-    Rc::new(maps)\n+    Rc::new(scope_tree)\n }\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n-        region_maps,\n+        region_scope_tree,\n         ..*providers\n     };\n }"}, {"sha": "1ea6c461fc180fcff99785ca0a41db5c6b778525", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -12,7 +12,7 @@\n \n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n-use middle::region::CodeExtent;\n+use middle::region;\n use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n@@ -918,9 +918,9 @@ pub enum StatementKind<'tcx> {\n     /// See <https://internals.rust-lang.org/t/types-as-contracts/5562/73> for more details.\n     Validate(ValidationOp, Vec<ValidationOperand<'tcx, Lvalue<'tcx>>>),\n \n-    /// Mark one terminating point of an extent (i.e. static region).\n+    /// Mark one terminating point of a region scope (i.e. static region).\n     /// (The starting point(s) arise implicitly from borrows.)\n-    EndRegion(CodeExtent),\n+    EndRegion(region::Scope),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n@@ -939,7 +939,7 @@ pub enum ValidationOp {\n     Release,\n     /// Recursive traverse the *mutable* part of the type and relinquish all exclusive\n     /// access *until* the given region ends.  Then, access will be recovered.\n-    Suspend(CodeExtent),\n+    Suspend(region::Scope),\n }\n \n impl Debug for ValidationOp {\n@@ -959,7 +959,7 @@ impl Debug for ValidationOp {\n pub struct ValidationOperand<'tcx, T> {\n     pub lval: T,\n     pub ty: Ty<'tcx>,\n-    pub re: Option<CodeExtent>,\n+    pub re: Option<region::Scope>,\n     pub mutbl: hir::Mutability,\n }\n \n@@ -1709,11 +1709,11 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n                 inputs: inputs.fold_with(folder)\n             },\n \n-            // Note for future: If we want to expose the extents\n+            // Note for future: If we want to expose the region scopes\n             // during the fold, we need to either generalize EndRegion\n             // to carry `[ty::Region]`, or extend the `TypeFolder`\n-            // trait with a `fn fold_extent`.\n-            EndRegion(ref extent) => EndRegion(extent.clone()),\n+            // trait with a `fn fold_scope`.\n+            EndRegion(ref region_scope) => EndRegion(region_scope.clone()),\n \n             Validate(ref op, ref lvals) =>\n                 Validate(op.clone(),\n@@ -1738,11 +1738,11 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n             InlineAsm { ref outputs, ref inputs, .. } =>\n                 outputs.visit_with(visitor) || inputs.visit_with(visitor),\n \n-            // Note for future: If we want to expose the extents\n+            // Note for future: If we want to expose the region scopes\n             // during the visit, we need to either generalize EndRegion\n             // to carry `[ty::Region]`, or extend the `TypeVisitor`\n-            // trait with a `fn visit_extent`.\n-            EndRegion(ref _extent) => false,\n+            // trait with a `fn visit_scope`.\n+            EndRegion(ref _scope) => false,\n \n             Validate(ref _op, ref lvalues) =>\n                 lvalues.iter().any(|ty_and_lvalue| ty_and_lvalue.visit_with(visitor)),"}, {"sha": "11a84f3636c67a85b20d2d182f4eda3e903274a4", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -17,7 +17,7 @@ pub use self::ObligationCauseCode::*;\n \n use hir;\n use hir::def_id::DefId;\n-use middle::region::RegionMaps;\n+use middle::region;\n use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n use ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, ToPredicate};\n@@ -532,9 +532,9 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n             predicates);\n \n-        let region_maps = RegionMaps::default();\n+        let region_scope_tree = region::ScopeTree::default();\n         let free_regions = FreeRegionMap::new();\n-        infcx.resolve_regions_and_report_errors(region_context, &region_maps, &free_regions);\n+        infcx.resolve_regions_and_report_errors(region_context, &region_scope_tree, &free_regions);\n         let predicates = match infcx.fully_resolve(&predicates) {\n             Ok(predicates) => predicates,\n             Err(fixup_err) => {"}, {"sha": "ecd742901ef177083897c1e44d7b6aaac4f4060c", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -17,7 +17,7 @@ use lint;\n use middle::const_val;\n use middle::cstore::{ExternCrate, LinkagePreference};\n use middle::privacy::AccessLevels;\n-use middle::region::RegionMaps;\n+use middle::region;\n use mir;\n use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n@@ -1080,10 +1080,9 @@ define_maps! { <'tcx>\n \n     [] fn reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n-    /// Per-function `RegionMaps`. The `DefId` should be the owner-def-id for the fn body;\n-    /// in the case of closures or \"inline\" expressions, this will be redirected to the enclosing\n-    /// fn item.\n-    [] fn region_maps: RegionMaps(DefId) -> Rc<RegionMaps>,\n+    /// Per-body `region::ScopeTree`. The `DefId` should be the owner-def-id for the body;\n+    /// in the case of closures, this will be redirected to the enclosing function.\n+    [] fn region_scope_tree: RegionScopeTree(DefId) -> Rc<region::ScopeTree>,\n \n     [] fn mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n "}, {"sha": "fc244cabcd11c7f4577d0ab19f77568c4667562f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -213,8 +213,8 @@ pub enum TypeVariants<'tcx> {\n /// as extra type parameters? The reason for this design is that the\n /// upvar types can reference lifetimes that are internal to the\n /// creating function. In my example above, for example, the lifetime\n-/// `'b` represents the extent of the closure itself; this is some\n-/// subset of `foo`, probably just the extent of the call to the to\n+/// `'b` represents the scope of the closure itself; this is some\n+/// subset of `foo`, probably just the scope of the call to the to\n /// `do()`. If we just had the lifetime/type parameters from the\n /// enclosing function, we couldn't name this lifetime `'b`. Note that\n /// there can also be lifetimes in the types of the upvars themselves,\n@@ -845,10 +845,10 @@ pub enum RegionKind {\n     /// region parameters.\n     ReFree(FreeRegion),\n \n-    /// A concrete region naming some statically determined extent\n+    /// A concrete region naming some statically determined scope\n     /// (e.g. an expression or sequence of statements) within the\n     /// current function.\n-    ReScope(region::CodeExtent),\n+    ReScope(region::Scope),\n \n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     ReStatic,"}, {"sha": "cc581b07de5fc61ea2a15107e4f190d97231d5af", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def_id::DefId;\n use hir::map::definitions::DefPathData;\n-use middle::region::{CodeExtent, BlockRemainder};\n+use middle::region::{self, BlockRemainder};\n use ty::subst::{self, Subst};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{TyBool, TyChar, TyAdt};\n@@ -524,18 +524,18 @@ impl fmt::Display for ty::RegionKind {\n             ty::ReSkolemized(_, br) => {\n                 write!(f, \"{}\", br)\n             }\n-            ty::ReScope(code_extent) if identify_regions() => {\n-                match code_extent {\n-                    CodeExtent::Misc(id) =>\n-                        write!(f, \"'{}mce\", id.as_usize()),\n-                    CodeExtent::CallSiteScope(id) =>\n-                        write!(f, \"'{}cce\", id.as_usize()),\n-                    CodeExtent::ParameterScope(id) =>\n-                        write!(f, \"'{}pce\", id.as_usize()),\n-                    CodeExtent::DestructionScope(id) =>\n-                        write!(f, \"'{}dce\", id.as_usize()),\n-                    CodeExtent::Remainder(BlockRemainder { block, first_statement_index }) =>\n-                        write!(f, \"'{}_{}rce\", block.as_usize(), first_statement_index),\n+            ty::ReScope(scope) if identify_regions() => {\n+                match scope {\n+                    region::Scope::Node(id) =>\n+                        write!(f, \"'{}s\", id.as_usize()),\n+                    region::Scope::CallSite(id) =>\n+                        write!(f, \"'{}cs\", id.as_usize()),\n+                    region::Scope::Arguments(id) =>\n+                        write!(f, \"'{}as\", id.as_usize()),\n+                    region::Scope::Destruction(id) =>\n+                        write!(f, \"'{}ds\", id.as_usize()),\n+                    region::Scope::Remainder(BlockRemainder { block, first_statement_index }) =>\n+                        write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index),\n                 }\n             }\n             ty::ReVar(region_vid) if identify_regions() => {"}, {"sha": "985257c28104cfdfa992dac96ff398d1d29638fd", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -206,7 +206,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         all_loans,\n         param_env,\n     };\n-    euv::ExprUseVisitor::new(&mut clcx, bccx.tcx, param_env, &bccx.region_maps, bccx.tables)\n+    euv::ExprUseVisitor::new(&mut clcx, bccx.tcx, param_env, &bccx.region_scope_tree, bccx.tables)\n         .consume_body(body);\n }\n \n@@ -240,14 +240,14 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn each_in_scope_loan<F>(&self, scope: region::CodeExtent, mut op: F) -> bool where\n+    pub fn each_in_scope_loan<F>(&self, scope: region::Scope, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,\n     {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n         self.each_issued_loan(scope.item_local_id(), |loan| {\n-            if self.bccx.region_maps.is_subscope_of(scope, loan.kill_scope) {\n+            if self.bccx.region_scope_tree.is_subscope_of(scope, loan.kill_scope) {\n                 op(loan)\n             } else {\n                 true\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn each_in_scope_loan_affecting_path<F>(&self,\n-                                            scope: region::CodeExtent,\n+                                            scope: region::Scope,\n                                             loan_path: &LoanPath<'tcx>,\n                                             mut op: F)\n                                             -> bool where\n@@ -386,7 +386,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                new_loan);\n \n         // Should only be called for loans that are in scope at the same time.\n-        assert!(self.bccx.region_maps.scopes_intersect(old_loan.kill_scope,\n+        assert!(self.bccx.region_scope_tree.scopes_intersect(old_loan.kill_scope,\n                                                        new_loan.kill_scope));\n \n         self.report_error_if_loan_conflicts_with_restriction(\n@@ -467,7 +467,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             // 3. Where does old loan expire.\n \n             let previous_end_span =\n-                old_loan.kill_scope.span(self.tcx(), &self.bccx.region_maps).end_point();\n+                old_loan.kill_scope.span(self.tcx(), &self.bccx.region_scope_tree).end_point();\n \n             let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n@@ -714,7 +714,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         let mut ret = UseOk;\n \n         self.each_in_scope_loan_affecting_path(\n-            region::CodeExtent::Misc(expr_id), use_path, |loan| {\n+            region::Scope::Node(expr_id), use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n@@ -833,7 +833,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         // Check that we don't invalidate any outstanding loans\n         if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n-            let scope = region::CodeExtent::Misc(assignment_id);\n+            let scope = region::Scope::Node(assignment_id);\n             self.each_in_scope_loan_affecting_path(scope, &loan_path, |loan| {\n                 self.report_illegal_mutation(assignment_span, &loan_path, loan);\n                 false"}, {"sha": "66aaafb77f757cc3e54681fc28f76b1f859299b7", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -24,7 +24,7 @@ use syntax_pos::Span;\n type R = Result<(),()>;\n \n pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    item_scope: region::CodeExtent,\n+                                    item_scope: region::Scope,\n                                     span: Span,\n                                     cause: euv::LoanCause,\n                                     cmt: mc::cmt<'tcx>,\n@@ -52,7 +52,7 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n \n     // the scope of the function body for the enclosing item\n-    item_scope: region::CodeExtent,\n+    item_scope: region::Scope,\n \n     span: Span,\n     cause: euv::LoanCause,\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             Categorization::Local(local_id) => {\n                 let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n                 self.bccx.tcx.mk_region(ty::ReScope(\n-                    self.bccx.region_maps.var_scope(hir_id.local_id)))\n+                    self.bccx.region_scope_tree.var_scope(hir_id.local_id)))\n             }\n             Categorization::StaticItem |\n             Categorization::Deref(_, mc::UnsafePtr(..)) => {"}, {"sha": "00edd9cb28a0d0b98983822ffa9fb7a2c9bc7732", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -43,12 +43,12 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let mut glcx = GatherLoanCtxt {\n         bccx,\n         all_loans: Vec::new(),\n-        item_ub: region::CodeExtent::Misc(bccx.tcx.hir.body(body).value.hir_id.local_id),\n+        item_ub: region::Scope::Node(bccx.tcx.hir.body(body).value.hir_id.local_id),\n         move_data: MoveData::default(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n-    euv::ExprUseVisitor::new(&mut glcx, bccx.tcx, param_env, &bccx.region_maps, bccx.tables)\n+    euv::ExprUseVisitor::new(&mut glcx, bccx.tcx, param_env, &bccx.region_scope_tree, bccx.tables)\n         .consume_body(bccx.body);\n \n     glcx.report_potential_errors();\n@@ -63,7 +63,7 @@ struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     all_loans: Vec<Loan<'tcx>>,\n     /// `item_ub` is used as an upper-bound on the lifetime whenever we\n     /// ask for the scope of an expression categorized as an upvar.\n-    item_ub: region::CodeExtent,\n+    item_ub: region::Scope,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n@@ -351,11 +351,11 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     ty::ReScope(scope) => scope,\n \n                     ty::ReEarlyBound(ref br) => {\n-                        self.bccx.region_maps.early_free_extent(self.tcx(), br)\n+                        self.bccx.region_scope_tree.early_free_scope(self.tcx(), br)\n                     }\n \n                     ty::ReFree(ref fr) => {\n-                        self.bccx.region_maps.free_extent(self.tcx(), fr)\n+                        self.bccx.region_scope_tree.free_scope(self.tcx(), fr)\n                     }\n \n                     ty::ReStatic => self.item_ub,\n@@ -373,7 +373,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);\n \n-                let borrow_scope = region::CodeExtent::Misc(borrow_id);\n+                let borrow_scope = region::Scope::Node(borrow_id);\n                 let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n                 debug!(\"gen_scope = {:?}\", gen_scope);\n \n@@ -473,23 +473,23 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn compute_gen_scope(&self,\n-                             borrow_scope: region::CodeExtent,\n-                             loan_scope: region::CodeExtent)\n-                             -> region::CodeExtent {\n+                             borrow_scope: region::Scope,\n+                             loan_scope: region::Scope)\n+                             -> region::Scope {\n         //! Determine when to introduce the loan. Typically the loan\n         //! is introduced at the point of the borrow, but in some cases,\n         //! notably method arguments, the loan may be introduced only\n         //! later, once it comes into scope.\n \n-        if self.bccx.region_maps.is_subscope_of(borrow_scope, loan_scope) {\n+        if self.bccx.region_scope_tree.is_subscope_of(borrow_scope, loan_scope) {\n             borrow_scope\n         } else {\n             loan_scope\n         }\n     }\n \n-    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent, lp: &LoanPath<'tcx>)\n-                              -> region::CodeExtent {\n+    pub fn compute_kill_scope(&self, loan_scope: region::Scope, lp: &LoanPath<'tcx>)\n+                              -> region::Scope {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the\n         //! local variable which roots the loan-path goes out of scope,\n@@ -512,10 +512,10 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         //! do not require restrictions and hence do not cause a loan.\n \n         let lexical_scope = lp.kill_scope(self.bccx);\n-        if self.bccx.region_maps.is_subscope_of(lexical_scope, loan_scope) {\n+        if self.bccx.region_scope_tree.is_subscope_of(lexical_scope, loan_scope) {\n             lexical_scope\n         } else {\n-            assert!(self.bccx.region_maps.is_subscope_of(loan_scope, lexical_scope));\n+            assert!(self.bccx.region_scope_tree.is_subscope_of(loan_scope, lexical_scope));\n             loan_scope\n         }\n     }"}, {"sha": "98c9a4a92ef3012ac8009f9155f3ba933e41bf7b", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -32,7 +32,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::ImmutabilityBlame;\n-use rustc::middle::region::{self, RegionMaps};\n+use rustc::middle::region;\n use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n@@ -98,9 +98,9 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n \n     let body_id = tcx.hir.body_owned_by(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n-    let region_maps = tcx.region_maps(owner_def_id);\n+    let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n     let body = tcx.hir.body(body_id);\n-    let bccx = &mut BorrowckCtxt { tcx, tables, region_maps, owner_def_id, body };\n+    let bccx = &mut BorrowckCtxt { tcx, tables, region_scope_tree, owner_def_id, body };\n \n     // Eventually, borrowck will always read the MIR, but at the\n     // moment we do not. So, for now, we always force MIR to be\n@@ -196,9 +196,9 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     let owner_id = tcx.hir.body_owner(body_id);\n     let owner_def_id = tcx.hir.local_def_id(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n-    let region_maps = tcx.region_maps(owner_def_id);\n+    let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n     let body = tcx.hir.body(body_id);\n-    let mut bccx = BorrowckCtxt { tcx, tables, region_maps, owner_def_id, body };\n+    let mut bccx = BorrowckCtxt { tcx, tables, region_scope_tree, owner_def_id, body };\n \n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx, true, body_id, |_| cfg);\n     (bccx, dataflow_data.unwrap())\n@@ -214,7 +214,7 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     // Some in `borrowck_fn` and cleared later\n     tables: &'a ty::TypeckTables<'tcx>,\n \n-    region_maps: Rc<RegionMaps>,\n+    region_scope_tree: Rc<region::ScopeTree>,\n \n     owner_def_id: DefId,\n \n@@ -255,13 +255,13 @@ pub struct Loan<'tcx> {\n     /// cases, notably method arguments, the loan may be introduced\n     /// only later, once it comes into scope.  See also\n     /// `GatherLoanCtxt::compute_gen_scope`.\n-    gen_scope: region::CodeExtent,\n+    gen_scope: region::Scope,\n \n     /// kill_scope indicates when the loan goes out of scope.  This is\n     /// either when the lifetime expires or when the local variable\n     /// which roots the loan-path goes out of scope, whichever happens\n     /// faster. See also `GatherLoanCtxt::compute_kill_scope`.\n-    kill_scope: region::CodeExtent,\n+    kill_scope: region::Scope,\n     span: Span,\n     cause: euv::LoanCause,\n }\n@@ -362,16 +362,16 @@ fn closure_to_block(closure_id: DefIndex,\n }\n \n impl<'a, 'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::CodeExtent {\n+    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::Scope {\n         match self.kind {\n             LpVar(local_id) => {\n                 let hir_id = bccx.tcx.hir.node_to_hir_id(local_id);\n-                bccx.region_maps.var_scope(hir_id.local_id)\n+                bccx.region_scope_tree.var_scope(hir_id.local_id)\n             }\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n                 let hir_id = bccx.tcx.hir.node_to_hir_id(block_id);\n-                region::CodeExtent::Misc(hir_id.local_id)\n+                region::Scope::Node(hir_id.local_id)\n             }\n             LpDowncast(ref base, _) |\n             LpExtend(ref base, ..) => base.kill_scope(bccx),\n@@ -535,7 +535,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     {\n         let region_rels = RegionRelations::new(self.tcx,\n                                                self.owner_def_id,\n-                                               &self.region_maps,\n+                                               &self.region_scope_tree,\n                                                &self.tables.free_region_map);\n         region_rels.is_subregion_of(r_sub, r_sup)\n     }\n@@ -820,18 +820,18 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 debug!(\"err_out_of_scope: self.body.is_generator = {:?}\",\n                        self.body.is_generator);\n                 let maybe_borrow_across_yield = if self.body.is_generator {\n-                    let body_extent = region::CodeExtent::Misc(self.body.value.hir_id.local_id);\n-                    debug!(\"err_out_of_scope: body_extent = {:?}\", body_extent);\n+                    let body_scope = region::Scope::Node(self.body.value.hir_id.local_id);\n+                    debug!(\"err_out_of_scope: body_scope = {:?}\", body_scope);\n                     debug!(\"err_out_of_scope: super_scope = {:?}\", super_scope);\n                     debug!(\"err_out_of_scope: sub_scope = {:?}\", sub_scope);\n                     match (super_scope, sub_scope) {\n-                        (&ty::RegionKind::ReScope(value_extent),\n-                         &ty::RegionKind::ReScope(loan_extent)) => {\n+                        (&ty::RegionKind::ReScope(value_scope),\n+                         &ty::RegionKind::ReScope(loan_scope)) => {\n                             if {\n-                                // value_extent <= body_extent &&\n-                                self.region_maps.is_subscope_of(value_extent, body_extent) &&\n-                                    // body_extent <= loan_extent\n-                                    self.region_maps.is_subscope_of(body_extent, loan_extent)\n+                                // value_scope <= body_scope &&\n+                                self.region_scope_tree.is_subscope_of(value_scope, body_scope) &&\n+                                    // body_scope <= loan_scope\n+                                    self.region_scope_tree.is_subscope_of(body_scope, loan_scope)\n                             } {\n                                 // We now know that this is a case\n                                 // that fits the bill described above:\n@@ -846,7 +846,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                 // block remainder that starts with\n                                 // `let a`) for a yield. We can cite\n                                 // that for the user.\n-                                self.region_maps.yield_in_scope(value_extent)\n+                                self.region_scope_tree.yield_in_scope(value_scope)\n                             } else {\n                                 None\n                             }\n@@ -945,7 +945,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             }\n                             None => {\n                                 self.tcx.note_and_explain_region(\n-                                    &self.region_maps,\n+                                    &self.region_scope_tree,\n                                     &mut db,\n                                     \"borrowed value must be valid for \",\n                                     sub_scope,\n@@ -958,7 +958,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             }\n                             None => {\n                                 self.tcx.note_and_explain_region(\n-                                    &self.region_maps,\n+                                    &self.region_scope_tree,\n                                     &mut db,\n                                     \"...but borrowed value is only valid for \",\n                                     super_scope,\n@@ -969,7 +969,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 }\n \n                 if let ty::ReScope(scope) = *super_scope {\n-                    let node_id = scope.node_id(self.tcx, &self.region_maps);\n+                    let node_id = scope.node_id(self.tcx, &self.region_scope_tree);\n                     match self.tcx.hir.find(node_id) {\n                         Some(hir_map::NodeStmt(_)) => {\n                             db.note(\"consider using a `let` binding to increase its lifetime\");\n@@ -994,14 +994,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     None => self.cmt_to_string(&err.cmt),\n                 };\n                 self.tcx.note_and_explain_region(\n-                    &self.region_maps,\n+                    &self.region_scope_tree,\n                     &mut db,\n                     &format!(\"{} would have to be valid for \",\n                             descr),\n                     loan_scope,\n                     \"...\");\n                 self.tcx.note_and_explain_region(\n-                    &self.region_maps,\n+                    &self.region_scope_tree,\n                     &mut db,\n                     &format!(\"...but {} is only valid for \", descr),\n                     ptr_scope,\n@@ -1257,7 +1257,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     fn region_end_span(&self, region: ty::Region<'tcx>) -> Option<Span> {\n         match *region {\n             ty::ReScope(scope) => {\n-                Some(scope.span(self.tcx, &self.region_maps).end_point())\n+                Some(scope.span(self.tcx, &self.region_scope_tree).end_point())\n             }\n             _ => None\n         }"}, {"sha": "d832ad0ab1d206a40dcabb53bff90ac868bd69bf", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -18,7 +18,7 @@ use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n-use rustc::middle::region::RegionMaps;\n+use rustc::middle::region;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n         MatchVisitor {\n             tcx: self.tcx,\n             tables: self.tcx.body_tables(b),\n-            region_maps: &self.tcx.region_maps(def_id),\n+            region_scope_tree: &self.tcx.region_scope_tree(def_id),\n             param_env: self.tcx.param_env(def_id),\n             identity_substs: Substs::identity_for_item(self.tcx, def_id),\n         }.visit_body(self.tcx.hir.body(b));\n@@ -72,7 +72,7 @@ struct MatchVisitor<'a, 'tcx: 'a> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     identity_substs: &'tcx Substs<'tcx>,\n-    region_maps: &'a RegionMaps,\n+    region_scope_tree: &'a region::ScopeTree,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n@@ -526,7 +526,7 @@ fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n     let mut checker = MutationChecker {\n         cx,\n     };\n-    ExprUseVisitor::new(&mut checker, cx.tcx, cx.param_env, cx.region_maps, cx.tables)\n+    ExprUseVisitor::new(&mut checker, cx.tcx, cx.param_env, cx.region_scope_tree, cx.tables)\n         .walk_expr(guard);\n }\n "}, {"sha": "552130e8a4703dab1c7e0e7333892751a6d89b2b", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -17,7 +17,7 @@ use rustc_resolve::MakeGlobMap;\n use rustc_trans;\n use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n-use rustc::middle::region::{CodeExtent, RegionMaps};\n+use rustc::middle::region;\n use rustc::middle::resolve_lifetime;\n use rustc::middle::stability;\n use rustc::ty::subst::{Kind, Subst};\n@@ -45,7 +45,7 @@ use rustc::hir;\n \n struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n-    region_maps: &'a mut RegionMaps,\n+    region_scope_tree: &'a mut region::ScopeTree,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n@@ -157,15 +157,15 @@ fn test_env<F>(source_string: &str,\n                              \"test_crate\",\n                              |tcx| {\n         tcx.infer_ctxt().enter(|infcx| {\n-            let mut region_maps = RegionMaps::default();\n+            let mut region_scope_tree = region::ScopeTree::default();\n             body(Env {\n                 infcx: &infcx,\n-                region_maps: &mut region_maps,\n+                region_scope_tree: &mut region_scope_tree,\n                 param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n             });\n             let free_regions = FreeRegionMap::new();\n             let def_id = tcx.hir.local_def_id(ast::CRATE_NODE_ID);\n-            infcx.resolve_regions_and_report_errors(def_id, &region_maps, &free_regions);\n+            infcx.resolve_regions_and_report_errors(def_id, &region_scope_tree, &free_regions);\n             assert_eq!(tcx.sess.err_count(), expected_err_count);\n         });\n     });\n@@ -176,9 +176,9 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn create_region_hierarchy(&mut self, rh: &RH, parent: CodeExtent) {\n-        let me = CodeExtent::Misc(rh.id);\n-        self.region_maps.record_code_extent(me, Some(parent));\n+    pub fn create_region_hierarchy(&mut self, rh: &RH, parent: region::Scope) {\n+        let me = region::Scope::Node(rh.id);\n+        self.region_scope_tree.record_scope_parent(me, Some(parent));\n         for child_rh in rh.sub {\n             self.create_region_hierarchy(child_rh, me);\n         }\n@@ -188,8 +188,8 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         // creates a region hierarchy where 1 is root, 10 and 11 are\n         // children of 1, etc\n \n-        let dscope = CodeExtent::DestructionScope(hir::ItemLocalId(1));\n-        self.region_maps.record_code_extent(dscope, None);\n+        let dscope = region::Scope::Destruction(hir::ItemLocalId(1));\n+        self.region_scope_tree.record_scope_parent(dscope, None);\n         self.create_region_hierarchy(&RH {\n             id: hir::ItemLocalId(1),\n             sub: &[RH {\n@@ -333,7 +333,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n-        let r = ty::ReScope(CodeExtent::Misc(hir::ItemLocalId(id)));\n+        let r = ty::ReScope(region::Scope::Node(hir::ItemLocalId(id)));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n "}, {"sha": "af550aea07ee9cdb5df417cad6ba512b7fd2f6e1", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -603,7 +603,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         //\n         // (Or if you prefer, all the *other* iterations over loans\n         // only consider loans that are in scope of some given\n-        // CodeExtent)\n+        // region::Scope)\n         //\n         // The (currently skeletal) code here does not encode such a\n         // distinction, which means it is almost certainly over"}, {"sha": "0e412fb27ca68b397263c3aec36a466958498d69", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -21,10 +21,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                      ast_block: &'tcx hir::Block,\n                      source_info: SourceInfo)\n                      -> BlockAnd<()> {\n-        let Block { extent, opt_destruction_extent, span, stmts, expr, targeted_by_break } =\n+        let Block { region_scope, opt_destruction_scope, span, stmts, expr, targeted_by_break } =\n             self.hir.mirror(ast_block);\n-        self.in_opt_scope(opt_destruction_extent.map(|de|(de, source_info)), block, move |this| {\n-            this.in_scope((extent, source_info), block, move |this| {\n+        self.in_opt_scope(opt_destruction_scope.map(|de|(de, source_info)), block, move |this| {\n+            this.in_scope((region_scope, source_info), block, move |this| {\n                 if targeted_by_break {\n                     // This is a `break`-able block (currently only `catch { ... }`)\n                     let exit_block = this.cfg.start_new_block();\n@@ -67,15 +67,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // the let-scopes at the end.\n         //\n         // First we build all the statements in the block.\n-        let mut let_extent_stack = Vec::with_capacity(8);\n+        let mut let_scope_stack = Vec::with_capacity(8);\n         let outer_visibility_scope = this.visibility_scope;\n         let source_info = this.source_info(span);\n         for stmt in stmts {\n-            let Stmt { kind, opt_destruction_extent } = this.hir.mirror(stmt);\n+            let Stmt { kind, opt_destruction_scope } = this.hir.mirror(stmt);\n             match kind {\n                 StmtKind::Expr { scope, expr } => {\n                     unpack!(block = this.in_opt_scope(\n-                        opt_destruction_extent.map(|de|(de, source_info)), block, |this| {\n+                        opt_destruction_scope.map(|de|(de, source_info)), block, |this| {\n                             this.in_scope((scope, source_info), block, |this| {\n                                 let expr = this.hir.mirror(expr);\n                                 this.stmt_expr(block, expr)\n@@ -85,17 +85,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n                     // Enter the remainder scope, i.e. the bindings' destruction scope.\n                     this.push_scope((remainder_scope, source_info));\n-                    let_extent_stack.push(remainder_scope);\n+                    let_scope_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a visibility scope.\n                     let remainder_span = remainder_scope.span(this.hir.tcx(),\n-                                                              &this.hir.region_maps);\n+                                                              &this.hir.region_scope_tree);\n                     let scope = this.declare_bindings(None, remainder_span, &pattern);\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n                         unpack!(block = this.in_opt_scope(\n-                            opt_destruction_extent.map(|de|(de, source_info)), block, move |this| {\n+                            opt_destruction_scope.map(|de|(de, source_info)), block, move |this| {\n                                 this.in_scope((init_scope, source_info), block, move |this| {\n                                     // FIXME #30046                             ^~~~\n                                     this.expr_into_pattern(block, pattern, init)\n@@ -124,8 +124,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n         // Finally, we pop all the let scopes before exiting out from the scope of block\n         // itself.\n-        for extent in let_extent_stack.into_iter().rev() {\n-            unpack!(block = this.pop_scope((extent, source_info), block));\n+        for scope in let_scope_stack.into_iter().rev() {\n+            unpack!(block = this.pop_scope((scope, source_info), block));\n         }\n         // Restore the original visibility scope.\n         this.visibility_scope = outer_visibility_scope;"}, {"sha": "d77fe5170e040f43548222276e0c36177202e4d9", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -14,7 +14,7 @@\n //! Routines for manipulating the control-flow graph.\n \n use build::CFG;\n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region;\n use rustc::mir::*;\n \n impl<'tcx> CFG<'tcx> {\n@@ -47,10 +47,10 @@ impl<'tcx> CFG<'tcx> {\n     pub fn push_end_region(&mut self,\n                            block: BasicBlock,\n                            source_info: SourceInfo,\n-                           extent: CodeExtent) {\n+                           region_scope: region::Scope) {\n         self.push(block, Statement {\n             source_info,\n-            kind: StatementKind::EndRegion(extent),\n+            kind: StatementKind::EndRegion(region_scope),\n         });\n     }\n "}, {"sha": "a86b7f4d239a3a0813181fc038e3583da0ec7cf0", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -29,7 +29,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let Expr { ty, temp_lifetime: _, span, kind }\n             = expr;\n         match kind {\n-            ExprKind::Scope { extent: _, value } =>\n+            ExprKind::Scope { region_scope: _, value } =>\n                 this.as_constant(value),\n             ExprKind::Literal { literal } =>\n                 Constant { span: span, ty: ty, literal: literal },"}, {"sha": "01b76af1576f8626340b7a567a7608ca8d2ef7bf", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -39,8 +39,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n         match expr.kind {\n-            ExprKind::Scope { extent, value } => {\n-                this.in_scope((extent, source_info), block, |this| this.as_lvalue(block, value))\n+            ExprKind::Scope { region_scope, value } => {\n+                this.in_scope((region_scope, source_info), block, |this| {\n+                    this.as_lvalue(block, value)\n+                })\n             }\n             ExprKind::Field { lhs, name } => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, lhs));\n@@ -56,7 +58,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let (usize_ty, bool_ty) = (this.hir.usize_ty(), this.hir.bool_ty());\n \n                 let slice = unpack!(block = this.as_lvalue(block, lhs));\n-                // extent=None so lvalue indexes live forever. They are scalars so they\n+                // region_scope=None so lvalue indexes live forever. They are scalars so they\n                 // do not need storage annotations, and they are often copied between\n                 // places.\n                 let idx = unpack!(block = this.as_operand(block, None, index));"}, {"sha": "ea1b53add5ee15bbb89730440fc703efef2c3f73", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -13,7 +13,7 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::Category;\n use hair::*;\n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region;\n use rustc::mir::*;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -39,7 +39,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// The operand is known to be live until the end of `scope`.\n     pub fn as_operand<M>(&mut self,\n                          block: BasicBlock,\n-                         scope: Option<CodeExtent>,\n+                         scope: Option<region::Scope>,\n                          expr: M) -> BlockAnd<Operand<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n@@ -49,16 +49,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_operand(&mut self,\n                        mut block: BasicBlock,\n-                       scope: Option<CodeExtent>,\n+                       scope: Option<region::Scope>,\n                        expr: Expr<'tcx>)\n                        -> BlockAnd<Operand<'tcx>> {\n         debug!(\"expr_as_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n-        if let ExprKind::Scope { extent, value } = expr.kind {\n+        if let ExprKind::Scope { region_scope, value } = expr.kind {\n             let source_info = this.source_info(expr.span);\n-            let extent = (extent, source_info);\n-            return this.in_scope(extent, block, |this| {\n+            let region_scope = (region_scope, source_info);\n+            return this.in_scope(region_scope, block, |this| {\n                 this.as_operand(block, scope, value)\n             });\n         }"}, {"sha": "7591200b13f6a6a5bda39101ba74000ccc70b248", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -21,7 +21,7 @@ use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n use rustc_const_math::{ConstInt, ConstIsize};\n use rustc::middle::const_val::ConstVal;\n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region;\n use rustc::ty;\n use rustc::mir::*;\n use syntax::ast;\n@@ -38,7 +38,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     /// Compile `expr`, yielding an rvalue.\n-    pub fn as_rvalue<M>(&mut self, block: BasicBlock, scope: Option<CodeExtent>, expr: M)\n+    pub fn as_rvalue<M>(&mut self, block: BasicBlock, scope: Option<region::Scope>, expr: M)\n                         -> BlockAnd<Rvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n@@ -48,7 +48,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_rvalue(&mut self,\n                       mut block: BasicBlock,\n-                      scope: Option<CodeExtent>,\n+                      scope: Option<region::Scope>,\n                       expr: Expr<'tcx>)\n                       -> BlockAnd<Rvalue<'tcx>> {\n         debug!(\"expr_as_rvalue(block={:?}, scope={:?}, expr={:?})\", block, scope, expr);\n@@ -58,9 +58,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_info = this.source_info(expr_span);\n \n         match expr.kind {\n-            ExprKind::Scope { extent, value } => {\n-                let extent = (extent, source_info);\n-                this.in_scope(extent, block, |this| this.as_rvalue(block, scope, value))\n+            ExprKind::Scope { region_scope, value } => {\n+                let region_scope = (region_scope, source_info);\n+                this.in_scope(region_scope, block, |this| this.as_rvalue(block, scope, value))\n             }\n             ExprKind::Repeat { value, count } => {\n                 let value_operand = unpack!(block = this.as_operand(block, scope, value));"}, {"sha": "1b63db9017db0dfca49ba598f51ffd946900dab0", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -13,15 +13,15 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::Category;\n use hair::*;\n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region;\n use rustc::mir::*;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n     /// up rvalues so as to freeze the value that will be consumed.\n     pub fn as_temp<M>(&mut self,\n                       block: BasicBlock,\n-                      temp_lifetime: Option<CodeExtent>,\n+                      temp_lifetime: Option<region::Scope>,\n                       expr: M)\n                       -> BlockAnd<Lvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n@@ -32,7 +32,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_temp(&mut self,\n                     mut block: BasicBlock,\n-                    temp_lifetime: Option<CodeExtent>,\n+                    temp_lifetime: Option<region::Scope>,\n                     expr: Expr<'tcx>)\n                     -> BlockAnd<Lvalue<'tcx>> {\n         debug!(\"expr_as_temp(block={:?}, temp_lifetime={:?}, expr={:?})\",\n@@ -41,8 +41,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n-        if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope((extent, source_info), block, |this| {\n+        if let ExprKind::Scope { region_scope, value } = expr.kind {\n+            return this.in_scope((region_scope, source_info), block, |this| {\n                 this.as_temp(block, temp_lifetime, value)\n             });\n         }"}, {"sha": "6d7c213266567262bbc64b45d54b871b90721d6c", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -38,9 +38,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_info = this.source_info(expr_span);\n \n         match expr.kind {\n-            ExprKind::Scope { extent, value } => {\n-                let extent = (extent, source_info);\n-                this.in_scope(extent, block, |this| this.into(destination, block, value))\n+            ExprKind::Scope { region_scope, value } => {\n+                let region_scope = (region_scope, source_info);\n+                this.in_scope(region_scope, block, |this| this.into(destination, block, value))\n             }\n             ExprKind::Block { body: ast_block } => {\n                 this.ast_block(destination, block, ast_block, source_info)"}, {"sha": "84468d5d6dc18f43bffcd415540f98ff6798e3e4", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -22,9 +22,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // Handle a number of expressions that don't need a destination at all. This\n         // avoids needing a mountain of temporary `()` variables.\n         match expr.kind {\n-            ExprKind::Scope { extent, value } => {\n+            ExprKind::Scope { region_scope, value } => {\n                 let value = this.hir.mirror(value);\n-                this.in_scope((extent, source_info), block, |this| this.stmt_expr(block, value))\n+                this.in_scope((region_scope, source_info), block, |this| {\n+                    this.stmt_expr(block, value)\n+                })\n             }\n             ExprKind::Assign { lhs, rhs } => {\n                 let lhs = this.hir.mirror(lhs);\n@@ -77,29 +79,29 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.unit()\n             }\n             ExprKind::Continue { label } => {\n-                let BreakableScope { continue_block, extent, .. } =\n+                let BreakableScope { continue_block, region_scope, .. } =\n                     *this.find_breakable_scope(expr_span, label);\n                 let continue_block = continue_block.expect(\n                     \"Attempted to continue in non-continuable breakable block\");\n-                this.exit_scope(expr_span, (extent, source_info), block, continue_block);\n+                this.exit_scope(expr_span, (region_scope, source_info), block, continue_block);\n                 this.cfg.start_new_block().unit()\n             }\n             ExprKind::Break { label, value } => {\n-                let (break_block, extent, destination) = {\n+                let (break_block, region_scope, destination) = {\n                     let BreakableScope {\n                         break_block,\n-                        extent,\n+                        region_scope,\n                         ref break_destination,\n                         ..\n                     } = *this.find_breakable_scope(expr_span, label);\n-                    (break_block, extent, break_destination.clone())\n+                    (break_block, region_scope, break_destination.clone())\n                 };\n                 if let Some(value) = value {\n                     unpack!(block = this.into(&destination, block, value))\n                 } else {\n                     this.cfg.push_assign_unit(block, source_info, &destination)\n                 }\n-                this.exit_scope(expr_span, (extent, source_info), block, break_block);\n+                this.exit_scope(expr_span, (region_scope, source_info), block, break_block);\n                 this.cfg.start_new_block().unit()\n             }\n             ExprKind::Return { value } => {\n@@ -114,9 +116,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         block\n                     }\n                 };\n-                let extent = this.extent_of_return_scope();\n+                let region_scope = this.region_scope_of_return_scope();\n                 let return_block = this.return_block();\n-                this.exit_scope(expr_span, (extent, source_info), block, return_block);\n+                this.exit_scope(expr_span, (region_scope, source_info), block, return_block);\n                 this.cfg.start_new_block().unit()\n             }\n             ExprKind::InlineAsm { asm, outputs, inputs } => {"}, {"sha": "a2b376336b8062878d80a0671a4d4f82bc4eaae3", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -203,8 +203,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let local_id = self.var_indices[&var];\n         let var_ty = self.local_decls[local_id].ty;\n         let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n-        let extent = self.hir.region_maps.var_scope(hir_id.local_id);\n-        self.schedule_drop(span, extent, &Lvalue::Local(local_id), var_ty);\n+        let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n+        self.schedule_drop(span, region_scope, &Lvalue::Local(local_id), var_ty);\n     }\n \n     pub fn visit_bindings<F>(&mut self, pattern: &Pattern<'tcx>, f: &mut F)"}, {"sha": "7d1aace873e82c466afe767537ac00e36ca7a864", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -14,7 +14,7 @@ use hair::cx::Cx;\n use hair::Pattern;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use rustc::mir::visit::{MutVisitor, Lookup};\n@@ -355,13 +355,13 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         arguments.len(),\n         return_ty);\n \n-    let call_site_extent = CodeExtent::CallSiteScope(body.value.hir_id.local_id);\n-    let arg_extent = CodeExtent::ParameterScope(body.value.hir_id.local_id);\n+    let call_site_scope = region::Scope::CallSite(body.value.hir_id.local_id);\n+    let arg_scope = region::Scope::Arguments(body.value.hir_id.local_id);\n     let mut block = START_BLOCK;\n     let source_info = builder.source_info(span);\n-    unpack!(block = builder.in_scope((call_site_extent, source_info), block, |builder| {\n-        unpack!(block = builder.in_scope((arg_extent, source_info), block, |builder| {\n-            builder.args_and_body(block, &arguments, arg_extent, &body.value)\n+    unpack!(block = builder.in_scope((call_site_scope, source_info), block, |builder| {\n+        unpack!(block = builder.in_scope((arg_scope, source_info), block, |builder| {\n+            builder.args_and_body(block, &arguments, arg_scope, &body.value)\n         }));\n         // Attribute epilogue to function's closing brace\n         let fn_end = span.with_lo(span.hi());\n@@ -503,7 +503,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n                      arguments: &[(Ty<'gcx>, Option<&'gcx hir::Pat>)],\n-                     argument_extent: CodeExtent,\n+                     argument_scope: region::Scope,\n                      ast_body: &'gcx hir::Expr)\n                      -> BlockAnd<()>\n     {\n@@ -547,7 +547,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(pattern.as_ref().map_or(ast_body.span, |pat| pat.span),\n-                               argument_extent, &lvalue, ty);\n+                               argument_scope, &lvalue, ty);\n \n         }\n "}, {"sha": "f527c4f03880b3b4186a78b1b008a0268971068c", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 68, "deletions": 64, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -12,7 +12,7 @@\n Managing the scope stack. The scopes are tied to lexical scopes, so as\n we descend the HAIR, we push a scope on the stack, translate ite\n contents, and then pop it off. Every scope is named by a\n-`CodeExtent`.\n+`region::Scope`.\n \n ### SEME Regions\n \n@@ -23,7 +23,7 @@ via a `break` or `return` or just by fallthrough, that marks an exit\n from the scope. Each lexical scope thus corresponds to a single-entry,\n multiple-exit (SEME) region in the control-flow graph.\n \n-For now, we keep a mapping from each `CodeExtent` to its\n+For now, we keep a mapping from each `region::Scope` to its\n corresponding SEME region for later reference (see caveat in next\n paragraph). This is because region scopes are tied to\n them. Eventually, when we shift to non-lexical lifetimes, there should\n@@ -88,7 +88,7 @@ should go to.\n */\n \n use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region;\n use rustc::ty::Ty;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n@@ -101,11 +101,11 @@ pub struct Scope<'tcx> {\n     /// The visibility scope this scope was created in.\n     visibility_scope: VisibilityScope,\n \n-    /// the extent of this scope within source code.\n-    extent: CodeExtent,\n+    /// the region span of this scope within source code.\n+    region_scope: region::Scope,\n \n-    /// the span of that extent\n-    extent_span: Span,\n+    /// the span of that region_scope\n+    region_scope_span: Span,\n \n     /// Whether there's anything to do for the cleanup path, that is,\n     /// when unwinding through this scope. This includes destructors,\n@@ -125,7 +125,7 @@ pub struct Scope<'tcx> {\n     drops: Vec<DropData<'tcx>>,\n \n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n-    cached_exits: FxHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n+    cached_exits: FxHashMap<(BasicBlock, region::Scope), BasicBlock>,\n \n     /// The cache for drop chain on \"generator drop\" exit.\n     cached_generator_drop: Option<BasicBlock>,\n@@ -165,8 +165,8 @@ enum DropKind {\n \n #[derive(Clone, Debug)]\n pub struct BreakableScope<'tcx> {\n-    /// Extent of the loop\n-    pub extent: CodeExtent,\n+    /// Region scope of the loop\n+    pub region_scope: region::Scope,\n     /// Where the body of the loop begins. `None` if block\n     pub continue_block: Option<BasicBlock>,\n     /// Block to branch into when the loop or block terminates (either by being `break`-en out\n@@ -269,80 +269,80 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                     f: F) -> R\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> R\n     {\n-        let extent = self.topmost_scope();\n+        let region_scope = self.topmost_scope();\n         let scope = BreakableScope {\n-            extent,\n+            region_scope,\n             continue_block: loop_block,\n             break_block,\n             break_destination,\n         };\n         self.breakable_scopes.push(scope);\n         let res = f(self);\n         let breakable_scope = self.breakable_scopes.pop().unwrap();\n-        assert!(breakable_scope.extent == extent);\n+        assert!(breakable_scope.region_scope == region_scope);\n         res\n     }\n \n     pub fn in_opt_scope<F, R>(&mut self,\n-                              opt_extent: Option<(CodeExtent, SourceInfo)>,\n+                              opt_scope: Option<(region::Scope, SourceInfo)>,\n                               mut block: BasicBlock,\n                               f: F)\n                               -> BlockAnd<R>\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n-        debug!(\"in_opt_scope(opt_extent={:?}, block={:?})\", opt_extent, block);\n-        if let Some(extent) = opt_extent { self.push_scope(extent); }\n+        debug!(\"in_opt_scope(opt_scope={:?}, block={:?})\", opt_scope, block);\n+        if let Some(region_scope) = opt_scope { self.push_scope(region_scope); }\n         let rv = unpack!(block = f(self));\n-        if let Some(extent) = opt_extent {\n-            unpack!(block = self.pop_scope(extent, block));\n+        if let Some(region_scope) = opt_scope {\n+            unpack!(block = self.pop_scope(region_scope, block));\n         }\n-        debug!(\"in_scope: exiting opt_extent={:?} block={:?}\", opt_extent, block);\n+        debug!(\"in_scope: exiting opt_scope={:?} block={:?}\", opt_scope, block);\n         block.and(rv)\n     }\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n     pub fn in_scope<F, R>(&mut self,\n-                          extent: (CodeExtent, SourceInfo),\n+                          region_scope: (region::Scope, SourceInfo),\n                           mut block: BasicBlock,\n                           f: F)\n                           -> BlockAnd<R>\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n-        debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n-        self.push_scope(extent);\n+        debug!(\"in_scope(region_scope={:?}, block={:?})\", region_scope, block);\n+        self.push_scope(region_scope);\n         let rv = unpack!(block = f(self));\n-        unpack!(block = self.pop_scope(extent, block));\n-        debug!(\"in_scope: exiting extent={:?} block={:?}\", extent, block);\n+        unpack!(block = self.pop_scope(region_scope, block));\n+        debug!(\"in_scope: exiting region_scope={:?} block={:?}\", region_scope, block);\n         block.and(rv)\n     }\n \n     /// Push a scope onto the stack. You can then build code in this\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: (CodeExtent, SourceInfo)) {\n-        debug!(\"push_scope({:?})\", extent);\n+    pub fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo)) {\n+        debug!(\"push_scope({:?})\", region_scope);\n         let vis_scope = self.visibility_scope;\n         self.scopes.push(Scope {\n             visibility_scope: vis_scope,\n-            extent: extent.0,\n-            extent_span: extent.1.span,\n+            region_scope: region_scope.0,\n+            region_scope_span: region_scope.1.span,\n             needs_cleanup: false,\n             drops: vec![],\n             cached_generator_drop: None,\n             cached_exits: FxHashMap()\n         });\n     }\n \n-    /// Pops a scope, which should have extent `extent`, adding any\n-    /// drops onto the end of `block` that are needed.  This must\n-    /// match 1-to-1 with `push_scope`.\n+    /// Pops a scope, which should have region scope `region_scope`,\n+    /// adding any drops onto the end of `block` that are needed.\n+    /// This must match 1-to-1 with `push_scope`.\n     pub fn pop_scope(&mut self,\n-                     extent: (CodeExtent, SourceInfo),\n+                     region_scope: (region::Scope, SourceInfo),\n                      mut block: BasicBlock)\n                      -> BlockAnd<()> {\n-        debug!(\"pop_scope({:?}, {:?})\", extent, block);\n+        debug!(\"pop_scope({:?}, {:?})\", region_scope, block);\n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n         let may_panic =\n@@ -351,33 +351,35 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.diverge_cleanup();\n         }\n         let scope = self.scopes.pop().unwrap();\n-        assert_eq!(scope.extent, extent.0);\n+        assert_eq!(scope.region_scope, region_scope.0);\n         unpack!(block = build_scope_drops(&mut self.cfg,\n                                           &scope,\n                                           &self.scopes,\n                                           block,\n                                           self.arg_count,\n                                           false));\n \n-        self.cfg.push_end_region(block, extent.1, scope.extent);\n+        self.cfg.push_end_region(block, region_scope.1, scope.region_scope);\n         block.unit()\n     }\n \n \n     /// Branch out of `block` to `target`, exiting all scopes up to\n-    /// and including `extent`.  This will insert whatever drops are\n+    /// and including `region_scope`.  This will insert whatever drops are\n     /// needed, as well as tracking this exit for the SEME region. See\n     /// module comment for details.\n     pub fn exit_scope(&mut self,\n                       span: Span,\n-                      extent: (CodeExtent, SourceInfo),\n+                      region_scope: (region::Scope, SourceInfo),\n                       mut block: BasicBlock,\n                       target: BasicBlock) {\n-        debug!(\"exit_scope(extent={:?}, block={:?}, target={:?})\", extent, block, target);\n-        let scope_count = 1 + self.scopes.iter().rev().position(|scope| scope.extent == extent.0)\n-                                                      .unwrap_or_else(||{\n-            span_bug!(span, \"extent {:?} does not enclose\", extent)\n-        });\n+        debug!(\"exit_scope(region_scope={:?}, block={:?}, target={:?})\",\n+               region_scope, block, target);\n+        let scope_count = 1 + self.scopes.iter().rev()\n+            .position(|scope| scope.region_scope == region_scope.0)\n+            .unwrap_or_else(|| {\n+                span_bug!(span, \"region_scope {:?} does not enclose\", region_scope)\n+            });\n         let len = self.scopes.len();\n         assert!(scope_count < len, \"should not use `exit_scope` to pop ALL scopes\");\n \n@@ -393,15 +395,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let mut rest = &mut self.scopes[(len - scope_count)..];\n         while let Some((scope, rest_)) = {rest}.split_last_mut() {\n             rest = rest_;\n-            block = if let Some(&e) = scope.cached_exits.get(&(target, extent.0)) {\n+            block = if let Some(&e) = scope.cached_exits.get(&(target, region_scope.0)) {\n                 self.cfg.terminate(block, scope.source_info(span),\n                                    TerminatorKind::Goto { target: e });\n                 return;\n             } else {\n                 let b = self.cfg.start_new_block();\n                 self.cfg.terminate(block, scope.source_info(span),\n                                    TerminatorKind::Goto { target: b });\n-                scope.cached_exits.insert((target, extent.0), b);\n+                scope.cached_exits.insert((target, region_scope.0), b);\n                 b\n             };\n             unpack!(block = build_scope_drops(&mut self.cfg,\n@@ -412,7 +414,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                               false));\n \n             // End all regions for scopes out of which we are breaking.\n-            self.cfg.push_end_region(block, extent.1, scope.extent);\n+            self.cfg.push_end_region(block, region_scope.1, scope.region_scope);\n         }\n         }\n         let scope = &self.scopes[len - scope_count];\n@@ -461,7 +463,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                               true));\n \n             // End all regions for scopes out of which we are breaking.\n-            self.cfg.push_end_region(block, src_info, scope.extent);\n+            self.cfg.push_end_region(block, src_info, scope.region_scope);\n         }\n \n         self.cfg.terminate(block, src_info, TerminatorKind::GeneratorDrop);\n@@ -486,12 +488,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// resolving `break` and `continue`.\n     pub fn find_breakable_scope(&mut self,\n                            span: Span,\n-                           label: CodeExtent)\n+                           label: region::Scope)\n                            -> &mut BreakableScope<'tcx> {\n         // find the loop-scope with the correct id\n         self.breakable_scopes.iter_mut()\n             .rev()\n-            .filter(|breakable_scope| breakable_scope.extent == label)\n+            .filter(|breakable_scope| breakable_scope.region_scope == label)\n             .next()\n             .unwrap_or_else(|| span_bug!(span, \"no enclosing breakable scope found\"))\n     }\n@@ -504,23 +506,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns the extent of the scope which should be exited by a\n+    /// Returns the `region::Scope` of the scope which should be exited by a\n     /// return.\n-    pub fn extent_of_return_scope(&self) -> CodeExtent {\n+    pub fn region_scope_of_return_scope(&self) -> region::Scope {\n         // The outermost scope (`scopes[0]`) will be the `CallSiteScope`.\n         // We want `scopes[1]`, which is the `ParameterScope`.\n         assert!(self.scopes.len() >= 2);\n-        assert!(match self.scopes[1].extent {\n-            CodeExtent::ParameterScope(_) => true,\n+        assert!(match self.scopes[1].region_scope {\n+            region::Scope::Arguments(_) => true,\n             _ => false,\n         });\n-        self.scopes[1].extent\n+        self.scopes[1].region_scope\n     }\n \n     /// Returns the topmost active scope, which is known to be alive until\n     /// the next scope expression.\n-    pub fn topmost_scope(&self) -> CodeExtent {\n-        self.scopes.last().expect(\"topmost_scope: no scopes present\").extent\n+    pub fn topmost_scope(&self) -> region::Scope {\n+        self.scopes.last().expect(\"topmost_scope: no scopes present\").region_scope\n     }\n \n     /// Returns the scope that we should use as the lifetime of an\n@@ -545,7 +547,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ///\n     /// When building statics/constants, returns `None` since\n     /// intermediate values do not have to be dropped in that case.\n-    pub fn local_scope(&self) -> Option<CodeExtent> {\n+    pub fn local_scope(&self) -> Option<region::Scope> {\n         match self.hir.src {\n             MirSource::Const(_) |\n             MirSource::Static(..) =>\n@@ -562,10 +564,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // Scheduling drops\n     // ================\n     /// Indicates that `lvalue` should be dropped on exit from\n-    /// `extent`.\n+    /// `region_scope`.\n     pub fn schedule_drop(&mut self,\n                          span: Span,\n-                         extent: CodeExtent,\n+                         region_scope: region::Scope,\n                          lvalue: &Lvalue<'tcx>,\n                          lvalue_ty: Ty<'tcx>) {\n         let needs_drop = self.hir.needs_drop(lvalue_ty);\n@@ -580,7 +582,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         for scope in self.scopes.iter_mut().rev() {\n-            let this_scope = scope.extent == extent;\n+            let this_scope = scope.region_scope == region_scope;\n             // When building drops, we try to cache chains of drops in such a way so these drops\n             // could be reused by the drops which would branch into the cached (already built)\n             // blocks.  This, however, means that whenever we add a drop into a scope which already\n@@ -633,9 +635,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if let DropKind::Value { .. } = drop_kind {\n                     scope.needs_cleanup = true;\n                 }\n-                let extent_span = extent.span(self.hir.tcx(), &self.hir.region_maps);\n+                let region_scope_span = region_scope.span(self.hir.tcx(),\n+                                                          &self.hir.region_scope_tree);\n                 // Attribute scope exit drops to scope's closing brace\n-                let scope_end = extent_span.with_lo(extent_span.hi());\n+                let scope_end = region_scope_span.with_lo(region_scope_span.hi());\n                 scope.drops.push(DropData {\n                     span: scope_end,\n                     location: lvalue.clone(),\n@@ -644,7 +647,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 return;\n             }\n         }\n-        span_bug!(span, \"extent {:?} not in scope to drop {:?}\", extent, lvalue);\n+        span_bug!(span, \"region scope {:?} not in scope to drop {:?}\", region_scope, lvalue);\n     }\n \n     // Other\n@@ -691,7 +694,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         for scope in scopes.iter_mut() {\n-            target = build_diverge_scope(cfg, scope.extent_span, scope, target, generator_drop);\n+            target = build_diverge_scope(cfg, scope.region_scope_span,\n+                                         scope, target, generator_drop);\n         }\n         Some(target)\n     }\n@@ -889,7 +893,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(cfg: &mut CFG<'tcx>,\n     // becomes trivial goto after pass that removes all EndRegions.)\n     {\n         let block = cfg.start_new_cleanup_block();\n-        cfg.push_end_region(block, source_info(span), scope.extent);\n+        cfg.push_end_region(block, source_info(span), scope.region_scope);\n         cfg.terminate(block, source_info(span), TerminatorKind::Goto { target: target });\n         target = block\n     }"}, {"sha": "3f815ec83e3a5e7854f6351c5a1b4d156255eaa7", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> BitDenotation for Borrows<'a, 'tcx> {\n         self.borrows.len()\n     }\n     fn start_block_effect(&self, _sets: &mut BlockSets<BorrowIndex>)  {\n-        // no borrows of code extents have been taken prior to\n+        // no borrows of code region_scopes have been taken prior to\n         // function execution, so this method has no effect on\n         // `_sets`.\n     }\n@@ -121,9 +121,9 @@ impl<'a, 'tcx> BitDenotation for Borrows<'a, 'tcx> {\n             panic!(\"could not find statement at location {:?}\");\n         });\n         match stmt.kind {\n-            mir::StatementKind::EndRegion(extent) => {\n-                let borrow_indexes = self.region_map.get(&ReScope(extent)).unwrap_or_else(|| {\n-                    panic!(\"could not find BorrowIndexs for code-extent {:?}\", extent);\n+            mir::StatementKind::EndRegion(region_scope) => {\n+                let borrow_indexes = self.region_map.get(&ReScope(region_scope)).unwrap_or_else(|| {\n+                    panic!(\"could not find BorrowIndexs for region scope {:?}\", region_scope);\n                 });\n \n                 for idx in borrow_indexes { sets.kill(&idx); }\n@@ -153,15 +153,15 @@ impl<'a, 'tcx> BitDenotation for Borrows<'a, 'tcx> {\n     fn terminator_effect(&self,\n                          _sets: &mut BlockSets<BorrowIndex>,\n                          _location: Location) {\n-        // no terminators start nor end code extents.\n+        // no terminators start nor end region scopes.\n     }\n \n     fn propagate_call_return(&self,\n                              _in_out: &mut IdxSet<BorrowIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              _dest_lval: &mir::Lvalue) {\n-        // there are no effects on the extents from method calls.\n+        // there are no effects on the region scopes from method calls.\n     }\n }\n "}, {"sha": "8b3031a3800a535ecea31a84e6a1cf3a3f5b95d9", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -11,7 +11,7 @@\n use hair::*;\n use hair::cx::Cx;\n use hair::cx::to_ref::ToRef;\n-use rustc::middle::region::{BlockRemainder, CodeExtent};\n+use rustc::middle::region::{self, BlockRemainder};\n use rustc::hir;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n@@ -21,11 +21,12 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n         // We have to eagerly translate the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n         let stmts = mirror_stmts(cx, self.hir_id.local_id, &*self.stmts);\n-        let opt_destruction_extent = cx.region_maps.opt_destruction_extent(self.hir_id.local_id);\n+        let opt_destruction_scope =\n+            cx.region_scope_tree.opt_destruction_scope(self.hir_id.local_id);\n         Block {\n             targeted_by_break: self.targeted_by_break,\n-            extent: CodeExtent::Misc(self.hir_id.local_id),\n-            opt_destruction_extent,\n+            region_scope: region::Scope::Node(self.hir_id.local_id),\n+            opt_destruction_scope,\n             span: self.span,\n             stmts,\n             expr: self.expr.to_ref(),\n@@ -40,16 +41,16 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n         let hir_id = cx.tcx.hir.node_to_hir_id(stmt.node.id());\n-        let opt_dxn_ext = cx.region_maps.opt_destruction_extent(hir_id.local_id);\n+        let opt_dxn_ext = cx.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n         match stmt.node {\n             hir::StmtExpr(ref expr, _) |\n             hir::StmtSemi(ref expr, _) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     kind: StmtKind::Expr {\n-                        scope: CodeExtent::Misc(hir_id.local_id),\n+                        scope: region::Scope::Node(hir_id.local_id),\n                         expr: expr.to_ref(),\n                     },\n-                    opt_destruction_extent: opt_dxn_ext,\n+                    opt_destruction_scope: opt_dxn_ext,\n                 })))\n             }\n             hir::StmtDecl(ref decl, _) => {\n@@ -58,7 +59,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         // ignore for purposes of the MIR\n                     }\n                     hir::DeclLocal(ref local) => {\n-                        let remainder_extent = CodeExtent::Remainder(BlockRemainder {\n+                        let remainder_scope = region::Scope::Remainder(BlockRemainder {\n                             block: block_id,\n                             first_statement_index: index as u32,\n                         });\n@@ -69,12 +70,12 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                                         &local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             kind: StmtKind::Let {\n-                                remainder_scope: remainder_extent,\n-                                init_scope: CodeExtent::Misc(hir_id.local_id),\n+                                remainder_scope: remainder_scope,\n+                                init_scope: region::Scope::Node(hir_id.local_id),\n                                 pattern,\n                                 initializer: local.init.to_ref(),\n                             },\n-                            opt_destruction_extent: opt_dxn_ext,\n+                            opt_destruction_scope: opt_dxn_ext,\n                         })));\n                     }\n                 }\n@@ -88,7 +89,7 @@ pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n     let block_ty = cx.tables().node_id_to_type(block.hir_id);\n-    let temp_lifetime = cx.region_maps.temporary_scope(block.hir_id.local_id);\n+    let temp_lifetime = cx.region_scope_tree.temporary_scope(block.hir_id.local_id);\n     let expr = Expr {\n         ty: block_ty,\n         temp_lifetime,"}, {"sha": "c96d42b94f97575c1e939a2bf380b70e8159315b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -25,8 +25,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n-        let temp_lifetime = cx.region_maps.temporary_scope(self.hir_id.local_id);\n-        let expr_extent = CodeExtent::Misc(self.hir_id.local_id);\n+        let temp_lifetime = cx.region_scope_tree.temporary_scope(self.hir_id.local_id);\n+        let expr_scope = region::Scope::Node(self.hir_id.local_id);\n \n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n@@ -46,19 +46,20 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             ty: expr.ty,\n             span: self.span,\n             kind: ExprKind::Scope {\n-                extent: expr_extent,\n+                region_scope: expr_scope,\n                 value: expr.to_ref(),\n             },\n         };\n \n         // Finally, create a destruction scope, if any.\n-        if let Some(extent) = cx.region_maps.opt_destruction_extent(self.hir_id.local_id) {\n+        if let Some(region_scope) =\n+                cx.region_scope_tree.opt_destruction_scope(self.hir_id.local_id) {\n             expr = Expr {\n                 temp_lifetime,\n                 ty: expr.ty,\n                 span: self.span,\n                 kind: ExprKind::Scope {\n-                    extent,\n+                    region_scope,\n                     value: expr.to_ref(),\n                 },\n             };\n@@ -125,7 +126,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // Convert this to a suitable `&foo` and\n             // then an unsafe coercion. Limit the region to be just this\n             // expression.\n-            let region = ty::ReScope(CodeExtent::Misc(hir_expr.hir_id.local_id));\n+            let region = ty::ReScope(region::Scope::Node(hir_expr.hir_id.local_id));\n             let region = cx.tcx.mk_region(region);\n             expr = Expr {\n                 temp_lifetime,\n@@ -160,7 +161,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n     let expr_ty = cx.tables().expr_ty(expr);\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n+    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n     let kind = match expr.node {\n         // Here comes the interesting stuff:\n@@ -487,7 +488,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(target_id) |\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(target_id)) => ExprKind::Break {\n-                    label: CodeExtent::Misc(cx.tcx.hir.node_to_hir_id(target_id).local_id),\n+                    label: region::Scope::Node(cx.tcx.hir.node_to_hir_id(target_id).local_id),\n                     value: value.to_ref(),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n@@ -498,7 +499,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(_) => bug!(\"cannot continue to blocks\"),\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => ExprKind::Continue {\n-                    label: CodeExtent::Misc(cx.tcx.hir.node_to_hir_id(loop_id).local_id),\n+                    label: region::Scope::Node(cx.tcx.hir.node_to_hir_id(loop_id).local_id),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n                     bug!(\"invalid loop id for continue: {}\", err)\n@@ -585,7 +586,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n                                  custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>)\n                                  -> Expr<'tcx> {\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n+    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n     let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n         (cx.tables().type_dependent_defs()[expr.hir_id].def_id(),\n          cx.tables().node_substs(expr.hir_id))\n@@ -676,7 +677,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                expr: &'tcx hir::Expr,\n                                def: Def)\n                                -> ExprKind<'tcx> {\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n+    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n     match def {\n         Def::Local(def_id) => {\n@@ -867,7 +868,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n+    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n     let fun = method_callee(cx, expr, custom_callee);\n     let ref_expr = Expr {\n         temp_lifetime,\n@@ -896,7 +897,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         closure_expr_id: cx.tcx.hir.local_def_id(closure_expr.id).index,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n-    let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.hir_id.local_id);\n+    let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n     let var_ty = cx.tables()\n                    .node_id_to_type(cx.tcx.hir.node_to_hir_id(var_node_id));\n     let captured_var = Expr {"}, {"sha": "3cabd8f18c19ebc2c9369bdec0f9f455f7a7bf22", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -22,7 +22,7 @@ use rustc_const_eval::ConstContext;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::middle::region::RegionMaps;\n+use rustc::middle::region;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -42,7 +42,7 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// Identity `Substs` for use with const-evaluation.\n     pub identity_substs: &'gcx Substs<'gcx>,\n \n-    pub region_maps: Rc<RegionMaps>,\n+    pub region_scope_tree: Rc<region::ScopeTree>,\n     pub tables: &'a ty::TypeckTables<'gcx>,\n \n     /// This is `Constness::Const` if we are compiling a `static`,\n@@ -92,7 +92,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             infcx,\n             param_env: tcx.param_env(src_def_id),\n             identity_substs: Substs::identity_for_item(tcx.global_tcx(), src_def_id),\n-            region_maps: tcx.region_maps(src_def_id),\n+            region_scope_tree: tcx.region_scope_tree(src_def_id),\n             tables: tcx.typeck_tables_of(src_def_id),\n             constness,\n             src,"}, {"sha": "067bd458d97ddb3e176a21a4064cef7a8028ac65", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -17,7 +17,7 @@\n use rustc_const_math::ConstUsize;\n use rustc::mir::{BinOp, BorrowKind, Field, Literal, UnOp};\n use rustc::hir::def_id::DefId;\n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtDef, ClosureSubsts, Region, Ty, GeneratorInterior};\n use rustc::hir;\n@@ -32,8 +32,8 @@ pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPatt\n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n     pub targeted_by_break: bool,\n-    pub extent: CodeExtent,\n-    pub opt_destruction_extent: Option<CodeExtent>,\n+    pub region_scope: region::Scope,\n+    pub opt_destruction_scope: Option<region::Scope>,\n     pub span: Span,\n     pub stmts: Vec<StmtRef<'tcx>>,\n     pub expr: Option<ExprRef<'tcx>>,\n@@ -47,14 +47,14 @@ pub enum StmtRef<'tcx> {\n #[derive(Clone, Debug)]\n pub struct Stmt<'tcx> {\n     pub kind: StmtKind<'tcx>,\n-    pub opt_destruction_extent: Option<CodeExtent>,\n+    pub opt_destruction_scope: Option<region::Scope>,\n }\n \n #[derive(Clone, Debug)]\n pub enum StmtKind<'tcx> {\n     Expr {\n         /// scope for this statement; may be used as lifetime of temporaries\n-        scope: CodeExtent,\n+        scope: region::Scope,\n \n         /// expression being evaluated in this statement\n         expr: ExprRef<'tcx>,\n@@ -63,11 +63,11 @@ pub enum StmtKind<'tcx> {\n     Let {\n         /// scope for variables bound in this let; covers this and\n         /// remaining statements in block\n-        remainder_scope: CodeExtent,\n+        remainder_scope: region::Scope,\n \n         /// scope for the initialization itself; might be used as\n         /// lifetime of temporaries\n-        init_scope: CodeExtent,\n+        init_scope: region::Scope,\n \n         /// let <PAT> = ...\n         pattern: Pattern<'tcx>,\n@@ -98,7 +98,7 @@ pub struct Expr<'tcx> {\n \n     /// lifetime of this expression if it should be spilled into a\n     /// temporary; should be None only if in a constant context\n-    pub temp_lifetime: Option<CodeExtent>,\n+    pub temp_lifetime: Option<region::Scope>,\n \n     /// span of the expression in the source\n     pub span: Span,\n@@ -110,7 +110,7 @@ pub struct Expr<'tcx> {\n #[derive(Clone, Debug)]\n pub enum ExprKind<'tcx> {\n     Scope {\n-        extent: CodeExtent,\n+        region_scope: region::Scope,\n         value: ExprRef<'tcx>,\n     },\n     Box {\n@@ -207,11 +207,11 @@ pub enum ExprKind<'tcx> {\n         arg: ExprRef<'tcx>,\n     },\n     Break {\n-        label: CodeExtent,\n+        label: region::Scope,\n         value: Option<ExprRef<'tcx>>,\n     },\n     Continue {\n-        label: CodeExtent,\n+        label: region::Scope,\n     },\n     Return {\n         value: Option<ExprRef<'tcx>>,"}, {"sha": "8fad538af97ba68cff53c6f5ea2c9a50747437aa", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::{self, TyCtxt, RegionKind};\n use rustc::hir;\n use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource};\n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region;\n \n pub struct AddValidation;\n \n@@ -27,7 +27,7 @@ fn lval_context<'a, 'tcx, D>(\n     lval: &Lvalue<'tcx>,\n     local_decls: &D,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>\n-) -> (Option<CodeExtent>, hir::Mutability)\n+) -> (Option<region::Scope>, hir::Mutability)\n     where D: HasLocalDecls<'tcx>\n {\n     use rustc::mir::Lvalue::*;"}, {"sha": "55a16b2f39161c0c9c7b43c7de331af9694a2875", "filename": "src/librustc_mir/transform/clean_end_regions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -21,7 +21,7 @@\n \n use rustc_data_structures::fx::FxHashSet;\n \n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region;\n use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::{BasicBlock, Location, Mir, Rvalue, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, Visitor, Lookup};\n@@ -30,11 +30,11 @@ use rustc::ty::{Ty, RegionKind, TyCtxt};\n pub struct CleanEndRegions;\n \n struct GatherBorrowedRegions {\n-    seen_regions: FxHashSet<CodeExtent>,\n+    seen_regions: FxHashSet<region::Scope>,\n }\n \n struct DeleteTrivialEndRegions<'a> {\n-    seen_regions: &'a FxHashSet<CodeExtent>,\n+    seen_regions: &'a FxHashSet<region::Scope>,\n }\n \n impl MirPass for CleanEndRegions {\n@@ -84,8 +84,8 @@ impl<'a, 'tcx> MutVisitor<'tcx> for DeleteTrivialEndRegions<'a> {\n                        location: Location) {\n         let mut delete_it = false;\n \n-        if let StatementKind::EndRegion(ref extent) = statement.kind {\n-            if !self.seen_regions.contains(extent) {\n+        if let StatementKind::EndRegion(ref region_scope) = statement.kind {\n+            if !self.seen_regions.contains(region_scope) {\n                 delete_it = true;\n             }\n         }"}, {"sha": "b4f4f565191213de941f2a217c7d5d279d23ed47", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -143,8 +143,8 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n \n         let tcx = self.tcx;\n         let param_env = self.param_env;\n-        let region_maps = self.tcx.region_maps(item_def_id);\n-        euv::ExprUseVisitor::new(self, tcx, param_env, &region_maps, self.tables)\n+        let region_scope_tree = self.tcx.region_scope_tree(item_def_id);\n+        euv::ExprUseVisitor::new(self, tcx, param_env, &region_scope_tree, self.tables)\n             .consume_body(body);\n \n         self.visit_body(body);"}, {"sha": "b21d48886120caa6ae03d8d3e9f2dd1e21571b65", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -11,7 +11,7 @@\n use rustc::hir::{self, ImplItemKind, TraitItemKind};\n use rustc::infer::{self, InferOk};\n use rustc::middle::free_region::FreeRegionMap;\n-use rustc::middle::region::RegionMaps;\n+use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n@@ -340,10 +340,12 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // region obligations that get overlooked.  The right\n             // thing to do is the code below. But we keep this old\n             // pass around temporarily.\n-            let region_maps = RegionMaps::default();\n+            let region_scope_tree = region::ScopeTree::default();\n             let mut free_regions = FreeRegionMap::new();\n             free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n-            infcx.resolve_regions_and_report_errors(impl_m.def_id, &region_maps, &free_regions);\n+            infcx.resolve_regions_and_report_errors(impl_m.def_id,\n+                                                    &region_scope_tree,\n+                                                    &free_regions);\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, impl_m_node_id);\n             fcx.regionck_item(impl_m_node_id, impl_m_span, &[]);"}, {"sha": "9bee26a52c0d7777b96192047931591418fd686b", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -13,7 +13,7 @@ use check::regionck::RegionCtxt;\n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferOk};\n-use rustc::middle::region::{self, RegionMaps};\n+use rustc::middle::region;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, ObligationCause};\n@@ -114,9 +114,9 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n             return Err(ErrorReported);\n         }\n \n-        let region_maps = RegionMaps::default();\n+        let region_scope_tree = region::ScopeTree::default();\n         let free_regions = FreeRegionMap::new();\n-        infcx.resolve_regions_and_report_errors(drop_impl_did, &region_maps, &free_regions);\n+        infcx.resolve_regions_and_report_errors(drop_impl_did, &region_scope_tree, &free_regions);\n         Ok(())\n     })\n }\n@@ -270,14 +270,14 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'gcx, 'tcx>,\n     ty: ty::Ty<'tcx>,\n     span: Span,\n-    scope: region::CodeExtent)\n+    scope: region::Scope)\n     -> Result<(), ErrorReported>\n {\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n            ty, scope);\n \n \n-    let parent_scope = match rcx.region_maps.opt_encl_scope(scope) {\n+    let parent_scope = match rcx.region_scope_tree.opt_encl_scope(scope) {\n         Some(parent_scope) => parent_scope,\n         // If no enclosing scope, then it must be the root scope\n         // which cannot be outlived."}, {"sha": "88219566792b6df15757a21e5ed5338c1942e5c8", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -16,7 +16,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Body, Pat, PatKind, Expr};\n-use rustc::middle::region::{RegionMaps, CodeExtent};\n+use rustc::middle::region;\n use rustc::ty::Ty;\n use std::rc::Rc;\n use super::FnCtxt;\n@@ -25,15 +25,15 @@ use util::nodemap::FxHashMap;\n struct InteriorVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     types: FxHashMap<Ty<'tcx>, usize>,\n-    region_maps: Rc<RegionMaps>,\n+    region_scope_tree: Rc<region::ScopeTree>,\n }\n \n impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n-    fn record(&mut self, ty: Ty<'tcx>, scope: Option<CodeExtent>, expr: Option<&'tcx Expr>) {\n+    fn record(&mut self, ty: Ty<'tcx>, scope: Option<region::Scope>, expr: Option<&'tcx Expr>) {\n         use syntax_pos::DUMMY_SP;\n \n         let live_across_yield = scope.map_or(Some(DUMMY_SP), |s| {\n-            self.region_maps.yield_in_scope(s)\n+            self.region_scope_tree.yield_in_scope(s)\n         });\n \n         if let Some(span) = live_across_yield {\n@@ -59,7 +59,7 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     let mut visitor = InteriorVisitor {\n         fcx,\n         types: FxHashMap(),\n-        region_maps: fcx.tcx.region_maps(def_id),\n+        region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n     };\n     intravisit::walk_body(&mut visitor, body);\n \n@@ -93,7 +93,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &'tcx Pat) {\n         if let PatKind::Binding(..) = pat.node {\n-            let scope = self.region_maps.var_scope(pat.hir_id.local_id);\n+            let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id);\n             let ty = self.fcx.tables.borrow().pat_ty(pat);\n             self.record(ty, Some(scope), None);\n         }\n@@ -102,7 +102,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        let scope = self.region_maps.temporary_scope(expr.hir_id.local_id);\n+        let scope = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n         let ty = self.fcx.tables.borrow().expr_ty_adjusted(expr);\n         self.record(ty, scope, Some(expr));\n "}, {"sha": "9d088c660451b80226195e029c1b3863f574933a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -91,7 +91,7 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_back::slice::ref_slice;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n use rustc::infer::type_variable::{TypeVariableOrigin};\n-use rustc::middle::region::CodeExtent;\n+use rustc::middle::region;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n use rustc::ty::{ParamTy, LvaluePreference, NoPreference, PreferMutLvalue};\n@@ -608,7 +608,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         let body_id = item_id.and_then(|id| tcx.hir.maybe_body_owned_by(id));\n         let implicit_region_bound = body_id.map(|body_id| {\n             let body = tcx.hir.body(body_id);\n-            tcx.mk_region(ty::ReScope(CodeExtent::CallSiteScope(body.value.hir_id.local_id)))\n+            tcx.mk_region(ty::ReScope(region::Scope::CallSite(body.value.hir_id.local_id)))\n         });\n \n         Inherited {"}, {"sha": "d475c37ed8c94ee0d9f79c5110eb894b02792bf6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -87,7 +87,7 @@ use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n-use middle::region::{CodeExtent, RegionMaps};\n+use middle::region;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n@@ -179,15 +179,15 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n \n-    pub region_maps: Rc<RegionMaps>,\n+    pub region_scope_tree: Rc<region::ScopeTree>,\n \n     free_region_map: FreeRegionMap<'tcx>,\n \n     // id of innermost fn body id\n     body_id: ast::NodeId,\n \n     // call_site scope of innermost fn\n-    call_site_scope: Option<CodeExtent>,\n+    call_site_scope: Option<region::Scope>,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n@@ -230,10 +230,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                RepeatingScope(initial_repeating_scope): RepeatingScope,\n                initial_body_id: ast::NodeId,\n                Subject(subject): Subject) -> RegionCtxt<'a, 'gcx, 'tcx> {\n-        let region_maps = fcx.tcx.region_maps(subject);\n+        let region_scope_tree = fcx.tcx.region_scope_tree(subject);\n         RegionCtxt {\n             fcx,\n-            region_maps,\n+            region_scope_tree,\n             repeating_scope: initial_repeating_scope,\n             body_id: initial_body_id,\n             call_site_scope: None,\n@@ -243,8 +243,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn set_call_site_scope(&mut self, call_site_scope: Option<CodeExtent>)\n-                           -> Option<CodeExtent> {\n+    fn set_call_site_scope(&mut self, call_site_scope: Option<region::Scope>)\n+                           -> Option<region::Scope> {\n         mem::replace(&mut self.call_site_scope, call_site_scope)\n     }\n \n@@ -305,7 +305,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let body_id = body.id();\n \n-        let call_site = CodeExtent::CallSiteScope(body.value.hir_id.local_id);\n+        let call_site = region::Scope::CallSite(body.value.hir_id.local_id);\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let old_body_id = self.set_body_id(body_id.node_id);\n         self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n-        self.link_fn_args(CodeExtent::Misc(body.value.hir_id.local_id), &body.arguments);\n+        self.link_fn_args(region::Scope::Node(body.value.hir_id.local_id), &body.arguments);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n@@ -580,7 +580,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn resolve_regions_and_report_errors(&self) {\n         self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n-                                                   &self.region_maps,\n+                                                   &self.region_scope_tree,\n                                                    &self.free_region_map);\n     }\n \n@@ -611,7 +611,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // variable's type enclose at least the variable's scope.\n \n             let hir_id = self.tcx.hir.node_to_hir_id(id);\n-            let var_scope = self.region_maps.var_scope(hir_id.local_id);\n+            let var_scope = self.region_scope_tree.var_scope(hir_id.local_id);\n             let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n \n             let origin = infer::BindingTypeIsNotValidAtDecl(span);\n@@ -668,7 +668,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // scope of that expression. This also guarantees basic WF.\n         let expr_ty = self.resolve_node_type(expr.hir_id);\n         // the region corresponding to this expression\n-        let expr_region = self.tcx.mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n+        let expr_region = self.tcx.mk_region(ty::ReScope(\n+            region::Scope::Node(expr.hir_id.local_id)));\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                                expr_ty, expr_region);\n \n@@ -950,7 +951,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // call occurs.\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n-        let callee_scope = CodeExtent::Misc(call_expr.hir_id.local_id);\n+        let callee_scope = region::Scope::Node(call_expr.hir_id.local_id);\n         let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n         debug!(\"callee_region={:?}\", callee_region);\n@@ -979,7 +980,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         where F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'gcx, 'tcx>) -> R\n     {\n         f(mc::MemCategorizationContext::with_infer(&self.infcx,\n-                                                   &self.region_maps,\n+                                                   &self.region_scope_tree,\n                                                    &self.tables.borrow()))\n     }\n \n@@ -1002,7 +1003,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // expression.\n         self.check_safety_of_rvalue_destructor_if_necessary(cmt.clone(), expr.span);\n \n-        let expr_region = self.tcx.mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n+        let expr_region = self.tcx.mk_region(ty::ReScope(\n+            region::Scope::Node(expr.hir_id.local_id)));\n         for adjustment in adjustments {\n             debug!(\"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n                    adjustment, cmt);\n@@ -1095,7 +1097,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n                self.ty_to_string(indexed_ty));\n \n-        let r_index_expr = ty::ReScope(CodeExtent::Misc(index_expr.hir_id.local_id));\n+        let r_index_expr = ty::ReScope(region::Scope::Node(index_expr.hir_id.local_id));\n         if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n             match mt.ty.sty {\n                 ty::TySlice(_) | ty::TyStr => {\n@@ -1176,7 +1178,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n+    fn link_fn_args(&self, body_scope: region::Scope, args: &[hir::Arg]) {\n         debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n         for arg in args {\n             let arg_ty = self.node_ty(arg.hir_id);\n@@ -1232,7 +1234,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n-                let r = self.tcx.mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n+                let r = self.tcx.mk_region(ty::ReScope(region::Scope::Node(expr.hir_id.local_id)));\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n         }"}, {"sha": "82d1210f42b2ecf5711c2e052ad39aee8a4a3d9e", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         {\n             let body_owner_def_id = self.tcx.hir.body_owner_def_id(body.id());\n-            let region_maps = &self.tcx.region_maps(body_owner_def_id);\n+            let region_scope_tree = &self.tcx.region_scope_tree(body_owner_def_id);\n             let mut delegate = InferBorrowKind {\n                 fcx: self,\n                 adjust_closure_kinds: FxHashMap(),\n@@ -161,7 +161,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             euv::ExprUseVisitor::with_infer(&mut delegate,\n                                             &self.infcx,\n                                             self.param_env,\n-                                            region_maps,\n+                                            region_scope_tree,\n                                             &self.tables.borrow())\n                 .consume_body(body);\n "}, {"sha": "b421fdfe8d8133e2eeeac844ad0278dac57cace7", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -12,7 +12,7 @@\n //! up data structures required by type-checking/translation.\n \n use rustc::middle::free_region::FreeRegionMap;\n-use rustc::middle::region::RegionMaps;\n+use rustc::middle::region;\n use rustc::middle::lang_items::UnsizeTraitLangItem;\n \n use rustc::traits::{self, ObligationCause};\n@@ -390,10 +390,10 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Finally, resolve all regions.\n-        let region_maps = RegionMaps::default();\n+        let region_scope_tree = region::ScopeTree::default();\n         let mut free_regions = FreeRegionMap::new();\n         free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n-        infcx.resolve_regions_and_report_errors(impl_did, &region_maps, &free_regions);\n+        infcx.resolve_regions_and_report_errors(impl_did, &region_scope_tree, &free_regions);\n \n         CoerceUnsizedInfo {\n             custom_kind: kind"}, {"sha": "54409d3543ebc2453bafc98119c7626c5d31706f", "filename": "src/test/mir-opt/end_region_1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_1.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -22,16 +22,16 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let _1: i32;\n-//     let _2: &'10_1rce i32;\n+//     let _2: &'10_1rs i32;\n //\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = const 3i32;\n //         StorageLive(_2);\n-//         _2 = &'10_1rce _1;\n+//         _2 = &'10_1rs _1;\n //         _0 = ();\n //         StorageDead(_2);\n-//         EndRegion('10_1rce);\n+//         EndRegion('10_1rs);\n //         StorageDead(_1);\n //         return;\n //     }"}, {"sha": "b37bd4188d9707a0409c5cd78c3a2c5418e9a1ac", "filename": "src/test/mir-opt/end_region_2.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_2.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -27,8 +27,8 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let _2: bool;\n-//     let _3: &'23_1rce bool;\n-//     let _7: &'23_3rce bool;\n+//     let _3: &'23_1rs bool;\n+//     let _7: &'23_3rs bool;\n //     let mut _4: ();\n //     let mut _5: bool;\n //     bb0: {\n@@ -38,7 +38,7 @@ fn main() {\n //         StorageLive(_2);\n //         _2 = const true;\n //         StorageLive(_3);\n-//         _3 = &'23_1rce _2;\n+//         _3 = &'23_1rs _2;\n //         StorageLive(_5);\n //         _5 = _2;\n //         switchInt(_5) -> [0u8: bb3, otherwise: bb2];\n@@ -47,19 +47,19 @@ fn main() {\n //         _0 = ();\n //         StorageDead(_5);\n //         StorageDead(_3);\n-//         EndRegion('23_1rce);\n+//         EndRegion('23_1rs);\n //         StorageDead(_2);\n //         return;\n //     }\n //     bb3: {\n //         StorageDead(_5);\n //         StorageLive(_7);\n-//         _7 = &'23_3rce _2;\n+//         _7 = &'23_3rs _2;\n //         _1 = ();\n //         StorageDead(_7);\n-//         EndRegion('23_3rce);\n+//         EndRegion('23_3rs);\n //         StorageDead(_3);\n-//         EndRegion('23_1rce);\n+//         EndRegion('23_1rs);\n //         StorageDead(_2);\n //         goto -> bb1;\n //     }"}, {"sha": "be9fc579ab6361446c322e0cac1c5ca1a63b787c", "filename": "src/test/mir-opt/end_region_3.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_3.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -28,8 +28,8 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let mut _1: bool;\n-//     let _3: &'26_1rce bool;\n-//     let _7: &'26_3rce bool;\n+//     let _3: &'26_1rs bool;\n+//     let _7: &'26_3rs bool;\n //     let mut _2: ();\n //     let mut _4: ();\n //     let mut _5: bool;\n@@ -41,7 +41,7 @@ fn main() {\n //     bb1: {\n //         _1 = const true;\n //         StorageLive(_3);\n-//         _3 = &'26_1rce _1;\n+//         _3 = &'26_1rs _1;\n //         StorageLive(_5);\n //         _5 = _1;\n //         switchInt(_5) -> [0u8: bb3, otherwise: bb2];\n@@ -50,20 +50,20 @@ fn main() {\n //         _0 = ();\n //         StorageDead(_5);\n //         StorageDead(_3);\n-//         EndRegion('26_1rce);\n+//         EndRegion('26_1rs);\n //         StorageDead(_1);\n //         return;\n //     }\n //     bb3: {\n //         _4 = ();\n //         StorageDead(_5);\n //         StorageLive(_7);\n-//         _7 = &'26_3rce _1;\n+//         _7 = &'26_3rs _1;\n //         _2 = ();\n //         StorageDead(_7);\n-//         EndRegion('26_3rce);\n+//         EndRegion('26_3rs);\n //         StorageDead(_3);\n-//         EndRegion('26_1rce);\n+//         EndRegion('26_1rs);\n //         goto -> bb1;\n //     }\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "58ce1ed5b84b7bf0d6e1969af52360b4fc9c45eb", "filename": "src/test/mir-opt/end_region_4.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_4.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -33,8 +33,8 @@ fn foo(i: i32) {\n //     let mut _0: ();\n //     let _1: D;\n //     let _2: i32;\n-//     let _3: &'26_2rce i32;\n-//     let _6: &'26_4rce i32;\n+//     let _3: &'26_2rs i32;\n+//     let _6: &'26_4rs i32;\n //     let mut _4: ();\n //     let mut _5: i32;\n //     bb0: {\n@@ -43,28 +43,28 @@ fn foo(i: i32) {\n //         StorageLive(_2);\n //         _2 = const 0i32;\n //         StorageLive(_3);\n-//         _3 = &'26_2rce _2;\n+//         _3 = &'26_2rs _2;\n //         StorageLive(_5);\n //         _5 = (*_3);\n //         _4 = const foo(_5) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n //         StorageDead(_5);\n //         StorageLive(_6);\n-//         _6 = &'26_4rce _2;\n+//         _6 = &'26_4rs _2;\n //         _0 = ();\n //         StorageDead(_6);\n-//         EndRegion('26_4rce);\n+//         EndRegion('26_4rs);\n //         StorageDead(_3);\n-//         EndRegion('26_2rce);\n+//         EndRegion('26_2rs);\n //         StorageDead(_2);\n //         drop(_1) -> bb4;\n //     }\n //     bb2: {\n //         resume;\n //     }\n //     bb3: {\n-//         EndRegion('26_2rce);\n+//         EndRegion('26_2rs);\n //         drop(_1) -> bb2;\n //     }\n //     bb4: {"}, {"sha": "be62a5473a6ffb9f4d6f032e805cad03da88140c", "filename": "src/test/mir-opt/end_region_5.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_5.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -31,29 +31,29 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _0: ();\n //     let _1: D;\n //     let mut _2: ();\n-//     let mut _3: [closure@NodeId(18) d:&'14mce D];\n-//     let mut _4: &'14mce D;\n+//     let mut _3: [closure@NodeId(18) d:&'14s D];\n+//     let mut _4: &'14s D;\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = &'14mce _1;\n+//         _4 = &'14s _1;\n //         _3 = [closure@NodeId(18)] { d: _4 };\n //         StorageDead(_4);\n //         _2 = const foo(_3) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n //         StorageDead(_3);\n-//         EndRegion('14mce);\n+//         EndRegion('14s);\n //         _0 = ();\n //         drop(_1) -> bb4;\n //     }\n //     bb2: {\n //         resume;\n //     }\n //     bb3: {\n-//         EndRegion('14mce);\n+//         EndRegion('14s);\n //         drop(_1) -> bb2;\n //     }\n //     bb4: {\n@@ -64,13 +64,13 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.node18.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(18) d:&'14mce D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(18) d:&'14s D]) -> i32 {\n //    let mut _0: i32;\n //    let mut _2: i32;\n //\n //    bb0: {\n //        StorageLive(_2);\n-//        _2 = ((*(_1.0: &'14mce D)).0: i32);\n+//        _2 = ((*(_1.0: &'14s D)).0: i32);\n //        _0 = _2;\n //        StorageDead(_2);\n //        return;"}, {"sha": "23b92583a11daab62bc21c5f3705be7922acb3ef", "filename": "src/test/mir-opt/end_region_6.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_6.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -31,29 +31,29 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _0: ();\n //     let _1: D;\n //     let mut _2: ();\n-//     let mut _3: [closure@NodeId(22) d:&'19mce D];\n-//     let mut _4: &'19mce D;\n+//     let mut _3: [closure@NodeId(22) d:&'19s D];\n+//     let mut _4: &'19s D;\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = &'19mce _1;\n+//         _4 = &'19s _1;\n //         _3 = [closure@NodeId(22)] { d: _4 };\n //         StorageDead(_4);\n //         _2 = const foo(_3) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n //         StorageDead(_3);\n-//         EndRegion('19mce);\n+//         EndRegion('19s);\n //         _0 = ();\n //         drop(_1) -> bb4;\n //     }\n //     bb2: {\n //         resume;\n //     }\n //     bb3: {\n-//         EndRegion('19mce);\n+//         EndRegion('19s);\n //         drop(_1) -> bb2;\n //     }\n //     bb4: {\n@@ -63,20 +63,20 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(22) d:&'19mce D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(22) d:&'19s D]) -> i32 {\n //     let mut _0: i32;\n-//     let _2: &'15_0rce D;\n+//     let _2: &'15_0rs D;\n //     let mut _3: i32;\n //\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = &'15_0rce (*(_1.0: &'19mce D));\n+//         _2 = &'15_0rs (*(_1.0: &'19s D));\n //         StorageLive(_3);\n //         _3 = ((*_2).0: i32);\n //         _0 = _3;\n //         StorageDead(_3);\n //         StorageDead(_2);\n-//         EndRegion('15_0rce);\n+//         EndRegion('15_0rs);\n //         return;\n //     }\n // END rustc.node22.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "ee0615f2bb312b39cb8e675398677ea6b2a0e780", "filename": "src/test/mir-opt/end_region_7.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -74,18 +74,18 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n // fn main::{{closure}}(_1: [closure@NodeId(22) d:D]) -> i32 {\n //     let mut _0: i32;\n-//     let _2: &'15_0rce D;\n+//     let _2: &'15_0rs D;\n //     let mut _3: i32;\n //\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = &'15_0rce (_1.0: D);\n+//         _2 = &'15_0rs (_1.0: D);\n //         StorageLive(_3);\n //         _3 = ((*_2).0: i32);\n //         _0 = _3;\n //         StorageDead(_3);\n //         StorageDead(_2);\n-//         EndRegion('15_0rce);\n+//         EndRegion('15_0rs);\n //         drop(_1) -> bb1;\n //     }\n //     bb1: {"}, {"sha": "ef184e39c0061529fe7faac6ed6cc293d76fcdd5", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -31,15 +31,15 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // fn main() -> () {\n //    let mut _0: ();\n //    let _1: D;\n-//    let _2: &'21_1rce D;\n+//    let _2: &'21_1rs D;\n //    let mut _3: ();\n-//    let mut _4: [closure@NodeId(22) r:&'21_1rce D];\n-//    let mut _5: &'21_1rce D;\n+//    let mut _4: [closure@NodeId(22) r:&'21_1rs D];\n+//    let mut _5: &'21_1rs D;\n //    bb0: {\n //        StorageLive(_1);\n //        _1 = D::{{constructor}}(const 0i32,);\n //        StorageLive(_2);\n-//        _2 = &'21_1rce _1;\n+//        _2 = &'21_1rs _1;\n //        StorageLive(_4);\n //        StorageLive(_5);\n //        _5 = _2;\n@@ -51,14 +51,14 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //        StorageDead(_4);\n //        _0 = ();\n //        StorageDead(_2);\n-//        EndRegion('21_1rce);\n+//        EndRegion('21_1rs);\n //        drop(_1) -> bb4;\n //    }\n //    bb2: {\n //        resume;\n //    }\n //    bb3: {\n-//        EndRegion('21_1rce);\n+//        EndRegion('21_1rs);\n //        drop(_1) -> bb2;\n //    }\n //    bb4: {\n@@ -69,13 +69,13 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(22) r:&'21_1rce D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(22) r:&'21_1rs D]) -> i32 {\n //     let mut _0: i32;\n //     let mut _2: i32;\n //\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = ((*(_1.0: &'21_1rce D)).0: i32);\n+//         _2 = ((*(_1.0: &'21_1rs D)).0: i32);\n //         _0 = _2;\n //         StorageDead(_2);\n //         return;"}, {"sha": "719bc3ff9dd04efa483d93e7af700b3dff688a92", "filename": "src/test/mir-opt/end_region_9.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fend_region_9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_9.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -42,7 +42,7 @@ fn main() {\n //     let mut _0: ();\n //     let mut _1: bool;\n //     let _2: i32;\n-//     let mut _4: &'13_0rce i32;\n+//     let mut _4: &'13_0rs i32;\n //     let mut _3: ();\n //     let mut _5: !;\n //     let mut _6: ();\n@@ -68,14 +68,14 @@ fn main() {\n //        _0 = ();\n //        StorageDead(_7);\n //        StorageDead(_4);\n-//        EndRegion('13_0rce);\n+//        EndRegion('13_0rs);\n //        StorageDead(_2);\n //        StorageDead(_1);\n //        return;\n //    }\n //\n //    bb3: {\n-//        _4 = &'13_0rce _2;\n+//        _4 = &'13_0rs _2;\n //        _6 = ();\n //        StorageDead(_7);\n //        _1 = const true;"}, {"sha": "2a36672a45774b4fec0758b70d7ef83140b7eb26", "filename": "src/test/mir-opt/issue-43457.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fissue-43457.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fissue-43457.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-43457.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -30,14 +30,14 @@ fn main() { }\n //     scope 1 {\n //         let _2: std::cell::RefCell<i32>;\n //     }\n-//     let mut _3: std::cell::RefMut<'17dce, i32>;\n-//     let mut _4: &'17dce std::cell::RefCell<i32>;\n+//     let mut _3: std::cell::RefMut<'17ds, i32>;\n+//     let mut _4: &'17ds std::cell::RefCell<i32>;\n //\n //     bb0: {\n //         StorageLive(_2);\n //         _2 = _1;\n //         StorageLive(_4);\n-//         _4 = &'17dce _2;\n+//         _4 = &'17ds _2;\n //         _3 = const <std::cell::RefCell<T>>::borrow_mut(_4) -> bb1;\n //     }\n //\n@@ -47,7 +47,7 @@ fn main() { }\n //\n //     bb2: {\n //         StorageDead(_4);\n-//         EndRegion('17dce);\n+//         EndRegion('17ds);\n //         _0 = ();\n //         StorageDead(_2);\n //         return;"}, {"sha": "ae9dcf8b7352df7ade54c3a59f1fc848abb032aa", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -37,19 +37,19 @@ fn main() {\n // START rustc.node23.EraseRegions.after.mir\n // fn main() -> () {\n //     bb0: {\n-//         Validate(Suspend(ReScope(Misc(ItemLocalId(10)))), [_1: i32]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(10)))), [_1: i32]);\n //         _6 = &ReErased mut _1;\n-//         Validate(Acquire, [(*_6): i32/ReScope(Misc(ItemLocalId(10)))]);\n-//         Validate(Suspend(ReScope(Misc(ItemLocalId(10)))), [(*_6): i32/ReScope(Misc(ItemLocalId(10)))]);\n+//         Validate(Acquire, [(*_6): i32/ReScope(Node(ItemLocalId(10)))]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(10)))), [(*_6): i32/ReScope(Node(ItemLocalId(10)))]);\n //         _5 = &ReErased mut (*_6);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Misc(ItemLocalId(10)))]);\n-//         Validate(Release, [_2: (), _3: &ReScope(Misc(ItemLocalId(10))) Test, _5: &ReScope(Misc(ItemLocalId(10))) mut i32]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(10)))]);\n+//         Validate(Release, [_2: (), _3: &ReScope(Node(ItemLocalId(10))) Test, _5: &ReScope(Node(ItemLocalId(10))) mut i32]);\n //         _2 = const Test::foo(_3, _5) -> bb1;\n //     }\n //\n //     bb1: {\n //         Validate(Acquire, [_2: ()]);\n-//         EndRegion(ReScope(Misc(ItemLocalId(10))));\n+//         EndRegion(ReScope(Node(ItemLocalId(10))));\n //         return;\n //     }\n // }"}, {"sha": "116e35b2d6f26952a870dbc11f095542d53b0dbf", "filename": "src/test/mir-opt/validate_3.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -32,17 +32,17 @@ fn main() {\n // fn main() -> () {\n //     let mut _5: &ReErased i32;\n //     bb0: {\n-//         Validate(Suspend(ReScope(Misc(ItemLocalId(17)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })) (imm)]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(17)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })) (imm)]);\n //         _5 = &ReErased ((*_2).0: i32);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Misc(ItemLocalId(17))) (imm)]);\n-//         Validate(Suspend(ReScope(Misc(ItemLocalId(17)))), [(*_5): i32/ReScope(Misc(ItemLocalId(17))) (imm)]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(17))) (imm)]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(17)))), [(*_5): i32/ReScope(Node(ItemLocalId(17))) (imm)]);\n //         _4 = &ReErased (*_5);\n-//         Validate(Acquire, [(*_4): i32/ReScope(Misc(ItemLocalId(17))) (imm)]);\n-//         Validate(Release, [_3: (), _4: &ReScope(Misc(ItemLocalId(17))) i32]);\n+//         Validate(Acquire, [(*_4): i32/ReScope(Node(ItemLocalId(17))) (imm)]);\n+//         Validate(Release, [_3: (), _4: &ReScope(Node(ItemLocalId(17))) i32]);\n //         _3 = const foo(_4) -> bb1;\n //     }\n //     bb1: {\n-//         EndRegion(ReScope(Misc(ItemLocalId(17))));\n+//         EndRegion(ReScope(Node(ItemLocalId(17))));\n //         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })));\n //         return;\n //     }"}, {"sha": "ef2073dcc4b0f3ccef3d9efbc33dad7074bcd197", "filename": "src/test/mir-opt/validate_5.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bdfd8a0036d3594efd9c90a328afa41a1ba359d/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=8bdfd8a0036d3594efd9c90a328afa41a1ba359d", "patch": "@@ -50,12 +50,12 @@ fn main() {\n //         _3 = _2;\n //         StorageLive(_4);\n //         StorageLive(_5);\n-//         Validate(Suspend(ReScope(Misc(ItemLocalId(9)))), [(*_3): i32]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(9)))), [(*_3): i32]);\n //         _5 = &ReErased mut (*_3);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Misc(ItemLocalId(9)))]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(9)))]);\n //         _4 = _5 as *mut i32 (Misc);\n //         StorageDead(_5);\n-//         EndRegion(ReScope(Misc(ItemLocalId(9))));\n+//         EndRegion(ReScope(Node(ItemLocalId(9))));\n //         Validate(Release, [_0: bool, _4: *mut i32]);\n //         _0 = const write_42(_4) -> bb1;\n //     }"}]}