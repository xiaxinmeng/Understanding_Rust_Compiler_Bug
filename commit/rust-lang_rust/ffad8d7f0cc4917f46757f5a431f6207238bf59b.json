{"sha": "ffad8d7f0cc4917f46757f5a431f6207238bf59b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmYWQ4ZDdmMGNjNDkxN2Y0Njc1N2Y1YTQzMWY2MjA3MjM4YmY1OWI=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-02-18T00:33:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-29T01:56:14Z"}, "message": "everything is laid out and working through a basic hw\n\nthe core impl is there, with a async handle in place\nto take incoming operations from user code. No actual\nuv handle/operations are implemented yet, though.", "tree": {"sha": "9886b90c1c311a31b94596e9150557bb08ac596f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9886b90c1c311a31b94596e9150557bb08ac596f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffad8d7f0cc4917f46757f5a431f6207238bf59b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffad8d7f0cc4917f46757f5a431f6207238bf59b", "html_url": "https://github.com/rust-lang/rust/commit/ffad8d7f0cc4917f46757f5a431f6207238bf59b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffad8d7f0cc4917f46757f5a431f6207238bf59b/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "418c6bcec35a5552f8732946819f792da75bf555", "url": "https://api.github.com/repos/rust-lang/rust/commits/418c6bcec35a5552f8732946819f792da75bf555", "html_url": "https://github.com/rust-lang/rust/commit/418c6bcec35a5552f8732946819f792da75bf555"}], "stats": {"total": 250, "additions": 250, "deletions": 0}, "files": [{"sha": "18d4904c22440766a2ab9ebcf48bdfca15818558", "filename": "src/libstd/uvtmp.rs", "status": "modified", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/ffad8d7f0cc4917f46757f5a431f6207238bf59b/src%2Flibstd%2Fuvtmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffad8d7f0cc4917f46757f5a431f6207238bf59b/src%2Flibstd%2Fuvtmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuvtmp.rs?ref=ffad8d7f0cc4917f46757f5a431f6207238bf59b", "patch": "@@ -1,5 +1,34 @@\n // Some temporary libuv hacks for servo\n \n+// UV2\n+enum uv_operation {\n+    op_hw()\n+}\n+\n+enum uv_msg {\n+    // requests from library users\n+    msg_run(comm::chan<bool>),\n+    msg_run_in_bg(),\n+    msg_loop_delete(),\n+    msg_async_init([u8], fn~()),\n+    msg_async_send([u8]),\n+    msg_hw(),\n+\n+    // dispatches from libuv\n+    uv_hw()\n+}\n+\n+type uv_loop_data = {\n+    operation_port: comm::port<uv_operation>,\n+    rust_loop_chan: comm::chan<uv_msg>\n+};\n+\n+type uv_loop = comm::chan<uv_msg>;\n+\n+enum uv_handle {\n+    handle([u8], *ctypes::void)\n+}\n+\n #[nolink]\n native mod rustrt {\n     fn rust_uvtmp_create_thread() -> thread;\n@@ -29,8 +58,177 @@ native mod rustrt {\n         chan: comm::chan<iomsg>);\n     fn rust_uvtmp_delete_buf(buf: *u8);\n     fn rust_uvtmp_get_req_id(cd: connect_data) -> u32;\n+\n+    fn rust_uvtmp_uv_loop_new() -> *ctypes::void;\n+    fn rust_uvtmp_uv_loop_set_data(\n+        loop: *ctypes::void,\n+        data: *uv_loop_data);\n+    fn rust_uvtmp_uv_bind_op_cb(loop: *ctypes::void, cb: *u8) -> *ctypes::void;\n+    fn rust_uvtmp_uv_run(loop_handle: *ctypes::void);\n+    fn rust_uvtmp_uv_async_send(handle: *ctypes::void);\n }\n \n+mod uv {\n+    export loop_new, run, run_in_bg, hw;\n+\n+    // public functions\n+    fn loop_new() -> uv_loop unsafe {\n+        let ret_recv_port: comm::port<uv_loop> =\n+            comm::port();\n+        let ret_recv_chan: comm::chan<uv_loop> =\n+            comm::chan(ret_recv_port);\n+\n+        task::spawn_sched(3u) {||\n+            // our beloved uv_loop_t ptr\n+            let loop_handle = rustrt::\n+                rust_uvtmp_uv_loop_new();\n+\n+            // this port/chan pair are used to send messages to\n+            // libuv. libuv processes any pending messages on the\n+            // port (via crust) after receiving an async \"wakeup\"\n+            // on a special uv_async_t handle created below\n+            let operation_port = comm::port::<uv_operation>();\n+            let operation_chan = comm::chan::<uv_operation>(\n+                operation_port);\n+\n+            // this port/chan pair as used in the while() loop\n+            // below. It takes dispatches, originating from libuv\n+            // callbacks, to invoke handles registered by the\n+            // user\n+            let rust_loop_port = comm::port::<uv_msg>();\n+            let rust_loop_chan =\n+                comm::chan::<uv_msg>(rust_loop_port);\n+            // let the task-spawner return\n+            comm::send(ret_recv_chan, copy(rust_loop_chan));\n+\n+            // create our \"special\" async handle that will\n+            // allow all operations against libuv to be\n+            // \"buffered\" in the operation_port, for processing\n+            // from the thread that libuv runs on\n+            let loop_data: uv_loop_data = {\n+                operation_port: operation_port,\n+                rust_loop_chan: rust_loop_chan\n+            };\n+            rustrt::rust_uvtmp_uv_loop_set_data(\n+                loop_handle,\n+                ptr::addr_of(loop_data)); // pass an opaque C-ptr\n+                                          // to libuv, this will be\n+                                          // in the process_operation\n+                                          // crust fn\n+            let async_handle = rustrt::rust_uvtmp_uv_bind_op_cb(\n+                loop_handle,\n+                process_operation);\n+\n+            // all state goes here\n+            let handles: map::map<[u8], uv_handle> =\n+                map::new_bytes_hash();\n+\n+            // the main loop that this task blocks on.\n+            // should have the same lifetime as the C libuv\n+            // event loop.\n+            let keep_going = true;\n+            while (keep_going) {\n+                alt comm::recv(rust_loop_port) {\n+                  msg_run(end_chan) {\n+                    // start the libuv event loop\n+                    // we'll also do a uv_async_send with\n+                    // the operation handle to have the\n+                    // loop process any pending operations\n+                    // once its up and running\n+                    task::spawn_sched(1u) {||\n+                        // this call blocks\n+                        rustrt::rust_uvtmp_uv_run(loop_handle);\n+                        // when we're done, msg the\n+                        // end chan\n+                        comm::send(end_chan, true);\n+                    };\n+                  }\n+                  msg_run_in_bg {\n+                    task::spawn_sched(1u) {||\n+                        // this call blocks\n+                        rustrt::rust_uvtmp_uv_run(loop_handle);\n+                    };\n+                  }\n+                  msg_hw() {\n+                    comm::send(operation_chan, op_hw);\n+                    io::println(\"CALLING ASYNC_SEND FOR HW\");\n+                    rustrt::rust_uvtmp_uv_async_send(async_handle);\n+                  }\n+                  uv_hw() {\n+                    io::println(\"HELLO WORLD!!!\");\n+                  }\n+\n+                  ////// STUBS ///////\n+                  msg_loop_delete {\n+                    // delete the event loop's c ptr\n+                    // this will of course stop any\n+                    // further processing\n+                  }\n+                  msg_async_init(id, callback) {\n+                    // create a new async handle\n+                    // with the id as the handle's\n+                    // data and save the callback for\n+                    // invocation on msg_async_send\n+                  }\n+                  msg_async_send(id) {\n+                    // get the callback matching the\n+                    // supplied id and invoke it\n+                  }\n+\n+                  _ { fail \"unknown form of uv_msg received\"; }\n+                }\n+            }\n+        };\n+        ret comm::recv(ret_recv_port);\n+    }\n+\n+    fn run(loop: uv_loop) {\n+        let end_port = comm::port::<bool>();\n+        let end_chan = comm::chan::<bool>(end_port);\n+        comm::send(loop, msg_run(end_chan));\n+        comm::recv(end_port);\n+    }\n+\n+    fn run_in_bg(loop: uv_loop) {\n+        comm::send(loop, msg_run_in_bg);\n+    }\n+\n+    fn hw(loop: uv_loop) {\n+        comm::send(loop, msg_hw);\n+    }\n+\n+    // internal functions\n+\n+    // crust\n+    crust fn process_operation(data: *uv_loop_data) unsafe {\n+        io::println(\"IN PROCESS_OPERATION\");\n+        let op_port = (*data).operation_port;\n+        let loop_chan = (*data).rust_loop_chan;\n+        let op_pending = comm::peek(op_port);\n+        while(op_pending) {\n+            io::println(\"OPERATION PENDING!\");\n+            alt comm::recv(op_port) {\n+              op_hw() {\n+                io::println(\"GOT OP_HW IN CRUST\");\n+                comm::send(loop_chan, uv_hw);\n+              }\n+              _ { fail \"unknown form of uv_operation received\"; }\n+            }\n+            op_pending = comm::peek(op_port);\n+        }\n+        io::println(\"NO MORE OPERATIONS PENDING!\");\n+    }\n+}\n+\n+#[test]\n+fn uvtmp_uv_test_hello_world() {\n+    let test_loop = uv::loop_new();\n+    uv::hw(test_loop);\n+    uv::run(test_loop);\n+}\n+\n+// END OF UV2\n+\n type thread = *ctypes::void;\n \n type connect_data = *ctypes::void;"}, {"sha": "4a8df1fa8863f306e0bf0c941d80fd6f264948c7", "filename": "src/rt/rust_uvtmp.cpp", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ffad8d7f0cc4917f46757f5a431f6207238bf59b/src%2Frt%2Frust_uvtmp.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ffad8d7f0cc4917f46757f5a431f6207238bf59b/src%2Frt%2Frust_uvtmp.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uvtmp.cpp?ref=ffad8d7f0cc4917f46757f5a431f6207238bf59b", "patch": "@@ -55,6 +55,58 @@ struct timer_start_data {\n     chan_handle chan;\n };\n \n+// UVTMP REWORK\n+\n+static void*\n+current_kernel_malloc(size_t size, const char* tag) {\n+  return rust_task_thread::get_task()->malloc(size, tag);\n+}\n+\n+/*\n+static void\n+current_kernel_free(void* ptr) {\n+  rust_task_thread::get_task()->free(ptr);\n+}\n+*/\n+\n+extern \"C\" void*\n+rust_uvtmp_uv_loop_new() {\n+    return (void*)uv_loop_new();\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_uv_loop_set_data(uv_loop_t* loop, void* data) {\n+    loop->data = data;\n+}\n+\n+typedef void (*async_op_cb)(void* data);\n+void native_async_op_cb(uv_async_t* handle, int status) {\n+    async_op_cb cb = (async_op_cb)handle->data;\n+\tvoid* loop_data = handle->loop->data;\n+\tcb(loop_data);\n+}\n+\n+extern \"C\" void*\n+rust_uvtmp_uv_bind_op_cb(uv_loop_t* loop, async_op_cb cb) {\n+    uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n+\t\tsizeof(uv_async_t),\n+\t\t\"uv_async_t\");\n+\tuv_async_init(loop, async, native_async_op_cb);\n+\tasync->data = (void*)cb;\n+\treturn async;\n+}\n+\n+extern \"C\" void rust_uvtmp_uv_run(uv_loop_t* loop) {\n+\tuv_run(loop);\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_uv_async_send(uv_async_t* handle) {\n+    uv_async_send(handle);\n+}\n+\n+// UVTMP REWORK\n+\n // FIXME: Copied from rust_builtins.cpp. Could bitrot easily\n static void\n send(rust_task *task, chan_handle chan, void *data) {"}]}