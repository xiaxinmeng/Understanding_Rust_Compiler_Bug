{"sha": "b2b88b326d476425f66d1def14aef3fd286d5aec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYjg4YjMyNmQ0NzY0MjVmNjZkMWRlZjE0YWVmM2ZkMjg2ZDVhZWM=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-11T13:47:52Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-11T13:54:35Z"}, "message": "dlist: Name the type DList for doubly-linked list", "tree": {"sha": "b43cf34337c96a73e25eccc94fd9d63d137a3e3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b43cf34337c96a73e25eccc94fd9d63d137a3e3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2b88b326d476425f66d1def14aef3fd286d5aec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b88b326d476425f66d1def14aef3fd286d5aec", "html_url": "https://github.com/rust-lang/rust/commit/b2b88b326d476425f66d1def14aef3fd286d5aec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2b88b326d476425f66d1def14aef3fd286d5aec/comments", "author": null, "committer": null, "parents": [{"sha": "a8e7bdd142e6cc0cac89a88eef3bbadceb5e6489", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e7bdd142e6cc0cac89a88eef3bbadceb5e6489", "html_url": "https://github.com/rust-lang/rust/commit/a8e7bdd142e6cc0cac89a88eef3bbadceb5e6489"}], "stats": {"total": 144, "additions": 72, "deletions": 72}, "files": [{"sha": "18629f8597c1cb41122890bc5b811a4e77aa0673", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b2b88b326d476425f66d1def14aef3fd286d5aec/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b88b326d476425f66d1def14aef3fd286d5aec/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=b2b88b326d476425f66d1def14aef3fd286d5aec", "patch": "@@ -10,13 +10,13 @@\n \n //! A doubly-linked list with owned nodes.\n //!\n-//! The List allows pushing and popping elements at either end.\n+//! The DList allows pushing and popping elements at either end.\n \n \n-// List is constructed like a singly-linked list over the field `next`.\n+// DList is constructed like a singly-linked list over the field `next`.\n // including the last link being None; each Node owns its `next` field.\n //\n-// Backlinks over List::prev are raw pointers that form a full chain in\n+// Backlinks over DList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n use std::cast;\n@@ -28,7 +28,7 @@ use std::iterator::FromIterator;\n use container::Deque;\n \n /// A doubly-linked list\n-pub struct List<T> {\n+pub struct DList<T> {\n     priv length: uint,\n     priv list_head: Link<T>,\n     priv list_tail: Rawlink<Node<T>>,\n@@ -43,42 +43,42 @@ struct Node<T> {\n     priv value: T,\n }\n \n-/// List iterator\n+/// DList iterator\n pub struct ForwardIterator<'self, T> {\n-    priv list: &'self List<T>,\n+    priv list: &'self DList<T>,\n     priv next: &'self Link<T>,\n     priv nelem: uint,\n }\n \n-/// List reverse iterator\n+/// DList reverse iterator\n pub struct ReverseIterator<'self, T> {\n-    priv list: &'self List<T>,\n+    priv list: &'self DList<T>,\n     priv next: Rawlink<Node<T>>,\n     priv nelem: uint,\n }\n \n-/// List mutable iterator\n+/// DList mutable iterator\n pub struct MutForwardIterator<'self, T> {\n-    priv list: &'self mut List<T>,\n+    priv list: &'self mut DList<T>,\n     priv curs: Rawlink<Node<T>>,\n     priv nelem: uint,\n }\n \n-/// List mutable reverse iterator\n+/// DList mutable reverse iterator\n pub struct MutReverseIterator<'self, T> {\n-    priv list: &'self mut List<T>,\n+    priv list: &'self mut DList<T>,\n     priv next: Rawlink<Node<T>>,\n     priv nelem: uint,\n }\n \n-/// List consuming iterator\n+/// DList consuming iterator\n pub struct ConsumeIterator<T> {\n-    priv list: List<T>\n+    priv list: DList<T>\n }\n \n-/// List reverse consuming iterator\n+/// DList reverse consuming iterator\n pub struct ConsumeRevIterator<T> {\n-    priv list: List<T>\n+    priv list: DList<T>\n }\n \n /// Rawlink is a type like Option<T> but for holding a raw pointer\n@@ -114,7 +114,7 @@ fn link_with_prev<T>(mut next: ~Node<T>, prev: Rawlink<Node<T>>) -> Link<T> {\n     Some(next)\n }\n \n-impl<T> Container for List<T> {\n+impl<T> Container for DList<T> {\n     /// O(1)\n     fn is_empty(&self) -> bool {\n         self.list_head.is_none()\n@@ -125,16 +125,16 @@ impl<T> Container for List<T> {\n     }\n }\n \n-impl<T> Mutable for List<T> {\n-    /// Remove all elements from the List\n+impl<T> Mutable for DList<T> {\n+    /// Remove all elements from the DList\n     ///\n     /// O(N)\n     fn clear(&mut self) {\n-        *self = List::new()\n+        *self = DList::new()\n     }\n }\n \n-impl<T> Deque<T> for List<T> {\n+impl<T> Deque<T> for DList<T> {\n     /// Provide a reference to the front element, or None if the list is empty\n     fn front<'a>(&'a self) -> Option<&'a T> {\n         self.list_head.chain_ref(|x| Some(&x.value))\n@@ -245,23 +245,23 @@ impl<T> Deque<T> for List<T> {\n     }\n }\n \n-impl<T> List<T> {\n-    /// Create an empty List\n+impl<T> DList<T> {\n+    /// Create an empty DList\n     #[inline]\n-    pub fn new() -> List<T> {\n-        List{list_head: None, list_tail: Rawlink::none(), length: 0}\n+    pub fn new() -> DList<T> {\n+        DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n \n     /// Add all elements from `other` to the end of the list\n     ///\n     /// O(1)\n-    pub fn append(&mut self, other: List<T>) {\n+    pub fn append(&mut self, other: DList<T>) {\n         match self.list_tail.resolve() {\n             None => *self = other,\n             Some(tail) => {\n                 match other {\n-                    List{list_head: None, list_tail: _, length: _} => return,\n-                    List{list_head: Some(node), list_tail: o_tail, length: o_length} => {\n+                    DList{list_head: None, list_tail: _, length: _} => return,\n+                    DList{list_head: Some(node), list_tail: o_tail, length: o_length} => {\n                         tail.next = link_with_prev(node, self.list_tail);\n                         self.list_tail = o_tail;\n                         self.length += o_length;\n@@ -274,7 +274,7 @@ impl<T> List<T> {\n     /// Add all elements from `other` to the beginning of the list\n     ///\n     /// O(1)\n-    pub fn prepend(&mut self, mut other: List<T>) {\n+    pub fn prepend(&mut self, mut other: DList<T>) {\n         util::swap(self, &mut other);\n         self.append(other);\n     }\n@@ -300,7 +300,7 @@ impl<T> List<T> {\n     /// Merge, using the function `f`; take `a` if `f(a, b)` is true, else `b`.\n     ///\n     /// O(max(N, M))\n-    pub fn merge(&mut self, mut other: List<T>, f: &fn(&T, &T) -> bool) {\n+    pub fn merge(&mut self, mut other: DList<T>, f: &fn(&T, &T) -> bool) {\n         {\n             let mut it = self.mut_iter();\n             loop {\n@@ -351,7 +351,7 @@ impl<T> List<T> {\n /// Insert sorted in ascending order\n ///\n /// O(N)\n-impl<T: cmp::TotalOrd> List<T> {\n+impl<T: cmp::TotalOrd> DList<T> {\n     fn insert_ordered(&mut self, elt: T) {\n         self.insert_when(elt, |a, b| a.cmp(b) != cmp::Less);\n     }\n@@ -445,7 +445,7 @@ impl<'self, A> Iterator<&'self mut A> for MutReverseIterator<'self, A> {\n     }\n }\n \n-/// Allow mutating the List while iterating\n+/// Allow mutating the DList while iterating\n pub trait ListInsertion<A> {\n     /// Insert `elt` just previous to the most recently yielded element\n     fn insert_before(&mut self, elt: A);\n@@ -497,32 +497,32 @@ impl<A> Iterator<A> for ConsumeRevIterator<A> {\n     }\n }\n \n-impl<A, T: Iterator<A>> FromIterator<A, T> for List<A> {\n-    fn from_iterator(iterator: &mut T) -> List<A> {\n-        let mut ret = List::new();\n+impl<A, T: Iterator<A>> FromIterator<A, T> for DList<A> {\n+    fn from_iterator(iterator: &mut T) -> DList<A> {\n+        let mut ret = DList::new();\n         for iterator.advance |elt| { ret.push_back(elt); }\n         ret\n     }\n }\n \n-impl<A: Eq> Eq for List<A> {\n-    fn eq(&self, other: &List<A>) -> bool {\n+impl<A: Eq> Eq for DList<A> {\n+    fn eq(&self, other: &DList<A>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n-    fn ne(&self, other: &List<A>) -> bool {\n+    fn ne(&self, other: &DList<A>) -> bool {\n         !self.eq(other)\n     }\n }\n \n-impl<A: Clone> Clone for List<A> {\n-    fn clone(&self) -> List<A> {\n+impl<A: Clone> Clone for DList<A> {\n+    fn clone(&self) -> DList<A> {\n         self.iter().transform(|x| x.clone()).collect()\n     }\n }\n \n #[cfg(test)]\n-pub fn check_links<T>(list: &List<T>) {\n+pub fn check_links<T>(list: &DList<T>) {\n     let mut len = 0u;\n     let mut last_ptr: Option<&Node<T>> = None;\n     let mut node_ptr: &Node<T>;\n@@ -563,7 +563,7 @@ mod tests {\n \n     #[test]\n     fn test_basic() {\n-        let mut m = List::new::<~int>();\n+        let mut m = DList::new::<~int>();\n         assert_eq!(m.pop_front(), None);\n         assert_eq!(m.pop_back(), None);\n         assert_eq!(m.pop_front(), None);\n@@ -582,7 +582,7 @@ mod tests {\n         m.push_back(~7);\n         assert_eq!(m.pop_front(), Some(~1));\n \n-        let mut n = List::new();\n+        let mut n = DList::new();\n         n.push_front(2);\n         n.push_front(3);\n         {\n@@ -602,29 +602,29 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn generate_test() -> List<int> {\n+    fn generate_test() -> DList<int> {\n         list_from(&[0,1,2,3,4,5,6])\n     }\n \n     #[cfg(test)]\n-    fn list_from<T: Copy>(v: &[T]) -> List<T> {\n+    fn list_from<T: Copy>(v: &[T]) -> DList<T> {\n         v.iter().transform(|x| copy *x).collect()\n     }\n \n     #[test]\n     fn test_append() {\n         {\n-            let mut m = List::new();\n-            let mut n = List::new();\n+            let mut m = DList::new();\n+            let mut n = DList::new();\n             n.push_back(2);\n             m.append(n);\n             assert_eq!(m.len(), 1);\n             assert_eq!(m.pop_back(), Some(2));\n             check_links(&m);\n         }\n         {\n-            let mut m = List::new();\n-            let n = List::new();\n+            let mut m = DList::new();\n+            let n = DList::new();\n             m.push_back(2);\n             m.append(n);\n             assert_eq!(m.len(), 1);\n@@ -647,8 +647,8 @@ mod tests {\n     #[test]\n     fn test_prepend() {\n         {\n-            let mut m = List::new();\n-            let mut n = List::new();\n+            let mut m = DList::new();\n+            let mut n = DList::new();\n             n.push_back(2);\n             m.prepend(n);\n             assert_eq!(m.len(), 1);\n@@ -674,7 +674,7 @@ mod tests {\n         for m.iter().enumerate().advance |(i, elt)| {\n             assert_eq!(i as int, *elt);\n         }\n-        let mut n = List::new();\n+        let mut n = DList::new();\n         assert_eq!(n.iter().next(), None);\n         n.push_front(4);\n         let mut it = n.iter();\n@@ -690,7 +690,7 @@ mod tests {\n         for m.rev_iter().enumerate().advance |(i, elt)| {\n             assert_eq!((6 - i) as int, *elt);\n         }\n-        let mut n = List::new();\n+        let mut n = DList::new();\n         assert_eq!(n.rev_iter().next(), None);\n         n.push_front(4);\n         let mut it = n.rev_iter();\n@@ -709,7 +709,7 @@ mod tests {\n             len -= 1;\n         }\n         assert_eq!(len, 0);\n-        let mut n = List::new();\n+        let mut n = DList::new();\n         assert!(n.mut_iter().next().is_none());\n         n.push_front(4);\n         let mut it = n.mut_iter();\n@@ -760,12 +760,12 @@ mod tests {\n \n     #[test]\n     fn test_insert_ordered() {\n-        let mut n = List::new();\n+        let mut n = DList::new();\n         n.insert_ordered(1);\n         assert_eq!(n.len(), 1);\n         assert_eq!(n.pop_front(), Some(1));\n \n-        let mut m = List::new();\n+        let mut m = DList::new();\n         m.push_back(2);\n         m.push_back(4);\n         m.insert_ordered(3);\n@@ -779,7 +779,7 @@ mod tests {\n         for m.mut_rev_iter().enumerate().advance |(i, elt)| {\n             assert_eq!((6-i) as int, *elt);\n         }\n-        let mut n = List::new();\n+        let mut n = DList::new();\n         assert!(n.mut_rev_iter().next().is_none());\n         n.push_front(4);\n         let mut it = n.mut_rev_iter();\n@@ -798,7 +798,7 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        let mut n: List<u8> = list_from([]);\n+        let mut n: DList<u8> = list_from([]);\n         let mut m = list_from([]);\n         assert_eq!(&n, &m);\n         n.push_front(1);\n@@ -818,7 +818,7 @@ mod tests {\n \n     #[cfg(test)]\n     fn fuzz_test(sz: int) {\n-        let mut m = List::new::<int>();\n+        let mut m = DList::new::<int>();\n         let mut v = ~[];\n         for int::range(0i, sz) |i| {\n             check_links(&m);\n@@ -857,7 +857,7 @@ mod tests {\n     fn bench_collect_into(b: &mut test::BenchHarness) {\n         let v = &[0, ..64];\n         do b.iter {\n-            let _: List<int> = v.iter().transform(|&x|x).collect();\n+            let _: DList<int> = v.iter().transform(|&x|x).collect();\n         }\n     }\n     #[bench]\n@@ -870,7 +870,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front(b: &mut test::BenchHarness) {\n-        let mut m = List::new::<int>();\n+        let mut m = DList::new::<int>();\n         do b.iter {\n             m.push_front(0);\n         }\n@@ -886,7 +886,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_back(b: &mut test::BenchHarness) {\n-        let mut m = List::new::<int>();\n+        let mut m = DList::new::<int>();\n         do b.iter {\n             m.push_back(0);\n         }\n@@ -901,7 +901,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::BenchHarness) {\n-        let mut m = List::new::<int>();\n+        let mut m = DList::new::<int>();\n         do b.iter {\n             m.push_back(0);\n             m.pop_back();\n@@ -919,31 +919,31 @@ mod tests {\n     #[bench]\n     fn bench_iter(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n-        let m: List<int> = v.iter().transform(|&x|x).collect();\n+        let m: DList<int> = v.iter().transform(|&x|x).collect();\n         do b.iter {\n             for m.iter().advance |_| {}\n         }\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n-        let mut m: List<int> = v.iter().transform(|&x|x).collect();\n+        let mut m: DList<int> = v.iter().transform(|&x|x).collect();\n         do b.iter {\n             for m.mut_iter().advance |_| {}\n         }\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n-        let m: List<int> = v.iter().transform(|&x|x).collect();\n+        let m: DList<int> = v.iter().transform(|&x|x).collect();\n         do b.iter {\n             for m.rev_iter().advance |_| {}\n         }\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n-        let mut m: List<int> = v.iter().transform(|&x|x).collect();\n+        let mut m: DList<int> = v.iter().transform(|&x|x).collect();\n         do b.iter {\n             for m.mut_rev_iter().advance |_| {}\n         }"}, {"sha": "9fec58e74958ee2a2c77ba9841e7e9f4dd5077bb", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2b88b326d476425f66d1def14aef3fd286d5aec/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b88b326d476425f66d1def14aef3fd286d5aec/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=b2b88b326d476425f66d1def14aef3fd286d5aec", "patch": "@@ -25,7 +25,7 @@ use std::uint;\n use std::vec;\n use ringbuf::RingBuf;\n use container::Deque;\n-use dlist::List;\n+use dlist::DList;\n use treemap::{TreeMap, TreeSet};\n \n pub trait Encoder {\n@@ -653,7 +653,7 @@ impl<\n impl<\n     S: Encoder,\n     T: Encodable<S> + Copy\n-> Encodable<S> for List<T> {\n+> Encodable<S> for DList<T> {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n@@ -665,9 +665,9 @@ impl<\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for List<T> {\n-    fn decode(d: &mut D) -> List<T> {\n-        let mut list = List::new();\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for DList<T> {\n+    fn decode(d: &mut D) -> DList<T> {\n+        let mut list = DList::new();\n         do d.read_seq |d, len| {\n             for uint::range(0, len) |i| {\n                 list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));"}]}