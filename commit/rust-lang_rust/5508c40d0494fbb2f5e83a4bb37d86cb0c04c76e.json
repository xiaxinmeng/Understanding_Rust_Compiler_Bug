{"sha": "5508c40d0494fbb2f5e83a4bb37d86cb0c04c76e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MDhjNDBkMDQ5NGZiYjJmNWU4M2E0YmIzN2Q4NmNiMGMwNGM3NmU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-03-15T14:23:10Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-03-21T17:36:23Z"}, "message": "remove uses of `RefCell` from move data builder.", "tree": {"sha": "da61ce3892048ed7629fb06ab746fcdf493fac6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da61ce3892048ed7629fb06ab746fcdf493fac6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5508c40d0494fbb2f5e83a4bb37d86cb0c04c76e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5508c40d0494fbb2f5e83a4bb37d86cb0c04c76e", "html_url": "https://github.com/rust-lang/rust/commit/5508c40d0494fbb2f5e83a4bb37d86cb0c04c76e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5508c40d0494fbb2f5e83a4bb37d86cb0c04c76e/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dda892a83d337556fd48aca78c07c7d3f5df69bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/dda892a83d337556fd48aca78c07c7d3f5df69bd", "html_url": "https://github.com/rust-lang/rust/commit/dda892a83d337556fd48aca78c07c7d3f5df69bd"}], "stats": {"total": 63, "additions": 26, "deletions": 37}, "files": [{"sha": "a524a03f0f5bee23826992705ba3555399b8d56d", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 26, "deletions": 37, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5508c40d0494fbb2f5e83a4bb37d86cb0c04c76e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5508c40d0494fbb2f5e83a4bb37d86cb0c04c76e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=5508c40d0494fbb2f5e83a4bb37d86cb0c04c76e", "patch": "@@ -14,7 +14,7 @@ use rustc::mir::repr::{self, Mir, BasicBlock, Lvalue, Rvalue};\n use rustc::mir::repr::{StatementKind, Terminator};\n use rustc::util::nodemap::FnvHashMap;\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell};\n use std::collections::hash_map::Entry;\n use std::fmt;\n use std::iter;\n@@ -220,8 +220,8 @@ type MovePathInverseMap = Vec<Option<MovePathIndex>>;\n \n struct MovePathDataBuilder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    pre_move_paths: RefCell<Vec<PreMovePath<'tcx>>>,\n-    rev_lookup: RefCell<MovePathLookup<'tcx>>,\n+    pre_move_paths: Vec<PreMovePath<'tcx>>,\n+    rev_lookup: MovePathLookup<'tcx>,\n }\n \n /// Tables mapping from an l-value to its MovePathIndex.\n@@ -400,41 +400,32 @@ impl<'tcx> MovePathLookup<'tcx> {\n \n impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n     fn lookup(&mut self, lval: &Lvalue<'tcx>) -> Lookup<MovePathIndex> {\n-        let proj = {\n-            let mut rev_lookup = self.rev_lookup.borrow_mut();\n-            match *lval {\n-                Lvalue::Var(var_idx) =>\n-                    return rev_lookup.lookup_var(var_idx),\n-                Lvalue::Temp(temp_idx) =>\n-                    return rev_lookup.lookup_temp(temp_idx),\n-                Lvalue::Arg(arg_idx) =>\n-                    return rev_lookup.lookup_arg(arg_idx),\n-                Lvalue::Static(_def_id) =>\n-                    return rev_lookup.lookup_static(),\n-                Lvalue::ReturnPointer =>\n-                    return rev_lookup.lookup_return_pointer(),\n-                Lvalue::Projection(ref proj) => {\n-                    proj\n-                }\n+        let proj = match *lval {\n+            Lvalue::Var(var_idx) =>\n+                return self.rev_lookup.lookup_var(var_idx),\n+            Lvalue::Temp(temp_idx) =>\n+                return self.rev_lookup.lookup_temp(temp_idx),\n+            Lvalue::Arg(arg_idx) =>\n+                return self.rev_lookup.lookup_arg(arg_idx),\n+            Lvalue::Static(_def_id) =>\n+                return self.rev_lookup.lookup_static(),\n+            Lvalue::ReturnPointer =>\n+                return self.rev_lookup.lookup_return_pointer(),\n+            Lvalue::Projection(ref proj) => {\n+                proj\n             }\n-            // drop the rev_lookup here ...\n         };\n \n         let base_index = self.move_path_for(&proj.base);\n-\n-        // ... restablish exclusive access to rev_lookup here.\n-        let mut rev_lookup = self.rev_lookup.borrow_mut();\n-        rev_lookup.lookup_proj(proj, base_index)\n+        self.rev_lookup.lookup_proj(proj, base_index)\n     }\n \n-    // Caller must ensure self's RefCells (i.e. `self.pre_move_paths`\n-    // and `self.rev_lookup`) are not mutably borrowed.\n     fn move_path_for(&mut self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n         let lookup: Lookup<MovePathIndex> = self.lookup(lval);\n \n         // `lookup` is either the previously assigned index or a\n         // newly-allocated one.\n-        debug_assert!(lookup.idx() <= self.pre_move_paths.borrow().len());\n+        debug_assert!(lookup.idx() <= self.pre_move_paths.len());\n \n         if let Lookup(LookupKind::Generate, mpi) = lookup {\n             let parent;\n@@ -465,8 +456,7 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n                     let idx = self.move_path_for(&proj.base);\n                     parent = Some(idx);\n \n-                    let mut pre_move_paths = self.pre_move_paths.borrow_mut();\n-                    let parent_move_path = &mut pre_move_paths[idx.idx()];\n+                    let parent_move_path = &mut self.pre_move_paths[idx.idx()];\n \n                     // At last: Swap in the new first_child.\n                     sibling = parent_move_path.first_child.get();\n@@ -486,8 +476,7 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n                 first_child: Cell::new(None),\n             };\n \n-            let mut pre_move_paths = self.pre_move_paths.borrow_mut();\n-            pre_move_paths.push(move_path);\n+            self.pre_move_paths.push(move_path);\n         }\n \n         return lookup.1;\n@@ -519,8 +508,8 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx>\n     // straight-forward than mutable borrows in this instance.)\n     let mut builder = MovePathDataBuilder {\n         mir: mir,\n-        pre_move_paths: RefCell::new(Vec::new()),\n-        rev_lookup: RefCell::new(MovePathLookup::new()),\n+        pre_move_paths: Vec::new(),\n+        rev_lookup: MovePathLookup::new(),\n     };\n \n     for bb in bbs {\n@@ -644,10 +633,10 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx>\n     // All such paths were not referenced ...\n     //\n     // well you know, lets actually try just asserting that the path map *is* complete.\n-    assert_eq!(path_map.len(), builder.pre_move_paths.borrow().len());\n-    path_map.fill_to(builder.pre_move_paths.borrow().len() - 1);\n+    assert_eq!(path_map.len(), builder.pre_move_paths.len());\n+    path_map.fill_to(builder.pre_move_paths.len() - 1);\n \n-    let pre_move_paths = builder.pre_move_paths.into_inner();\n+    let pre_move_paths = builder.pre_move_paths;\n     let move_paths: Vec<_> = pre_move_paths.into_iter()\n         .map(|p| p.into_move_path())\n         .collect();\n@@ -672,7 +661,7 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx>\n         moves: moves,\n         loc_map: LocMap { map: loc_map },\n         path_map: PathMap { map: path_map },\n-        rev_lookup: builder.rev_lookup.into_inner(),\n+        rev_lookup: builder.rev_lookup,\n     }\n }\n "}]}