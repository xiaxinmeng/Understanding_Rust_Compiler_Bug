{"sha": "aff4d3e659872ec1fbf469e91575a9a711ce4705", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZjRkM2U2NTk4NzJlYzFmYmY0NjllOTE1NzVhOWE3MTFjZTQ3MDU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-09-21T23:21:26Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-10-21T02:46:16Z"}, "message": "rustc_mir: run the MIR inlining Integrator on the whole callee body at once.", "tree": {"sha": "a2a3947bbd08cae611a095edf60d37f1ba14edb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2a3947bbd08cae611a095edf60d37f1ba14edb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aff4d3e659872ec1fbf469e91575a9a711ce4705", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aff4d3e659872ec1fbf469e91575a9a711ce4705", "html_url": "https://github.com/rust-lang/rust/commit/aff4d3e659872ec1fbf469e91575a9a711ce4705", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aff4d3e659872ec1fbf469e91575a9a711ce4705/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b21c50335887fe9ecbd44d5a3efa105feae0a6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b21c50335887fe9ecbd44d5a3efa105feae0a6d", "html_url": "https://github.com/rust-lang/rust/commit/9b21c50335887fe9ecbd44d5a3efa105feae0a6d"}], "stats": {"total": 135, "additions": 65, "deletions": 70}, "files": [{"sha": "944f41c61a2b58a1834dae145d397461e438e19f", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 65, "deletions": 70, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/aff4d3e659872ec1fbf469e91575a9a711ce4705/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff4d3e659872ec1fbf469e91575a9a711ce4705/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=aff4d3e659872ec1fbf469e91575a9a711ce4705", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_attr as attr;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n@@ -14,6 +14,7 @@ use super::simplify::{remove_dead_blocks, CfgSimplifier};\n use crate::transform::MirPass;\n use std::collections::VecDeque;\n use std::iter;\n+use std::ops::RangeFrom;\n \n const DEFAULT_THRESHOLD: usize = 50;\n const HINT_THRESHOLD: usize = 100;\n@@ -477,26 +478,24 @@ impl Inliner<'tcx> {\n                 // Copy the arguments if needed.\n                 let args: Vec<_> = self.make_call_args(args, &callsite, caller_body, return_block);\n \n-                let bb_len = caller_body.basic_blocks().len();\n                 let mut integrator = Integrator {\n-                    block_idx: bb_len,\n                     args: &args,\n-                    local_map: IndexVec::with_capacity(callee_body.local_decls.len()),\n-                    scope_map: IndexVec::with_capacity(callee_body.source_scopes.len()),\n+                    new_locals: Local::new(caller_body.local_decls.len())..,\n+                    new_scopes: SourceScope::new(caller_body.source_scopes.len())..,\n+                    new_blocks: BasicBlock::new(caller_body.basic_blocks().len())..,\n                     destination: dest,\n                     return_block,\n                     cleanup_block: cleanup,\n                     in_cleanup_block: false,\n                     tcx: self.tcx,\n                 };\n \n-                for mut scope in callee_body.source_scopes.iter().cloned() {\n-                    // Map the callee scopes into the caller.\n-                    // FIXME(eddyb) this may ICE if the scopes are out of order.\n-                    scope.parent_scope = scope.parent_scope.map(|s| integrator.scope_map[s]);\n-                    scope.inlined_parent_scope =\n-                        scope.inlined_parent_scope.map(|s| integrator.scope_map[s]);\n+                // Map all `Local`s, `SourceScope`s and `BasicBlock`s to new ones\n+                // (or existing ones, in a few special cases) in the caller.\n+                integrator.visit_body(&mut callee_body);\n \n+                for scope in &mut callee_body.source_scopes {\n+                    // FIXME(eddyb) move this into a `fn visit_scope_data` in `Integrator`.\n                     if scope.parent_scope.is_none() {\n                         let callsite_scope = &caller_body.source_scopes[callsite.source_info.scope];\n \n@@ -516,38 +515,26 @@ impl Inliner<'tcx> {\n                     } else if scope.inlined_parent_scope.is_none() {\n                         // Make it easy to find the scope with `inlined` set above.\n                         scope.inlined_parent_scope =\n-                            Some(integrator.scope_map[OUTERMOST_SOURCE_SCOPE]);\n+                            Some(integrator.map_scope(OUTERMOST_SOURCE_SCOPE));\n                     }\n-\n-                    let idx = caller_body.source_scopes.push(scope);\n-                    integrator.scope_map.push(idx);\n-                }\n-\n-                for loc in callee_body.vars_and_temps_iter() {\n-                    let mut local = callee_body.local_decls[loc].clone();\n-\n-                    local.source_info.scope = integrator.scope_map[local.source_info.scope];\n-\n-                    let idx = caller_body.local_decls.push(local);\n-                    integrator.local_map.push(idx);\n-                }\n-\n-                for mut var_debug_info in callee_body.var_debug_info.drain(..) {\n-                    integrator.visit_var_debug_info(&mut var_debug_info);\n-                    caller_body.var_debug_info.push(var_debug_info);\n                 }\n \n-                for (bb, mut block) in callee_body.basic_blocks_mut().drain_enumerated(..) {\n-                    integrator.visit_basic_block_data(bb, &mut block);\n-                    caller_body.basic_blocks_mut().push(block);\n-                }\n+                // Insert all of the (mapped) parts of the callee body into the caller.\n+                caller_body.local_decls.extend(\n+                    // FIXME(eddyb) make `Range<Local>` iterable so that we can use\n+                    // `callee_body.local_decls.drain(callee_body.vars_and_temps())`\n+                    callee_body\n+                        .vars_and_temps_iter()\n+                        .map(|local| callee_body.local_decls[local].clone()),\n+                );\n+                caller_body.source_scopes.extend(callee_body.source_scopes.drain(..));\n+                caller_body.var_debug_info.extend(callee_body.var_debug_info.drain(..));\n+                caller_body.basic_blocks_mut().extend(callee_body.basic_blocks_mut().drain(..));\n \n-                let terminator = Terminator {\n+                caller_body[callsite.bb].terminator = Some(Terminator {\n                     source_info: callsite.source_info,\n-                    kind: TerminatorKind::Goto { target: BasicBlock::new(bb_len) },\n-                };\n-\n-                caller_body[callsite.bb].terminator = Some(terminator);\n+                    kind: TerminatorKind::Goto { target: integrator.map_block(START_BLOCK) },\n+                });\n \n                 true\n             }\n@@ -703,10 +690,10 @@ fn type_size_of<'tcx>(\n  * stuff.\n */\n struct Integrator<'a, 'tcx> {\n-    block_idx: usize,\n     args: &'a [Local],\n-    local_map: IndexVec<Local, Local>,\n-    scope_map: IndexVec<SourceScope, SourceScope>,\n+    new_locals: RangeFrom<Local>,\n+    new_scopes: RangeFrom<SourceScope>,\n+    new_blocks: RangeFrom<BasicBlock>,\n     destination: Place<'tcx>,\n     return_block: BasicBlock,\n     cleanup_block: Option<BasicBlock>,\n@@ -715,23 +702,31 @@ struct Integrator<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Integrator<'a, 'tcx> {\n-    fn update_target(&self, tgt: BasicBlock) -> BasicBlock {\n-        let new = BasicBlock::new(tgt.index() + self.block_idx);\n-        debug!(\"updating target `{:?}`, new: `{:?}`\", tgt, new);\n+    fn map_local(&self, local: Local) -> Local {\n+        let new = if local == RETURN_PLACE {\n+            self.destination.local\n+        } else {\n+            let idx = local.index() - 1;\n+            if idx < self.args.len() {\n+                self.args[idx]\n+            } else {\n+                Local::new(self.new_locals.start.index() + (idx - self.args.len()))\n+            }\n+        };\n+        debug!(\"mapping local `{:?}` to `{:?}`\", local, new);\n         new\n     }\n \n-    fn make_integrate_local(&self, local: Local) -> Local {\n-        if local == RETURN_PLACE {\n-            return self.destination.local;\n-        }\n-\n-        let idx = local.index() - 1;\n-        if idx < self.args.len() {\n-            return self.args[idx];\n-        }\n+    fn map_scope(&self, scope: SourceScope) -> SourceScope {\n+        let new = SourceScope::new(self.new_scopes.start.index() + scope.index());\n+        debug!(\"mapping scope `{:?}` to `{:?}`\", scope, new);\n+        new\n+    }\n \n-        self.local_map[Local::new(idx - self.args.len())]\n+    fn map_block(&self, block: BasicBlock) -> BasicBlock {\n+        let new = BasicBlock::new(self.new_blocks.start.index() + block.index());\n+        debug!(\"mapping block `{:?}` to `{:?}`\", block, new);\n+        new\n     }\n }\n \n@@ -741,7 +736,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n     }\n \n     fn visit_local(&mut self, local: &mut Local, _ctxt: PlaceContext, _location: Location) {\n-        *local = self.make_integrate_local(*local);\n+        *local = self.map_local(*local);\n+    }\n+\n+    fn visit_source_scope(&mut self, scope: &mut SourceScope) {\n+        *scope = self.map_scope(*scope);\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n@@ -785,18 +784,18 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         match terminator.kind {\n             TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => bug!(),\n             TerminatorKind::Goto { ref mut target } => {\n-                *target = self.update_target(*target);\n+                *target = self.map_block(*target);\n             }\n             TerminatorKind::SwitchInt { ref mut targets, .. } => {\n                 for tgt in targets.all_targets_mut() {\n-                    *tgt = self.update_target(*tgt);\n+                    *tgt = self.map_block(*tgt);\n                 }\n             }\n             TerminatorKind::Drop { ref mut target, ref mut unwind, .. }\n             | TerminatorKind::DropAndReplace { ref mut target, ref mut unwind, .. } => {\n-                *target = self.update_target(*target);\n+                *target = self.map_block(*target);\n                 if let Some(tgt) = *unwind {\n-                    *unwind = Some(self.update_target(tgt));\n+                    *unwind = Some(self.map_block(tgt));\n                 } else if !self.in_cleanup_block {\n                     // Unless this drop is in a cleanup block, add an unwind edge to\n                     // the original call's cleanup block\n@@ -805,20 +804,20 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n             }\n             TerminatorKind::Call { ref mut destination, ref mut cleanup, .. } => {\n                 if let Some((_, ref mut tgt)) = *destination {\n-                    *tgt = self.update_target(*tgt);\n+                    *tgt = self.map_block(*tgt);\n                 }\n                 if let Some(tgt) = *cleanup {\n-                    *cleanup = Some(self.update_target(tgt));\n+                    *cleanup = Some(self.map_block(tgt));\n                 } else if !self.in_cleanup_block {\n                     // Unless this call is in a cleanup block, add an unwind edge to\n                     // the original call's cleanup block\n                     *cleanup = self.cleanup_block;\n                 }\n             }\n             TerminatorKind::Assert { ref mut target, ref mut cleanup, .. } => {\n-                *target = self.update_target(*target);\n+                *target = self.map_block(*target);\n                 if let Some(tgt) = *cleanup {\n-                    *cleanup = Some(self.update_target(tgt));\n+                    *cleanup = Some(self.map_block(tgt));\n                 } else if !self.in_cleanup_block {\n                     // Unless this assert is in a cleanup block, add an unwind edge to\n                     // the original call's cleanup block\n@@ -836,8 +835,8 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n             TerminatorKind::Abort => {}\n             TerminatorKind::Unreachable => {}\n             TerminatorKind::FalseEdge { ref mut real_target, ref mut imaginary_target } => {\n-                *real_target = self.update_target(*real_target);\n-                *imaginary_target = self.update_target(*imaginary_target);\n+                *real_target = self.map_block(*real_target);\n+                *imaginary_target = self.map_block(*imaginary_target);\n             }\n             TerminatorKind::FalseUnwind { real_target: _, unwind: _ } =>\n             // see the ordering of passes in the optimized_mir query.\n@@ -846,13 +845,9 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n             }\n             TerminatorKind::InlineAsm { ref mut destination, .. } => {\n                 if let Some(ref mut tgt) = *destination {\n-                    *tgt = self.update_target(*tgt);\n+                    *tgt = self.map_block(*tgt);\n                 }\n             }\n         }\n     }\n-\n-    fn visit_source_scope(&mut self, scope: &mut SourceScope) {\n-        *scope = self.scope_map[*scope];\n-    }\n }"}]}