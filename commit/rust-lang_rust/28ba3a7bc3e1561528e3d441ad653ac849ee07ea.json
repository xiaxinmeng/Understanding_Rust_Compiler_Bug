{"sha": "28ba3a7bc3e1561528e3d441ad653ac849ee07ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YmEzYTdiYzNlMTU2MTUyOGUzZDQ0MWFkNjUzYWM4NDllZTA3ZWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-11T04:44:02Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-12T20:42:07Z"}, "message": "native: Remove timerfd implementation on linux\n\nRust advertises itself as being compatible with linux 2.6.18, but the timerfd\nset of syscalls weren't added until linux 2.6.25. There is no real need for a\nspecialized timer implementation beyond being a \"little more accurate\", but the\nselect() implementation will suffice for now.\n\nIf it is later deemed that an accurate timerfd implementation is needed, it can\nbe added then through some method which will allow the standard distribution to\ncontinue to be compatible with 2.6.18\n\nCloses #13447", "tree": {"sha": "710c41a41afc476911128c249cab3eb2b955b5c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/710c41a41afc476911128c249cab3eb2b955b5c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28ba3a7bc3e1561528e3d441ad653ac849ee07ea", "comment_count": 13, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28ba3a7bc3e1561528e3d441ad653ac849ee07ea", "html_url": "https://github.com/rust-lang/rust/commit/28ba3a7bc3e1561528e3d441ad653ac849ee07ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28ba3a7bc3e1561528e3d441ad653ac849ee07ea/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab0d8472777d2359492dfdee1d21230fbf144f70", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab0d8472777d2359492dfdee1d21230fbf144f70", "html_url": "https://github.com/rust-lang/rust/commit/ab0d8472777d2359492dfdee1d21230fbf144f70"}], "stats": {"total": 339, "additions": 6, "deletions": 333}, "files": [{"sha": "78d17bc8d747f55ff91635cffb8077eea5024f94", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28ba3a7bc3e1561528e3d441ad653ac849ee07ea/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ba3a7bc3e1561528e3d441ad653ac849ee07ea/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=28ba3a7bc3e1561528e3d441ad653ac849ee07ea", "patch": "@@ -55,11 +55,8 @@ pub mod file;\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"android\")]\n-#[path = \"timer_other.rs\"]\n-pub mod timer;\n-\n #[cfg(target_os = \"linux\")]\n-#[path = \"timer_timerfd.rs\"]\n+#[path = \"timer_unix.rs\"]\n pub mod timer;\n \n #[cfg(target_os = \"win32\")]"}, {"sha": "3fd61dc1da5d09086cf0e711905a78d9560c003b", "filename": "src/libnative/io/timer_timerfd.rs", "status": "removed", "additions": 0, "deletions": 327, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab0d8472777d2359492dfdee1d21230fbf144f70/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=ab0d8472777d2359492dfdee1d21230fbf144f70", "patch": "@@ -1,327 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Timers based on timerfd_create(2)\n-//!\n-//! On OSes which support timerfd_create, we can use these much more accurate\n-//! timers over select() + a timeout (see timer_other.rs). This strategy still\n-//! employs a worker thread which does the waiting on the timer fds (to send\n-//! messages away).\n-//!\n-//! The worker thread in this implementation uses epoll(7) to block. It\n-//! maintains a working set of *all* native timers in the process, along with a\n-//! pipe file descriptor used to communicate that there is data available on the\n-//! incoming channel to the worker thread. Timers send requests to update their\n-//! timerfd settings to the worker thread (see the comment above 'oneshot' for\n-//! why).\n-//!\n-//! As with timer_other, timers just using sleep() do not use the timerfd at\n-//! all. They remove the timerfd from the worker thread and then invoke\n-//! nanosleep() to block the calling thread.\n-//!\n-//! As with timer_other, all units in this file are in units of millseconds.\n-\n-use libc;\n-use std::ptr;\n-use std::os;\n-use std::rt::rtio;\n-use std::mem;\n-\n-use io::file::FileDesc;\n-use io::IoResult;\n-use io::timer_helper;\n-\n-pub struct Timer {\n-    fd: FileDesc,\n-    on_worker: bool,\n-}\n-\n-#[allow(visible_private_types)]\n-pub enum Req {\n-    NewTimer(libc::c_int, Sender<()>, bool, imp::itimerspec),\n-    RemoveTimer(libc::c_int, Sender<()>),\n-    Shutdown,\n-}\n-\n-fn helper(input: libc::c_int, messages: Receiver<Req>) {\n-    let efd = unsafe { imp::epoll_create(10) };\n-    let _fd1 = FileDesc::new(input, true);\n-    let _fd2 = FileDesc::new(efd, true);\n-\n-    fn add(efd: libc::c_int, fd: libc::c_int) {\n-        let event = imp::epoll_event {\n-            events: imp::EPOLLIN as u32,\n-            data: fd as i64,\n-        };\n-        let ret = unsafe {\n-            imp::epoll_ctl(efd, imp::EPOLL_CTL_ADD, fd, &event)\n-        };\n-        assert_eq!(ret, 0);\n-    }\n-    fn del(efd: libc::c_int, fd: libc::c_int) {\n-        let event = imp::epoll_event { events: 0, data: 0 };\n-        let ret = unsafe {\n-            imp::epoll_ctl(efd, imp::EPOLL_CTL_DEL, fd, &event)\n-        };\n-        assert_eq!(ret, 0);\n-    }\n-\n-    add(efd, input);\n-    let events: [imp::epoll_event, ..16] = unsafe { mem::init() };\n-    let mut list: Vec<(libc::c_int, Sender<()>, bool)> = vec![];\n-    'outer: loop {\n-        let n = match unsafe {\n-            imp::epoll_wait(efd, events.as_ptr(),\n-                            events.len() as libc::c_int, -1)\n-        } {\n-            0 => fail!(\"epoll_wait returned immediately!\"),\n-            -1 if os::errno() == libc::EINTR as int => { continue }\n-            -1 => fail!(\"epoll wait failed: {}\", os::last_os_error()),\n-            n => n\n-        };\n-\n-        let mut incoming = false;\n-        for event in events.slice_to(n as uint).iter() {\n-            let fd = event.data as libc::c_int;\n-            if fd == input {\n-                let mut buf = [0, ..1];\n-                // drain the input file descriptor of its input\n-                let _ = FileDesc::new(fd, false).inner_read(buf).unwrap();\n-                incoming = true;\n-            } else {\n-                let mut bits = [0, ..8];\n-                // drain the timerfd of how many times its fired\n-                //\n-                // FIXME: should this perform a send() this number of\n-                //      times?\n-                let _ = FileDesc::new(fd, false).inner_read(bits).unwrap();\n-                let (remove, i) = {\n-                    match list.as_slice().bsearch(|&(f, _, _)| f.cmp(&fd)) {\n-                        Some(i) => {\n-                            let (_, ref c, oneshot) = *list.get(i);\n-                            (c.send_opt(()).is_err() || oneshot, i)\n-                        }\n-                        None => fail!(\"fd not active: {}\", fd),\n-                    }\n-                };\n-                if remove {\n-                    drop(list.remove(i));\n-                    del(efd, fd);\n-                }\n-            }\n-        }\n-\n-        while incoming {\n-            match messages.try_recv() {\n-                Ok(NewTimer(fd, chan, one, timeval)) => {\n-                    // acknowledge we have the new channel, we will never send\n-                    // another message to the old channel\n-                    chan.send(());\n-\n-                    // If we haven't previously seen the file descriptor, then\n-                    // we need to add it to the epoll set.\n-                    match list.as_slice().bsearch(|&(f, _, _)| f.cmp(&fd)) {\n-                        Some(i) => {\n-                            drop(mem::replace(list.get_mut(i), (fd, chan, one)));\n-                        }\n-                        None => {\n-                            match list.iter().position(|&(f, _, _)| f >= fd) {\n-                                Some(i) => list.insert(i, (fd, chan, one)),\n-                                None => list.push((fd, chan, one)),\n-                            }\n-                            add(efd, fd);\n-                        }\n-                    }\n-\n-                    // Update the timerfd's time value now that we have control\n-                    // of the timerfd\n-                    let ret = unsafe {\n-                        imp::timerfd_settime(fd, 0, &timeval, ptr::null())\n-                    };\n-                    assert_eq!(ret, 0);\n-                }\n-\n-                Ok(RemoveTimer(fd, chan)) => {\n-                    match list.as_slice().bsearch(|&(f, _, _)| f.cmp(&fd)) {\n-                        Some(i) => {\n-                            drop(list.remove(i));\n-                            del(efd, fd);\n-                        }\n-                        None => {}\n-                    }\n-                    chan.send(());\n-                }\n-\n-                Ok(Shutdown) => {\n-                    assert!(list.len() == 0);\n-                    break 'outer;\n-                }\n-\n-                _ => break,\n-            }\n-        }\n-    }\n-}\n-\n-impl Timer {\n-    pub fn new() -> IoResult<Timer> {\n-        timer_helper::boot(helper);\n-        match unsafe { imp::timerfd_create(imp::CLOCK_MONOTONIC, 0) } {\n-            -1 => Err(super::last_error()),\n-            n => Ok(Timer { fd: FileDesc::new(n, true), on_worker: false, }),\n-        }\n-    }\n-\n-    pub fn sleep(ms: u64) {\n-        let mut to_sleep = libc::timespec {\n-            tv_sec: (ms / 1000) as libc::time_t,\n-            tv_nsec: ((ms % 1000) * 1000000) as libc::c_long,\n-        };\n-        while unsafe { libc::nanosleep(&to_sleep, &mut to_sleep) } != 0 {\n-            if os::errno() as int != libc::EINTR as int {\n-                fail!(\"failed to sleep, but not because of EINTR?\");\n-            }\n-        }\n-    }\n-\n-    fn remove(&mut self) {\n-        if !self.on_worker { return }\n-\n-        let (tx, rx) = channel();\n-        timer_helper::send(RemoveTimer(self.fd.fd(), tx));\n-        rx.recv();\n-        self.on_worker = false;\n-    }\n-}\n-\n-impl rtio::RtioTimer for Timer {\n-    fn sleep(&mut self, msecs: u64) {\n-        self.remove();\n-        Timer::sleep(msecs);\n-    }\n-\n-    // Periodic and oneshot channels are updated by updating the settings on the\n-    // corresopnding timerfd. The update is not performed on the thread calling\n-    // oneshot or period, but rather the helper epoll thread. The reason for\n-    // this is to avoid losing messages and avoid leaking messages across ports.\n-    //\n-    // By updating the timerfd on the helper thread, we're guaranteed that all\n-    // messages for a particular setting of the timer will be received by the\n-    // new channel/port pair rather than leaking old messages onto the new port\n-    // or leaking new messages onto the old port.\n-    //\n-    // We also wait for the remote thread to actually receive the new settings\n-    // before returning to guarantee the invariant that when oneshot() and\n-    // period() return that the old port will never receive any more messages.\n-\n-    fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n-        let (tx, rx) = channel();\n-\n-        let new_value = imp::itimerspec {\n-            it_interval: imp::timespec { tv_sec: 0, tv_nsec: 0 },\n-            it_value: imp::timespec {\n-                tv_sec: (msecs / 1000) as libc::time_t,\n-                tv_nsec: ((msecs % 1000) * 1000000) as libc::c_long,\n-            }\n-        };\n-        timer_helper::send(NewTimer(self.fd.fd(), tx, true, new_value));\n-        rx.recv();\n-        self.on_worker = true;\n-\n-        return rx;\n-    }\n-\n-    fn period(&mut self, msecs: u64) -> Receiver<()> {\n-        let (tx, rx) = channel();\n-\n-        let spec = imp::timespec {\n-            tv_sec: (msecs / 1000) as libc::time_t,\n-            tv_nsec: ((msecs % 1000) * 1000000) as libc::c_long,\n-        };\n-        let new_value = imp::itimerspec { it_interval: spec, it_value: spec, };\n-        timer_helper::send(NewTimer(self.fd.fd(), tx, false, new_value));\n-        rx.recv();\n-        self.on_worker = true;\n-\n-        return rx;\n-    }\n-}\n-\n-impl Drop for Timer {\n-    fn drop(&mut self) {\n-        // When the timerfd file descriptor is closed, it will be automatically\n-        // removed from the epoll set of the worker thread, but we want to make\n-        // sure that the associated channel is also removed from the worker's\n-        // hash map.\n-        self.remove();\n-    }\n-}\n-\n-#[allow(dead_code)]\n-mod imp {\n-    use libc;\n-\n-    pub static CLOCK_MONOTONIC: libc::c_int = 1;\n-    pub static EPOLL_CTL_ADD: libc::c_int = 1;\n-    pub static EPOLL_CTL_DEL: libc::c_int = 2;\n-    pub static EPOLL_CTL_MOD: libc::c_int = 3;\n-    pub static EPOLLIN: libc::c_int = 0x001;\n-    pub static EPOLLOUT: libc::c_int = 0x004;\n-    pub static EPOLLPRI: libc::c_int = 0x002;\n-    pub static EPOLLERR: libc::c_int = 0x008;\n-    pub static EPOLLRDHUP: libc::c_int = 0x2000;\n-    pub static EPOLLET: libc::c_int = 1 << 31;\n-    pub static EPOLLHUP: libc::c_int = 0x010;\n-    pub static EPOLLONESHOT: libc::c_int = 1 << 30;\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    #[packed]\n-    pub struct epoll_event {\n-        pub events: u32,\n-        pub data: i64,\n-    }\n-\n-    #[cfg(not(target_arch = \"x86_64\"))]\n-    pub struct epoll_event {\n-        pub events: u32,\n-        pub data: i64,\n-    }\n-\n-    pub struct timespec {\n-        pub tv_sec: libc::time_t,\n-        pub tv_nsec: libc::c_long,\n-    }\n-\n-    pub struct itimerspec {\n-        pub it_interval: timespec,\n-        pub it_value: timespec,\n-    }\n-\n-    extern {\n-        pub fn timerfd_create(clockid: libc::c_int,\n-                              flags: libc::c_int) -> libc::c_int;\n-        pub fn timerfd_settime(fd: libc::c_int,\n-                               flags: libc::c_int,\n-                               new_value: *itimerspec,\n-                               old_value: *itimerspec) -> libc::c_int;\n-        pub fn timerfd_gettime(fd: libc::c_int,\n-                               curr_value: *itimerspec) -> libc::c_int;\n-\n-        pub fn epoll_create(size: libc::c_int) -> libc::c_int;\n-        pub fn epoll_ctl(epfd: libc::c_int,\n-                         op: libc::c_int,\n-                         fd: libc::c_int,\n-                         event: *epoll_event) -> libc::c_int;\n-        pub fn epoll_wait(epfd: libc::c_int,\n-                          events: *epoll_event,\n-                          maxevents: libc::c_int,\n-                          timeout: libc::c_int) -> libc::c_int;\n-    }\n-}"}, {"sha": "0444604d42a0b1b41c50ac6022ef9781a267d86b", "filename": "src/libnative/io/timer_unix.rs", "status": "renamed", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28ba3a7bc3e1561528e3d441ad653ac849ee07ea/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ba3a7bc3e1561528e3d441ad653ac849ee07ea/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=28ba3a7bc3e1561528e3d441ad653ac849ee07ea", "patch": "@@ -312,17 +312,20 @@ mod imp {\n \n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"linux\")]\n mod imp {\n     use libc;\n+    use std::uint;\n \n     pub static FD_SETSIZE: uint = 1024;\n \n     pub struct fd_set {\n-        fds_bits: [u64, ..(FD_SETSIZE / 64)]\n+        fds_bits: [uint, ..(FD_SETSIZE / uint::BITS)]\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {\n-        set.fds_bits[(fd / 64) as uint] |= (1 << (fd % 64)) as u64;\n+        let fd = fd as uint;\n+        set.fds_bits[fd / uint::BITS] |= 1 << (fd % uint::BITS);\n     }\n \n     extern {", "previous_filename": "src/libnative/io/timer_other.rs"}]}