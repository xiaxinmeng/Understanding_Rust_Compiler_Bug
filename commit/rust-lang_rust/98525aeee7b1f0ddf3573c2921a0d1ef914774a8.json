{"sha": "98525aeee7b1f0ddf3573c2921a0d1ef914774a8", "node_id": "C_kwDOAAsO6NoAKDk4NTI1YWVlZTdiMWYwZGRmMzU3M2MyOTIxYTBkMWVmOTE0Nzc0YTg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-22T01:11:57Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-24T02:45:05Z"}, "message": "Check object's supertrait and associated type bounds in new solver", "tree": {"sha": "bedb64015ad98ed65cb3ac40565720ae6e15426f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bedb64015ad98ed65cb3ac40565720ae6e15426f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98525aeee7b1f0ddf3573c2921a0d1ef914774a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98525aeee7b1f0ddf3573c2921a0d1ef914774a8", "html_url": "https://github.com/rust-lang/rust/commit/98525aeee7b1f0ddf3573c2921a0d1ef914774a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07c993eba8b76eae497e98433ae075b00f01be10", "url": "https://api.github.com/repos/rust-lang/rust/commits/07c993eba8b76eae497e98433ae075b00f01be10", "html_url": "https://github.com/rust-lang/rust/commit/07c993eba8b76eae497e98433ae075b00f01be10"}], "stats": {"total": 195, "additions": 193, "deletions": 2}, "files": [{"sha": "dec9f8016b0c18845d2ae581c0eada8915de7e50", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=98525aeee7b1f0ddf3573c2921a0d1ef914774a8", "patch": "@@ -99,6 +99,15 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> QueryResult<'tcx>;\n \n+    // Consider a clause specifically for a `dyn Trait` self type. This requires\n+    // additionally checking all of the supertraits and object bounds to hold,\n+    // since they're not implied by the well-formedness of the object type.\n+    fn consider_object_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx>;\n+\n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n@@ -455,7 +464,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         for assumption in\n             elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n         {\n-            match G::consider_implied_clause(self, goal, assumption.predicate, []) {\n+            match G::consider_object_bound_candidate(self, goal, assumption.predicate) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n                 }"}, {"sha": "807527e86600205c05314b9a4556527a3868b4e9", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=98525aeee7b1f0ddf3573c2921a0d1ef914774a8", "patch": "@@ -128,6 +128,50 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         }\n     }\n \n+    fn consider_object_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n+            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n+        {\n+            ecx.probe(|ecx| {\n+                let assumption_projection_pred =\n+                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n+                let mut nested_goals = ecx.eq(\n+                    goal.param_env,\n+                    goal.predicate.projection_ty,\n+                    assumption_projection_pred.projection_ty,\n+                )?;\n+\n+                let tcx = ecx.tcx();\n+                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n+                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n+                };\n+                nested_goals.extend(\n+                    structural_traits::predicates_for_object_candidate(\n+                        tcx,\n+                        goal.predicate.projection_ty.trait_ref(tcx),\n+                        bounds,\n+                    )\n+                    .into_iter()\n+                    .map(|pred| goal.with(tcx, pred)),\n+                );\n+\n+                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n+\n+                ecx.eq_term_and_make_canonical_response(\n+                    goal,\n+                    subst_certainty,\n+                    assumption_projection_pred.term,\n+                )\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,"}, {"sha": "9aded080f20ba59cf9dc8fab34660bf57a71d164", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=98525aeee7b1f0ddf3573c2921a0d1ef914774a8", "patch": "@@ -86,6 +86,45 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n     }\n \n+    fn consider_object_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n+            && poly_trait_pred.def_id() == goal.predicate.def_id()\n+        {\n+            // FIXME: Constness and polarity\n+            ecx.probe(|ecx| {\n+                let assumption_trait_pred =\n+                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n+                let mut nested_goals = ecx.eq(\n+                    goal.param_env,\n+                    goal.predicate.trait_ref,\n+                    assumption_trait_pred.trait_ref,\n+                )?;\n+\n+                let tcx = ecx.tcx();\n+                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n+                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n+                };\n+                nested_goals.extend(\n+                    structural_traits::predicates_for_object_candidate(\n+                        tcx,\n+                        goal.predicate.trait_ref,\n+                        bounds,\n+                    )\n+                    .into_iter()\n+                    .map(|pred| goal.with(tcx, pred)),\n+                );\n+\n+                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_auto_trait_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,"}, {"sha": "3fcf96be203cac1ee877798e417d809a281398c1", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=98525aeee7b1f0ddf3573c2921a0d1ef914774a8", "patch": "@@ -1,6 +1,7 @@\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{Movability, Mutability};\n use rustc_infer::traits::query::NoSolution;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable};\n \n use crate::solve::EvalCtxt;\n \n@@ -233,3 +234,62 @@ pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n         }\n     }\n }\n+\n+pub(crate) fn predicates_for_object_candidate<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n+    object_bound: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n+) -> Vec<ty::Predicate<'tcx>> {\n+    let mut requirements = vec![];\n+    requirements.extend(\n+        tcx.super_predicates_of(trait_ref.def_id).instantiate(tcx, trait_ref.substs).predicates,\n+    );\n+    for item in tcx.associated_items(trait_ref.def_id).in_definition_order() {\n+        if item.kind == ty::AssocKind::Type {\n+            requirements.extend(tcx.item_bounds(item.def_id).subst(tcx, trait_ref.substs));\n+        }\n+    }\n+\n+    let mut replace_projection_with = FxHashMap::default();\n+    for bound in object_bound {\n+        let bound = bound.no_bound_vars().expect(\"higher-ranked projections not supported, yet\");\n+        if let ty::ExistentialPredicate::Projection(proj) = bound {\n+            let proj = proj.with_self_ty(tcx, trait_ref.self_ty());\n+            let old_ty = replace_projection_with.insert(\n+                proj.projection_ty,\n+                proj.term.ty().expect(\"expected only types in dyn right now\"),\n+            );\n+            assert_eq!(\n+                old_ty,\n+                None,\n+                \"{} has two substitutions: {} and {}\",\n+                proj.projection_ty,\n+                proj.term,\n+                old_ty.unwrap()\n+            );\n+        }\n+    }\n+\n+    requirements.fold_with(&mut ReplaceProjectionWith { tcx, mapping: replace_projection_with })\n+}\n+\n+struct ReplaceProjectionWith<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    mapping: FxHashMap<ty::AliasTy<'tcx>, Ty<'tcx>>,\n+}\n+\n+impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ReplaceProjectionWith<'tcx> {\n+    fn interner(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if let ty::Alias(ty::Projection, alias_ty) = *ty.kind()\n+            && let Some(replacement) = self.mapping.get(&alias_ty)\n+        {\n+            *replacement\n+        } else {\n+            ty.super_fold_with(self)\n+        }\n+    }\n+}"}, {"sha": "7bdd863a762c4069d3f1fdcb5a1e7f8c5c519981", "filename": "tests/ui/traits/new-solver/object-unsafety.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.rs?ref=98525aeee7b1f0ddf3573c2921a0d1ef914774a8", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+trait Setup {\n+    type From: Copy;\n+}\n+\n+fn copy<U: Setup + ?Sized>(from: &U::From) -> U::From {\n+    *from\n+}\n+\n+pub fn copy_any<T>(t: &T) -> T {\n+    copy::<dyn Setup<From=T>>(t)\n+    //~^ ERROR the trait bound `dyn Setup<From = T>: Setup` is not satisfied\n+}\n+\n+fn main() {\n+    let x = String::from(\"Hello, world\");\n+    let y = copy_any(&x);\n+    println!(\"{y}\");\n+}"}, {"sha": "198ac623df8a6836339851d26131f2bc5b3cd380", "filename": "tests/ui/traits/new-solver/object-unsafety.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98525aeee7b1f0ddf3573c2921a0d1ef914774a8/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.stderr?ref=98525aeee7b1f0ddf3573c2921a0d1ef914774a8", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `dyn Setup<From = T>: Setup` is not satisfied\n+  --> $DIR/object-unsafety.rs:12:12\n+   |\n+LL |     copy::<dyn Setup<From=T>>(t)\n+   |            ^^^^^^^^^^^^^^^^^ the trait `Setup` is not implemented for `dyn Setup<From = T>`\n+   |\n+note: required by a bound in `copy`\n+  --> $DIR/object-unsafety.rs:7:12\n+   |\n+LL | fn copy<U: Setup + ?Sized>(from: &U::From) -> U::From {\n+   |            ^^^^^ required by this bound in `copy`\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n+   |\n+LL | pub fn copy_any<T>(t: &T) -> T where dyn Setup<From = T>: Setup {\n+   |                                ++++++++++++++++++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}