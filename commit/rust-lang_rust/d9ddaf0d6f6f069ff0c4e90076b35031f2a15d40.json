{"sha": "d9ddaf0d6f6f069ff0c4e90076b35031f2a15d40", "node_id": "C_kwDOAAsO6NoAKGQ5ZGRhZjBkNmY2ZjA2OWZmMGM0ZTkwMDc2YjM1MDMxZjJhMTVkNDA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-06-11T16:57:33Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-06-11T17:24:56Z"}, "message": "Use if-let instead of match with guard", "tree": {"sha": "001ccd78b581eb3c6cddf94a2f709c1f69e4489d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/001ccd78b581eb3c6cddf94a2f709c1f69e4489d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9ddaf0d6f6f069ff0c4e90076b35031f2a15d40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9ddaf0d6f6f069ff0c4e90076b35031f2a15d40", "html_url": "https://github.com/rust-lang/rust/commit/d9ddaf0d6f6f069ff0c4e90076b35031f2a15d40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9ddaf0d6f6f069ff0c4e90076b35031f2a15d40/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c00e546679fc653396377e226a30fb0b86fd5e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c00e546679fc653396377e226a30fb0b86fd5e6", "html_url": "https://github.com/rust-lang/rust/commit/6c00e546679fc653396377e226a30fb0b86fd5e6"}], "stats": {"total": 157, "additions": 74, "deletions": 83}, "files": [{"sha": "86ad62355104ca7129257531280bebf0e5eac30d", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 74, "deletions": 83, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/d9ddaf0d6f6f069ff0c4e90076b35031f2a15d40/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ddaf0d6f6f069ff0c4e90076b35031f2a15d40/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=d9ddaf0d6f6f069ff0c4e90076b35031f2a15d40", "patch": "@@ -41,8 +41,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::InferOk;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n-use rustc_middle::ty::error::ExpectedFound;\n-use rustc_middle::ty::error::TypeError::{FieldMisMatch, Sorts};\n+use rustc_middle::ty::error::TypeError::FieldMisMatch;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TypeFoldable};\n use rustc_session::parse::feature_err;\n@@ -65,7 +64,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n-        extend_err: impl Fn(&mut Diagnostic),\n+        extend_err: impl FnMut(&mut Diagnostic),\n     ) -> Ty<'tcx> {\n         self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected), extend_err)\n     }\n@@ -74,7 +73,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        extend_err: impl Fn(&mut Diagnostic),\n+        mut extend_err: impl FnMut(&mut Diagnostic),\n     ) -> Ty<'tcx> {\n         let expected_ty = expected.to_option(&self).unwrap_or(self.tcx.types.bool);\n         let mut ty = self.check_expr_with_expectation(expr, expected);\n@@ -1557,89 +1556,81 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // FIXME: We are currently creating two branches here in order to maintain\n             // consistency. But they should be merged as much as possible.\n             let fru_tys = if self.tcx.features().type_changing_struct_update {\n-                match adt_ty.kind() {\n-                    ty::Adt(adt, substs) if adt.is_struct() => {\n-                        // Make an ADT with fresh inference substitutions. This\n-                        // will allow us to guide inference along so that, e.g.\n-                        // ```\n-                        // let x = MyStruct<'a, B, const C: usize> {\n-                        //    f: 1,\n-                        //    ..Default::default()\n-                        // };\n-                        // ```\n-                        // will have the default base expression constrained to\n-                        // `MyStruct<'_, _, _>`, as opposed to just `_`... This\n-                        // will allow us to then do a subtyping relation on all\n-                        // of the `remaining_fields` below, per the RFC.\n-                        let fresh_substs = self.fresh_substs_for_item(base_expr.span, adt.did());\n-                        let base_ty = self.check_expr_has_type_or_error(\n-                            base_expr,\n-                            self.tcx.mk_adt(*adt, fresh_substs),\n-                            |_| {},\n-                        );\n-                        let base_ty = self.shallow_resolve(base_ty);\n-                        match base_ty.kind() {\n-                            ty::Adt(base_adt, base_subs) if adt == base_adt => {\n-                                variant\n-                                    .fields\n-                                    .iter()\n-                                    .map(|f| {\n-                                        let fru_ty = self.normalize_associated_types_in(\n-                                            expr_span,\n-                                            self.field_ty(base_expr.span, f, base_subs),\n-                                        );\n-                                        let ident = self\n-                                            .tcx\n-                                            .adjust_ident(f.ident(self.tcx), variant.def_id);\n-                                        if let Some(_) = remaining_fields.remove(&ident) {\n-                                            let target_ty =\n-                                                self.field_ty(base_expr.span, f, substs);\n-                                            let cause = self.misc(base_expr.span);\n-                                            match self\n-                                                .at(&cause, self.param_env)\n-                                                .sup(target_ty, fru_ty)\n-                                            {\n-                                                Ok(InferOk { obligations, value: () }) => {\n-                                                    self.register_predicates(obligations)\n-                                                }\n-                                                // FIXME: Need better diagnostics for `FieldMisMatch` error\n-                                                Err(type_error) => {\n-                                                    debug!(\"check_expr_struct_fields: {fru_ty} sub {target_ty} failed: {type_error:?}\");\n-                                                    self.report_mismatched_types(\n-                                                        &cause,\n-                                                        target_ty,\n-                                                        fru_ty,\n-                                                        FieldMisMatch(variant.name, ident.name),\n-                                                    )\n-                                                    .emit();\n-                                                }\n-                                            }\n+                if let ty::Adt(adt, substs) = adt_ty.kind() && adt.is_struct() {\n+                    // Make an ADT with fresh inference substitutions. This\n+                    // will allow us to guide inference along so that, e.g.\n+                    // ```\n+                    // let x = MyStruct<'a, B, const C: usize> {\n+                    //    f: 1,\n+                    //    ..Default::default()\n+                    // };\n+                    // ```\n+                    // will have the default base expression constrained to\n+                    // `MyStruct<'_, _, _>`, as opposed to just `_`... This\n+                    // will allow us to then do a subtyping relation on all\n+                    // of the `remaining_fields` below, per the RFC.\n+                    let fresh_substs = self.fresh_substs_for_item(base_expr.span, adt.did());\n+                    let fresh_base_ty = self.tcx.mk_adt(*adt, fresh_substs);\n+                    let base_ty = self.check_expr_has_type_or_error(\n+                        base_expr,\n+                        fresh_base_ty,\n+                        |_| {\n+                            error_happened = true;\n+                        },\n+                    );\n+                    let base_ty = self.shallow_resolve(base_ty);\n+                    if let ty::Adt(base_adt, base_substs) = base_ty.kind() && adt == base_adt {\n+                        variant\n+                            .fields\n+                            .iter()\n+                            .map(|f| {\n+                                let fru_ty = self.normalize_associated_types_in(\n+                                    expr_span,\n+                                    self.field_ty(base_expr.span, f, base_substs),\n+                                );\n+                                let ident = self\n+                                    .tcx\n+                                    .adjust_ident(f.ident(self.tcx), variant.def_id);\n+                                if let Some(_) = remaining_fields.remove(&ident) {\n+                                    let target_ty =\n+                                        self.field_ty(base_expr.span, f, substs);\n+                                    let cause = self.misc(base_expr.span);\n+                                    match self\n+                                        .at(&cause, self.param_env)\n+                                        .sup(target_ty, fru_ty)\n+                                    {\n+                                        Ok(InferOk { obligations, value: () }) => {\n+                                            self.register_predicates(obligations)\n                                         }\n-                                        self.resolve_vars_if_possible(fru_ty)\n-                                    })\n-                                    .collect()\n-                            }\n-                            _ => {\n-                                self.report_mismatched_types(\n-                                    &self.misc(base_expr.span),\n-                                    adt_ty,\n-                                    base_ty,\n-                                    Sorts(ExpectedFound::new(true, adt_ty, base_ty)),\n-                                )\n-                                .emit();\n-                                return;\n-                            }\n+                                        // FIXME: Need better diagnostics for `FieldMisMatch` error\n+                                        Err(_) => {\n+                                            self.report_mismatched_types(\n+                                                &cause,\n+                                                target_ty,\n+                                                fru_ty,\n+                                                FieldMisMatch(variant.name, ident.name),\n+                                            )\n+                                            .emit();\n+                                        }\n+                                    }\n+                                }\n+                                self.resolve_vars_if_possible(fru_ty)\n+                            })\n+                            .collect()\n+                    } else {\n+                        if !error_happened && !base_ty.references_error() {\n+                            span_bug!(base_expr.span, \"expected an error to have been reported in `check_expr_has_type_or_error`\");\n                         }\n-                    }\n-                    _ => {\n-                        // Check the base_expr, regardless of a bad expected adt_ty, so we can get\n-                        // type errors on that expression, too.\n-                        self.check_expr(base_expr);\n-                        self.tcx\n-                            .sess\n-                            .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n                         return;\n                     }\n+                } else {\n+                    // Check the base_expr, regardless of a bad expected adt_ty, so we can get\n+                    // type errors on that expression, too.\n+                    self.check_expr(base_expr);\n+                    self.tcx\n+                        .sess\n+                        .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n+                    return;\n                 }\n             } else {\n                 self.check_expr_has_type_or_error(base_expr, adt_ty, |_| {"}]}