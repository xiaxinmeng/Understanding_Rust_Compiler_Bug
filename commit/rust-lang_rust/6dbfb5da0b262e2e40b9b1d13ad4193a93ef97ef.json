{"sha": "6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkYmZiNWRhMGIyNjJlMmU0MGI5YjFkMTNhZDQxOTNhOTNlZjk3ZWY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-16T20:51:46Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-23T19:37:32Z"}, "message": "libcore: Use LLVM intrinsics for floor; add a new Perlin noise benchmark. r=brson", "tree": {"sha": "486cdd193c951ab7279e1a97d9188234387aaaf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/486cdd193c951ab7279e1a97d9188234387aaaf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef", "html_url": "https://github.com/rust-lang/rust/commit/6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "778aec998b0a4a34632b22abd8c1cfa599fe78f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/778aec998b0a4a34632b22abd8c1cfa599fe78f0", "html_url": "https://github.com/rust-lang/rust/commit/778aec998b0a4a34632b22abd8c1cfa599fe78f0"}], "stats": {"total": 132, "additions": 129, "deletions": 3}, "files": [{"sha": "795a9f9371c3c3ac9ef3eeeb62d7f64163998ed8", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef", "patch": "@@ -56,7 +56,6 @@ delegate!(fn exp2(n: c_float) -> c_float = cmath::c_float_utils::exp2)\n delegate!(fn abs(n: c_float) -> c_float = cmath::c_float_utils::abs)\n delegate!(fn abs_sub(a: c_float, b: c_float) -> c_float =\n     cmath::c_float_utils::abs_sub)\n-delegate!(fn floor(n: c_float) -> c_float = cmath::c_float_utils::floor)\n delegate!(fn mul_add(a: c_float, b: c_float, c: c_float) -> c_float =\n     cmath::c_float_utils::mul_add)\n delegate!(fn fmax(a: c_float, b: c_float) -> c_float =\n@@ -141,6 +140,10 @@ pub pure fn ge(x: f32, y: f32) -> bool { return x >= y; }\n #[inline(always)]\n pub pure fn gt(x: f32, y: f32) -> bool { return x > y; }\n \n+/// Returns `x` rounded down\n+#[inline(always)]\n+pub pure fn floor(x: f32) -> f32 { unsafe { floorf32(x) } }\n+\n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n@@ -298,6 +301,11 @@ impl f32: num::One {\n     static pure fn one() -> f32 { 1.0 }\n }\n \n+#[abi=\"rust-intrinsic\"]\n+pub extern {\n+    fn floorf32(val: f32) -> f32;\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "8cd94c9357d610bc566b0fceec7753a82b8927d3", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef", "patch": "@@ -57,7 +57,6 @@ delegate!(fn exp2(n: c_double) -> c_double = cmath::c_double_utils::exp2)\n delegate!(fn abs(n: c_double) -> c_double = cmath::c_double_utils::abs)\n delegate!(fn abs_sub(a: c_double, b: c_double) -> c_double =\n     cmath::c_double_utils::abs_sub)\n-delegate!(fn floor(n: c_double) -> c_double = cmath::c_double_utils::floor)\n delegate!(fn mul_add(a: c_double, b: c_double, c: c_double) -> c_double =\n     cmath::c_double_utils::mul_add)\n delegate!(fn fmax(a: c_double, b: c_double) -> c_double =\n@@ -210,12 +209,16 @@ pub pure fn is_infinite(x: f64) -> bool {\n     return x == infinity || x == neg_infinity;\n }\n \n-/// Returns true if `x`is a finite number\n+/// Returns true if `x` is a finite number\n #[inline(always)]\n pub pure fn is_finite(x: f64) -> bool {\n     return !(is_NaN(x) || is_infinite(x));\n }\n \n+/// Returns `x` rounded down\n+#[inline(always)]\n+pub pure fn floor(x: f64) -> f64 { unsafe { floorf64(x) } }\n+\n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n \n /* Module: consts */\n@@ -322,6 +325,11 @@ impl f64: num::One {\n     static pure fn one() -> f64 { 1.0 }\n }\n \n+#[abi=\"rust-intrinsic\"]\n+pub extern {\n+    fn floorf64(val: f64) -> f64;\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "a07dcee35f4d35acb6d5c49377b212be1f36f7ab", "filename": "src/test/bench/noise.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=6dbfb5da0b262e2e40b9b1d13ad4193a93ef97ef", "patch": "@@ -0,0 +1,110 @@\n+// Perlin noise benchmark from https://gist.github.com/1170424\n+\n+struct Vec2 {\n+    x: f32,\n+    y: f32,\n+}\n+\n+fn lerp(a: f32, b: f32, v: f32) -> f32  { a * (1.0 - v) + b * v }\n+fn smooth(v: f32) -> f32                { v * v * (3.0 - 2.0 * v) }\n+\n+fn random_gradient(r: rand::Rng) -> Vec2 {\n+    let v = r.gen_float() * float::consts::pi * 2.0;\n+    Vec2{\n+        x: float::cos(v) as f32,\n+        y: float::sin(v) as f32,\n+    }\n+}\n+\n+fn gradient(orig: Vec2, grad: Vec2, p: Vec2) -> f32 {\n+    let sp = Vec2{x: p.x - orig.x, y: p.y - orig.y};\n+    grad.x * sp.x + grad.y + sp.y\n+}\n+\n+struct Noise2DContext {\n+    rgradients: [Vec2 * 256],\n+    permutations: [int * 256],\n+}\n+\n+fn Noise2DContext() -> ~Noise2DContext {\n+    let r = rand::Rng();\n+    let mut rgradients = [ Vec2 { x: 0.0, y: 0.0 }, ..256 ];\n+    for int::range(0, 256) |i| { rgradients[i] = random_gradient(r); }\n+    let mut permutations = [ 0, ..256 ];\n+    for int::range(0, 256) |i| { permutations[i] = i; }\n+    r.shuffle_mut(permutations);\n+\n+    ~Noise2DContext{\n+        rgradients: move rgradients,\n+        permutations: move permutations,\n+    }\n+}\n+\n+impl Noise2DContext {\n+    #[inline(always)]\n+    fn get_gradient(&self, x: int, y: int) -> Vec2 {\n+        let idx = self.permutations[x & 255] + self.permutations[y & 255];\n+        self.rgradients[idx & 255]\n+    }\n+\n+    #[inline(always)]\n+    fn get_gradients(&self, gradients: &mut [Vec2 * 4], origins: &mut [Vec2 * 4], x: f32, y: f32) {\n+        let x0f = f32::floor(x);\n+        let y0f = f32::floor(y);\n+        let x0 = x0f as int;\n+        let y0 = y0f as int;\n+        let x1 = x0 + 1;\n+        let y1 = y0 + 1;\n+\n+        gradients[0] = self.get_gradient(x0, y0);\n+        gradients[1] = self.get_gradient(x1, y0);\n+        gradients[2] = self.get_gradient(x0, y1);\n+        gradients[3] = self.get_gradient(x1, y1);\n+\n+        origins[0] = Vec2{x: x0f + 0.0, y: y0f + 0.0};\n+        origins[1] = Vec2{x: x0f + 1.0, y: y0f + 0.0};\n+        origins[2] = Vec2{x: x0f + 0.0, y: y0f + 1.0};\n+        origins[3] = Vec2{x: x0f + 1.0, y: y0f + 1.0};\n+    }\n+\n+    fn get(&self, x: f32, y: f32) -> f32 {\n+        let p = Vec2{x: x, y: y};\n+        let mut gradients = [ Vec2 { x: 0.0, y: 0.0 }, ..4 ];\n+        let mut origins = [ Vec2 { x: 0.0, y: 0.0 }, ..4 ];\n+        self.get_gradients(&mut gradients, &mut origins, x, y);\n+        let v0 = gradient(origins[0], gradients[0], p);\n+        let v1 = gradient(origins[1], gradients[1], p);\n+        let v2 = gradient(origins[2], gradients[2], p);\n+        let v3 = gradient(origins[3], gradients[3], p);\n+        let fx = smooth(x - origins[0].x);\n+        let vx0 = lerp(v0, v1, fx);\n+        let vx1 = lerp(v2, v3, fx);\n+        let fy = smooth(y - origins[0].y);\n+        lerp(vx0, vx1, fy)\n+    }\n+}\n+\n+fn main() {\n+    let symbols = [\" \", \"\u2591\", \"\u2592\", \"\u2593\", \"\u2588\", \"\u2588\"];\n+    let mut pixels = vec::from_elem(256*256, 0f32);\n+    let n2d = Noise2DContext();\n+    for int::range(0, 100) |_| {\n+        for int::range(0, 256) |y| {\n+            for int::range(0, 256) |x| {\n+                let v = n2d.get(\n+                    x as f32 * 0.1f32,\n+                    y as f32 * 0.1f32\n+                ) * 0.5f32 + 0.5f32;\n+                pixels[y*256+x] = v;\n+            };\n+        };\n+    };\n+\n+    /*for int::range(0, 256) |y| {\n+        for int::range(0, 256) |x| {\n+            io::print(symbols[pixels[y*256+x] / 0.2f32 as int]);\n+        }\n+        io::println(\"\");\n+    }*/\n+}\n+"}]}