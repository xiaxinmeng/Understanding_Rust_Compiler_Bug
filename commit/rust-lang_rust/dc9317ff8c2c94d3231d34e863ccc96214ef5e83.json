{"sha": "dc9317ff8c2c94d3231d34e863ccc96214ef5e83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjOTMxN2ZmOGMyYzk0ZDMyMzFkMzRlODYzY2NjOTYyMTRlZjVlODM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-19T20:12:00Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T13:38:26Z"}, "message": "use `IfEq` to defer equality comparison around `where` clauses`", "tree": {"sha": "cc33c1032ff849b42f1af539f569fdf209c30482", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc33c1032ff849b42f1af539f569fdf209c30482"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc9317ff8c2c94d3231d34e863ccc96214ef5e83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc9317ff8c2c94d3231d34e863ccc96214ef5e83", "html_url": "https://github.com/rust-lang/rust/commit/dc9317ff8c2c94d3231d34e863ccc96214ef5e83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc9317ff8c2c94d3231d34e863ccc96214ef5e83/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23", "html_url": "https://github.com/rust-lang/rust/commit/7f8c42d7f01b36132588ff0cd6b1c6a90ed52b23"}], "stats": {"total": 108, "additions": 59, "deletions": 49}, "files": [{"sha": "332859d4f81db28fd6b24471e4c40ba24126bba6", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dc9317ff8c2c94d3231d34e863ccc96214ef5e83/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9317ff8c2c94d3231d34e863ccc96214ef5e83/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=dc9317ff8c2c94d3231d34e863ccc96214ef5e83", "patch": "@@ -401,12 +401,9 @@ where\n         // Compute the bounds we can derive from the trait definition.\n         // These are guaranteed to apply, no matter the inference\n         // results.\n-        let trait_bounds = self.verify_bound\n-            .projection_declared_bounds_from_trait(projection_ty);\n-        debug!(\n-            \"projection_must_outlive: trait_bounds={:?}\",\n-            trait_bounds\n-        );\n+        let trait_bounds: Vec<_> = self.verify_bound\n+            .projection_declared_bounds_from_trait(projection_ty)\n+            .collect();\n \n         // If declared bounds list is empty, the only applicable rule is\n         // OutlivesProjectionComponent. If there are inference variables,\n@@ -451,7 +448,7 @@ where\n         if !trait_bounds.is_empty()\n             && trait_bounds[1..]\n                 .iter()\n-                .chain(&approx_env_bounds)\n+                .chain(approx_env_bounds.iter().map(|b| &b.1))\n                 .all(|b| *b == trait_bounds[0])\n         {\n             let unique_bound = trait_bounds[0];"}, {"sha": "5b23fc19a9d1ba874ef5c24a1e8bb0185ff9eed7", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 55, "deletions": 42, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/dc9317ff8c2c94d3231d34e863ccc96214ef5e83/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9317ff8c2c94d3231d34e863ccc96214ef5e83/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=dc9317ff8c2c94d3231d34e863ccc96214ef5e83", "patch": "@@ -14,6 +14,7 @@ use infer::{GenericKind, VerifyBound};\n use traits;\n use ty::subst::{Subst, Substs};\n use ty::{self, Ty, TyCtxt};\n+use util::captures::Captures;\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n /// obligation into a series of `'a: 'b` constraints and \"verifys\", as\n@@ -65,21 +66,15 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n \n         // Start with anything like `T: 'a` we can scrape from the\n         // environment\n-        let param_bounds =\n-            self.declared_generic_bounds_from_env(GenericKind::Param(param_ty))\n-            .into_iter();\n+        let param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty))\n+            .into_iter()\n+            .map(|outlives| outlives.1);\n \n         // Add in the default bound of fn body that applies to all in\n         // scope type parameters:\n-        let param_bounds =\n-            param_bounds\n-            .chain(self.implicit_region_bound);\n+        let param_bounds = param_bounds.chain(self.implicit_region_bound);\n \n-        VerifyBound::AnyBound(\n-            param_bounds\n-                .map(|r| VerifyBound::OutlivedBy(r))\n-                .collect()\n-        )\n+        VerifyBound::AnyBound(param_bounds.map(|r| VerifyBound::OutlivedBy(r)).collect())\n     }\n \n     /// Given a projection like `T::Item`, searches the environment\n@@ -98,7 +93,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     pub fn projection_approx_declared_bounds_from_env(\n         &self,\n         projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n+    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n         let projection_ty = GenericKind::Projection(projection_ty).to_ty(self.tcx);\n         let erased_projection_ty = self.tcx.erase_regions(&projection_ty);\n         self.declared_generic_bounds_from_env_with_compare_fn(|ty| {\n@@ -117,31 +112,42 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     pub fn projection_declared_bounds_from_trait(\n         &self,\n         projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'gcx> {\n         self.declared_projection_bounds_from_trait(projection_ty)\n     }\n \n     pub fn projection_bound(&self, projection_ty: ty::ProjectionTy<'tcx>) -> VerifyBound<'tcx> {\n         debug!(\"projection_bound(projection_ty={:?})\", projection_ty);\n \n+        let projection_ty_as_ty =\n+            self.tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs);\n+\n         // Search the env for where clauses like `P: 'a`.\n-        let env_bounds =\n-            self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty))\n-            .into_iter();\n+        let env_bounds = self.projection_approx_declared_bounds_from_env(projection_ty)\n+            .into_iter()\n+            .map(|ty::OutlivesPredicate(ty, r)| {\n+                let vb = VerifyBound::OutlivedBy(r);\n+                if ty == projection_ty_as_ty {\n+                    // Micro-optimize if this is an exact match (this\n+                    // occurs often when there are no region variables\n+                    // involved).\n+                    vb\n+                } else {\n+                    VerifyBound::IfEq(ty, Box::new(vb))\n+                }\n+            });\n \n         // Extend with bounds that we can find from the trait.\n-        let trait_bounds =\n-            self.projection_declared_bounds_from_trait(projection_ty)\n-            .into_iter();\n+        let trait_bounds = self.projection_declared_bounds_from_trait(projection_ty)\n+            .into_iter()\n+            .map(|r| VerifyBound::OutlivedBy(r));\n \n         // see the extensive comment in projection_must_outlive\n         let ty = self.tcx\n             .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n         let recursive_bound = self.recursive_type_bound(ty);\n \n-        VerifyBound::AnyBound(\n-            env_bounds.chain(trait_bounds).map(|r| VerifyBound::OutlivedBy(r)).collect()\n-        ).or(recursive_bound)\n+        VerifyBound::AnyBound(env_bounds.chain(trait_bounds).collect()).or(recursive_bound)\n     }\n \n     fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n@@ -151,11 +157,12 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n \n         let mut regions = ty.regions();\n         regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n-        bounds.push(\n-            VerifyBound::AllBounds(\n-                regions.into_iter().map(|r| VerifyBound::OutlivedBy(r)).collect()\n-            )\n-        );\n+        bounds.push(VerifyBound::AllBounds(\n+            regions\n+                .into_iter()\n+                .map(|r| VerifyBound::OutlivedBy(r))\n+                .collect(),\n+        ));\n \n         // remove bounds that must hold, since they are not interesting\n         bounds.retain(|b| !b.must_hold());\n@@ -176,15 +183,15 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     fn declared_generic_bounds_from_env(\n         &self,\n         generic: GenericKind<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n+    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n         let generic_ty = generic.to_ty(self.tcx);\n         self.declared_generic_bounds_from_env_with_compare_fn(|ty| ty == generic_ty)\n     }\n \n     fn declared_generic_bounds_from_env_with_compare_fn(\n         &self,\n         compare_ty: impl Fn(Ty<'tcx>) -> bool,\n-    ) -> Vec<ty::Region<'tcx>> {\n+    ) -> Vec<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n         let tcx = self.tcx;\n \n         // To start, collect bounds from user environment. Note that\n@@ -212,14 +219,23 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n                 \"declared_generic_bounds_from_env_with_compare_fn: region_bound_pair = {:?}\",\n                 (r, p)\n             );\n-            if compare_ty(p.to_ty(tcx)) {\n-                Some(r)\n+            let p_ty = p.to_ty(tcx);\n+            if compare_ty(p_ty) {\n+                Some(ty::OutlivesPredicate(p_ty, r))\n             } else {\n                 None\n             }\n         });\n \n-        param_bounds.chain(from_region_bound_pairs).collect()\n+        param_bounds\n+            .chain(from_region_bound_pairs)\n+            .inspect(|bound| {\n+                debug!(\n+                    \"declared_generic_bounds_from_env_with_compare_fn: result predicate = {:?}\",\n+                    bound\n+                )\n+            })\n+            .collect()\n     }\n \n     /// Given a projection like `<T as Foo<'x>>::Bar`, returns any bounds\n@@ -237,13 +253,11 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     fn declared_projection_bounds_from_trait(\n         &self,\n         projection_ty: ty::ProjectionTy<'tcx>,\n-    ) -> Vec<ty::Region<'tcx>> {\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'gcx> {\n         debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n-        let mut bounds = self.region_bounds_declared_on_associated_item(projection_ty.item_def_id);\n-        for r in &mut bounds {\n-            *r = r.subst(self.tcx, projection_ty.substs);\n-        }\n-        bounds\n+        let tcx = self.tcx;\n+        self.region_bounds_declared_on_associated_item(projection_ty.item_def_id)\n+            .map(move |r| r.subst(tcx, projection_ty.substs))\n     }\n \n     /// Given the def-id of an associated item, returns any region\n@@ -279,7 +293,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     fn region_bounds_declared_on_associated_item(\n         &self,\n         assoc_item_def_id: DefId,\n-    ) -> Vec<ty::Region<'tcx>> {\n+    ) -> impl Iterator<Item = ty::Region<'tcx>> + 'cx + Captures<'gcx> {\n         let tcx = self.tcx;\n         let assoc_item = tcx.associated_item(assoc_item_def_id);\n         let trait_def_id = assoc_item.container.assert_trait();\n@@ -289,7 +303,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n         self.collect_outlives_from_predicate_list(\n             move |ty| ty == identity_proj,\n             traits::elaborate_predicates(tcx, trait_predicates.predicates),\n-        ).collect()\n+        ).map(|b| b.1)\n     }\n \n     /// Searches through a predicate list for a predicate `T: 'a`.\n@@ -302,12 +316,11 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n         &self,\n         compare_ty: impl Fn(Ty<'tcx>) -> bool,\n         predicates: impl IntoIterator<Item = impl AsRef<ty::Predicate<'tcx>>>,\n-    ) -> impl Iterator<Item = ty::Region<'tcx>> {\n+    ) -> impl Iterator<Item = ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n         predicates\n             .into_iter()\n             .filter_map(|p| p.as_ref().to_opt_type_outlives())\n             .filter_map(|p| p.no_late_bound_regions())\n             .filter(move |p| compare_ty(p.0))\n-            .map(|p| p.1)\n     }\n }"}]}