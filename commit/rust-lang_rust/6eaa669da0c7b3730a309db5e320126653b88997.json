{"sha": "6eaa669da0c7b3730a309db5e320126653b88997", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYWE2NjlkYTBjN2IzNzMwYTMwOWRiNWUzMjAxMjY2NTNiODg5OTc=", "commit": {"author": {"name": "Roland Ruckerbauer", "email": "roland.rucky@gmail.com", "date": "2020-05-19T19:03:59Z"}, "committer": {"name": "Roland Ruckerbauer", "email": "roland.rucky@gmail.com", "date": "2020-05-19T19:06:47Z"}, "message": "loop return value inference: coerce_merge branches", "tree": {"sha": "9771a59dc7398f0de8d2d707f77ecb73a83f53c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9771a59dc7398f0de8d2d707f77ecb73a83f53c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6eaa669da0c7b3730a309db5e320126653b88997", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6eaa669da0c7b3730a309db5e320126653b88997", "html_url": "https://github.com/rust-lang/rust/commit/6eaa669da0c7b3730a309db5e320126653b88997", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6eaa669da0c7b3730a309db5e320126653b88997/comments", "author": null, "committer": null, "parents": [{"sha": "0fe876925e59aad4765b415d9caaf262a6d43c4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fe876925e59aad4765b415d9caaf262a6d43c4c", "html_url": "https://github.com/rust-lang/rust/commit/0fe876925e59aad4765b415d9caaf262a6d43c4c"}], "stats": {"total": 38, "additions": 23, "deletions": 15}, "files": [{"sha": "83702ada044cd154cfb58b64002b3caa8d49bd23", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6eaa669da0c7b3730a309db5e320126653b88997/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eaa669da0c7b3730a309db5e320126653b88997/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=6eaa669da0c7b3730a309db5e320126653b88997", "patch": "@@ -93,14 +93,17 @@ impl<'a> InferenceContext<'a> {\n                 Ty::Unknown\n             }\n             Expr::Loop { body } => {\n-                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n+                self.breakables.push(BreakableContext {\n+                    may_break: false,\n+                    break_ty: self.table.new_type_var(),\n+                });\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n \n                 let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 if ctxt.may_break {\n                     self.diverges = Diverges::Maybe;\n                 }\n-                // FIXME handle break with value\n+\n                 if ctxt.may_break {\n                     ctxt.break_ty\n                 } else {\n@@ -229,26 +232,31 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Continue => Ty::simple(TypeCtor::Never),\n             Expr::Break { expr } => {\n-                let mut has_val_ty = None;\n+                let val_ty = if let Some(expr) = expr {\n+                    self.infer_expr(*expr, &Expectation::none())\n+                } else {\n+                    Ty::unit()\n+                };\n \n-                if let Some(expr) = expr {\n-                    has_val_ty = Some(self.infer_expr(*expr, &Expectation::none()));\n-                }\n+                let mut has_brkctx = false;\n \n-                if let Some(ctxt) = self.breakables.last_mut() {\n-                    ctxt.may_break = true;\n-                    if let Some(val_ty) = has_val_ty {\n-                        if ctxt.break_ty == Ty::Unknown {\n-                            ctxt.break_ty = val_ty;\n-                        } else if ctxt.break_ty != val_ty {\n-                            // TODO: Unify partially matching type information (Option<{unknown}> + Option<i32> => Option<i32>)\n-                        }\n-                    }\n+                if self.breakables.last().is_some() {\n+                    has_brkctx = true;\n                 } else {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,\n                     });\n                 }\n+\n+                if has_brkctx {\n+                    let last_ty = self.breakables.last().expect(\"This is a bug\").break_ty.clone();\n+                    let merged_type = self.coerce_merge_branch(&last_ty, &val_ty);\n+\n+                    let ctxt = self.breakables.last_mut().expect(\"This is a bug\");\n+                    ctxt.may_break = true;\n+                    ctxt.break_ty = merged_type;\n+                }\n+\n                 Ty::simple(TypeCtor::Never)\n             }\n             Expr::Return { expr } => {"}]}