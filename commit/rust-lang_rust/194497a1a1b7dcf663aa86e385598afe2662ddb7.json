{"sha": "194497a1a1b7dcf663aa86e385598afe2662ddb7", "node_id": "C_kwDOAAsO6NoAKDE5NDQ5N2ExYTFiN2RjZjY2M2FhODZlMzg1NTk4YWZlMjY2MmRkYjc", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-10T09:06:59Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-14T16:26:11Z"}, "message": "Remove attempt to optimize codegen for discriminants.", "tree": {"sha": "c67e638690fadb28724ad51e506875585d3fd870", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c67e638690fadb28724ad51e506875585d3fd870"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/194497a1a1b7dcf663aa86e385598afe2662ddb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/194497a1a1b7dcf663aa86e385598afe2662ddb7", "html_url": "https://github.com/rust-lang/rust/commit/194497a1a1b7dcf663aa86e385598afe2662ddb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/194497a1a1b7dcf663aa86e385598afe2662ddb7/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65c334ee8c1bb8ba9316f82a1cbcef3880cc5db2", "url": "https://api.github.com/repos/rust-lang/rust/commits/65c334ee8c1bb8ba9316f82a1cbcef3880cc5db2", "html_url": "https://github.com/rust-lang/rust/commit/65c334ee8c1bb8ba9316f82a1cbcef3880cc5db2"}], "stats": {"total": 92, "additions": 0, "deletions": 92}, "files": [{"sha": "a58a61cd567fc6139120ef4d2862759777bcc0fb", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/194497a1a1b7dcf663aa86e385598afe2662ddb7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194497a1a1b7dcf663aa86e385598afe2662ddb7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=194497a1a1b7dcf663aa86e385598afe2662ddb7", "patch": "@@ -211,7 +211,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     ) -> V {\n         let dl = &bx.tcx().data_layout;\n         let cast_to_layout = bx.cx().layout_of(cast_to);\n-        let cast_to_size = cast_to_layout.layout.size();\n         let cast_to = bx.cx().immediate_backend_type(cast_to_layout);\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_poison(cast_to);\n@@ -261,21 +260,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     _ => (tag_imm, bx.cx().immediate_backend_type(tag_op.layout)),\n                 };\n \n-                let tag_size = tag_scalar.size(bx.cx());\n-                let max_unsigned = tag_size.unsigned_int_max();\n-                let max_signed = tag_size.signed_int_max() as u128;\n-                let min_signed = max_signed + 1;\n                 let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-                let niche_end = niche_start.wrapping_add(relative_max as u128) & max_unsigned;\n-                let range = tag_scalar.valid_range(bx.cx());\n-\n-                let sle = |lhs: u128, rhs: u128| -> bool {\n-                    // Signed and unsigned comparisons give the same results,\n-                    // except that in signed comparisons an integer with the\n-                    // sign bit set is less than one with the sign bit clear.\n-                    // Toggle the sign bit to do a signed comparison.\n-                    (lhs ^ min_signed) <= (rhs ^ min_signed)\n-                };\n \n                 // We have a subrange `niche_start..=niche_end` inside `range`.\n                 // If the value of the tag is inside this subrange, it's a\n@@ -291,49 +276,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 //     untagged_variant\n                 // }\n                 // However, we will likely be able to emit simpler code.\n-\n-                // Find the least and greatest values in `range`, considered\n-                // both as signed and unsigned.\n-                let (low_unsigned, high_unsigned) = if range.start <= range.end {\n-                    (range.start, range.end)\n-                } else {\n-                    (0, max_unsigned)\n-                };\n-                let (low_signed, high_signed) = if sle(range.start, range.end) {\n-                    (range.start, range.end)\n-                } else {\n-                    (min_signed, max_signed)\n-                };\n-\n-                let niches_ule = niche_start <= niche_end;\n-                let niches_sle = sle(niche_start, niche_end);\n-                let cast_smaller = cast_to_size <= tag_size;\n-\n-                // In the algorithm above, we can change\n-                // cast(relative_tag) + niche_variants.start()\n-                // into\n-                // cast(tag + (niche_variants.start() - niche_start))\n-                // if either the casted type is no larger than the original\n-                // type, or if the niche values are contiguous (in either the\n-                // signed or unsigned sense).\n-                let can_incr = cast_smaller || niches_ule || niches_sle;\n-\n-                let data_for_boundary_niche = || -> Option<(IntPredicate, u128)> {\n-                    if !can_incr {\n-                        None\n-                    } else if niche_start == low_unsigned {\n-                        Some((IntPredicate::IntULE, niche_end))\n-                    } else if niche_end == high_unsigned {\n-                        Some((IntPredicate::IntUGE, niche_start))\n-                    } else if niche_start == low_signed {\n-                        Some((IntPredicate::IntSLE, niche_end))\n-                    } else if niche_end == high_signed {\n-                        Some((IntPredicate::IntSGE, niche_start))\n-                    } else {\n-                        None\n-                    }\n-                };\n-\n                 let (is_niche, tagged_discr, delta) = if relative_max == 0 {\n                     // Best case scenario: only one tagged variant. This will\n                     // likely become just a comparison and a jump.\n@@ -349,40 +291,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     let tagged_discr =\n                         bx.cx().const_uint(cast_to, niche_variants.start().as_u32() as u64);\n                     (is_niche, tagged_discr, 0)\n-                } else if let Some((predicate, constant)) = data_for_boundary_niche() {\n-                    // The niche values are either the lowest or the highest in\n-                    // `range`. We can avoid the first subtraction in the\n-                    // algorithm.\n-                    // The algorithm is now this:\n-                    // is_niche = tag <= niche_end\n-                    // discr = if is_niche {\n-                    //     cast(tag + (niche_variants.start() - niche_start))\n-                    // } else {\n-                    //     untagged_variant\n-                    // }\n-                    // (the first line may instead be tag >= niche_start,\n-                    // and may be a signed or unsigned comparison)\n-                    // The arithmetic must be done before the cast, so we can\n-                    // have the correct wrapping behavior. See issue #104519 for\n-                    // the consequences of getting this wrong.\n-                    let is_niche =\n-                        bx.icmp(predicate, tag, bx.cx().const_uint_big(tag_llty, constant));\n-                    let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n-                    let incr_tag = if delta == 0 {\n-                        tag\n-                    } else {\n-                        bx.add(tag, bx.cx().const_uint_big(tag_llty, delta))\n-                    };\n-\n-                    let cast_tag = if cast_smaller {\n-                        bx.intcast(incr_tag, cast_to, false)\n-                    } else if niches_ule {\n-                        bx.zext(incr_tag, cast_to)\n-                    } else {\n-                        bx.sext(incr_tag, cast_to)\n-                    };\n-\n-                    (is_niche, cast_tag, 0)\n                 } else {\n                     // The special cases don't apply, so we'll have to go with\n                     // the general algorithm."}]}