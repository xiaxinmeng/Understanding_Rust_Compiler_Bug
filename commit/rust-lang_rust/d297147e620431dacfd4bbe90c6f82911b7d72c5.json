{"sha": "d297147e620431dacfd4bbe90c6f82911b7d72c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyOTcxNDdlNjIwNDMxZGFjZmQ0YmJlOTBjNmY4MjkxMWI3ZDcyYzU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-24T18:13:44Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:19:22Z"}, "message": "Split bounds from predicates", "tree": {"sha": "7d484c524f382463983e0ec2789c4c1d3b7d9acd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d484c524f382463983e0ec2789c4c1d3b7d9acd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d297147e620431dacfd4bbe90c6f82911b7d72c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d297147e620431dacfd4bbe90c6f82911b7d72c5", "html_url": "https://github.com/rust-lang/rust/commit/d297147e620431dacfd4bbe90c6f82911b7d72c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d297147e620431dacfd4bbe90c6f82911b7d72c5/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7ead3bd539e75cb2e881238406a203023f1acd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7ead3bd539e75cb2e881238406a203023f1acd3", "html_url": "https://github.com/rust-lang/rust/commit/a7ead3bd539e75cb2e881238406a203023f1acd3"}], "stats": {"total": 384, "additions": 153, "deletions": 231}, "files": [{"sha": "2662f6b6ed65cec9781549636b480ea35045e207", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=d297147e620431dacfd4bbe90c6f82911b7d72c5", "patch": "@@ -937,7 +937,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .inferred_outlives\n             .get(self, item_id)\n-            .map(|predicates| predicates.decode((self, tcx)))\n+            .map(|predicates| tcx.arena.alloc_from_iter(predicates.decode((self, tcx))))\n             .unwrap_or_default()\n     }\n \n@@ -949,6 +949,19 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.root.tables.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n+    fn get_explicit_item_bounds(\n+        &self,\n+        item_id: DefIndex,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+        self.root\n+            .tables\n+            .explicit_item_bounds\n+            .get(self, item_id)\n+            .map(|bounds| tcx.arena.alloc_from_iter(bounds.decode((self, tcx))))\n+            .unwrap_or_default()\n+    }\n+\n     fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n         self.root.tables.generics.get(self, item_id).unwrap().decode((self, sess))\n     }"}, {"sha": "60705f68681a1d6170a600ff5a05533695f3af7e", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=d297147e620431dacfd4bbe90c6f82911b7d72c5", "patch": "@@ -89,6 +89,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     explicit_predicates_of => { cdata.get_explicit_predicates(def_id.index, tcx) }\n     inferred_outlives_of => { cdata.get_inferred_outlives(def_id.index, tcx) }\n     super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n+    explicit_item_bounds => { cdata.get_explicit_item_bounds(def_id.index, tcx) }\n     trait_def => { cdata.get_trait_def(def_id.index, tcx.sess) }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n     adt_destructor => {"}, {"sha": "9f12edf9cb2f85efed82a7687379bf9c2af4da05", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d297147e620431dacfd4bbe90c6f82911b7d72c5", "patch": "@@ -965,6 +965,14 @@ impl EncodeContext<'a, 'tcx> {\n         record!(self.tables.super_predicates[def_id] <- self.tcx.super_predicates_of(def_id));\n     }\n \n+    fn encode_explicit_item_bounds(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_explicit_item_bounds({:?})\", def_id);\n+        let bounds = self.tcx.explicit_item_bounds(def_id);\n+        if !bounds.is_empty() {\n+            record!(self.tables.explicit_item_bounds[def_id] <- bounds);\n+        }\n+    }\n+\n     fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -1017,7 +1025,10 @@ impl EncodeContext<'a, 'tcx> {\n                     has_self: trait_item.fn_has_self_parameter,\n                 }))\n             }\n-            ty::AssocKind::Type => EntryKind::AssocType(container),\n+            ty::AssocKind::Type => {\n+                self.encode_explicit_item_bounds(def_id);\n+                EntryKind::AssocType(container)\n+            }\n         });\n         record!(self.tables.visibility[def_id] <- trait_item.vis);\n         record!(self.tables.span[def_id] <- ast_item.span);"}, {"sha": "2bd2019d3cdb529b617f00d274ee4db57e7470bc", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=d297147e620431dacfd4bbe90c6f82911b7d72c5", "patch": "@@ -295,13 +295,11 @@ define_tables! {\n     generics: Table<DefIndex, Lazy<ty::Generics>>,\n     explicit_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n     expn_that_defined: Table<DefIndex, Lazy<ExpnId>>,\n-    // FIXME(eddyb) this would ideally be `Lazy<[...]>` but `ty::Predicate`\n-    // doesn't handle shorthands in its own (de)serialization impls,\n-    // as it's an `enum` for which we want to derive (de)serialization,\n-    // so the `ty::codec` APIs handle the whole `&'tcx [...]` at once.\n-    // Also, as an optimization, a missing entry indicates an empty `&[]`.\n-    inferred_outlives: Table<DefIndex, Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>,\n+    // As an optimization, a missing entry indicates an empty `&[]`.\n+    inferred_outlives: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n     super_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n+    // As an optimization, a missing entry indicates an empty `&[]`.\n+    explicit_item_bounds: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n     mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n     mir_abstract_consts: Table<DefIndex, Lazy!(&'tcx [mir::abstract_const::Node<'tcx>])>,"}, {"sha": "8b94818d8e651ad194b227b7c8932b478771b54a", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=d297147e620431dacfd4bbe90c6f82911b7d72c5", "patch": "@@ -169,8 +169,13 @@ rustc_queries! {\n         ///      ^^^^^^^^^^^^^^^\n         ///\n         /// `key` is the `DefId` of the associated type or opaque type.\n+        query explicit_item_bounds(key: DefId) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+            desc { |tcx| \"finding item bounds for `{}`\", tcx.def_path_str(key) }\n+        }\n+\n+        /// Elaborated the predicates from `explicit_item_bounds`.\n         query item_bounds(key: DefId) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n-            desc { |tcx| \"finding projection predicates for `{}`\", tcx.def_path_str(key) }\n+            desc { |tcx| \"elaborating item bounds for `{}`\", tcx.def_path_str(key) }\n         }\n \n         query projection_ty_from_predicates(key: (DefId, DefId)) -> Option<ty::ProjectionTy<'tcx>> {"}, {"sha": "5cd8f3e787751d0ead6abbdab4ae44ab9cbdd414", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=d297147e620431dacfd4bbe90c6f82911b7d72c5", "patch": "@@ -607,12 +607,12 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n                     // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                     // by looking up the projections associated with the def_id.\n-                    let bounds = self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+                    let bounds = self.tcx().item_bounds(def_id).subst(self.tcx(), substs);\n \n                     let mut first = true;\n                     let mut is_sized = false;\n                     p!(\"impl\");\n-                    for predicate in bounds.predicates {\n+                    for predicate in bounds {\n                         // Note: We can't use `to_opt_poly_trait_ref` here as `predicate`\n                         // may contain unbound variables. We therefore do this manually.\n                         //"}, {"sha": "1babfb8508ed8f65a774fd135ff372772f3bf4ea", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=d297147e620431dacfd4bbe90c6f82911b7d72c5", "patch": "@@ -10,7 +10,7 @@ use rustc_infer::infer::free_regions::FreeRegionRelations;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::config::nightly_options;\n use rustc_span::Span;\n@@ -428,14 +428,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         // If there are required region bounds, we can use them.\n         if opaque_defn.has_required_region_bounds {\n-            let predicates_of = tcx.predicates_of(def_id);\n-            debug!(\"constrain_opaque_type: predicates: {:#?}\", predicates_of,);\n-            let bounds = predicates_of.instantiate(tcx, opaque_defn.substs);\n+            let bounds = tcx.explicit_item_bounds(def_id);\n+            debug!(\"constrain_opaque_type: predicates: {:#?}\", bounds);\n+            let bounds: Vec<_> =\n+                bounds.iter().map(|(bound, _)| bound.subst(tcx, opaque_defn.substs)).collect();\n             debug!(\"constrain_opaque_type: bounds={:#?}\", bounds);\n             let opaque_type = tcx.mk_opaque(def_id, opaque_defn.substs);\n \n             let required_region_bounds =\n-                required_region_bounds(tcx, opaque_type, bounds.predicates.into_iter());\n+                required_region_bounds(tcx, opaque_type, bounds.into_iter());\n             debug_assert!(!required_region_bounds.is_empty());\n \n             for required_region in required_region_bounds {\n@@ -1112,9 +1113,10 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         let ty_var = infcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n \n-        let predicates_of = tcx.predicates_of(def_id);\n-        debug!(\"instantiate_opaque_types: predicates={:#?}\", predicates_of,);\n-        let bounds = predicates_of.instantiate(tcx, substs);\n+        let item_bounds = tcx.explicit_item_bounds(def_id);\n+        debug!(\"instantiate_opaque_types: bounds={:#?}\", item_bounds);\n+        let bounds: Vec<_> =\n+            item_bounds.iter().map(|(bound, _)| bound.subst(tcx, substs)).collect();\n \n         let param_env = tcx.param_env(def_id);\n         let InferOk { value: bounds, obligations } =\n@@ -1123,8 +1125,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n         debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n \n-        let required_region_bounds =\n-            required_region_bounds(tcx, ty, bounds.predicates.iter().cloned());\n+        let required_region_bounds = required_region_bounds(tcx, ty, bounds.iter().copied());\n         debug!(\"instantiate_opaque_types: required_region_bounds={:?}\", required_region_bounds);\n \n         // Make sure that we are in fact defining the *entire* type\n@@ -1153,7 +1154,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         );\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n-        for predicate in &bounds.predicates {\n+        for predicate in &bounds {\n             if let ty::PredicateAtom::Projection(projection) = predicate.skip_binders() {\n                 if projection.ty.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n@@ -1162,8 +1163,8 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             }\n         }\n \n-        self.obligations.reserve(bounds.predicates.len());\n-        for predicate in bounds.predicates {\n+        self.obligations.reserve(bounds.len());\n+        for predicate in bounds {\n             // Change the predicate to refer to the type variable,\n             // which will be the concrete type instead of the opaque type.\n             // This also instantiates nested instances of `impl Trait`."}, {"sha": "80f39051c587f9d9055c151c07cd84dca3454f19", "filename": "compiler/rustc_typeck/src/bounds.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs?ref=d297147e620431dacfd4bbe90c6f82911b7d72c5", "patch": "@@ -71,12 +71,8 @@ impl<'tcx> Bounds<'tcx> {\n                 self.region_bounds\n                     .iter()\n                     .map(|&(region_bound, span)| {\n-                        // Account for the binder being introduced below; no need to shift `param_ty`\n-                        // because, at present at least, it either only refers to early-bound regions,\n-                        // or it's a generic associated type that deliberately has escaping bound vars.\n-                        let region_bound = ty::fold::shift_region(tcx, region_bound, 1);\n                         let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n-                        (ty::Binder::bind(outlives).to_predicate(tcx), span)\n+                        (ty::Binder::dummy(outlives).to_predicate(tcx), span)\n                     })\n                     .chain(self.trait_bounds.iter().map(|&(bound_trait_ref, span, constness)| {\n                         let predicate = bound_trait_ref.with_constness(constness).to_predicate(tcx);"}, {"sha": "4df5135cca5791b2aca050d3998be84fff52f919", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 11, "deletions": 101, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=d297147e620431dacfd4bbe90c6f82911b7d72c5", "patch": "@@ -70,6 +70,7 @@ pub fn provide(providers: &mut Providers) {\n         opt_const_param_of: type_of::opt_const_param_of,\n         type_of: type_of::type_of,\n         item_bounds: item_bounds::item_bounds,\n+        explicit_item_bounds: item_bounds::explicit_item_bounds,\n         generics_of,\n         predicates_of,\n         predicates_defined_on,\n@@ -1728,7 +1729,6 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n     let mut is_trait = None;\n     let mut is_default_impl_trait = None;\n-    let mut is_trait_associated_type = None;\n \n     let icx = ItemCtxt::new(tcx, def_id);\n     let constness = icx.default_constness_for_trait_bounds();\n@@ -1741,12 +1741,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     let mut predicates: FxIndexSet<(ty::Predicate<'_>, Span)> = FxIndexSet::default();\n \n     let ast_generics = match node {\n-        Node::TraitItem(item) => {\n-            if let hir::TraitItemKind::Type(bounds, _) = item.kind {\n-                is_trait_associated_type = Some((bounds, item.span));\n-            }\n-            &item.generics\n-        }\n+        Node::TraitItem(item) => &item.generics,\n \n         Node::ImplItem(item) => &item.generics,\n \n@@ -1764,44 +1759,26 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                 | ItemKind::Struct(_, ref generics)\n                 | ItemKind::Union(_, ref generics) => generics,\n \n-                ItemKind::Trait(_, _, ref generics, .., items) => {\n-                    is_trait = Some((ty::TraitRef::identity(tcx, def_id), items));\n+                ItemKind::Trait(_, _, ref generics, ..) => {\n+                    is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n                     generics\n                 }\n                 ItemKind::TraitAlias(ref generics, _) => {\n-                    is_trait = Some((ty::TraitRef::identity(tcx, def_id), &[]));\n+                    is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n                     generics\n                 }\n                 ItemKind::OpaqueTy(OpaqueTy {\n-                    ref bounds,\n+                    bounds: _,\n                     impl_trait_fn,\n                     ref generics,\n                     origin: _,\n                 }) => {\n-                    let bounds_predicates = ty::print::with_no_queries(|| {\n-                        let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                        let opaque_ty = tcx.mk_opaque(def_id, substs);\n-\n-                        // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n-                        let bounds = AstConv::compute_bounds(\n-                            &icx,\n-                            opaque_ty,\n-                            bounds,\n-                            SizedByDefault::Yes,\n-                            tcx.def_span(def_id),\n-                        );\n-\n-                        bounds.predicates(tcx, opaque_ty)\n-                    });\n                     if impl_trait_fn.is_some() {\n-                        // opaque types\n-                        return ty::GenericPredicates {\n-                            parent: None,\n-                            predicates: tcx.arena.alloc_from_iter(bounds_predicates),\n-                        };\n+                        // return-position impl trait\n+                        // TODO: Investigate why we have this special case?\n+                        return ty::GenericPredicates { parent: None, predicates: &[] };\n                     } else {\n-                        // named opaque types\n-                        predicates.extend(bounds_predicates);\n+                        // type alias impl trait\n                         generics\n                     }\n                 }\n@@ -1827,7 +1804,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     // and the explicit where-clauses, but to get the full set of predicates\n     // on a trait we need to add in the supertrait bounds and bounds found on\n     // associated types.\n-    if let Some((_trait_ref, _)) = is_trait {\n+    if let Some(_trait_ref) = is_trait {\n         predicates.extend(tcx.super_predicates_of(def_id).predicates.iter().cloned());\n     }\n \n@@ -1994,24 +1971,6 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }\n     }\n \n-    // Add predicates from associated type bounds (`type X: Bound`)\n-    if tcx.features().generic_associated_types {\n-        // New behavior: bounds declared on associate type are predicates of that\n-        // associated type. Not the default because it needs more testing.\n-        if let Some((bounds, span)) = is_trait_associated_type {\n-            let projection_ty =\n-                tcx.mk_projection(def_id, InternalSubsts::identity_for_item(tcx, def_id));\n-\n-            predicates.extend(associated_item_bounds(tcx, def_id, bounds, projection_ty, span))\n-        }\n-    } else if let Some((self_trait_ref, trait_items)) = is_trait {\n-        // Current behavior: bounds declared on associate type are predicates\n-        // of its parent trait.\n-        predicates.extend(trait_items.iter().flat_map(|trait_item_ref| {\n-            trait_associated_item_predicates(tcx, def_id, self_trait_ref, trait_item_ref)\n-        }))\n-    }\n-\n     if tcx.features().const_evaluatable_checked {\n         predicates.extend(const_evaluatable_predicates_of(tcx, def_id.expect_local()));\n     }\n@@ -2155,55 +2114,6 @@ fn projection_ty_from_predicates(\n     projection_ty\n }\n \n-fn trait_associated_item_predicates(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    self_trait_ref: ty::TraitRef<'tcx>,\n-    trait_item_ref: &hir::TraitItemRef,\n-) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-    let trait_item = tcx.hir().trait_item(trait_item_ref.id);\n-    let item_def_id = tcx.hir().local_def_id(trait_item_ref.id.hir_id);\n-    let bounds = match trait_item.kind {\n-        hir::TraitItemKind::Type(ref bounds, _) => bounds,\n-        _ => return Vec::new(),\n-    };\n-\n-    if !tcx.generics_of(item_def_id).params.is_empty() {\n-        // For GATs the substs provided to the mk_projection call below are\n-        // wrong. We should emit a feature gate error if we get here so skip\n-        // this type.\n-        tcx.sess.delay_span_bug(trait_item.span, \"gats used without feature gate\");\n-        return Vec::new();\n-    }\n-\n-    let assoc_ty = tcx.mk_projection(\n-        tcx.hir().local_def_id(trait_item.hir_id).to_def_id(),\n-        self_trait_ref.substs,\n-    );\n-\n-    associated_item_bounds(tcx, def_id, bounds, assoc_ty, trait_item.span)\n-}\n-\n-fn associated_item_bounds(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    bounds: &'tcx [hir::GenericBound<'tcx>],\n-    projection_ty: Ty<'tcx>,\n-    span: Span,\n-) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-    let bounds = AstConv::compute_bounds(\n-        &ItemCtxt::new(tcx, def_id),\n-        projection_ty,\n-        bounds,\n-        SizedByDefault::Yes,\n-        span,\n-    );\n-\n-    let predicates = bounds.predicates(tcx, projection_ty);\n-\n-    predicates\n-}\n-\n /// Converts a specific `GenericBound` from the AST into a set of\n /// predicates that apply to the self type. A vector is returned\n /// because this can be anywhere from zero predicates (`T: ?Sized` adds no"}, {"sha": "96e331ba516de023a8fc427d2e900687916fe310", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 88, "deletions": 101, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d297147e620431dacfd4bbe90c6f82911b7d72c5/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=d297147e620431dacfd4bbe90c6f82911b7d72c5", "patch": "@@ -1,126 +1,113 @@\n-use rustc_hir::def::DefKind;\n+use super::ItemCtxt;\n+use crate::astconv::{AstConv, SizedByDefault};\n+use rustc_hir as hir;\n use rustc_infer::traits::util;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::def_id::DefId;\n+use rustc_span::Span;\n \n-/// For associated types we allow bounds written on the associated type\n-/// (`type X: Trait`) to be used as candidates. We also allow the same bounds\n-/// when desugared as bounds on the trait `where Self::X: Trait`.\n+/// For associated types we include both bounds written on the type\n+/// (`type X: Trait`) and predicates from the trait: `where Self::X: Trait`.\n ///\n /// Note that this filtering is done with the items identity substs to\n /// simplify checking that these bounds are met in impls. This means that\n /// a bound such as `for<'b> <Self as X<'b>>::U: Clone` can't be used, as in\n /// `hr-associated-type-bound-1.rs`.\n-fn associated_type_bounds(\n-    tcx: TyCtxt<'_>,\n+fn associated_type_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     assoc_item_def_id: DefId,\n-) -> &'_ ty::List<ty::Predicate<'_>> {\n-    let generic_trait_bounds = tcx.predicates_of(assoc_item_def_id);\n-    // We include predicates from the trait as well to handle\n-    // `where Self::X: Trait`.\n-    let item_bounds = generic_trait_bounds.instantiate_identity(tcx);\n-    let item_predicates = util::elaborate_predicates(tcx, item_bounds.predicates.into_iter());\n+    bounds: &'tcx [hir::GenericBound<'tcx>],\n+    span: Span,\n+) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    let item_ty = tcx.mk_projection(\n+        assoc_item_def_id,\n+        InternalSubsts::identity_for_item(tcx, assoc_item_def_id),\n+    );\n \n-    let assoc_item_ty = ty::ProjectionTy {\n-        item_def_id: assoc_item_def_id,\n-        substs: InternalSubsts::identity_for_item(tcx, assoc_item_def_id),\n-    };\n+    let bounds = AstConv::compute_bounds(\n+        &ItemCtxt::new(tcx, assoc_item_def_id),\n+        item_ty,\n+        bounds,\n+        SizedByDefault::Yes,\n+        span,\n+    );\n \n-    let predicates = item_predicates.filter_map(|obligation| {\n-        let pred = obligation.predicate;\n-        match pred.kind() {\n-            ty::PredicateKind::Trait(tr, _) => {\n-                if let ty::Projection(p) = *tr.skip_binder().self_ty().kind() {\n-                    if p == assoc_item_ty {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n+    let trait_def_id = tcx.associated_item(assoc_item_def_id).container.id();\n+    let trait_predicates = tcx.predicates_of(trait_def_id);\n+\n+    let bounds_from_parent =\n+        trait_predicates.predicates.iter().copied().filter(|(pred, _)| match pred.kind() {\n+            ty::PredicateKind::Trait(tr, _) => tr.skip_binder().self_ty() == item_ty,\n             ty::PredicateKind::Projection(proj) => {\n-                if let ty::Projection(p) = *proj.skip_binder().projection_ty.self_ty().kind() {\n-                    if p == assoc_item_ty {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            ty::PredicateKind::TypeOutlives(outlives) => {\n-                if let ty::Projection(p) = *outlives.skip_binder().0.kind() {\n-                    if p == assoc_item_ty {\n-                        return Some(pred);\n-                    }\n-                }\n+                proj.skip_binder().projection_ty.self_ty() == item_ty\n             }\n-            _ => {}\n-        }\n-        None\n-    });\n+            ty::PredicateKind::TypeOutlives(outlives) => outlives.skip_binder().0 == item_ty,\n+            _ => false,\n+        });\n \n-    let result = tcx.mk_predicates(predicates);\n-    debug!(\"associated_type_bounds({}) = {:?}\", tcx.def_path_str(assoc_item_def_id), result);\n-    result\n+    let all_bounds = tcx\n+        .arena\n+        .alloc_from_iter(bounds.predicates(tcx, item_ty).into_iter().chain(bounds_from_parent));\n+    debug!(\"associated_type_bounds({}) = {:?}\", tcx.def_path_str(assoc_item_def_id), all_bounds);\n+    all_bounds\n }\n \n-/// Opaque types don't have the same issues as associated types: the only\n-/// predicates on an opaque type (excluding those it inherits from its parent\n-/// item) should be of the form we're expecting.\n-fn opaque_type_bounds(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n-    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-\n-    let bounds = tcx.predicates_of(def_id);\n-    let predicates =\n-        util::elaborate_predicates(tcx, bounds.predicates.iter().map(|&(pred, _)| pred));\n+/// Opaque types don't inherit bounds from their parent: for return position\n+/// impl trait it isn't possible to write a suitable predicate on the\n+/// containing function and for type-alias impl trait we don't have a backwards\n+/// compatibility issue.\n+fn opaque_type_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    opaque_def_id: DefId,\n+    bounds: &'tcx [hir::GenericBound<'tcx>],\n+    span: Span,\n+) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    let item_ty =\n+        tcx.mk_opaque(opaque_def_id, InternalSubsts::identity_for_item(tcx, opaque_def_id));\n \n-    let filtered_predicates = predicates.filter_map(|obligation| {\n-        let pred = obligation.predicate;\n-        match pred.kind() {\n-            ty::PredicateKind::Trait(tr, _) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = *tr.skip_binder().self_ty().kind()\n-                {\n-                    if opaque_def_id == def_id && opaque_substs == substs {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            ty::PredicateKind::Projection(proj) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) =\n-                    *proj.skip_binder().projection_ty.self_ty().kind()\n-                {\n-                    if opaque_def_id == def_id && opaque_substs == substs {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            ty::PredicateKind::TypeOutlives(outlives) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = *outlives.skip_binder().0.kind() {\n-                    if opaque_def_id == def_id && opaque_substs == substs {\n-                        return Some(pred);\n-                    }\n-                } else {\n-                    // These can come from elaborating other predicates\n-                    return None;\n-                }\n-            }\n-            // These can come from elaborating other predicates\n-            ty::PredicateKind::RegionOutlives(_) => return None,\n-            _ => {}\n-        }\n-        tcx.sess.delay_span_bug(\n-            obligation.cause.span(tcx),\n-            &format!(\"unexpected predicate {:?} on opaque type\", pred),\n-        );\n-        None\n+    let bounds = ty::print::with_no_queries(|| {\n+        AstConv::compute_bounds(\n+            &ItemCtxt::new(tcx, opaque_def_id),\n+            item_ty,\n+            bounds,\n+            SizedByDefault::Yes,\n+            span,\n+        )\n     });\n \n-    let result = tcx.mk_predicates(filtered_predicates);\n-    debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(def_id), result);\n-    result\n+    let bounds = bounds.predicates(tcx, item_ty);\n+    debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(opaque_def_id), bounds);\n+\n+    tcx.arena.alloc_slice(&bounds)\n }\n \n-pub(super) fn item_bounds(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n-    match tcx.def_kind(def_id) {\n-        DefKind::AssocTy => associated_type_bounds(tcx, def_id),\n-        DefKind::OpaqueTy => opaque_type_bounds(tcx, def_id),\n-        k => bug!(\"item_bounds called on {}\", k.descr(def_id)),\n+pub(super) fn explicit_item_bounds(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+) -> &'_ [(ty::Predicate<'_>, Span)] {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+    match tcx.hir().get(hir_id) {\n+        hir::Node::TraitItem(hir::TraitItem {\n+            kind: hir::TraitItemKind::Type(bounds, _),\n+            span,\n+            ..\n+        }) => associated_type_bounds(tcx, def_id, bounds, *span),\n+        hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }),\n+            span,\n+            ..\n+        }) => opaque_type_bounds(tcx, def_id, bounds, *span),\n+        _ => bug!(\"item_bounds called on {:?}\", def_id),\n     }\n }\n+\n+pub(super) fn item_bounds(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n+    tcx.mk_predicates(\n+        util::elaborate_predicates(\n+            tcx,\n+            tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n+        )\n+        .map(|obligation| obligation.predicate),\n+    )\n+}"}]}