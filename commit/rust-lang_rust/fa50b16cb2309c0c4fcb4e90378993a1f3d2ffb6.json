{"sha": "fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNTBiMTZjYjIzMDljMGM0ZmNiNGU5MDM3ODk5M2ExZjNkMmZmYjY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-20T09:35:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-20T09:35:50Z"}, "message": "Merge #2322\n\n2322: Move Generics to hir_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "be32707506b562828759e3c9dc72414796a817ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be32707506b562828759e3c9dc72414796a817ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd1Qj2CRBK7hj4Ov3rIwAAdHIIAFHRpU23p26daV30y+XKFNEM\n7Ft3w+mQDWF87uAJMwGwP7FJpXcfdlWjXJY8T55E6cCKDlrpKD88ELE4B6TV+b3Z\nm0vjXoB+8ZWkUt+CW5vURhWnzfaHmH8I9JFgNTR24bPO2NHlU1p4MeXOgCrnVutY\n7yQaMkgARWRiynC+0Ib9bvqLSinTqxAL5M4TQAkY8eNXaSUbVzyZxGT4lg2bVht6\nTjKqVsc4KDfn/20Ma/SYgDztXPKJsgR4Vy6/2Wm6/F7ur6F7NxD3BrFy15Jq6PBe\nBAP+KEN08E9SMYE8aD3qjjZUeg/HcUAdrWPjbvBMyptK1+Rwc3+wcFNmzqBNbA0=\n=/Md0\n-----END PGP SIGNATURE-----\n", "payload": "tree be32707506b562828759e3c9dc72414796a817ca\nparent d24e8f9ea42dd2d08b2e02f8106690fd4baa8071\nparent e1a6e38767c1e47e5e88a97a9ef5b4547390803c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574242550 +0000\ncommitter GitHub <noreply@github.com> 1574242550 +0000\n\nMerge #2322\n\n2322: Move Generics to hir_def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6", "html_url": "https://github.com/rust-lang/rust/commit/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d24e8f9ea42dd2d08b2e02f8106690fd4baa8071", "url": "https://api.github.com/repos/rust-lang/rust/commits/d24e8f9ea42dd2d08b2e02f8106690fd4baa8071", "html_url": "https://github.com/rust-lang/rust/commit/d24e8f9ea42dd2d08b2e02f8106690fd4baa8071"}, {"sha": "e1a6e38767c1e47e5e88a97a9ef5b4547390803c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1a6e38767c1e47e5e88a97a9ef5b4547390803c", "html_url": "https://github.com/rust-lang/rust/commit/e1a6e38767c1e47e5e88a97a9ef5b4547390803c"}], "stats": {"total": 417, "additions": 247, "deletions": 170}, "files": [{"sha": "0d35014a0f9e19b1c2321960b6ff71a67369626d", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6", "patch": "@@ -43,7 +43,7 @@ pub trait DefDatabase: HirDebugDatabase + DefDatabase2 {\n     #[salsa::invoke(crate::traits::TraitItemsIndex::trait_items_index)]\n     fn trait_items_index(&self, module: Module) -> crate::traits::TraitItemsIndex;\n \n-    #[salsa::invoke(crate::generics::GenericParams::generic_params_query)]\n+    #[salsa::invoke(crate::generics::generic_params_query)]\n     fn generic_params(&self, def: GenericDef) -> Arc<GenericParams>;\n \n     #[salsa::invoke(FnData::fn_data_query)]"}, {"sha": "b7692d407330ba179e152ea0896f2057b7c7daf2", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6", "patch": "@@ -3,9 +3,9 @@\n //! It's unclear if we need this long-term, but it's definitelly useful while we\n //! are splitting the hir.\n \n-use hir_def::{AdtId, AssocItemId, DefWithBodyId, EnumVariantId, ModuleDefId};\n+use hir_def::{AdtId, AssocItemId, DefWithBodyId, EnumVariantId, GenericDefId, ModuleDefId};\n \n-use crate::{Adt, AssocItem, DefWithBody, EnumVariant, ModuleDef};\n+use crate::{Adt, AssocItem, DefWithBody, EnumVariant, GenericDef, ModuleDef};\n \n macro_rules! from_id {\n     ($(($id:path, $ty:path)),*) => {$(\n@@ -41,6 +41,16 @@ impl From<AdtId> for Adt {\n     }\n }\n \n+impl From<Adt> for AdtId {\n+    fn from(id: Adt) -> Self {\n+        match id {\n+            Adt::Struct(it) => AdtId::StructId(it.id),\n+            Adt::Union(it) => AdtId::UnionId(it.id),\n+            Adt::Enum(it) => AdtId::EnumId(it.id),\n+        }\n+    }\n+}\n+\n impl From<EnumVariantId> for EnumVariant {\n     fn from(id: EnumVariantId) -> Self {\n         EnumVariant { parent: id.parent.into(), id: id.local_id }\n@@ -82,3 +92,33 @@ impl From<AssocItemId> for AssocItem {\n         }\n     }\n }\n+\n+impl From<GenericDef> for GenericDefId {\n+    fn from(def: GenericDef) -> Self {\n+        match def {\n+            GenericDef::Function(it) => GenericDefId::FunctionId(it.id),\n+            GenericDef::Adt(it) => GenericDefId::AdtId(it.into()),\n+            GenericDef::Trait(it) => GenericDefId::TraitId(it.id),\n+            GenericDef::TypeAlias(it) => GenericDefId::TypeAliasId(it.id),\n+            GenericDef::ImplBlock(it) => GenericDefId::ImplId(it.id),\n+            GenericDef::EnumVariant(it) => {\n+                GenericDefId::EnumVariantId(EnumVariantId { parent: it.parent.id, local_id: it.id })\n+            }\n+            GenericDef::Const(it) => GenericDefId::ConstId(it.id),\n+        }\n+    }\n+}\n+\n+impl From<GenericDefId> for GenericDef {\n+    fn from(def: GenericDefId) -> Self {\n+        match def {\n+            GenericDefId::FunctionId(it) => GenericDef::Function(it.into()),\n+            GenericDefId::AdtId(it) => GenericDef::Adt(it.into()),\n+            GenericDefId::TraitId(it) => GenericDef::Trait(it.into()),\n+            GenericDefId::TypeAliasId(it) => GenericDef::TypeAlias(it.into()),\n+            GenericDefId::ImplId(it) => GenericDef::ImplBlock(it.into()),\n+            GenericDefId::EnumVariantId(it) => GenericDef::EnumVariant(it.into()),\n+            GenericDefId::ConstId(it) => GenericDef::Const(it.into()),\n+        }\n+    }\n+}"}, {"sha": "caedb90e6ab85f67a41f85fcec8d41355216b970", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 16, "deletions": 166, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6", "patch": "@@ -1,47 +1,12 @@\n-//! Many kinds of items or constructs can have generic parameters: functions,\n-//! structs, impls, traits, etc. This module provides a common HIR for these\n-//! generic parameters. See also the `Generics` type and the `generics_of` query\n-//! in rustc.\n-\n+//! Temp module to wrap hir_def::generics\n use std::sync::Arc;\n \n-use hir_def::type_ref::{TypeBound, TypeRef};\n-use hir_expand::name::{self, AsName};\n-use ra_syntax::ast::{self, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n-\n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n-    Adt, Const, Container, Enum, EnumVariant, Function, HasSource, ImplBlock, Name, Struct, Trait,\n-    TypeAlias, Union,\n+    Adt, Const, Container, Enum, EnumVariant, Function, ImplBlock, Struct, Trait, TypeAlias, Union,\n };\n \n-/// Data about a generic parameter (to a function, struct, impl, ...).\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct GenericParam {\n-    // FIXME: give generic params proper IDs\n-    pub idx: u32,\n-    pub name: Name,\n-    pub default: Option<TypeRef>,\n-}\n-\n-/// Data about the generic parameters of a function, struct, impl, etc.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct GenericParams {\n-    pub(crate) def: GenericDef,\n-    pub(crate) parent_params: Option<Arc<GenericParams>>,\n-    pub(crate) params: Vec<GenericParam>,\n-    pub(crate) where_predicates: Vec<WherePredicate>,\n-}\n-\n-/// A single predicate from a where clause, i.e. `where Type: Trait`. Combined\n-/// where clauses like `where T: Foo + Bar` are turned into multiple of these.\n-/// It might still result in multiple actual predicates though, because of\n-/// associated type bindings like `Iterator<Item = u32>`.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct WherePredicate {\n-    pub(crate) type_ref: TypeRef,\n-    pub(crate) bound: TypeBound,\n-}\n+pub use hir_def::generics::{GenericParam, GenericParams, WherePredicate};\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n pub enum GenericDef {\n@@ -66,134 +31,19 @@ impl_froms!(\n     Const\n );\n \n-impl GenericParams {\n-    pub(crate) fn generic_params_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        def: GenericDef,\n-    ) -> Arc<GenericParams> {\n-        let parent = match def {\n-            GenericDef::Function(it) => it.container(db).map(GenericDef::from),\n-            GenericDef::TypeAlias(it) => it.container(db).map(GenericDef::from),\n-            GenericDef::Const(it) => it.container(db).map(GenericDef::from),\n-            GenericDef::EnumVariant(it) => Some(it.parent_enum(db).into()),\n-            GenericDef::Adt(_) | GenericDef::Trait(_) => None,\n-            GenericDef::ImplBlock(_) => None,\n-        };\n-        let mut generics = GenericParams {\n-            def,\n-            params: Vec::new(),\n-            parent_params: parent.map(|p| db.generic_params(p)),\n-            where_predicates: Vec::new(),\n-        };\n-        let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n-        // FIXME: add `: Sized` bound for everything except for `Self` in traits\n-        match def {\n-            GenericDef::Function(it) => generics.fill(&it.source(db).value, start),\n-            GenericDef::Adt(Adt::Struct(it)) => generics.fill(&it.source(db).value, start),\n-            GenericDef::Adt(Adt::Union(it)) => generics.fill(&it.source(db).value, start),\n-            GenericDef::Adt(Adt::Enum(it)) => generics.fill(&it.source(db).value, start),\n-            GenericDef::Trait(it) => {\n-                // traits get the Self type as an implicit first type parameter\n-                generics.params.push(GenericParam {\n-                    idx: start,\n-                    name: name::SELF_TYPE,\n-                    default: None,\n-                });\n-                generics.fill(&it.source(db).value, start + 1);\n-                // add super traits as bounds on Self\n-                // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n-                let self_param = TypeRef::Path(name::SELF_TYPE.into());\n-                generics.fill_bounds(&it.source(db).value, self_param);\n-            }\n-            GenericDef::TypeAlias(it) => generics.fill(&it.source(db).value, start),\n-            // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n-            // type-parameter, but rather is a type-alias for impl's target\n-            // type, so this is handled by the resolver.\n-            GenericDef::ImplBlock(it) => generics.fill(&it.source(db).value, start),\n-            GenericDef::EnumVariant(_) | GenericDef::Const(_) => {}\n-        }\n-\n-        Arc::new(generics)\n-    }\n-\n-    fn fill(&mut self, node: &impl TypeParamsOwner, start: u32) {\n-        if let Some(params) = node.type_param_list() {\n-            self.fill_params(params, start)\n-        }\n-        if let Some(where_clause) = node.where_clause() {\n-            self.fill_where_predicates(where_clause);\n-        }\n-    }\n-\n-    fn fill_bounds(&mut self, node: &impl ast::TypeBoundsOwner, type_ref: TypeRef) {\n-        for bound in\n-            node.type_bound_list().iter().flat_map(|type_bound_list| type_bound_list.bounds())\n-        {\n-            self.add_where_predicate_from_bound(bound, type_ref.clone());\n-        }\n-    }\n-\n-    fn fill_params(&mut self, params: ast::TypeParamList, start: u32) {\n-        for (idx, type_param) in params.type_params().enumerate() {\n-            let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n-            // FIXME: Use `Path::from_src`\n-            let default = type_param.default_type().map(TypeRef::from_ast);\n-\n-            let param = GenericParam { idx: idx as u32 + start, name: name.clone(), default };\n-            self.params.push(param);\n-\n-            let type_ref = TypeRef::Path(name.into());\n-            self.fill_bounds(&type_param, type_ref);\n-        }\n-    }\n-\n-    fn fill_where_predicates(&mut self, where_clause: ast::WhereClause) {\n-        for pred in where_clause.predicates() {\n-            let type_ref = match pred.type_ref() {\n-                Some(type_ref) => type_ref,\n-                None => continue,\n-            };\n-            let type_ref = TypeRef::from_ast(type_ref);\n-            for bound in pred.type_bound_list().iter().flat_map(|l| l.bounds()) {\n-                self.add_where_predicate_from_bound(bound, type_ref.clone());\n-            }\n-        }\n-    }\n-\n-    fn add_where_predicate_from_bound(&mut self, bound: ast::TypeBound, type_ref: TypeRef) {\n-        if bound.has_question_mark() {\n-            // FIXME: remove this bound\n-            return;\n-        }\n-        let bound = TypeBound::from_ast(bound);\n-        self.where_predicates.push(WherePredicate { type_ref, bound });\n-    }\n-\n-    pub(crate) fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n-        self.params.iter().find(|p| &p.name == name)\n-    }\n-\n-    pub fn count_parent_params(&self) -> usize {\n-        self.parent_params.as_ref().map(|p| p.count_params_including_parent()).unwrap_or(0)\n-    }\n-\n-    pub fn count_params_including_parent(&self) -> usize {\n-        let parent_count = self.count_parent_params();\n-        parent_count + self.params.len()\n-    }\n-\n-    fn for_each_param<'a>(&'a self, f: &mut impl FnMut(&'a GenericParam)) {\n-        if let Some(parent) = &self.parent_params {\n-            parent.for_each_param(f);\n-        }\n-        self.params.iter().for_each(f);\n-    }\n-\n-    pub fn params_including_parent(&self) -> Vec<&GenericParam> {\n-        let mut vec = Vec::with_capacity(self.count_params_including_parent());\n-        self.for_each_param(&mut |p| vec.push(p));\n-        vec\n-    }\n+pub(crate) fn generic_params_query(\n+    db: &(impl DefDatabase + AstDatabase),\n+    def: GenericDef,\n+) -> Arc<GenericParams> {\n+    let parent = match def {\n+        GenericDef::Function(it) => it.container(db).map(GenericDef::from),\n+        GenericDef::TypeAlias(it) => it.container(db).map(GenericDef::from),\n+        GenericDef::Const(it) => it.container(db).map(GenericDef::from),\n+        GenericDef::EnumVariant(it) => Some(it.parent_enum(db).into()),\n+        GenericDef::Adt(_) | GenericDef::Trait(_) => None,\n+        GenericDef::ImplBlock(_) => None,\n+    };\n+    Arc::new(GenericParams::new(db, def.into(), parent.map(|it| db.generic_params(it))))\n }\n \n impl GenericDef {"}, {"sha": "a2fa0bb79e142b740930e3792664e0845a121761", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6", "patch": "@@ -369,7 +369,7 @@ impl Resolver {\n \n     pub(crate) fn generic_def(&self) -> Option<crate::generics::GenericDef> {\n         self.scopes.iter().find_map(|scope| match scope {\n-            Scope::GenericParams(params) => Some(params.def),\n+            Scope::GenericParams(params) => Some(params.def.into()),\n             _ => None,\n         })\n     }"}, {"sha": "4adfc16bbb25f54eaace0453e1300fa11f070a0e", "filename": "crates/ra_hir_def/src/generics.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6", "patch": "@@ -0,0 +1,163 @@\n+//! Many kinds of items or constructs can have generic parameters: functions,\n+//! structs, impls, traits, etc. This module provides a common HIR for these\n+//! generic parameters. See also the `Generics` type and the `generics_of` query\n+//! in rustc.\n+use std::sync::Arc;\n+\n+use hir_expand::name::{self, AsName, Name};\n+\n+use ra_syntax::ast::{self, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n+\n+use crate::{\n+    db::DefDatabase2,\n+    type_ref::{TypeBound, TypeRef},\n+    AdtId, AstItemDef, GenericDefId,\n+};\n+\n+/// Data about a generic parameter (to a function, struct, impl, ...).\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct GenericParam {\n+    // FIXME: give generic params proper IDs\n+    pub idx: u32,\n+    pub name: Name,\n+    pub default: Option<TypeRef>,\n+}\n+\n+/// Data about the generic parameters of a function, struct, impl, etc.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct GenericParams {\n+    pub def: GenericDefId,\n+    pub parent_params: Option<Arc<GenericParams>>,\n+    pub params: Vec<GenericParam>,\n+    pub where_predicates: Vec<WherePredicate>,\n+}\n+\n+/// A single predicate from a where clause, i.e. `where Type: Trait`. Combined\n+/// where clauses like `where T: Foo + Bar` are turned into multiple of these.\n+/// It might still result in multiple actual predicates though, because of\n+/// associated type bindings like `Iterator<Item = u32>`.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct WherePredicate {\n+    pub type_ref: TypeRef,\n+    pub bound: TypeBound,\n+}\n+\n+impl GenericParams {\n+    pub fn new(\n+        db: &impl DefDatabase2,\n+        def: GenericDefId,\n+        parent_params: Option<Arc<GenericParams>>,\n+    ) -> GenericParams {\n+        let mut generics =\n+            GenericParams { def, params: Vec::new(), parent_params, where_predicates: Vec::new() };\n+        let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n+        // FIXME: add `: Sized` bound for everything except for `Self` in traits\n+        match def {\n+            GenericDefId::FunctionId(it) => generics.fill(&it.source(db).value, start),\n+            GenericDefId::AdtId(AdtId::StructId(it)) => {\n+                generics.fill(&it.0.source(db).value, start)\n+            }\n+            GenericDefId::AdtId(AdtId::UnionId(it)) => generics.fill(&it.0.source(db).value, start),\n+            GenericDefId::AdtId(AdtId::EnumId(it)) => generics.fill(&it.source(db).value, start),\n+            GenericDefId::TraitId(it) => {\n+                // traits get the Self type as an implicit first type parameter\n+                generics.params.push(GenericParam {\n+                    idx: start,\n+                    name: name::SELF_TYPE,\n+                    default: None,\n+                });\n+                generics.fill(&it.source(db).value, start + 1);\n+                // add super traits as bounds on Self\n+                // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n+                let self_param = TypeRef::Path(name::SELF_TYPE.into());\n+                generics.fill_bounds(&it.source(db).value, self_param);\n+            }\n+            GenericDefId::TypeAliasId(it) => generics.fill(&it.source(db).value, start),\n+            // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n+            // type-parameter, but rather is a type-alias for impl's target\n+            // type, so this is handled by the resolver.\n+            GenericDefId::ImplId(it) => generics.fill(&it.source(db).value, start),\n+            GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => {}\n+        }\n+\n+        generics\n+    }\n+\n+    fn fill(&mut self, node: &impl TypeParamsOwner, start: u32) {\n+        if let Some(params) = node.type_param_list() {\n+            self.fill_params(params, start)\n+        }\n+        if let Some(where_clause) = node.where_clause() {\n+            self.fill_where_predicates(where_clause);\n+        }\n+    }\n+\n+    fn fill_bounds(&mut self, node: &impl ast::TypeBoundsOwner, type_ref: TypeRef) {\n+        for bound in\n+            node.type_bound_list().iter().flat_map(|type_bound_list| type_bound_list.bounds())\n+        {\n+            self.add_where_predicate_from_bound(bound, type_ref.clone());\n+        }\n+    }\n+\n+    fn fill_params(&mut self, params: ast::TypeParamList, start: u32) {\n+        for (idx, type_param) in params.type_params().enumerate() {\n+            let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n+            // FIXME: Use `Path::from_src`\n+            let default = type_param.default_type().map(TypeRef::from_ast);\n+            let param = GenericParam { idx: idx as u32 + start, name: name.clone(), default };\n+            self.params.push(param);\n+\n+            let type_ref = TypeRef::Path(name.into());\n+            self.fill_bounds(&type_param, type_ref);\n+        }\n+    }\n+\n+    fn fill_where_predicates(&mut self, where_clause: ast::WhereClause) {\n+        for pred in where_clause.predicates() {\n+            let type_ref = match pred.type_ref() {\n+                Some(type_ref) => type_ref,\n+                None => continue,\n+            };\n+            let type_ref = TypeRef::from_ast(type_ref);\n+            for bound in pred.type_bound_list().iter().flat_map(|l| l.bounds()) {\n+                self.add_where_predicate_from_bound(bound, type_ref.clone());\n+            }\n+        }\n+    }\n+\n+    fn add_where_predicate_from_bound(&mut self, bound: ast::TypeBound, type_ref: TypeRef) {\n+        if bound.has_question_mark() {\n+            // FIXME: remove this bound\n+            return;\n+        }\n+        let bound = TypeBound::from_ast(bound);\n+        self.where_predicates.push(WherePredicate { type_ref, bound });\n+    }\n+\n+    pub fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n+        self.params.iter().find(|p| &p.name == name)\n+    }\n+\n+    pub fn count_parent_params(&self) -> usize {\n+        self.parent_params.as_ref().map(|p| p.count_params_including_parent()).unwrap_or(0)\n+    }\n+\n+    pub fn count_params_including_parent(&self) -> usize {\n+        let parent_count = self.count_parent_params();\n+        parent_count + self.params.len()\n+    }\n+\n+    fn for_each_param<'a>(&'a self, f: &mut impl FnMut(&'a GenericParam)) {\n+        if let Some(parent) = &self.parent_params {\n+            parent.for_each_param(f);\n+        }\n+        self.params.iter().for_each(f);\n+    }\n+\n+    pub fn params_including_parent(&self) -> Vec<&GenericParam> {\n+        let mut vec = Vec::with_capacity(self.count_params_including_parent());\n+        self.for_each_param(&mut |p| vec.push(p));\n+        vec\n+    }\n+}"}, {"sha": "dffc82ff8c8571075bb8d2e0905b70003b384bf3", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=fa50b16cb2309c0c4fcb4e90378993a1f3d2ffb6", "patch": "@@ -17,6 +17,7 @@ pub mod imp;\n pub mod diagnostics;\n pub mod expr;\n pub mod body;\n+pub mod generics;\n \n #[cfg(test)]\n mod test_db;\n@@ -408,3 +409,26 @@ pub enum AssocItemId {\n // require not implementing From, and instead having some checked way of\n // casting them, and somehow making the constructors private, which would be annoying.\n impl_froms!(AssocItemId: FunctionId, ConstId, TypeAliasId);\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n+pub enum GenericDefId {\n+    FunctionId(FunctionId),\n+    AdtId(AdtId),\n+    TraitId(TraitId),\n+    TypeAliasId(TypeAliasId),\n+    ImplId(ImplId),\n+    // enum variants cannot have generics themselves, but their parent enums\n+    // can, and this makes some code easier to write\n+    EnumVariantId(EnumVariantId),\n+    // consts can have type parameters from their parents (i.e. associated consts of traits)\n+    ConstId(ConstId),\n+}\n+impl_froms!(\n+    GenericDefId: FunctionId,\n+    AdtId(StructId, EnumId, UnionId),\n+    TraitId,\n+    TypeAliasId,\n+    ImplId,\n+    EnumVariantId,\n+    ConstId\n+);"}]}