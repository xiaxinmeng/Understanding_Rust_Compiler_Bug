{"sha": "38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZWZhMTdiYjhiOWMxMDc3ZTdiOGNkOWQ2N2RhMDhkZWMzZjBiZGE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-22T03:20:48Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-26T16:25:27Z"}, "message": "test: Remove all remaining non-procedure uses of `do`.", "tree": {"sha": "02ee1d054e2e991f9885ecfbf0c8dd6a9700df78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02ee1d054e2e991f9885ecfbf0c8dd6a9700df78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "html_url": "https://github.com/rust-lang/rust/commit/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f571e46ddb696d15a8cc912309714ca74f23dcc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f571e46ddb696d15a8cc912309714ca74f23dcc4", "html_url": "https://github.com/rust-lang/rust/commit/f571e46ddb696d15a8cc912309714ca74f23dcc4"}], "stats": {"total": 779, "additions": 386, "deletions": 393}, "files": [{"sha": "4fca2b33696eb0dea770a09a2da36db9c93c3d9c", "filename": "doc/rust.md", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -2703,33 +2703,27 @@ A `loop` expression is only permitted in the body of a loop.\n do_expr : \"do\" expr [ '|' ident_list '|' ] ? '{' block '}' ;\n ~~~~\n \n-A _do expression_ provides a more-familiar block-syntax for a [lambda expression](#lambda-expressions),\n-including a special translation of [return expressions](#return-expressions) inside the supplied block.\n-\n-Any occurrence of a [return expression](#return-expressions)\n-inside this `block` expression is rewritten\n-as a reference to an (anonymous) flag set in the caller's environment,\n-which is checked on return from the `expr` and, if set,\n-causes a corresponding return from the caller.\n-In this way, the meaning of `return` statements in language built-in control blocks is preserved,\n-if they are rewritten using lambda functions and `do` expressions as abstractions.\n-\n-The optional `ident_list` and `block` provided in a `do` expression are parsed as though they constitute a lambda expression;\n+A _do expression_ provides a more-familiar block syntax\n+for invoking a function and passing it a newly-created a procedure.\n+\n+The optional `ident_list` and `block` provided in a `do` expression are parsed\n+as though they constitute a procedure expression;\n if the `ident_list` is missing, an empty `ident_list` is implied.\n \n-The lambda expression is then provided as a _trailing argument_\n-to the outermost [call](#call-expressions) or [method call](#method-call-expressions) expression\n+The procedure expression is then provided as a _trailing argument_\n+to the outermost [call](#call-expressions) or\n+[method call](#method-call-expressions) expression\n in the `expr` following `do`.\n If the `expr` is a [path expression](#path-expressions), it is parsed as though it is a call expression.\n If the `expr` is a [field expression](#field-expressions), it is parsed as though it is a method call expression.\n \n In this example, both calls to `f` are equivalent:\n \n ~~~~\n-# fn f(f: |int|) { }\n+# fn f(f: proc(int)) { }\n # fn g(i: int) { }\n \n-f(|j| g(j));\n+f(proc(j) { g(j) });\n \n do f |j| {\n     g(j);\n@@ -2739,10 +2733,10 @@ do f |j| {\n In this example, both calls to the (binary) function `k` are equivalent:\n \n ~~~~\n-# fn k(x:int, f: |int|) { }\n+# fn k(x:int, f: proc(int)) { }\n # fn l(i: int) { }\n \n-k(3, |j| l(j));\n+k(3, proc(j) { l(j) });\n \n do k(3) |j| {\n    l(j);"}, {"sha": "2fb35fce9c46a4363008546a29d8c3d71ca4e2ce", "filename": "doc/tutorial-conditions.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/doc%2Ftutorial-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/doc%2Ftutorial-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-conditions.md?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -457,15 +457,15 @@ condition! {\n \n fn main() {\n     // Trap the condition:\n-    do malformed_line::cond.trap(|_| (-1,-1)).inside {\n+    malformed_line::cond.trap(|_| (-1,-1)).inside(|| {\n \n         // The protected logic.\n         let pairs = read_int_pairs();\n         for &(a,b) in pairs.iter() {\n                 println!(\"{:4.4d}, {:4.4d}\", a, b);\n         }\n \n-    }\n+    })\n }\n \n fn read_int_pairs() -> ~[(int,int)] {\n@@ -535,15 +535,15 @@ condition! {\n \n fn main() {\n     // Trap the condition and return `None`\n-    do malformed_line::cond.trap(|_| None).inside {\n+    malformed_line::cond.trap(|_| None).inside(|| {\n \n         // The protected logic.\n         let pairs = read_int_pairs();\n         for &(a,b) in pairs.iter() {\n             println!(\"{:4.4d}, {:4.4d}\", a, b);\n         }\n \n-    }\n+    })\n }\n \n fn read_int_pairs() -> ~[(int,int)] {\n@@ -631,15 +631,15 @@ condition! {\n \n fn main() {\n     // Trap the condition and return `UsePreviousLine`\n-    do malformed_line::cond.trap(|_| UsePreviousLine).inside {\n+    malformed_line::cond.trap(|_| UsePreviousLine).inside(|| {\n \n         // The protected logic.\n         let pairs = read_int_pairs();\n         for &(a,b) in pairs.iter() {\n             println!(\"{:4.4d}, {:4.4d}\", a, b);\n         }\n \n-    }\n+    })\n }\n \n fn read_int_pairs() -> ~[(int,int)] {\n@@ -758,19 +758,19 @@ condition! {\n \n fn main() {\n     // Trap the `malformed_int` condition and return -1\n-    do malformed_int::cond.trap(|_| -1).inside {\n+    malformed_int::cond.trap(|_| -1).inside(|| {\n \n         // Trap the `malformed_line` condition and return `UsePreviousLine`\n-        do malformed_line::cond.trap(|_| UsePreviousLine).inside {\n+        malformed_line::cond.trap(|_| UsePreviousLine).inside(|| {\n \n             // The protected logic.\n             let pairs = read_int_pairs();\n             for &(a,b) in pairs.iter() {\n                 println!(\"{:4.4d}, {:4.4d}\", a, b);\n             }\n \n-        }\n-    }\n+        })\n+    })\n }\n \n // Parse an int; if parsing fails, call the condition handler and"}, {"sha": "3017bc8b7ea01ce139ebcb5996415ef00c57dd8f", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -253,13 +253,13 @@ might look like the example below.\n # use std::vec;\n \n // Create a vector of ports, one for each child task\n-let ports = do vec::from_fn(3) |init_val| {\n+let ports = vec::from_fn(3, |init_val| {\n     let (port, chan) = stream();\n     do spawn {\n         chan.send(some_expensive_computation(init_val));\n     }\n     port\n-};\n+});\n \n // Wait on each port, accumulating the results\n let result = ports.iter().fold(0, |accum, port| accum + port.recv() );"}, {"sha": "1559033a582aaba3127a70c2e1707624c4d19fc2", "filename": "doc/tutorial.md", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -1439,19 +1439,14 @@ call_twice(function);\n \n ## Do syntax\n \n-The `do` expression provides a way to treat higher-order functions\n-(functions that take closures as arguments) as control structures.\n+The `do` expression makes it easier to call functions that take procedures\n+as arguments.\n \n-Consider this function that iterates over a vector of\n-integers, passing in a pointer to each integer in the vector:\n+Consider this function that takes a procedure:\n \n ~~~~\n-fn each(v: &[int], op: |v: &int|) {\n-   let mut n = 0;\n-   while n < v.len() {\n-       op(&v[n]);\n-       n += 1;\n-   }\n+fn call_it(op: proc(v: int)) {\n+    op(10)\n }\n ~~~~\n \n@@ -1460,26 +1455,24 @@ argument, we can write it in a way that has a pleasant, block-like\n structure.\n \n ~~~~\n-# fn each(v: &[int], op: |v: &int|) { }\n-# fn do_some_work(i: &int) { }\n-each([1, 2, 3], |n| {\n-    do_some_work(n);\n+# fn call_it(op: proc(v: int)) { }\n+call_it(proc(n) {\n+    println(n.to_str());\n });\n ~~~~\n \n This is such a useful pattern that Rust has a special form of function\n-call that can be written more like a built-in control structure:\n+call for these functions.\n \n ~~~~\n-# fn each(v: &[int], op: |v: &int|) { }\n-# fn do_some_work(i: &int) { }\n-do each([1, 2, 3]) |n| {\n-    do_some_work(n);\n+# fn call_it(op: proc(v: int)) { }\n+do call_it() |n| {\n+    println(n.to_str());\n }\n ~~~~\n \n The call is prefixed with the keyword `do` and, instead of writing the\n-final closure inside the argument list, it appears outside of the\n+final procedure inside the argument list, it appears outside of the\n parentheses, where it looks more like a typical block of\n code.\n "}, {"sha": "8aa89f86642a5fbe92489c44d0933300945d97ff", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -297,14 +297,14 @@ fn test_arena_destructors_fail() {\n     for i in range(0u, 10) {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n-        do arena.alloc { @i };\n+        arena.alloc(|| { @i });\n         // Allocate something with funny size and alignment, to keep\n         // things interesting.\n-        do arena.alloc { [0u8, 1u8, 2u8] };\n+        arena.alloc(|| { [0u8, 1u8, 2u8] });\n     }\n     // Now, fail while allocating\n-    do arena.alloc::<@int> {\n+    arena.alloc::<@int>(|| {\n         // Now fail.\n         fail!();\n-    };\n+    });\n }"}, {"sha": "94e3917a7ecdf76055011e7e3008a84ac33e83de", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -317,20 +317,20 @@ mod test {\n         use std::rand::{task_rng, random, Rng};\n         use std::vec;\n \n-        do 1000.times {\n+        1000.times(|| {\n             let times = task_rng().gen_range(1u, 100);\n             let v = vec::from_fn(times, |_| random::<u8>());\n             assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n-        }\n+        })\n     }\n \n     #[bench]\n     pub fn bench_to_base64(bh: & mut BenchHarness) {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        do bh.iter {\n+        bh.iter(|| {\n             s.as_bytes().to_base64(STANDARD);\n-        }\n+        });\n         bh.bytes = s.len() as u64;\n     }\n \n@@ -339,9 +339,9 @@ mod test {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let b = s.as_bytes().to_base64(STANDARD);\n-        do bh.iter {\n+        bh.iter(|| {\n             b.from_base64();\n-        }\n+        });\n         bh.bytes = b.len() as u64;\n     }\n "}, {"sha": "09137d6bb74519fbd92fe786c40da7d1868f9d69", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -1362,18 +1362,18 @@ mod tests {\n     fn test_small_clear() {\n         let mut b = Bitv::new(14, true);\n         b.clear();\n-        do b.ones |i| {\n+        b.ones(|i| {\n             fail!(\"found 1 at {:?}\", i)\n-        };\n+        });\n     }\n \n     #[test]\n     fn test_big_clear() {\n         let mut b = Bitv::new(140, true);\n         b.clear();\n-        do b.ones |i| {\n+        b.ones(|i| {\n             fail!(\"found 1 at {:?}\", i)\n-        };\n+        });\n     }\n \n     #[test]\n@@ -1408,11 +1408,11 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n-        do a.intersection(&b) |x| {\n+        a.intersection(&b, |x| {\n             assert_eq!(*x, expected[i]);\n             i += 1;\n             true\n-        };\n+        });\n         assert_eq!(i, expected.len());\n     }\n \n@@ -1432,11 +1432,11 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 5, 500];\n-        do a.difference(&b) |x| {\n+        a.difference(&b, |x| {\n             assert_eq!(*x, expected[i]);\n             i += 1;\n             true\n-        };\n+        });\n         assert_eq!(i, expected.len());\n     }\n \n@@ -1458,11 +1458,11 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 5, 11, 14, 220];\n-        do a.symmetric_difference(&b) |x| {\n+        a.symmetric_difference(&b, |x| {\n             assert_eq!(*x, expected[i]);\n             i += 1;\n             true\n-        };\n+        });\n         assert_eq!(i, expected.len());\n     }\n \n@@ -1487,11 +1487,11 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n-        do a.union(&b) |x| {\n+        a.union(&b, |x| {\n             assert_eq!(*x, expected[i]);\n             i += 1;\n             true\n-        };\n+        });\n         assert_eq!(i, expected.len());\n     }\n \n@@ -1538,27 +1538,27 @@ mod tests {\n     fn bench_uint_small(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = 0 as uint;\n-        do b.iter {\n+        b.iter(|| {\n             bitv |= (1 << ((r.next_u32() as uint) % uint::bits));\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_small_bitv_small(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = SmallBitv::new(uint::bits);\n-        do b.iter {\n+        b.iter(|| {\n             bitv.set((r.next_u32() as uint) % uint::bits, true);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_big_bitv_small(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = BigBitv::new(~[0]);\n-        do b.iter {\n+        b.iter(|| {\n             bitv.set((r.next_u32() as uint) % uint::bits, true);\n-        }\n+        })\n     }\n \n     #[bench]\n@@ -1567,87 +1567,87 @@ mod tests {\n         let mut storage = ~[];\n         storage.grow(BENCH_BITS / uint::bits, &0u);\n         let mut bitv = BigBitv::new(storage);\n-        do b.iter {\n+        b.iter(|| {\n             bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitv_big(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = Bitv::new(BENCH_BITS, false);\n-        do b.iter {\n+        b.iter(|| {\n             bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitv_small(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = Bitv::new(uint::bits, false);\n-        do b.iter {\n+        b.iter(|| {\n             bitv.set((r.next_u32() as uint) % uint::bits, true);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitv_set_small(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n-        do b.iter {\n+        b.iter(|| {\n             bitv.insert((r.next_u32() as uint) % uint::bits);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitv_set_big(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n-        do b.iter {\n+        b.iter(|| {\n             bitv.insert((r.next_u32() as uint) % BENCH_BITS);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitv_big_union(b: &mut BenchHarness) {\n         let mut b1 = Bitv::new(BENCH_BITS, false);\n         let b2 = Bitv::new(BENCH_BITS, false);\n-        do b.iter {\n+        b.iter(|| {\n             b1.union(&b2);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_btv_small_iter(b: &mut BenchHarness) {\n         let bitv = Bitv::new(uint::bits, false);\n-        do b.iter {\n+        b.iter(|| {\n             let mut _sum = 0;\n             for pres in bitv.iter() {\n                 _sum += pres as uint;\n             }\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitv_big_iter(b: &mut BenchHarness) {\n         let bitv = Bitv::new(BENCH_BITS, false);\n-        do b.iter {\n+        b.iter(|| {\n             let mut _sum = 0;\n             for pres in bitv.iter() {\n                 _sum += pres as uint;\n             }\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitvset_iter(b: &mut BenchHarness) {\n         let bitv = BitvSet::from_bitv(from_fn(BENCH_BITS,\n                                               |idx| {idx % 3 == 0}));\n-        do b.iter {\n+        b.iter(|| {\n             let mut _sum = 0;\n             for idx in bitv.iter() {\n                 _sum += idx;\n             }\n-        }\n+        })\n     }\n }"}, {"sha": "42287736ffa5f2a46ad172dd96fa34c62967a6f3", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -167,9 +167,9 @@ mod test {\n         do run_in_uv_task {\n             let (port, chan) = rendezvous();\n             do spawn {\n-                do 1000000.times { chan.send(()) }\n+                1000000.times(|| { chan.send(()) })\n             }\n-            do 1000000.times { port.recv() }\n+            1000000.times(|| { port.recv() })\n         }\n     }\n "}, {"sha": "0ba00510ed8b575ef431fd8e2c7f6818e14ea4e7", "filename": "src/libextra/container.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcontainer.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -58,11 +58,11 @@ pub mod bench {\n         }\n \n         // measure\n-        do bh.iter {\n+        bh.iter(|| {\n             let k = rng.gen::<uint>() % n;\n             map.insert(k, 1);\n             map.remove(&k);\n-        }\n+        })\n     }\n \n     pub fn insert_seq_n<M:MutableMap<uint,uint>>(n: uint,\n@@ -76,11 +76,11 @@ pub mod bench {\n \n         // measure\n         let mut i = 1;\n-        do bh.iter {\n+        bh.iter(|| {\n             map.insert(i, 1);\n             map.remove(&i);\n             i = (i + 2) % n;\n-        }\n+        })\n     }\n \n     pub fn find_rand_n<M:MutableMap<uint,uint>>(n: uint,\n@@ -98,10 +98,10 @@ pub mod bench {\n \n         // measure\n         let mut i = 0;\n-        do bh.iter {\n+        bh.iter(|| {\n             map.find(&(keys[i]));\n             i = (i + 1) % n;\n-        }\n+        })\n     }\n \n     pub fn find_seq_n<M:MutableMap<uint,uint>>(n: uint,\n@@ -114,9 +114,9 @@ pub mod bench {\n \n         // measure\n         let mut i = 0;\n-        do bh.iter {\n+        bh.iter(|| {\n             map.find(&i);\n             i = (i + 1) % n;\n-        }\n+        })\n      }\n }"}, {"sha": "22109c98dc863518144aaed1d99a0d9e79f9d5df", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -1031,11 +1031,11 @@ mod tests {\n \n     #[test]\n     fn test_fuzz() {\n-        do 25.times {\n+        25.times(|| {\n             fuzz_test(3);\n             fuzz_test(16);\n             fuzz_test(189);\n-        }\n+        })\n     }\n \n     #[cfg(test)]\n@@ -1078,95 +1078,95 @@ mod tests {\n     #[bench]\n     fn bench_collect_into(b: &mut test::BenchHarness) {\n         let v = &[0, ..64];\n-        do b.iter {\n+        b.iter(|| {\n             let _: DList<int> = v.iter().map(|x| *x).collect();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_push_front(b: &mut test::BenchHarness) {\n         let mut m: DList<int> = DList::new();\n-        do b.iter {\n+        b.iter(|| {\n             m.push_front(0);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_push_back(b: &mut test::BenchHarness) {\n         let mut m: DList<int> = DList::new();\n-        do b.iter {\n+        b.iter(|| {\n             m.push_back(0);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::BenchHarness) {\n         let mut m: DList<int> = DList::new();\n-        do b.iter {\n+        b.iter(|| {\n             m.push_back(0);\n             m.pop_back();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_push_front_pop_front(b: &mut test::BenchHarness) {\n         let mut m: DList<int> = DList::new();\n-        do b.iter {\n+        b.iter(|| {\n             m.push_front(0);\n             m.pop_front();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_rotate_forward(b: &mut test::BenchHarness) {\n         let mut m: DList<int> = DList::new();\n         m.push_front(0);\n         m.push_front(1);\n-        do b.iter {\n+        b.iter(|| {\n             m.rotate_forward();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_rotate_backward(b: &mut test::BenchHarness) {\n         let mut m: DList<int> = DList::new();\n         m.push_front(0);\n         m.push_front(1);\n-        do b.iter {\n+        b.iter(|| {\n             m.rotate_backward();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_iter(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let m: DList<int> = v.iter().map(|&x|x).collect();\n-        do b.iter {\n+        b.iter(|| {\n             assert!(m.iter().len() == 128);\n-        }\n+        })\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let mut m: DList<int> = v.iter().map(|&x|x).collect();\n-        do b.iter {\n+        b.iter(|| {\n             assert!(m.mut_iter().len() == 128);\n-        }\n+        })\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let m: DList<int> = v.iter().map(|&x|x).collect();\n-        do b.iter {\n+        b.iter(|| {\n             assert!(m.rev_iter().len() == 128);\n-        }\n+        })\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let mut m: DList<int> = v.iter().map(|&x|x).collect();\n-        do b.iter {\n+        b.iter(|| {\n             assert!(m.mut_rev_iter().len() == 128);\n-        }\n+        })\n     }\n }"}, {"sha": "3d1d0c91e317d1c57b52d4f4cc09bea35f5ba098", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -108,15 +108,15 @@ mod tests {\n     fn test_flate_round_trip() {\n         let mut r = rand::rng();\n         let mut words = ~[];\n-        do 20.times {\n+        20.times(|| {\n             let range = r.gen_range(1u, 10);\n             words.push(r.gen_vec::<u8>(range));\n-        }\n-        do 20.times {\n+        });\n+        20.times(|| {\n             let mut input = ~[];\n-            do 2000.times {\n+            2000.times(|| {\n                 input.push_all(r.choose(words));\n-            }\n+            });\n             debug!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());\n             let cmp = deflate_bytes(input);\n@@ -125,7 +125,7 @@ mod tests {\n                    input.len(), cmp.len(),\n                    100.0 * ((cmp.len() as f64) / (input.len() as f64)));\n             assert_eq!(input, out);\n-        }\n+        });\n     }\n \n     #[test]"}, {"sha": "5a1d1308f8cdae04925fe70c69dbe95a73ac7feb", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -174,9 +174,9 @@ mod tests {\n     pub fn bench_to_hex(bh: & mut BenchHarness) {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        do bh.iter {\n+        bh.iter(|| {\n             s.as_bytes().to_hex();\n-        }\n+        });\n         bh.bytes = s.len() as u64;\n     }\n \n@@ -185,9 +185,9 @@ mod tests {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let b = s.as_bytes().to_hex();\n-        do bh.iter {\n+        bh.iter(|| {\n             b.from_hex();\n-        }\n+        });\n         bh.bytes = b.len() as u64;\n     }\n }"}, {"sha": "c30963568286ff18005ba26dff2dea926ef6a8ed", "filename": "src/libextra/json.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -1521,33 +1521,33 @@ mod tests {\n     fn test_write_enum() {\n         let animal = Dog;\n         assert_eq!(\n-            do with_str_writer |wr| {\n+            with_str_writer(|wr| {\n                 let mut encoder = Encoder(wr);\n                 animal.encode(&mut encoder);\n-            },\n+            }),\n             ~\"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n-            do with_str_writer |wr| {\n+            with_str_writer(|wr| {\n                 let mut encoder = PrettyEncoder(wr);\n                 animal.encode(&mut encoder);\n-            },\n+            }),\n             ~\"\\\"Dog\\\"\"\n         );\n \n         let animal = Frog(~\"Henry\", 349);\n         assert_eq!(\n-            do with_str_writer |wr| {\n+            with_str_writer(|wr| {\n                 let mut encoder = Encoder(wr);\n                 animal.encode(&mut encoder);\n-            },\n+            }),\n             ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n-            do with_str_writer |wr| {\n+            with_str_writer(|wr| {\n                 let mut encoder = PrettyEncoder(wr);\n                 animal.encode(&mut encoder);\n-            },\n+            }),\n             ~\"\\\n             [\\n  \\\n                 \\\"Frog\\\",\\n  \\\n@@ -1560,33 +1560,33 @@ mod tests {\n     #[test]\n     fn test_write_some() {\n         let value = Some(~\"jodhpurs\");\n-        let s = do with_str_writer |wr| {\n+        let s = with_str_writer(|wr| {\n             let mut encoder = Encoder(wr);\n             value.encode(&mut encoder);\n-        };\n+        });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n \n         let value = Some(~\"jodhpurs\");\n-        let s = do with_str_writer |wr| {\n+        let s = with_str_writer(|wr| {\n             let mut encoder = PrettyEncoder(wr);\n             value.encode(&mut encoder);\n-        };\n+        });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n     }\n \n     #[test]\n     fn test_write_none() {\n         let value: Option<~str> = None;\n-        let s = do with_str_writer |wr| {\n+        let s = with_str_writer(|wr| {\n             let mut encoder = Encoder(wr);\n             value.encode(&mut encoder);\n-        };\n+        });\n         assert_eq!(s, ~\"null\");\n \n-        let s = do with_str_writer |wr| {\n+        let s = with_str_writer(|wr| {\n             let mut encoder = Encoder(wr);\n             value.encode(&mut encoder);\n-        };\n+        });\n         assert_eq!(s, ~\"null\");\n     }\n "}, {"sha": "a37a0c39e304dee7dbb216330c20eb9dc81e1dfe", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -2615,19 +2615,27 @@ mod bench {\n \n     #[bench]\n     fn factorial_100(bh: &mut BenchHarness) {\n-        bh.iter(|| factorial(100));\n+        bh.iter(|| {\n+            factorial(100);\n+        });\n     }\n \n     #[bench]\n     fn fib_100(bh: &mut BenchHarness) {\n-        bh.iter(|| fib(100));\n+        bh.iter(|| {\n+            fib(100);\n+        });\n     }\n \n     #[bench]\n     fn to_str(bh: &mut BenchHarness) {\n         let fac = factorial(100);\n         let fib = fib(100);\n-        bh.iter(|| fac.to_str());\n-        bh.iter(|| fib.to_str());\n+        bh.iter(|| {\n+            fac.to_str();\n+        });\n+        bh.iter(|| {\n+            fib.to_str();\n+        });\n     }\n }"}, {"sha": "f6bf6c21335f8d72d69cec55a5e98b09ad13a74e", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -499,35 +499,35 @@ mod tests {\n \n     #[bench]\n     fn bench_new(b: &mut test::BenchHarness) {\n-        do b.iter {\n+        b.iter(|| {\n             let _: RingBuf<u64> = RingBuf::new();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_push_back(b: &mut test::BenchHarness) {\n         let mut deq = RingBuf::new();\n-        do b.iter {\n+        b.iter(|| {\n             deq.push_back(0);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_push_front(b: &mut test::BenchHarness) {\n         let mut deq = RingBuf::new();\n-        do b.iter {\n+        b.iter(|| {\n             deq.push_front(0);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_grow(b: &mut test::BenchHarness) {\n         let mut deq = RingBuf::new();\n-        do b.iter {\n-            do 65.times {\n+        b.iter(|| {\n+            65.times(|| {\n                 deq.push_front(1);\n-            }\n-        }\n+            })\n+        })\n     }\n \n     #[deriving(Clone, Eq)]"}, {"sha": "5d5696d778ffca207e6800457fbb33036afef902", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -828,7 +828,7 @@ mod test_qsort {\n \n         let expected = ~[1, 2, 3];\n \n-        do quick_sort(names) |x, y| { *x < *y };\n+        quick_sort(names, |x, y| *x < *y);\n \n         let immut_names = names;\n \n@@ -968,9 +968,9 @@ mod test_tim_sort {\n     #[cfg(unix)]\n     fn crash_test() {\n         let mut rng = rand::rng();\n-        let mut arr = do vec::from_fn(1000) |_i| {\n+        let mut arr = vec::from_fn(1000, |_i| {\n             CVal { val: rng.gen() }\n-        };\n+        });\n \n         tim_sort(arr);\n         fail!(\"Guarantee the fail\");\n@@ -991,9 +991,9 @@ mod test_tim_sort {\n     #[test]\n     fn test_bad_Ord_impl() {\n         let mut rng = rand::rng();\n-        let mut arr = do vec::from_fn(500) |_i| {\n+        let mut arr = vec::from_fn(500, |_i| {\n             DVal { val: rng.gen() }\n-        };\n+        });\n \n         tim_sort(arr);\n     }\n@@ -1024,14 +1024,14 @@ mod big_tests {\n \n     fn multiplyVec<T:Clone>(arr: &[T], num: uint) -> ~[T] {\n         let size = arr.len();\n-        let res = do vec::from_fn(num) |i| {\n+        let res = vec::from_fn(num, |i| {\n             arr[i % size].clone()\n-        };\n+        });\n         res\n     }\n \n     fn makeRange(n: uint) -> ~[uint] {\n-        let one = do vec::from_fn(n) |i| { i };\n+        let one = vec::from_fn(n, |i| i);\n         let mut two = one.clone();\n         two.reverse();\n         vec::append(two, one)\n@@ -1050,9 +1050,9 @@ mod big_tests {\n \n         for i in range(lo, hi) {\n             let n = 1 << i;\n-            let mut arr: ~[f64] = do vec::from_fn(n) |_i| {\n+            let mut arr: ~[f64] = vec::from_fn(n, |_i| {\n                 rng.gen()\n-            };\n+            });\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1064,11 +1064,11 @@ mod big_tests {\n             tim_sort(arr); // /sort\n             isSorted(arr);\n \n-            do 3.times {\n+            3.times(|| {\n                 let i1 = rng.gen_range(0u, n);\n                 let i2 = rng.gen_range(0u, n);\n                 arr.swap(i1, i2);\n-            }\n+            });\n             tim_sort(arr); // 3sort\n             isSorted(arr);\n \n@@ -1083,10 +1083,10 @@ mod big_tests {\n             tim_sort(arr); // +sort\n             isSorted(arr);\n \n-            do (n/100).times {\n+            (n/100).times(|| {\n                 let idx = rng.gen_range(0u, n);\n                 arr[idx] = rng.gen();\n-            }\n+            });\n             tim_sort(arr);\n             isSorted(arr);\n \n@@ -1121,9 +1121,9 @@ mod big_tests {\n \n         for i in range(lo, hi) {\n             let n = 1 << i;\n-            let arr: ~[@f64] = do vec::from_fn(n) |_i| {\n+            let arr: ~[@f64] = vec::from_fn(n, |_i| {\n                 @rng.gen()\n-            };\n+            });\n             let mut arr = arr;\n \n             tim_sort(arr); // *sort\n@@ -1136,11 +1136,11 @@ mod big_tests {\n             tim_sort(arr); // /sort\n             isSorted(arr);\n \n-            do 3.times {\n+            3.times(|| {\n                 let i1 = rng.gen_range(0u, n);\n                 let i2 = rng.gen_range(0u, n);\n                 arr.swap(i1, i2);\n-            }\n+            });\n             tim_sort(arr); // 3sort\n             isSorted(arr);\n \n@@ -1155,10 +1155,10 @@ mod big_tests {\n             tim_sort(arr); // +sort\n             isSorted(arr);\n \n-            do (n/100).times {\n+            (n/100).times(|| {\n                 let idx = rng.gen_range(0u, n);\n                 arr[idx] = @rng.gen();\n-            }\n+            });\n             tim_sort(arr);\n             isSorted(arr);\n "}, {"sha": "0d5368695b79cfc962a2cbb8261b1581a6128fc8", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 116, "deletions": 116, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -571,15 +571,15 @@ impl RWLock {\n      * # Example\n      *\n      * ```rust\n-     * do lock.write_downgrade |mut write_token| {\n-     *     do write_token.write_cond |condvar| {\n+     * lock.write_downgrade(|mut write_token| {\n+     *     write_token.write_cond(|condvar| {\n      *         ... exclusive access ...\n-     *     }\n+     *     });\n      *     let read_token = lock.downgrade(write_token);\n-     *     do read_token.read {\n+     *     read_token.read(|| {\n      *         ... shared access ...\n-     *     }\n-     * }\n+     *     })\n+     * })\n      * ```\n      */\n     pub fn write_downgrade<U>(&self, blk: |v: RWLockWriteMode| -> U) -> U {\n@@ -698,20 +698,20 @@ mod tests {\n     #[test]\n     fn test_sem_basic() {\n         let s = Semaphore::new(1);\n-        do s.access { }\n+        s.access(|| { })\n     }\n     #[test]\n     fn test_sem_as_mutex() {\n         let s = Semaphore::new(1);\n         let s2 = s.clone();\n         do task::spawn {\n-            do s2.access {\n-                do 5.times { task::deschedule(); }\n-            }\n-        }\n-        do s.access {\n-            do 5.times { task::deschedule(); }\n+            s2.access(|| {\n+                5.times(|| { task::deschedule(); })\n+            })\n         }\n+        s.access(|| {\n+            5.times(|| { task::deschedule(); })\n+        })\n     }\n     #[test]\n     fn test_sem_as_cvar() {\n@@ -723,7 +723,7 @@ mod tests {\n             s2.acquire();\n             c.send(());\n         }\n-        do 5.times { task::deschedule(); }\n+        5.times(|| { task::deschedule(); });\n         s.release();\n         let _ = p.recv();\n \n@@ -732,7 +732,7 @@ mod tests {\n         let s = Semaphore::new(0);\n         let s2 = s.clone();\n         do task::spawn {\n-            do 5.times { task::deschedule(); }\n+            5.times(|| { task::deschedule(); });\n             s2.release();\n             let _ = p.recv();\n         }\n@@ -748,15 +748,15 @@ mod tests {\n         let (p1,c1) = comm::stream();\n         let (p2,c2) = comm::stream();\n         do task::spawn {\n-            do s2.access {\n+            s2.access(|| {\n                 let _ = p2.recv();\n                 c1.send(());\n-            }\n+            })\n         }\n-        do s.access {\n+        s.access(|| {\n             c2.send(());\n             let _ = p1.recv();\n-        }\n+        })\n     }\n     #[test]\n     fn test_sem_runtime_friendly_blocking() {\n@@ -767,16 +767,16 @@ mod tests {\n             let s2 = s.clone();\n             let (p, c) = comm::stream();\n             let child_data = Cell::new((s2, c));\n-            do s.access {\n+            s.access(|| {\n                 let (s2, c) = child_data.take();\n                 do task::spawn {\n                     c.send(());\n-                    do s2.access { }\n+                    s2.access(|| { });\n                     c.send(());\n                 }\n                 let _ = p.recv(); // wait for child to come alive\n-                do 5.times { task::deschedule(); } // let the child contend\n-            }\n+                5.times(|| { task::deschedule(); }); // let the child contend\n+            });\n             let _ = p.recv(); // wait for child to be done\n         }\n     }\n@@ -809,71 +809,71 @@ mod tests {\n         }\n \n         fn access_shared(sharedstate: &mut int, m: &Mutex, n: uint) {\n-            do n.times {\n-                do m.lock {\n+            n.times(|| {\n+                m.lock(|| {\n                     let oldval = *sharedstate;\n                     task::deschedule();\n                     *sharedstate = oldval + 1;\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n     #[test]\n     fn test_mutex_cond_wait() {\n         let m = Mutex::new();\n \n         // Child wakes up parent\n-        do m.lock_cond |cond| {\n+        m.lock_cond(|cond| {\n             let m2 = m.clone();\n             do task::spawn {\n-                do m2.lock_cond |cond| {\n+                m2.lock_cond(|cond| {\n                     let woken = cond.signal();\n                     assert!(woken);\n-                }\n+                })\n             }\n             cond.wait();\n-        }\n+        });\n         // Parent wakes up child\n         let (port,chan) = comm::stream();\n         let m3 = m.clone();\n         do task::spawn {\n-            do m3.lock_cond |cond| {\n+            m3.lock_cond(|cond| {\n                 chan.send(());\n                 cond.wait();\n                 chan.send(());\n-            }\n+            })\n         }\n         let _ = port.recv(); // Wait until child gets in the mutex\n-        do m.lock_cond |cond| {\n+        m.lock_cond(|cond| {\n             let woken = cond.signal();\n             assert!(woken);\n-        }\n+        });\n         let _ = port.recv(); // Wait until child wakes up\n     }\n     #[cfg(test)]\n     fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n         let m = Mutex::new();\n         let mut ports = ~[];\n \n-        do num_waiters.times {\n+        num_waiters.times(|| {\n             let mi = m.clone();\n             let (port, chan) = comm::stream();\n             ports.push(port);\n             do task::spawn {\n-                do mi.lock_cond |cond| {\n+                mi.lock_cond(|cond| {\n                     chan.send(());\n                     cond.wait();\n                     chan.send(());\n-                }\n+                })\n             }\n-        }\n+        });\n \n         // wait until all children get in the mutex\n         for port in ports.iter() { let _ = port.recv(); }\n-        do m.lock_cond |cond| {\n+        m.lock_cond(|cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n-        }\n+        });\n         // wait until all children wake up\n         for port in ports.iter() { let _ = port.recv(); }\n     }\n@@ -890,11 +890,11 @@ mod tests {\n         let m = Mutex::new();\n         let m2 = m.clone();\n         do task::try {\n-            do m.lock_cond |_x| { }\n+            m.lock_cond(|_x| { })\n         };\n-        do m2.lock_cond |cond| {\n+        m2.lock_cond(|cond| {\n             assert!(!cond.signal());\n-        }\n+        })\n     }\n     #[test]\n     fn test_mutex_killed_simple() {\n@@ -903,13 +903,13 @@ mod tests {\n         let m2 = m.clone();\n \n         let result: result::Result<(), ~Any> = do task::try {\n-            do m2.lock {\n+            m2.lock(|| {\n                 fail!();\n-            }\n+            })\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        do m.lock { }\n+        m.lock(|| { })\n     }\n     #[ignore(reason = \"linked failure\")]\n     #[test]\n@@ -926,17 +926,17 @@ mod tests {\n                 task::deschedule();\n                 fail!();\n             }\n-            do m2.lock_cond |cond| {\n+            m2.lock_cond(|cond| {\n                 c.send(()); // tell sibling go ahead\n                 cond.wait(); // block forever\n-            }\n+            })\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        do m.lock_cond |cond| {\n+        m.lock_cond(|cond| {\n             let woken = cond.signal();\n             assert!(!woken);\n-        }\n+        })\n     }\n     #[ignore(reason = \"linked failure\")]\n     #[test]\n@@ -949,55 +949,55 @@ mod tests {\n \n         let result: result::Result<(), ~Any> = do task::try {\n             let mut sibling_convos = ~[];\n-            do 2.times {\n+            2.times(|| {\n                 let (p, c) = comm::stream();\n                 let c = Cell::new(c);\n                 sibling_convos.push(p);\n                 let mi = m2.clone();\n                 // spawn sibling task\n                 do task::spawn { // linked\n-                    do mi.lock_cond |cond| {\n+                    mi.lock_cond(|cond| {\n                         let c = c.take();\n                         c.send(()); // tell sibling to go ahead\n-                        do (|| {\n+                        (|| {\n                             cond.wait(); // block forever\n-                        }).finally {\n+                        }).finally(|| {\n                             error!(\"task unwinding and sending\");\n                             c.send(());\n                             error!(\"task unwinding and done sending\");\n-                        }\n-                    }\n+                        })\n+                    })\n                 }\n-            }\n+            });\n             for p in sibling_convos.iter() {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n-            do m2.lock { }\n+            m2.lock(|| { });\n             c.send(sibling_convos); // let parent wait on all children\n             fail!();\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n         let r = p.recv();\n         for p in r.iter() { p.recv(); } // wait on all its siblings\n-        do m.lock_cond |cond| {\n+        m.lock_cond(|cond| {\n             let woken = cond.broadcast();\n             assert_eq!(woken, 0);\n-        }\n+        })\n     }\n     #[test]\n     fn test_mutex_cond_signal_on_0() {\n         // Tests that signal_on(0) is equivalent to signal().\n         let m = Mutex::new();\n-        do m.lock_cond |cond| {\n+        m.lock_cond(|cond| {\n             let m2 = m.clone();\n             do task::spawn {\n-                do m2.lock_cond |cond| {\n+                m2.lock_cond(|cond| {\n                     cond.signal_on(0);\n-                }\n+                })\n             }\n             cond.wait();\n-        }\n+        })\n     }\n     #[test]\n     fn test_mutex_different_conds() {\n@@ -1006,35 +1006,35 @@ mod tests {\n             let m2 = m.clone();\n             let (p, c) = comm::stream();\n             do task::spawn {\n-                do m2.lock_cond |cond| {\n+                m2.lock_cond(|cond| {\n                     c.send(());\n                     cond.wait_on(1);\n-                }\n+                })\n             }\n             let _ = p.recv();\n-            do m.lock_cond |cond| {\n+            m.lock_cond(|cond| {\n                 if !cond.signal_on(0) {\n                     fail!(); // success; punt sibling awake.\n                 }\n-            }\n+            })\n         };\n         assert!(result.is_err());\n     }\n     #[test]\n     fn test_mutex_no_condvars() {\n         let result = do task::try {\n             let m = Mutex::new_with_condvars(0);\n-            do m.lock_cond |cond| { cond.wait(); }\n+            m.lock_cond(|cond| { cond.wait(); })\n         };\n         assert!(result.is_err());\n         let result = do task::try {\n             let m = Mutex::new_with_condvars(0);\n-            do m.lock_cond |cond| { cond.signal(); }\n+            m.lock_cond(|cond| { cond.signal(); })\n         };\n         assert!(result.is_err());\n         let result = do task::try {\n             let m = Mutex::new_with_condvars(0);\n-            do m.lock_cond |cond| { cond.broadcast(); }\n+            m.lock_cond(|cond| { cond.broadcast(); })\n         };\n         assert!(result.is_err());\n     }\n@@ -1049,14 +1049,14 @@ mod tests {\n             Read => x.read(blk),\n             Write => x.write(blk),\n             Downgrade =>\n-                do x.write_downgrade |mode| {\n-                    do mode.write { blk() };\n-                },\n+                x.write_downgrade(|mode| {\n+                    mode.write(|| { blk() });\n+                }),\n             DowngradeRead =>\n-                do x.write_downgrade |mode| {\n+                x.write_downgrade(|mode| {\n                     let mode = x.downgrade(mode);\n-                    do mode.read { blk() };\n-                },\n+                    mode.read(|| { blk() });\n+                }),\n         }\n     }\n     #[cfg(test)]\n@@ -1086,13 +1086,13 @@ mod tests {\n \n         fn access_shared(sharedstate: &mut int, x: &RWLock, mode: RWLockMode,\n                          n: uint) {\n-            do n.times {\n-                do lock_rwlock_in_mode(x, mode) {\n+            n.times(|| {\n+                lock_rwlock_in_mode(x, mode, || {\n                     let oldval = *sharedstate;\n                     task::deschedule();\n                     *sharedstate = oldval + 1;\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n     #[test]\n@@ -1122,24 +1122,24 @@ mod tests {\n             if !make_mode2_go_first {\n                 let _ = p2.recv(); // parent sends to us once it locks, or ...\n             }\n-            do lock_rwlock_in_mode(&x2, mode2) {\n+            lock_rwlock_in_mode(&x2, mode2, || {\n                 if make_mode2_go_first {\n                     c1.send(()); // ... we send to it once we lock\n                 }\n                 let _ = p2.recv();\n                 c1.send(());\n-            }\n+            })\n         }\n         if make_mode2_go_first {\n             let _ = p1.recv(); // child sends to us once it locks, or ...\n         }\n-        do lock_rwlock_in_mode(x, mode1) {\n+        lock_rwlock_in_mode(x, mode1, || {\n             if !make_mode2_go_first {\n                 c2.send(()); // ... we send to it once we lock\n             }\n             c2.send(());\n             let _ = p1.recv();\n-        }\n+        })\n     }\n     #[test]\n     fn test_rwlock_readers_and_readers() {\n@@ -1154,51 +1154,51 @@ mod tests {\n     fn test_rwlock_downgrade_unlock() {\n         // Tests that downgrade can unlock the lock in both modes\n         let x = RWLock::new();\n-        do lock_rwlock_in_mode(&x, Downgrade) { }\n+        lock_rwlock_in_mode(&x, Downgrade, || { });\n         test_rwlock_handshake(&x, Read, Read, false);\n         let y = RWLock::new();\n-        do lock_rwlock_in_mode(&y, DowngradeRead) { }\n+        lock_rwlock_in_mode(&y, DowngradeRead, || { });\n         test_rwlock_exclusion(&y, Write, Write);\n     }\n     #[test]\n     fn test_rwlock_read_recursive() {\n         let x = RWLock::new();\n-        do x.read { do x.read { } }\n+        x.read(|| { x.read(|| { }) })\n     }\n     #[test]\n     fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n         let x = RWLock::new();\n \n         // Child wakes up parent\n-        do x.write_cond |cond| {\n+        x.write_cond(|cond| {\n             let x2 = x.clone();\n             do task::spawn {\n-                do x2.write_cond |cond| {\n+                x2.write_cond(|cond| {\n                     let woken = cond.signal();\n                     assert!(woken);\n-                }\n+                })\n             }\n             cond.wait();\n-        }\n+        });\n         // Parent wakes up child\n         let (port, chan) = comm::stream();\n         let x3 = x.clone();\n         do task::spawn {\n-            do x3.write_cond |cond| {\n+            x3.write_cond(|cond| {\n                 chan.send(());\n                 cond.wait();\n                 chan.send(());\n-            }\n+            })\n         }\n         let _ = port.recv(); // Wait until child gets in the rwlock\n-        do x.read { } // Must be able to get in as a reader in the meantime\n-        do x.write_cond |cond| { // Or as another writer\n+        x.read(|| { }); // Must be able to get in as a reader in the meantime\n+        x.write_cond(|cond| { // Or as another writer\n             let woken = cond.signal();\n             assert!(woken);\n-        }\n+        });\n         let _ = port.recv(); // Wait until child wakes up\n-        do x.read { } // Just for good measure\n+        x.read(|| { }); // Just for good measure\n     }\n     #[cfg(test)]\n     fn test_rwlock_cond_broadcast_helper(num_waiters: uint,\n@@ -1207,35 +1207,35 @@ mod tests {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n         fn lock_cond(x: &RWLock, downgrade: bool, blk: |c: &Condvar|) {\n             if downgrade {\n-                do x.write_downgrade |mode| {\n-                    do mode.write_cond |c| { blk(c) }\n-                }\n+                x.write_downgrade(|mode| {\n+                    mode.write_cond(|c| { blk(c) });\n+                });\n             } else {\n-                do x.write_cond |c| { blk(c) }\n+                x.write_cond(|c| { blk(c) });\n             }\n         }\n         let x = RWLock::new();\n         let mut ports = ~[];\n \n-        do num_waiters.times {\n+        num_waiters.times(|| {\n             let xi = x.clone();\n             let (port, chan) = comm::stream();\n             ports.push(port);\n             do task::spawn {\n-                do lock_cond(&xi, dg1) |cond| {\n+                lock_cond(&xi, dg1, |cond| {\n                     chan.send(());\n                     cond.wait();\n                     chan.send(());\n-                }\n+                })\n             }\n-        }\n+        });\n \n         // wait until all children get in the mutex\n         for port in ports.iter() { let _ = port.recv(); }\n-        do lock_cond(&x, dg2) |cond| {\n+        lock_cond(&x, dg2, |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n-        }\n+        });\n         // wait until all children wake up\n         for port in ports.iter() { let _ = port.recv(); }\n     }\n@@ -1257,13 +1257,13 @@ mod tests {\n         let x2 = x.clone();\n \n         let result: result::Result<(), ~Any> = do task::try || {\n-            do lock_rwlock_in_mode(&x2, mode1) {\n+            lock_rwlock_in_mode(&x2, mode1, || {\n                 fail!();\n-            }\n+            })\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        do lock_rwlock_in_mode(&x, mode2) { }\n+        lock_rwlock_in_mode(&x, mode2, || { })\n     }\n     #[test]\n     fn test_rwlock_reader_killed_writer() {\n@@ -1301,12 +1301,12 @@ mod tests {\n         // Tests that you can't downgrade with a different rwlock's token.\n         let x = RWLock::new();\n         let y = RWLock::new();\n-        do x.write_downgrade |xwrite| {\n+        x.write_downgrade(|xwrite| {\n             let mut xopt = Some(xwrite);\n-            do y.write_downgrade |_ywrite| {\n+            y.write_downgrade(|_ywrite| {\n                 y.downgrade(xopt.take_unwrap());\n                 error!(\"oops, y.downgrade(x) should have failed!\");\n-            }\n-        }\n+            })\n+        })\n     }\n }"}, {"sha": "d6eed24ef8d44a53c8780393fd37929263d14714", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -102,7 +102,7 @@ fn test_task_pool() {\n         g\n     };\n     let mut pool = TaskPool::new(4, Some(SingleThreaded), f);\n-    do 8.times {\n+    8.times(|| {\n         pool.execute(|i| println!(\"Hello from thread {}!\", *i));\n-    }\n+    })\n }"}, {"sha": "cf63c63c942a1365ee861b6595fb62f8ed62ffde", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -1027,8 +1027,8 @@ mod test_treemap {\n \n         let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(&[42]);\n \n-        do 3.times {\n-            do 90.times {\n+        3.times(|| {\n+            90.times(|| {\n                 let k = rng.gen();\n                 let v = rng.gen();\n                 if !ctrl.iter().any(|x| x == &(k, v)) {\n@@ -1037,16 +1037,16 @@ mod test_treemap {\n                     check_structure(&map);\n                     check_equal(ctrl, &map);\n                 }\n-            }\n+            });\n \n-            do 30.times {\n+            30.times(|| {\n                 let r = rng.gen_range(0, ctrl.len());\n                 let (key, _) = ctrl.remove(r);\n                 assert!(map.remove(&key));\n                 check_structure(&map);\n                 check_equal(ctrl, &map);\n-            }\n-        }\n+            });\n+        })\n     }\n \n     #[test]\n@@ -1414,11 +1414,11 @@ mod test_set {\n         for y in b.iter() { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n-        do f(&set_a, &set_b) |x| {\n+        f(&set_a, &set_b, |x| {\n             assert_eq!(*x, expected[i]);\n             i += 1;\n             true\n-        };\n+        });\n         assert_eq!(i, expected.len());\n     }\n "}, {"sha": "d40eef732f112086d69e9349372e0867b9f5304f", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -811,24 +811,24 @@ mod bench {\n \n     #[bench]\n     pub fn create_uuids(bh: &mut BenchHarness) {\n-        do bh.iter {\n+        bh.iter(|| {\n             Uuid::new_v4();\n-        }\n+        })\n     }\n \n     #[bench]\n     pub fn uuid_to_str(bh: &mut BenchHarness) {\n         let u = Uuid::new_v4();\n-        do bh.iter {\n+        bh.iter(|| {\n             u.to_str();\n-        }\n+        })\n     }\n \n     #[bench]\n     pub fn parse_str(bh: &mut BenchHarness) {\n         let s = \"urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4\";\n-        do bh.iter {\n+        bh.iter(|| {\n             Uuid::parse_string(s);\n-        }\n+        })\n     }\n }"}, {"sha": "86c0fb276801631e0071fea9ed02f21824fbe28d", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -384,7 +384,7 @@ fn executable_exists(repo: &Path, short_name: &str) -> bool {\n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n-    exec.map_default(false, |exec| exec.exists() && is_rwx(&exec));\n+    exec.map_default(false, |exec| exec.exists() && is_rwx(&exec))\n }\n \n fn remove_executable_file(p: &PkgId, workspace: &Path) {"}, {"sha": "1f06f87c9de6e80f32ac72c1568ba4318038130c", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -392,11 +392,11 @@ fn local_loop() -> &'static mut Loop {\n     unsafe {\n         cast::transmute(Local::borrow(|sched: &mut Scheduler| {\n             let mut io = None;\n-            do sched.event_loop.io |i| {\n+            sched.event_loop.io(|i| {\n                 let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n                     cast::transmute(i);\n                 io = Some(uvio);\n-            }\n+            });\n             io.unwrap()\n         }).uv_loop())\n     }"}, {"sha": "2d13cdb9bbb7f3f863faffba73bfd1e06e2608da", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -48,9 +48,9 @@ fn with_error_checking_parse<T>(s: @str, f: |&mut Parser| -> T) -> T {\n \n // parse a string, return a crate.\n pub fn string_to_crate (source_str : @str) -> ast::Crate {\n-    do with_error_checking_parse(source_str) |p| {\n+    with_error_checking_parse(source_str, |p| {\n         p.parse_crate_mod()\n-    }\n+    })\n }\n \n // parse a string, return a crate and the ParseSess\n@@ -61,23 +61,23 @@ pub fn string_to_crate_and_sess (source_str : @str) -> (ast::Crate,@mut ParseSes\n \n // parse a string, return an expr\n pub fn string_to_expr (source_str : @str) -> @ast::Expr {\n-    do with_error_checking_parse(source_str) |p| {\n+    with_error_checking_parse(source_str, |p| {\n         p.parse_expr()\n-    }\n+    })\n }\n \n // parse a string, return an item\n pub fn string_to_item (source_str : @str) -> Option<@ast::item> {\n-    do with_error_checking_parse(source_str) |p| {\n+    with_error_checking_parse(source_str, |p| {\n         p.parse_item(~[])\n-    }\n+    })\n }\n \n // parse a string, return a stmt\n pub fn string_to_stmt(source_str : @str) -> @ast::Stmt {\n-    do with_error_checking_parse(source_str) |p| {\n+    with_error_checking_parse(source_str, |p| {\n         p.parse_stmt(~[])\n-    }\n+    })\n }\n \n // parse a string, return a pat. Uses \"irrefutable\"... which doesn't"}, {"sha": "ca7dc238e2e819b33998f054a8e41eee533fbef6", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -29,66 +29,65 @@ fn timed(label: &str, f: ||) {\n fn ascending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n     println(\" Ascending integers:\");\n \n-    do timed(\"insert\") {\n+    timed(\"insert\", || {\n         for i in range(0u, n_keys) {\n             map.insert(i, i + 1);\n         }\n-    }\n+    });\n \n-    do timed(\"search\") {\n+    timed(\"search\", || {\n         for i in range(0u, n_keys) {\n             assert_eq!(map.find(&i).unwrap(), &(i + 1));\n         }\n-    }\n+    });\n \n-    do timed(\"remove\") {\n+    timed(\"remove\", || {\n         for i in range(0, n_keys) {\n             assert!(map.remove(&i));\n         }\n-    }\n+    });\n }\n \n fn descending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n     println(\" Descending integers:\");\n \n-    do timed(\"insert\") {\n+    timed(\"insert\", || {\n         for i in range(0, n_keys).invert() {\n             map.insert(i, i + 1);\n         }\n-    }\n+    });\n \n-    do timed(\"search\") {\n+    timed(\"search\", || {\n         for i in range(0, n_keys).invert() {\n             assert_eq!(map.find(&i).unwrap(), &(i + 1));\n         }\n-    }\n+    });\n \n-    do timed(\"remove\") {\n+    timed(\"remove\", || {\n         for i in range(0, n_keys) {\n             assert!(map.remove(&i));\n         }\n-    }\n+    });\n }\n \n fn vector<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint, dist: &[uint]) {\n-\n-    do timed(\"insert\") {\n+    timed(\"insert\", || {\n         for i in range(0u, n_keys) {\n             map.insert(dist[i], i + 1);\n         }\n-    }\n+    });\n \n-    do timed(\"search\") {\n+    timed(\"search\", || {\n         for i in range(0u, n_keys) {\n             assert_eq!(map.find(&dist[i]).unwrap(), &(i + 1));\n         }\n-    }\n+    });\n \n-    do timed(\"remove\") {\n+    timed(\"remove\", || {\n         for i in range(0u, n_keys) {\n             assert!(map.remove(&dist[i]));\n         }\n-    }\n+    });\n }\n \n fn main() {"}, {"sha": "ff3ab37b29cb906c1eb4a32e0e32095e94b7a585", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -43,24 +43,24 @@ impl Results {\n                      rand_cap: uint,\n                      f: || -> T) { {\n             let mut set = f();\n-            do timed(&mut self.sequential_ints) {\n+            timed(&mut self.sequential_ints, || {\n                 for i in range(0u, num_keys) {\n                     set.insert(i);\n                 }\n \n                 for i in range(0u, num_keys) {\n                     assert!(set.contains(&i));\n                 }\n-            }\n+            })\n         }\n \n         {\n             let mut set = f();\n-            do timed(&mut self.random_ints) {\n+            timed(&mut self.random_ints, || {\n                 for _ in range(0, num_keys) {\n                     set.insert(rng.gen::<uint>() % rand_cap);\n                 }\n-            }\n+            })\n         }\n \n         {\n@@ -69,11 +69,11 @@ impl Results {\n                 set.insert(i);\n             }\n \n-            do timed(&mut self.delete_ints) {\n+            timed(&mut self.delete_ints, || {\n                 for i in range(0u, num_keys) {\n                     assert!(set.remove(&i));\n                 }\n-            }\n+            })\n         }\n     }\n \n@@ -85,37 +85,37 @@ impl Results {\n                      f: || -> T) {\n         {\n             let mut set = f();\n-            do timed(&mut self.sequential_strings) {\n+            timed(&mut self.sequential_strings, || {\n                 for i in range(0u, num_keys) {\n                     set.insert(i.to_str());\n                 }\n \n                 for i in range(0u, num_keys) {\n                     assert!(set.contains(&i.to_str()));\n                 }\n-            }\n+            })\n         }\n \n         {\n             let mut set = f();\n-            do timed(&mut self.random_strings) {\n+            timed(&mut self.random_strings, || {\n                 for _ in range(0, num_keys) {\n                     let s = rng.gen::<uint>().to_str();\n                     set.insert(s);\n                 }\n-            }\n+            })\n         }\n \n         {\n             let mut set = f();\n             for i in range(0u, num_keys) {\n                 set.insert(i.to_str());\n             }\n-            do timed(&mut self.delete_strings) {\n+            timed(&mut self.delete_strings, || {\n                 for i in range(0u, num_keys) {\n                     assert!(set.remove(&i.to_str()));\n                 }\n-            }\n+            })\n         }\n     }\n }"}, {"sha": "facd8a3bd74e6ee9afbb04f74128bbe8efa0c1b1", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -29,20 +29,20 @@ type pipe = arc::MutexArc<~[uint]>;\n \n fn send(p: &pipe, msg: uint) {\n     unsafe {\n-        do p.access_cond |state, cond| {\n+        p.access_cond(|state, cond| {\n             state.push(msg);\n             cond.signal();\n-        }\n+        })\n     }\n }\n fn recv(p: &pipe) -> uint {\n     unsafe {\n-        do p.access_cond |state, cond| {\n+        p.access_cond(|state, cond| {\n             while state.is_empty() {\n                 cond.wait();\n             }\n             state.pop()\n-        }\n+        })\n     }\n }\n "}, {"sha": "2ce3a373f8b33d606d094fbe611a8d3a79341e14", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -28,18 +28,18 @@ use std::uint;\n type pipe = arc::RWArc<~[uint]>;\n \n fn send(p: &pipe, msg: uint) {\n-    do p.write_cond |state, cond| {\n+    p.write_cond(|state, cond| {\n         state.push(msg);\n         cond.signal();\n-    }\n+    })\n }\n fn recv(p: &pipe) -> uint {\n-    do p.write_cond |state, cond| {\n+    p.write_cond(|state, cond| {\n         while state.is_empty() {\n             cond.wait();\n         }\n         state.pop()\n-    }\n+    })\n }\n \n fn init() -> (pipe,pipe) {"}, {"sha": "715043d5be686cf23c2ce2b1e3608fa8bbe9a65b", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -37,26 +37,25 @@ fn ping_pong_bench(n: uint, m: uint) {\n         do spawntask_later() || {\n             let chan = ca.take();\n             let port = pb.take();\n-            do n.times {\n+            n.times(|| {\n                 chan.send(());\n                 port.recv();\n-            }\n+            })\n         }\n \n         do spawntask_later() || {\n             let chan = cb.take();\n             let port = pa.take();\n-            do n.times {\n+            n.times(|| {\n                 port.recv();\n                 chan.send(());\n-            }\n+            })\n         }\n     }\n \n-    do m.times {\n+    m.times(|| {\n         run_pair(n)\n-    }\n-\n+    })\n }\n \n "}, {"sha": "e057d6862e6a91685d02bda9e64c291973b9fd99", "filename": "src/test/bench/rt-spawn-rate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-spawn-rate.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -26,8 +26,8 @@ fn main() {\n         100000\n     };\n \n-    do n.times {\n+    n.times(|| {\n         do spawn || {};\n-    }\n+    })\n \n }"}, {"sha": "d2241a0ddee525393c9bbda9e45e572be0e1e0da", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -28,11 +28,11 @@ fn item_check(t: &Tree) -> int {\n \n fn bottom_up_tree<'r>(arena: &'r Arena, item: int, depth: int) -> &'r Tree<'r> {\n     if depth > 0 {\n-        do arena.alloc {\n+        arena.alloc(|| {\n             Node(bottom_up_tree(arena, 2 * item - 1, depth - 1),\n                  bottom_up_tree(arena, 2 * item, depth - 1),\n                  item)\n-        }\n+        })\n     } else {arena.alloc(|| Nil)}\n }\n "}, {"sha": "5045e9c58d92527f94a5d4604aed907b611870a6", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -169,7 +169,7 @@ fn main() {\n     let sizes = ~[1u,2,3,4,6,12,18];\n     let mut streams = vec::from_fn(sizes.len(), |_| Some(stream::<~str>()));\n     let mut from_child = ~[];\n-    let to_child   = do sizes.iter().zip(streams.mut_iter()).map |(sz, stream_ref)| {\n+    let to_child   = sizes.iter().zip(streams.mut_iter()).map(|(sz, stream_ref)| {\n         let sz = *sz;\n         let stream = util::replace(stream_ref, None);\n         let (from_child_, to_parent_) = stream.unwrap();\n@@ -183,7 +183,7 @@ fn main() {\n         }\n \n         to_child\n-    }.collect::<~[Chan<~[u8]>]>();\n+    }).collect::<~[Chan<~[u8]>]>();\n \n \n    // latch stores true after we've started"}, {"sha": "5685b489072f1801826ed0bb81c2fd954411374e", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -18,7 +18,7 @@ fn iterate<'a, T>(x: T, f: 'a |&T| -> T) -> Iterate<'a, T> {\n     Iterate {f: f, next: x}\n }\n struct Iterate<'self, T> {\n-    priv f: &'self |&T| -> T,\n+    priv f: 'self |&T| -> T,\n     priv next: T\n }\n impl<'self, T> Iterator<T> for Iterate<'self, T> {"}, {"sha": "497b6a392a539d5b539c59aa1c1cff5182f7ce5e", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -51,9 +51,9 @@ impl Sudoku {\n     }\n \n     pub fn from_vec(vec: &[[u8, ..9], ..9]) -> Sudoku {\n-        let g = do vec::from_fn(9u) |i| {\n-            do vec::from_fn(9u) |j| { vec[i][j] }\n-        };\n+        let g = vec::from_fn(9u, |i| {\n+            vec::from_fn(9u, |j| { vec[i][j] })\n+        });\n         return Sudoku::new(g)\n     }\n "}, {"sha": "cdbec1784b98ebc2c7409894daaf15cebe3881d2", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=38efa17bb8b9c1077e7b8cd9d67da08dec3f0bda", "patch": "@@ -19,13 +19,13 @@ use std::vec;\n \n fn calc(children: uint, parent_wait_chan: &Chan<Chan<Chan<int>>>) {\n \n-    let wait_ports: ~[Port<Chan<Chan<int>>>] = do vec::from_fn(children) |_| {\n+    let wait_ports: ~[Port<Chan<Chan<int>>>] = vec::from_fn(children, |_| {\n         let (wait_port, wait_chan) = stream::<Chan<Chan<int>>>();\n         do task::spawn {\n             calc(children / 2, &wait_chan);\n         }\n         wait_port\n-    };\n+    });\n \n     let child_start_chans: ~[Chan<Chan<int>>] =\n         wait_ports.move_iter().map(|port| port.recv()).collect();\n@@ -35,11 +35,11 @@ fn calc(children: uint, parent_wait_chan: &Chan<Chan<Chan<int>>>) {\n     let parent_result_chan: Chan<int> = start_port.recv();\n \n     let child_sum_ports: ~[Port<int>] =\n-        do child_start_chans.move_iter().map |child_start_chan| {\n+        child_start_chans.move_iter().map(|child_start_chan| {\n             let (child_sum_port, child_sum_chan) = stream::<int>();\n             child_start_chan.send(child_sum_chan);\n             child_sum_port\n-    }.collect();\n+    }).collect();\n \n     let sum = child_sum_ports.move_iter().fold(0, |sum, sum_port| sum + sum_port.recv() );\n "}]}