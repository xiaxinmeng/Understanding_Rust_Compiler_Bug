{"sha": "6516f9408ef47137e070c2635b9f4a67d848f129", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MTZmOTQwOGVmNDcxMzdlMDcwYzI2MzViOWY0YTY3ZDg0OGYxMjk=", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2021-03-17T18:41:01Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2021-04-17T16:21:52Z"}, "message": "rustdoc: use more precise relative URLS\n\nInstead of using a depth counter and adding \"../\" to get to the top,\nthis commit makes rustdoc actually compare the path of what it's\nlinking from to the path that it's linking to. This makes the resulting\nHTML shorter.\n\nHere's a comparison of one of the largest (non-source) files in the\nRust standard library docs (about 4% improvement before gzipping).\n\n    $ wc -c struct.Wrapping.old.html struct.Wrapping.new.html\n    2387389 struct.Wrapping.old.html\n    2298538 struct.Wrapping.new.html\n\nMost if it can be efficiently gzipped away.\n\n    $ wc -c struct.Wrapping.old.html.gz struct.Wrapping.new.html.gz\n    70679 struct.Wrapping.old.html.gz\n    70050 struct.Wrapping.new.html.gz\n\nBut it also makes a difference in the final DOM size, reducing it from 91MiB to 82MiB.", "tree": {"sha": "05ffb4e6bcbddf1048d40471d7a560eb907fd27d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05ffb4e6bcbddf1048d40471d7a560eb907fd27d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6516f9408ef47137e070c2635b9f4a67d848f129", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6516f9408ef47137e070c2635b9f4a67d848f129", "html_url": "https://github.com/rust-lang/rust/commit/6516f9408ef47137e070c2635b9f4a67d848f129", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6516f9408ef47137e070c2635b9f4a67d848f129/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03301ef1d8028dff1b07766dff14bfcafb309a85", "url": "https://api.github.com/repos/rust-lang/rust/commits/03301ef1d8028dff1b07766dff14bfcafb309a85", "html_url": "https://github.com/rust-lang/rust/commit/03301ef1d8028dff1b07766dff14bfcafb309a85"}], "stats": {"total": 1190, "additions": 613, "deletions": 577}, "files": [{"sha": "f5cd298dac4ff9fec55b9d179879cdd60bbc75e4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -2284,6 +2284,13 @@ impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n             let vis = item.vis.clean(cx);\n             let def_id = item.def_id.to_def_id();\n \n+            // Since this occurs in `clean()`, there are no cache entries for vis.print_with_space,\n+            // so no links can be made.\n+            //\n+            // It's important that we maintain this invariant, because this is supposed to generate\n+            // source code, not HTML.\n+            assert!(cx.cache.paths.is_empty());\n+\n             if matchers.len() <= 1 {\n                 format!(\n                     \"{}macro {}{} {{\\n    ...\\n}}\","}, {"sha": "2b25c6a26bcc4c8e18ec8fea81c0332874066336", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -41,6 +41,7 @@ use crate::core::DocContext;\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::render::cache::ExternalLocation;\n+use crate::html::render::Context;\n \n use self::FnRetTy::*;\n use self::ItemKind::*;\n@@ -193,19 +194,18 @@ impl Item {\n         self.attrs.collapsed_doc_value()\n     }\n \n-    crate fn links(&self, cache: &Cache) -> Vec<RenderedLink> {\n+    crate fn links(&self, cx: &Context<'_>) -> Vec<RenderedLink> {\n         use crate::html::format::href;\n-        use crate::html::render::CURRENT_DEPTH;\n \n-        cache\n+        cx.cache()\n             .intra_doc_links\n             .get(&self.def_id)\n             .map_or(&[][..], |v| v.as_slice())\n             .iter()\n-            .filter_map(|ItemLink { link: s, link_text, did, fragment }| {\n+            .filter_map(|ItemLink { link: s, link_text, did, ref fragment }| {\n                 match *did {\n                     Some(did) => {\n-                        if let Some((mut href, ..)) = href(did, cache) {\n+                        if let Some((mut href, ..)) = href(did, cx) {\n                             if let Some(ref fragment) = *fragment {\n                                 href.push('#');\n                                 href.push_str(fragment);\n@@ -219,16 +219,26 @@ impl Item {\n                             None\n                         }\n                     }\n+                    // FIXME(83083): using fragments as a side-channel for\n+                    // primitive names is very unfortunate\n                     None => {\n+                        let relative_to = &cx.current;\n                         if let Some(ref fragment) = *fragment {\n-                            let url = match cache.extern_locations.get(&self.def_id.krate) {\n+                            let url = match cx.cache().extern_locations.get(&self.def_id.krate) {\n                                 Some(&(_, _, ExternalLocation::Local)) => {\n-                                    let depth = CURRENT_DEPTH.with(|l| l.get());\n-                                    \"../\".repeat(depth)\n+                                    if relative_to[0] == \"std\" {\n+                                        let depth = relative_to.len() - 1;\n+                                        \"../\".repeat(depth)\n+                                    } else {\n+                                        let depth = relative_to.len();\n+                                        format!(\"{}std/\", \"../\".repeat(depth))\n+                                    }\n+                                }\n+                                Some(&(_, _, ExternalLocation::Remote(ref s))) => {\n+                                    format!(\"{}/std/\", s.trim_end_matches('/'))\n                                 }\n-                                Some(&(_, _, ExternalLocation::Remote(ref s))) => s.to_string(),\n                                 Some(&(_, _, ExternalLocation::Unknown)) | None => format!(\n-                                    \"https://doc.rust-lang.org/{}\",\n+                                    \"https://doc.rust-lang.org/{}/std/\",\n                                     crate::doc_rust_lang_org_channel(),\n                                 ),\n                             };\n@@ -238,9 +248,8 @@ impl Item {\n                                 original_text: s.clone(),\n                                 new_text: link_text.clone(),\n                                 href: format!(\n-                                    \"{}{}std/primitive.{}.html{}\",\n+                                    \"{}primitive.{}.html{}\",\n                                     url,\n-                                    if !url.ends_with('/') { \"/\" } else { \"\" },\n                                     &fragment[..tail],\n                                     &fragment[tail..]\n                                 ),"}, {"sha": "191f29f40e72e4fef07e1adf67952155b4cbcc26", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 253, "deletions": 264, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -20,6 +20,7 @@ use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n use crate::html::render::cache::ExternalLocation;\n+use crate::html::render::Context;\n use crate::html::render::CURRENT_DEPTH;\n \n crate trait Print {\n@@ -123,82 +124,79 @@ fn comma_sep<T: fmt::Display>(items: impl Iterator<Item = T>) -> impl fmt::Displ\n     })\n }\n \n-crate fn print_generic_bounds<'a, 'tcx: 'a>(\n+crate fn print_generic_bounds<'a, 'cx: 'a>(\n+    cx: &'a Context<'cx>,\n     bounds: &'a [clean::GenericBound],\n-    cache: &'a Cache,\n-    tcx: TyCtxt<'tcx>,\n-) -> impl fmt::Display + 'a + Captures<'tcx> {\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n     display_fn(move |f| {\n         let mut bounds_dup = FxHashSet::default();\n \n         for (i, bound) in\n-            bounds.iter().filter(|b| bounds_dup.insert(b.print(cache, tcx).to_string())).enumerate()\n+            bounds.iter().filter(|b| bounds_dup.insert(b.print(cx).to_string())).enumerate()\n         {\n             if i > 0 {\n                 f.write_str(\" + \")?;\n             }\n-            fmt::Display::fmt(&bound.print(cache, tcx), f)?;\n+            fmt::Display::fmt(&bound.print(cx), f)?;\n         }\n         Ok(())\n     })\n }\n \n impl clean::GenericParamDef {\n-    crate fn print<'a, 'tcx: 'a>(\n+    crate fn print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| match self.kind {\n             clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n             clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n                 f.write_str(&*self.name.as_str())?;\n \n                 if !bounds.is_empty() {\n                     if f.alternate() {\n-                        write!(f, \": {:#}\", print_generic_bounds(bounds, cache, tcx))?;\n+                        write!(f, \": {:#}\", print_generic_bounds(cx, bounds))?;\n                     } else {\n-                        write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cache, tcx))?;\n+                        write!(f, \":&nbsp;{}\", print_generic_bounds(cx, bounds))?;\n                     }\n                 }\n \n                 if let Some(ref ty) = default {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty.print(cache, tcx))?;\n+                        write!(f, \" = {:#}\", ty.print(cx))?;\n                     } else {\n-                        write!(f, \"&nbsp;=&nbsp;{}\", ty.print(cache, tcx))?;\n+                        write!(f, \"&nbsp;=&nbsp;{}\", ty.print(cx))?;\n                     }\n                 }\n \n                 Ok(())\n             }\n             clean::GenericParamDefKind::Const { ref ty, .. } => {\n                 if f.alternate() {\n-                    write!(f, \"const {}: {:#}\", self.name, ty.print(cache, tcx))\n+                    write!(f, \"const {}: {:#}\", self.name, ty.print(cx))\n                 } else {\n-                    write!(f, \"const {}:&nbsp;{}\", self.name, ty.print(cache, tcx))\n+                    write!(f, \"const {}:&nbsp;{}\", self.name, ty.print(cx))\n                 }\n             }\n         })\n     }\n }\n \n impl clean::Generics {\n-    crate fn print<'a, 'tcx: 'a>(\n+    crate fn print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| {\n             let real_params =\n                 self.params.iter().filter(|p| !p.is_synthetic_type_param()).collect::<Vec<_>>();\n             if real_params.is_empty() {\n                 return Ok(());\n             }\n             if f.alternate() {\n-                write!(f, \"<{:#}>\", comma_sep(real_params.iter().map(|g| g.print(cache, tcx))))\n+                write!(f, \"<{:#}>\", comma_sep(real_params.iter().map(|g| g.print(cx))))\n             } else {\n-                write!(f, \"&lt;{}&gt;\", comma_sep(real_params.iter().map(|g| g.print(cache, tcx))))\n+                write!(f, \"&lt;{}&gt;\", comma_sep(real_params.iter().map(|g| g.print(cx))))\n             }\n         })\n     }\n@@ -207,13 +205,12 @@ impl clean::Generics {\n /// * The Generics from which to emit a where-clause.\n /// * The number of spaces to indent each line with.\n /// * Whether the where-clause needs to add a comma and newline after the last bound.\n-crate fn print_where_clause<'a, 'tcx: 'a>(\n+crate fn print_where_clause<'a, 'cx: 'a>(\n     gens: &'a clean::Generics,\n-    cache: &'a Cache,\n-    tcx: TyCtxt<'tcx>,\n+    cx: &'a Context<'cx>,\n     indent: usize,\n     end_newline: bool,\n-) -> impl fmt::Display + 'a + Captures<'tcx> {\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n     display_fn(move |f| {\n         if gens.where_predicates.is_empty() {\n             return Ok(());\n@@ -241,14 +238,14 @@ crate fn print_where_clause<'a, 'tcx: 'a>(\n                     if f.alternate() {\n                         clause.push_str(&format!(\n                             \"{:#}: {:#}\",\n-                            ty.print(cache, tcx),\n-                            print_generic_bounds(bounds, cache, tcx)\n+                            ty.print(cx),\n+                            print_generic_bounds(cx, bounds)\n                         ));\n                     } else {\n                         clause.push_str(&format!(\n                             \"{}: {}\",\n-                            ty.print(cache, tcx),\n-                            print_generic_bounds(bounds, cache, tcx)\n+                            ty.print(cx),\n+                            print_generic_bounds(cx, bounds)\n                         ));\n                     }\n                 }\n@@ -258,24 +255,16 @@ crate fn print_where_clause<'a, 'tcx: 'a>(\n                         lifetime.print(),\n                         bounds\n                             .iter()\n-                            .map(|b| b.print(cache, tcx).to_string())\n+                            .map(|b| b.print(cx).to_string())\n                             .collect::<Vec<_>>()\n                             .join(\" + \")\n                     ));\n                 }\n                 clean::WherePredicate::EqPredicate { lhs, rhs } => {\n                     if f.alternate() {\n-                        clause.push_str(&format!(\n-                            \"{:#} == {:#}\",\n-                            lhs.print(cache, tcx),\n-                            rhs.print(cache, tcx),\n-                        ));\n+                        clause.push_str(&format!(\"{:#} == {:#}\", lhs.print(cx), rhs.print(cx),));\n                     } else {\n-                        clause.push_str(&format!(\n-                            \"{} == {}\",\n-                            lhs.print(cache, tcx),\n-                            rhs.print(cache, tcx),\n-                        ));\n+                        clause.push_str(&format!(\"{} == {}\", lhs.print(cx), rhs.print(cx),));\n                     }\n                 }\n             }\n@@ -325,42 +314,40 @@ impl clean::Constant {\n }\n \n impl clean::PolyTrait {\n-    fn print<'a, 'tcx: 'a>(\n+    fn print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| {\n             if !self.generic_params.is_empty() {\n                 if f.alternate() {\n                     write!(\n                         f,\n                         \"for<{:#}> \",\n-                        comma_sep(self.generic_params.iter().map(|g| g.print(cache, tcx)))\n+                        comma_sep(self.generic_params.iter().map(|g| g.print(cx)))\n                     )?;\n                 } else {\n                     write!(\n                         f,\n                         \"for&lt;{}&gt; \",\n-                        comma_sep(self.generic_params.iter().map(|g| g.print(cache, tcx)))\n+                        comma_sep(self.generic_params.iter().map(|g| g.print(cx)))\n                     )?;\n                 }\n             }\n             if f.alternate() {\n-                write!(f, \"{:#}\", self.trait_.print(cache, tcx))\n+                write!(f, \"{:#}\", self.trait_.print(cx))\n             } else {\n-                write!(f, \"{}\", self.trait_.print(cache, tcx))\n+                write!(f, \"{}\", self.trait_.print(cx))\n             }\n         })\n     }\n }\n \n impl clean::GenericBound {\n-    crate fn print<'a, 'tcx: 'a>(\n+    crate fn print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| match self {\n             clean::GenericBound::Outlives(lt) => write!(f, \"{}\", lt.print()),\n             clean::GenericBound::TraitBound(ty, modifier) => {\n@@ -370,21 +357,20 @@ impl clean::GenericBound {\n                     hir::TraitBoundModifier::MaybeConst => \"?const\",\n                 };\n                 if f.alternate() {\n-                    write!(f, \"{}{:#}\", modifier_str, ty.print(cache, tcx))\n+                    write!(f, \"{}{:#}\", modifier_str, ty.print(cx))\n                 } else {\n-                    write!(f, \"{}{}\", modifier_str, ty.print(cache, tcx))\n+                    write!(f, \"{}{}\", modifier_str, ty.print(cx))\n                 }\n             }\n         })\n     }\n }\n \n impl clean::GenericArgs {\n-    fn print<'a, 'tcx: 'a>(\n+    fn print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| {\n             match self {\n                 clean::GenericArgs::AngleBracketed { args, bindings } => {\n@@ -401,9 +387,9 @@ impl clean::GenericArgs {\n                             }\n                             comma = true;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", arg.print(cache, tcx))?;\n+                                write!(f, \"{:#}\", arg.print(cx))?;\n                             } else {\n-                                write!(f, \"{}\", arg.print(cache, tcx))?;\n+                                write!(f, \"{}\", arg.print(cx))?;\n                             }\n                         }\n                         for binding in bindings {\n@@ -412,9 +398,9 @@ impl clean::GenericArgs {\n                             }\n                             comma = true;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", binding.print(cache, tcx))?;\n+                                write!(f, \"{:#}\", binding.print(cx))?;\n                             } else {\n-                                write!(f, \"{}\", binding.print(cache, tcx))?;\n+                                write!(f, \"{}\", binding.print(cx))?;\n                             }\n                         }\n                         if f.alternate() {\n@@ -433,17 +419,17 @@ impl clean::GenericArgs {\n                         }\n                         comma = true;\n                         if f.alternate() {\n-                            write!(f, \"{:#}\", ty.print(cache, tcx))?;\n+                            write!(f, \"{:#}\", ty.print(cx))?;\n                         } else {\n-                            write!(f, \"{}\", ty.print(cache, tcx))?;\n+                            write!(f, \"{}\", ty.print(cx))?;\n                         }\n                     }\n                     f.write_str(\")\")?;\n                     if let Some(ref ty) = *output {\n                         if f.alternate() {\n-                            write!(f, \" -> {:#}\", ty.print(cache, tcx))?;\n+                            write!(f, \" -> {:#}\", ty.print(cx))?;\n                         } else {\n-                            write!(f, \" -&gt; {}\", ty.print(cache, tcx))?;\n+                            write!(f, \" -&gt; {}\", ty.print(cx))?;\n                         }\n                     }\n                 }\n@@ -453,56 +439,89 @@ impl clean::GenericArgs {\n     }\n }\n \n-crate fn href(did: DefId, cache: &Cache) -> Option<(String, ItemType, Vec<String>)> {\n+crate fn href(did: DefId, cx: &Context<'_>) -> Option<(String, ItemType, Vec<String>)> {\n+    let cache = &cx.cache();\n+    let relative_to = &cx.current;\n+    fn to_module_fqp(shortty: ItemType, fqp: &[String]) -> &[String] {\n+        if shortty == ItemType::Module { &fqp[..] } else { &fqp[..fqp.len() - 1] }\n+    }\n+\n     if !did.is_local() && !cache.access_levels.is_public(did) && !cache.document_private {\n         return None;\n     }\n \n-    let depth = CURRENT_DEPTH.with(|l| l.get());\n-    let (fqp, shortty, mut url) = match cache.paths.get(&did) {\n-        Some(&(ref fqp, shortty)) => (fqp, shortty, \"../\".repeat(depth)),\n+    let (fqp, shortty, mut url_parts) = match cache.paths.get(&did) {\n+        Some(&(ref fqp, shortty)) => (fqp, shortty, {\n+            let module_fqp = to_module_fqp(shortty, fqp);\n+            href_relative_parts(module_fqp, relative_to)\n+        }),\n         None => {\n             let &(ref fqp, shortty) = cache.external_paths.get(&did)?;\n+            let module_fqp = to_module_fqp(shortty, fqp);\n             (\n                 fqp,\n                 shortty,\n                 match cache.extern_locations[&did.krate] {\n-                    (.., ExternalLocation::Remote(ref s)) => s.to_string(),\n-                    (.., ExternalLocation::Local) => \"../\".repeat(depth),\n+                    (.., ExternalLocation::Remote(ref s)) => {\n+                        let s = s.trim_end_matches('/');\n+                        let mut s = vec![&s[..]];\n+                        s.extend(module_fqp[..].iter().map(String::as_str));\n+                        s\n+                    }\n+                    (.., ExternalLocation::Local) => href_relative_parts(module_fqp, relative_to),\n                     (.., ExternalLocation::Unknown) => return None,\n                 },\n             )\n         }\n     };\n-    for component in &fqp[..fqp.len() - 1] {\n-        url.push_str(component);\n-        url.push('/');\n-    }\n+    let last = &fqp.last().unwrap()[..];\n+    let filename;\n     match shortty {\n         ItemType::Module => {\n-            url.push_str(fqp.last().unwrap());\n-            url.push_str(\"/index.html\");\n+            url_parts.push(\"index.html\");\n         }\n         _ => {\n-            url.push_str(shortty.as_str());\n-            url.push('.');\n-            url.push_str(fqp.last().unwrap());\n-            url.push_str(\".html\");\n+            filename = format!(\"{}.{}.html\", shortty.as_str(), last);\n+            url_parts.push(&filename);\n+        }\n+    }\n+    Some((url_parts.join(\"/\"), shortty, fqp.to_vec()))\n+}\n+\n+/// Both paths should only be modules.\n+/// This is because modules get their own directories; that is, `std::vec` and `std::vec::Vec` will\n+/// both need `../iter/trait.Iterator.html` to get at the iterator trait.\n+crate fn href_relative_parts<'a>(fqp: &'a [String], relative_to_fqp: &'a [String]) -> Vec<&'a str> {\n+    for (i, (f, r)) in fqp.iter().zip(relative_to_fqp.iter()).enumerate() {\n+        // e.g. linking to std::iter from std::vec (`dissimilar_part_count` will be 1)\n+        if f != r {\n+            let dissimilar_part_count = relative_to_fqp.len() - i;\n+            let fqp_module = fqp[i..fqp.len()].iter().map(String::as_str);\n+            return std::iter::repeat(\"..\").take(dissimilar_part_count).chain(fqp_module).collect();\n         }\n     }\n-    Some((url, shortty, fqp.to_vec()))\n+    // e.g. linking to std::sync::atomic from std::sync\n+    if relative_to_fqp.len() < fqp.len() {\n+        fqp[relative_to_fqp.len()..fqp.len()].iter().map(String::as_str).collect()\n+    // e.g. linking to std::sync from std::sync::atomic\n+    } else if fqp.len() < relative_to_fqp.len() {\n+        let dissimilar_part_count = relative_to_fqp.len() - fqp.len();\n+        std::iter::repeat(\"..\").take(dissimilar_part_count).collect()\n+    // linking to the same module\n+    } else {\n+        Vec::new()\n+    }\n }\n \n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n-fn resolved_path<'a, 'tcx: 'a>(\n+fn resolved_path<'a, 'cx: 'a>(\n     w: &mut fmt::Formatter<'_>,\n     did: DefId,\n     path: &clean::Path,\n     print_all: bool,\n     use_absolute: bool,\n-    cache: &Cache,\n-    tcx: TyCtxt<'tcx>,\n+    cx: &'cx Context<'_>,\n ) -> fmt::Result {\n     let last = path.segments.last().unwrap();\n \n@@ -512,22 +531,22 @@ fn resolved_path<'a, 'tcx: 'a>(\n         }\n     }\n     if w.alternate() {\n-        write!(w, \"{}{:#}\", &last.name, last.args.print(cache, tcx))?;\n+        write!(w, \"{}{:#}\", &last.name, last.args.print(cx))?;\n     } else {\n         let path = if use_absolute {\n-            if let Some((_, _, fqp)) = href(did, cache) {\n+            if let Some((_, _, fqp)) = href(did, cx) {\n                 format!(\n                     \"{}::{}\",\n                     fqp[..fqp.len() - 1].join(\"::\"),\n-                    anchor(did, fqp.last().unwrap(), cache)\n+                    anchor(did, fqp.last().unwrap(), cx)\n                 )\n             } else {\n                 last.name.to_string()\n             }\n         } else {\n-            anchor(did, &*last.name.as_str(), cache).to_string()\n+            anchor(did, &*last.name.as_str(), cx).to_string()\n         };\n-        write!(w, \"{}{}\", path, last.args.print(cache, tcx))?;\n+        write!(w, \"{}{}\", path, last.args.print(cx))?;\n     }\n     Ok(())\n }\n@@ -583,26 +602,30 @@ fn primitive_link(\n }\n \n /// Helper to render type parameters\n-fn tybounds<'a, 'tcx: 'a>(\n+fn tybounds<'a, 'cx: 'a>(\n     param_names: &'a Option<Vec<clean::GenericBound>>,\n-    cache: &'a Cache,\n-    tcx: TyCtxt<'tcx>,\n-) -> impl fmt::Display + 'a + Captures<'tcx> {\n+    cx: &'a Context<'cx>,\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n     display_fn(move |f| match *param_names {\n         Some(ref params) => {\n             for param in params {\n                 write!(f, \" + \")?;\n-                fmt::Display::fmt(&param.print(cache, tcx), f)?;\n+                fmt::Display::fmt(&param.print(cx), f)?;\n             }\n             Ok(())\n         }\n         None => Ok(()),\n     })\n }\n \n-crate fn anchor<'a>(did: DefId, text: &'a str, cache: &'a Cache) -> impl fmt::Display + 'a {\n+crate fn anchor<'a, 'cx: 'a>(\n+    did: DefId,\n+    text: &'a str,\n+    cx: &'cx Context<'_>,\n+) -> impl fmt::Display + 'a {\n+    let parts = href(did, cx);\n     display_fn(move |f| {\n-        if let Some((url, short_ty, fqp)) = href(did, cache) {\n+        if let Some((url, short_ty, fqp)) = parts {\n             write!(\n                 f,\n                 r#\"<a class=\"{}\" href=\"{}\" title=\"{} {}\">{}</a>\"#,\n@@ -618,12 +641,11 @@ crate fn anchor<'a>(did: DefId, text: &'a str, cache: &'a Cache) -> impl fmt::Di\n     })\n }\n \n-fn fmt_type(\n+fn fmt_type<'cx>(\n     t: &clean::Type,\n     f: &mut fmt::Formatter<'_>,\n     use_absolute: bool,\n-    cache: &Cache,\n-    tcx: TyCtxt<'_>,\n+    cx: &'cx Context<'_>,\n ) -> fmt::Result {\n     debug!(\"fmt_type(t = {:?})\", t);\n \n@@ -634,69 +656,69 @@ fn fmt_type(\n                 f.write_str(\"dyn \")?;\n             }\n             // Paths like `T::Output` and `Self::Output` should be rendered with all segments.\n-            resolved_path(f, did, path, is_generic, use_absolute, cache, tcx)?;\n-            fmt::Display::fmt(&tybounds(param_names, cache, tcx), f)\n+            resolved_path(f, did, path, is_generic, use_absolute, cx)?;\n+            fmt::Display::fmt(&tybounds(param_names, cx), f)\n         }\n         clean::Infer => write!(f, \"_\"),\n-        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str(), cache),\n+        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str(), &cx.cache()),\n         clean::BareFunction(ref decl) => {\n             if f.alternate() {\n                 write!(\n                     f,\n                     \"{:#}{}{:#}fn{:#}\",\n-                    decl.print_hrtb_with_space(cache, tcx),\n+                    decl.print_hrtb_with_space(cx),\n                     decl.unsafety.print_with_space(),\n                     print_abi_with_space(decl.abi),\n-                    decl.decl.print(cache, tcx),\n+                    decl.decl.print(cx),\n                 )\n             } else {\n                 write!(\n                     f,\n                     \"{}{}{}\",\n-                    decl.print_hrtb_with_space(cache, tcx),\n+                    decl.print_hrtb_with_space(cx),\n                     decl.unsafety.print_with_space(),\n                     print_abi_with_space(decl.abi)\n                 )?;\n-                primitive_link(f, PrimitiveType::Fn, \"fn\", cache)?;\n-                write!(f, \"{}\", decl.decl.print(cache, tcx))\n+                primitive_link(f, PrimitiveType::Fn, \"fn\", &cx.cache())?;\n+                write!(f, \"{}\", decl.decl.print(cx))\n             }\n         }\n         clean::Tuple(ref typs) => {\n             match &typs[..] {\n-                &[] => primitive_link(f, PrimitiveType::Unit, \"()\", cache),\n+                &[] => primitive_link(f, PrimitiveType::Unit, \"()\", &cx.cache()),\n                 &[ref one] => {\n-                    primitive_link(f, PrimitiveType::Tuple, \"(\", cache)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\", &cx.cache())?;\n                     // Carry `f.alternate()` into this display w/o branching manually.\n-                    fmt::Display::fmt(&one.print(cache, tcx), f)?;\n-                    primitive_link(f, PrimitiveType::Tuple, \",)\", cache)\n+                    fmt::Display::fmt(&one.print(cx), f)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \",)\", &cx.cache())\n                 }\n                 many => {\n-                    primitive_link(f, PrimitiveType::Tuple, \"(\", cache)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\", &cx.cache())?;\n                     for (i, item) in many.iter().enumerate() {\n                         if i != 0 {\n                             write!(f, \", \")?;\n                         }\n-                        fmt::Display::fmt(&item.print(cache, tcx), f)?;\n+                        fmt::Display::fmt(&item.print(cx), f)?;\n                     }\n-                    primitive_link(f, PrimitiveType::Tuple, \")\", cache)\n+                    primitive_link(f, PrimitiveType::Tuple, \")\", &cx.cache())\n                 }\n             }\n         }\n         clean::Slice(ref t) => {\n-            primitive_link(f, PrimitiveType::Slice, \"[\", cache)?;\n-            fmt::Display::fmt(&t.print(cache, tcx), f)?;\n-            primitive_link(f, PrimitiveType::Slice, \"]\", cache)\n+            primitive_link(f, PrimitiveType::Slice, \"[\", &cx.cache())?;\n+            fmt::Display::fmt(&t.print(cx), f)?;\n+            primitive_link(f, PrimitiveType::Slice, \"]\", &cx.cache())\n         }\n         clean::Array(ref t, ref n) => {\n-            primitive_link(f, PrimitiveType::Array, \"[\", cache)?;\n-            fmt::Display::fmt(&t.print(cache, tcx), f)?;\n+            primitive_link(f, PrimitiveType::Array, \"[\", &cx.cache())?;\n+            fmt::Display::fmt(&t.print(cx), f)?;\n             if f.alternate() {\n-                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n), cache)\n+                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n), &cx.cache())\n             } else {\n-                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", Escape(n)), cache)\n+                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", Escape(n)), &cx.cache())\n             }\n         }\n-        clean::Never => primitive_link(f, PrimitiveType::Never, \"!\", cache),\n+        clean::Never => primitive_link(f, PrimitiveType::Never, \"!\", &cx.cache()),\n         clean::RawPointer(m, ref t) => {\n             let m = match m {\n                 hir::Mutability::Mut => \"mut\",\n@@ -708,15 +730,15 @@ fn fmt_type(\n                         primitive_link(\n                             f,\n                             clean::PrimitiveType::RawPointer,\n-                            &format!(\"*{} {:#}\", m, t.print(cache, tcx)),\n-                            cache,\n+                            &format!(\"*{} {:#}\", m, t.print(cx)),\n+                            &cx.cache(),\n                         )\n                     } else {\n                         primitive_link(\n                             f,\n                             clean::PrimitiveType::RawPointer,\n-                            &format!(\"*{} {}\", m, t.print(cache, tcx)),\n-                            cache,\n+                            &format!(\"*{} {}\", m, t.print(cx)),\n+                            &cx.cache(),\n                         )\n                     }\n                 }\n@@ -725,9 +747,9 @@ fn fmt_type(\n                         f,\n                         clean::PrimitiveType::RawPointer,\n                         &format!(\"*{} \", m),\n-                        cache,\n+                        &cx.cache(),\n                     )?;\n-                    fmt::Display::fmt(&t.print(cache, tcx), f)\n+                    fmt::Display::fmt(&t.print(cx), f)\n                 }\n             }\n         }\n@@ -747,15 +769,15 @@ fn fmt_type(\n                                 primitive_link(\n                                     f,\n                                     PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, bt.print(cache, tcx)),\n-                                    cache,\n+                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, bt.print(cx)),\n+                                    &cx.cache(),\n                                 )\n                             } else {\n                                 primitive_link(\n                                     f,\n                                     PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{}]\", amp, lt, m, bt.print(cache, tcx)),\n-                                    cache,\n+                                    &format!(\"{}{}{}[{}]\", amp, lt, m, bt.print(cx)),\n+                                    &cx.cache(),\n                                 )\n                             }\n                         }\n@@ -764,42 +786,42 @@ fn fmt_type(\n                                 f,\n                                 PrimitiveType::Slice,\n                                 &format!(\"{}{}{}[\", amp, lt, m),\n-                                cache,\n+                                &cx.cache(),\n                             )?;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", bt.print(cache, tcx))?;\n+                                write!(f, \"{:#}\", bt.print(cx))?;\n                             } else {\n-                                write!(f, \"{}\", bt.print(cache, tcx))?;\n+                                write!(f, \"{}\", bt.print(cx))?;\n                             }\n-                            primitive_link(f, PrimitiveType::Slice, \"]\", cache)\n+                            primitive_link(f, PrimitiveType::Slice, \"]\", &cx.cache())\n                         }\n                     }\n                 }\n                 clean::ResolvedPath { param_names: Some(ref v), .. } if !v.is_empty() => {\n                     write!(f, \"{}{}{}(\", amp, lt, m)?;\n-                    fmt_type(&ty, f, use_absolute, cache, tcx)?;\n+                    fmt_type(&ty, f, use_absolute, cx)?;\n                     write!(f, \")\")\n                 }\n                 clean::Generic(..) => {\n                     primitive_link(\n                         f,\n                         PrimitiveType::Reference,\n                         &format!(\"{}{}{}\", amp, lt, m),\n-                        cache,\n+                        &cx.cache(),\n                     )?;\n-                    fmt_type(&ty, f, use_absolute, cache, tcx)\n+                    fmt_type(&ty, f, use_absolute, cx)\n                 }\n                 _ => {\n                     write!(f, \"{}{}{}\", amp, lt, m)?;\n-                    fmt_type(&ty, f, use_absolute, cache, tcx)\n+                    fmt_type(&ty, f, use_absolute, cx)\n                 }\n             }\n         }\n         clean::ImplTrait(ref bounds) => {\n             if f.alternate() {\n-                write!(f, \"impl {:#}\", print_generic_bounds(bounds, cache, tcx))\n+                write!(f, \"impl {:#}\", print_generic_bounds(cx, bounds))\n             } else {\n-                write!(f, \"impl {}\", print_generic_bounds(bounds, cache, tcx))\n+                write!(f, \"impl {}\", print_generic_bounds(cx, bounds))\n             }\n         }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n@@ -811,25 +833,15 @@ fn fmt_type(\n             };\n             if f.alternate() {\n                 if should_show_cast {\n-                    write!(\n-                        f,\n-                        \"<{:#} as {:#}>::\",\n-                        self_type.print(cache, tcx),\n-                        trait_.print(cache, tcx)\n-                    )?\n+                    write!(f, \"<{:#} as {:#}>::\", self_type.print(cx), trait_.print(cx))?\n                 } else {\n-                    write!(f, \"{:#}::\", self_type.print(cache, tcx))?\n+                    write!(f, \"{:#}::\", self_type.print(cx))?\n                 }\n             } else {\n                 if should_show_cast {\n-                    write!(\n-                        f,\n-                        \"&lt;{} as {}&gt;::\",\n-                        self_type.print(cache, tcx),\n-                        trait_.print(cache, tcx)\n-                    )?\n+                    write!(f, \"&lt;{} as {}&gt;::\", self_type.print(cx), trait_.print(cx))?\n                 } else {\n-                    write!(f, \"{}::\", self_type.print(cache, tcx))?\n+                    write!(f, \"{}::\", self_type.print(cx))?\n                 }\n             };\n             match *trait_ {\n@@ -844,7 +856,7 @@ fn fmt_type(\n                 //        everything comes in as a fully resolved QPath (hard to\n                 //        look at).\n                 box clean::ResolvedPath { did, ref param_names, .. } => {\n-                    match href(did, cache) {\n+                    match href(did, cx) {\n                         Some((ref url, _, ref path)) if !f.alternate() => {\n                             write!(\n                                 f,\n@@ -870,64 +882,61 @@ fn fmt_type(\n }\n \n impl clean::Type {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    crate fn print<'b, 'a: 'b, 'cx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n-        display_fn(move |f| fmt_type(self, f, false, cache, tcx))\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'b + Captures<'cx> {\n+        display_fn(move |f| fmt_type(self, f, false, cx))\n     }\n }\n \n impl clean::Impl {\n-    crate fn print<'a, 'tcx: 'a>(\n+    crate fn print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n         use_absolute: bool,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| {\n             if f.alternate() {\n-                write!(f, \"impl{:#} \", self.generics.print(cache, tcx))?;\n+                write!(f, \"impl{:#} \", self.generics.print(cx))?;\n             } else {\n-                write!(f, \"impl{} \", self.generics.print(cache, tcx))?;\n+                write!(f, \"impl{} \", self.generics.print(cx))?;\n             }\n \n             if let Some(ref ty) = self.trait_ {\n                 if self.negative_polarity {\n                     write!(f, \"!\")?;\n                 }\n-                fmt::Display::fmt(&ty.print(cache, tcx), f)?;\n+                fmt::Display::fmt(&ty.print(cx), f)?;\n                 write!(f, \" for \")?;\n             }\n \n             if let Some(ref ty) = self.blanket_impl {\n-                fmt_type(ty, f, use_absolute, cache, tcx)?;\n+                fmt_type(ty, f, use_absolute, cx)?;\n             } else {\n-                fmt_type(&self.for_, f, use_absolute, cache, tcx)?;\n+                fmt_type(&self.for_, f, use_absolute, cx)?;\n             }\n \n-            fmt::Display::fmt(&print_where_clause(&self.generics, cache, tcx, 0, true), f)?;\n+            fmt::Display::fmt(&print_where_clause(&self.generics, cx, 0, true), f)?;\n             Ok(())\n         })\n     }\n }\n \n impl clean::Arguments {\n-    crate fn print<'a, 'tcx: 'a>(\n+    crate fn print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| {\n             for (i, input) in self.values.iter().enumerate() {\n                 if !input.name.is_empty() {\n                     write!(f, \"{}: \", input.name)?;\n                 }\n                 if f.alternate() {\n-                    write!(f, \"{:#}\", input.type_.print(cache, tcx))?;\n+                    write!(f, \"{:#}\", input.type_.print(cx))?;\n                 } else {\n-                    write!(f, \"{}\", input.type_.print(cache, tcx))?;\n+                    write!(f, \"{}\", input.type_.print(cx))?;\n                 }\n                 if i + 1 < self.values.len() {\n                     write!(f, \", \")?;\n@@ -939,33 +948,29 @@ impl clean::Arguments {\n }\n \n impl clean::FnRetTy {\n-    crate fn print<'a, 'tcx: 'a>(\n+    crate fn print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| match self {\n             clean::Return(clean::Tuple(tys)) if tys.is_empty() => Ok(()),\n-            clean::Return(ty) if f.alternate() => write!(f, \" -> {:#}\", ty.print(cache, tcx)),\n-            clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print(cache, tcx)),\n+            clean::Return(ty) if f.alternate() => {\n+                write!(f, \" -> {:#}\", ty.print(cx))\n+            }\n+            clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print(cx)),\n             clean::DefaultReturn => Ok(()),\n         })\n     }\n }\n \n impl clean::BareFunctionDecl {\n-    fn print_hrtb_with_space<'a, 'tcx: 'a>(\n+    fn print_hrtb_with_space<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'a Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| {\n             if !self.generic_params.is_empty() {\n-                write!(\n-                    f,\n-                    \"for<{}> \",\n-                    comma_sep(self.generic_params.iter().map(|g| g.print(cache, tcx)))\n-                )\n+                write!(f, \"for<{}> \", comma_sep(self.generic_params.iter().map(|g| g.print(cx))))\n             } else {\n                 Ok(())\n             }\n@@ -974,28 +979,27 @@ impl clean::BareFunctionDecl {\n }\n \n impl clean::FnDecl {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    crate fn print<'b, 'a: 'b, 'cx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'b + Captures<'cx> {\n         display_fn(move |f| {\n             let ellipsis = if self.c_variadic { \", ...\" } else { \"\" };\n             if f.alternate() {\n                 write!(\n                     f,\n                     \"({args:#}{ellipsis}){arrow:#}\",\n-                    args = self.inputs.print(cache, tcx),\n+                    args = self.inputs.print(cx),\n                     ellipsis = ellipsis,\n-                    arrow = self.output.print(cache, tcx)\n+                    arrow = self.output.print(cx)\n                 )\n             } else {\n                 write!(\n                     f,\n                     \"({args}{ellipsis}){arrow}\",\n-                    args = self.inputs.print(cache, tcx),\n+                    args = self.inputs.print(cx),\n                     ellipsis = ellipsis,\n-                    arrow = self.output.print(cache, tcx)\n+                    arrow = self.output.print(cx)\n                 )\n             }\n         })\n@@ -1007,21 +1011,19 @@ impl clean::FnDecl {\n     /// * `indent`: The number of spaces to indent each successive line with, if line-wrapping is\n     ///   necessary.\n     /// * `asyncness`: Whether the function is async or not.\n-    crate fn full_print<'b, 'a: 'b, 'tcx: 'a>(\n+    crate fn full_print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'cx>,\n         header_len: usize,\n         indent: usize,\n         asyncness: hir::IsAsync,\n-    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n-        display_fn(move |f| self.inner_full_print(cache, tcx, header_len, indent, asyncness, f))\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        display_fn(move |f| self.inner_full_print(cx, header_len, indent, asyncness, f))\n     }\n \n     fn inner_full_print(\n         &self,\n-        cache: &Cache,\n-        tcx: TyCtxt<'_>,\n+        cx: &Context<'_>,\n         header_len: usize,\n         indent: usize,\n         asyncness: hir::IsAsync,\n@@ -1060,11 +1062,11 @@ impl clean::FnDecl {\n                     }\n                     clean::SelfExplicit(ref typ) => {\n                         if f.alternate() {\n-                            args.push_str(&format!(\"self: {:#}\", typ.print(cache, tcx)));\n+                            args.push_str(&format!(\"self: {:#}\", typ.print(cx)));\n                         } else {\n-                            args.push_str(&format!(\"self: {}\", typ.print(cache, tcx)));\n+                            args.push_str(&format!(\"self: {}\", typ.print(cx)));\n                         }\n-                        args_plain.push_str(&format!(\"self: {:#}\", typ.print(cache, tcx)));\n+                        args_plain.push_str(&format!(\"self: {:#}\", typ.print(cx)));\n                     }\n                 }\n             } else {\n@@ -1078,11 +1080,11 @@ impl clean::FnDecl {\n                 }\n \n                 if f.alternate() {\n-                    args.push_str(&format!(\"{:#}\", input.type_.print(cache, tcx)));\n+                    args.push_str(&format!(\"{:#}\", input.type_.print(cx)));\n                 } else {\n-                    args.push_str(&input.type_.print(cache, tcx).to_string());\n+                    args.push_str(&input.type_.print(cx).to_string());\n                 }\n-                args_plain.push_str(&format!(\"{:#}\", input.type_.print(cache, tcx)));\n+                args_plain.push_str(&format!(\"{:#}\", input.type_.print(cx)));\n             }\n             if i + 1 < self.inputs.values.len() {\n                 args.push(',');\n@@ -1100,19 +1102,11 @@ impl clean::FnDecl {\n         let arrow_plain;\n         let arrow = if let hir::IsAsync::Async = asyncness {\n             let output = self.sugared_async_return_type();\n-            arrow_plain = format!(\"{:#}\", output.print(cache, tcx));\n-            if f.alternate() {\n-                arrow_plain.clone()\n-            } else {\n-                format!(\"{}\", output.print(cache, tcx))\n-            }\n+            arrow_plain = format!(\"{:#}\", output.print(cx));\n+            if f.alternate() { arrow_plain.clone() } else { format!(\"{}\", output.print(cx)) }\n         } else {\n-            arrow_plain = format!(\"{:#}\", self.output.print(cache, tcx));\n-            if f.alternate() {\n-                arrow_plain.clone()\n-            } else {\n-                format!(\"{}\", self.output.print(cache, tcx))\n-            }\n+            arrow_plain = format!(\"{:#}\", self.output.print(cx));\n+            if f.alternate() { arrow_plain.clone() } else { format!(\"{}\", self.output.print(cx)) }\n         };\n \n         let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n@@ -1138,20 +1132,19 @@ impl clean::FnDecl {\n }\n \n impl clean::Visibility {\n-    crate fn print_with_space<'a, 'tcx: 'a>(\n+    crate fn print_with_space<'a, 'cx: 'a>(\n         self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &'a Context<'cx>,\n         item_did: DefId,\n-        cache: &'a Cache,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         let to_print = match self {\n             clean::Public => \"pub \".to_owned(),\n             clean::Inherited => String::new(),\n             clean::Visibility::Restricted(vis_did) => {\n                 // FIXME(camelid): This may not work correctly if `item_did` is a module.\n                 //                 However, rustdoc currently never displays a module's\n                 //                 visibility, so it shouldn't matter.\n-                let parent_module = find_nearest_parent_module(tcx, item_did);\n+                let parent_module = find_nearest_parent_module(cx.tcx(), item_did);\n \n                 if vis_did.index == CRATE_DEF_INDEX {\n                     \"pub(crate) \".to_owned()\n@@ -1160,17 +1153,17 @@ impl clean::Visibility {\n                     // is the same as no visibility modifier\n                     String::new()\n                 } else if parent_module\n-                    .map(|parent| find_nearest_parent_module(tcx, parent))\n+                    .map(|parent| find_nearest_parent_module(cx.tcx(), parent))\n                     .flatten()\n                     == Some(vis_did)\n                 {\n                     \"pub(super) \".to_owned()\n                 } else {\n-                    let path = tcx.def_path(vis_did);\n+                    let path = cx.tcx().def_path(vis_did);\n                     debug!(\"path={:?}\", path);\n                     // modified from `resolved_path()` to work with `DefPathData`\n                     let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n-                    let anchor = anchor(vis_did, &last_name.as_str(), cache).to_string();\n+                    let anchor = anchor(vis_did, &last_name.as_str(), cx).to_string();\n \n                     let mut s = \"pub(in \".to_owned();\n                     for seg in &path.data[..path.data.len() - 1] {\n@@ -1263,45 +1256,43 @@ impl PrintWithSpace for hir::Mutability {\n }\n \n impl clean::Import {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    crate fn print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| match self.kind {\n             clean::ImportKind::Simple(name) => {\n                 if name == self.source.path.last() {\n-                    write!(f, \"use {};\", self.source.print(cache, tcx))\n+                    write!(f, \"use {};\", self.source.print(cx))\n                 } else {\n-                    write!(f, \"use {} as {};\", self.source.print(cache, tcx), name)\n+                    write!(f, \"use {} as {};\", self.source.print(cx), name)\n                 }\n             }\n             clean::ImportKind::Glob => {\n                 if self.source.path.segments.is_empty() {\n                     write!(f, \"use *;\")\n                 } else {\n-                    write!(f, \"use {}::*;\", self.source.print(cache, tcx))\n+                    write!(f, \"use {}::*;\", self.source.print(cx))\n                 }\n             }\n         })\n     }\n }\n \n impl clean::ImportSource {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    crate fn print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| match self.did {\n-            Some(did) => resolved_path(f, did, &self.path, true, false, cache, tcx),\n+            Some(did) => resolved_path(f, did, &self.path, true, false, cx),\n             _ => {\n                 for seg in &self.path.segments[..self.path.segments.len() - 1] {\n                     write!(f, \"{}::\", seg.name)?;\n                 }\n                 let name = self.path.last_name();\n                 if let hir::def::Res::PrimTy(p) = self.path.res {\n-                    primitive_link(f, PrimitiveType::from(p), &*name, cache)?;\n+                    primitive_link(f, PrimitiveType::from(p), &*name, &cx.cache())?;\n                 } else {\n                     write!(f, \"{}\", name)?;\n                 }\n@@ -1312,27 +1303,26 @@ impl clean::ImportSource {\n }\n \n impl clean::TypeBinding {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    crate fn print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| {\n             f.write_str(&*self.name.as_str())?;\n             match self.kind {\n                 clean::TypeBindingKind::Equality { ref ty } => {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty.print(cache, tcx))?;\n+                        write!(f, \" = {:#}\", ty.print(cx))?;\n                     } else {\n-                        write!(f, \" = {}\", ty.print(cache, tcx))?;\n+                        write!(f, \" = {}\", ty.print(cx))?;\n                     }\n                 }\n                 clean::TypeBindingKind::Constraint { ref bounds } => {\n                     if !bounds.is_empty() {\n                         if f.alternate() {\n-                            write!(f, \": {:#}\", print_generic_bounds(bounds, cache, tcx))?;\n+                            write!(f, \": {:#}\", print_generic_bounds(cx, bounds))?;\n                         } else {\n-                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cache, tcx))?;\n+                            write!(f, \":&nbsp;{}\", print_generic_bounds(cx, bounds))?;\n                         }\n                     }\n                 }\n@@ -1357,15 +1347,14 @@ crate fn print_default_space<'a>(v: bool) -> &'a str {\n }\n \n impl clean::GenericArg {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    crate fn print<'a, 'cx: 'a>(\n         &'a self,\n-        cache: &'b Cache,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n+        cx: &'a Context<'cx>,\n+    ) -> impl fmt::Display + 'a + Captures<'cx> {\n         display_fn(move |f| match self {\n             clean::GenericArg::Lifetime(lt) => fmt::Display::fmt(&lt.print(), f),\n-            clean::GenericArg::Type(ty) => fmt::Display::fmt(&ty.print(cache, tcx), f),\n-            clean::GenericArg::Const(ct) => fmt::Display::fmt(&ct.print(tcx), f),\n+            clean::GenericArg::Type(ty) => fmt::Display::fmt(&ty.print(cx), f),\n+            clean::GenericArg::Const(ct) => fmt::Display::fmt(&ct.print(cx.tcx()), f),\n         })\n     }\n }"}, {"sha": "60ebdf5690d0d2aa9fffa476f38826a454767545", "filename": "src/librustdoc/html/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -8,3 +8,6 @@ crate mod render;\n crate mod sources;\n crate mod static_files;\n crate mod toc;\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "d866cf4f4cf046dc9c7255fb2187aa89569e56da", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -40,7 +40,7 @@ use crate::html::{layout, sources};\n crate struct Context<'tcx> {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n-    pub(super) current: Vec<String>,\n+    pub(crate) current: Vec<String>,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n     pub(super) dst: PathBuf,\n@@ -144,10 +144,14 @@ impl SharedContext<'_> {\n }\n \n impl<'tcx> Context<'tcx> {\n-    pub(super) fn tcx(&self) -> TyCtxt<'tcx> {\n+    pub(crate) fn tcx(&self) -> TyCtxt<'tcx> {\n         self.shared.tcx\n     }\n \n+    pub(crate) fn cache(&self) -> &Cache {\n+        &self.cache\n+    }\n+\n     fn sess(&self) -> &'tcx Session {\n         &self.shared.tcx.sess\n     }"}, {"sha": "9bd4f57051c87f0cd0c5d10d97041dac0b860a3a", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 58, "deletions": 87, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -51,7 +51,6 @@ use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Mutability;\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{kw, sym, Symbol};\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n@@ -61,7 +60,7 @@ use crate::docfs::PathError;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n-use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n+use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n     href, print_abi_with_space, print_default_space, print_generic_bounds, print_where_clause,\n@@ -560,11 +559,10 @@ fn document_short(\n         return;\n     }\n     if let Some(s) = item.doc_value() {\n-        let mut summary_html = MarkdownSummaryLine(&s, &item.links(&cx.cache)).into_string();\n+        let mut summary_html = MarkdownSummaryLine(&s, &item.links(cx)).into_string();\n \n         if s.contains('\\n') {\n-            let link =\n-                format!(r#\" <a href=\"{}\">Read more</a>\"#, naive_assoc_href(item, link, cx.cache()));\n+            let link = format!(r#\" <a href=\"{}\">Read more</a>\"#, naive_assoc_href(item, link, cx));\n \n             if let Some(idx) = summary_html.rfind(\"</p>\") {\n                 summary_html.insert_str(idx, &link);\n@@ -599,7 +597,7 @@ fn document_full(\n ) {\n     if let Some(s) = cx.shared.maybe_collapsed_doc_value(item) {\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n-        render_markdown(w, cx, &*s, item.links(&cx.cache), prefix, is_hidden);\n+        render_markdown(w, cx, &*s, item.links(cx), prefix, is_hidden);\n     } else if !prefix.is_empty() {\n         if is_hidden {\n             w.write_str(\"<div class=\\\"docblock hidden\\\">\");\n@@ -785,7 +783,7 @@ fn render_impls(\n     w.write_str(&impls.join(\"\"));\n }\n \n-fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cache: &Cache) -> String {\n+fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cx: &Context<'_>) -> String {\n     use crate::formats::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n@@ -799,7 +797,7 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cache: &Cache) ->\n         AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n         AssocItemLink::Anchor(None) => anchor,\n         AssocItemLink::GotoSource(did, _) => {\n-            href(did, cache).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n+            href(did, cx).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n         }\n     }\n }\n@@ -813,16 +811,14 @@ fn assoc_const(\n     extra: &str,\n     cx: &Context<'_>,\n ) {\n-    let cache = cx.cache();\n-    let tcx = cx.tcx();\n     write!(\n         w,\n         \"{}{}const <a href=\\\"{}\\\" class=\\\"constant\\\"><b>{}</b></a>: {}\",\n         extra,\n-        it.visibility.print_with_space(tcx, it.def_id, cache),\n-        naive_assoc_href(it, link, cache),\n+        it.visibility.print_with_space(cx, it.def_id),\n+        naive_assoc_href(it, link, cx),\n         it.name.as_ref().unwrap(),\n-        ty.print(cache, tcx)\n+        ty.print(cx)\n     );\n }\n \n@@ -833,21 +829,20 @@ fn assoc_type(\n     default: Option<&clean::Type>,\n     link: AssocItemLink<'_>,\n     extra: &str,\n-    cache: &Cache,\n-    tcx: TyCtxt<'_>,\n+    cx: &Context<'_>,\n ) {\n     write!(\n         w,\n         \"{}type <a href=\\\"{}\\\" class=\\\"type\\\">{}</a>\",\n         extra,\n-        naive_assoc_href(it, link, cache),\n+        naive_assoc_href(it, link, cx),\n         it.name.as_ref().unwrap()\n     );\n     if !bounds.is_empty() {\n-        write!(w, \": {}\", print_generic_bounds(bounds, cache, tcx))\n+        write!(w, \": {}\", print_generic_bounds(cx, bounds))\n     }\n     if let Some(default) = default {\n-        write!(w, \" = {}\", default.print(cache, tcx))\n+        write!(w, \" = {}\", default.print(cx))\n     }\n }\n \n@@ -897,8 +892,6 @@ fn render_assoc_item(\n         parent: ItemType,\n         cx: &Context<'_>,\n     ) {\n-        let cache = cx.cache();\n-        let tcx = cx.tcx();\n         let name = meth.name.as_ref().unwrap();\n         let href = match link {\n             AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n@@ -912,19 +905,19 @@ fn render_assoc_item(\n                     ItemType::TyMethod\n                 };\n \n-                href(did, cache)\n+                href(did, cx)\n                     .map(|p| format!(\"{}#{}.{}\", p.0, ty, name))\n                     .unwrap_or_else(|| format!(\"#{}.{}\", ty, name))\n             }\n         };\n-        let vis = meth.visibility.print_with_space(tcx, meth.def_id, cache).to_string();\n+        let vis = meth.visibility.print_with_space(cx, meth.def_id).to_string();\n         let constness = header.constness.print_with_space();\n         let asyncness = header.asyncness.print_with_space();\n         let unsafety = header.unsafety.print_with_space();\n         let defaultness = print_default_space(meth.is_default());\n         let abi = print_abi_with_space(header.abi).to_string();\n         // NOTE: `{:#}` does not print HTML formatting, `{}` does. So `g.print` can't be reused between the length calculation and `write!`.\n-        let generics_len = format!(\"{:#}\", g.print(cache, tcx)).len();\n+        let generics_len = format!(\"{:#}\", g.print(cx)).len();\n         let mut header_len = \"fn \".len()\n             + vis.len()\n             + constness.len()\n@@ -958,10 +951,10 @@ fn render_assoc_item(\n             abi,\n             href = href,\n             name = name,\n-            generics = g.print(cache, tcx),\n-            decl = d.full_print(cache, tcx, header_len, indent, header.asyncness),\n-            notable_traits = notable_traits_decl(&d, cache, tcx),\n-            where_clause = print_where_clause(g, cache, tcx, indent, end_newline),\n+            generics = g.print(cx),\n+            decl = d.full_print(cx, header_len, indent, header.asyncness),\n+            notable_traits = notable_traits_decl(&d, cx),\n+            where_clause = print_where_clause(g, cx, indent, end_newline),\n         )\n     }\n     match *item.kind {\n@@ -988,8 +981,7 @@ fn render_assoc_item(\n             default.as_ref(),\n             link,\n             if parent == ItemType::Trait { \"    \" } else { \"\" },\n-            cx.cache(),\n-            cx.tcx(),\n+            cx,\n         ),\n         _ => panic!(\"render_assoc_item called on non-associated-item\"),\n     }\n@@ -1076,11 +1068,9 @@ fn render_assoc_items(\n                 RenderMode::Normal\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n-                let id = cx.derive_id(small_url_encode(format!(\n-                    \"deref-methods-{:#}\",\n-                    type_.print(cache, tcx)\n-                )));\n-                debug!(\"Adding {} to deref id map\", type_.print(cache, tcx));\n+                let id =\n+                    cx.derive_id(small_url_encode(format!(\"deref-methods-{:#}\", type_.print(cx))));\n+                debug!(\"Adding {} to deref id map\", type_.print(cx));\n                 cx.deref_id_map.borrow_mut().insert(type_.def_id_full(cache).unwrap(), id.clone());\n                 write!(\n                     w,\n@@ -1089,8 +1079,8 @@ fn render_assoc_items(\n                          <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n                      </h2>\",\n                     id = id,\n-                    trait_ = trait_.print(cache, tcx),\n-                    type_ = type_.print(cache, tcx),\n+                    trait_ = trait_.print(cx),\n+                    type_ = type_.print(cx),\n                 );\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n@@ -1242,36 +1232,34 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, cache: &Cache) -> bo\n     }\n }\n \n-fn notable_traits_decl(decl: &clean::FnDecl, cache: &Cache, tcx: TyCtxt<'_>) -> String {\n+fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n     let mut out = Buffer::html();\n     let mut trait_ = String::new();\n \n-    if let Some(did) = decl.output.def_id_full(cache) {\n-        if let Some(impls) = cache.impls.get(&did) {\n+    if let Some(did) = decl.output.def_id_full(cx.cache()) {\n+        if let Some(impls) = cx.cache().impls.get(&did) {\n             for i in impls {\n                 let impl_ = i.inner_impl();\n-                if impl_\n-                    .trait_\n-                    .def_id()\n-                    .map_or(false, |d| cache.traits.get(&d).map(|t| t.is_notable).unwrap_or(false))\n-                {\n+                if impl_.trait_.def_id().map_or(false, |d| {\n+                    cx.cache().traits.get(&d).map(|t| t.is_notable).unwrap_or(false)\n+                }) {\n                     if out.is_empty() {\n                         write!(\n                             &mut out,\n                             \"<h3 class=\\\"notable\\\">Notable traits for {}</h3>\\\n                              <code class=\\\"content\\\">\",\n-                            impl_.for_.print(cache, tcx)\n+                            impl_.for_.print(cx)\n                         );\n-                        trait_.push_str(&impl_.for_.print(cache, tcx).to_string());\n+                        trait_.push_str(&impl_.for_.print(cx).to_string());\n                     }\n \n                     //use the \"where\" class here to make it small\n                     write!(\n                         &mut out,\n                         \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n-                        impl_.print(cache, false, tcx)\n+                        impl_.print(false, cx)\n                     );\n-                    let t_did = impl_.trait_.def_id_full(cache).unwrap();\n+                    let t_did = impl_.trait_.def_id_full(cx.cache()).unwrap();\n                     for it in &impl_.items {\n                         if let clean::TypedefItem(ref tydef, _) = *it.kind {\n                             out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n@@ -1282,8 +1270,7 @@ fn notable_traits_decl(decl: &clean::FnDecl, cache: &Cache, tcx: TyCtxt<'_>) ->\n                                 Some(&tydef.type_),\n                                 AssocItemLink::GotoSource(t_did, &FxHashSet::default()),\n                                 \"\",\n-                                cache,\n-                                tcx,\n+                                cx,\n                             );\n                             out.push_str(\";</span>\");\n                         }\n@@ -1322,18 +1309,18 @@ fn render_impl(\n     // in documentation pages for trait with automatic implementations like \"Send\" and \"Sync\".\n     aliases: &[String],\n ) {\n-    let traits = &cx.cache.traits;\n     let tcx = cx.tcx();\n     let cache = cx.cache();\n+    let traits = &cache.traits;\n     let trait_ = i.trait_did_full(cache).map(|did| &traits[&did]);\n \n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => {\n                 if is_on_foreign_type {\n-                    get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t, cache, tcx)\n+                    get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t, cx)\n                 } else {\n-                    format!(\"impl-{}\", small_url_encode(format!(\"{:#}\", t.print(cache, tcx))))\n+                    format!(\"impl-{}\", small_url_encode(format!(\"{:#}\", t.print(cx))))\n                 }\n             }\n             None => \"impl\".to_string(),\n@@ -1345,7 +1332,7 @@ fn render_impl(\n         };\n         if let Some(use_absolute) = use_absolute {\n             write!(w, \"<h3 id=\\\"{}\\\" class=\\\"impl\\\"{}><code class=\\\"in-band\\\">\", id, aliases);\n-            write!(w, \"{}\", i.inner_impl().print(cache, use_absolute, tcx));\n+            write!(w, \"{}\", i.inner_impl().print(use_absolute, cx));\n             if show_def_docs {\n                 for it in &i.inner_impl().items {\n                     if let clean::TypedefItem(ref tydef, _) = *it.kind {\n@@ -1357,8 +1344,7 @@ fn render_impl(\n                             Some(&tydef.type_),\n                             AssocItemLink::Anchor(None),\n                             \"\",\n-                            cache,\n-                            tcx,\n+                            cx,\n                         );\n                         w.write_str(\";</span>\");\n                     }\n@@ -1371,7 +1357,7 @@ fn render_impl(\n                 \"<h3 id=\\\"{}\\\" class=\\\"impl\\\"{}><code class=\\\"in-band\\\">{}</code>\",\n                 id,\n                 aliases,\n-                i.inner_impl().print(cache, false, tcx)\n+                i.inner_impl().print(false, cx)\n             );\n         }\n         write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n@@ -1398,7 +1384,7 @@ fn render_impl(\n                 \"<div class=\\\"docblock\\\">{}</div>\",\n                 Markdown(\n                     &*dox,\n-                    &i.impl_item.links(&cx.cache),\n+                    &i.impl_item.links(cx),\n                     &mut ids,\n                     cx.shared.codes,\n                     cx.shared.edition,\n@@ -1495,8 +1481,7 @@ fn render_impl(\n                     Some(&tydef.type_),\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n                     \"\",\n-                    cx.cache(),\n-                    tcx,\n+                    cx,\n                 );\n                 w.write_str(\"</code>\");\n                 write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n@@ -1546,8 +1531,7 @@ fn render_impl(\n                     default.as_ref(),\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n                     \"\",\n-                    cx.cache(),\n-                    tcx,\n+                    cx,\n                 );\n                 w.write_str(\"</code>\");\n                 write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n@@ -1853,7 +1837,6 @@ fn small_url_encode(s: String) -> String {\n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     if let Some(v) = cx.cache.impls.get(&it.def_id) {\n         let mut used_links = FxHashSet::default();\n-        let tcx = cx.tcx();\n         let cache = cx.cache();\n \n         {\n@@ -1888,9 +1871,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n                     .iter()\n                     .filter_map(|it| {\n                         if let Some(ref i) = it.inner_impl().trait_ {\n-                            let i_display = format!(\"{:#}\", i.print(cache, tcx));\n+                            let i_display = format!(\"{:#}\", i.print(cx));\n                             let out = Escape(&i_display);\n-                            let encoded = small_url_encode(format!(\"{:#}\", i.print(cache, tcx)));\n+                            let encoded = small_url_encode(format!(\"{:#}\", i.print(cx)));\n                             let generated = format!(\n                                 \"<a href=\\\"#impl-{}\\\">{}{}</a>\",\n                                 encoded,\n@@ -1962,7 +1945,6 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n \n fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &Vec<Impl>) {\n     let c = cx.cache();\n-    let tcx = cx.tcx();\n \n     debug!(\"found Deref: {:?}\", impl_);\n     if let Some((target, real_target)) =\n@@ -2011,11 +1993,8 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n                     out,\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#{}\\\">Methods from {}&lt;Target={}&gt;</a>\",\n                     id,\n-                    Escape(&format!(\n-                        \"{:#}\",\n-                        impl_.inner_impl().trait_.as_ref().unwrap().print(c, tcx)\n-                    )),\n-                    Escape(&format!(\"{:#}\", real_target.print(c, tcx))),\n+                    Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print(cx))),\n+                    Escape(&format!(\"{:#}\", real_target.print(cx))),\n                 );\n                 // We want links' order to be reproducible so we don't use unstable sort.\n                 ret.sort();\n@@ -2071,27 +2050,20 @@ fn sidebar_struct(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, s: &clea\n fn get_id_for_impl_on_foreign_type(\n     for_: &clean::Type,\n     trait_: &clean::Type,\n-    cache: &Cache,\n-    tcx: TyCtxt<'_>,\n+    cx: &Context<'_>,\n ) -> String {\n-    small_url_encode(format!(\n-        \"impl-{:#}-for-{:#}\",\n-        trait_.print(cache, tcx),\n-        for_.print(cache, tcx)\n-    ))\n+    small_url_encode(format!(\"impl-{:#}-for-{:#}\", trait_.print(cx), for_.print(cx),))\n }\n \n-fn extract_for_impl_name(\n-    item: &clean::Item,\n-    cache: &Cache,\n-    tcx: TyCtxt<'_>,\n-) -> Option<(String, String)> {\n+fn extract_for_impl_name(item: &clean::Item, cx: &Context<'_>) -> Option<(String, String)> {\n     match *item.kind {\n         clean::ItemKind::ImplItem(ref i) => {\n             if let Some(ref trait_) = i.trait_ {\n+                // Alternative format produces no URLs,\n+                // so this parameter does nothing.\n                 Some((\n-                    format!(\"{:#}\", i.for_.print(cache, tcx)),\n-                    get_id_for_impl_on_foreign_type(&i.for_, trait_, cache, tcx),\n+                    format!(\"{:#}\", i.for_.print(cx)),\n+                    get_id_for_impl_on_foreign_type(&i.for_, trait_, cx),\n                 ))\n             } else {\n                 None\n@@ -2172,7 +2144,6 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n \n     if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n         let cache = cx.cache();\n-        let tcx = cx.tcx();\n         let mut res = implementors\n             .iter()\n             .filter(|i| {\n@@ -2181,7 +2152,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n                     .def_id_full(cache)\n                     .map_or(false, |d| !cx.cache.paths.contains_key(&d))\n             })\n-            .filter_map(|i| extract_for_impl_name(&i.impl_item, cache, tcx))\n+            .filter_map(|i| extract_for_impl_name(&i.impl_item, cx))\n             .collect::<Vec<_>>();\n \n         if !res.is_empty() {"}, {"sha": "3b939a255a4e72c7c6042d4bd5d6e587d18ca979", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 63, "deletions": 74, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -15,9 +15,8 @@ use super::{\n     render_impl, render_stability_since_raw, write_srclink, AssocItemLink, Context,\n };\n use crate::clean::{self, GetDefId};\n-use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n-use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n+use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{print_abi_with_space, print_where_clause, Buffer, PrintWithSpace};\n use crate::html::highlight;\n@@ -268,15 +267,15 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     Some(ref src) => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n-                        anchor(myitem.def_id, &*src.as_str(), cx.cache()),\n+                        myitem.visibility.print_with_space(cx, myitem.def_id),\n+                        anchor(myitem.def_id, &*src.as_str(), cx),\n                         myitem.name.as_ref().unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n-                        anchor(myitem.def_id, &*myitem.name.as_ref().unwrap().as_str(), cx.cache()),\n+                        myitem.visibility.print_with_space(cx, myitem.def_id),\n+                        anchor(myitem.def_id, &*myitem.name.as_ref().unwrap().as_str(), cx),\n                     ),\n                 }\n                 w.write_str(\"</code></td></tr>\");\n@@ -286,8 +285,8 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 write!(\n                     w,\n                     \"<tr><td><code>{}{}</code></td></tr>\",\n-                    myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n-                    import.print(cx.cache(), cx.tcx()),\n+                    myitem.visibility.print_with_space(cx, myitem.def_id),\n+                    import.print(cx),\n                 );\n             }\n \n@@ -318,7 +317,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                      </tr>\",\n                     name = *myitem.name.as_ref().unwrap(),\n                     stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n-                    docs = MarkdownSummaryLine(&doc_value, &myitem.links(&cx.cache)).into_string(),\n+                    docs = MarkdownSummaryLine(&doc_value, &myitem.links(cx)).into_string(),\n                     class = myitem.type_(),\n                     add = add,\n                     stab = stab.unwrap_or_else(String::new),\n@@ -387,13 +386,13 @@ fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) ->\n fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        it.visibility.print_with_space(cx, it.def_id),\n         f.header.constness.print_with_space(),\n         f.header.asyncness.print_with_space(),\n         f.header.unsafety.print_with_space(),\n         print_abi_with_space(f.header.abi),\n         it.name.as_ref().unwrap(),\n-        f.generics.print(cx.cache(), cx.tcx())\n+        f.generics.print(cx),\n     )\n     .len();\n     w.write_str(\"<pre class=\\\"rust fn\\\">\");\n@@ -402,22 +401,22 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         w,\n         \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n          {name}{generics}{decl}{notable_traits}{where_clause}</pre>\",\n-        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        vis = it.visibility.print_with_space(cx, it.def_id),\n         constness = f.header.constness.print_with_space(),\n         asyncness = f.header.asyncness.print_with_space(),\n         unsafety = f.header.unsafety.print_with_space(),\n         abi = print_abi_with_space(f.header.abi),\n         name = it.name.as_ref().unwrap(),\n-        generics = f.generics.print(cx.cache(), cx.tcx()),\n-        where_clause = print_where_clause(&f.generics, cx.cache(), cx.tcx(), 0, true),\n-        decl = f.decl.full_print(cx.cache(), cx.tcx(), header_len, 0, f.header.asyncness),\n-        notable_traits = notable_traits_decl(&f.decl, cx.cache(), cx.tcx()),\n+        generics = f.generics.print(cx),\n+        where_clause = print_where_clause(&f.generics, cx, 0, true),\n+        decl = f.decl.full_print(cx, header_len, 0, f.header.asyncness),\n+        notable_traits = notable_traits_decl(&f.decl, cx),\n     );\n     document(w, cx, it, None)\n }\n \n fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait) {\n-    let bounds = bounds(&t.bounds, false, cx.cache(), cx.tcx());\n+    let bounds = bounds(&t.bounds, false, cx);\n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n     let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n@@ -430,16 +429,16 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         write!(\n             w,\n             \"{}{}{}trait {}{}{}\",\n-            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+            it.visibility.print_with_space(cx, it.def_id),\n             t.unsafety.print_with_space(),\n             if t.is_auto { \"auto \" } else { \"\" },\n             it.name.as_ref().unwrap(),\n-            t.generics.print(cx.cache(), cx.tcx()),\n+            t.generics.print(cx),\n             bounds\n         );\n \n         if !t.generics.where_predicates.is_empty() {\n-            write!(w, \"{}\", print_where_clause(&t.generics, cx.cache(), cx.tcx(), 0, true));\n+            write!(w, \"{}\", print_where_clause(&t.generics, cx, 0, true));\n         } else {\n             w.write_str(\" \");\n         }\n@@ -634,8 +633,8 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             local.iter().partition(|i| i.inner_impl().synthetic);\n \n-        synthetic.sort_by(|a, b| compare_impl(a, b, cx.cache(), cx.tcx()));\n-        concrete.sort_by(|a, b| compare_impl(a, b, cx.cache(), cx.tcx()));\n+        synthetic.sort_by(|a, b| compare_impl(a, b, cx));\n+        concrete.sort_by(|a, b| compare_impl(a, b, cx));\n \n         if !foreign.is_empty() {\n             write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\");\n@@ -740,9 +739,9 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n         w,\n         \"trait {}{}{} = {};</pre>\",\n         it.name.as_ref().unwrap(),\n-        t.generics.print(cx.cache(), cx.tcx()),\n-        print_where_clause(&t.generics, cx.cache(), cx.tcx(), 0, true),\n-        bounds(&t.bounds, true, cx.cache(), cx.tcx())\n+        t.generics.print(cx),\n+        print_where_clause(&t.generics, cx, 0, true),\n+        bounds(&t.bounds, true, cx)\n     );\n \n     document(w, cx, it, None);\n@@ -761,9 +760,9 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n         w,\n         \"type {}{}{where_clause} = impl {bounds};</pre>\",\n         it.name.as_ref().unwrap(),\n-        t.generics.print(cx.cache(), cx.tcx()),\n-        where_clause = print_where_clause(&t.generics, cx.cache(), cx.tcx(), 0, true),\n-        bounds = bounds(&t.bounds, false, cx.cache(), cx.tcx()),\n+        t.generics.print(cx),\n+        where_clause = print_where_clause(&t.generics, cx, 0, true),\n+        bounds = bounds(&t.bounds, false, cx),\n     );\n \n     document(w, cx, it, None);\n@@ -782,9 +781,9 @@ fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::T\n         w,\n         \"type {}{}{where_clause} = {type_};</pre>\",\n         it.name.as_ref().unwrap(),\n-        t.generics.print(cx.cache(), cx.tcx()),\n-        where_clause = print_where_clause(&t.generics, cx.cache(), cx.tcx(), 0, true),\n-        type_ = t.type_.print(cx.cache(), cx.tcx()),\n+        t.generics.print(cx),\n+        where_clause = print_where_clause(&t.generics, cx, 0, true),\n+        type_ = t.type_.print(cx),\n     );\n \n     document(w, cx, it, None);\n@@ -831,7 +830,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n                 id = id,\n                 name = name,\n                 shortty = ItemType::StructField,\n-                ty = ty.print(cx.cache(), cx.tcx()),\n+                ty = ty.print(cx),\n             );\n             if let Some(stability_class) = field.stability_class(cx.tcx()) {\n                 write!(w, \"<span class=\\\"stab {stab}\\\"></span>\", stab = stability_class);\n@@ -849,10 +848,10 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n         write!(\n             w,\n             \"{}enum {}{}{}\",\n-            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+            it.visibility.print_with_space(cx, it.def_id),\n             it.name.as_ref().unwrap(),\n-            e.generics.print(cx.cache(), cx.tcx()),\n-            print_where_clause(&e.generics, cx.cache(), cx.tcx(), 0, true),\n+            e.generics.print(cx),\n+            print_where_clause(&e.generics, cx, 0, true),\n         );\n         if e.variants.is_empty() && !e.variants_stripped {\n             w.write_str(\" {}\");\n@@ -874,7 +873,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                                 if i > 0 {\n                                     w.write_str(\",&nbsp;\")\n                                 }\n-                                write!(w, \"{}\", ty.print(cx.cache(), cx.tcx()));\n+                                write!(w, \"{}\", ty.print(cx));\n                             }\n                             w.write_str(\")\");\n                         }\n@@ -924,7 +923,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                     if i > 0 {\n                         w.write_str(\",&nbsp;\");\n                     }\n-                    write!(w, \"{}\", ty.print(cx.cache(), cx.tcx()));\n+                    write!(w, \"{}\", ty.print(cx));\n                 }\n                 w.write_str(\")\");\n             }\n@@ -961,7 +960,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                              </span>\",\n                             id = id,\n                             f = field.name.as_ref().unwrap(),\n-                            t = ty.print(cx.cache(), cx.tcx())\n+                            t = ty.print(cx)\n                         );\n                         document(w, cx, field, Some(variant));\n                     }\n@@ -1030,9 +1029,9 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n     write!(\n         w,\n         \"{vis}const {name}: {typ}\",\n-        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        vis = it.visibility.print_with_space(cx, it.def_id),\n         name = it.name.as_ref().unwrap(),\n-        typ = c.type_.print(cx.cache(), cx.tcx()),\n+        typ = c.type_.print(cx),\n     );\n \n     let value = c.value(cx.tcx());\n@@ -1102,7 +1101,7 @@ fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n                     item_type = ItemType::StructField,\n                     id = id,\n                     name = field.name.as_ref().unwrap(),\n-                    ty = ty.print(cx.cache(), cx.tcx())\n+                    ty = ty.print(cx)\n                 );\n                 document(w, cx, field, Some(it));\n             }\n@@ -1117,10 +1116,10 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n     write!(\n         w,\n         \"{vis}static {mutability}{name}: {typ}</pre>\",\n-        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        vis = it.visibility.print_with_space(cx, it.def_id),\n         mutability = s.mutability.print_with_space(),\n         name = it.name.as_ref().unwrap(),\n-        typ = s.type_.print(cx.cache(), cx.tcx())\n+        typ = s.type_.print(cx)\n     );\n     document(w, cx, it, None)\n }\n@@ -1131,7 +1130,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        it.visibility.print_with_space(cx, it.def_id),\n         it.name.as_ref().unwrap(),\n     );\n \n@@ -1195,12 +1194,7 @@ pub(super) fn item_path(ty: ItemType, name: &str) -> String {\n     }\n }\n \n-fn bounds(\n-    t_bounds: &[clean::GenericBound],\n-    trait_alias: bool,\n-    cache: &Cache,\n-    tcx: TyCtxt<'_>,\n-) -> String {\n+fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool, cx: &Context<'_>) -> String {\n     let mut bounds = String::new();\n     if !t_bounds.is_empty() {\n         if !trait_alias {\n@@ -1210,7 +1204,7 @@ fn bounds(\n             if i > 0 {\n                 bounds.push_str(\" + \");\n             }\n-            bounds.push_str(&p.print(cache, tcx).to_string());\n+            bounds.push_str(&p.print(cx).to_string());\n         }\n     }\n     bounds\n@@ -1240,17 +1234,12 @@ fn render_stability_since(\n     )\n }\n \n-fn compare_impl<'a, 'b>(\n-    lhs: &'a &&Impl,\n-    rhs: &'b &&Impl,\n-    cache: &Cache,\n-    tcx: TyCtxt<'_>,\n-) -> Ordering {\n-    let lhs = format!(\"{}\", lhs.inner_impl().print(cache, false, tcx));\n-    let rhs = format!(\"{}\", rhs.inner_impl().print(cache, false, tcx));\n+fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl, cx: &Context<'_>) -> Ordering {\n+    let lhss = format!(\"{}\", lhs.inner_impl().print(false, cx));\n+    let rhss = format!(\"{}\", rhs.inner_impl().print(false, cx));\n \n     // lhs and rhs are formatted as HTML, which may be unnecessary\n-    compare_names(&lhs, &rhs)\n+    compare_names(&lhss, &rhss)\n }\n \n fn render_implementor(\n@@ -1300,13 +1289,13 @@ fn render_union(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        it.visibility.print_with_space(cx, it.def_id),\n         if structhead { \"union \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n     if let Some(g) = g {\n-        write!(w, \"{}\", g.print(cx.cache(), cx.tcx()));\n-        write!(w, \"{}\", print_where_clause(&g, cx.cache(), cx.tcx(), 0, true));\n+        write!(w, \"{}\", g.print(cx));\n+        write!(w, \"{}\", print_where_clause(&g, cx, 0, true));\n     }\n \n     write!(w, \" {{\\n{}\", tab);\n@@ -1322,9 +1311,9 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                field.visibility.print_with_space(cx, field.def_id),\n                 field.name.as_ref().unwrap(),\n-                ty.print(cx.cache(), cx.tcx()),\n+                ty.print(cx),\n                 tab\n             );\n         }\n@@ -1352,17 +1341,17 @@ fn render_struct(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        it.visibility.print_with_space(cx, it.def_id),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n     if let Some(g) = g {\n-        write!(w, \"{}\", g.print(cx.cache(), cx.tcx()))\n+        write!(w, \"{}\", g.print(cx))\n     }\n     match ty {\n         CtorKind::Fictive => {\n             if let Some(g) = g {\n-                write!(w, \"{}\", print_where_clause(g, cx.cache(), cx.tcx(), 0, true),)\n+                write!(w, \"{}\", print_where_clause(g, cx, 0, true),)\n             }\n             w.write_str(\" {\");\n             let count_fields =\n@@ -1378,9 +1367,9 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                        field.visibility.print_with_space(cx, field.def_id),\n                         field.name.as_ref().unwrap(),\n-                        ty.print(cx.cache(), cx.tcx()),\n+                        ty.print(cx),\n                     );\n                 }\n             }\n@@ -1412,23 +1401,23 @@ fn render_struct(\n                         write!(\n                             w,\n                             \"{}{}\",\n-                            field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n-                            ty.print(cx.cache(), cx.tcx()),\n+                            field.visibility.print_with_space(cx, field.def_id),\n+                            ty.print(cx),\n                         )\n                     }\n                     _ => unreachable!(),\n                 }\n             }\n             w.write_str(\")\");\n             if let Some(g) = g {\n-                write!(w, \"{}\", print_where_clause(g, cx.cache(), cx.tcx(), 0, false),)\n+                write!(w, \"{}\", print_where_clause(g, cx, 0, false),)\n             }\n             w.write_str(\";\");\n         }\n         CtorKind::Const => {\n             // Needed for PhantomData.\n             if let Some(g) = g {\n-                write!(w, \"{}\", print_where_clause(g, cx.cache(), cx.tcx(), 0, false),)\n+                write!(w, \"{}\", print_where_clause(g, cx, 0, false),)\n             }\n             w.write_str(\";\");\n         }"}, {"sha": "90e56d00a1132f9fca66f641979859e00b33049c", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -16,7 +16,6 @@ use crate::clean::Crate;\n use crate::config::{EmitType, RenderOptions};\n use crate::docfs::PathError;\n use crate::error::Error;\n-use crate::formats::FormatRenderer;\n use crate::html::{layout, static_files};\n \n crate static FILES_UNVERSIONED: Lazy<FxHashMap<&str, &[u8]>> = Lazy::new(|| {\n@@ -500,7 +499,7 @@ pub(super) fn write_shared(\n                     None\n                 } else {\n                     Some(Implementor {\n-                        text: imp.inner_impl().print(cx.cache(), false, cx.tcx()).to_string(),\n+                        text: imp.inner_impl().print(false, cx).to_string(),\n                         synthetic: imp.inner_impl().synthetic,\n                         types: collect_paths_for_type(imp.inner_impl().for_.clone(), cx.cache()),\n                     })"}, {"sha": "5d537dabd0c076c4bd75dd54aa6a9a4e38c4289b", "filename": "src/librustdoc/html/tests.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Fhtml%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftests.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -0,0 +1,44 @@\n+use crate::html::format::href_relative_parts;\n+\n+fn assert_relative_path(expected: &[&str], relative_to_fqp: &[&str], fqp: &[&str]) {\n+    let relative_to_fqp: Vec<String> = relative_to_fqp.iter().copied().map(String::from).collect();\n+    let fqp: Vec<String> = fqp.iter().copied().map(String::from).collect();\n+    assert_eq!(expected, href_relative_parts(&fqp, &relative_to_fqp));\n+}\n+\n+#[test]\n+fn href_relative_parts_basic() {\n+    let relative_to_fqp = &[\"std\", \"vec\"];\n+    let fqp = &[\"std\", \"iter\"];\n+    assert_relative_path(&[\"..\", \"iter\"], relative_to_fqp, fqp);\n+}\n+#[test]\n+fn href_relative_parts_parent_module() {\n+    let relative_to_fqp = &[\"std\", \"vec\"];\n+    let fqp = &[\"std\"];\n+    assert_relative_path(&[\"..\"], relative_to_fqp, fqp);\n+}\n+#[test]\n+fn href_relative_parts_different_crate() {\n+    let relative_to_fqp = &[\"std\", \"vec\"];\n+    let fqp = &[\"core\", \"iter\"];\n+    assert_relative_path(&[\"..\", \"..\", \"core\", \"iter\"], relative_to_fqp, fqp);\n+}\n+#[test]\n+fn href_relative_parts_same_module() {\n+    let relative_to_fqp = &[\"std\", \"vec\"];\n+    let fqp = &[\"std\", \"vec\"];\n+    assert_relative_path(&[], relative_to_fqp, fqp);\n+}\n+#[test]\n+fn href_relative_parts_child_module() {\n+    let relative_to_fqp = &[\"std\"];\n+    let fqp = &[\"std\", \"vec\"];\n+    assert_relative_path(&[\"vec\"], relative_to_fqp, fqp);\n+}\n+#[test]\n+fn href_relative_parts_root() {\n+    let relative_to_fqp = &[];\n+    let fqp = &[\"std\"];\n+    assert_relative_path(&[\"std\"], relative_to_fqp, fqp);\n+}"}, {"sha": "2a51d78f64a390e4466d2870dcde1bcd89b8f0de", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -289,7 +289,13 @@ fn opts() -> Vec<RustcOptGroup> {\n         stable(\"cfg\", |o| o.optmulti(\"\", \"cfg\", \"pass a --cfg to rustc\", \"\")),\n         stable(\"extern\", |o| o.optmulti(\"\", \"extern\", \"pass an --extern to rustc\", \"NAME[=PATH]\")),\n         unstable(\"extern-html-root-url\", |o| {\n-            o.optmulti(\"\", \"extern-html-root-url\", \"base URL to use for dependencies\", \"NAME=URL\")\n+            o.optmulti(\n+                \"\",\n+                \"extern-html-root-url\",\n+                \"base URL to use for dependencies; for example, \\\n+                 \\\"std=/doc\\\" links std::vec::Vec to /doc/std/vec/struct.Vec.html\",\n+                \"NAME=URL\",\n+            )\n         }),\n         stable(\"plugin-path\", |o| o.optmulti(\"\", \"plugin-path\", \"removed\", \"DIR\")),\n         stable(\"C\", |o| {"}, {"sha": "8fda171002ba045f1166a80b5a652df20473ff27", "filename": "src/test/rustdoc/assoc-types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fassoc-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fassoc-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-types.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -6,14 +6,14 @@ pub trait Index<I: ?Sized> {\n     type Output: ?Sized;\n     // @has - '//*[@id=\"tymethod.index\"]//code' \\\n     //      \"fn index<'a>(&'a self, index: I) -> &'a Self::Output\"\n-    // @has - '//*[@id=\"tymethod.index\"]//code//a[@href=\"../assoc_types/trait.Index.html#associatedtype.Output\"]' \\\n+    // @has - '//*[@id=\"tymethod.index\"]//code//a[@href=\"trait.Index.html#associatedtype.Output\"]' \\\n     //      \"Output\"\n     fn index<'a>(&'a self, index: I) -> &'a Self::Output;\n }\n \n // @has assoc_types/fn.use_output.html\n // @has - '//*[@class=\"rust fn\"]' '-> &T::Output'\n-// @has - '//*[@class=\"rust fn\"]//a[@href=\"../assoc_types/trait.Index.html#associatedtype.Output\"]' 'Output'\n+// @has - '//*[@class=\"rust fn\"]//a[@href=\"trait.Index.html#associatedtype.Output\"]' 'Output'\n pub fn use_output<T: Index<usize>>(obj: &T, index: usize) -> &T::Output {\n     obj.index(index)\n }\n@@ -24,12 +24,12 @@ pub trait Feed {\n \n // @has assoc_types/fn.use_input.html\n // @has - '//*[@class=\"rust fn\"]' 'T::Input'\n-// @has - '//*[@class=\"rust fn\"]//a[@href=\"../assoc_types/trait.Feed.html#associatedtype.Input\"]' 'Input'\n+// @has - '//*[@class=\"rust fn\"]//a[@href=\"trait.Feed.html#associatedtype.Input\"]' 'Input'\n pub fn use_input<T: Feed>(_feed: &T, _element: T::Input) { }\n \n // @has assoc_types/fn.cmp_input.html\n // @has - '//*[@class=\"rust fn\"]' 'where T::Input: PartialEq<U::Input>'\n-// @has - '//*[@class=\"rust fn\"]//a[@href=\"../assoc_types/trait.Feed.html#associatedtype.Input\"]' 'Input'\n+// @has - '//*[@class=\"rust fn\"]//a[@href=\"trait.Feed.html#associatedtype.Input\"]' 'Input'\n pub fn cmp_input<T: Feed, U: Feed>(a: &T::Input, b: &U::Input) -> bool\n     where T::Input: PartialEq<U::Input>\n {"}, {"sha": "a5b69740dd447c9e99944eafb0d4ad278f4e5de8", "filename": "src/test/rustdoc/auxiliary/primitive-doc.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fauxiliary%2Fprimitive-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fauxiliary%2Fprimitive-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fprimitive-doc.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -0,0 +1,6 @@\n+// compile-flags: --crate-type lib --edition 2018\n+\n+#[doc(primitive = \"usize\")]\n+/// This is the built-in type `usize`.\n+mod usize {\n+}"}, {"sha": "ed4a5ea21374b7b19e1c1b22e149f9e4e4380aeb", "filename": "src/test/rustdoc/check-styled-link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fcheck-styled-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fcheck-styled-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-styled-link.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -2,7 +2,7 @@\n \n pub struct Foo;\n \n-// @has foo/struct.Bar.html '//a[@href=\"../foo/struct.Foo.html\"]' 'Foo'\n+// @has foo/struct.Bar.html '//a[@href=\"struct.Foo.html\"]' 'Foo'\n \n /// Code-styled reference to [`Foo`].\n pub struct Bar;"}, {"sha": "05376e4680ec4d5477ba8667835a3ce4baa1f213", "filename": "src/test/rustdoc/cross-crate-primitive-doc.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcross-crate-primitive-doc.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -0,0 +1,9 @@\n+// aux-build:primitive-doc.rs\n+// compile-flags: --extern-html-root-url=primitive_doc=../ -Z unstable-options\n+\n+#![no_std]\n+\n+extern crate primitive_doc;\n+\n+// @has 'cross_crate_primitive_doc/fn.foo.html' '//a[@href=\"../primitive_doc/primitive.usize.html\"]' 'usize'\n+pub fn foo() -> usize { 0 }"}, {"sha": "7bcd2a3c149e9a7a81d0bbc947311fc4827f39ae", "filename": "src/test/rustdoc/default-trait-method-link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fdefault-trait-method-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fdefault-trait-method-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdefault-trait-method-link.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -1,7 +1,7 @@\n #![crate_name = \"foo\"]\n \n-// @has foo/trait.Foo.html '//a[@href=\"../foo/trait.Foo.html#tymethod.req\"]' 'req'\n-// @has foo/trait.Foo.html '//a[@href=\"../foo/trait.Foo.html#method.prov\"]' 'prov'\n+// @has foo/trait.Foo.html '//a[@href=\"trait.Foo.html#tymethod.req\"]' 'req'\n+// @has foo/trait.Foo.html '//a[@href=\"trait.Foo.html#method.prov\"]' 'prov'\n \n /// Always make sure to implement [`req`], but you don't have to implement [`prov`].\n ///"}, {"sha": "8c36a7fa002d856badd5b14c9954854dc78b8ee9", "filename": "src/test/rustdoc/intra-doc-crate/self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fself.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fself.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-crate%2Fself.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -3,7 +3,7 @@\n \n extern crate cross_crate_self;\n \n-// @has self/struct.S.html '//a[@href=\"../self/struct.S.html#method.f\"]' \"Self::f\"\n-// @has self/struct.S.html '//a[@href=\"../self/struct.S.html\"]' \"Self\"\n+// @has self/struct.S.html '//a[@href=\"struct.S.html#method.f\"]' \"Self::f\"\n+// @has self/struct.S.html '//a[@href=\"struct.S.html\"]' \"Self\"\n // @has self/struct.S.html '//a[@href=\"../cross_crate_self/index.html\"]' \"crate\"\n pub use cross_crate_self::S;"}, {"sha": "8ec1a7b4f9056381784dda314f1537252061b2bd", "filename": "src/test/rustdoc/intra-doc/anchors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fanchors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fanchors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fanchors.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -4,7 +4,7 @@\n pub struct Something;\n \n // @has anchors/struct.SomeOtherType.html\n-// @has - '//a/@href' '../anchors/struct.Something.html#Anchor!'\n+// @has - '//a/@href' 'struct.Something.html#Anchor!'\n \n /// I want...\n ///"}, {"sha": "68647127fe880317b22fedae82dc95035c8d0c3a", "filename": "src/test/rustdoc/intra-doc/associated-defaults.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-defaults.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -9,14 +9,14 @@ pub trait TraitWithDefault {\n }\n \n /// Link to [UsesDefaults::T] and [UsesDefaults::f]\n-// @has 'associated_defaults/struct.UsesDefaults.html' '//a[@href=\"../associated_defaults/struct.UsesDefaults.html#associatedtype.T\"]' 'UsesDefaults::T'\n-// @has 'associated_defaults/struct.UsesDefaults.html' '//a[@href=\"../associated_defaults/struct.UsesDefaults.html#method.f\"]' 'UsesDefaults::f'\n+// @has 'associated_defaults/struct.UsesDefaults.html' '//a[@href=\"struct.UsesDefaults.html#associatedtype.T\"]' 'UsesDefaults::T'\n+// @has 'associated_defaults/struct.UsesDefaults.html' '//a[@href=\"struct.UsesDefaults.html#method.f\"]' 'UsesDefaults::f'\n pub struct UsesDefaults;\n impl TraitWithDefault for UsesDefaults {}\n \n /// Link to [OverridesDefaults::T] and [OverridesDefaults::f]\n-// @has 'associated_defaults/struct.OverridesDefaults.html' '//a[@href=\"../associated_defaults/struct.OverridesDefaults.html#associatedtype.T\"]' 'OverridesDefaults::T'\n-// @has 'associated_defaults/struct.OverridesDefaults.html' '//a[@href=\"../associated_defaults/struct.OverridesDefaults.html#method.f\"]' 'OverridesDefaults::f'\n+// @has 'associated_defaults/struct.OverridesDefaults.html' '//a[@href=\"struct.OverridesDefaults.html#associatedtype.T\"]' 'OverridesDefaults::T'\n+// @has 'associated_defaults/struct.OverridesDefaults.html' '//a[@href=\"struct.OverridesDefaults.html#method.f\"]' 'OverridesDefaults::f'\n pub struct OverridesDefaults;\n impl TraitWithDefault for OverridesDefaults {\n     type T = bool;"}, {"sha": "2757418bc64e5c4990885be015c95b3813c8771a", "filename": "src/test/rustdoc/intra-doc/associated-items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-items.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -9,10 +9,10 @@\n pub fn foo() {}\n \n /// Link to [MyStruct], [link from struct][MyStruct::method], [MyStruct::clone], [MyStruct::Input]\n-// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"../associated_items/struct.MyStruct.html\"]' 'MyStruct'\n-// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"../associated_items/struct.MyStruct.html#method.method\"]' 'link from struct'\n-// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"../associated_items/struct.MyStruct.html#method.clone\"]' 'MyStruct::clone'\n-// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"../associated_items/struct.MyStruct.html#associatedtype.Input\"]' 'MyStruct::Input'\n+// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"struct.MyStruct.html\"]' 'MyStruct'\n+// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"struct.MyStruct.html#method.method\"]' 'link from struct'\n+// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"struct.MyStruct.html#method.clone\"]' 'MyStruct::clone'\n+// @has 'associated_items/struct.MyStruct.html' '//a[@href=\"struct.MyStruct.html#associatedtype.Input\"]' 'MyStruct::Input'\n pub struct MyStruct { foo: () }\n \n impl Clone for MyStruct {\n@@ -30,7 +30,7 @@ impl T for MyStruct {\n     type Input = usize;\n \n     /// [link from method][MyStruct::method] on method\n-    // @has 'associated_items/struct.MyStruct.html' '//a[@href=\"../associated_items/struct.MyStruct.html#method.method\"]' 'link from method'\n+    // @has 'associated_items/struct.MyStruct.html' '//a[@href=\"struct.MyStruct.html#method.method\"]' 'link from method'\n     fn method(i: usize) {\n     }\n }"}, {"sha": "39f5c298bc4a1ac30164bb4c904c3aad9a037c4f", "filename": "src/test/rustdoc/intra-doc/basic.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fbasic.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -1,21 +1,21 @@\n // @has basic/index.html\n-// @has - '//a/@href' '../basic/struct.ThisType.html'\n-// @has - '//a/@href' '../basic/struct.ThisType.html#method.this_method'\n-// @has - '//a/@href' '../basic/enum.ThisEnum.html'\n-// @has - '//a/@href' '../basic/enum.ThisEnum.html#variant.ThisVariant'\n-// @has - '//a/@href' '../basic/trait.ThisTrait.html'\n-// @has - '//a/@href' '../basic/trait.ThisTrait.html#tymethod.this_associated_method'\n-// @has - '//a/@href' '../basic/trait.ThisTrait.html#associatedtype.ThisAssociatedType'\n-// @has - '//a/@href' '../basic/trait.ThisTrait.html#associatedconstant.THIS_ASSOCIATED_CONST'\n-// @has - '//a/@href' '../basic/trait.ThisTrait.html'\n-// @has - '//a/@href' '../basic/type.ThisAlias.html'\n-// @has - '//a/@href' '../basic/union.ThisUnion.html'\n-// @has - '//a/@href' '../basic/fn.this_function.html'\n-// @has - '//a/@href' '../basic/constant.THIS_CONST.html'\n-// @has - '//a/@href' '../basic/static.THIS_STATIC.html'\n-// @has - '//a/@href' '../basic/macro.this_macro.html'\n-// @has - '//a/@href' '../basic/trait.SoAmbiguous.html'\n-// @has - '//a/@href' '../basic/fn.SoAmbiguous.html'\n+// @has - '//a/@href' 'struct.ThisType.html'\n+// @has - '//a/@href' 'struct.ThisType.html#method.this_method'\n+// @has - '//a/@href' 'enum.ThisEnum.html'\n+// @has - '//a/@href' 'enum.ThisEnum.html#variant.ThisVariant'\n+// @has - '//a/@href' 'trait.ThisTrait.html'\n+// @has - '//a/@href' 'trait.ThisTrait.html#tymethod.this_associated_method'\n+// @has - '//a/@href' 'trait.ThisTrait.html#associatedtype.ThisAssociatedType'\n+// @has - '//a/@href' 'trait.ThisTrait.html#associatedconstant.THIS_ASSOCIATED_CONST'\n+// @has - '//a/@href' 'trait.ThisTrait.html'\n+// @has - '//a/@href' 'type.ThisAlias.html'\n+// @has - '//a/@href' 'union.ThisUnion.html'\n+// @has - '//a/@href' 'fn.this_function.html'\n+// @has - '//a/@href' 'constant.THIS_CONST.html'\n+// @has - '//a/@href' 'static.THIS_STATIC.html'\n+// @has - '//a/@href' 'macro.this_macro.html'\n+// @has - '//a/@href' 'trait.SoAmbiguous.html'\n+// @has - '//a/@href' 'fn.SoAmbiguous.html'\n //! In this crate we would like to link to:\n //!\n //! * [`ThisType`](ThisType)\n@@ -46,7 +46,7 @@ macro_rules! this_macro {\n     () => {};\n }\n \n-// @has basic/struct.ThisType.html '//a/@href' '../basic/macro.this_macro.html'\n+// @has basic/struct.ThisType.html '//a/@href' 'macro.this_macro.html'\n /// another link to [`this_macro!()`]\n pub struct ThisType;\n \n@@ -72,10 +72,10 @@ pub trait SoAmbiguous {}\n pub fn SoAmbiguous() {}\n \n \n-// @has basic/struct.SomeOtherType.html '//a/@href' '../basic/struct.ThisType.html'\n-// @has - '//a/@href' '../basic/struct.ThisType.html#method.this_method'\n-// @has - '//a/@href' '../basic/enum.ThisEnum.html'\n-// @has - '//a/@href' '../basic/enum.ThisEnum.html#variant.ThisVariant'\n+// @has basic/struct.SomeOtherType.html '//a/@href' 'struct.ThisType.html'\n+// @has - '//a/@href' 'struct.ThisType.html#method.this_method'\n+// @has - '//a/@href' 'enum.ThisEnum.html'\n+// @has - '//a/@href' 'enum.ThisEnum.html#variant.ThisVariant'\n /// Shortcut links for:\n /// * [`ThisType`]\n /// * [`ThisType::this_method`]"}, {"sha": "85c5866ca7ecfbc1b8ad0d56d01f3cc1d84e538e", "filename": "src/test/rustdoc/intra-doc/cross-crate/additional_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fadditional_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fadditional_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fadditional_doc.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -4,7 +4,7 @@\n \n extern crate my_rand;\n \n-// @has 'additional_doc/trait.Rng.html' '//a[@href=\"../additional_doc/trait.Rng.html\"]' 'Rng'\n+// @has 'additional_doc/trait.Rng.html' '//a[@href=\"trait.Rng.html\"]' 'Rng'\n // @has 'additional_doc/trait.Rng.html' '//a[@href=\"../my_rand/trait.RngCore.html\"]' 'RngCore'\n /// This is an [`Rng`].\n pub use my_rand::Rng;"}, {"sha": "31337f20f18dc91e1336f26378bbcf2a9c59ae07", "filename": "src/test/rustdoc/intra-doc/cross-crate/hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fhidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fhidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fhidden.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -6,5 +6,5 @@\n \n extern crate hidden_dep;\n \n-// @has 'hidden/struct.Ready.html' '//a/@href' '../hidden/fn.ready.html'\n+// @has 'hidden/struct.Ready.html' '//a/@href' 'fn.ready.html'\n pub use hidden_dep::future::{ready, Ready};"}, {"sha": "db7952b5aced0699f2408995dda1d8db8f1cd48d", "filename": "src/test/rustdoc/intra-doc/cross-crate/submodule-outer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fsubmodule-outer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fsubmodule-outer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fcross-crate%2Fsubmodule-outer.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -11,6 +11,6 @@ pub mod bar {\n \n // NOTE: we re-exported both `Foo` and `Bar` here,\n // NOTE: so they are inlined and therefore we link to the current module.\n-// @has 'submodule_outer/trait.Foo.html' '//a[@href=\"../submodule_outer/bar/trait.Bar.html\"]' 'Bar'\n-// @has 'submodule_outer/trait.Foo.html' '//a[@href=\"../submodule_outer/trait.Baz.html\"]' 'Baz'\n+// @has 'submodule_outer/trait.Foo.html' '//a[@href=\"bar/trait.Bar.html\"]' 'Bar'\n+// @has 'submodule_outer/trait.Foo.html' '//a[@href=\"trait.Baz.html\"]' 'Baz'\n pub use ::bar_::{Foo, Baz};"}, {"sha": "d782c5cf5dc84ade7959ce68d05c429dbeb81127", "filename": "src/test/rustdoc/intra-doc/disambiguators-removed.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fdisambiguators-removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fdisambiguators-removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fdisambiguators-removed.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -2,49 +2,49 @@\n // first try backticks\n /// Trait: [`trait@Name`], fn: [`fn@Name`], [`Name`][`macro@Name`]\n // @has disambiguators_removed/struct.AtDisambiguator.html\n-// @has - '//a[@href=\"../disambiguators_removed/trait.Name.html\"][code]' \"Name\"\n-// @has - '//a[@href=\"../disambiguators_removed/fn.Name.html\"][code]' \"Name\"\n-// @has - '//a[@href=\"../disambiguators_removed/macro.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"trait.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"fn.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"macro.Name.html\"][code]' \"Name\"\n pub struct AtDisambiguator;\n \n /// fn: [`Name()`], macro: [`Name!`]\n // @has disambiguators_removed/struct.SymbolDisambiguator.html\n-// @has - '//a[@href=\"../disambiguators_removed/fn.Name.html\"][code]' \"Name()\"\n-// @has - '//a[@href=\"../disambiguators_removed/macro.Name.html\"][code]' \"Name!\"\n+// @has - '//a[@href=\"fn.Name.html\"][code]' \"Name()\"\n+// @has - '//a[@href=\"macro.Name.html\"][code]' \"Name!\"\n pub struct SymbolDisambiguator;\n \n // Now make sure that backticks aren't added if they weren't already there\n /// [fn@Name]\n // @has disambiguators_removed/trait.Name.html\n-// @has - '//a[@href=\"../disambiguators_removed/fn.Name.html\"]' \"Name\"\n-// @!has - '//a[@href=\"../disambiguators_removed/fn.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"fn.Name.html\"]' \"Name\"\n+// @!has - '//a[@href=\"fn.Name.html\"][code]' \"Name\"\n \n // FIXME: this will turn !() into ! alone\n /// [Name!()]\n-// @has - '//a[@href=\"../disambiguators_removed/macro.Name.html\"]' \"Name!\"\n+// @has - '//a[@href=\"macro.Name.html\"]' \"Name!\"\n pub trait Name {}\n \n #[allow(non_snake_case)]\n \n // Try collapsed reference links\n /// [macro@Name][]\n // @has disambiguators_removed/fn.Name.html\n-// @has - '//a[@href=\"../disambiguators_removed/macro.Name.html\"]' \"Name\"\n+// @has - '//a[@href=\"macro.Name.html\"]' \"Name\"\n \n // Try links that have the same text as a generated URL\n-/// Weird URL aligned [../disambiguators_removed/macro.Name.html][trait@Name]\n-// @has - '//a[@href=\"../disambiguators_removed/trait.Name.html\"]' \"../disambiguators_removed/macro.Name.html\"\n+/// Weird URL aligned [macro.Name.html][trait@Name]\n+// @has - '//a[@href=\"trait.Name.html\"]' \"macro.Name.html\"\n pub fn Name() {}\n \n #[macro_export]\n // Rustdoc doesn't currently handle links that have weird interspersing of inline code blocks.\n /// [fn@Na`m`e]\n // @has disambiguators_removed/macro.Name.html\n-// @has - '//a[@href=\"../disambiguators_removed/fn.Name.html\"]' \"fn@Name\"\n+// @has - '//a[@href=\"fn.Name.html\"]' \"fn@Name\"\n \n // It also doesn't handle any case where the code block isn't the whole link text:\n /// [trait@`Name`]\n-// @has - '//a[@href=\"../disambiguators_removed/trait.Name.html\"]' \"trait@Name\"\n+// @has - '//a[@href=\"trait.Name.html\"]' \"trait@Name\"\n macro_rules! Name {\n     () => ()\n }"}, {"sha": "2270a1fafa1cb8dd75d3a971a89aa5d45ba39849", "filename": "src/test/rustdoc/intra-doc/enum-struct-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fenum-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fenum-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fenum-struct-field.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -11,4 +11,4 @@ pub enum Foo {\n /// I want [Foo::X::y].\n pub fn foo() {}\n \n-// @has foo/fn.foo.html '//a/@href' '../foo/enum.Foo.html#variant.X.field.y'\n+// @has foo/fn.foo.html '//a/@href' 'enum.Foo.html#variant.X.field.y'"}, {"sha": "f37ae62dde1aa45076563fe149bdbb9fc323dc06", "filename": "src/test/rustdoc/intra-doc/extern-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-type.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -12,6 +12,6 @@ impl ExternType {\n \n // @has 'extern_type/foreigntype.ExternType.html'\n // @has 'extern_type/fn.links_to_extern_type.html' \\\n-// 'href=\"../extern_type/foreigntype.ExternType.html#method.f\"'\n+// 'href=\"foreigntype.ExternType.html#method.f\"'\n /// See also [ExternType::f]\n pub fn links_to_extern_type() {}"}, {"sha": "68a5672a8d2091e6ca3c3a7c53fbef0cf59a1e1e", "filename": "src/test/rustdoc/intra-doc/issue-82209.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fissue-82209.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fissue-82209.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fissue-82209.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -8,4 +8,4 @@ pub enum Foo {\n     },\n }\n \n-// @has foo/enum.Foo.html '//a/@href' '../foo/enum.Foo.html#variant.Bar.field.abc'\n+// @has foo/enum.Foo.html '//a/@href' 'enum.Foo.html#variant.Bar.field.abc'"}, {"sha": "24b9dc30a9e496cd50123c6522e829f8540f085a", "filename": "src/test/rustdoc/intra-doc/mod-ambiguity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fmod-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fmod-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fmod-ambiguity.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -6,11 +6,11 @@ pub fn foo() {\n }\n \n pub mod foo {}\n-// @has mod_ambiguity/struct.A.html '//a/@href' '../mod_ambiguity/foo/index.html'\n+// @has mod_ambiguity/struct.A.html '//a/@href' 'foo/index.html'\n /// Module is [`module@foo`]\n pub struct A;\n \n \n-// @has mod_ambiguity/struct.B.html '//a/@href' '../mod_ambiguity/fn.foo.html'\n+// @has mod_ambiguity/struct.B.html '//a/@href' 'fn.foo.html'\n /// Function is [`fn@foo`]\n pub struct B;"}, {"sha": "478b40b0b516fb9c3b19bfbbb78312019f16eed1", "filename": "src/test/rustdoc/intra-doc/prim-precedence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-precedence.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -11,6 +11,6 @@ pub mod char {\n pub struct MyString;\n \n /// See also [crate::char] and [mod@char]\n-// @has prim_precedence/struct.MyString2.html '//*[@href=\"../prim_precedence/char/index.html\"]' 'crate::char'\n-// @has - '//*[@href=\"../prim_precedence/char/index.html\"]' 'mod@char'\n+// @has prim_precedence/struct.MyString2.html '//*[@href=\"char/index.html\"]' 'crate::char'\n+// @has - '//*[@href=\"char/index.html\"]' 'mod@char'\n pub struct MyString2;"}, {"sha": "2756a7998e8ea42cdb580578b8b0cc17a6e26b4e", "filename": "src/test/rustdoc/intra-doc/private.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -4,9 +4,9 @@\n // make sure to update `rustdoc-ui/intra-doc/private.rs` if you update this file\n \n /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n-// @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html\"]' 'DontDocMe'\n-// @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html#method.f\"]' 'DontDocMe::f'\n-// @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html#structfield.x\"]' 'DontDocMe::x'\n+// @has private/struct.DocMe.html '//*a[@href=\"struct.DontDocMe.html\"]' 'DontDocMe'\n+// @has private/struct.DocMe.html '//*a[@href=\"struct.DontDocMe.html#method.f\"]' 'DontDocMe::f'\n+// @has private/struct.DocMe.html '//*a[@href=\"struct.DontDocMe.html#structfield.x\"]' 'DontDocMe::x'\n pub struct DocMe;\n struct DontDocMe {\n     x: usize,"}, {"sha": "fce10a130be655a70684bf0809caae5fdc20b94b", "filename": "src/test/rustdoc/intra-doc/proc-macro.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fproc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fproc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fproc-macro.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -9,17 +9,17 @@ pub use proc_macro_macro::{DeriveA, attr_a};\n use proc_macro_macro::{DeriveB, attr_b};\n \n // @has proc_macro/struct.Foo.html\n-// @has - '//a/@href' '../proc_macro/derive.DeriveA.html'\n-// @has - '//a/@href' '../proc_macro/attr.attr_a.html'\n-// @has - '//a/@href' '../proc_macro/trait.DeriveTrait.html'\n+// @has - '//a/@href' 'derive.DeriveA.html'\n+// @has - '//a/@href' 'attr.attr_a.html'\n+// @has - '//a/@href' 'trait.DeriveTrait.html'\n // @has - '//a/@href' '../proc_macro_macro/derive.DeriveB.html'\n // @has - '//a/@href' '../proc_macro_macro/attr.attr_b.html'\n /// Link to [DeriveA], [attr_a], [DeriveB], [attr_b], [DeriveTrait]\n pub struct Foo;\n \n // @has proc_macro/struct.Bar.html\n-// @has - '//a/@href' '../proc_macro/derive.DeriveA.html'\n-// @has - '//a/@href' '../proc_macro/attr.attr_a.html'\n+// @has - '//a/@href' 'derive.DeriveA.html'\n+// @has - '//a/@href' 'attr.attr_a.html'\n /// Link to [deriveA](derive@DeriveA) [attr](macro@attr_a)\n pub struct Bar;\n "}, {"sha": "579fa68cee8be37d1ff4e5b2a5516e77e4f0a682", "filename": "src/test/rustdoc/intra-doc/pub-use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fpub-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fpub-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fpub-use.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -13,7 +13,7 @@ extern crate inner;\n \n // @has outer/index.html\n // @ has - '//a[@href=\"https://doc.rust-lang.org/nightly/std/env/fn.var.html\"]' \"std::env\"\n-// @ has - '//a[@href=\"../outer/fn.f.html\"]' \"g\"\n+// @ has - '//a[@href=\"fn.f.html\"]' \"g\"\n pub use f as g;\n \n // FIXME: same as above"}, {"sha": "177c3016fb1515728f54073540a3a0bda841d4e8", "filename": "src/test/rustdoc/intra-doc/raw-ident-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fraw-ident-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fraw-ident-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fraw-ident-self.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -5,7 +5,7 @@ pub mod r#impl {\n     impl S {\n         /// See [Self::b].\n         // @has raw_ident_self/impl/struct.S.html\n-        // @has - '//a[@href=\"../../raw_ident_self/impl/struct.S.html#method.b\"]' 'Self::b'\n+        // @has - '//a[@href=\"struct.S.html#method.b\"]' 'Self::b'\n         pub fn a() {}\n \n         pub fn b() {}"}, {"sha": "64683bacd6513838fdc3a001f1fb3e61aebb08bd", "filename": "src/test/rustdoc/intra-doc/reexport-additional-docs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Freexport-additional-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Freexport-additional-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Freexport-additional-docs.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -3,13 +3,13 @@\n #![crate_name = \"foo\"]\n extern crate inner;\n \n-// @has foo/struct.Inner.html '//a[@href=\"../foo/fn.with_code.html\"]' 'crate::with_code'\n+// @has foo/struct.Inner.html '//a[@href=\"fn.with_code.html\"]' 'crate::with_code'\n /// [crate::with_code]\n-// @has - '//a[@href=\"../foo/fn.with_code.html\"]' 'different text'\n+// @has - '//a[@href=\"fn.with_code.html\"]' 'different text'\n /// [different text][with_code]\n-// @has - '//a[@href=\"../foo/fn.me_too.html\"]' 'me_too'\n+// @has - '//a[@href=\"fn.me_too.html\"]' 'me_too'\n #[doc = \"[me_too]\"]\n-// @has - '//a[@href=\"../foo/fn.me_three.html\"]' 'reference link'\n+// @has - '//a[@href=\"fn.me_three.html\"]' 'reference link'\n /// This [reference link]\n #[doc = \"has an attr in the way\"]\n ///"}, {"sha": "0ba7df8a78ad75a57016a09e88f1c676a9f615c9", "filename": "src/test/rustdoc/intra-doc/self.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fself.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Fself.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fself.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -1,8 +1,8 @@\n #![crate_name = \"foo\"]\n \n \n-// @has foo/index.html '//a/@href' '../foo/struct.Foo.html#method.new'\n-// @has foo/struct.Foo.html '//a/@href' '../foo/struct.Foo.html#method.new'\n+// @has foo/index.html '//a/@href' 'struct.Foo.html#method.new'\n+// @has foo/struct.Foo.html '//a/@href' 'struct.Foo.html#method.new'\n \n /// Use [`new`] to create a new instance.\n ///\n@@ -15,8 +15,8 @@ impl Foo {\n     }\n }\n \n-// @has foo/index.html '//a/@href' '../foo/struct.Bar.html#method.new2'\n-// @has foo/struct.Bar.html '//a/@href' '../foo/struct.Bar.html#method.new2'\n+// @has foo/index.html '//a/@href' 'struct.Bar.html#method.new2'\n+// @has foo/struct.Bar.html '//a/@href' 'struct.Bar.html#method.new2'\n \n /// Use [`new2`] to create a new instance.\n ///\n@@ -30,7 +30,7 @@ impl Bar {\n }\n \n pub struct MyStruct {\n-    // @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#structfield.struct_field'\n+    // @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#structfield.struct_field'\n \n     /// [`struct_field`]\n     ///\n@@ -39,7 +39,7 @@ pub struct MyStruct {\n }\n \n pub enum MyEnum {\n-    // @has foo/enum.MyEnum.html '//a/@href' '../foo/enum.MyEnum.html#variant.EnumVariant'\n+    // @has foo/enum.MyEnum.html '//a/@href' 'enum.MyEnum.html#variant.EnumVariant'\n \n     /// [`EnumVariant`]\n     ///\n@@ -48,7 +48,7 @@ pub enum MyEnum {\n }\n \n pub union MyUnion {\n-    // @has foo/union.MyUnion.html '//a/@href' '../foo/union.MyUnion.html#structfield.union_field'\n+    // @has foo/union.MyUnion.html '//a/@href' 'union.MyUnion.html#structfield.union_field'\n \n     /// [`union_field`]\n     ///\n@@ -57,21 +57,21 @@ pub union MyUnion {\n }\n \n pub trait MyTrait {\n-    // @has foo/trait.MyTrait.html '//a/@href' '../foo/trait.MyTrait.html#associatedtype.AssoType'\n+    // @has foo/trait.MyTrait.html '//a/@href' 'trait.MyTrait.html#associatedtype.AssoType'\n \n     /// [`AssoType`]\n     ///\n     /// [`AssoType`]: Self::AssoType\n     type AssoType;\n \n-    // @has foo/trait.MyTrait.html '//a/@href' '../foo/trait.MyTrait.html#associatedconstant.ASSO_CONST'\n+    // @has foo/trait.MyTrait.html '//a/@href' 'trait.MyTrait.html#associatedconstant.ASSO_CONST'\n \n     /// [`ASSO_CONST`]\n     ///\n     /// [`ASSO_CONST`]: Self::ASSO_CONST\n     const ASSO_CONST: i32 = 1;\n \n-    // @has foo/trait.MyTrait.html '//a/@href' '../foo/trait.MyTrait.html#method.asso_fn'\n+    // @has foo/trait.MyTrait.html '//a/@href' 'trait.MyTrait.html#method.asso_fn'\n \n     /// [`asso_fn`]\n     ///\n@@ -80,7 +80,7 @@ pub trait MyTrait {\n }\n \n impl MyStruct {\n-    // @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#method.for_impl'\n+    // @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#method.for_impl'\n \n     /// [`for_impl`]\n     ///\n@@ -91,21 +91,21 @@ impl MyStruct {\n }\n \n impl MyTrait for MyStruct {\n-    // @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#associatedtype.AssoType'\n+    // @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#associatedtype.AssoType'\n \n     /// [`AssoType`]\n     ///\n     /// [`AssoType`]: Self::AssoType\n     type AssoType = u32;\n \n-    // @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#associatedconstant.ASSO_CONST'\n+    // @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#associatedconstant.ASSO_CONST'\n \n     /// [`ASSO_CONST`]\n     ///\n     /// [`ASSO_CONST`]: Self::ASSO_CONST\n     const ASSO_CONST: i32 = 10;\n \n-    // @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#method.asso_fn'\n+    // @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#method.asso_fn'\n \n     /// [`asso_fn`]\n     ///"}, {"sha": "cf60dc1dbd50ec11c6e9a5802f1e48c2885c318e", "filename": "src/test/rustdoc/intra-doc/trait-impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Ftrait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Ftrait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Ftrait-impl.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -5,21 +5,21 @@ pub struct MyStruct;\n \n impl MyTrait for MyStruct {\n \n-// @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#associatedtype.AssoType'\n+// @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#associatedtype.AssoType'\n \n     /// [`AssoType`]\n     ///\n     /// [`AssoType`]: MyStruct::AssoType\n     type AssoType = u32;\n \n-// @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#associatedconstant.ASSO_CONST'\n+// @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#associatedconstant.ASSO_CONST'\n \n     /// [`ASSO_CONST`]\n     ///\n     /// [`ASSO_CONST`]: MyStruct::ASSO_CONST\n     const ASSO_CONST: i32 = 10;\n \n-// @has foo/struct.MyStruct.html '//a/@href' '../foo/struct.MyStruct.html#method.trait_fn'\n+// @has foo/struct.MyStruct.html '//a/@href' 'struct.MyStruct.html#method.trait_fn'\n \n     /// [`trait_fn`]\n     ///"}, {"sha": "7602aced56416ba9a002a87b3ac142238c28edaf", "filename": "src/test/rustdoc/intra-doc/trait-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Ftrait-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-doc%2Ftrait-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Ftrait-item.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -2,7 +2,7 @@\n \n /// Link to [S::assoc_fn()]\n /// Link to [Default::default()]\n-// @has trait_item/struct.S.html '//*[@href=\"../trait_item/struct.S.html#method.assoc_fn\"]' 'S::assoc_fn()'\n+// @has trait_item/struct.S.html '//*[@href=\"struct.S.html#method.assoc_fn\"]' 'S::assoc_fn()'\n // @has - '//*[@href=\"https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default\"]' 'Default::default()'\n pub struct S;\n "}, {"sha": "63bf7fa5768a718992c85318e13a0dc197481b75", "filename": "src/test/rustdoc/intra-link-self-cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-link-self-cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fintra-link-self-cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-self-cache.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -1,12 +1,12 @@\n #![crate_name = \"foo\"]\n-// @has foo/enum.E1.html '//a/@href' '../foo/enum.E1.html#variant.A'\n+// @has foo/enum.E1.html '//a/@href' 'enum.E1.html#variant.A'\n \n /// [Self::A::b]\n pub enum E1 {\n     A { b: usize }\n }\n \n-// @has foo/enum.E2.html '//a/@href' '../foo/enum.E2.html#variant.A'\n+// @has foo/enum.E2.html '//a/@href' 'enum.E2.html#variant.A'\n \n /// [Self::A::b]\n pub enum E2 {"}, {"sha": "497276e6826a1acc1556ae1b22bfeddef74a47b9", "filename": "src/test/rustdoc/issue-28478.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fissue-28478.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fissue-28478.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-28478.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -23,9 +23,9 @@ impl Foo {\n }\n \n impl Bar for Foo {\n-    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#associatedtype.Bar\"]' 'Bar'\n-    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#associatedconstant.Baz\"]' 'Baz'\n-    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#tymethod.bar\"]' 'bar'\n+    // @has - '//*[@href=\"trait.Bar.html#associatedtype.Bar\"]' 'Bar'\n+    // @has - '//*[@href=\"trait.Bar.html#associatedconstant.Baz\"]' 'Baz'\n+    // @has - '//*[@href=\"trait.Bar.html#tymethod.bar\"]' 'bar'\n     fn bar() {}\n-    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#method.baz\"]' 'baz'\n+    // @has - '//*[@href=\"trait.Bar.html#method.baz\"]' 'baz'\n }"}, {"sha": "f156d225bd79b5ee9c3846522f6d9781fdd2c9bf", "filename": "src/test/rustdoc/issue-55364.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fissue-55364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fissue-55364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-55364.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -2,19 +2,19 @@\n \n // @has issue_55364/subone/index.html\n // These foo/bar links in the module's documentation should refer inside `subone`\n-// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subone/fn.foo.html\"]' 'foo'\n-// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subone/fn.bar.html\"]' 'bar'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.foo.html\"]' 'foo'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.bar.html\"]' 'bar'\n pub mod subone {\n     //! See either [foo] or [bar].\n \n     // This should refer to subone's `bar`\n     // @has issue_55364/subone/fn.foo.html\n-    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subone/fn.bar.html\"]' 'bar'\n+    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.bar.html\"]' 'bar'\n     /// See [bar]\n     pub fn foo() {}\n     // This should refer to subone's `foo`\n     // @has issue_55364/subone/fn.bar.html\n-    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subone/fn.foo.html\"]' 'foo'\n+    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.foo.html\"]' 'foo'\n     /// See [foo]\n     pub fn bar() {}\n }\n@@ -23,11 +23,11 @@ pub mod subone {\n \n // @has issue_55364/subtwo/index.html\n // These foo/bar links in the module's documentation should not reference inside `subtwo`\n-// @!has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subtwo/fn.foo.html\"]' 'foo'\n-// @!has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subtwo/fn.bar.html\"]' 'bar'\n+// @!has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.foo.html\"]' 'foo'\n+// @!has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.bar.html\"]' 'bar'\n // Instead it should be referencing the top level functions\n-// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/fn.foo.html\"]' 'foo'\n-// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/fn.bar.html\"]' 'bar'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../fn.foo.html\"]' 'foo'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../fn.bar.html\"]' 'bar'\n // Though there should be such links later\n // @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td/a[@class=\"fn\"][@href=\"fn.foo.html\"]' 'foo'\n // @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td/a[@class=\"fn\"][@href=\"fn.bar.html\"]' 'bar'\n@@ -37,13 +37,13 @@ pub mod subtwo {\n     // Despite the module's docs referring to the top level foo/bar,\n     // this should refer to subtwo's `bar`\n     // @has issue_55364/subtwo/fn.foo.html\n-    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subtwo/fn.bar.html\"]' 'bar'\n+    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.bar.html\"]' 'bar'\n     /// See [bar]\n     pub fn foo() {}\n     // Despite the module's docs referring to the top level foo/bar,\n     // this should refer to subtwo's `foo`\n     // @has issue_55364/subtwo/fn.bar.html\n-    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/subtwo/fn.foo.html\"]' 'foo'\n+    // @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"fn.foo.html\"]' 'foo'\n     /// See [foo]\n     pub fn bar() {}\n }\n@@ -59,17 +59,17 @@ pub fn bar() {}\n \n // @has issue_55364/subthree/index.html\n // This module should also refer to the top level foo/bar\n-// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/fn.foo.html\"]' 'foo'\n-// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../../issue_55364/fn.bar.html\"]' 'bar'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../fn.foo.html\"]' 'foo'\n+// @has - '//section[@id=\"main\"]/div[@class=\"docblock\"]//a[@href=\"../fn.bar.html\"]' 'bar'\n pub mod subthree {\n     //! See either [foo][super::foo] or [bar][super::bar]\n }\n \n // Next we go *deeper* - In order to ensure it's not just \"this or parent\"\n // we test `crate::` and a `super::super::...` chain\n // @has issue_55364/subfour/subfive/subsix/subseven/subeight/index.html\n-// @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td[@class=\"docblock-short\"]//a[@href=\"../../../../../../issue_55364/subone/fn.foo.html\"]' 'other foo'\n-// @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td[@class=\"docblock-short\"]//a[@href=\"../../../../../../issue_55364/subtwo/fn.bar.html\"]' 'other bar'\n+// @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td[@class=\"docblock-short\"]//a[@href=\"../../../../../subone/fn.foo.html\"]' 'other foo'\n+// @has - '//section[@id=\"main\"]/table//tr[@class=\"module-item\"]/td[@class=\"docblock-short\"]//a[@href=\"../../../../../subtwo/fn.bar.html\"]' 'other bar'\n pub mod subfour {\n     pub mod subfive {\n         pub mod subsix {"}, {"sha": "64044cfe94720f5531b77147f04560653104b042", "filename": "src/test/rustdoc/issue-72340.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fissue-72340.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fissue-72340.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-72340.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -10,7 +10,7 @@ impl Body {\n }\n \n impl Default for Body {\n-    // @has foo/struct.Body.html '//a/@href' '../foo/struct.Body.html#method.empty'\n+    // @has foo/struct.Body.html '//a/@href' 'struct.Body.html#method.empty'\n \n     /// Returns [`Body::empty()`](Body::empty).\n     fn default() -> Body {"}, {"sha": "75a2531a308f7d95d31d703bee35a99682e2efb3", "filename": "src/test/rustdoc/link-assoc-const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Flink-assoc-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Flink-assoc-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Flink-assoc-const.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -1,7 +1,7 @@\n #![crate_name = \"foo\"]\n \n-// @has foo/index.html '//a[@href=\"../foo/foo/constant.FIRSTCONST.html\"]' 'foo::FIRSTCONST'\n-// @has foo/index.html '//a[@href=\"../foo/struct.Bar.html#associatedconstant.CONST\"]' 'Bar::CONST'\n+// @has foo/index.html '//a[@href=\"foo/constant.FIRSTCONST.html\"]' 'foo::FIRSTCONST'\n+// @has foo/index.html '//a[@href=\"struct.Bar.html#associatedconstant.CONST\"]' 'Bar::CONST'\n \n //! We have here [`foo::FIRSTCONST`] and [`Bar::CONST`].\n "}, {"sha": "f6d1f2cf91b5fca1915212708a47ee68c3d6473b", "filename": "src/test/rustdoc/proc-macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fproc-macro.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -61,12 +61,12 @@ pub fn some_derive(_item: TokenStream) -> TokenStream {\n // @has some_macros/foo/index.html\n mod foo {\n     // @has - '//code' 'pub use some_proc_macro;'\n-    // @has - '//a/@href' '../../some_macros/macro.some_proc_macro.html'\n+    // @has - '//a/@href' '../macro.some_proc_macro.html'\n     pub use some_proc_macro;\n     // @has - '//code' 'pub use some_proc_attr;'\n-    // @has - '//a/@href' '../../some_macros/attr.some_proc_attr.html'\n+    // @has - '//a/@href' '../attr.some_proc_attr.html'\n     pub use some_proc_attr;\n     // @has - '//code' 'pub use some_derive;'\n-    // @has - '//a/@href' '../../some_macros/derive.SomeDerive.html'\n+    // @has - '//a/@href' '../derive.SomeDerive.html'\n     pub use some_derive;\n }"}, {"sha": "ad190361267606a0e514d7ee23f93eb5ce12de94", "filename": "src/test/rustdoc/raw-ident-eliminate-r-hashtag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fraw-ident-eliminate-r-hashtag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fraw-ident-eliminate-r-hashtag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fraw-ident-eliminate-r-hashtag.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -8,13 +8,13 @@ pub mod internal {\n     ///\n     /// [name]: mod\n     /// [other name]: crate::internal::mod\n-    // @has 'raw_ident_eliminate_r_hashtag/internal/struct.B.html' '//*a[@href=\"../../raw_ident_eliminate_r_hashtag/internal/struct.mod.html\"]' 'name'\n-    // @has 'raw_ident_eliminate_r_hashtag/internal/struct.B.html' '//*a[@href=\"../../raw_ident_eliminate_r_hashtag/internal/struct.mod.html\"]' 'other name'\n+    // @has 'raw_ident_eliminate_r_hashtag/internal/struct.B.html' '//*a[@href=\"struct.mod.html\"]' 'name'\n+    // @has 'raw_ident_eliminate_r_hashtag/internal/struct.B.html' '//*a[@href=\"struct.mod.html\"]' 'other name'\n     pub struct B;\n }\n \n /// See [name].\n ///\n /// [name]: internal::mod\n-// @has 'raw_ident_eliminate_r_hashtag/struct.A.html' '//*a[@href=\"../raw_ident_eliminate_r_hashtag/internal/struct.mod.html\"]' 'name'\n+// @has 'raw_ident_eliminate_r_hashtag/struct.A.html' '//*a[@href=\"internal/struct.mod.html\"]' 'name'\n pub struct A;"}, {"sha": "998683bdde7f27236af2fedf949f96fa81822ca5", "filename": "src/test/rustdoc/struct-field.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fstruct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Fstruct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstruct-field.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -1,9 +1,9 @@\n #![crate_name = \"foo\"]\n \n \n-// @has foo/index.html '//*[@class=\"docblock\"]/p/a[@href=\"../foo/struct.Foo.html#structfield.bar\"]' 'Foo::bar'\n-// @has foo/index.html '//*[@class=\"docblock\"]/p/a[@href=\"../foo/union.Bar.html#structfield.foo\"]' 'Bar::foo'\n-// @has foo/index.html '//*[@class=\"docblock\"]/p/a[@href=\"../foo/enum.Uniooon.html#variant.X\"]' 'Uniooon::X'\n+// @has foo/index.html '//*[@class=\"docblock\"]/p/a[@href=\"struct.Foo.html#structfield.bar\"]' 'Foo::bar'\n+// @has foo/index.html '//*[@class=\"docblock\"]/p/a[@href=\"union.Bar.html#structfield.foo\"]' 'Bar::foo'\n+// @has foo/index.html '//*[@class=\"docblock\"]/p/a[@href=\"enum.Uniooon.html#variant.X\"]' 'Uniooon::X'\n \n //! Test with [Foo::bar], [Bar::foo], [Uniooon::X]\n "}, {"sha": "c6a9313e821c9562fc55c2b952829b52d0d37cbc", "filename": "src/test/rustdoc/trait-impl-items-links-and-anchors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Ftrait-impl-items-links-and-anchors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Ftrait-impl-items-links-and-anchors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftrait-impl-items-links-and-anchors.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -40,25 +40,25 @@ impl MyTrait for Vec<u8> {\n impl MyTrait for MyStruct {\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"associatedtype.Assoc-3\"]//a[@class=\"type\"]/@href' #associatedtype.Assoc\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"associatedtype.Assoc-3\"]//a[@class=\"anchor\"]/@href' #associatedtype.Assoc-3\n-    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"associatedtype.Assoc\"]//a[@class=\"type\"]/@href' ../trait_impl_items_links_and_anchors/trait.MyTrait.html#associatedtype.Assoc\n+    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"associatedtype.Assoc\"]//a[@class=\"type\"]/@href' trait.MyTrait.html#associatedtype.Assoc\n     // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"associatedtype.Assoc\"]//a[@class=\"anchor\"]/@href' #associatedtype.Assoc\n     type Assoc = bool;\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"associatedconstant.VALUE-3\"]//a[@class=\"constant\"]/@href' #associatedconstant.VALUE\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"associatedconstant.VALUE-3\"]//a[@class=\"anchor\"]/@href' #associatedconstant.VALUE-3\n-    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"associatedconstant.VALUE\"]//a[@class=\"constant\"]/@href' ../trait_impl_items_links_and_anchors/trait.MyTrait.html#associatedconstant.VALUE\n+    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"associatedconstant.VALUE\"]//a[@class=\"constant\"]/@href' trait.MyTrait.html#associatedconstant.VALUE\n     // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"associatedconstant.VALUE\"]//a[@class=\"anchor\"]/@href' #associatedconstant.VALUE\n     const VALUE: u32 = 20;\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"method.trait_function-2\"]//a[@class=\"fnname\"]/@href' #tymethod.trait_function\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"method.trait_function-2\"]//a[@class=\"anchor\"]/@href' #method.trait_function-2\n-    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.trait_function\"]//a[@class=\"fnname\"]/@href' ../trait_impl_items_links_and_anchors/trait.MyTrait.html#tymethod.trait_function\n+    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.trait_function\"]//a[@class=\"fnname\"]/@href' trait.MyTrait.html#tymethod.trait_function\n     // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.trait_function\"]//a[@class=\"anchor\"]/@href' #method.trait_function\n     fn trait_function(&self) {}\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"method.defaulted_override-3\"]//a[@class=\"fnname\"]/@href' #method.defaulted_override\n     // @has trait_impl_items_links_and_anchors/trait.MyTrait.html '//h4[@id=\"method.defaulted_override-3\"]//a[@class=\"anchor\"]/@href' #method.defaulted_override-3\n-    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.defaulted_override\"]//a[@class=\"fnname\"]/@href' ../trait_impl_items_links_and_anchors/trait.MyTrait.html#method.defaulted_override\n+    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.defaulted_override\"]//a[@class=\"fnname\"]/@href' trait.MyTrait.html#method.defaulted_override\n     // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.defaulted_override\"]//a[@class=\"anchor\"]/@href' #method.defaulted_override\n     fn defaulted_override(&self) {}\n-    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.defaulted\"]//a[@class=\"fnname\"]/@href' ../trait_impl_items_links_and_anchors/trait.MyTrait.html#method.defaulted\n+    // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.defaulted\"]//a[@class=\"fnname\"]/@href' trait.MyTrait.html#method.defaulted\n     // @has trait_impl_items_links_and_anchors/struct.MyStruct.html '//h4[@id=\"method.defaulted\"]//a[@class=\"anchor\"]/@href' #method.defaulted\n }\n "}, {"sha": "e311dadff0e637f1393573cbbc00a4600df289cc", "filename": "src/test/rustdoc/trait-self-link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Ftrait-self-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6516f9408ef47137e070c2635b9f4a67d848f129/src%2Ftest%2Frustdoc%2Ftrait-self-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftrait-self-link.rs?ref=6516f9408ef47137e070c2635b9f4a67d848f129", "patch": "@@ -1,4 +1,4 @@\n-// @has trait_self_link/trait.Foo.html //a/@href ../trait_self_link/trait.Foo.html\n+// @has trait_self_link/trait.Foo.html //a/@href trait.Foo.html\n pub trait Foo {}\n \n pub struct Bar;"}]}