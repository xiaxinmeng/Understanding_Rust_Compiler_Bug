{"sha": "48cc11631ca358fe6cd3fec3daf1e9c1d132a810", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4Y2MxMTYzMWNhMzU4ZmU2Y2QzZmVjM2RhZjFlOWMxZDEzMmE4MTA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-29T13:01:06Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-29T13:01:06Z"}, "message": "Parse anonymous objs in statement position\n\nCloses #761", "tree": {"sha": "2388b4a6fce2b6b1bbca2f4f3894fcd78aba0edc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2388b4a6fce2b6b1bbca2f4f3894fcd78aba0edc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48cc11631ca358fe6cd3fec3daf1e9c1d132a810", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48cc11631ca358fe6cd3fec3daf1e9c1d132a810", "html_url": "https://github.com/rust-lang/rust/commit/48cc11631ca358fe6cd3fec3daf1e9c1d132a810", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48cc11631ca358fe6cd3fec3daf1e9c1d132a810/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "451ec03c2df60c26f888cd9762b6f416415a38fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/451ec03c2df60c26f888cd9762b6f416415a38fb", "html_url": "https://github.com/rust-lang/rust/commit/451ec03c2df60c26f888cd9762b6f416415a38fb"}], "stats": {"total": 53, "additions": 21, "deletions": 32}, "files": [{"sha": "6c3f04d1c87c71f439ab03310de0808bd430bcaf", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 32, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/48cc11631ca358fe6cd3fec3daf1e9c1d132a810/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48cc11631ca358fe6cd3fec3daf1e9c1d132a810/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=48cc11631ca358fe6cd3fec3daf1e9c1d132a810", "patch": "@@ -883,8 +883,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n \n         // We don't need to pull \".node\" out of fields because it's not a\n         // \"spanned\".\n-        let ob: ast::anon_obj =\n-            {fields: fields, methods: meths, inner_obj: inner_obj};\n+        let ob = {fields: fields, methods: meths, inner_obj: inner_obj};\n         ex = ast::expr_anon_obj(ob);\n     } else if (eat_word(p, \"bind\")) {\n         let e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n@@ -1554,27 +1553,20 @@ fn parse_source_stmt(p: &parser) -> @ast::stmt {\n         // If we have attributes then we should have an item\n         if ivec::len(item_attrs) > 0u {\n             alt maybe_item {\n-              got_item(_) {/* fallthrough */ }\n+              some(_) {/* fallthrough */ }\n               _ { ret p.fatal(\"expected item\"); }\n             }\n         }\n \n \n         alt maybe_item {\n-          got_item(i) {\n+          some(i) {\n             let hi = i.span.hi;\n             let decl = @spanned(lo, hi, ast::decl_item(i));\n             ret @spanned(lo, hi, ast::stmt_decl(decl, p.get_id()));\n           }\n-          fn_no_item. { // parse_item will have already skipped \"fn\"\n-\n-            let e = parse_fn_expr(p, ast::proto_fn);\n-            e = parse_dot_or_call_expr_with(p, e);\n-            ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_id()));\n-          }\n-          no_item. {\n+          none. {\n             // Remainder are line-expr stmts.\n-\n             let e = parse_expr(p);\n             ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_id()));\n           }\n@@ -1873,7 +1865,7 @@ fn parse_mod_items(p: &parser, term: token::token,\n         let attrs = initial_attrs + parse_outer_attributes(p);\n         initial_attrs = ~[];\n         alt parse_item(p, attrs) {\n-          got_item(i) { items += ~[i]; }\n+          some(i) { items += ~[i]; }\n           _ {\n             p.fatal(\"expected item but found \" +\n                         token::to_str(p.get_reader(), p.peek()));\n@@ -2082,37 +2074,34 @@ fn parse_auth(p: &parser) -> ast::_auth {\n     fail;\n }\n \n-tag parsed_item { got_item(@ast::item); no_item; fn_no_item; }\n-\n-fn parse_item(p: &parser, attrs: &ast::attribute[]) -> parsed_item {\n+fn parse_item(p: &parser, attrs: &ast::attribute[]) -> option::t[@ast::item] {\n     if eat_word(p, \"const\") {\n-        ret got_item(parse_item_const(p, attrs));\n-    } else if (eat_word(p, \"fn\")) {\n-        // This is an anonymous function\n-\n-        if p.peek() == token::LPAREN { ret fn_no_item; }\n-        ret got_item(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_fn,\n+        ret some(parse_item_const(p, attrs));\n+    } else if (is_word(p, \"fn\") && p.look_ahead(1u) != token::LPAREN) {\n+        p.bump();\n+        ret some(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_fn,\n                                            attrs));\n     } else if (eat_word(p, \"pred\")) {\n-        ret got_item(parse_item_fn_or_iter(p, ast::pure_fn, ast::proto_fn,\n+        ret some(parse_item_fn_or_iter(p, ast::pure_fn, ast::proto_fn,\n                                            attrs));\n     } else if (eat_word(p, \"iter\")) {\n-        ret got_item(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_iter,\n+        ret some(parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_iter,\n                                            attrs));\n     } else if (eat_word(p, \"mod\")) {\n-        ret got_item(parse_item_mod(p, attrs));\n+        ret some(parse_item_mod(p, attrs));\n     } else if (eat_word(p, \"native\")) {\n-        ret got_item(parse_item_native_mod(p, attrs));\n+        ret some(parse_item_native_mod(p, attrs));\n     }\n     if eat_word(p, \"type\") {\n-        ret got_item(parse_item_type(p, attrs));\n+        ret some(parse_item_type(p, attrs));\n     } else if (eat_word(p, \"tag\")) {\n-        ret got_item(parse_item_tag(p, attrs));\n-    } else if (eat_word(p, \"obj\")) {\n-        ret got_item(parse_item_obj(p, attrs));\n+        ret some(parse_item_tag(p, attrs));\n+    } else if (is_word(p, \"obj\") && p.look_ahead(1u) != token::LPAREN) {\n+        p.bump();\n+        ret some(parse_item_obj(p, attrs));\n     } else if (eat_word(p, \"resource\")) {\n-        ret got_item(parse_item_res(p, attrs));\n-    } else { ret no_item; }\n+        ret some(parse_item_res(p, attrs));\n+    } else { ret none; }\n }\n \n // A type to distingush between the parsing of item attributes or syntax"}]}