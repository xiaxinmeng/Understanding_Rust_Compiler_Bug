{"sha": "044b07dd2089d8e3786c5939fc948710d722845f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NGIwN2RkMjA4OWQ4ZTM3ODZjNTkzOWZjOTQ4NzEwZDcyMjg0NWY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-01T01:00:08Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-20T10:37:15Z"}, "message": "Update to last master", "tree": {"sha": "06a46bd190fd4e62e55faf00b1760677235901ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06a46bd190fd4e62e55faf00b1760677235901ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/044b07dd2089d8e3786c5939fc948710d722845f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/044b07dd2089d8e3786c5939fc948710d722845f", "html_url": "https://github.com/rust-lang/rust/commit/044b07dd2089d8e3786c5939fc948710d722845f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/044b07dd2089d8e3786c5939fc948710d722845f/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bb3278e53f44e413101501043d86764037a8ca2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bb3278e53f44e413101501043d86764037a8ca2", "html_url": "https://github.com/rust-lang/rust/commit/3bb3278e53f44e413101501043d86764037a8ca2"}], "stats": {"total": 165, "additions": 44, "deletions": 121}, "files": [{"sha": "c09fde04ba4cd7de7092294e2d3c2296d4ebf237", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 26, "deletions": 105, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/044b07dd2089d8e3786c5939fc948710d722845f/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044b07dd2089d8e3786c5939fc948710d722845f/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=044b07dd2089d8e3786c5939fc948710d722845f", "patch": "@@ -17,7 +17,8 @@ use rustc::traits::ObligationCause;\n use syntax::ast;\n use syntax_pos::{self, Span};\n use rustc::hir;\n-use rustc::ty::{self, ImplOrTraitItem};\n+use rustc::hir::def::Def;\n+use rustc::ty::{self, AssociatedItem};\n \n use super::method::probe;\n \n@@ -31,11 +32,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.register_predicates(obligations);\n             },\n             Err(e) => {\n-<<<<<<< HEAD\n-                self.report_mismatched_types(&cause, expected, actual, e);\n-=======\n-                self.report_mismatched_types(origin, expected, actual, e).emit();\n->>>>>>> Return DiagnosticBuilder to add help suggestions\n+                self.report_mismatched_types(&cause, expected, actual, e).emit();\n             }\n         }\n     }\n@@ -59,128 +56,47 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// This function is used to determine potential \"simple\" improvements or users' errors and\n-    /// provide them useful help. For example:\n-    ///\n-    /// ```\n-    /// fn some_fn(s: &str) {}\n-    ///\n-    /// let x = \"hey!\".to_owned();\n-    /// some_fn(x); // error\n-    /// ```\n-    ///\n-    /// No need to find every potential function which could make a coercion to transform a\n-    /// `String` into a `&str` since a `&` would do the trick!\n-    ///\n-    /// In addition of this check, it also checks between references mutability state. If the\n-    /// expected is mutable but the provided isn't, maybe we could just say \"Hey, try with\n-    /// `&mut`!\".\n-    fn check_ref(&self,\n-                 expr: &hir::Expr,\n-                 checked_ty: Ty<'tcx>,\n-                 expected: Ty<'tcx>)\n-                 -> Option<String> {\n-        match (&expected.sty, &checked_ty.sty) {\n-            (&ty::TyRef(_, expected_mutability),\n-             &ty::TyRef(_, checked_mutability)) => {\n-                // check if there is a mutability difference\n-                if checked_mutability.mutbl == hir::Mutability::MutImmutable &&\n-                   checked_mutability.mutbl != expected_mutability.mutbl &&\n-                   self.can_sub_types(&checked_mutability.ty,\n-                                      expected_mutability.ty).is_ok() {\n-                    if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n-                        return Some(format!(\"try with `&mut {}`\", &src.replace(\"&\", \"\")));\n-                    }\n-                }\n-                None\n-            }\n-            (&ty::TyRef(_, mutability), _) => {\n-                // Check if it can work when put into a ref. For example:\n-                //\n-                // ```\n-                // fn bar(x: &mut i32) {}\n-                //\n-                // let x = 0u32;\n-                // bar(&x); // error, expected &mut\n-                // ```\n-                let ref_ty = match mutability.mutbl {\n-                    hir::Mutability::MutMutable => self.tcx.mk_mut_ref(\n-                                                       self.tcx.mk_region(ty::ReStatic),\n-                                                       checked_ty),\n-                    hir::Mutability::MutImmutable => self.tcx.mk_imm_ref(\n-                                                       self.tcx.mk_region(ty::ReStatic),\n-                                                       checked_ty),\n-                };\n-                if self.try_coerce(expr, ref_ty, expected).is_ok() {\n-                    if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n-                        return Some(format!(\"try with `{}{}`\",\n-                                            match mutability.mutbl {\n-                                                hir::Mutability::MutMutable => \"&mut \",\n-                                                hir::Mutability::MutImmutable => \"&\",\n-                                            },\n-                                            &src));\n-                    }\n-                }\n-                None\n-            }\n-            _ => None,\n-        }\n-    }\n-\n     // Checks that the type of `expr` can be coerced to `expected`.\n     pub fn demand_coerce(&self, expr: &hir::Expr, checked_ty: Ty<'tcx>, expected: Ty<'tcx>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n         if let Err(e) = self.try_coerce(expr, checked_ty, expected) {\n             let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n             let mode = probe::Mode::MethodCall;\n-            let suggestions = if let Some(s) = self.check_ref(expr, checked_ty, expected) {\n-                Some(s)\n-            } else {\n-                let suggestions = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n-                                                             mode,\n-                                                             expected,\n-                                                             checked_ty,\n-                                                             ast::DUMMY_NODE_ID);\n-                if suggestions.len() > 0 {\n-                    Some(format!(\"here are some functions which \\\n-                                  might fulfill your needs:\\n - {}\",\n-                                 self.get_best_match(&suggestions)))\n-                } else {\n-                    None\n-                }\n+            let suggestions = self.probe_for_return_type(syntax_pos::DUMMY_SP,\n+                                                         mode,\n+                                                         expected,\n+                                                         checked_ty,\n+                                                         ast::DUMMY_NODE_ID);\n+            let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n+            if suggestions.len() > 0 {\n+                err.help(&format!(\"here are some functions which \\\n+                                   might fulfill your needs:\\n - {}\",\n+                                  self.get_best_match(&suggestions)));\n             };\n-            let mut err = self.report_mismatched_types(origin, expected, expr_ty, e);\n-            if let Some(suggestions) = suggestions {\n-                err.help(&suggestions);\n-            }\n-<<<<<<< HEAD\n-            self.report_mismatched_types(&cause, expected, expr_ty, e);\n-=======\n             err.emit();\n->>>>>>> Return DiagnosticBuilder to add help suggestions\n         }\n     }\n \n-    fn format_method_suggestion(&self, method: &ImplOrTraitItem<'tcx>) -> String {\n+    fn format_method_suggestion(&self, method: &AssociatedItem) -> String {\n         format!(\".{}({})\",\n-                method.name(),\n+                method.name,\n                 if self.has_not_input_arg(method) {\n                     \"\"\n                 } else {\n                     \"...\"\n                 })\n     }\n \n-    fn display_suggested_methods(&self, methods: &[ImplOrTraitItem<'tcx>]) -> String {\n+    fn display_suggested_methods(&self, methods: &[AssociatedItem]) -> String {\n         methods.iter()\n                .take(5)\n                .map(|method| self.format_method_suggestion(&*method))\n                .collect::<Vec<String>>()\n                .join(\"\\n - \")\n     }\n \n-    fn get_best_match(&self, methods: &[ImplOrTraitItem<'tcx>]) -> String {\n+    fn get_best_match(&self, methods: &[AssociatedItem]) -> String {\n         let no_argument_methods: Vec<_> =\n             methods.iter()\n                    .filter(|ref x| self.has_not_input_arg(&*x))\n@@ -194,10 +110,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // This function checks if the method isn't static and takes other arguments than `self`.\n-    fn has_not_input_arg(&self, method: &ImplOrTraitItem<'tcx>) -> bool {\n-        match *method {\n-            ImplOrTraitItem::MethodTraitItem(ref x) => {\n-                x.fty.sig.skip_binder().inputs.len() == 1\n+    fn has_not_input_arg(&self, method: &AssociatedItem) -> bool {\n+        match method.def() {\n+            Def::Method(def_id) => {\n+                match self.tcx.item_type(def_id).sty {\n+                    ty::TypeVariants::TyFnDef(_, _, fty) => {\n+                        fty.sig.skip_binder().inputs.len() == 1\n+                    }\n+                    _ => false,\n+                }\n             }\n             _ => false,\n         }"}, {"sha": "04d714f269a5697579b0cba3c6664aea7d7e1759", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/044b07dd2089d8e3786c5939fc948710d722845f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044b07dd2089d8e3786c5939fc948710d722845f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=044b07dd2089d8e3786c5939fc948710d722845f", "patch": "@@ -16,7 +16,6 @@ use super::suggest;\n use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n-use rustc::infer::InferOk;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n@@ -162,7 +161,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  return_type: Ty<'tcx>,\n                                  self_ty: Ty<'tcx>,\n                                  scope_expr_id: ast::NodeId)\n-                                 -> Vec<ty::ImplOrTraitItem<'tcx>> {\n+                                 -> Vec<ty::AssociatedItem> {\n         debug!(\"probe(self_ty={:?}, return_type={}, scope_expr_id={})\",\n                self_ty,\n                return_type,\n@@ -643,13 +642,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn matches_return_type(&self, method: &ty::ImplOrTraitItem<'tcx>,\n+    pub fn matches_return_type(&self, method: &ty::AssociatedItem,\n                                expected: ty::Ty<'tcx>) -> bool {\n-        match *method {\n-            ty::ImplOrTraitItem::MethodTraitItem(ref x) => {\n+        match method.def() {\n+            Def::Method(def_id) => {\n+                let fty = self.tcx.item_type(def_id).fn_sig();\n                 self.probe(|_| {\n-                    let substs = self.fresh_substs_for_item(self.span, method.def_id());\n-                    let output = x.fty.sig.output().subst(self.tcx, substs);\n+                    let substs = self.fresh_substs_for_item(self.span, method.def_id);\n+                    let output = fty.output().subst(self.tcx, substs);\n                     let (output, _) = self.replace_late_bound_regions_with_fresh_var(\n                         self.span, infer::FnCall, &output);\n                     self.can_sub_types(output, expected).is_ok()\n@@ -906,12 +906,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn candidate_method_names(&self) -> Vec<ast::Name> {\n-        let mut set = FnvHashSet();\n+        let mut set = FxHashSet();\n         let mut names: Vec<_> =\n             self.inherent_candidates\n                 .iter()\n                 .chain(&self.extension_candidates)\n-                .map(|candidate| candidate.item.name())\n+                .map(|candidate| candidate.item.name)\n                 .filter(|&name| set.insert(name))\n                 .collect();\n \n@@ -1353,19 +1353,21 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     /// Find item with name `item_name` defined in impl/trait `def_id`\n     /// and return it, or `None`, if no such item was defined there.\n     fn associated_item(&self, def_id: DefId) -> Option<ty::AssociatedItem> {\n-        self.fcx.associated_item(def_id, self.item_name)\n+        match self.looking_for {\n+            LookingFor::MethodName(item_name) => self.fcx.associated_item(def_id, item_name),\n+            _ => None,\n+        }\n     }\n \n-    fn impl_or_trait_item(&self, def_id: DefId) -> Option<ty::ImplOrTraitItem<'tcx>> {\n+    fn impl_or_trait_item(&self, def_id: DefId) -> Option<ty::AssociatedItem> {\n         match self.looking_for {\n             LookingFor::MethodName(name) => {\n-                self.fcx.impl_or_trait_item(def_id, name)\n+                self.fcx.associated_item(def_id, name)\n             }\n             LookingFor::ReturnType(return_ty) => {\n                 self.tcx\n-                    .impl_or_trait_items(def_id)\n-                    .iter()\n-                    .map(|&did| self.tcx.impl_or_trait_item(did))\n+                    .associated_items(def_id)\n+                    .map(|did| self.tcx.associated_item(did.def_id))\n                     .find(|m| self.matches_return_type(m, return_ty))\n             }\n         }"}, {"sha": "3086721852deb82732883dc9de9e50057d11d718", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/044b07dd2089d8e3786c5939fc948710d722845f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044b07dd2089d8e3786c5939fc948710d722845f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=044b07dd2089d8e3786c5939fc948710d722845f", "patch": "@@ -3697,7 +3697,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 match result {\n                     Ok(ty) => ctxt.unified = ty,\n                     Err(err) => {\n-                        self.report_mismatched_types(&cause, ctxt.unified, e_ty, err);\n+                        self.report_mismatched_types(&cause, ctxt.unified, e_ty, err).emit();\n                     }\n                 }\n "}]}