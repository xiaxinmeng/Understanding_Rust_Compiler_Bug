{"sha": "c119903f621a11643d5f299423a2c72eefffec4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMTk5MDNmNjIxYTExNjQzZDVmMjk5NDIzYTJjNzJlZWZmZmVjNGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-13T09:57:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-13T09:57:06Z"}, "message": "auto merge of #13222 : nick29581/rust/dxr4, r=brson\n\nAdds a -Z flag `save-analysis` which runs after the analysis phase of the compiler and saves a bunch of info into a CSV file for the crate. This is designed to work with the DXR code browser, but is frontend-independent, that is this info should be useful for all kinds of code browsers, IDEs, or other tools.\r\n\r\nI need to squash commits before landing (there will probably be a fair few to come), please ignore them for now and just comment on the changes.", "tree": {"sha": "ff02659ad639ce78a447ef2ce6cea7c9c29b82e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff02659ad639ce78a447ef2ce6cea7c9c29b82e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c119903f621a11643d5f299423a2c72eefffec4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c119903f621a11643d5f299423a2c72eefffec4c", "html_url": "https://github.com/rust-lang/rust/commit/c119903f621a11643d5f299423a2c72eefffec4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c119903f621a11643d5f299423a2c72eefffec4c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d9bceb1440b6bb5759bc3c1e5ad2170a199d0ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9bceb1440b6bb5759bc3c1e5ad2170a199d0ce", "html_url": "https://github.com/rust-lang/rust/commit/5d9bceb1440b6bb5759bc3c1e5ad2170a199d0ce"}, {"sha": "984e9afae5098192a789dc39d44cec8225067896", "url": "https://api.github.com/repos/rust-lang/rust/commits/984e9afae5098192a789dc39d44cec8225067896", "html_url": "https://github.com/rust-lang/rust/commit/984e9afae5098192a789dc39d44cec8225067896"}], "stats": {"total": 2568, "additions": 2531, "deletions": 37}, "files": [{"sha": "3326b4e8304cec3246741b26056a2933bbd5fc3c", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=c119903f621a11643d5f299423a2c72eefffec4c", "patch": "@@ -172,7 +172,8 @@ debugging_opts!(\n         LTO,\n         AST_JSON,\n         AST_JSON_NOEXPAND,\n-        LS\n+        LS,\n+        SAVE_ANALYSIS\n     ]\n     0\n )\n@@ -206,7 +207,9 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n      (\"lto\", \"Perform LLVM link-time optimizations\", LTO),\n      (\"ast-json\", \"Print the AST as JSON and halt\", AST_JSON),\n      (\"ast-json-noexpand\", \"Print the pre-expansion AST as JSON and halt\", AST_JSON_NOEXPAND),\n-     (\"ls\", \"List the symbols defined by a library crate\", LS))\n+     (\"ls\", \"List the symbols defined by a library crate\", LS),\n+     (\"save-analysis\", \"Write syntax and type analysis information \\\n+                        in addition to normal output\", SAVE_ANALYSIS))\n }\n \n /// Declare a macro that will define all CodegenOptions fields and parsers all"}, {"sha": "880c1d6d5104d5290d015b440d874f52719f20c8", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=c119903f621a11643d5f299423a2c72eefffec4c", "patch": "@@ -87,6 +87,7 @@ pub fn compile_input(sess: Session,\n         if stop_after_phase_2(&sess) { return; }\n \n         let analysis = phase_3_run_analysis_passes(sess, &expanded_crate, ast_map);\n+        phase_save_analysis(&analysis.ty_cx.sess, &expanded_crate, &analysis, outdir);\n         if stop_after_phase_3(&analysis.ty_cx.sess) { return; }\n         let (tcx, trans) = phase_4_translate_to_llvm(expanded_crate,\n                                                      analysis, &outputs);\n@@ -370,6 +371,17 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     }\n }\n \n+pub fn phase_save_analysis(sess: &Session,\n+                           krate: &ast::Crate,\n+                           analysis: &CrateAnalysis,\n+                           odir: &Option<Path>) {\n+    if (sess.opts.debugging_opts & config::SAVE_ANALYSIS) == 0 {\n+        return;\n+    }\n+    time(sess.time_passes(), \"save analysis\", krate, |krate|\n+         middle::save::process_crate(sess, krate, analysis, odir));\n+}\n+\n pub struct CrateTranslation {\n     pub context: ContextRef,\n     pub module: ModuleRef,"}, {"sha": "3efff5eac9e4d92ca0942997b533dc11f51b7a5d", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=c119903f621a11643d5f299423a2c72eefffec4c", "patch": "@@ -28,6 +28,7 @@ use syntax::{ast, codemap};\n use std::os;\n use std::cell::{Cell, RefCell};\n \n+\n pub struct Session {\n     pub targ_cfg: config::Config,\n     pub opts: config::Options,"}, {"sha": "f79aaa40d213b98f77014a15fcb693702a616677", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c119903f621a11643d5f299423a2c72eefffec4c", "patch": "@@ -84,6 +84,7 @@ pub mod middle {\n     pub mod expr_use_visitor;\n     pub mod dependency_format;\n     pub mod weak_lang_items;\n+    pub mod save;\n }\n \n pub mod front {"}, {"sha": "2c73bc847a3b7d14e9c74fbf191abbfd1192ebfb", "filename": "src/librustc/middle/save/mod.rs", "status": "added", "additions": 1439, "deletions": 0, "changes": 1439, "blob_url": "https://github.com/rust-lang/rust/blob/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=c119903f621a11643d5f299423a2c72eefffec4c", "patch": "@@ -0,0 +1,1439 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Output a CSV file containing the output from rustc's analysis. The data is\n+//! primarily designed to be used as input to the DXR tool, specifically its\n+//! Rust plugin. It could also be used by IDEs or other code browsing, search, or\n+//! cross-referencing tools.\n+//!\n+//! Dumping the analysis is implemented by walking the AST and getting a bunch of\n+//! info out from all over the place. We use Def IDs to identify objects. The\n+//! tricky part is getting syntactic (span, source text) and semantic (reference\n+//! Def IDs) information for parts of expressions which the compiler has discarded.\n+//! E.g., in a path `foo::bar::baz`, the compiler only keeps a span for the whole\n+//! path and a reference to `baz`, but we want spans and references for all three\n+//! idents.\n+//!\n+//! SpanUtils is used to manipulate spans. In particular, to extract sub-spans\n+//! from spans (e.g., the span for `bar` from the above example path).\n+//! Recorder is used for recording the output in csv format. FmtStrs separates\n+//! the format of the output away from extracting it from the compiler.\n+//! DxrVisitor walks the AST and processes it.\n+\n+use driver::driver::CrateAnalysis;\n+use driver::session::Session;\n+\n+use middle::def;\n+use middle::ty;\n+use middle::typeck;\n+\n+use std::cell::Cell;\n+use std::gc::Gc;\n+use std::io;\n+use std::io::File;\n+use std::io::fs;\n+use std::os;\n+\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::ast::{NodeId,DefId};\n+use syntax::ast_map::NodeItem;\n+use syntax::attr;\n+use syntax::codemap::*;\n+use syntax::parse::token;\n+use syntax::parse::token::{get_ident,keywords};\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+use syntax::print::pprust::{path_to_str,ty_to_str};\n+\n+use middle::save::span_utils::SpanUtils;\n+use middle::save::recorder::Recorder;\n+use middle::save::recorder::FmtStrs;\n+\n+use util::ppaux;\n+\n+mod span_utils;\n+mod recorder;\n+\n+// Helper function to escape quotes in a string\n+fn escape(s: String) -> String {\n+    s.replace(\"\\\"\", \"\\\"\\\"\")\n+}\n+\n+// If the expression is a macro expansion or other generated code, run screaming and don't index.\n+fn generated_code(span: Span) -> bool {\n+    span.expn_info.is_some() || span  == DUMMY_SP\n+}\n+\n+struct DxrVisitor<'l> {\n+    sess: &'l Session,\n+    analysis: &'l CrateAnalysis,\n+\n+    collected_paths: Vec<(NodeId, ast::Path, bool, recorder::Row)>,\n+    collecting: bool,\n+\n+    span: SpanUtils<'l>,\n+    fmt: FmtStrs<'l>,\n+}\n+\n+impl <'l> DxrVisitor<'l> {\n+    fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n+        // the current crate\n+        self.fmt.crate_str(krate.span, name);\n+\n+        // dump info about all the external crates referenced from this crate\n+        self.sess.cstore.iter_crate_data(|n, cmd| {\n+            self.fmt.external_crate_str(krate.span, cmd.name.as_slice(), n);\n+        });\n+        self.fmt.recorder.record(\"end_external_crates\\n\");\n+    }\n+\n+    // Return all non-empty prefixes of a path.\n+    // For each prefix, we return the span for the last segment in the prefix and\n+    // a str representation of the entire prefix.\n+    fn process_path_prefixes(&self, path: &ast::Path) -> Vec<(Span, String)> {\n+        let spans = self.span.spans_for_path_segments(path);\n+\n+        // Paths to enums seem to not match their spans - the span includes all the\n+        // variants too. But they seem to always be at the end, so I hope we can cope with\n+        // always using the first ones. So, only error out if we don't have enough spans.\n+        // What could go wrong...?\n+        if spans.len() < path.segments.len() {\n+            error!(\"Mis-calculated spans for path '{}'. \\\n+                    Found {} spans, expected {}. Found spans:\",\n+                   path_to_str(path), spans.len(), path.segments.len());\n+            for s in spans.iter() {\n+                let loc = self.sess.codemap().lookup_char_pos(s.lo);\n+                error!(\"    '{}' in {}, line {}\",\n+                       self.span.snippet(*s), loc.file.name, loc.line);\n+            }\n+            return vec!();\n+        }\n+\n+        let mut result: Vec<(Span, String)> = vec!();\n+\n+\n+        let mut segs = vec!();\n+        for (seg, span) in path.segments.iter().zip(spans.iter()) {\n+            segs.push(seg.clone());\n+            let sub_path = ast::Path{span: *span, // span for the last segment\n+                                     global: path.global,\n+                                     segments: segs};\n+            let qualname = path_to_str(&sub_path);\n+            result.push((*span, qualname));\n+            segs = sub_path.segments;\n+        }\n+\n+        result\n+    }\n+\n+    fn write_sub_paths(&mut self, path: &ast::Path, scope_id: NodeId) {\n+        let sub_paths = self.process_path_prefixes(path);\n+        for &(ref span, ref qualname) in sub_paths.iter() {\n+            self.fmt.sub_mod_ref_str(path.span,\n+                                     *span,\n+                                     qualname.as_slice(),\n+                                     scope_id);\n+        }\n+    }\n+\n+    // As write_sub_paths, but does not process the last ident in the path (assuming it\n+    // will be processed elsewhere).\n+    fn write_sub_paths_truncated(&mut self, path: &ast::Path, scope_id: NodeId) {\n+        let sub_paths = self.process_path_prefixes(path);\n+        let len = sub_paths.len();\n+        if len <= 1 {\n+            return;\n+        }\n+\n+        let sub_paths = sub_paths.slice(0, len-1);\n+        for &(ref span, ref qualname) in sub_paths.iter() {\n+            self.fmt.sub_mod_ref_str(path.span,\n+                                     *span,\n+                                     qualname.as_slice(),\n+                                     scope_id);\n+        }\n+    }\n+\n+    // As write_sub_paths, but expects a path of the form module_path::trait::method\n+    // Where trait could actually be a struct too.\n+    fn write_sub_path_trait_truncated(&mut self, path: &ast::Path, scope_id: NodeId) {\n+        let sub_paths = self.process_path_prefixes(path);\n+        let len = sub_paths.len();\n+        if len <= 1 {\n+            return;\n+        }\n+        let sub_paths = sub_paths.slice_to(len-1);\n+\n+        // write the trait part of the sub-path\n+        let (ref span, ref qualname) = sub_paths[len-2];\n+        self.fmt.sub_type_ref_str(path.span,\n+                                  *span,\n+                                  qualname.as_slice());\n+\n+        // write the other sub-paths\n+        if len <= 2 {\n+            return;\n+        }\n+        let sub_paths = sub_paths.slice(0, len-2);\n+        for &(ref span, ref qualname) in sub_paths.iter() {\n+            self.fmt.sub_mod_ref_str(path.span,\n+                                     *span,\n+                                     qualname.as_slice(),\n+                                     scope_id);\n+        }\n+    }\n+\n+    // looks up anything, not just a type\n+    fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n+        if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n+            self.sess.bug(format!(\"def_map has no key for {} in lookup_type_ref\",\n+                                  ref_id).as_slice());\n+        }\n+        let def = *self.analysis.ty_cx.def_map.borrow().get(&ref_id);\n+        match def {\n+            def::DefPrimTy(_) => None,\n+            _ => Some(def.def_id()),\n+        }\n+    }\n+\n+    fn lookup_def_kind(&self, ref_id: NodeId, span: Span) -> Option<recorder::Row> {\n+        let def_map = self.analysis.ty_cx.def_map.borrow();\n+        if !def_map.contains_key(&ref_id) {\n+            self.sess.span_bug(span, format!(\"def_map has no key for {} in lookup_def_kind\",\n+                                             ref_id).as_slice());\n+        }\n+        let def = *def_map.get(&ref_id);\n+        match def {\n+            def::DefMod(_) |\n+            def::DefForeignMod(_) => Some(recorder::ModRef),\n+            def::DefStruct(_) => Some(recorder::StructRef),\n+            def::DefTy(_) |\n+            def::DefTrait(_) => Some(recorder::TypeRef),\n+            def::DefStatic(_, _) |\n+            def::DefBinding(_, _) |\n+            def::DefArg(_, _) |\n+            def::DefLocal(_, _) |\n+            def::DefVariant(_, _, _) |\n+            def::DefUpvar(_, _, _, _) => Some(recorder::VarRef),\n+\n+            def::DefFn(_, _) => Some(recorder::FnRef),\n+\n+            def::DefSelfTy(_) |\n+            def::DefRegion(_) |\n+            def::DefTyParamBinder(_) |\n+            def::DefLabel(_) |\n+            def::DefStaticMethod(_, _, _) |\n+            def::DefTyParam(_, _) |\n+            def::DefUse(_) |\n+            def::DefMethod(_, _) |\n+            def::DefPrimTy(_) => {\n+                self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {:?}\",\n+                                                 def).as_slice());\n+            },\n+        }\n+    }\n+\n+    fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str, e:DxrVisitorEnv) {\n+        for arg in formals.iter() {\n+            assert!(self.collected_paths.len() == 0 && !self.collecting);\n+            self.collecting = true;\n+            self.visit_pat(&*arg.pat, e);\n+            self.collecting = false;\n+            let span_utils = self.span;\n+            for &(id, ref p, _, _) in self.collected_paths.iter() {\n+                let typ = ppaux::ty_to_str(&self.analysis.ty_cx,\n+                    *self.analysis.ty_cx.node_types.borrow().get(&(id as uint)));\n+                // get the span only for the name of the variable (I hope the path is only ever a\n+                // variable name, but who knows?)\n+                self.fmt.formal_str(p.span,\n+                                    span_utils.span_for_last_ident(p.span),\n+                                    id,\n+                                    qualname,\n+                                    path_to_str(p).as_slice(),\n+                                    typ.as_slice());\n+            }\n+            self.collected_paths.clear();\n+        }\n+    }\n+\n+    fn process_method(&mut self, method: &ast::Method, e:DxrVisitorEnv) {\n+        if generated_code(method.span) {\n+            return;\n+        }\n+\n+        let mut scope_id;\n+        // The qualname for a method is the trait name or name of the struct in an impl in\n+        // which the method is declared in followed by the method's name.\n+        let mut qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n+                                                ast_util::local_def(method.id)) {\n+            Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n+                NodeItem(item) => {\n+                    scope_id = item.id;\n+                    match item.node {\n+                        ast::ItemImpl(_, _, ty, _) => {\n+                            let mut result = String::from_str(\"<\");\n+                            result.push_str(ty_to_str(&*ty).as_slice());\n+\n+                            match ty::trait_of_method(&self.analysis.ty_cx,\n+                                                      ast_util::local_def(method.id)) {\n+                                Some(def_id) => {\n+                                    result.push_str(\" as \");\n+                                    result.push_str(\n+                                        ty::item_path_str(&self.analysis.ty_cx, def_id).as_slice());\n+                                },\n+                                None => {}\n+                            }\n+                            result.append(\">::\")\n+                        }\n+                        _ => {\n+                            self.sess.span_bug(method.span,\n+                                               format!(\"Container {} for method {} not an impl?\",\n+                                                       impl_id.node, method.id).as_slice());\n+                        },\n+                    }\n+                },\n+                _ => {\n+                    self.sess.span_bug(method.span,\n+                                       format!(\"Container {} for method {} is not a node item {:?}\",\n+                                               impl_id.node,\n+                                               method.id,\n+                                               self.analysis.ty_cx.map.get(impl_id.node)\n+                                              ).as_slice());\n+                },\n+            },\n+            None => match ty::trait_of_method(&self.analysis.ty_cx,\n+                                              ast_util::local_def(method.id)) {\n+                Some(def_id) => {\n+                    scope_id = def_id.node;\n+                    match self.analysis.ty_cx.map.get(def_id.node) {\n+                        NodeItem(_) => {\n+                            let result = ty::item_path_str(&self.analysis.ty_cx, def_id);\n+                            result.append(\"::\")\n+                        }\n+                        _ => {\n+                            self.sess.span_bug(method.span,\n+                                               format!(\"Could not find container {} for method {}\",\n+                                                       def_id.node, method.id).as_slice());\n+                        }\n+                    }\n+                },\n+                None => {\n+                    self.sess.span_bug(method.span,\n+                                       format!(\"Could not find container for method {}\",\n+                                               method.id).as_slice());\n+                },\n+            },\n+        };\n+\n+        qualname.push_str(get_ident(method.ident).get());\n+        let qualname = qualname.as_slice();\n+\n+        // record the decl for this def (if it has one)\n+        let decl_id = ty::trait_method_of_method(&self.analysis.ty_cx,\n+                                                 ast_util::local_def(method.id))\n+            .filtered(|def_id| method.id != 0 && def_id.node == 0);\n+\n+        let sub_span = self.span.sub_span_after_keyword(method.span, keywords::Fn);\n+        self.fmt.method_str(method.span,\n+                            sub_span,\n+                            method.id,\n+                            qualname,\n+                            decl_id,\n+                            scope_id);\n+\n+        self.process_formals(&method.decl.inputs, qualname, e);\n+\n+        // walk arg and return types\n+        for arg in method.decl.inputs.iter() {\n+            self.visit_ty(&*arg.ty, e);\n+        }\n+        self.visit_ty(&*method.decl.output, e);\n+        // walk the fn body\n+        self.visit_block(&*method.body, DxrVisitorEnv::new_nested(method.id));\n+\n+        self.process_generic_params(&method.generics,\n+                                    method.span,\n+                                    qualname,\n+                                    method.id,\n+                                    e);\n+    }\n+\n+    fn process_trait_ref(&mut self,\n+                         trait_ref: &ast::TraitRef,\n+                         e: DxrVisitorEnv,\n+                         impl_id: Option<NodeId>) {\n+        match self.lookup_type_ref(trait_ref.ref_id) {\n+            Some(id) => {\n+                let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n+                self.fmt.ref_str(recorder::TypeRef,\n+                                 trait_ref.path.span,\n+                                 sub_span,\n+                                 id,\n+                                 e.cur_scope);\n+                match impl_id {\n+                    Some(impl_id) => self.fmt.impl_str(trait_ref.path.span,\n+                                                       sub_span,\n+                                                       impl_id,\n+                                                       id,\n+                                                       e.cur_scope),\n+                    None => (),\n+                }\n+                visit::walk_path(self, &trait_ref.path, e);\n+            },\n+            None => ()\n+        }\n+    }\n+\n+    fn process_struct_field_def(&mut self,\n+                                field: &ast::StructField,\n+                                qualname: &str,\n+                                scope_id: NodeId) {\n+        match field.node.kind {\n+            ast::NamedField(ident, _) => {\n+                let name = get_ident(ident);\n+                let qualname = format!(\"{}::{}\", qualname, name);\n+                let typ = ppaux::ty_to_str(&self.analysis.ty_cx,\n+                    *self.analysis.ty_cx.node_types.borrow().get(&(field.node.id as uint)));\n+                match self.span.sub_span_before_token(field.span, token::COLON) {\n+                    Some(sub_span) => self.fmt.field_str(field.span,\n+                                                         Some(sub_span),\n+                                                         field.node.id,\n+                                                         name.get().as_slice(),\n+                                                         qualname.as_slice(),\n+                                                         typ.as_slice(),\n+                                                         scope_id),\n+                    None => self.sess.span_bug(field.span,\n+                                               format!(\"Could not find sub-span for field {}\",\n+                                                       qualname).as_slice()),\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    // Dump generic params bindings, then visit_generics\n+    fn process_generic_params(&mut self, generics:&ast::Generics,\n+                              full_span: Span,\n+                              prefix: &str,\n+                              id: NodeId,\n+                              e: DxrVisitorEnv) {\n+        // We can't only use visit_generics since we don't have spans for param\n+        // bindings, so we reparse the full_span to get those sub spans.\n+        // However full span is the entire enum/fn/struct block, so we only want\n+        // the first few to match the number of generics we're looking for.\n+        let param_sub_spans = self.span.spans_for_ty_params(full_span,\n+                                                           (generics.ty_params.len() as int));\n+        for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans.iter()) {\n+            // Append $id to name to make sure each one is unique\n+            let name = format!(\"{}::{}${}\",\n+                               prefix,\n+                               escape(self.span.snippet(*param_ss)),\n+                               id);\n+            self.fmt.typedef_str(full_span,\n+                                 Some(*param_ss),\n+                                 param.id,\n+                                 name.as_slice(),\n+                                 \"\");\n+        }\n+        self.visit_generics(generics, e);\n+    }\n+\n+    fn process_fn(&mut self,\n+                  item: &ast::Item,\n+                  e: DxrVisitorEnv,\n+                  decl: ast::P<ast::FnDecl>,\n+                  ty_params: &ast::Generics,\n+                  body: ast::P<ast::Block>) {\n+        let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Fn);\n+        self.fmt.fn_str(item.span,\n+                        sub_span,\n+                        item.id,\n+                        qualname.as_slice(),\n+                        e.cur_scope);\n+\n+        self.process_formals(&decl.inputs, qualname.as_slice(), e);\n+\n+        // walk arg and return types\n+        for arg in decl.inputs.iter() {\n+            self.visit_ty(&*arg.ty, e);\n+        }\n+        self.visit_ty(&*decl.output, e);\n+\n+        // walk the body\n+        self.visit_block(&*body, DxrVisitorEnv::new_nested(item.id));\n+\n+        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id, e);\n+    }\n+\n+    fn process_static(&mut self,\n+                      item: &ast::Item,\n+                      e: DxrVisitorEnv,\n+                      typ: ast::P<ast::Ty>,\n+                      mt: ast::Mutability,\n+                      expr: &ast::Expr)\n+    {\n+        let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+\n+        // If the variable is immutable, save the initialising expresion.\n+        let value = match mt {\n+            ast::MutMutable => String::from_str(\"<mutable>\"),\n+            ast::MutImmutable => self.span.snippet(expr.span),\n+        };\n+\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Static);\n+        self.fmt.static_str(item.span,\n+                            sub_span,\n+                            item.id,\n+                            get_ident(item.ident).get(),\n+                            qualname.as_slice(),\n+                            value.as_slice(),\n+                            ty_to_str(&*typ).as_slice(),\n+                            e.cur_scope);\n+\n+        // walk type and init value\n+        self.visit_ty(&*typ, e);\n+        self.visit_expr(expr, e);\n+    }\n+\n+    fn process_struct(&mut self,\n+                      item: &ast::Item,\n+                      e: DxrVisitorEnv,\n+                      def: &ast::StructDef,\n+                      ty_params: &ast::Generics) {\n+        let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+\n+        let ctor_id = match def.ctor_id {\n+            Some(node_id) => node_id,\n+            None => -1,\n+        };\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n+        self.fmt.struct_str(item.span,\n+                            sub_span,\n+                            item.id,\n+                            ctor_id,\n+                            qualname.as_slice(),\n+                            e.cur_scope);\n+\n+        // fields\n+        for field in def.fields.iter() {\n+            self.process_struct_field_def(field, qualname.as_slice(), item.id);\n+            self.visit_ty(&*field.node.ty, e);\n+        }\n+\n+        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id, e);\n+    }\n+\n+    fn process_enum(&mut self,\n+                    item: &ast::Item,\n+                    e: DxrVisitorEnv,\n+                    enum_definition: &ast::EnumDef,\n+                    ty_params: &ast::Generics) {\n+        let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+        match self.span.sub_span_after_keyword(item.span, keywords::Enum) {\n+            Some(sub_span) => self.fmt.enum_str(item.span,\n+                                                Some(sub_span),\n+                                                item.id,\n+                                                qualname.as_slice(),\n+                                                e.cur_scope),\n+            None => self.sess.span_bug(item.span,\n+                                       format!(\"Could not find subspan for enum {}\",\n+                                               qualname).as_slice()),\n+        }\n+        for variant in enum_definition.variants.iter() {\n+            let name = get_ident(variant.node.name);\n+            let name = name.get();\n+            let qualname = qualname.clone().append(\"::\").append(name);\n+            let val = self.span.snippet(variant.span);\n+            match variant.node.kind {\n+                ast::TupleVariantKind(ref args) => {\n+                    // first ident in span is the variant's name\n+                    self.fmt.tuple_variant_str(variant.span,\n+                                               self.span.span_for_first_ident(variant.span),\n+                                               variant.node.id,\n+                                               name,\n+                                               qualname.as_slice(),\n+                                               val.as_slice(),\n+                                               item.id);\n+                    for arg in args.iter() {\n+                        self.visit_ty(&*arg.ty, e);\n+                    }\n+                }\n+                ast::StructVariantKind(ref struct_def) => {\n+                    let ctor_id = match struct_def.ctor_id {\n+                        Some(node_id) => node_id,\n+                        None => -1,\n+                    };\n+                    self.fmt.struct_variant_str(\n+                        variant.span,\n+                        self.span.span_for_first_ident(variant.span),\n+                        variant.node.id,\n+                        ctor_id,\n+                        qualname.as_slice(),\n+                        val.as_slice(),\n+                        item.id);\n+\n+                    for field in struct_def.fields.iter() {\n+                        self.process_struct_field_def(field, qualname.as_slice(), variant.node.id);\n+                        self.visit_ty(&*field.node.ty, e);\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id, e);\n+    }\n+\n+    fn process_impl(&mut self,\n+                    item: &ast::Item,\n+                    e: DxrVisitorEnv,\n+                    type_parameters: &ast::Generics,\n+                    trait_ref: &Option<ast::TraitRef>,\n+                    typ: ast::P<ast::Ty>,\n+                    methods: &Vec<Gc<ast::Method>>) {\n+        match typ.node {\n+            ast::TyPath(ref path, _, id) => {\n+                match self.lookup_type_ref(id) {\n+                    Some(id) => {\n+                        let sub_span = self.span.sub_span_for_type_name(path.span);\n+                        self.fmt.ref_str(recorder::TypeRef,\n+                                         path.span,\n+                                         sub_span,\n+                                         id,\n+                                         e.cur_scope);\n+                        self.fmt.impl_str(path.span,\n+                                          sub_span,\n+                                          item.id,\n+                                          id,\n+                                          e.cur_scope);\n+                    },\n+                    None => ()\n+                }\n+            },\n+            _ => self.visit_ty(&*typ, e),\n+        }\n+\n+        match *trait_ref {\n+            Some(ref trait_ref) => self.process_trait_ref(trait_ref, e, Some(item.id)),\n+            None => (),\n+        }\n+\n+        self.process_generic_params(type_parameters, item.span, \"\", item.id, e);\n+        for method in methods.iter() {\n+            visit::walk_method_helper(self, &**method, e)\n+        }\n+    }\n+\n+    fn process_trait(&mut self,\n+                     item: &ast::Item,\n+                     e: DxrVisitorEnv,\n+                     generics: &ast::Generics,\n+                     trait_refs: &Vec<ast::TraitRef>,\n+                     methods: &Vec<ast::TraitMethod>) {\n+        let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n+        self.fmt.trait_str(item.span,\n+                           sub_span,\n+                           item.id,\n+                           qualname.as_slice(),\n+                           e.cur_scope);\n+\n+        // super-traits\n+        for trait_ref in trait_refs.iter() {\n+            match self.lookup_type_ref(trait_ref.ref_id) {\n+                Some(id) => {\n+                    let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n+                    self.fmt.ref_str(recorder::TypeRef,\n+                                     trait_ref.path.span,\n+                                     sub_span,\n+                                     id,\n+                                     e.cur_scope);\n+                    self.fmt.inherit_str(trait_ref.path.span,\n+                                         sub_span,\n+                                         id,\n+                                         item.id);\n+                },\n+                None => ()\n+            }\n+        }\n+\n+        // walk generics and methods\n+        self.process_generic_params(generics, item.span, qualname.as_slice(), item.id, e);\n+        for method in methods.iter() {\n+            self.visit_trait_method(method, e)\n+        }\n+    }\n+\n+    fn process_mod(&mut self,\n+                   item: &ast::Item,  // The module in question, represented as an item.\n+                   e: DxrVisitorEnv,\n+                   m: &ast::Mod) {\n+        let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+\n+        let cm = self.sess.codemap();\n+        let filename = cm.span_to_filename(m.inner);\n+\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Mod);\n+        self.fmt.mod_str(item.span,\n+                         sub_span,\n+                         item.id,\n+                         qualname.as_slice(),\n+                         e.cur_scope,\n+                         filename.as_slice());\n+\n+        visit::walk_mod(self, m, DxrVisitorEnv::new_nested(item.id));\n+    }\n+\n+    fn process_path(&mut self,\n+                    ex: &ast::Expr,\n+                    e: DxrVisitorEnv,\n+                    path: &ast::Path) {\n+        if generated_code(path.span) {\n+            return\n+        }\n+\n+        let def_map = self.analysis.ty_cx.def_map.borrow();\n+        if !def_map.contains_key(&ex.id) {\n+            self.sess.span_bug(ex.span,\n+                               format!(\"def_map has no key for {} in visit_expr\",\n+                                       ex.id).as_slice());\n+        }\n+        let def = def_map.get(&ex.id);\n+        let sub_span = self.span.span_for_last_ident(ex.span);\n+        match *def {\n+            def::DefLocal(id, _) |\n+            def::DefArg(id, _) |\n+            def::DefUpvar(id, _, _, _) |\n+            def::DefBinding(id, _) => self.fmt.ref_str(recorder::VarRef,\n+                                                       ex.span,\n+                                                       sub_span,\n+                                                       ast_util::local_def(id),\n+                                                       e.cur_scope),\n+            def::DefStatic(def_id,_) |\n+            def::DefVariant(_, def_id, _) => self.fmt.ref_str(recorder::VarRef,\n+                                                              ex.span,\n+                                                              sub_span,\n+                                                              def_id,\n+                                                              e.cur_scope),\n+            def::DefStruct(def_id) => self.fmt.ref_str(recorder::StructRef,\n+                                                       ex.span,\n+                                                       sub_span,\n+                                                       def_id,\n+                                                        e.cur_scope),\n+            def::DefStaticMethod(declid, provenence, _) => {\n+                let sub_span = self.span.sub_span_for_meth_name(ex.span);\n+                let defid = if declid.krate == ast::LOCAL_CRATE {\n+                    let m = ty::method(&self.analysis.ty_cx, declid);\n+                    match provenence {\n+                        def::FromTrait(def_id) =>\n+                            Some(ty::trait_methods(&self.analysis.ty_cx, def_id)\n+                                .iter().find(|mr| mr.ident.name == m.ident.name).unwrap().def_id),\n+                        def::FromImpl(def_id) => {\n+                            let impl_methods = self.analysis.ty_cx.impl_methods.borrow();\n+                            Some(*impl_methods.get(&def_id)\n+                                .iter().find(|mr|\n+                                    ty::method(\n+                                        &self.analysis.ty_cx, **mr).ident.name == m.ident.name)\n+                                .unwrap())\n+                        }\n+                    }\n+                } else {\n+                    None\n+                };\n+                self.fmt.meth_call_str(ex.span,\n+                                       sub_span,\n+                                       defid,\n+                                       Some(declid),\n+                                       e.cur_scope);\n+            },\n+            def::DefFn(def_id, _) => self.fmt.fn_call_str(ex.span,\n+                                                          sub_span,\n+                                                          def_id,\n+                                                          e.cur_scope),\n+            _ => self.sess.span_bug(ex.span,\n+                                    format!(\"Unexpected def kind while looking up path in '{}'\",\n+                                            self.span.snippet(ex.span)).as_slice()),\n+        }\n+        // modules or types in the path prefix\n+        match *def {\n+            def::DefStaticMethod(_, _, _) => {\n+                self.write_sub_path_trait_truncated(path, e.cur_scope);\n+            },\n+            def::DefLocal(_, _) |\n+            def::DefArg(_, _) |\n+            def::DefStatic(_,_) |\n+            def::DefStruct(_) |\n+            def::DefFn(_, _) => self.write_sub_paths_truncated(path, e.cur_scope),\n+            _ => {},\n+        }\n+\n+        visit::walk_path(self, path, e);\n+    }\n+\n+    fn process_struct_lit(&mut self,\n+                          ex: &ast::Expr,\n+                          e: DxrVisitorEnv,\n+                          path: &ast::Path,\n+                          fields: &Vec<ast::Field>,\n+                          base: Option<Gc<ast::Expr>>) {\n+        if generated_code(path.span) {\n+            return\n+        }\n+\n+        let mut struct_def: Option<DefId> = None;\n+        match self.lookup_type_ref(ex.id) {\n+            Some(id) => {\n+                struct_def = Some(id);\n+                let sub_span = self.span.span_for_last_ident(path.span);\n+                self.fmt.ref_str(recorder::StructRef,\n+                                 path.span,\n+                                 sub_span,\n+                                 id,\n+                                 e.cur_scope);\n+            },\n+            None => ()\n+        }\n+\n+        self.write_sub_paths_truncated(path, e.cur_scope);\n+\n+        for field in fields.iter() {\n+            match struct_def {\n+                Some(struct_def) => {\n+                    let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n+                    for f in fields.iter() {\n+                        if generated_code(field.ident.span) {\n+                            continue;\n+                        }\n+                        if f.name == field.ident.node.name {\n+                            // We don't really need a sub-span here, but no harm done\n+                            let sub_span = self.span.span_for_last_ident(field.ident.span);\n+                            self.fmt.ref_str(recorder::VarRef,\n+                                             field.ident.span,\n+                                             sub_span,\n+                                             f.id,\n+                                             e.cur_scope);\n+                        }\n+                    }\n+                }\n+                None => {}\n+            }\n+\n+            self.visit_expr(&*field.expr, e)\n+        }\n+        visit::walk_expr_opt(self, base, e)\n+    }\n+\n+    fn process_method_call(&mut self,\n+                           ex: &ast::Expr,\n+                           e: DxrVisitorEnv,\n+                           args: &Vec<Gc<ast::Expr>>) {\n+        let method_map = self.analysis.ty_cx.method_map.borrow();\n+        let method_callee = method_map.get(&typeck::MethodCall::expr(ex.id));\n+        let (def_id, decl_id) = match method_callee.origin {\n+            typeck::MethodStatic(def_id) => {\n+                // method invoked on an object with a concrete type (not a static method)\n+                let decl_id = ty::trait_method_of_method(&self.analysis.ty_cx, def_id);\n+\n+                // This incantation is required if the method referenced is a trait's\n+                // defailt implementation.\n+                let def_id = ty::method(&self.analysis.ty_cx, def_id).provided_source\n+                                    .unwrap_or(def_id);\n+                (Some(def_id), decl_id)\n+            }\n+            typeck::MethodParam(mp) => {\n+                // method invoked on a type parameter\n+                let method = ty::trait_method(&self.analysis.ty_cx,\n+                                              mp.trait_id,\n+                                              mp.method_num);\n+                (None, Some(method.def_id))\n+            },\n+            typeck::MethodObject(mo) => {\n+                // method invoked on a trait instance\n+                let method = ty::trait_method(&self.analysis.ty_cx,\n+                                              mo.trait_id,\n+                                              mo.method_num);\n+                (None, Some(method.def_id))\n+            },\n+        };\n+        let sub_span = self.span.sub_span_for_meth_name(ex.span);\n+        self.fmt.meth_call_str(ex.span,\n+                               sub_span,\n+                               def_id,\n+                               decl_id,\n+                               e.cur_scope);\n+\n+        // walk receiver and args\n+        visit::walk_exprs(self, args.as_slice(), e);\n+    }\n+\n+    fn process_pat(&mut self, p:&ast::Pat, e: DxrVisitorEnv) {\n+        if generated_code(p.span) {\n+            return\n+        }\n+\n+        match p.node {\n+            ast::PatStruct(ref path, ref fields, _) => {\n+                self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n+                visit::walk_path(self, path, e);\n+                let struct_def = match self.lookup_type_ref(p.id) {\n+                    Some(sd) => sd,\n+                    None => {\n+                        self.sess.span_bug(p.span,\n+                                           format!(\"Could not find struct_def for `{}`\",\n+                                                   self.span.snippet(p.span)).as_slice());\n+                    }\n+                };\n+                // The AST doesn't give us a span for the struct field, so we have\n+                // to figure out where it is by assuming it's the token before each colon.\n+                let field_spans = self.span.sub_spans_before_tokens(p.span,\n+                                                                    token::COMMA,\n+                                                                    token::COLON);\n+                if fields.len() != field_spans.len() {\n+                    self.sess.span_bug(p.span,\n+                        format!(\"Mismatched field count in '{}', found {}, expected {}\",\n+                                self.span.snippet(p.span), field_spans.len(), fields.len()\n+                               ).as_slice());\n+                }\n+                for (field, &span) in fields.iter().zip(field_spans.iter()) {\n+                    self.visit_pat(&*field.pat, e);\n+                    if span.is_none() {\n+                        continue;\n+                    }\n+                    let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n+                    for f in fields.iter() {\n+                        if f.name == field.ident.name {\n+                            self.fmt.ref_str(recorder::VarRef,\n+                                             p.span,\n+                                             span,\n+                                             f.id,\n+                                             e.cur_scope);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            ast::PatEnum(ref path, _) => {\n+                self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n+                visit::walk_pat(self, p, e);\n+            }\n+            ast::PatIdent(bm, ref path, ref optional_subpattern) => {\n+                let immut = match bm {\n+                    // Even if the ref is mut, you can't change the ref, only\n+                    // the data pointed at, so showing the initialising expression\n+                    // is still worthwhile.\n+                    ast::BindByRef(_) => true,\n+                    ast::BindByValue(mt) => {\n+                        match mt {\n+                            ast::MutMutable => false,\n+                            ast::MutImmutable => true,\n+                        }\n+                    }\n+                };\n+                // collect path for either visit_local or visit_arm\n+                self.collected_paths.push((p.id, path.clone(), immut, recorder::VarRef));\n+                match *optional_subpattern {\n+                    None => {}\n+                    Some(subpattern) => self.visit_pat(&*subpattern, e),\n+                }\n+            }\n+            _ => visit::walk_pat(self, p, e)\n+        }\n+    }\n+}\n+\n+impl<'l> Visitor<DxrVisitorEnv> for DxrVisitor<'l> {\n+    fn visit_item(&mut self, item:&ast::Item, e: DxrVisitorEnv) {\n+        if generated_code(item.span) {\n+            return\n+        }\n+\n+        match item.node {\n+            ast::ItemFn(decl, _, _, ref ty_params, body) =>\n+                self.process_fn(item, e, decl, ty_params, body),\n+            ast::ItemStatic(typ, mt, expr) =>\n+                self.process_static(item, e, typ, mt, &*expr),\n+            ast::ItemStruct(def, ref ty_params) => self.process_struct(item, e, &*def, ty_params),\n+            ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, e, def, ty_params),\n+            ast::ItemImpl(ref ty_params, ref trait_ref, typ, ref methods) =>\n+                self.process_impl(item, e, ty_params, trait_ref, typ, methods),\n+            ast::ItemTrait(ref generics, _, ref trait_refs, ref methods) =>\n+                self.process_trait(item, e, generics, trait_refs, methods),\n+            ast::ItemMod(ref m) => self.process_mod(item, e, m),\n+            ast::ItemTy(ty, ref ty_params) => {\n+                let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n+                let value = ty_to_str(&*ty);\n+                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n+                self.fmt.typedef_str(item.span,\n+                                     sub_span,\n+                                     item.id,\n+                                     qualname.as_slice(),\n+                                     value.as_slice());\n+\n+                self.visit_ty(&*ty, e);\n+                self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id, e);\n+            },\n+            ast::ItemMac(_) => (),\n+            _ => visit::walk_item(self, item, e),\n+        }\n+    }\n+\n+    fn visit_generics(&mut self, generics: &ast::Generics, e: DxrVisitorEnv) {\n+        for param in generics.ty_params.iter() {\n+            for bound in param.bounds.iter() {\n+                match *bound {\n+                    ast::TraitTyParamBound(ref trait_ref) => {\n+                        self.process_trait_ref(trait_ref, e, None);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            match param.default {\n+                Some(ty) => self.visit_ty(&*ty, e),\n+                None => (),\n+            }\n+        }\n+    }\n+\n+    // We don't actually index functions here, that is done in visit_item/ItemFn.\n+    // Here we just visit methods.\n+    fn visit_fn(&mut self,\n+                fk: &visit::FnKind,\n+                fd: &ast::FnDecl,\n+                b: &ast::Block,\n+                s: Span,\n+                _: NodeId,\n+                e: DxrVisitorEnv) {\n+        if generated_code(s) {\n+            return;\n+        }\n+\n+        match *fk {\n+            visit::FkMethod(_, _, method) => self.process_method(method, e),\n+            _ => visit::walk_fn(self, fk, fd, b, s, e),\n+        }\n+    }\n+\n+    fn visit_trait_method(&mut self, tm: &ast::TraitMethod, e: DxrVisitorEnv) {\n+        match *tm {\n+            ast::Required(ref method_type) => {\n+                if generated_code(method_type.span) {\n+                    return;\n+                }\n+\n+                let mut scope_id ;\n+                let mut qualname = match ty::trait_of_method(&self.analysis.ty_cx,\n+                                                             ast_util::local_def(method_type.id)) {\n+                    Some(def_id) => {\n+                        scope_id = def_id.node;\n+                        ty::item_path_str(&self.analysis.ty_cx, def_id).append(\"::\")\n+                    },\n+                    None => {\n+                        self.sess.span_bug(method_type.span,\n+                                           format!(\"Could not find trait for method {}\",\n+                                                   method_type.id).as_slice());\n+                    },\n+                };\n+\n+                qualname.push_str(get_ident(method_type.ident).get());\n+                let qualname = qualname.as_slice();\n+\n+                let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n+                self.fmt.method_decl_str(method_type.span,\n+                                         sub_span,\n+                                         method_type.id,\n+                                         qualname,\n+                                         scope_id);\n+\n+                // walk arg and return types\n+                for arg in method_type.decl.inputs.iter() {\n+                    self.visit_ty(&*arg.ty, e);\n+                }\n+                self.visit_ty(&*method_type.decl.output, e);\n+\n+                self.process_generic_params(&method_type.generics,\n+                                            method_type.span,\n+                                            qualname,\n+                                            method_type.id,\n+                                            e);\n+            }\n+            ast::Provided(method) => self.process_method(&*method, e),\n+        }\n+    }\n+\n+    fn visit_view_item(&mut self, i:&ast::ViewItem, e:DxrVisitorEnv) {\n+        if generated_code(i.span) {\n+            return\n+        }\n+\n+        match i.node {\n+            ast::ViewItemUse(ref path) => {\n+                match path.node {\n+                    ast::ViewPathSimple(ident, ref path, id) => {\n+                        let sub_span = self.span.span_for_last_ident(path.span);\n+                        let mod_id = match self.lookup_type_ref(id) {\n+                            Some(def_id) => {\n+                                match self.lookup_def_kind(id, path.span) {\n+                                    Some(kind) => self.fmt.ref_str(kind,\n+                                                                   path.span,\n+                                                                   sub_span,\n+                                                                   def_id,\n+                                                                   e.cur_scope),\n+                                    None => {},\n+                                }\n+                                Some(def_id)\n+                            },\n+                            None => None,\n+                        };\n+\n+                        // 'use' always introduces an alias, if there is not an explicit\n+                        // one, there is an implicit one.\n+                        let sub_span =\n+                            match self.span.sub_span_before_token(path.span, token::EQ) {\n+                                Some(sub_span) => Some(sub_span),\n+                                None => sub_span,\n+                            };\n+\n+                        self.fmt.use_alias_str(path.span,\n+                                               sub_span,\n+                                               id,\n+                                               mod_id,\n+                                               get_ident(ident).get(),\n+                                               e.cur_scope);\n+                        self.write_sub_paths_truncated(path, e.cur_scope);\n+                    }\n+                    ast::ViewPathGlob(ref path, _) => {\n+                        self.write_sub_paths(path, e.cur_scope);\n+                    }\n+                    ast::ViewPathList(ref path, ref list, _) => {\n+                        for plid in list.iter() {\n+                            match self.lookup_type_ref(plid.node.id) {\n+                                Some(id) => match self.lookup_def_kind(plid.node.id, plid.span) {\n+                                    Some(kind) => self.fmt.ref_str(kind,\n+                                                                   plid.span,\n+                                                                   Some(plid.span),\n+                                                                   id,\n+                                                                   e.cur_scope),\n+                                    None => (),\n+                                },\n+                                None => ()\n+                            }\n+                        }\n+\n+                        self.write_sub_paths(path, e.cur_scope);\n+                    }\n+                }\n+            },\n+            ast::ViewItemExternCrate(ident, ref s, id) => {\n+                let name = get_ident(ident).get().to_owned();\n+                let s = match *s {\n+                    Some((ref s, _)) => s.get().to_owned(),\n+                    None => name.to_owned(),\n+                };\n+                let sub_span = self.span.sub_span_after_keyword(i.span, keywords::Crate);\n+                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(id) {\n+                    Some(cnum) => cnum,\n+                    None => 0,\n+                };\n+                self.fmt.extern_crate_str(i.span,\n+                                          sub_span,\n+                                          id,\n+                                          cnum,\n+                                          name.as_slice(),\n+                                          s.as_slice(),\n+                                          e.cur_scope);\n+            },\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty, e: DxrVisitorEnv) {\n+        if generated_code(t.span) {\n+            return\n+        }\n+\n+        match t.node {\n+            ast::TyPath(ref path, _, id) => {\n+                match self.lookup_type_ref(id) {\n+                    Some(id) => {\n+                        let sub_span = self.span.sub_span_for_type_name(t.span);\n+                        self.fmt.ref_str(recorder::TypeRef,\n+                                         t.span,\n+                                         sub_span,\n+                                         id,\n+                                         e.cur_scope);\n+                    },\n+                    None => ()\n+                }\n+\n+                self.write_sub_paths_truncated(path, e.cur_scope);\n+\n+                visit::walk_path(self, path, e);\n+            },\n+            _ => visit::walk_ty(self, t, e),\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, ex: &ast::Expr, e: DxrVisitorEnv) {\n+        if generated_code(ex.span) {\n+            return\n+        }\n+\n+        match ex.node {\n+            ast::ExprCall(_f, ref _args) => {\n+                // Don't need to do anything for function calls,\n+                // because just walking the callee path does what we want.\n+                visit::walk_expr(self, ex, e);\n+            },\n+            ast::ExprPath(ref path) => self.process_path(ex, e, path),\n+            ast::ExprStruct(ref path, ref fields, base) =>\n+                self.process_struct_lit(ex, e, path, fields, base),\n+            ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, e, args),\n+            ast::ExprField(sub_ex, ident, _) => {\n+                if generated_code(sub_ex.span) {\n+                    return\n+                }\n+\n+                self.visit_expr(&*sub_ex, e);\n+\n+                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &*sub_ex);\n+                let t_box = ty::get(t);\n+                match t_box.sty {\n+                    ty::ty_struct(def_id, _) => {\n+                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n+                        for f in fields.iter() {\n+                            if f.name == ident.name {\n+                                let sub_span = self.span.span_for_last_ident(ex.span);\n+                                self.fmt.ref_str(recorder::VarRef,\n+                                                 ex.span,\n+                                                 sub_span,\n+                                                 f.id,\n+                                                 e.cur_scope);\n+                                break;\n+                            }\n+                        }\n+                    },\n+                    _ => self.sess.span_bug(ex.span,\n+                                            \"Expected struct type, but not ty_struct\"),\n+                }\n+            },\n+            ast::ExprFnBlock(decl, body) => {\n+                if generated_code(body.span) {\n+                    return\n+                }\n+\n+                let id = String::from_str(\"$\").append(ex.id.to_str().as_slice());\n+                self.process_formals(&decl.inputs, id.as_slice(), e);\n+\n+                // walk arg and return types\n+                for arg in decl.inputs.iter() {\n+                    self.visit_ty(&*arg.ty, e);\n+                }\n+                self.visit_ty(&*decl.output, e);\n+\n+                // walk the body\n+                self.visit_block(&*body, DxrVisitorEnv::new_nested(ex.id));\n+            },\n+            _ => {\n+                visit::walk_expr(self, ex, e)\n+            },\n+        }\n+    }\n+\n+    fn visit_mac(&mut self, _: &ast::Mac, _: DxrVisitorEnv) {\n+        // Just stop, macros are poison to us.\n+    }\n+\n+    fn visit_pat(&mut self, p: &ast::Pat, e: DxrVisitorEnv) {\n+        self.process_pat(p, e);\n+        if !self.collecting {\n+            self.collected_paths.clear();\n+        }\n+    }\n+\n+    fn visit_arm(&mut self, arm: &ast::Arm, e: DxrVisitorEnv) {\n+        assert!(self.collected_paths.len() == 0 && !self.collecting);\n+        self.collecting = true;\n+\n+        for pattern in arm.pats.iter() {\n+            // collect paths from the arm's patterns\n+            self.visit_pat(&**pattern, e);\n+        }\n+        self.collecting = false;\n+        // process collected paths\n+        for &(id, ref p, ref immut, ref_kind) in self.collected_paths.iter() {\n+            let value = if *immut {\n+                self.span.snippet(p.span).into_owned()\n+            } else {\n+                \"<mutable>\".to_owned()\n+            };\n+            let sub_span = self.span.span_for_first_ident(p.span);\n+            let def_map = self.analysis.ty_cx.def_map.borrow();\n+            if !def_map.contains_key(&id) {\n+                self.sess.span_bug(p.span,\n+                                   format!(\"def_map has no key for {} in visit_arm\",\n+                                           id).as_slice());\n+            }\n+            let def = def_map.get(&id);\n+            match *def {\n+                def::DefBinding(id, _)  => self.fmt.variable_str(p.span,\n+                                                                 sub_span,\n+                                                                 id,\n+                                                                 path_to_str(p).as_slice(),\n+                                                                 value.as_slice(),\n+                                                                 \"\"),\n+                def::DefVariant(_,id,_) => self.fmt.ref_str(ref_kind,\n+                                                            p.span,\n+                                                            sub_span,\n+                                                            id,\n+                                                            e.cur_scope),\n+                // FIXME(nrc) what is this doing here?\n+                def::DefStatic(_, _) => {}\n+                _ => error!(\"unexpected defintion kind when processing collected paths: {:?}\", *def)\n+            }\n+        }\n+        self.collected_paths.clear();\n+        visit::walk_expr_opt(self, arm.guard, e);\n+        self.visit_expr(&*arm.body, e);\n+    }\n+\n+    fn visit_stmt(&mut self, s:&ast::Stmt, e:DxrVisitorEnv) {\n+        if generated_code(s.span) {\n+            return\n+        }\n+\n+        visit::walk_stmt(self, s, e)\n+    }\n+\n+    fn visit_local(&mut self, l:&ast::Local, e: DxrVisitorEnv) {\n+        if generated_code(l.span) {\n+            return\n+        }\n+\n+        // The local could declare multiple new vars, we must walk the\n+        // pattern and collect them all.\n+        assert!(self.collected_paths.len() == 0 && !self.collecting);\n+        self.collecting = true;\n+        self.visit_pat(&*l.pat, e);\n+        self.collecting = false;\n+\n+        let value = self.span.snippet(l.span);\n+\n+        for &(id, ref p, ref immut, _) in self.collected_paths.iter() {\n+            let value = if *immut { value.to_owned() } else { \"<mutable>\".to_owned() };\n+            let types = self.analysis.ty_cx.node_types.borrow();\n+            let typ = ppaux::ty_to_str(&self.analysis.ty_cx, *types.get(&(id as uint)));\n+            // Get the span only for the name of the variable (I hope the path\n+            // is only ever a variable name, but who knows?).\n+            let sub_span = self.span.span_for_last_ident(p.span);\n+            // Rust uses the id of the pattern for var lookups, so we'll use it too.\n+            self.fmt.variable_str(p.span,\n+                                  sub_span,\n+                                  id,\n+                                  path_to_str(p).as_slice(),\n+                                  value.as_slice(),\n+                                  typ.as_slice());\n+        }\n+        self.collected_paths.clear();\n+\n+        // Just walk the initialiser and type (don't want to walk the pattern again).\n+        self.visit_ty(&*l.ty, e);\n+        visit::walk_expr_opt(self, l.init, e);\n+    }\n+}\n+\n+#[deriving(Clone)]\n+struct DxrVisitorEnv {\n+    cur_scope: NodeId,\n+}\n+\n+impl DxrVisitorEnv {\n+    fn new() -> DxrVisitorEnv {\n+        DxrVisitorEnv{cur_scope: 0}\n+    }\n+    fn new_nested(new_mod: NodeId) -> DxrVisitorEnv {\n+        DxrVisitorEnv{cur_scope: new_mod}\n+    }\n+}\n+\n+pub fn process_crate(sess: &Session,\n+                     krate: &ast::Crate,\n+                     analysis: &CrateAnalysis,\n+                     odir: &Option<Path>) {\n+    if generated_code(krate.span) {\n+        return;\n+    }\n+\n+    let (cratename, crateid) = match attr::find_crateid(krate.attrs.as_slice()) {\n+        Some(crateid) => (crateid.name.clone(), crateid.to_str()),\n+        None => {\n+            info!(\"Could not find crate name, using 'unknown_crate'\");\n+            (String::from_str(\"unknown_crate\"),\"unknown_crate\".to_owned())\n+        },\n+    };\n+\n+    info!(\"Dumping crate {} ({})\", cratename, crateid);\n+\n+    // find a path to dump our data to\n+    let mut root_path = match os::getenv(\"DXR_RUST_TEMP_FOLDER\") {\n+        Some(val) => Path::new(val),\n+        None => match *odir {\n+            Some(ref val) => val.join(\"dxr\"),\n+            None => Path::new(\"dxr-temp\"),\n+        },\n+    };\n+\n+    match fs::mkdir_recursive(&root_path, io::UserRWX) {\n+        Err(e) => sess.err(format!(\"Could not create directory {}: {}\",\n+                           root_path.display(), e).as_slice()),\n+        _ => (),\n+    }\n+\n+    {\n+        let disp = root_path.display();\n+        info!(\"Writing output to {}\", disp);\n+    }\n+\n+    // Create ouput file.\n+    let mut out_name = cratename.clone();\n+    out_name.push_str(\".csv\");\n+    root_path.push(out_name);\n+    let output_file = match File::create(&root_path) {\n+        Ok(f) => box f,\n+        Err(e) => {\n+            let disp = root_path.display();\n+            sess.fatal(format!(\"Could not open {}: {}\", disp, e).as_slice());\n+        }\n+    };\n+    root_path.pop();\n+\n+    let mut visitor = DxrVisitor{ sess: sess,\n+                                  analysis: analysis,\n+                                  collected_paths: vec!(),\n+                                  collecting: false,\n+                                  fmt: FmtStrs::new(box Recorder {\n+                                                        out: output_file as Box<Writer>,\n+                                                        dump_spans: false,\n+                                                    },\n+                                                    SpanUtils {\n+                                                        sess: sess,\n+                                                        err_count: Cell::new(0)\n+                                                    },\n+                                                    cratename.clone()),\n+                                  span: SpanUtils {\n+                                      sess: sess,\n+                                      err_count: Cell::new(0)\n+                                  }};\n+\n+    visitor.dump_crate_info(cratename.as_slice(), krate);\n+\n+    visit::walk_crate(&mut visitor, krate, DxrVisitorEnv::new());\n+}"}, {"sha": "428f97d0e53d5a1cde970456e5fcf1a1762e1221", "filename": "src/librustc/middle/save/recorder.rs", "status": "added", "additions": 575, "deletions": 0, "changes": 575, "blob_url": "https://github.com/rust-lang/rust/blob/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs?ref=c119903f621a11643d5f299423a2c72eefffec4c", "patch": "@@ -0,0 +1,575 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::save::escape;\n+use middle::save::span_utils::SpanUtils;\n+\n+use std::vec::Vec;\n+\n+use syntax::ast;\n+use syntax::ast::{NodeId,DefId};\n+use syntax::codemap::*;\n+\n+pub struct Recorder {\n+    // output file\n+    pub out: Box<Writer>,\n+    pub dump_spans: bool,\n+}\n+\n+impl Recorder {\n+    pub fn record(&mut self, info: &str) {\n+        match write!(self.out, \"{}\", info) {\n+            Err(_) => error!(\"Error writing output '{}'\", info),\n+            _ => (),\n+        }\n+    }\n+\n+    pub fn dump_span(&mut self,\n+                     su: SpanUtils,\n+                     kind: &str,\n+                     span: Span,\n+                     _sub_span: Option<Span>) {\n+        assert!(self.dump_spans);\n+        let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n+                             kind, su.extent_str(span), escape(su.snippet(span)));\n+        self.record(result.as_slice());\n+    }\n+}\n+\n+pub struct FmtStrs<'a> {\n+    pub recorder: Box<Recorder>,\n+    span: SpanUtils<'a>,\n+    krate: String,\n+}\n+\n+macro_rules! s { ($e:expr) => { format!(\"{}\", $e) }}\n+macro_rules! svec {\n+    ($($e:expr),*) => ({\n+        // leading _ to allow empty construction without a warning.\n+        let mut _temp = ::std::vec::Vec::new();\n+        $(_temp.push(s!($e));)*\n+        _temp\n+    })\n+}\n+\n+pub enum Row {\n+    Variable,\n+    Enum,\n+    Variant,\n+    VariantStruct,\n+    Function,\n+    MethodDecl,\n+    Struct,\n+    Trait,\n+    Impl,\n+    Module,\n+    UseAlias,\n+    ExternCrate,\n+    Inheritance,\n+    MethodCall,\n+    Typedef,\n+    ExternalCrate,\n+    Crate,\n+    FnCall,\n+    ModRef,\n+    VarRef,\n+    TypeRef,\n+    StructRef,\n+    FnRef,\n+}\n+\n+impl<'a> FmtStrs<'a> {\n+    pub fn new(rec: Box<Recorder>, span: SpanUtils<'a>, krate: String) -> FmtStrs<'a> {\n+        FmtStrs {\n+            recorder: rec,\n+            span: span,\n+            krate: krate,\n+        }\n+    }\n+\n+    // A map from kind of item to a tuple of\n+    //   a string representation of the name\n+    //   a vector of field names\n+    //   whether this kind requires a span\n+    //   whether dump_spans should dump for this kind\n+    fn lookup_row(r: Row) -> (&'static str, Vec<&'static str>, bool, bool) {\n+        match r {\n+            Variable => (\"variable\",\n+                         vec!(\"id\",\"name\",\"qualname\",\"value\",\"type\",\"scopeid\"),\n+                         true, true),\n+            Enum => (\"enum\", vec!(\"id\",\"qualname\",\"scopeid\"), true, true),\n+            Variant => (\"variant\", vec!(\"id\",\"name\",\"qualname\",\"value\",\"scopeid\"), true, true),\n+            VariantStruct => (\"variant_struct\",\n+                              vec!(\"id\",\"ctor_id\",\"qualname\",\"value\",\"scopeid\"), true, true),\n+            Function => (\"function\", vec!(\"id\",\"qualname\",\"declid\",\"declidcrate\",\"scopeid\"),\n+                         true, true),\n+            MethodDecl => (\"method_decl\", vec!(\"id\",\"qualname\",\"scopeid\"), true, true),\n+            Struct => (\"struct\", vec!(\"id\",\"ctor_id\",\"qualname\",\"scopeid\"), true, true),\n+            Trait => (\"trait\", vec!(\"id\",\"qualname\",\"scopeid\"), true, true),\n+            Impl => (\"impl\", vec!(\"id\",\"refid\",\"refidcrate\",\"scopeid\"), true, true),\n+            Module => (\"module\", vec!(\"id\",\"qualname\",\"scopeid\",\"def_file\"), true, false),\n+            UseAlias => (\"use_alias\",\n+                         vec!(\"id\",\"refid\",\"refidcrate\",\"name\",\"scopeid\"),\n+                         true, true),\n+            ExternCrate => (\"extern_crate\",\n+                            vec!(\"id\",\"name\",\"location\",\"crate\",\"scopeid\"),\n+                            true, true),\n+            Inheritance => (\"inheritance\",\n+                            vec!(\"base\",\"basecrate\",\"derived\",\"derivedcrate\"),\n+                            true, false),\n+            MethodCall => (\"method_call\",\n+                           vec!(\"refid\",\"refidcrate\",\"declid\",\"declidcrate\",\"scopeid\"),\n+                            true, true),\n+            Typedef => (\"typedef\", vec!(\"id\",\"qualname\",\"value\"), true, true),\n+            ExternalCrate => (\"external_crate\", vec!(\"name\",\"crate\",\"file_name\"), false, false),\n+            Crate => (\"crate\", vec!(\"name\"), true, false),\n+            FnCall => (\"fn_call\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n+            ModRef => (\"mod_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n+            VarRef => (\"var_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true),\n+            TypeRef => (\"type_ref\",\n+                        vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"),\n+                        true, true),\n+            StructRef => (\"struct_ref\",\n+                          vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"),\n+                           true, true),\n+            FnRef => (\"fn_ref\", vec!(\"refid\",\"refidcrate\",\"qualname\",\"scopeid\"), true, true)\n+        }\n+    }\n+\n+    pub fn make_values_str(&self,\n+                           kind: &'static str,\n+                           fields: &Vec<&'static str>,\n+                           values: Vec<String>,\n+                           span: Span) -> Option<String> {\n+        if values.len() != fields.len() {\n+            self.span.sess.span_bug(span, format!(\n+                \"Mismatch between length of fields for '{}', expected '{}', found '{}'\",\n+                kind, fields.len(), values.len()).as_slice());\n+        }\n+\n+        let values = values.iter().map(|s| {\n+            if s.len() > 1020 {\n+                s.as_slice().slice_to(1020)\n+            } else {\n+                s.as_slice()\n+            }\n+        });\n+\n+        let pairs = fields.iter().zip(values);\n+        let mut strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(\n+            if *f == \"qualname\" {\n+                self.krate.clone().append(\"::\").append(v)\n+            } else {\n+                String::from_str(v)\n+            }\n+        )));\n+        Some(strs.fold(String::new(), |s, ss| s.append(ss.as_slice()))).map(|s| s.into_owned())\n+    }\n+\n+    pub fn record_without_span(&mut self,\n+                               kind: Row,\n+                               values: Vec<String>,\n+                               span: Span) {\n+        let (label, ref fields, needs_span, dump_spans) = FmtStrs::lookup_row(kind);\n+\n+        if needs_span {\n+            self.span.sess.span_bug(span, format!(\n+                \"Called record_without_span for '{}' which does requires a span\",\n+                label).as_slice());\n+        }\n+        assert!(!dump_spans);\n+\n+        if self.recorder.dump_spans {\n+            return;\n+        }\n+\n+        let values_str = match self.make_values_str(label, fields, values, span) {\n+            Some(vs) => vs,\n+            None => return,\n+        };\n+\n+        let result = String::from_str(label);\n+        self.recorder.record(result.append(values_str.as_slice()).append(\"\\n\").as_slice());\n+    }\n+\n+    pub fn record_with_span(&mut self,\n+                            kind: Row,\n+                            span: Span,\n+                            sub_span: Span,\n+                            values: Vec<String>) {\n+        let (label, ref fields, needs_span, dump_spans) = FmtStrs::lookup_row(kind);\n+\n+        if self.recorder.dump_spans {\n+            if dump_spans {\n+                self.recorder.dump_span(self.span, label, span, Some(sub_span));\n+            }\n+            return;\n+        }\n+\n+        if !needs_span {\n+            self.span.sess.span_bug(span,\n+                                    format!(\"Called record_with_span for '{}' \\\n+                                             which does not require a span\", label).as_slice());\n+        }\n+\n+        let values_str = match self.make_values_str(label, fields, values, span) {\n+            Some(vs) => vs,\n+            None => return,\n+        };\n+        let result = format!(\"{},{}{}\\n\", label, self.span.extent_str(sub_span), values_str);\n+        self.recorder.record(result.as_slice());\n+    }\n+\n+    pub fn check_and_record(&mut self,\n+                            kind: Row,\n+                            span: Span,\n+                            sub_span: Option<Span>,\n+                            values: Vec<String>) {\n+        match sub_span {\n+            Some(sub_span) => self.record_with_span(kind, span, sub_span, values),\n+            None => {\n+                let (label, _, _, _) = FmtStrs::lookup_row(kind);\n+                self.span.report_span_err(label, span);\n+            }\n+        }\n+    }\n+\n+    pub fn variable_str(&mut self,\n+                        span: Span,\n+                        sub_span: Option<Span>,\n+                        id: NodeId,\n+                        name: &str,\n+                        value: &str,\n+                        typ: &str) {\n+        // Getting a fully qualified name for a variable is hard because in\n+        // the local case they can be overridden in one block and there is no nice way\n+        // to refer to such a scope in english, so we just hack it by appending the\n+        // variable def's node id\n+        let qualname = String::from_str(name).append(\"$\").append(id.to_str().as_slice());\n+        self.check_and_record(Variable,\n+                              span,\n+                              sub_span,\n+                              svec!(id, name, qualname, value, typ, 0));\n+    }\n+\n+    // formal parameters\n+    pub fn formal_str(&mut self,\n+                      span: Span,\n+                      sub_span: Option<Span>,\n+                      id: NodeId,\n+                      fn_name: &str,\n+                      name: &str,\n+                      typ: &str) {\n+        let qualname = String::from_str(fn_name).append(\"::\").append(name);\n+        self.check_and_record(Variable,\n+                              span,\n+                              sub_span,\n+                              svec!(id, name, qualname, \"\", typ, 0));\n+    }\n+\n+    // value is the initialising expression of the static if it is not mut, otherwise \"\".\n+    pub fn static_str(&mut self,\n+                      span: Span,\n+                      sub_span: Option<Span>,\n+                      id: NodeId,\n+                      name: &str,\n+                      qualname: &str,\n+                      value: &str,\n+                      typ: &str,\n+                      scope_id: NodeId) {\n+        self.check_and_record(Variable,\n+                              span,\n+                              sub_span,\n+                              svec!(id, name, qualname, value, typ, scope_id));\n+    }\n+\n+    pub fn field_str(&mut self,\n+                     span: Span,\n+                     sub_span: Option<Span>,\n+                     id: NodeId,\n+                     name: &str,\n+                     qualname: &str,\n+                     typ: &str,\n+                     scope_id: NodeId) {\n+        self.check_and_record(Variable,\n+                              span,\n+                              sub_span,\n+                              svec!(id, name, qualname, \"\", typ, scope_id));\n+    }\n+\n+    pub fn enum_str(&mut self,\n+                    span: Span,\n+                    sub_span: Option<Span>,\n+                    id: NodeId,\n+                    name: &str,\n+                    scope_id: NodeId) {\n+        self.check_and_record(Enum,\n+                              span,\n+                              sub_span,\n+                              svec!(id, name, scope_id));\n+    }\n+\n+    pub fn tuple_variant_str(&mut self,\n+                             span: Span,\n+                             sub_span: Option<Span>,\n+                             id: NodeId,\n+                             name: &str,\n+                             qualname: &str,\n+                             val: &str,\n+                             scope_id: NodeId) {\n+        self.check_and_record(Variant,\n+                              span,\n+                              sub_span,\n+                              svec!(id, name, qualname, val, scope_id));\n+    }\n+\n+    pub fn struct_variant_str(&mut self,\n+                              span: Span,\n+                              sub_span: Option<Span>,\n+                              id: NodeId,\n+                              ctor_id: NodeId,\n+                              name: &str,\n+                              val: &str,\n+                              scope_id: NodeId) {\n+        self.check_and_record(VariantStruct,\n+                              span,\n+                              sub_span,\n+                              svec!(id, ctor_id, name, val, scope_id));\n+    }\n+\n+    pub fn fn_str(&mut self,\n+                  span: Span,\n+                  sub_span: Option<Span>,\n+                  id: NodeId,\n+                  name: &str,\n+                  scope_id: NodeId) {\n+        self.check_and_record(Function,\n+                              span,\n+                              sub_span,\n+                              svec!(id, name, \"\", \"\", scope_id));\n+    }\n+\n+    pub fn method_str(&mut self,\n+                      span: Span,\n+                      sub_span: Option<Span>,\n+                      id: NodeId,\n+                      name: &str,\n+                      decl_id: Option<DefId>,\n+                      scope_id: NodeId) {\n+        let values = match decl_id {\n+            Some(decl_id) => svec!(id, name, decl_id.node, decl_id.krate, scope_id),\n+            None => svec!(id, name, \"\", \"\", scope_id)\n+        };\n+        self.check_and_record(Function,\n+                              span,\n+                              sub_span,\n+                              values);\n+    }\n+\n+    pub fn method_decl_str(&mut self,\n+                           span: Span,\n+                           sub_span: Option<Span>,\n+                           id: NodeId,\n+                           name: &str,\n+                           scope_id: NodeId) {\n+        self.check_and_record(MethodDecl,\n+                              span,\n+                              sub_span,\n+                              svec!(id, name, scope_id));\n+    }\n+\n+    pub fn struct_str(&mut self,\n+                      span: Span,\n+                      sub_span: Option<Span>,\n+                      id: NodeId,\n+                      ctor_id: NodeId,\n+                      name: &str,\n+                      scope_id: NodeId) {\n+        self.check_and_record(Struct,\n+                              span,\n+                              sub_span,\n+                              svec!(id, ctor_id, name, scope_id));\n+    }\n+\n+    pub fn trait_str(&mut self,\n+                     span: Span,\n+                     sub_span: Option<Span>,\n+                     id: NodeId,\n+                     name: &str,\n+                     scope_id: NodeId) {\n+        self.check_and_record(Trait,\n+                              span,\n+                              sub_span,\n+                              svec!(id, name, scope_id));\n+    }\n+\n+    pub fn impl_str(&mut self,\n+                    span: Span,\n+                    sub_span: Option<Span>,\n+                    id: NodeId,\n+                    ref_id: DefId,\n+                    scope_id: NodeId) {\n+        self.check_and_record(Impl,\n+                              span,\n+                              sub_span,\n+                              svec!(id, ref_id.node, ref_id.krate, scope_id));\n+    }\n+\n+    pub fn mod_str(&mut self,\n+                   span: Span,\n+                   sub_span: Option<Span>,\n+                   id: NodeId,\n+                   name: &str,\n+                   parent: NodeId,\n+                   filename: &str) {\n+        self.check_and_record(Module,\n+                              span,\n+                              sub_span,\n+                              svec!(id, name, parent, filename));\n+    }\n+\n+    pub fn use_alias_str(&mut self,\n+                         span: Span,\n+                         sub_span: Option<Span>,\n+                         id: NodeId,\n+                         mod_id: Option<DefId>,\n+                         name: &str,\n+                         parent: NodeId) {\n+        let (mod_node, mod_crate) = match mod_id {\n+            Some(mod_id) => (mod_id.node, mod_id.krate),\n+            None => (0, 0)\n+        };\n+        self.check_and_record(UseAlias,\n+                              span,\n+                              sub_span,\n+                              svec!(id, mod_node, mod_crate, name, parent));\n+    }\n+\n+    pub fn extern_crate_str(&mut self,\n+                          span: Span,\n+                          sub_span: Option<Span>,\n+                          id: NodeId,\n+                          cnum: ast::CrateNum,\n+                          name: &str,\n+                          loc: &str,\n+                          parent: NodeId) {\n+        self.check_and_record(ExternCrate,\n+                              span,\n+                              sub_span,\n+                              svec!(id, name, loc, cnum, parent));\n+    }\n+\n+    pub fn inherit_str(&mut self,\n+                       span: Span,\n+                       sub_span: Option<Span>,\n+                       base_id: DefId,\n+                       deriv_id: NodeId) {\n+        self.check_and_record(Inheritance,\n+                              span,\n+                              sub_span,\n+                              svec!(base_id.node, base_id.krate, deriv_id, 0));\n+    }\n+\n+    pub fn fn_call_str(&mut self,\n+                       span: Span,\n+                       sub_span: Option<Span>,\n+                       id: DefId,\n+                       scope_id:NodeId) {\n+        self.check_and_record(FnCall,\n+                              span,\n+                              sub_span,\n+                              svec!(id.node, id.krate, \"\", scope_id));\n+    }\n+\n+    pub fn meth_call_str(&mut self,\n+                         span: Span,\n+                         sub_span: Option<Span>,\n+                         defid: Option<DefId>,\n+                         declid: Option<DefId>,\n+                         scope_id: NodeId) {\n+        let (dfn, dfk) = match defid {\n+            Some(defid) => (defid.node, defid.krate),\n+            None => (0, 0)\n+        };\n+        let (dcn, dck) = match declid {\n+            Some(declid) => (s!(declid.node), s!(declid.krate)),\n+            None => (\"\".to_owned(), \"\".to_owned())\n+        };\n+        self.check_and_record(MethodCall,\n+                              span,\n+                              sub_span,\n+                              svec!(dfn, dfk, dcn, dck, scope_id));\n+    }\n+\n+    pub fn sub_mod_ref_str(&mut self,\n+                           span: Span,\n+                           sub_span: Span,\n+                           qualname: &str,\n+                           parent:NodeId) {\n+        self.record_with_span(ModRef,\n+                              span,\n+                              sub_span,\n+                              svec!(0, 0, qualname, parent));\n+    }\n+\n+    pub fn typedef_str(&mut self,\n+                       span: Span,\n+                       sub_span: Option<Span>,\n+                       id: NodeId,\n+                       qualname: &str,\n+                       value: &str) {\n+        self.check_and_record(Typedef,\n+                              span,\n+                              sub_span,\n+                              svec!(id, qualname, value));\n+    }\n+\n+    pub fn crate_str(&mut self,\n+                     span: Span,\n+                     name: &str) {\n+        self.record_with_span(Crate,\n+                              span,\n+                              span,\n+                              svec!(name));\n+    }\n+\n+    pub fn external_crate_str(&mut self,\n+                              span: Span,\n+                              name: &str,\n+                              num: ast::CrateNum) {\n+        let lo_loc = self.span.sess.codemap().lookup_char_pos(span.lo);\n+        self.record_without_span(ExternalCrate,\n+                                 svec!(name, num, lo_loc.file.name),\n+                                 span);\n+    }\n+\n+    pub fn sub_type_ref_str(&mut self,\n+                            span: Span,\n+                            sub_span: Span,\n+                            qualname: &str) {\n+        self.record_with_span(TypeRef,\n+                              span,\n+                              sub_span,\n+                              svec!(0, 0, qualname, 0));\n+    }\n+\n+    // A slightly generic function for a reference to an item of any kind.\n+    pub fn ref_str(&mut self,\n+                   kind: Row,\n+                   span: Span,\n+                   sub_span: Option<Span>,\n+                   id: DefId,\n+                   scope_id: NodeId) {\n+        self.check_and_record(kind,\n+                              span,\n+                              sub_span,\n+                              svec!(id.node, id.krate, \"\", scope_id));\n+    }\n+}"}, {"sha": "e646827fa23ddc7c6ba4f39ce309e0a9d601ae60", "filename": "src/librustc/middle/save/span_utils.rs", "status": "added", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs?ref=c119903f621a11643d5f299423a2c72eefffec4c", "patch": "@@ -0,0 +1,381 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use driver::session::Session;\n+\n+use middle::save::generated_code;\n+\n+use std::cell::Cell;\n+\n+use syntax::ast;\n+use syntax::codemap::*;\n+use syntax::parse::lexer;\n+use syntax::parse::lexer::{Reader,StringReader};\n+use syntax::parse::token;\n+use syntax::parse::token::{is_keyword,keywords,is_ident,Token};\n+\n+pub struct SpanUtils<'a> {\n+    pub sess: &'a Session,\n+    pub err_count: Cell<int>,\n+}\n+\n+impl<'a> SpanUtils<'a> {\n+    // Standard string for extents/location.\n+    pub fn extent_str(&self, span: Span) -> String {\n+        let lo_loc = self.sess.codemap().lookup_char_pos(span.lo);\n+        let hi_loc = self.sess.codemap().lookup_char_pos(span.hi);\n+        let lo_pos = self.sess.codemap().lookup_byte_offset(span.lo).pos;\n+        let hi_pos = self.sess.codemap().lookup_byte_offset(span.hi).pos;\n+\n+        format!(\"file_name,{},file_line,{},file_col,{},extent_start,{},\\\n+                 file_line_end,{},file_col_end,{},extent_end,{}\",\n+                lo_loc.file.name, lo_loc.line, lo_loc.col.to_uint(), lo_pos.to_uint(),\n+                hi_loc.line, hi_loc.col.to_uint(), hi_pos.to_uint())\n+    }\n+\n+    // sub_span starts at span.lo, so we need to adjust the positions etc.\n+    // If sub_span is None, we don't need to adjust.\n+    pub fn make_sub_span(&self, span: Span, sub_span: Option<Span>) -> Option<Span> {\n+        let loc = self.sess.codemap().lookup_char_pos(span.lo);\n+        assert!(!generated_code(span),\n+                \"generated code; we should not be processing this `{}` in {}, line {}\",\n+                 self.snippet(span), loc.file.name, loc.line);\n+\n+        match sub_span {\n+            None => None,\n+            Some(sub) => {\n+                let FileMapAndBytePos {fm, pos} =\n+                    self.sess.codemap().lookup_byte_offset(span.lo);\n+                let base = pos + fm.start_pos;\n+                Some(Span {\n+                    lo: base + self.sess.codemap().lookup_byte_offset(sub.lo).pos,\n+                    hi: base + self.sess.codemap().lookup_byte_offset(sub.hi).pos,\n+                    expn_info: None,\n+                })\n+            }\n+        }\n+    }\n+\n+    pub fn snippet(&self, span: Span) -> String {\n+        match self.sess.codemap().span_to_snippet(span) {\n+            Some(s) => s,\n+            None => String::new(),\n+        }\n+    }\n+\n+    pub fn retokenise_span(&self, span: Span) -> StringReader<'a> {\n+        // sadness - we don't have spans for sub-expressions nor access to the tokens\n+        // so in order to get extents for the function name itself (which dxr expects)\n+        // we need to re-tokenise the fn definition\n+\n+        // Note: this is a bit awful - it adds the contents of span to the end of\n+        // the codemap as a new filemap. This is mostly OK, but means we should\n+        // not iterate over the codemap. Also, any spans over the new filemap\n+        // are incompatible with spans over other filemaps.\n+        let filemap = self.sess.codemap().new_filemap(String::from_str(\"<anon-dxr>\"),\n+                                                      self.snippet(span));\n+        let s = self.sess;\n+        lexer::StringReader::new(s.diagnostic(), filemap)\n+    }\n+\n+    // Re-parses a path and returns the span for the last identifier in the path\n+    pub fn span_for_last_ident(&self, span: Span) -> Option<Span> {\n+        let mut result = None;\n+\n+        let mut toks = self.retokenise_span(span);\n+        let mut bracket_count = 0;\n+        loop {\n+            let ts = toks.next_token();\n+            if ts.tok == token::EOF {\n+                return self.make_sub_span(span, result)\n+            }\n+            if bracket_count == 0 &&\n+               (is_ident(&ts.tok) || is_keyword(keywords::Self, &ts.tok)) {\n+                result = Some(ts.sp);\n+            }\n+\n+            bracket_count += match ts.tok {\n+                token::LT => 1,\n+                token::GT => -1,\n+                token::BINOP(token::SHR) => -2,\n+                _ => 0\n+            }\n+        }\n+    }\n+\n+    // Return the span for the first identifier in the path.\n+    pub fn span_for_first_ident(&self, span: Span) -> Option<Span> {\n+        let mut toks = self.retokenise_span(span);\n+        let mut bracket_count = 0;\n+        loop {\n+            let ts = toks.next_token();\n+            if ts.tok == token::EOF {\n+                return None;\n+            }\n+            if bracket_count == 0 &&\n+               (is_ident(&ts.tok) || is_keyword(keywords::Self, &ts.tok)) {\n+                return self.make_sub_span(span, Some(ts.sp));\n+            }\n+\n+            bracket_count += match ts.tok {\n+                token::LT => 1,\n+                token::GT => -1,\n+                token::BINOP(token::SHR) => -2,\n+                _ => 0\n+            }\n+        }\n+    }\n+\n+    // Return the span for the last ident before a `(` or `<` or '::<' and outside any\n+    // any brackets, or the last span.\n+    pub fn sub_span_for_meth_name(&self, span: Span) -> Option<Span> {\n+        let mut toks = self.retokenise_span(span);\n+        let mut prev = toks.next_token();\n+        let mut result = None;\n+        let mut bracket_count = 0;\n+        let mut last_span = None;\n+        while prev.tok != token::EOF {\n+            last_span = None;\n+            let mut next = toks.next_token();\n+\n+            if (next.tok == token::LPAREN ||\n+                next.tok == token::LT) &&\n+               bracket_count == 0 &&\n+               is_ident(&prev.tok) {\n+                result = Some(prev.sp);\n+            }\n+\n+            if bracket_count == 0 &&\n+                next.tok == token::MOD_SEP {\n+                let old = prev;\n+                prev = next;\n+                next = toks.next_token();\n+                if next.tok == token::LT &&\n+                   is_ident(&old.tok) {\n+                    result = Some(old.sp);\n+                }\n+            }\n+\n+            bracket_count += match prev.tok {\n+                token::LPAREN | token::LT => 1,\n+                token::RPAREN | token::GT => -1,\n+                token::BINOP(token::SHR) => -2,\n+                _ => 0\n+            };\n+\n+            if is_ident(&prev.tok) && bracket_count == 0 {\n+                last_span = Some(prev.sp);\n+            }\n+            prev = next;\n+        }\n+        if result.is_none() && last_span.is_some() {\n+            return self.make_sub_span(span, last_span);\n+        }\n+        return self.make_sub_span(span, result);\n+    }\n+\n+    // Return the span for the last ident before a `<` and outside any\n+    // brackets, or the last span.\n+    pub fn sub_span_for_type_name(&self, span: Span) -> Option<Span> {\n+        let mut toks = self.retokenise_span(span);\n+        let mut prev = toks.next_token();\n+        let mut result = None;\n+        let mut bracket_count = 0;\n+        loop {\n+            let next = toks.next_token();\n+\n+            if (next.tok == token::LT ||\n+                next.tok == token::COLON) &&\n+               bracket_count == 0 &&\n+               is_ident(&prev.tok) {\n+                result = Some(prev.sp);\n+            }\n+\n+            bracket_count += match prev.tok {\n+                token::LT => 1,\n+                token::GT => -1,\n+                token::BINOP(token::SHR) => -2,\n+                _ => 0\n+            };\n+\n+            if next.tok == token::EOF {\n+                break;\n+            }\n+            prev = next;\n+        }\n+        if bracket_count != 0 {\n+            let loc = self.sess.codemap().lookup_char_pos(span.lo);\n+            self.sess.span_bug(span,\n+                format!(\"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n+                        self.snippet(span), loc.file.name, loc.line).as_slice());\n+        }\n+        if result.is_none() && is_ident(&prev.tok) && bracket_count == 0 {\n+            return self.make_sub_span(span, Some(prev.sp));\n+        }\n+        self.make_sub_span(span, result)\n+    }\n+\n+    // Reparse span and return an owned vector of sub spans of the first limit\n+    // identifier tokens in the given nesting level.\n+    // example with Foo<Bar<T,V>, Bar<T,V>>\n+    // Nesting = 0: all idents outside of brackets: ~[Foo]\n+    // Nesting = 1: idents within one level of brackets: ~[Bar, Bar]\n+    pub fn spans_with_brackets(&self, span: Span, nesting: int, limit: int) -> Vec<Span> {\n+        let mut result: Vec<Span> = vec!();\n+\n+        let mut toks = self.retokenise_span(span);\n+        // We keep track of how many brackets we're nested in\n+        let mut bracket_count = 0;\n+        loop {\n+            let ts = toks.next_token();\n+            if ts.tok == token::EOF {\n+                if bracket_count != 0 {\n+                    let loc = self.sess.codemap().lookup_char_pos(span.lo);\n+                    self.sess.span_bug(span, format!(\n+                        \"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n+                         self.snippet(span), loc.file.name, loc.line).as_slice());\n+                }\n+                return result\n+            }\n+            if (result.len() as int) == limit {\n+                return result;\n+            }\n+            bracket_count += match ts.tok {\n+                token::LT => 1,\n+                token::GT => -1,\n+                token::BINOP(token::SHL) => 2,\n+                token::BINOP(token::SHR) => -2,\n+                _ => 0\n+            };\n+            if is_ident(&ts.tok) &&\n+               bracket_count == nesting {\n+                result.push(self.make_sub_span(span, Some(ts.sp)).unwrap());\n+            }\n+        }\n+    }\n+\n+    pub fn sub_span_before_token(&self, span: Span, tok: Token) -> Option<Span> {\n+        let mut toks = self.retokenise_span(span);\n+        let mut prev = toks.next_token();\n+        loop {\n+            if prev.tok == token::EOF {\n+                return None;\n+            }\n+            let next = toks.next_token();\n+            if next.tok == tok {\n+                return self.make_sub_span(span, Some(prev.sp));\n+            }\n+            prev = next;\n+        }\n+    }\n+\n+    // Return an owned vector of the subspans of the tokens that come before tok2\n+    // which is before tok1. If there is no instance of tok2 before tok1, then that\n+    // place in the result is None.\n+    // Everything returned must be inside a set of (non-angle) brackets, but no\n+    // more deeply nested than that.\n+    pub fn sub_spans_before_tokens(&self,\n+                               span: Span,\n+                               tok1: Token,\n+                               tok2: Token) -> Vec<Option<Span>> {\n+        let mut sub_spans : Vec<Option<Span>> = vec!();\n+        let mut toks = self.retokenise_span(span);\n+        let mut prev = toks.next_token();\n+        let mut next = toks.next_token();\n+        let mut stored_val = false;\n+        let mut found_val = false;\n+        let mut bracket_count = 0;\n+        while next.tok != token::EOF {\n+            if bracket_count == 1 {\n+                if next.tok == tok2 {\n+                    sub_spans.push(self.make_sub_span(span, Some(prev.sp)));\n+                    stored_val = true;\n+                    found_val = false;\n+                }\n+                if next.tok == tok1 {\n+                    if !stored_val {\n+                        sub_spans.push(None);\n+                    } else {\n+                        stored_val = false;\n+                    }\n+                    found_val = false;\n+                }\n+                if !stored_val &&\n+                   is_ident(&next.tok) {\n+                    found_val = true;\n+                }\n+            }\n+\n+            bracket_count += match next.tok {\n+                token::LPAREN | token::LBRACE => 1,\n+                token::RPAREN | token::RBRACE => -1,\n+                _ => 0\n+            };\n+\n+            prev = next;\n+            next = toks.next_token();\n+        }\n+        if found_val {\n+            sub_spans.push(None);\n+        }\n+        return sub_spans;\n+    }\n+\n+    pub fn sub_span_after_keyword(&self,\n+                              span: Span,\n+                              keyword: keywords::Keyword) -> Option<Span> {\n+        let mut toks = self.retokenise_span(span);\n+        loop {\n+            let ts = toks.next_token();\n+            if ts.tok == token::EOF {\n+                return None;\n+            }\n+            if is_keyword(keyword, &ts.tok) {\n+                let ts = toks.next_token();\n+                if ts.tok == token::EOF {\n+                    return None\n+                } else {\n+                    return self.make_sub_span(span, Some(ts.sp));\n+                }\n+            }\n+        }\n+    }\n+\n+    // Returns a list of the spans of idents in a patch.\n+    // E.g., For foo::bar<x,t>::baz, we return [foo, bar, baz] (well, their spans)\n+    pub fn spans_for_path_segments(&self, path: &ast::Path) -> Vec<Span> {\n+        if generated_code(path.span) {\n+            return vec!();\n+        }\n+\n+        self.spans_with_brackets(path.span, 0, -1)\n+    }\n+\n+    // Return an owned vector of the subspans of the param identifier\n+    // tokens found in span.\n+    pub fn spans_for_ty_params(&self, span: Span, number: int) -> Vec<Span> {\n+        if generated_code(span) {\n+            return vec!();\n+        }\n+        // Type params are nested within one level of brackets:\n+        // i.e. we want ~[A, B] from Foo<A, B<T,U>>\n+        self.spans_with_brackets(span, 1, number)\n+    }\n+\n+    pub fn report_span_err(&self, kind: &str, span: Span) {\n+        let loc = self.sess.codemap().lookup_char_pos(span.lo);\n+        info!(\"({}) Could not find sub_span in `{}` in {}, line {}\",\n+              kind, self.snippet(span), loc.file.name, loc.line);\n+        self.err_count.set(self.err_count.get()+1);\n+        if self.err_count.get() > 1000 {\n+            self.sess.bug(\"span errors reached 1000, giving up\");\n+        }\n+    }\n+}"}, {"sha": "a04f198da368d36f87c56a44efeb46f547cf59e0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c119903f621a11643d5f299423a2c72eefffec4c", "patch": "@@ -4375,6 +4375,27 @@ pub fn trait_id_of_impl(tcx: &ctxt,\n     }\n }\n \n+/// If the given def ID describes a method belonging to an impl, return the\n+/// ID of the impl that the method belongs to. Otherwise, return `None`.\n+pub fn impl_of_method(tcx: &ctxt, def_id: ast::DefId)\n+                       -> Option<ast::DefId> {\n+    if def_id.krate != LOCAL_CRATE {\n+        return match csearch::get_method(tcx, def_id).container {\n+            TraitContainer(_) => None,\n+            ImplContainer(def_id) => Some(def_id),\n+        };\n+    }\n+    match tcx.methods.borrow().find_copy(&def_id) {\n+        Some(method) => {\n+            match method.container {\n+                TraitContainer(_) => None,\n+                ImplContainer(def_id) => Some(def_id),\n+            }\n+        }\n+        None => None\n+    }\n+}\n+\n /// If the given def ID describes a method belonging to a trait (either a\n /// default method or an implementation of a trait method), return the ID of\n /// the trait that the method belongs to. Otherwise, return `None`."}, {"sha": "c917198e7d4714fa31ab8ac82bee0e3687f7daf8", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c119903f621a11643d5f299423a2c72eefffec4c/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c119903f621a11643d5f299423a2c72eefffec4c", "patch": "@@ -421,6 +421,41 @@ impl CodeMap {\n         fail!(\"asking for {} which we don't know about\", filename);\n     }\n \n+    pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n+        let idx = self.lookup_filemap_idx(bpos);\n+        let fm = self.files.borrow().get(idx).clone();\n+        let offset = bpos - fm.start_pos;\n+        FileMapAndBytePos {fm: fm, pos: offset}\n+    }\n+\n+    // Converts an absolute BytePos to a CharPos relative to the filemap and above.\n+    pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n+        debug!(\"codemap: converting {:?} to char pos\", bpos);\n+        let idx = self.lookup_filemap_idx(bpos);\n+        let files = self.files.borrow();\n+        let map = files.get(idx);\n+\n+        // The number of extra bytes due to multibyte chars in the FileMap\n+        let mut total_extra_bytes = 0;\n+\n+        for mbc in map.multibyte_chars.borrow().iter() {\n+            debug!(\"codemap: {:?}-byte char at {:?}\", mbc.bytes, mbc.pos);\n+            if mbc.pos < bpos {\n+                // every character is at least one byte, so we only\n+                // count the actual extra bytes.\n+                total_extra_bytes += mbc.bytes - 1;\n+                // We should never see a byte position in the middle of a\n+                // character\n+                assert!(bpos.to_uint() >= mbc.pos.to_uint() + mbc.bytes);\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        assert!(map.start_pos.to_uint() + total_extra_bytes <= bpos.to_uint());\n+        CharPos(bpos.to_uint() - map.start_pos.to_uint() - total_extra_bytes)\n+    }\n+\n     fn lookup_filemap_idx(&self, pos: BytePos) -> uint {\n         let files = self.files.borrow();\n         let files = files;\n@@ -491,41 +526,6 @@ impl CodeMap {\n             col: chpos - linechpos\n         }\n     }\n-\n-    fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n-        let idx = self.lookup_filemap_idx(bpos);\n-        let fm = self.files.borrow().get(idx).clone();\n-        let offset = bpos - fm.start_pos;\n-        FileMapAndBytePos {fm: fm, pos: offset}\n-    }\n-\n-    // Converts an absolute BytePos to a CharPos relative to the filemap.\n-    fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n-        debug!(\"codemap: converting {:?} to char pos\", bpos);\n-        let idx = self.lookup_filemap_idx(bpos);\n-        let files = self.files.borrow();\n-        let map = files.get(idx);\n-\n-        // The number of extra bytes due to multibyte chars in the FileMap\n-        let mut total_extra_bytes = 0;\n-\n-        for mbc in map.multibyte_chars.borrow().iter() {\n-            debug!(\"codemap: {:?}-byte char at {:?}\", mbc.bytes, mbc.pos);\n-            if mbc.pos < bpos {\n-                // every character is at least one byte, so we only\n-                // count the actual extra bytes.\n-                total_extra_bytes += mbc.bytes - 1;\n-                // We should never see a byte position in the middle of a\n-                // character\n-                assert!(bpos.to_uint() >= mbc.pos.to_uint() + mbc.bytes);\n-            } else {\n-                break;\n-            }\n-        }\n-\n-        assert!(map.start_pos.to_uint() + total_extra_bytes <= bpos.to_uint());\n-        CharPos(bpos.to_uint() - map.start_pos.to_uint() - total_extra_bytes)\n-    }\n }\n \n #[cfg(test)]"}, {"sha": "e1cbf7549467ef5d56f44c7f412b84ed75508e99", "filename": "src/test/run-make/save-analysis/Makefile", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c119903f621a11643d5f299423a2c72eefffec4c/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c119903f621a11643d5f299423a2c72eefffec4c/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile?ref=c119903f621a11643d5f299423a2c72eefffec4c", "patch": "@@ -0,0 +1,3 @@\n+-include ../tools.mk\n+all:\n+\t$(RUSTC) foo.rs -Zsave-analysis"}, {"sha": "bf5cc833d32f93f8b08c5d2135c6f5e6c8868226", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c119903f621a11643d5f299423a2c72eefffec4c/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c119903f621a11643d5f299423a2c72eefffec4c/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=c119903f621a11643d5f299423a2c72eefffec4c", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+    f: int\n+}\n+\n+impl Foo {\n+    fn bar(&self) -> int {\n+        println!(\"f is {}\", self.f);\n+        self.f\n+    }\n+}\n+\n+trait Tr {\n+    fn tar(&self, x: Box<Foo>) -> Foo;\n+}\n+\n+impl Tr for Foo {\n+    fn tar(&self, x: Box<Foo>) -> Foo {\n+        Foo{ f: self.f + x.f }\n+    }\n+}\n+\n+trait Tr2<X, Y: Tr> {\n+    fn squid(&self, y: &Y, z: Self) -> Box<X>;\n+}\n+\n+impl Tr2<Foo, Foo> for Foo {\n+    fn squid(&self, y: &Foo, z: Foo) -> Box<Foo> {\n+        box Foo { f: y.f + z.f + self.f }\n+    }\n+}\n+\n+enum En {\n+    Var1,\n+    Var2,\n+    Var3(int, int, Foo)\n+}\n+\n+fn main() {\n+    let x = Foo { f: 237 };\n+    let _f = x.bar();\n+    let en = Var2;\n+\n+    let _ = match en {\n+        Var1 => x.bar(),\n+        Var2 => 34,\n+        Var3(x, y, f) => f.bar()\n+    };\n+}"}]}