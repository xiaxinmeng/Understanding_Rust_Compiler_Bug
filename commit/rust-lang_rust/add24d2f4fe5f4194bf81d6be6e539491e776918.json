{"sha": "add24d2f4fe5f4194bf81d6be6e539491e776918", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZDI0ZDJmNGZlNWY0MTk0YmY4MWQ2YmU2ZTUzOTQ5MWU3NzY5MTg=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-07-05T17:33:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-05T17:33:13Z"}, "message": "Rollup merge of #85377 - ijackson:abort-docs, r=m-ou-se\n\naborts: Clarify documentation and comments\n\nIn the docs for intrinsics::abort():\n\n * Strengthen the recommendation by to use process::abort instead.\n * Document the fact that it sometimes (ab)uses an LLVM debug trap and what the likely consequences are.\n * State that the precise behaviour is unstable.\n\nIn the docs for process::abort():\n\n * Promise that we have the same behaviour as C `abort()`.\n * Document the likely consequences, including, specifically, the consequences on Unix.\n\nIn the internal comment for unix::abort_internal:\n\n * Refer to the public docs for the public API functions.\n * Correct and expand the description of libc::abort.  Specifically:\n * Do not claim that abort() unregisters signal handlers.  It doesn't; it honours the SIGABRT handler.\n * Discuss, extensively, the issue with abort() flushing stdio buffers.\n * Describe the glibc behaviour in some detail.\n\nCo-authored-by: Mark Wooding <mdw@distorted.org.uk>\nSigned-off-by: Ian Jackson <ijackson@chiark.greenend.org.uk>\n\nFixes #40230", "tree": {"sha": "a04e210a35be1e422b5eb0dbb642042da12d031b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a04e210a35be1e422b5eb0dbb642042da12d031b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/add24d2f4fe5f4194bf81d6be6e539491e776918", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg40JZCRBK7hj4Ov3rIwAA1HQIAEAxW+aQeyzEobg3d/30vMua\nQTE0xit5BPuq9x6wYSR22IPDe1WGU82XLjxvDtFO3OdJC3WOrHWbTBNBR1uDe/Io\nQn/jXLyzado2dItjOxl/2U7wDyj/dxqPBQXLxbDZV+6eN3FvsuxtvFGGZk5TnKsS\nvrHKUNrgVRN4+bD1graKHNrIEyDfkeBW9NnJVg4hOFqvNYccA8i1oRn/zoBuO08k\nLb6LkB0Q8KFOfAI3aQK6cJv3NJEka8D7niO20dNq5uUgKI87rvX3+VVNXlcuM4m5\nGPFjepLNp5I7S5WpZvpWevKWQNCbo+3ra0rS6ek9voAIVbt+C0syhH6Hmn88VrY=\n=8TVQ\n-----END PGP SIGNATURE-----\n", "payload": "tree a04e210a35be1e422b5eb0dbb642042da12d031b\nparent 1fcd9abbb1f80a0a467d8e54b573a7ba207925c7\nparent 08d912fdcc4b9c8af3c00db78804f85abfadbd7a\nauthor Yuki Okushi <jtitor@2k36.org> 1625506393 +0900\ncommitter GitHub <noreply@github.com> 1625506393 +0900\n\nRollup merge of #85377 - ijackson:abort-docs, r=m-ou-se\n\naborts: Clarify documentation and comments\n\nIn the docs for intrinsics::abort():\n\n * Strengthen the recommendation by to use process::abort instead.\n * Document the fact that it sometimes (ab)uses an LLVM debug trap and what the likely consequences are.\n * State that the precise behaviour is unstable.\n\nIn the docs for process::abort():\n\n * Promise that we have the same behaviour as C `abort()`.\n * Document the likely consequences, including, specifically, the consequences on Unix.\n\nIn the internal comment for unix::abort_internal:\n\n * Refer to the public docs for the public API functions.\n * Correct and expand the description of libc::abort.  Specifically:\n * Do not claim that abort() unregisters signal handlers.  It doesn't; it honours the SIGABRT handler.\n * Discuss, extensively, the issue with abort() flushing stdio buffers.\n * Describe the glibc behaviour in some detail.\n\nCo-authored-by: Mark Wooding <mdw@distorted.org.uk>\nSigned-off-by: Ian Jackson <ijackson@chiark.greenend.org.uk>\n\nFixes #40230\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/add24d2f4fe5f4194bf81d6be6e539491e776918", "html_url": "https://github.com/rust-lang/rust/commit/add24d2f4fe5f4194bf81d6be6e539491e776918", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/add24d2f4fe5f4194bf81d6be6e539491e776918/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fcd9abbb1f80a0a467d8e54b573a7ba207925c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fcd9abbb1f80a0a467d8e54b573a7ba207925c7", "html_url": "https://github.com/rust-lang/rust/commit/1fcd9abbb1f80a0a467d8e54b573a7ba207925c7"}, {"sha": "08d912fdcc4b9c8af3c00db78804f85abfadbd7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/08d912fdcc4b9c8af3c00db78804f85abfadbd7a", "html_url": "https://github.com/rust-lang/rust/commit/08d912fdcc4b9c8af3c00db78804f85abfadbd7a"}], "stats": {"total": 59, "additions": 50, "deletions": 9}, "files": [{"sha": "c5a4bbd32080461e6b5fece33b964ce967329966", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/add24d2f4fe5f4194bf81d6be6e539491e776918/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add24d2f4fe5f4194bf81d6be6e539491e776918/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=add24d2f4fe5f4194bf81d6be6e539491e776918", "patch": "@@ -717,8 +717,14 @@ extern \"rust-intrinsic\" {\n     /// Therefore, implementations must not require the user to uphold\n     /// any safety invariants.\n     ///\n-    /// A more user-friendly and stable version of this operation is\n-    /// [`std::process::abort`](../../std/process/fn.abort.html).\n+    /// [`std::process::abort`](../../std/process/fn.abort.html) is to be preferred if possible,\n+    /// as its behavior is more user-friendly and more stable.\n+    ///\n+    /// The current implementation of `intrinsics::abort` is to invoke an invalid instruction,\n+    /// on most platforms.\n+    /// On Unix, the\n+    /// process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n+    /// `SIGBUS`.  The precise behaviour is not guaranteed and not stable.\n     pub fn abort() -> !;\n \n     /// Informs the optimizer that this point in the code is not reachable,"}, {"sha": "11a0432ce27a1ebb91e8f90724cfe87fd694a783", "filename": "library/std/src/process.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/add24d2f4fe5f4194bf81d6be6e539491e776918/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add24d2f4fe5f4194bf81d6be6e539491e776918/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=add24d2f4fe5f4194bf81d6be6e539491e776918", "patch": "@@ -1898,6 +1898,9 @@ pub fn exit(code: i32) -> ! {\n /// process, no destructors on the current stack or any other thread's stack\n /// will be run.\n ///\n+/// Rust IO buffers (eg, from `BufWriter`) will not be flushed.\n+/// Likewise, C stdio buffers will (on most platforms) not be flushed.\n+///\n /// This is in contrast to the default behaviour of [`panic!`] which unwinds\n /// the current thread's stack and calls all destructors.\n /// When `panic=\"abort\"` is set, either as an argument to `rustc` or in a\n@@ -1908,6 +1911,10 @@ pub fn exit(code: i32) -> ! {\n /// this function at a known point where there are no more destructors left\n /// to run.\n ///\n+/// The process's termination will be similar to that from the C `abort()`\n+/// function.  On Unix, the process will terminate with signal `SIGABRT`, which\n+/// typically means that the shell prints \"Aborted\".\n+///\n /// # Examples\n ///\n /// ```no_run"}, {"sha": "2da71b2a448ac1d8aea5a6f2be657faeaebf2723", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/add24d2f4fe5f4194bf81d6be6e539491e776918/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/add24d2f4fe5f4194bf81d6be6e539491e776918/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=add24d2f4fe5f4194bf81d6be6e539491e776918", "patch": "@@ -217,13 +217,41 @@ pub fn cvt_nz(error: libc::c_int) -> crate::io::Result<()> {\n     if error == 0 { Ok(()) } else { Err(crate::io::Error::from_raw_os_error(error)) }\n }\n \n-// On Unix-like platforms, libc::abort will unregister signal handlers\n-// including the SIGABRT handler, preventing the abort from being blocked, and\n-// fclose streams, with the side effect of flushing them so libc buffered\n-// output will be printed.  Additionally the shell will generally print a more\n-// understandable error message like \"Abort trap\" rather than \"Illegal\n-// instruction\" that intrinsics::abort would cause, as intrinsics::abort is\n-// implemented as an illegal instruction.\n+// libc::abort() will run the SIGABRT handler.  That's fine because anyone who\n+// installs a SIGABRT handler already has to expect it to run in Very Bad\n+// situations (eg, malloc crashing).\n+//\n+// Current glibc's abort() function unblocks SIGABRT, raises SIGABRT, clears the\n+// SIGABRT handler and raises it again, and then starts to get creative.\n+//\n+// See the public documentation for `intrinsics::abort()` and `process::abort()`\n+// for further discussion.\n+//\n+// There is confusion about whether libc::abort() flushes stdio streams.\n+// libc::abort() is required by ISO C 99 (7.14.1.1p5) to be async-signal-safe,\n+// so flushing streams is at least extremely hard, if not entirely impossible.\n+//\n+// However, some versions of POSIX (eg IEEE Std 1003.1-2001) required abort to\n+// do so.  In 1003.1-2004 this was fixed.\n+//\n+// glibc's implementation did the flush, unsafely, before glibc commit\n+// 91e7cf982d01 `abort: Do not flush stdio streams [BZ #15436]' by Florian\n+// Weimer.  According to glibc's NEWS:\n+//\n+//    The abort function terminates the process immediately, without flushing\n+//    stdio streams.  Previous glibc versions used to flush streams, resulting\n+//    in deadlocks and further data corruption.  This change also affects\n+//    process aborts as the result of assertion failures.\n+//\n+// This is an accurate description of the problem.  The only solution for\n+// program with nontrivial use of C stdio is a fixed libc - one which does not\n+// try to flush in abort - since even libc-internal errors, and assertion\n+// failures generated from C, will go via abort().\n+//\n+// On systems with old, buggy, libcs, the impact can be severe for a\n+// multithreaded C program.  It is much less severe for Rust, because Rust\n+// stdlib doesn't use libc stdio buffering.  In a typical Rust program, which\n+// does not use C stdio, even a buggy libc::abort() is, in fact, safe.\n pub fn abort_internal() -> ! {\n     unsafe { libc::abort() }\n }"}]}