{"sha": "26aad254875464ff352a4e18d16f668b5bd9b7cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YWFkMjU0ODc1NDY0ZmYzNTJhNGUxOGQxNmY2NjhiNWJkOWI3Y2I=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-05-17T18:28:50Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-05-19T17:34:42Z"}, "message": "rustc: introduce {ast,hir}::AnonConst to consolidate so-called \"embedded constants\".", "tree": {"sha": "82c41e684745a322d3a33156dd00016136a5ce45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82c41e684745a322d3a33156dd00016136a5ce45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26aad254875464ff352a4e18d16f668b5bd9b7cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26aad254875464ff352a4e18d16f668b5bd9b7cb", "html_url": "https://github.com/rust-lang/rust/commit/26aad254875464ff352a4e18d16f668b5bd9b7cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26aad254875464ff352a4e18d16f668b5bd9b7cb/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "072b0f617fdd2ccb3bc6dd08718acf9504b7ed3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/072b0f617fdd2ccb3bc6dd08718acf9504b7ed3a", "html_url": "https://github.com/rust-lang/rust/commit/072b0f617fdd2ccb3bc6dd08718acf9504b7ed3a"}], "stats": {"total": 640, "additions": 334, "deletions": 306}, "files": [{"sha": "2ef022cecdf49bf3eb7fb04d38c3e381e8351fa3", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -272,6 +272,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_decl(&mut self, d: &'v Decl) {\n         walk_decl(self, d)\n     }\n+    fn visit_anon_const(&mut self, c: &'v AnonConst) {\n+        walk_anon_const(self, c)\n+    }\n     fn visit_expr(&mut self, ex: &'v Expr) {\n         walk_expr(self, ex)\n     }\n@@ -547,7 +550,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                generics,\n                                parent_item_id,\n                                variant.span);\n-    walk_list!(visitor, visit_nested_body, variant.node.disr_expr);\n+    walk_list!(visitor, visit_anon_const, &variant.node.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n \n@@ -576,9 +579,9 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyPath(ref qpath) => {\n             visitor.visit_qpath(qpath, typ.id, typ.span);\n         }\n-        TyArray(ref ty, length) => {\n+        TyArray(ref ty, ref length) => {\n             visitor.visit_ty(ty);\n-            visitor.visit_nested_body(length)\n+            visitor.visit_anon_const(length)\n         }\n         TyTraitObject(ref bounds, ref lifetime) => {\n             for bound in bounds {\n@@ -592,8 +595,8 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n             walk_list!(visitor, visit_lifetime, lifetimes);\n         }\n-        TyTypeof(expression) => {\n-            visitor.visit_nested_body(expression)\n+        TyTypeof(ref expression) => {\n+            visitor.visit_anon_const(expression)\n         }\n         TyInfer | TyErr => {}\n     }\n@@ -944,6 +947,11 @@ pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n     }\n }\n \n+pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonConst) {\n+    visitor.visit_id(constant.id);\n+    visitor.visit_nested_body(constant.body);\n+}\n+\n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     visitor.visit_id(expression.id);\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n@@ -954,9 +962,9 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprArray(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprRepeat(ref element, count) => {\n+        ExprRepeat(ref element, ref count) => {\n             visitor.visit_expr(element);\n-            visitor.visit_nested_body(count)\n+            visitor.visit_anon_const(count)\n         }\n         ExprStruct(ref qpath, ref fields, ref optional_base) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);"}, {"sha": "02c2aa1c71ba08efcb81d296198a4a77a2d79dcb", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -1080,12 +1080,10 @@ impl<'a> LoweringContext<'a> {\n                 }),\n             )),\n             TyKind::Array(ref ty, ref length) => {\n-                let length = self.lower_body(None, |this| this.lower_expr(length));\n-                hir::TyArray(self.lower_ty(ty, itctx), length)\n+                hir::TyArray(self.lower_ty(ty, itctx), self.lower_anon_const(length))\n             }\n             TyKind::Typeof(ref expr) => {\n-                let expr = self.lower_body(None, |this| this.lower_expr(expr));\n-                hir::TyTypeof(expr)\n+                hir::TyTypeof(self.lower_anon_const(expr))\n             }\n             TyKind::TraitObject(ref bounds, kind) => {\n                 let mut lifetime_bound = None;\n@@ -1365,10 +1363,7 @@ impl<'a> LoweringContext<'a> {\n                 name: v.node.ident.name,\n                 attrs: self.lower_attrs(&v.node.attrs),\n                 data: self.lower_variant_data(&v.node.data),\n-                disr_expr: v.node\n-                    .disr_expr\n-                    .as_ref()\n-                    .map(|e| self.lower_body(None, |this| this.lower_expr(e))),\n+                disr_expr: v.node.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n             },\n             span: v.span,\n         }\n@@ -2927,6 +2922,16 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn lower_anon_const(&mut self, c: &AnonConst) -> hir::AnonConst {\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(c.id);\n+\n+        hir::AnonConst {\n+            id: node_id,\n+            hir_id,\n+            body: self.lower_body(None, |this| this.lower_expr(&c.value)),\n+        }\n+    }\n+\n     fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n         let kind = match e.node {\n             ExprKind::Box(ref inner) => hir::ExprBox(P(self.lower_expr(inner))),\n@@ -2936,7 +2941,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ExprKind::Repeat(ref expr, ref count) => {\n                 let expr = P(self.lower_expr(expr));\n-                let count = self.lower_body(None, |this| this.lower_expr(count));\n+                let count = self.lower_anon_const(count);\n                 hir::ExprRepeat(expr, count)\n             }\n             ExprKind::Tup(ref elts) => {"}, {"sha": "8f28dfab1e772d9307088d55b1461186502c77ea", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -202,6 +202,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             NodeImplItem(n) => EntryImplItem(parent, dep_node_index, n),\n             NodeVariant(n) => EntryVariant(parent, dep_node_index, n),\n             NodeField(n) => EntryField(parent, dep_node_index, n),\n+            NodeAnonConst(n) => EntryAnonConst(parent, dep_node_index, n),\n             NodeExpr(n) => EntryExpr(parent, dep_node_index, n),\n             NodeStmt(n) => EntryStmt(parent, dep_node_index, n),\n             NodeTy(n) => EntryTy(parent, dep_node_index, n),\n@@ -390,6 +391,14 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    fn visit_anon_const(&mut self, constant: &'hir AnonConst) {\n+        self.insert(constant.id, NodeAnonConst(constant));\n+\n+        self.with_parent(constant.id, |this| {\n+            intravisit::walk_anon_const(this, constant);\n+        });\n+    }\n+\n     fn visit_expr(&mut self, expr: &'hir Expr) {\n         self.insert(expr.id, NodeExpr(expr));\n "}, {"sha": "03b6dc1676fb33d63fb89cdb743fa72eb740f6d4", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 40, "deletions": 62, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -33,7 +33,6 @@ pub struct DefCollector<'a> {\n pub struct MacroInvocationData {\n     pub mark: Mark,\n     pub def_index: DefIndex,\n-    pub const_expr: bool,\n }\n \n impl<'a> DefCollector<'a> {\n@@ -74,25 +73,10 @@ impl<'a> DefCollector<'a> {\n         self.parent_def = parent;\n     }\n \n-    pub fn visit_const_expr(&mut self, expr: &Expr) {\n-        match expr.node {\n-            // Find the node which will be used after lowering.\n-            ExprKind::Paren(ref inner) => return self.visit_const_expr(inner),\n-            ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id, true),\n-            // FIXME(eddyb) Closures should have separate\n-            // function definition IDs and expression IDs.\n-            ExprKind::Closure(..) => return,\n-            _ => {}\n-        }\n-\n-        self.create_def(expr.id, DefPathData::Initializer, REGULAR_SPACE, expr.span);\n-    }\n-\n-    fn visit_macro_invoc(&mut self, id: NodeId, const_expr: bool) {\n+    fn visit_macro_invoc(&mut self, id: NodeId) {\n         if let Some(ref mut visit) = self.visit_macro_invoc {\n             visit(MacroInvocationData {\n                 mark: id.placeholder_to_mark(),\n-                const_expr,\n                 def_index: self.parent_def.unwrap(),\n             })\n         }\n@@ -119,7 +103,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n                 DefPathData::ValueNs(i.ident.name.as_interned_str()),\n             ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name.as_interned_str()),\n-            ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n+            ItemKind::Mac(..) => return self.visit_macro_invoc(i.id),\n             ItemKind::GlobalAsm(..) => DefPathData::Misc,\n             ItemKind::Use(..) => {\n                 return visit::walk_item(self, i);\n@@ -129,30 +113,6 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n         self.with_parent(def, |this| {\n             match i.node {\n-                ItemKind::Enum(ref enum_definition, _) => {\n-                    for v in &enum_definition.variants {\n-                        let variant_def_index =\n-                            this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.ident\n-                                                                      .name.as_interned_str()),\n-                                            REGULAR_SPACE,\n-                                            v.span);\n-                        this.with_parent(variant_def_index, |this| {\n-                            for (index, field) in v.node.data.fields().iter().enumerate() {\n-                                let name = field.ident.map(|ident| ident.name)\n-                                    .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                                this.create_def(field.id,\n-                                                DefPathData::Field(name.as_interned_str()),\n-                                                REGULAR_SPACE,\n-                                                field.span);\n-                            }\n-\n-                            if let Some(ref expr) = v.node.disr_expr {\n-                                this.visit_const_expr(expr);\n-                            }\n-                        });\n-                    }\n-                }\n                 ItemKind::Struct(ref struct_def, _) | ItemKind::Union(ref struct_def, _) => {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n@@ -161,15 +121,6 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                                         REGULAR_SPACE,\n                                         i.span);\n                     }\n-\n-                    for (index, field) in struct_def.fields().iter().enumerate() {\n-                        let name = field.ident.map(|ident| ident.name)\n-                            .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                        this.create_def(field.id,\n-                                        DefPathData::Field(name.as_interned_str()),\n-                                        REGULAR_SPACE,\n-                                        field.span);\n-                    }\n                 }\n                 _ => {}\n             }\n@@ -184,7 +135,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         if let ForeignItemKind::Macro(_) = foreign_item.node {\n-            return self.visit_macro_invoc(foreign_item.id, false);\n+            return self.visit_macro_invoc(foreign_item.id);\n         }\n \n         let def = self.create_def(foreign_item.id,\n@@ -197,6 +148,28 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         });\n     }\n \n+    fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+        let def = self.create_def(v.node.data.id(),\n+                                  DefPathData::EnumVariant(v.node.ident\n+                                                            .name.as_interned_str()),\n+                                  REGULAR_SPACE,\n+                                  v.span);\n+        self.with_parent(def, |this| visit::walk_variant(this, v, g, item_id));\n+    }\n+\n+    fn visit_variant_data(&mut self, data: &'a VariantData, _: Ident,\n+                          _: &'a Generics, _: NodeId, _: Span) {\n+        for (index, field) in data.fields().iter().enumerate() {\n+            let name = field.ident.map(|ident| ident.name)\n+                .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n+            let def = self.create_def(field.id,\n+                                      DefPathData::Field(name.as_interned_str()),\n+                                      REGULAR_SPACE,\n+                                      field.span);\n+            self.with_parent(def, |this| this.visit_struct_field(field));\n+        }\n+    }\n+\n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n         match *param {\n             GenericParam::Lifetime(ref lifetime_def) => {\n@@ -227,7 +200,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             TraitItemKind::Type(..) => {\n                 DefPathData::AssocTypeInTrait(ti.ident.name.as_interned_str())\n             },\n-            TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n+            TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id),\n         };\n \n         let def = self.create_def(ti.id, def_data, ITEM_LIKE_SPACE, ti.span);\n@@ -239,7 +212,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n                 DefPathData::ValueNs(ii.ident.name.as_interned_str()),\n             ImplItemKind::Type(..) => DefPathData::AssocTypeInImpl(ii.ident.name.as_interned_str()),\n-            ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n+            ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id),\n         };\n \n         let def = self.create_def(ii.id, def_data, ITEM_LIKE_SPACE, ii.span);\n@@ -248,17 +221,24 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_pat(&mut self, pat: &'a Pat) {\n         match pat.node {\n-            PatKind::Mac(..) => return self.visit_macro_invoc(pat.id, false),\n+            PatKind::Mac(..) => return self.visit_macro_invoc(pat.id),\n             _ => visit::walk_pat(self, pat),\n         }\n     }\n \n+    fn visit_anon_const(&mut self, constant: &'a AnonConst) {\n+        let def = self.create_def(constant.id,\n+                                  DefPathData::AnonConst,\n+                                  REGULAR_SPACE,\n+                                  constant.value.span);\n+        self.with_parent(def, |this| visit::walk_anon_const(this, constant));\n+    }\n+\n     fn visit_expr(&mut self, expr: &'a Expr) {\n         let parent_def = self.parent_def;\n \n         match expr.node {\n-            ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id, false),\n-            ExprKind::Repeat(_, ref count) => self.visit_const_expr(count),\n+            ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id),\n             ExprKind::Closure(..) => {\n                 let def = self.create_def(expr.id,\n                                           DefPathData::ClosureExpr,\n@@ -275,20 +255,18 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_ty(&mut self, ty: &'a Ty) {\n         match ty.node {\n-            TyKind::Mac(..) => return self.visit_macro_invoc(ty.id, false),\n-            TyKind::Array(_, ref length) => self.visit_const_expr(length),\n+            TyKind::Mac(..) => return self.visit_macro_invoc(ty.id),\n             TyKind::ImplTrait(..) => {\n                 self.create_def(ty.id, DefPathData::ImplTrait, REGULAR_SPACE, ty.span);\n             }\n-            TyKind::Typeof(ref expr) => self.visit_const_expr(expr),\n             _ => {}\n         }\n         visit::walk_ty(self, ty);\n     }\n \n     fn visit_stmt(&mut self, stmt: &'a Stmt) {\n         match stmt.node {\n-            StmtKind::Mac(..) => self.visit_macro_invoc(stmt.id, false),\n+            StmtKind::Mac(..) => self.visit_macro_invoc(stmt.id),\n             _ => visit::walk_stmt(self, stmt),\n         }\n     }\n@@ -298,7 +276,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             match nt.0 {\n                 token::NtExpr(ref expr) => {\n                     if let ExprKind::Mac(..) = expr.node {\n-                        self.visit_macro_invoc(expr.id, false);\n+                        self.visit_macro_invoc(expr.id);\n                     }\n                 }\n                 _ => {}"}, {"sha": "e380a7bfbfebe33ba38244611b910ffa7d91e391", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -231,9 +231,8 @@ impl DefKey {\n             DefPathData::Misc |\n             DefPathData::ClosureExpr |\n             DefPathData::StructCtor |\n-            DefPathData::Initializer |\n-            DefPathData::ImplTrait |\n-            DefPathData::Typeof => {}\n+            DefPathData::AnonConst |\n+            DefPathData::ImplTrait => {}\n         };\n \n         disambiguator.hash(&mut hasher);\n@@ -389,12 +388,10 @@ pub enum DefPathData {\n     Field(InternedString),\n     /// Implicit ctor for a tuple-like struct\n     StructCtor,\n-    /// Initializer for a const\n-    Initializer,\n+    /// A constant expression (see {ast,hir}::AnonConst).\n+    AnonConst,\n     /// An `impl Trait` type node.\n     ImplTrait,\n-    /// A `typeof` type node.\n-    Typeof,\n \n     /// GlobalMetaData identifies a piece of crate metadata that is global to\n     /// a whole crate (as opposed to just one item). GlobalMetaData components\n@@ -665,9 +662,8 @@ impl DefPathData {\n             Misc |\n             ClosureExpr |\n             StructCtor |\n-            Initializer |\n-            ImplTrait |\n-            Typeof => None\n+            AnonConst |\n+            ImplTrait => None\n         }\n     }\n \n@@ -696,9 +692,8 @@ impl DefPathData {\n             Misc => \"{{?}}\",\n             ClosureExpr => \"{{closure}}\",\n             StructCtor => \"{{constructor}}\",\n-            Initializer => \"{{initializer}}\",\n+            AnonConst => \"{{constant}}\",\n             ImplTrait => \"{{impl-Trait}}\",\n-            Typeof => \"{{typeof}}\",\n         };\n \n         Symbol::intern(s).as_interned_str()"}, {"sha": "951bb6ad1501b06368327659536eb1f52c37840e", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -53,6 +53,7 @@ pub enum Node<'hir> {\n     NodeImplItem(&'hir ImplItem),\n     NodeVariant(&'hir Variant),\n     NodeField(&'hir StructField),\n+    NodeAnonConst(&'hir AnonConst),\n     NodeExpr(&'hir Expr),\n     NodeStmt(&'hir Stmt),\n     NodeTy(&'hir Ty),\n@@ -85,6 +86,7 @@ enum MapEntry<'hir> {\n     EntryImplItem(NodeId, DepNodeIndex, &'hir ImplItem),\n     EntryVariant(NodeId, DepNodeIndex, &'hir Variant),\n     EntryField(NodeId, DepNodeIndex, &'hir StructField),\n+    EntryAnonConst(NodeId, DepNodeIndex, &'hir AnonConst),\n     EntryExpr(NodeId, DepNodeIndex, &'hir Expr),\n     EntryStmt(NodeId, DepNodeIndex, &'hir Stmt),\n     EntryTy(NodeId, DepNodeIndex, &'hir Ty),\n@@ -120,6 +122,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryImplItem(id, _, _) => id,\n             EntryVariant(id, _, _) => id,\n             EntryField(id, _, _) => id,\n+            EntryAnonConst(id, _, _) => id,\n             EntryExpr(id, _, _) => id,\n             EntryStmt(id, _, _) => id,\n             EntryTy(id, _, _) => id,\n@@ -147,6 +150,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryImplItem(_, _, n) => NodeImplItem(n),\n             EntryVariant(_, _, n) => NodeVariant(n),\n             EntryField(_, _, n) => NodeField(n),\n+            EntryAnonConst(_, _, n) => NodeAnonConst(n),\n             EntryExpr(_, _, n) => NodeExpr(n),\n             EntryStmt(_, _, n) => NodeStmt(n),\n             EntryTy(_, _, n) => NodeTy(n),\n@@ -193,6 +197,8 @@ impl<'hir> MapEntry<'hir> {\n                 }\n             }\n \n+            EntryAnonConst(_, _, constant) => Some(constant.body),\n+\n             EntryExpr(_, _, expr) => {\n                 match expr.node {\n                     ExprClosure(.., body, _, _) => Some(body),\n@@ -290,6 +296,7 @@ impl<'hir> Map<'hir> {\n             EntryLifetime(_, dep_node_index, _) |\n             EntryTyParam(_, dep_node_index, _) |\n             EntryVisibility(_, dep_node_index, _) |\n+            EntryAnonConst(_, dep_node_index, _) |\n             EntryExpr(_, dep_node_index, _) |\n             EntryLocal(_, dep_node_index, _) |\n             EntryMacroDef(dep_node_index, _) |\n@@ -434,6 +441,7 @@ impl<'hir> Map<'hir> {\n                 Some(Def::Variant(def_id))\n             }\n             NodeField(_) |\n+            NodeAnonConst(_) |\n             NodeExpr(_) |\n             NodeStmt(_) |\n             NodeTy(_) |\n@@ -495,15 +503,11 @@ impl<'hir> Map<'hir> {\n \n     /// Returns the `NodeId` that corresponds to the definition of\n     /// which this is the body of, i.e. a `fn`, `const` or `static`\n-    /// item (possibly associated), or a closure, or the body itself\n-    /// for embedded constant expressions (e.g. `N` in `[T; N]`).\n+    /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n         let parent = self.get_parent_node(node_id);\n-        if self.map[parent.as_usize()].is_body_owner(node_id) {\n-            parent\n-        } else {\n-            node_id\n-        }\n+        assert!(self.map[parent.as_usize()].is_body_owner(node_id));\n+        parent\n     }\n \n     pub fn body_owner_def_id(&self, id: BodyId) -> DefId {\n@@ -520,19 +524,7 @@ impl<'hir> Map<'hir> {\n                 self.dep_graph.read(def_path_hash.to_dep_node(DepKind::HirBody));\n             }\n \n-            if let Some(body_id) = entry.associated_body() {\n-                // For item-like things and closures, the associated\n-                // body has its own distinct id, and that is returned\n-                // by `associated_body`.\n-                Some(body_id)\n-            } else {\n-                // For some expressions, the expression is its own body.\n-                if let EntryExpr(_, _, expr) = entry {\n-                    Some(BodyId { node_id: expr.id })\n-                } else {\n-                    None\n-                }\n-            }\n+            entry.associated_body()\n         } else {\n             bug!(\"no entry for id `{}`\", id)\n         }\n@@ -547,17 +539,11 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body_owner_kind(&self, id: NodeId) -> BodyOwnerKind {\n-        // Handle constants in enum discriminants, types, and repeat expressions.\n-        let def_id = self.local_def_id(id);\n-        let def_key = self.def_key(def_id);\n-        if def_key.disambiguated_data.data == DefPathData::Initializer {\n-            return BodyOwnerKind::Const;\n-        }\n-\n         match self.get(id) {\n             NodeItem(&Item { node: ItemConst(..), .. }) |\n             NodeTraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n-            NodeImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) => {\n+            NodeImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n+            NodeAnonConst(_) => {\n                 BodyOwnerKind::Const\n             }\n             NodeItem(&Item { node: ItemStatic(_, m, _), .. }) => {\n@@ -982,6 +968,7 @@ impl<'hir> Map<'hir> {\n             Some(EntryImplItem(_, _, impl_item)) => impl_item.span,\n             Some(EntryVariant(_, _, variant)) => variant.span,\n             Some(EntryField(_, _, field)) => field.span,\n+            Some(EntryAnonConst(_, _, constant)) => self.body(constant.body).value.span,\n             Some(EntryExpr(_, _, expr)) => expr.span,\n             Some(EntryStmt(_, _, stmt)) => stmt.span,\n             Some(EntryTy(_, _, ty)) => ty.span,\n@@ -1201,6 +1188,7 @@ impl<'a> print::State<'a> {\n             NodeTraitItem(a)   => self.print_trait_item(a),\n             NodeImplItem(a)    => self.print_impl_item(a),\n             NodeVariant(a)     => self.print_variant(&a),\n+            NodeAnonConst(a)   => self.print_anon_const(&a),\n             NodeExpr(a)        => self.print_expr(&a),\n             NodeStmt(a)        => self.print_stmt(&a),\n             NodeTy(a)          => self.print_type(&a),\n@@ -1306,6 +1294,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                     field.name,\n                     path_str(), id_str)\n         }\n+        Some(NodeAnonConst(_)) => {\n+            format!(\"const {}{}\", map.node_to_pretty_string(id), id_str)\n+        }\n         Some(NodeExpr(_)) => {\n             format!(\"expr {}{}\", map.node_to_pretty_string(id), id_str)\n         }"}, {"sha": "caae79961a6d1383f3ae41480d2d60c4ce502d37", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -1272,6 +1272,18 @@ pub enum BodyOwnerKind {\n     Static(Mutability),\n }\n \n+/// A constant (expression) that's not an item or associated item,\n+/// but needs its own `DefId` for type-checking, const-eval, etc.\n+/// These are usually found nested inside types (e.g. array lengths)\n+/// or expressions (e.g. repeat counts), and also used to define\n+/// explicit discriminant values for enum variants.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct AnonConst {\n+    pub id: NodeId,\n+    pub hir_id: HirId,\n+    pub body: BodyId,\n+}\n+\n /// An expression\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Expr {\n@@ -1419,7 +1431,7 @@ pub enum Expr_ {\n     ///\n     /// For example, `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n-    ExprRepeat(P<Expr>, BodyId),\n+    ExprRepeat(P<Expr>, AnonConst),\n \n     /// A suspension point for generators. This is `yield <expr>` in Rust.\n     ExprYield(P<Expr>),\n@@ -1677,7 +1689,7 @@ pub enum Ty_ {\n     /// A variable length slice (`[T]`)\n     TySlice(P<Ty>),\n     /// A fixed length array (`[T; n]`)\n-    TyArray(P<Ty>, BodyId),\n+    TyArray(P<Ty>, AnonConst),\n     /// A raw pointer (`*const T` or `*mut T`)\n     TyPtr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n@@ -1709,7 +1721,7 @@ pub enum Ty_ {\n     /// so they are resolved directly through the parent `Generics`.\n     TyImplTraitExistential(ExistTy, HirVec<Lifetime>),\n     /// Unused for now\n-    TyTypeof(BodyId),\n+    TyTypeof(AnonConst),\n     /// TyInfer means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n     TyInfer,\n@@ -1882,7 +1894,7 @@ pub struct Variant_ {\n     pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n     /// Explicit discriminant, eg `Foo = 1`\n-    pub disr_expr: Option<BodyId>,\n+    pub disr_expr: Option<AnonConst>,\n }\n \n pub type Variant = Spanned<Variant_>;"}, {"sha": "8173ec48045c303045651d0d780ffabc6bd3ee23", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -416,16 +416,16 @@ impl<'a> State<'a> {\n             hir::TyImplTraitExistential(ref existty, ref _lifetimes) => {\n                 self.print_bounds(\"impl\", &existty.bounds[..])?;\n             }\n-            hir::TyArray(ref ty, v) => {\n+            hir::TyArray(ref ty, ref length) => {\n                 self.s.word(\"[\")?;\n                 self.print_type(&ty)?;\n                 self.s.word(\"; \")?;\n-                self.ann.nested(self, Nested::Body(v))?;\n+                self.print_anon_const(length)?;\n                 self.s.word(\"]\")?;\n             }\n-            hir::TyTypeof(e) => {\n+            hir::TyTypeof(ref e) => {\n                 self.s.word(\"typeof(\")?;\n-                self.ann.nested(self, Nested::Body(e))?;\n+                self.print_anon_const(e)?;\n                 self.s.word(\")\")?;\n             }\n             hir::TyInfer => {\n@@ -871,10 +871,10 @@ impl<'a> State<'a> {\n         self.head(\"\")?;\n         let generics = hir::Generics::empty();\n         self.print_struct(&v.node.data, &generics, v.node.name, v.span, false)?;\n-        if let Some(d) = v.node.disr_expr {\n+        if let Some(ref d) = v.node.disr_expr {\n             self.s.space()?;\n             self.word_space(\"=\")?;\n-            self.ann.nested(self, Nested::Body(d))?;\n+            self.print_anon_const(d)?;\n         }\n         Ok(())\n     }\n@@ -1091,6 +1091,9 @@ impl<'a> State<'a> {\n         self.print_else(elseopt)\n     }\n \n+    pub fn print_anon_const(&mut self, constant: &hir::AnonConst) -> io::Result<()> {\n+        self.ann.nested(self, Nested::Body(constant.body))\n+    }\n \n     fn print_call_post(&mut self, args: &[hir::Expr]) -> io::Result<()> {\n         self.popen()?;\n@@ -1141,12 +1144,12 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    fn print_expr_repeat(&mut self, element: &hir::Expr, count: hir::BodyId) -> io::Result<()> {\n+    fn print_expr_repeat(&mut self, element: &hir::Expr, count: &hir::AnonConst) -> io::Result<()> {\n         self.ibox(indent_unit)?;\n         self.s.word(\"[\")?;\n         self.print_expr(element)?;\n         self.word_space(\";\")?;\n-        self.ann.nested(self, Nested::Body(count))?;\n+        self.print_anon_const(count)?;\n         self.s.word(\"]\")?;\n         self.end()\n     }\n@@ -1288,7 +1291,7 @@ impl<'a> State<'a> {\n             hir::ExprArray(ref exprs) => {\n                 self.print_expr_vec(exprs)?;\n             }\n-            hir::ExprRepeat(ref element, count) => {\n+            hir::ExprRepeat(ref element, ref count) => {\n                 self.print_expr_repeat(&element, count)?;\n             }\n             hir::ExprStruct(ref qpath, ref fields, ref wth) => {"}, {"sha": "21c1af919de9aa61b562a5596b70f700300793a2", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -553,6 +553,12 @@ impl_stable_hash_for!(enum hir::UnsafeSource {\n     UserProvided\n });\n \n+impl_stable_hash_for!(struct hir::AnonConst {\n+    id,\n+    hir_id,\n+    body\n+});\n+\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,"}, {"sha": "93d78210b1ad0877865709432785a9708e7c539a", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -214,11 +214,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::LifetimeDef(..) |\n             data @ DefPathData::EnumVariant(..) |\n             data @ DefPathData::Field(..) |\n-            data @ DefPathData::Initializer |\n+            data @ DefPathData::AnonConst |\n             data @ DefPathData::MacroDef(..) |\n             data @ DefPathData::ClosureExpr |\n             data @ DefPathData::ImplTrait |\n-            data @ DefPathData::Typeof |\n             data @ DefPathData::GlobalMetaData(..) => {\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();\n                 self.push_item_path(buffer, parent_def_id);"}, {"sha": "b8345b6c2d9a347eee56b06d2dedb7958bdbb9ff", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -290,9 +290,8 @@ impl PrintContext {\n                     DefPathData::LifetimeDef(_) |\n                     DefPathData::Field(_) |\n                     DefPathData::StructCtor |\n-                    DefPathData::Initializer |\n+                    DefPathData::AnonConst |\n                     DefPathData::ImplTrait |\n-                    DefPathData::Typeof |\n                     DefPathData::GlobalMetaData(_) => {\n                         // if we're making a symbol for something, there ought\n                         // to be a value or type-def or something in there"}, {"sha": "a8836694933e2a39bd599c2d4ced3c9989a14fa1", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -1359,8 +1359,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn encode_info_for_embedded_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_embedded_const({:?})\", def_id);\n+    fn encode_info_for_anon_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n+        debug!(\"IsolatedEncoder::encode_info_for_anon_const({:?})\", def_id);\n         let tcx = self.tcx;\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         let body_id = tcx.hir.body_owned_by(id);\n@@ -1623,9 +1623,9 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n                      id: ast::NodeId) {\n         intravisit::walk_variant(self, v, g, id);\n \n-        if let Some(discr) = v.node.disr_expr {\n-            let def_id = self.index.tcx.hir.body_owner_def_id(discr);\n-            self.index.record(def_id, IsolatedEncoder::encode_info_for_embedded_const, def_id);\n+        if let Some(ref discr) = v.node.disr_expr {\n+            let def_id = self.index.tcx.hir.local_def_id(discr.id);\n+            self.index.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n         }\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n@@ -1668,9 +1668,9 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 let def_id = self.tcx.hir.local_def_id(ty.id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_anon_ty, def_id);\n             }\n-            hir::TyArray(_, len) => {\n-                let def_id = self.tcx.hir.body_owner_def_id(len);\n-                self.record(def_id, IsolatedEncoder::encode_info_for_embedded_const, def_id);\n+            hir::TyArray(_, ref length) => {\n+                let def_id = self.tcx.hir.local_def_id(length.id);\n+                self.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n             }\n             _ => {}\n         }"}, {"sha": "2da2d3f697f2ea965bd0301cdcc6ab4f0bcfeee8", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -42,46 +42,15 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n \n     // Figure out what primary body this item has.\n     let body_id = match tcx.hir.get(id) {\n-        hir::map::NodeItem(item) => {\n-            match item.node {\n-                hir::ItemConst(_, body) |\n-                hir::ItemStatic(_, _, body) |\n-                hir::ItemFn(.., body) => body,\n-                _ => unsupported()\n-            }\n-        }\n-        hir::map::NodeTraitItem(item) => {\n-            match item.node {\n-                hir::TraitItemKind::Const(_, Some(body)) |\n-                hir::TraitItemKind::Method(_,\n-                    hir::TraitMethod::Provided(body)) => body,\n-                _ => unsupported()\n-            }\n-        }\n-        hir::map::NodeImplItem(item) => {\n-            match item.node {\n-                hir::ImplItemKind::Const(_, body) |\n-                hir::ImplItemKind::Method(_, body) => body,\n-                _ => unsupported()\n-            }\n-        }\n-        hir::map::NodeExpr(expr) => {\n-            // FIXME(eddyb) Closures should have separate\n-            // function definition IDs and expression IDs.\n-            // Type-checking should not let closures get\n-            // this far in a constant position.\n-            // Assume that everything other than closures\n-            // is a constant \"initializer\" expression.\n-            match expr.node {\n-                hir::ExprClosure(_, _, body, _, _) => body,\n-                _ => hir::BodyId { node_id: expr.id },\n-            }\n-        }\n         hir::map::NodeVariant(variant) =>\n             return create_constructor_shim(tcx, id, &variant.node.data),\n         hir::map::NodeStructCtor(ctor) =>\n             return create_constructor_shim(tcx, id, ctor),\n-        _ => unsupported(),\n+\n+        _ => match tcx.hir.maybe_body_owned_by(id) {\n+            Some(body) => body,\n+            None => unsupported(),\n+        },\n     };\n \n     tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "0d93634981f56640183df2c5dc6922766a59b01c", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -506,9 +506,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         // Now comes the rote stuff:\n-        hir::ExprRepeat(ref v, count) => {\n-            let c = &cx.tcx.hir.body(count).value;\n-            let def_id = cx.tcx.hir.body_owner_def_id(count);\n+        hir::ExprRepeat(ref v, ref count) => {\n+            let def_id = cx.tcx.hir.local_def_id(count.id);\n             let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n             let instance = ty::Instance::resolve(\n                 cx.tcx.global_tcx(),\n@@ -520,7 +519,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 instance,\n                 promoted: None\n             };\n-            let count = match cx.tcx.at(c.span).const_eval(cx.param_env.and(global_id)) {\n+            let span = cx.tcx.def_span(def_id);\n+            let count = match cx.tcx.at(span).const_eval(cx.param_env.and(global_id)) {\n                 Ok(cv) => cv.unwrap_usize(cx.tcx),\n                 Err(e) => {\n                     e.report(cx.tcx, cx.tcx.def_span(def_id), \"array length\");"}, {"sha": "a8ac940765daab993455fb4874e5b5d60db70689", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 31, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -802,6 +802,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n     fn visit_block(&mut self, block: &'tcx Block) {\n         self.resolve_block(block);\n     }\n+    fn visit_anon_const(&mut self, constant: &'tcx ast::AnonConst) {\n+        self.with_constant_rib(|this| {\n+            visit::walk_anon_const(this, constant);\n+        });\n+    }\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         self.resolve_expr(expr, None);\n     }\n@@ -819,13 +824,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                               .map_or(Def::Err, |d| d.def());\n                 self.record_def(ty.id, PathResolution::new(def));\n             }\n-            TyKind::Array(ref element, ref length) => {\n-                self.visit_ty(element);\n-                self.with_constant_rib(|this| {\n-                    this.visit_expr(length);\n-                });\n-                return;\n-            }\n             _ => (),\n         }\n         visit::walk_ty(self, ty);\n@@ -837,24 +835,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                                 &tref.trait_ref.path, PathSource::Trait(AliasPossibility::Maybe));\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n-    fn visit_variant(&mut self,\n-                     variant: &'tcx ast::Variant,\n-                     generics: &'tcx Generics,\n-                     item_id: ast::NodeId) {\n-        if let Some(ref dis_expr) = variant.node.disr_expr {\n-            // resolve the discriminator expr as a constant\n-            self.with_constant_rib(|this| {\n-                this.visit_expr(dis_expr);\n-            });\n-        }\n-\n-        // `visit::walk_variant` without the discriminant expression.\n-        self.visit_variant_data(&variant.node.data,\n-                                variant.node.ident,\n-                                generics,\n-                                item_id,\n-                                variant.span);\n-    }\n     fn visit_foreign_item(&mut self, foreign_item: &'tcx ForeignItem) {\n         let type_parameters = match foreign_item.node {\n             ForeignItemKind::Fn(_, ref generics) => {\n@@ -3820,12 +3800,6 @@ impl<'a> Resolver<'a> {\n                 self.visit_path_segment(expr.span, segment);\n             }\n \n-            ExprKind::Repeat(ref element, ref count) => {\n-                self.visit_expr(element);\n-                self.with_constant_rib(|this| {\n-                    this.visit_expr(count);\n-                });\n-            }\n             ExprKind::Call(ref callee, ref arguments) => {\n                 self.resolve_expr(callee, Some(expr));\n                 for argument in arguments {"}, {"sha": "296d1a5828a26a3e30c6c394c5b72cea122d18a7", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -45,9 +45,6 @@ use rustc_data_structures::sync::Lrc;\n pub struct InvocationData<'a> {\n     pub module: Cell<Module<'a>>,\n     pub def_index: DefIndex,\n-    // True if this expansion is in a `const_expr` position, for example `[u32; m!()]`.\n-    // c.f. `DefCollector::visit_const_expr`.\n-    pub const_expr: bool,\n     // The scope in which the invocation path is resolved.\n     pub legacy_scope: Cell<LegacyScope<'a>>,\n     // The smallest scope that includes this invocation's expansion,\n@@ -60,7 +57,6 @@ impl<'a> InvocationData<'a> {\n         InvocationData {\n             module: Cell::new(graph_root),\n             def_index: CRATE_DEF_INDEX,\n-            const_expr: false,\n             legacy_scope: Cell::new(LegacyScope::Empty),\n             expansion: Cell::new(LegacyScope::Empty),\n         }\n@@ -124,7 +120,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n             module: Cell::new(module),\n             def_index: module.def_id().unwrap().index,\n-            const_expr: false,\n             legacy_scope: Cell::new(LegacyScope::Empty),\n             expansion: Cell::new(LegacyScope::Empty),\n         }));\n@@ -716,13 +711,12 @@ impl<'a> Resolver<'a> {\n                        invocation: &'a InvocationData<'a>,\n                        expansion: &Expansion) {\n         let Resolver { ref mut invocations, arenas, graph_root, .. } = *self;\n-        let InvocationData { def_index, const_expr, .. } = *invocation;\n+        let InvocationData { def_index, .. } = *invocation;\n \n         let visit_macro_invoc = &mut |invoc: map::MacroInvocationData| {\n             invocations.entry(invoc.mark).or_insert_with(|| {\n                 arenas.alloc_invocation_data(InvocationData {\n                     def_index: invoc.def_index,\n-                    const_expr: invoc.const_expr,\n                     module: Cell::new(graph_root),\n                     expansion: Cell::new(LegacyScope::Empty),\n                     legacy_scope: Cell::new(LegacyScope::Empty),\n@@ -733,11 +727,6 @@ impl<'a> Resolver<'a> {\n         let mut def_collector = DefCollector::new(&mut self.definitions, mark);\n         def_collector.visit_macro_invoc = Some(visit_macro_invoc);\n         def_collector.with_parent(def_index, |def_collector| {\n-            if const_expr {\n-                if let Expansion::Expr(ref expr) = *expansion {\n-                    def_collector.visit_const_expr(expr);\n-                }\n-            }\n             expansion.visit_with(def_collector)\n         });\n     }"}, {"sha": "279ee403cc6258d5b6e702a6fa55986bd32569b7", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -1516,7 +1516,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n             }\n             ast::TyKind::Array(ref element, ref length) => {\n                 self.visit_ty(element);\n-                self.nest_tables(length.id, |v| v.visit_expr(length));\n+                self.nest_tables(length.id, |v| v.visit_expr(&length.value));\n             }\n             _ => visit::walk_ty(self, t),\n         }\n@@ -1589,7 +1589,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n                 self.visit_expr(element);\n-                self.nest_tables(count.id, |v| v.visit_expr(count));\n+                self.nest_tables(count.id, |v| v.visit_expr(&count.value));\n             }\n             // In particular, we take this branch for call and path expressions,\n             // where we'll index the idents involved just by continuing to walk."}, {"sha": "e3545e8f1a9b8e2a931c7d99ea5cfa08449f46dc", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -313,7 +313,7 @@ impl Sig for ast::Ty {\n             }\n             ast::TyKind::Array(ref ty, ref v) => {\n                 let nested_ty = ty.make(offset + 1, id, scx)?;\n-                let expr = pprust::expr_to_string(v).replace('\\n', \" \");\n+                let expr = pprust::expr_to_string(&v.value).replace('\\n', \" \");\n                 let text = format!(\"[{}; {}]\", nested_ty.text, expr);\n                 Ok(replace_text(nested_ty, text))\n             }"}, {"sha": "e6ccbd61bd58e88a6f973e5c59901f834c469193", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -1116,8 +1116,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 };\n                 self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n             }\n-            hir::TyArray(ref ty, length) => {\n-                let length_def_id = tcx.hir.body_owner_def_id(length);\n+            hir::TyArray(ref ty, ref length) => {\n+                let length_def_id = tcx.hir.local_def_id(length.id);\n                 let substs = Substs::identity_for_item(tcx, length_def_id);\n                 let length = ty::Const::unevaluated(tcx, length_def_id, substs, tcx.types.usize);\n                 let array_ty = tcx.mk_ty(ty::TyArray(self.ast_ty_to_ty(&ty), length));"}, {"sha": "1088ec1b2acb9e2840b81681683646e7d945e3a5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -787,20 +787,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        hir::map::NodeExpr(expr) => {\n-            // FIXME(eddyb) Closures should have separate\n-            // function definition IDs and expression IDs.\n-            // Type-checking should not let closures get\n-            // this far in a constant position.\n-            // Assume that everything other than closures\n-            // is a constant \"initializer\" expression.\n-            match expr.node {\n-                hir::ExprClosure(..) =>\n-                    None,\n-                _ =>\n-                    Some((hir::BodyId { node_id: expr.id }, None)),\n-            }\n-        }\n+        hir::map::NodeAnonConst(constant) => Some((constant.body, None)),\n         _ => None,\n     }\n }\n@@ -1674,8 +1661,8 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     for v in vs {\n-        if let Some(e) = v.node.disr_expr {\n-            tcx.typeck_tables_of(tcx.hir.local_def_id(e.node_id));\n+        if let Some(ref e) = v.node.disr_expr {\n+            tcx.typeck_tables_of(tcx.hir.local_def_id(e.id));\n         }\n     }\n \n@@ -1686,11 +1673,11 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let variant_i_node_id = tcx.hir.as_local_node_id(def.variants[i].did).unwrap();\n             let variant_i = tcx.hir.expect_variant(variant_i_node_id);\n             let i_span = match variant_i.node.disr_expr {\n-                Some(expr) => tcx.hir.span(expr.node_id),\n+                Some(ref expr) => tcx.hir.span(expr.id),\n                 None => tcx.hir.span(variant_i_node_id)\n             };\n             let span = match v.node.disr_expr {\n-                Some(expr) => tcx.hir.span(expr.node_id),\n+                Some(ref expr) => tcx.hir.span(expr.id),\n                 None => v.span\n             };\n             struct_span_err!(tcx.sess, span, E0081,\n@@ -3975,8 +3962,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               };\n               tcx.mk_array(element_ty, args.len() as u64)\n           }\n-          hir::ExprRepeat(ref element, count) => {\n-            let count_def_id = tcx.hir.body_owner_def_id(count);\n+          hir::ExprRepeat(ref element, ref count) => {\n+            let count_def_id = tcx.hir.local_def_id(count.id);\n             let param_env = ty::ParamEnv::empty();\n             let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n             let instance = ty::Instance::resolve("}, {"sha": "4d691de2037cab0ea354281a04ba879a1b710776", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -481,8 +481,8 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // fill the discriminant values and field types\n     for variant in variants {\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n-        prev_discr = Some(if let Some(e) = variant.node.disr_expr {\n-            let expr_did = tcx.hir.local_def_id(e.node_id);\n+        prev_discr = Some(if let Some(ref e) = variant.node.disr_expr {\n+            let expr_did = tcx.hir.local_def_id(e.id);\n             def.eval_explicit_discr(tcx, expr_did)\n         } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n             Some(discr)\n@@ -565,9 +565,9 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let mut distance_from_explicit = 0;\n             (AdtKind::Enum, def.variants.iter().map(|v| {\n                 let did = tcx.hir.local_def_id(v.node.data.id());\n-                let discr = if let Some(e) = v.node.disr_expr {\n+                let discr = if let Some(ref e) = v.node.disr_expr {\n                     distance_from_explicit = 0;\n-                    ty::VariantDiscr::Explicit(tcx.hir.local_def_id(e.node_id))\n+                    ty::VariantDiscr::Explicit(tcx.hir.local_def_id(e.id))\n                 } else {\n                     ty::VariantDiscr::Relative(distance_from_explicit)\n                 };\n@@ -1102,20 +1102,20 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             tcx.mk_closure(def_id, substs)\n         }\n \n-        NodeExpr(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n-            NodeTy(&hir::Ty { node: TyArray(_, body), .. }) |\n-            NodeTy(&hir::Ty { node: TyTypeof(body), .. }) |\n-            NodeExpr(&hir::Expr { node: ExprRepeat(_, body), .. })\n-                if body.node_id == node_id => tcx.types.usize,\n+        NodeAnonConst(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n+            NodeTy(&hir::Ty { node: TyArray(_, ref constant), .. }) |\n+            NodeTy(&hir::Ty { node: TyTypeof(ref constant), .. }) |\n+            NodeExpr(&hir::Expr { node: ExprRepeat(_, ref constant), .. })\n+                if constant.id == node_id => tcx.types.usize,\n \n-            NodeVariant(&Spanned { node: Variant_ { disr_expr: Some(e), .. }, .. })\n-                if e.node_id == node_id => {\n+            NodeVariant(&Spanned { node: Variant_ { disr_expr: Some(ref e), .. }, .. })\n+                if e.id == node_id => {\n                     tcx.adt_def(tcx.hir.get_parent_did(node_id))\n                         .repr.discr_type().to_ty(tcx)\n                 }\n \n             x => {\n-                bug!(\"unexpected expr parent in type_of_def_id(): {:?}\", x);\n+                bug!(\"unexpected const parent in type_of_def_id(): {:?}\", x);\n             }\n         },\n "}, {"sha": "ae53b9ded4eee84d6525ce06cfb5c9d8ace301ae", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -2669,19 +2669,19 @@ impl Clean<Type> for hir::Ty {\n                              type_: box m.ty.clean(cx)}\n             }\n             TySlice(ref ty) => Slice(box ty.clean(cx)),\n-            TyArray(ref ty, n) => {\n-                let def_id = cx.tcx.hir.body_owner_def_id(n);\n+            TyArray(ref ty, ref length) => {\n+                let def_id = cx.tcx.hir.local_def_id(length.id);\n                 let param_env = cx.tcx.param_env(def_id);\n                 let substs = Substs::identity_for_item(cx.tcx, def_id);\n                 let cid = GlobalId {\n                     instance: ty::Instance::new(def_id, substs),\n                     promoted: None\n                 };\n-                let n = cx.tcx.const_eval(param_env.and(cid)).unwrap_or_else(|_| {\n+                let length = cx.tcx.const_eval(param_env.and(cid)).unwrap_or_else(|_| {\n                     ty::Const::unevaluated(cx.tcx, def_id, substs, cx.tcx.types.usize)\n                 });\n-                let n = print_const(cx, n);\n-                Array(box ty.clean(cx), n)\n+                let length = print_const(cx, length);\n+                Array(box ty.clean(cx), length)\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(hir::QPath::Resolved(None, ref path)) => {"}, {"sha": "0ce9763ded8bf4fd376af595ce3c172d04e30197", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -920,6 +920,18 @@ pub enum UnsafeSource {\n     UserProvided,\n }\n \n+/// A constant (expression) that's not an item or associated item,\n+/// but needs its own `DefId` for type-checking, const-eval, etc.\n+/// These are usually found nested inside types (e.g. array lengths)\n+/// or expressions (e.g. repeat counts), and also used to define\n+/// explicit discriminant values for enum variants.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct AnonConst {\n+    pub id: NodeId,\n+    pub value: P<Expr>,\n+}\n+\n+\n /// An expression\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash,)]\n pub struct Expr {\n@@ -1168,9 +1180,9 @@ pub enum ExprKind {\n \n     /// An array literal constructed from one repeated element.\n     ///\n-    /// For example, `[1; 5]`. The first expression is the element\n-    /// to be repeated; the second is the number of times to repeat it.\n-    Repeat(P<Expr>, P<Expr>),\n+    /// For example, `[1; 5]`. The expression is the element to be\n+    /// repeated; the constant is the number of times to repeat it.\n+    Repeat(P<Expr>, AnonConst),\n \n     /// No-op: used solely so we can pretty-print faithfully\n     Paren(P<Expr>),\n@@ -1565,7 +1577,7 @@ pub enum TyKind {\n     /// A variable-length slice (`[T]`)\n     Slice(P<Ty>),\n     /// A fixed length array (`[T; n]`)\n-    Array(P<Ty>, P<Expr>),\n+    Array(P<Ty>, AnonConst),\n     /// A raw pointer (`*const T` or `*mut T`)\n     Ptr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n@@ -1590,7 +1602,7 @@ pub enum TyKind {\n     /// No-op; kept solely so that we can pretty-print faithfully\n     Paren(P<Ty>),\n     /// Unused for now\n-    Typeof(P<Expr>),\n+    Typeof(AnonConst),\n     /// TyKind::Infer means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n     Infer,\n@@ -1856,7 +1868,7 @@ pub struct Variant_ {\n     pub attrs: Vec<Attribute>,\n     pub data: VariantData,\n     /// Explicit discriminant, e.g. `Foo = 1`\n-    pub disr_expr: Option<P<Expr>>,\n+    pub disr_expr: Option<AnonConst>,\n }\n \n pub type Variant = Spanned<Variant_>;"}, {"sha": "6c3117b963fed8ad00884384f74cb027e619495d", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -207,7 +207,10 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                 span,\n                 ast::TyKind::Tup(vec![ty_str.clone(), ty_str])\n             ),\n-            ecx.expr_usize(span, count),\n+            ast::AnonConst {\n+                id: ast::DUMMY_NODE_ID,\n+                value: ecx.expr_usize(span, count),\n+            },\n         ),\n     );\n "}, {"sha": "28fb95f165fde509536b9acc669a5e1548a0ee1d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -112,6 +112,10 @@ pub trait Folder : Sized {\n         noop_fold_pat(p, self)\n     }\n \n+    fn fold_anon_const(&mut self, c: AnonConst) -> AnonConst {\n+        noop_fold_anon_const(c, self)\n+    }\n+\n     fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n         e.map(|e| noop_fold_expr(e, self))\n     }\n@@ -394,11 +398,11 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                 });\n                 TyKind::Path(qself, fld.fold_path(path))\n             }\n-            TyKind::Array(ty, e) => {\n-                TyKind::Array(fld.fold_ty(ty), fld.fold_expr(e))\n+            TyKind::Array(ty, length) => {\n+                TyKind::Array(fld.fold_ty(ty), fld.fold_anon_const(length))\n             }\n             TyKind::Typeof(expr) => {\n-                TyKind::Typeof(fld.fold_expr(expr))\n+                TyKind::Typeof(fld.fold_anon_const(expr))\n             }\n             TyKind::TraitObject(bounds, syntax) => {\n                 TyKind::TraitObject(bounds.move_map(|b| fld.fold_ty_param_bound(b)), syntax)\n@@ -433,7 +437,7 @@ pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant {\n             ident: fld.fold_ident(v.node.ident),\n             attrs: fold_attrs(v.node.attrs, fld),\n             data: fld.fold_variant_data(v.node.data),\n-            disr_expr: v.node.disr_expr.map(|e| fld.fold_expr(e)),\n+            disr_expr: v.node.disr_expr.map(|e| fld.fold_anon_const(e)),\n         },\n         span: fld.new_span(v.span),\n     }\n@@ -1170,6 +1174,14 @@ pub fn noop_fold_range_end<T: Folder>(end: RangeEnd, _folder: &mut T) -> RangeEn\n     end\n }\n \n+pub fn noop_fold_anon_const<T: Folder>(constant: AnonConst, folder: &mut T) -> AnonConst {\n+    let AnonConst {id, value} = constant;\n+    AnonConst {\n+        id: folder.new_id(id),\n+        value: folder.fold_expr(value),\n+    }\n+}\n+\n pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mut T) -> Expr {\n     Expr {\n         node: match node {\n@@ -1180,7 +1192,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 ExprKind::Array(folder.fold_exprs(exprs))\n             }\n             ExprKind::Repeat(expr, count) => {\n-                ExprKind::Repeat(folder.fold_expr(expr), folder.fold_expr(count))\n+                ExprKind::Repeat(folder.fold_expr(expr), folder.fold_anon_const(count))\n             }\n             ExprKind::Tup(exprs) => ExprKind::Tup(folder.fold_exprs(exprs)),\n             ExprKind::Call(f, args) => {"}, {"sha": "aca23581d95e3241260b5232252f4103e076564d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -12,7 +12,7 @@ use rustc_target::spec::abi::{self, Abi};\n use ast::{AngleBracketedParameterData, ParenthesizedParameterData, AttrStyle, BareFnTy};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Unsafety;\n-use ast::{Mod, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n+use ast::{Mod, AnonConst, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n use ast::Block;\n use ast::{BlockCheckMode, CaptureBy, Movability};\n use ast::{Constness, Crate};\n@@ -1543,7 +1543,10 @@ impl<'a> Parser<'a> {\n             // Parse optional `; EXPR` in `[TYPE; EXPR]`\n             let t = match self.maybe_parse_fixed_length_of_vec()? {\n                 None => TyKind::Slice(t),\n-                Some(suffix) => TyKind::Array(t, suffix),\n+                Some(length) => TyKind::Array(t, AnonConst {\n+                    id: ast::DUMMY_NODE_ID,\n+                    value: length,\n+                }),\n             };\n             self.expect(&token::CloseDelim(token::Bracket))?;\n             t\n@@ -1555,7 +1558,10 @@ impl<'a> Parser<'a> {\n             // `typeof(EXPR)`\n             // In order to not be ambiguous, the type must be surrounded by parens.\n             self.expect(&token::OpenDelim(token::Paren))?;\n-            let e = self.parse_expr()?;\n+            let e = AnonConst {\n+                id: ast::DUMMY_NODE_ID,\n+                value: self.parse_expr()?,\n+            };\n             self.expect(&token::CloseDelim(token::Paren))?;\n             TyKind::Typeof(e)\n         } else if self.eat_keyword(keywords::Underscore) {\n@@ -2264,7 +2270,10 @@ impl<'a> Parser<'a> {\n                     if self.check(&token::Semi) {\n                         // Repeating array syntax: [ 0; 512 ]\n                         self.bump();\n-                        let count = self.parse_expr()?;\n+                        let count = AnonConst {\n+                            id: ast::DUMMY_NODE_ID,\n+                            value: self.parse_expr()?,\n+                        };\n                         self.expect(&token::CloseDelim(token::Bracket))?;\n                         ex = ExprKind::Repeat(first_expr, count);\n                     } else if self.check(&token::Comma) {\n@@ -6353,8 +6362,11 @@ impl<'a> Parser<'a> {\n                 struct_def = VariantData::Tuple(self.parse_tuple_struct_body()?,\n                                                 ast::DUMMY_NODE_ID);\n             } else if self.eat(&token::Eq) {\n-                disr_expr = Some(self.parse_expr()?);\n-                any_disr = disr_expr.as_ref().map(|expr| expr.span);\n+                disr_expr = Some(AnonConst {\n+                    id: ast::DUMMY_NODE_ID,\n+                    value: self.parse_expr()?,\n+                });\n+                any_disr = disr_expr.as_ref().map(|c| c.value.span);\n                 struct_def = VariantData::Unit(ast::DUMMY_NODE_ID);\n             } else {\n                 struct_def = VariantData::Unit(ast::DUMMY_NODE_ID);"}, {"sha": "be3408ce565992ef26abdf204ffd5bfdc7aab780", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -1076,16 +1076,16 @@ impl<'a> State<'a> {\n             ast::TyKind::ImplTrait(ref bounds) => {\n                 self.print_bounds(\"impl\", &bounds[..])?;\n             }\n-            ast::TyKind::Array(ref ty, ref v) => {\n+            ast::TyKind::Array(ref ty, ref length) => {\n                 self.s.word(\"[\")?;\n                 self.print_type(ty)?;\n                 self.s.word(\"; \")?;\n-                self.print_expr(v)?;\n+                self.print_expr(&length.value)?;\n                 self.s.word(\"]\")?;\n             }\n             ast::TyKind::Typeof(ref e) => {\n                 self.s.word(\"typeof(\")?;\n-                self.print_expr(e)?;\n+                self.print_expr(&e.value)?;\n                 self.s.word(\")\")?;\n             }\n             ast::TyKind::Infer => {\n@@ -1552,7 +1552,7 @@ impl<'a> State<'a> {\n             Some(ref d) => {\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(d)\n+                self.print_expr(&d.value)\n             }\n             _ => Ok(())\n         }\n@@ -1905,14 +1905,14 @@ impl<'a> State<'a> {\n \n     fn print_expr_repeat(&mut self,\n                          element: &ast::Expr,\n-                         count: &ast::Expr,\n+                         count: &ast::AnonConst,\n                          attrs: &[Attribute]) -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n         self.s.word(\"[\")?;\n         self.print_inner_attributes_inline(attrs)?;\n         self.print_expr(element)?;\n         self.word_space(\";\")?;\n-        self.print_expr(count)?;\n+        self.print_expr(&count.value)?;\n         self.s.word(\"]\")?;\n         self.end()\n     }"}, {"sha": "b6eb649daa24de56f33f834ea30663c7592c5926", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -69,6 +69,7 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_stmt(&mut self, s: &'ast Stmt) { walk_stmt(self, s) }\n     fn visit_arm(&mut self, a: &'ast Arm) { walk_arm(self, a) }\n     fn visit_pat(&mut self, p: &'ast Pat) { walk_pat(self, p) }\n+    fn visit_anon_const(&mut self, c: &'ast AnonConst) { walk_anon_const(self, c) }\n     fn visit_expr(&mut self, ex: &'ast Expr) { walk_expr(self, ex) }\n     fn visit_expr_post(&mut self, _ex: &'ast Expr) { }\n     fn visit_ty(&mut self, t: &'ast Ty) { walk_ty(self, t) }\n@@ -296,7 +297,7 @@ pub fn walk_variant<'a, V>(visitor: &mut V,\n     visitor.visit_ident(variant.node.ident);\n     visitor.visit_variant_data(&variant.node.data, variant.node.ident,\n                              generics, item_id, variant.span);\n-    walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n+    walk_list!(visitor, visit_anon_const, &variant.node.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n \n@@ -326,16 +327,16 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             }\n             visitor.visit_path(path, typ.id);\n         }\n-        TyKind::Array(ref ty, ref expression) => {\n+        TyKind::Array(ref ty, ref length) => {\n             visitor.visit_ty(ty);\n-            visitor.visit_expr(expression)\n+            visitor.visit_anon_const(length)\n         }\n         TyKind::TraitObject(ref bounds, ..) |\n         TyKind::ImplTrait(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyKind::Typeof(ref expression) => {\n-            visitor.visit_expr(expression)\n+            visitor.visit_anon_const(expression)\n         }\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err => {}\n         TyKind::Mac(ref mac) => {\n@@ -647,6 +648,10 @@ pub fn walk_mac<'a, V: Visitor<'a>>(_: &mut V, _: &Mac) {\n     // Empty!\n }\n \n+pub fn walk_anon_const<'a, V: Visitor<'a>>(visitor: &mut V, constant: &'a AnonConst) {\n+    visitor.visit_expr(&constant.value);\n+}\n+\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     for attr in expression.attrs.iter() {\n         visitor.visit_attribute(attr);\n@@ -660,7 +665,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         }\n         ExprKind::Repeat(ref element, ref count) => {\n             visitor.visit_expr(element);\n-            visitor.visit_expr(count)\n+            visitor.visit_anon_const(count)\n         }\n         ExprKind::Struct(ref path, ref fields, ref optional_base) => {\n             visitor.visit_path(path, expression.id);"}, {"sha": "ab52a32869f216dd210a70de68a326b229471092", "filename": "src/test/compile-fail/issue-48838.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Fcompile-fail%2Fissue-48838.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Fcompile-fail%2Fissue-48838.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-48838.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Functions {\n+    Square = |x| x, //~ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "6169a7770bfc4d89f54b3fe7e7dda8c94628dd63", "filename": "src/test/compile-fail/issue-50600.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Fcompile-fail%2Fissue-50600.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Fcompile-fail%2Fissue-50600.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-50600.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo (\n+    fn([u8; |x: u8| {}]), //~ ERROR mismatched types\n+);\n+\n+fn main() {}"}, {"sha": "ff45cf639decdc115ec1d76d93d694a638804307", "filename": "src/test/compile-fail/issue-50688.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Fcompile-fail%2Fissue-50688.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Fcompile-fail%2Fissue-50688.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-50688.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    [1; || {}]; //~ ERROR mismatched types\n+}"}, {"sha": "d437b9d88f4d7b77604bbb551240117acc5ced6a", "filename": "src/test/run-pass/issue-50689.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Frun-pass%2Fissue-50689.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Frun-pass%2Fissue-50689.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-50689.rs?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Foo {\n+    Bar = (|x: i32| { }, 42).1,\n+}\n+\n+fn main() {\n+    assert_eq!(Foo::Bar as usize, 42);\n+}"}, {"sha": "dcf021de57e563fa5e9636f466229f31d3805db1", "filename": "src/test/ui/issue-23302-1.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Fui%2Fissue-23302-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Fui%2Fissue-23302-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-1.stderr?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -1,11 +1,11 @@\n-error[E0391]: cycle detected when processing `X::A::{{initializer}}`\n+error[E0391]: cycle detected when processing `X::A::{{constant}}`\n   --> $DIR/issue-23302-1.rs:14:9\n    |\n LL |     A = X::A as isize, //~ ERROR E0391\n    |         ^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `X::A::{{initializer}}`, completing the cycle\n-note: cycle used when const-evaluating `X::A::{{initializer}}`\n+   = note: ...which again requires processing `X::A::{{constant}}`, completing the cycle\n+note: cycle used when const-evaluating `X::A::{{constant}}`\n   --> $DIR/issue-23302-1.rs:14:9\n    |\n LL |     A = X::A as isize, //~ ERROR E0391"}, {"sha": "146f86127c5e44648d2201cb3c68f8b172f6e2c3", "filename": "src/test/ui/issue-23302-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Fui%2Fissue-23302-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Fui%2Fissue-23302-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-2.stderr?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -1,11 +1,11 @@\n-error[E0391]: cycle detected when processing `Y::A::{{initializer}}`\n+error[E0391]: cycle detected when processing `Y::A::{{constant}}`\n   --> $DIR/issue-23302-2.rs:14:9\n    |\n LL |     A = Y::B as isize, //~ ERROR E0391\n    |         ^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `Y::A::{{initializer}}`, completing the cycle\n-note: cycle used when const-evaluating `Y::A::{{initializer}}`\n+   = note: ...which again requires processing `Y::A::{{constant}}`, completing the cycle\n+note: cycle used when const-evaluating `Y::A::{{constant}}`\n   --> $DIR/issue-23302-2.rs:14:9\n    |\n LL |     A = Y::B as isize, //~ ERROR E0391"}, {"sha": "5623437669f0682e2ed60f8fb3de869ea06805e7", "filename": "src/test/ui/issue-36163.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Fui%2Fissue-36163.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26aad254875464ff352a4e18d16f668b5bd9b7cb/src%2Ftest%2Fui%2Fissue-36163.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-36163.stderr?ref=26aad254875464ff352a4e18d16f668b5bd9b7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0391]: cycle detected when processing `Foo::B::{{initializer}}`\n+error[E0391]: cycle detected when processing `Foo::B::{{constant}}`\n   --> $DIR/issue-36163.rs:14:9\n    |\n LL |     B = A, //~ ERROR E0391\n@@ -9,8 +9,8 @@ note: ...which requires processing `A`...\n    |\n LL | const A: isize = Foo::B as isize;\n    |                  ^^^^^^^^^^^^^^^\n-   = note: ...which again requires processing `Foo::B::{{initializer}}`, completing the cycle\n-note: cycle used when const-evaluating `Foo::B::{{initializer}}`\n+   = note: ...which again requires processing `Foo::B::{{constant}}`, completing the cycle\n+note: cycle used when const-evaluating `Foo::B::{{constant}}`\n   --> $DIR/issue-36163.rs:14:9\n    |\n LL |     B = A, //~ ERROR E0391"}]}