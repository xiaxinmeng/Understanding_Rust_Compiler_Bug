{"sha": "cffa3f960e401ac8100fd450b32c336c93181959", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZmEzZjk2MGU0MDFhYzgxMDBmZDQ1MGIzMmMzMzZjOTMxODE5NTk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-26T15:32:46Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-26T15:47:52Z"}, "message": "make stuff private", "tree": {"sha": "1abe5d28a477b0791b5515faaefd76c01c71a223", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1abe5d28a477b0791b5515faaefd76c01c71a223"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cffa3f960e401ac8100fd450b32c336c93181959", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cffa3f960e401ac8100fd450b32c336c93181959", "html_url": "https://github.com/rust-lang/rust/commit/cffa3f960e401ac8100fd450b32c336c93181959", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cffa3f960e401ac8100fd450b32c336c93181959/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f324773127c733b12d1c5ee98a3d9c6a5360db0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f324773127c733b12d1c5ee98a3d9c6a5360db0", "html_url": "https://github.com/rust-lang/rust/commit/8f324773127c733b12d1c5ee98a3d9c6a5360db0"}], "stats": {"total": 40, "additions": 14, "deletions": 26}, "files": [{"sha": "04b7bb7b3e2a74fd703809a5e50a15a7721019f9", "filename": "crates/ra_hir/src/source_id.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cffa3f960e401ac8100fd450b32c336c93181959/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cffa3f960e401ac8100fd450b32c336c93181959/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_id.rs?ref=cffa3f960e401ac8100fd450b32c336c93181959", "patch": "@@ -36,7 +36,9 @@ impl<N: AstNode> AstId<N> {\n     }\n \n     pub(crate) fn to_node(&self, db: &impl DefDatabase) -> TreeArc<N> {\n-        let syntax_node = db.file_item(self.file_ast_id.raw.with_file_id(self.file_id));\n+        let source_item_id =\n+            SourceItemId { file_id: self.file_id(), item_id: self.file_ast_id.raw };\n+        let syntax_node = db.file_item(source_item_id);\n         N::cast(&syntax_node).unwrap().to_owned()\n     }\n }\n@@ -75,19 +77,13 @@ impl<N: AstNode> FileAstId<N> {\n /// Identifier of item within a specific file. This is stable over reparses, so\n /// it's OK to use it as a salsa key/value.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub(crate) struct SourceFileItemId(RawId);\n+struct SourceFileItemId(RawId);\n impl_arena_id!(SourceFileItemId);\n \n-impl SourceFileItemId {\n-    pub(crate) fn with_file_id(self, file_id: HirFileId) -> SourceItemId {\n-        SourceItemId { file_id, item_id: self }\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct SourceItemId {\n-    pub(crate) file_id: HirFileId,\n-    pub(crate) item_id: SourceFileItemId,\n+    file_id: HirFileId,\n+    item_id: SourceFileItemId,\n }\n \n /// Maps items' `SyntaxNode`s to `SourceFileItemId`s and back.\n@@ -111,15 +107,16 @@ impl SourceFileItems {\n         source_item_id: SourceItemId,\n     ) -> TreeArc<SyntaxNode> {\n         let source_file = db.hir_parse(source_item_id.file_id);\n-        db.file_items(source_item_id.file_id)[source_item_id.item_id]\n+        db.file_items(source_item_id.file_id).arena[source_item_id.item_id]\n             .to_node(&source_file)\n             .to_owned()\n     }\n \n-    pub(crate) fn from_source_file(\n-        source_file: &SourceFile,\n-        file_id: HirFileId,\n-    ) -> SourceFileItems {\n+    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> FileAstId<N> {\n+        FileAstId { raw: self.id_of_unchecked(item.syntax()), _ty: PhantomData }\n+    }\n+\n+    fn from_source_file(source_file: &SourceFile, file_id: HirFileId) -> SourceFileItems {\n         let mut res = SourceFileItems { file_id, arena: Arena::default() };\n         // By walking the tree in bread-first order we make sure that parents\n         // get lower ids then children. That is, adding a new child does not\n@@ -138,7 +135,8 @@ impl SourceFileItems {\n     fn alloc(&mut self, item: &SyntaxNode) -> SourceFileItemId {\n         self.arena.alloc(SyntaxNodePtr::new(item))\n     }\n-    pub(crate) fn id_of_unchecked(&self, item: &SyntaxNode) -> SourceFileItemId {\n+\n+    fn id_of_unchecked(&self, item: &SyntaxNode) -> SourceFileItemId {\n         let ptr = SyntaxNodePtr::new(item);\n         if let Some((id, _)) = self.arena.iter().find(|(_id, i)| **i == ptr) {\n             return id;\n@@ -149,16 +147,6 @@ impl SourceFileItems {\n             self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n         );\n     }\n-    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> FileAstId<N> {\n-        FileAstId { raw: self.id_of_unchecked(item.syntax()), _ty: PhantomData }\n-    }\n-}\n-\n-impl std::ops::Index<SourceFileItemId> for SourceFileItems {\n-    type Output = SyntaxNodePtr;\n-    fn index(&self, idx: SourceFileItemId) -> &SyntaxNodePtr {\n-        &self.arena[idx]\n-    }\n }\n \n /// Walks the subtree in bfs order, calling `f` for each node."}]}