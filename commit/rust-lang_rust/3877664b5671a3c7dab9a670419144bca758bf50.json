{"sha": "3877664b5671a3c7dab9a670419144bca758bf50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4Nzc2NjRiNTY3MWEzYzdkYWI5YTY3MDQxOTE0NGJjYTc1OGJmNTA=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-11-20T12:51:18Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-11-26T16:21:17Z"}, "message": "stop using csearch in librustc and librustc_lint", "tree": {"sha": "a99b23728e97a2cb6fa6ec7d2e32b4d6fbdeba20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a99b23728e97a2cb6fa6ec7d2e32b4d6fbdeba20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3877664b5671a3c7dab9a670419144bca758bf50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3877664b5671a3c7dab9a670419144bca758bf50", "html_url": "https://github.com/rust-lang/rust/commit/3877664b5671a3c7dab9a670419144bca758bf50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3877664b5671a3c7dab9a670419144bca758bf50/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da0444d5d49bca80a75df7dbca502909558dfee5", "url": "https://api.github.com/repos/rust-lang/rust/commits/da0444d5d49bca80a75df7dbca502909558dfee5", "html_url": "https://github.com/rust-lang/rust/commit/da0444d5d49bca80a75df7dbca502909558dfee5"}], "stats": {"total": 477, "additions": 391, "deletions": 86}, "files": [{"sha": "40159b24fe71d0cca6804f55510421f63bec51c4", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=3877664b5671a3c7dab9a670419144bca758bf50", "patch": "@@ -406,4 +406,3 @@ pub fn def_path(tcx: &ty::ctxt, def: DefId) -> ast_map::DefPath {\n     let local_path = cdata.local_def_path();\n     local_path.into_iter().chain(path).collect()\n }\n-"}, {"sha": "008228e713bf1e20c03ce6abe748508b4e171e1f", "filename": "src/librustc/metadata/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=3877664b5671a3c7dab9a670419144bca758bf50", "patch": "@@ -21,3 +21,4 @@ pub mod loader;\n pub mod filesearch;\n pub mod macro_import;\n pub mod inline;\n+pub mod util;"}, {"sha": "c29c32311900ed4443ad7bb7cae634ffba6d6a59", "filename": "src/librustc/metadata/util.rs", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmetadata%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmetadata%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Futil.rs?ref=3877664b5671a3c7dab9a670419144bca758bf50", "patch": "@@ -0,0 +1,324 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use front::map as ast_map;\n+use metadata::cstore;\n+use metadata::decoder;\n+use middle::astencode;\n+use middle::lang_items;\n+use middle::ty;\n+use middle::def_id::{DefId, DefIndex};\n+\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::attr;\n+use rustc_front::hir;\n+\n+pub use metadata::csearch::FoundAst;\n+pub use metadata::cstore::LinkagePreference;\n+pub use metadata::decoder::DecodeInlinedItem;\n+pub use metadata::inline::InlinedItem;\n+\n+pub trait CrateStore<'tcx> {\n+    // item info\n+    fn stability(&self, def: DefId) -> Option<attr::Stability>;\n+    fn closure_kind(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n+                    -> ty::ClosureKind;\n+    fn closure_ty(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n+                  -> ty::ClosureTy<'tcx>;\n+    fn item_variances(&self, def: DefId) -> ty::ItemVariances;\n+    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n+    fn item_type(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                 -> ty::TypeScheme<'tcx>;\n+    fn item_path(&self, def: DefId) -> Vec<ast_map::PathElem>;\n+    fn item_name(&self, def: DefId) -> ast::Name;\n+    fn item_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                       -> ty::GenericPredicates<'tcx>;\n+    fn item_super_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                             -> ty::GenericPredicates<'tcx>;\n+    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n+    fn trait_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n+    fn adt_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n+    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n+\n+    // trait info\n+    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>;\n+    fn provided_trait_methods(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                              -> Vec<Rc<ty::Method<'tcx>>>;\n+    fn trait_item_def_ids(&self, def: DefId)\n+                          -> Vec<ty::ImplOrTraitItemId>;\n+\n+    // impl info\n+    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>;\n+    fn impl_trait_ref(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                      -> Option<ty::TraitRef<'tcx>>;\n+    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>;\n+    fn custom_coerce_unsized_kind(&self, def: DefId)\n+                                  -> Option<ty::adjustment::CustomCoerceUnsized>;\n+    fn associated_consts(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                         -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n+\n+    // trait/impl-item info\n+    fn trait_of_item(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId)\n+                     -> Option<DefId>;\n+    fn impl_or_trait_item(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> ty::ImplOrTraitItem<'tcx>;\n+\n+    // flags\n+    fn is_const_fn(&self, did: DefId) -> bool;\n+    fn is_defaulted_trait(&self, did: DefId) -> bool;\n+    fn is_impl(&self, did: DefId) -> bool;\n+\n+    // metadata\n+    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n+                                    -> Vec<(ast::CrateNum, cstore::LinkagePreference)>;\n+    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>;\n+    fn missing_lang_items(&self, cnum: ast::CrateNum)\n+                          -> Vec<lang_items::LangItem>;\n+    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool;\n+\n+    // misc.\n+    fn def_path(&self, def: DefId) -> ast_map::DefPath;\n+    fn maybe_get_item_ast(&'tcx self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> FoundAst<'tcx>;\n+}\n+\n+impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n+    fn stability(&self, def: DefId) -> Option<attr::Stability>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_stability(&*cdata, def.index)\n+    }\n+\n+    fn closure_kind(&self, _tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureKind\n+    {\n+        assert!(!def_id.is_local());\n+        let cdata = self.get_crate_data(def_id.krate);\n+        decoder::closure_kind(&*cdata, def_id.index)\n+    }\n+\n+    fn closure_ty(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx>\n+    {\n+        assert!(!def_id.is_local());\n+        let cdata = self.get_crate_data(def_id.krate);\n+        decoder::closure_ty(&*cdata, def_id.index, tcx)\n+    }\n+\n+    fn item_variances(&self, def: DefId) -> ty::ItemVariances {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_item_variances(&*cdata, def.index)\n+    }\n+\n+    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_repr_attrs(&*cdata, def.index)\n+    }\n+\n+    fn item_type(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                 -> ty::TypeScheme<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_type(&*cdata, def.index, tcx)\n+    }\n+\n+    fn item_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                       -> ty::GenericPredicates<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_predicates(&*cdata, def.index, tcx)\n+    }\n+\n+    fn item_super_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                             -> ty::GenericPredicates<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_super_predicates(&*cdata, def.index, tcx)\n+    }\n+\n+    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n+    {\n+        let cdata = self.get_crate_data(def_id.krate);\n+        decoder::get_item_attrs(&*cdata, def_id.index)\n+    }\n+\n+    fn trait_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_trait_def(&*cdata, def.index, tcx)\n+    }\n+\n+    fn adt_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_adt_def(&self.intr, &*cdata, def.index, tcx)\n+    }\n+\n+    fn item_path(&self, def: DefId) -> Vec<ast_map::PathElem> {\n+        let cdata = self.get_crate_data(def.krate);\n+        let path = decoder::get_item_path(&*cdata, def.index);\n+\n+        cdata.with_local_path(|cpath| {\n+            let mut r = Vec::with_capacity(cpath.len() + path.len());\n+            r.push_all(cpath);\n+            r.push_all(&path);\n+            r\n+        })\n+    }\n+\n+    fn item_name(&self, def: DefId) -> ast::Name {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_item_name(&self.intr, &cdata, def.index)\n+    }\n+\n+\n+    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n+    {\n+        let mut result = vec![];\n+        let cdata = self.get_crate_data(def_id.krate);\n+        decoder::each_inherent_implementation_for_type(&*cdata, def_id.index,\n+                                                       |iid| result.push(iid));\n+        result\n+    }\n+\n+    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>\n+    {\n+        let mut result = vec![];\n+        self.iter_crate_data(|_, cdata| {\n+            decoder::each_implementation_for_trait(cdata, def_id, &mut |iid| {\n+                result.push(iid)\n+            })\n+        });\n+        result\n+    }\n+\n+    fn provided_trait_methods(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                              -> Vec<Rc<ty::Method<'tcx>>>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_provided_trait_methods(self.intr.clone(), &*cdata, def.index, tcx)\n+    }\n+\n+    fn trait_item_def_ids(&self, def: DefId)\n+                          -> Vec<ty::ImplOrTraitItemId>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_trait_item_def_ids(&*cdata, def.index)\n+    }\n+\n+    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n+    {\n+        let cdata = self.get_crate_data(impl_def_id.krate);\n+        decoder::get_impl_items(&*cdata, impl_def_id.index)\n+    }\n+\n+    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_impl_polarity(&*cdata, def.index)\n+    }\n+\n+    fn impl_trait_ref(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                      -> Option<ty::TraitRef<'tcx>>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_impl_trait(&*cdata, def.index, tcx)\n+    }\n+\n+    fn custom_coerce_unsized_kind(&self, def: DefId)\n+                                  -> Option<ty::adjustment::CustomCoerceUnsized>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_custom_coerce_unsized_kind(&*cdata, def.index)\n+    }\n+\n+    // FIXME: killme\n+    fn associated_consts(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                         -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_associated_consts(self.intr.clone(), &*cdata, def.index, tcx)\n+    }\n+\n+    fn trait_of_item(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId) -> Option<DefId>\n+    {\n+        let cdata = self.get_crate_data(def_id.krate);\n+        decoder::get_trait_of_item(&*cdata, def_id.index, tcx)\n+    }\n+\n+    fn impl_or_trait_item(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> ty::ImplOrTraitItem<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::get_impl_or_trait_item(\n+            self.intr.clone(),\n+            &*cdata,\n+            def.index,\n+            tcx)\n+    }\n+\n+    fn is_const_fn(&self, did: DefId) -> bool\n+    {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::is_const_fn(&cdata, did.index)\n+    }\n+\n+    fn is_defaulted_trait(&self, trait_def_id: DefId) -> bool {\n+        let cdata = self.get_crate_data(trait_def_id.krate);\n+        decoder::is_defaulted_trait(&*cdata, trait_def_id.index)\n+    }\n+\n+    fn is_impl(&self, did: DefId) -> bool {\n+        let cdata = self.get_crate_data(did.krate);\n+        decoder::is_impl(&*cdata, did.index)\n+    }\n+\n+    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n+                                -> Vec<(ast::CrateNum, cstore::LinkagePreference)>\n+    {\n+        let cdata = self.get_crate_data(cnum);\n+        decoder::get_dylib_dependency_formats(&cdata)\n+    }\n+\n+    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>\n+    {\n+        let mut result = vec![];\n+        let crate_data = self.get_crate_data(cnum);\n+        decoder::each_lang_item(&*crate_data, |did, lid| {\n+            result.push((did, lid)); true\n+        });\n+        result\n+    }\n+\n+    fn missing_lang_items(&self, cnum: ast::CrateNum)\n+                          -> Vec<lang_items::LangItem>\n+    {\n+        let cdata = self.get_crate_data(cnum);\n+        decoder::get_missing_lang_items(&*cdata)\n+    }\n+\n+    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool\n+    {\n+        self.get_crate_data(cnum).staged_api\n+    }\n+\n+    fn def_path(&self, def: DefId) -> ast_map::DefPath {\n+        let cdata = self.get_crate_data(def.krate);\n+        let path = decoder::def_path(&*cdata, def.index);\n+        let local_path = cdata.local_def_path();\n+        local_path.into_iter().chain(path).collect()\n+    }\n+\n+    fn maybe_get_item_ast(&'tcx self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> FoundAst<'tcx>\n+    {\n+        let cdata = self.get_crate_data(def.krate);\n+        let decode_inlined_item = Box::new(astencode::decode_inlined_item);\n+        decoder::maybe_get_item_ast(&*cdata, tcx, def.index, decode_inlined_item)\n+    }\n+}"}, {"sha": "63134a8766d963f1a25f1e0d6b163af7c579005c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=3877664b5671a3c7dab9a670419144bca758bf50", "patch": "@@ -16,9 +16,8 @@ use self::EvalHint::*;\n \n use front::map as ast_map;\n use front::map::blocks::FnLikeNode;\n-use metadata::csearch;\n-use metadata::inline::InlinedItem;\n-use middle::{astencode, def, infer, subst, traits};\n+use metadata::util::{self as mdutil, CrateStore, InlinedItem};\n+use middle::{def, infer, subst, traits};\n use middle::def_id::DefId;\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n@@ -145,13 +144,12 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n             None => {}\n         }\n         let mut used_ref_id = false;\n-        let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n-            Box::new(astencode::decode_inlined_item)) {\n-            csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n+        let expr_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n+            mdutil::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 hir::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n-            csearch::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n+            mdutil::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n                 hir::ConstTraitItem(_, _) => {\n                     used_ref_id = true;\n                     match maybe_ref_id {\n@@ -170,7 +168,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                 }\n                 _ => None\n             },\n-            csearch::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n+            mdutil::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n                 hir::ImplItemKind::Const(_, ref expr) => Some(expr.id),\n                 _ => None\n             },\n@@ -196,15 +194,14 @@ fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: DefId)\n         None => {}\n     }\n \n-    if !csearch::is_const_fn(&tcx.sess.cstore, def_id) {\n+    if !tcx.sess.cstore.is_const_fn(def_id) {\n         tcx.extern_const_fns.borrow_mut().insert(def_id, ast::DUMMY_NODE_ID);\n         return None;\n     }\n \n-    let fn_id = match csearch::maybe_get_item_ast(tcx, def_id,\n-        box astencode::decode_inlined_item) {\n-        csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => Some(item.id),\n-        csearch::FoundAst::Found(&InlinedItem::ImplItem(_, ref item)) => Some(item.id),\n+    let fn_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n+        mdutil::FoundAst::Found(&InlinedItem::Item(ref item)) => Some(item.id),\n+        mdutil::FoundAst::Found(&InlinedItem::ImplItem(_, ref item)) => Some(item.id),\n         _ => None\n     };\n     tcx.extern_const_fns.borrow_mut().insert(def_id,"}, {"sha": "3be95d54ce54cd8610c64f859e858fbd410f8ed8", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=3877664b5671a3c7dab9a670419144bca758bf50", "patch": "@@ -65,8 +65,8 @@ use syntax::ast;\n \n use session;\n use session::config;\n-use metadata::cstore;\n-use metadata::csearch;\n+use metadata::util::CrateStore;\n+use metadata::util::LinkagePreference::{self, RequireStatic, RequireDynamic};\n use util::nodemap::FnvHashMap;\n \n /// A list of dependencies for a certain crate type.\n@@ -155,8 +155,8 @@ fn calculate_type(sess: &session::Session,\n         let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n         if src.dylib.is_some() {\n             info!(\"adding dylib: {}\", data.name);\n-            add_library(sess, cnum, cstore::RequireDynamic, &mut formats);\n-            let deps = csearch::get_dylib_dependency_formats(&sess.cstore, cnum);\n+            add_library(sess, cnum, RequireDynamic, &mut formats);\n+            let deps = sess.cstore.dylib_dependency_formats(cnum);\n             for &(depnum, style) in &deps {\n                 info!(\"adding {:?}: {}\", style,\n                       sess.cstore.get_crate_data(depnum).name.clone());\n@@ -168,8 +168,8 @@ fn calculate_type(sess: &session::Session,\n     // Collect what we've got so far in the return vector.\n     let mut ret = (1..sess.cstore.next_crate_num()).map(|i| {\n         match formats.get(&i) {\n-            Some(&cstore::RequireDynamic) => Linkage::Dynamic,\n-            Some(&cstore::RequireStatic) => Linkage::IncludedFromDylib,\n+            Some(&RequireDynamic) => Linkage::Dynamic,\n+            Some(&RequireStatic) => Linkage::IncludedFromDylib,\n             None => Linkage::NotLinked,\n         }\n     }).collect::<Vec<_>>();\n@@ -186,7 +186,7 @@ fn calculate_type(sess: &session::Session,\n            data.explicitly_linked.get() {\n             assert!(src.rlib.is_some());\n             info!(\"adding staticlib: {}\", data.name);\n-            add_library(sess, cnum, cstore::RequireStatic, &mut formats);\n+            add_library(sess, cnum, RequireStatic, &mut formats);\n             ret[cnum as usize - 1] = Linkage::Static;\n         }\n     });\n@@ -229,8 +229,8 @@ fn calculate_type(sess: &session::Session,\n \n fn add_library(sess: &session::Session,\n                cnum: ast::CrateNum,\n-               link: cstore::LinkagePreference,\n-               m: &mut FnvHashMap<ast::CrateNum, cstore::LinkagePreference>) {\n+               link: LinkagePreference,\n+               m: &mut FnvHashMap<ast::CrateNum, LinkagePreference>) {\n     match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library\n@@ -240,7 +240,7 @@ fn add_library(sess: &session::Session,\n             //\n             // This error is probably a little obscure, but I imagine that it\n             // can be refined over time.\n-            if link2 != link || link == cstore::RequireStatic {\n+            if link2 != link || link == RequireStatic {\n                 let data = sess.cstore.get_crate_data(cnum);\n                 sess.err(&format!(\"cannot satisfy dependencies so `{}` only \\\n                                    shows up once\", data.name));\n@@ -253,7 +253,7 @@ fn add_library(sess: &session::Session,\n }\n \n fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n-    let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n+    let crates = sess.cstore.get_used_crates(RequireStatic);\n     if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n         return None\n     }"}, {"sha": "470c12f1221ce0b761e4361d5214f14c6d92b146", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3877664b5671a3c7dab9a670419144bca758bf50", "patch": "@@ -23,7 +23,7 @@ pub use self::LangItem::*;\n \n use front::map as hir_map;\n use session::Session;\n-use metadata::csearch::each_lang_item;\n+use metadata::util::CrateStore;\n use middle::def_id::DefId;\n use middle::ty;\n use middle::weak_lang_items;\n@@ -205,11 +205,10 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     pub fn collect_external_language_items(&mut self) {\n         let crate_store = &self.session.cstore;\n         crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n-            each_lang_item(crate_store, crate_number, |index, item_index| {\n+            for (index, item_index) in crate_store.lang_items(crate_number) {\n                 let def_id = DefId { krate: crate_number, index: index };\n                 self.collect_item(item_index, def_id, DUMMY_SP);\n-                true\n-            });\n+            }\n         })\n     }\n "}, {"sha": "96c9f424e3e9ad165803217179cbd6bf9a550443", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=3877664b5671a3c7dab9a670419144bca758bf50", "patch": "@@ -16,11 +16,11 @@ pub use self::StabilityLevel::*;\n use session::Session;\n use lint;\n use metadata::cstore::LOCAL_CRATE;\n+use metadata::util::CrateStore;\n use middle::def;\n use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::ty;\n use middle::privacy::AccessLevels;\n-use metadata::csearch;\n use syntax::parse::token::InternedString;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::ast;\n@@ -621,7 +621,7 @@ fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n             }\n         _ => {\n             *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n-                || csearch::is_staged_api(&tcx.sess.cstore, id.krate))\n+                || tcx.sess.cstore.is_staged_api(id.krate))\n         }\n     }\n }\n@@ -653,7 +653,7 @@ fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stabil\n     let item_stab = if id.is_local() {\n         None // The stability cache is filled partially lazily\n     } else {\n-        csearch::get_stability(&tcx.sess.cstore, id).map(|st| tcx.intern_stability(st))\n+        tcx.sess.cstore.stability(id).map(|st| tcx.intern_stability(st))\n     };\n \n     item_stab.or_else(|| {"}, {"sha": "105abe155093f2594caf34544ae230d089a58d70", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=3877664b5671a3c7dab9a670419144bca758bf50", "patch": "@@ -16,7 +16,7 @@\n use front::map as ast_map;\n use session::Session;\n use lint;\n-use metadata::csearch;\n+use metadata::util::CrateStore;\n use middle;\n use middle::def::DefMap;\n use middle::def_id::DefId;\n@@ -155,7 +155,7 @@ impl<'tcx> Tables<'tcx> {\n             return kind;\n         }\n \n-        let kind = csearch::closure_kind(tcx, def_id);\n+        let kind = tcx.sess.cstore.closure_kind(tcx, def_id);\n         this.borrow_mut().closure_kinds.insert(def_id, kind);\n         kind\n     }\n@@ -173,7 +173,7 @@ impl<'tcx> Tables<'tcx> {\n             return ty.subst(tcx, &substs.func_substs);\n         }\n \n-        let ty = csearch::closure_ty(tcx, def_id);\n+        let ty = tcx.sess.cstore.closure_ty(tcx, def_id);\n         this.borrow_mut().closure_tys.insert(def_id, ty.clone());\n         ty.subst(tcx, &substs.func_substs)\n     }"}, {"sha": "bedff8b9a8a9da28d5b0fd09da8f1ba96c0d0e9e", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=3877664b5671a3c7dab9a670419144bca758bf50", "patch": "@@ -21,8 +21,8 @@ pub use self::LvaluePreference::*;\n \n use front::map as ast_map;\n use front::map::LinkedPath;\n-use metadata::csearch;\n use metadata::cstore::LOCAL_CRATE;\n+use metadata::util::CrateStore;\n use middle;\n use middle::def::{self, ExportMap};\n use middle::def_id::DefId;\n@@ -2131,7 +2131,7 @@ impl<'tcx> ctxt<'tcx> {\n                 self.sess.bug(&format!(\"provided_trait_methods: `{:?}` is not a trait\", id))\n             }\n         } else {\n-            csearch::get_provided_trait_methods(self, id)\n+            self.sess.cstore.provided_trait_methods(self, id)\n         }\n     }\n \n@@ -2176,7 +2176,7 @@ impl<'tcx> ctxt<'tcx> {\n                 }\n             }\n         } else {\n-            csearch::get_associated_consts(self, id)\n+            self.sess.cstore.associated_consts(self, id)\n         }\n     }\n \n@@ -2208,14 +2208,14 @@ impl<'tcx> ctxt<'tcx> {\n                 _ => None\n             }\n         } else {\n-            csearch::get_impl_polarity(self, id)\n+            self.sess.cstore.impl_polarity(id)\n         }\n     }\n \n     pub fn custom_coerce_unsized_kind(&self, did: DefId) -> adjustment::CustomCoerceUnsized {\n         memoized(&self.custom_coerce_unsized_kinds, did, |did: DefId| {\n             let (kind, src) = if did.krate != LOCAL_CRATE {\n-                (csearch::get_custom_coerce_unsized_kind(self, did), \"external\")\n+                (self.sess.cstore.custom_coerce_unsized_kind(did), \"external\")\n             } else {\n                 (None, \"local\")\n             };\n@@ -2234,21 +2234,21 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn impl_or_trait_item(&self, id: DefId) -> ImplOrTraitItem<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"impl_or_trait_items\", id, &self.impl_or_trait_items,\n-            || csearch::get_impl_or_trait_item(self, id))\n+            || self.sess.cstore.impl_or_trait_item(self, id))\n     }\n \n     pub fn trait_item_def_ids(&self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n         lookup_locally_or_in_crate_store(\n             \"trait_item_def_ids\", id, &self.trait_item_def_ids,\n-            || Rc::new(csearch::get_trait_item_def_ids(&self.sess.cstore, id)))\n+            || Rc::new(self.sess.cstore.trait_item_def_ids(id)))\n     }\n \n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n     /// an inherent impl.\n     pub fn impl_trait_ref(&self, id: DefId) -> Option<TraitRef<'tcx>> {\n         lookup_locally_or_in_crate_store(\n             \"impl_trait_refs\", id, &self.impl_trait_refs,\n-            || csearch::get_impl_trait(self, id))\n+            || self.sess.cstore.impl_trait_ref(self, id))\n     }\n \n     /// Returns whether this DefId refers to an impl\n@@ -2261,7 +2261,7 @@ impl<'tcx> ctxt<'tcx> {\n                 false\n             }\n         } else {\n-            csearch::is_impl(&self.sess.cstore, id)\n+            self.sess.cstore.is_impl(id)\n         }\n     }\n \n@@ -2277,7 +2277,7 @@ impl<'tcx> ctxt<'tcx> {\n         if id.is_local() {\n             self.map.def_path(id)\n         } else {\n-            csearch::def_path(self, id)\n+            self.sess.cstore.def_path(id)\n         }\n     }\n \n@@ -2287,15 +2287,15 @@ impl<'tcx> ctxt<'tcx> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.with_path(id, f)\n         } else {\n-            f(csearch::get_item_path(self, id).iter().cloned().chain(LinkedPath::empty()))\n+            f(self.sess.cstore.item_path(id).iter().cloned().chain(LinkedPath::empty()))\n         }\n     }\n \n     pub fn item_name(&self, id: DefId) -> ast::Name {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.get_path_elem(id).name()\n         } else {\n-            csearch::get_item_name(self, id)\n+            self.sess.cstore.item_name(id)\n         }\n     }\n \n@@ -2309,14 +2309,14 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn lookup_item_type(&self, did: DefId) -> TypeScheme<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"tcache\", did, &self.tcache,\n-            || csearch::get_type(self, did))\n+            || self.sess.cstore.item_type(self, did))\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n     pub fn lookup_trait_def(&self, did: DefId) -> &'tcx TraitDef<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"trait_defs\", did, &self.trait_defs,\n-            || self.alloc_trait_def(csearch::get_trait_def(self, did))\n+            || self.alloc_trait_def(self.sess.cstore.trait_def(self, did))\n         )\n     }\n \n@@ -2326,7 +2326,7 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn lookup_adt_def_master(&self, did: DefId) -> AdtDefMaster<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"adt_defs\", did, &self.adt_defs,\n-            || csearch::get_adt_def(self, did)\n+            || self.sess.cstore.adt_def(self, did)\n         )\n     }\n \n@@ -2341,22 +2341,22 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn lookup_predicates(&self, did: DefId) -> GenericPredicates<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"predicates\", did, &self.predicates,\n-            || csearch::get_predicates(self, did))\n+            || self.sess.cstore.item_predicates(self, did))\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n     pub fn lookup_super_predicates(&self, did: DefId) -> GenericPredicates<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"super_predicates\", did, &self.super_predicates,\n-            || csearch::get_super_predicates(self, did))\n+            || self.sess.cstore.item_super_predicates(self, did))\n     }\n \n     /// Get the attributes of a definition.\n     pub fn get_attrs(&self, did: DefId) -> Cow<'tcx, [ast::Attribute]> {\n         if let Some(id) = self.map.as_local_node_id(did) {\n             Cow::Borrowed(self.map.attrs(id))\n         } else {\n-            Cow::Owned(csearch::get_item_attrs(&self.sess.cstore, did))\n+            Cow::Owned(self.sess.cstore.item_attrs(did))\n         }\n     }\n \n@@ -2384,15 +2384,15 @@ impl<'tcx> ctxt<'tcx> {\n                     attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n                 }).collect()\n             } else {\n-                csearch::get_repr_attrs(&self.sess.cstore, did)\n+                self.sess.cstore.repr_attrs(did)\n             })\n         })\n     }\n \n     pub fn item_variances(&self, item_id: DefId) -> Rc<ItemVariances> {\n         lookup_locally_or_in_crate_store(\n             \"item_variance_map\", item_id, &self.item_variance_map,\n-            || Rc::new(csearch::get_item_variances(&self.sess.cstore, item_id)))\n+            || Rc::new(self.sess.cstore.item_variances(item_id)))\n     }\n \n     pub fn trait_has_default_impl(&self, trait_def_id: DefId) -> bool {\n@@ -2422,7 +2422,7 @@ impl<'tcx> ctxt<'tcx> {\n         debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\",\n                primitive_def_id);\n \n-        let impl_items = csearch::get_impl_items(&self.sess.cstore, primitive_def_id);\n+        let impl_items = self.sess.cstore.impl_items(primitive_def_id);\n \n         // Store the implementation info.\n         self.impl_items.borrow_mut().insert(primitive_def_id, impl_items);\n@@ -2444,15 +2444,12 @@ impl<'tcx> ctxt<'tcx> {\n         debug!(\"populate_inherent_implementations_for_type_if_necessary: searching for {:?}\",\n                type_id);\n \n-        let mut inherent_impls = Vec::new();\n-        csearch::each_inherent_implementation_for_type(&self.sess.cstore, type_id, |impl_def_id| {\n-            // Record the implementation.\n-            inherent_impls.push(impl_def_id);\n-\n+        let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n+        for &impl_def_id in &inherent_impls {\n             // Store the implementation info.\n-            let impl_items = csearch::get_impl_items(&self.sess.cstore, impl_def_id);\n+            let impl_items = self.sess.cstore.impl_items(impl_def_id);\n             self.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n-        });\n+        }\n \n         self.inherent_impls.borrow_mut().insert(type_id, Rc::new(inherent_impls));\n         self.populated_external_types.borrow_mut().insert(type_id);\n@@ -2472,12 +2469,12 @@ impl<'tcx> ctxt<'tcx> {\n \n         debug!(\"populate_implementations_for_trait_if_necessary: searching for {:?}\", def);\n \n-        if csearch::is_defaulted_trait(&self.sess.cstore, trait_id) {\n+        if self.sess.cstore.is_defaulted_trait(trait_id) {\n             self.record_trait_has_default_impl(trait_id);\n         }\n \n-        csearch::each_implementation_for_trait(&self.sess.cstore, trait_id, |impl_def_id| {\n-            let impl_items = csearch::get_impl_items(&self.sess.cstore, impl_def_id);\n+        for impl_def_id in self.sess.cstore.implementations_of_trait(trait_id) {\n+            let impl_items = self.sess.cstore.impl_items(impl_def_id);\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n             // Record the trait->implementation mapping.\n             def.record_impl(self, impl_def_id, trait_ref);\n@@ -2493,7 +2490,7 @@ impl<'tcx> ctxt<'tcx> {\n \n             // Store the implementation info.\n             self.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n-        });\n+        }\n \n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n     }\n@@ -2520,8 +2517,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(&self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return match csearch::get_impl_or_trait_item(self,\n-                                                         def_id).container() {\n+            return match self.sess.cstore.impl_or_trait_item(self, def_id).container() {\n                 TraitContainer(_) => None,\n                 ImplContainer(def_id) => Some(def_id),\n             };\n@@ -2542,7 +2538,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// the trait that the method belongs to. Otherwise, return `None`.\n     pub fn trait_of_item(&self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return csearch::get_trait_of_item(&self.sess.cstore, def_id, self);\n+            return self.sess.cstore.trait_of_item(self, def_id);\n         }\n         match self.impl_or_trait_items.borrow().get(&def_id).cloned() {\n             Some(impl_or_trait_item) => {"}, {"sha": "464d5a89995b45eb08414f3fbb00d5822d45995d", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=3877664b5671a3c7dab9a670419144bca758bf50", "patch": "@@ -12,7 +12,7 @@\n \n use session::config;\n use session::Session;\n-use metadata::csearch;\n+use metadata::util::CrateStore;\n use middle::lang_items;\n \n use syntax::ast;\n@@ -80,8 +80,8 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n \n     let mut missing = HashSet::new();\n     sess.cstore.iter_crate_data(|cnum, _| {\n-        for item in &csearch::get_missing_lang_items(&sess.cstore, cnum) {\n-            missing.insert(*item);\n+        for item in sess.cstore.missing_lang_items(cnum) {\n+            missing.insert(item);\n         }\n     });\n "}, {"sha": "b8750cccb4b729d7c4f78bb21a4c121fdbaddc25", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3877664b5671a3c7dab9a670419144bca758bf50/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=3877664b5671a3c7dab9a670419144bca758bf50", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use metadata::csearch;\n use middle::pat_util;\n use middle::ty;\n use middle::ty::adjustment;\n-use rustc::front::map as hir_map;\n use util::nodemap::FnvHashMap;\n use lint::{LateContext, EarlyContext, LintContext, LintArray};\n use lint::{LintPass, EarlyLintPass, LateLintPass};\n@@ -138,16 +136,8 @@ impl LateLintPass for UnusedResults {\n             ty::TyBool => return,\n             ty::TyStruct(def, _) |\n             ty::TyEnum(def, _) => {\n-                if let Some(def_node_id) = cx.tcx.map.as_local_node_id(def.did) {\n-                    if let hir_map::NodeItem(it) = cx.tcx.map.get(def_node_id) {\n-                        check_must_use(cx, &it.attrs, s.span)\n-                    } else {\n-                        false\n-                    }\n-                } else {\n-                    let attrs = csearch::get_item_attrs(&cx.sess().cstore, def.did);\n-                    check_must_use(cx, &attrs[..], s.span)\n-                }\n+                let attrs = cx.tcx.get_attrs(def.did);\n+                check_must_use(cx, &attrs[..], s.span)\n             }\n             _ => false,\n         };\n@@ -459,4 +449,3 @@ impl LateLintPass for UnusedAllocation {\n         }\n     }\n }\n-"}]}