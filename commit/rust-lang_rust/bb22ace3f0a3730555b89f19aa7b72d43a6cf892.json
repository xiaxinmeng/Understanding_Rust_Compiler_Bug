{"sha": "bb22ace3f0a3730555b89f19aa7b72d43a6cf892", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMjJhY2UzZjBhMzczMDU1NWI4OWYxOWFhN2I3MmQ0M2E2Y2Y4OTI=", "commit": {"author": {"name": "Scott Lawrence", "email": "bytbox@gmail.com", "date": "2014-01-27T04:21:44Z"}, "committer": {"name": "Scott Lawrence", "email": "bytbox@gmail.com", "date": "2014-01-29T14:15:41Z"}, "message": "Removing do keyword from libgreen", "tree": {"sha": "d092f9cc2d94784ff9e6578c7ef271de6f201d4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d092f9cc2d94784ff9e6578c7ef271de6f201d4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb22ace3f0a3730555b89f19aa7b72d43a6cf892", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb22ace3f0a3730555b89f19aa7b72d43a6cf892", "html_url": "https://github.com/rust-lang/rust/commit/bb22ace3f0a3730555b89f19aa7b72d43a6cf892", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb22ace3f0a3730555b89f19aa7b72d43a6cf892/comments", "author": {"login": "bytbox", "id": 160033, "node_id": "MDQ6VXNlcjE2MDAzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/160033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bytbox", "html_url": "https://github.com/bytbox", "followers_url": "https://api.github.com/users/bytbox/followers", "following_url": "https://api.github.com/users/bytbox/following{/other_user}", "gists_url": "https://api.github.com/users/bytbox/gists{/gist_id}", "starred_url": "https://api.github.com/users/bytbox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bytbox/subscriptions", "organizations_url": "https://api.github.com/users/bytbox/orgs", "repos_url": "https://api.github.com/users/bytbox/repos", "events_url": "https://api.github.com/users/bytbox/events{/privacy}", "received_events_url": "https://api.github.com/users/bytbox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bytbox", "id": 160033, "node_id": "MDQ6VXNlcjE2MDAzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/160033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bytbox", "html_url": "https://github.com/bytbox", "followers_url": "https://api.github.com/users/bytbox/followers", "following_url": "https://api.github.com/users/bytbox/following{/other_user}", "gists_url": "https://api.github.com/users/bytbox/gists{/gist_id}", "starred_url": "https://api.github.com/users/bytbox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bytbox/subscriptions", "organizations_url": "https://api.github.com/users/bytbox/orgs", "repos_url": "https://api.github.com/users/bytbox/repos", "events_url": "https://api.github.com/users/bytbox/events{/privacy}", "received_events_url": "https://api.github.com/users/bytbox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "badc580416febb2570064df955dec1cdb1a471d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/badc580416febb2570064df955dec1cdb1a471d0", "html_url": "https://github.com/rust-lang/rust/commit/badc580416febb2570064df955dec1cdb1a471d0"}], "stats": {"total": 200, "additions": 99, "deletions": 101}, "files": [{"sha": "89c3398ab62d029795e5e658452cb076b12f6171", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bb22ace3f0a3730555b89f19aa7b72d43a6cf892/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb22ace3f0a3730555b89f19aa7b72d43a6cf892/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=bb22ace3f0a3730555b89f19aa7b72d43a6cf892", "patch": "@@ -247,18 +247,18 @@ mod test {\n \n     #[test]\n     fn smoke() {\n-        do run {}\n+        run(proc() {});\n     }\n \n     #[test]\n     fn some_channels() {\n-        do run {\n+        run(proc() {\n             let (p, c) = Chan::new();\n-            do spawn {\n+            spawn(proc() {\n                 c.send(());\n-            }\n+            });\n             p.recv();\n-        }\n+        });\n     }\n \n     #[test]\n@@ -269,13 +269,13 @@ mod test {\n         });\n \n         for _ in range(0, 20) {\n-            do pool.spawn(TaskOpts::new()) {\n+            pool.spawn(TaskOpts::new(), proc() {\n                 let (p, c) = Chan::new();\n-                do spawn {\n+                spawn(proc() {\n                     c.send(());\n-                }\n+                });\n                 p.recv();\n-            }\n+            });\n         }\n \n         pool.shutdown();"}, {"sha": "f8d629589fc3c5f2a1d33b2cf062f57059ee455d", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb22ace3f0a3730555b89f19aa7b72d43a6cf892/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb22ace3f0a3730555b89f19aa7b72d43a6cf892/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=bb22ace3f0a3730555b89f19aa7b72d43a6cf892", "patch": "@@ -60,10 +60,10 @@ pub mod task;\n #[cfg(not(test))]\n pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n     use std::cast;\n-    do start(argc, argv) {\n+    start(argc, argv, proc() {\n         let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n         main();\n-    }\n+    })\n }\n \n /// Set up a default runtime configuration, given compiler-supplied arguments.\n@@ -222,7 +222,7 @@ impl SchedPool {\n                                             pool.task_state.clone());\n             pool.handles.push(sched.make_handle());\n             let sched = sched;\n-            pool.threads.push(do Thread::start { sched.bootstrap(); });\n+            pool.threads.push(Thread::start(proc() { sched.bootstrap(); }));\n         }\n \n         return pool;\n@@ -284,7 +284,7 @@ impl SchedPool {\n         let ret = sched.make_handle();\n         self.handles.push(sched.make_handle());\n         let sched = sched;\n-        self.threads.push(do Thread::start { sched.bootstrap() });\n+        self.threads.push(Thread::start(proc() { sched.bootstrap() }));\n \n         return ret;\n     }"}, {"sha": "7ac874ebd9542f7525a7408c64deb21f7bc60daf", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 70, "deletions": 72, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/bb22ace3f0a3730555b89f19aa7b72d43a6cf892/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb22ace3f0a3730555b89f19aa7b72d43a6cf892/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=bb22ace3f0a3730555b89f19aa7b72d43a6cf892", "patch": "@@ -998,10 +998,10 @@ mod test {\n     fn trivial_run_in_newsched_task_test() {\n         let mut task_ran = false;\n         let task_ran_ptr: *mut bool = &mut task_ran;\n-        do run {\n+        run(proc() {\n             unsafe { *task_ran_ptr = true };\n             rtdebug!(\"executed from the new scheduler\")\n-        }\n+        });\n         assert!(task_ran);\n     }\n \n@@ -1012,31 +1012,31 @@ mod test {\n         let task_run_count_ptr: *mut uint = &mut task_run_count;\n         // with only one thread this is safe to run in without worries of\n         // contention.\n-        do run {\n+        run(proc() {\n             for _ in range(0u, total) {\n-                do spawn || {\n+                spawn(proc() {\n                     unsafe { *task_run_count_ptr = *task_run_count_ptr + 1};\n-                }\n+                });\n             }\n-        }\n+        });\n         assert!(task_run_count == total);\n     }\n \n     #[test]\n     fn multiple_task_nested_test() {\n         let mut task_run_count = 0;\n         let task_run_count_ptr: *mut uint = &mut task_run_count;\n-        do run {\n-            do spawn {\n+        run(proc() {\n+            spawn(proc() {\n                 unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n-                do spawn {\n+                spawn(proc() {\n                     unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n-                    do spawn {\n+                    spawn(proc() {\n                         unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n-                    }\n-                }\n-            }\n-        }\n+                    })\n+                })\n+            })\n+        });\n         assert!(task_run_count == 3);\n     }\n \n@@ -1052,15 +1052,15 @@ mod test {\n             let mut handle1 = pool.spawn_sched();\n             let mut handle2 = pool.spawn_sched();\n \n-            handle1.send(TaskFromFriend(do pool.task(TaskOpts::new()) {\n+            handle1.send(TaskFromFriend(pool.task(TaskOpts::new(), proc() {\n                 chan.send(sched_id());\n-            }));\n+            })));\n             let sched1_id = port.recv();\n \n-            let mut task = do pool.task(TaskOpts::new()) {\n+            let mut task = pool.task(TaskOpts::new(), proc() {\n                 assert_eq!(sched_id(), sched1_id);\n                 dchan.send(());\n-            };\n+            });\n             task.give_home(HomeSched(handle1));\n             handle2.send(TaskFromFriend(task));\n         }\n@@ -1080,7 +1080,7 @@ mod test {\n         use std::rt::thread::Thread;\n         use std::sync::deque::BufferPool;\n \n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let sleepers = SleeperList::new();\n             let mut pool = BufferPool::new();\n             let (normal_worker, normal_stealer) = pool.deque();\n@@ -1146,23 +1146,23 @@ mod test {\n                 ret\n             }\n \n-            let task1 = do GreenTask::new_homed(&mut special_sched.stack_pool,\n-                                                None, HomeSched(t1_handle)) {\n+            let task1 = GreenTask::new_homed(&mut special_sched.stack_pool,\n+                                             None, HomeSched(t1_handle), proc() {\n                 rtassert!(on_appropriate_sched());\n-            };\n+            });\n \n-            let task2 = do GreenTask::new(&mut normal_sched.stack_pool, None) {\n+            let task2 = GreenTask::new(&mut normal_sched.stack_pool, None, proc() {\n                 rtassert!(on_appropriate_sched());\n-            };\n+            });\n \n-            let task3 = do GreenTask::new(&mut normal_sched.stack_pool, None) {\n+            let task3 = GreenTask::new(&mut normal_sched.stack_pool, None, proc() {\n                 rtassert!(on_appropriate_sched());\n-            };\n+            });\n \n-            let task4 = do GreenTask::new_homed(&mut special_sched.stack_pool,\n-                                                None, HomeSched(t4_handle)) {\n+            let task4 = GreenTask::new_homed(&mut special_sched.stack_pool,\n+                                             None, HomeSched(t4_handle), proc() {\n                 rtassert!(on_appropriate_sched());\n-            };\n+            });\n \n             // Signal from the special task that we are done.\n             let (port, chan) = Chan::<()>::new();\n@@ -1173,35 +1173,33 @@ mod test {\n                 sched.run_task(task, next)\n             }\n \n-            let normal_task = do GreenTask::new(&mut normal_sched.stack_pool,\n-                                                None) {\n+            let normal_task = GreenTask::new(&mut normal_sched.stack_pool, None, proc() {\n                 run(task2);\n                 run(task4);\n                 port.recv();\n                 let mut nh = normal_handle;\n                 nh.send(Shutdown);\n                 let mut sh = special_handle;\n                 sh.send(Shutdown);\n-            };\n+            });\n             normal_sched.enqueue_task(normal_task);\n \n-            let special_task = do GreenTask::new(&mut special_sched.stack_pool,\n-                                                 None) {\n+            let special_task = GreenTask::new(&mut special_sched.stack_pool, None, proc() {\n                 run(task1);\n                 run(task3);\n                 chan.send(());\n-            };\n+            });\n             special_sched.enqueue_task(special_task);\n \n             let normal_sched = normal_sched;\n-            let normal_thread = do Thread::start { normal_sched.bootstrap() };\n+            let normal_thread = Thread::start(proc() { normal_sched.bootstrap() });\n \n             let special_sched = special_sched;\n-            let special_thread = do Thread::start { special_sched.bootstrap() };\n+            let special_thread = Thread::start(proc() { special_sched.bootstrap() });\n \n             normal_thread.join();\n             special_thread.join();\n-        }\n+        });\n     }\n \n     //#[test]\n@@ -1226,11 +1224,11 @@ mod test {\n         // the work queue, but we are performing I/O, that once we do put\n         // something in the work queue again the scheduler picks it up and\n         // doesn't exit before emptying the work queue\n-        do pool.spawn(TaskOpts::new()) {\n-            do spawn {\n+        pool.spawn(TaskOpts::new(), proc() {\n+            spawn(proc() {\n                 timer::sleep(10);\n-            }\n-        }\n+            });\n+        });\n \n         pool.shutdown();\n     }\n@@ -1243,19 +1241,19 @@ mod test {\n         let mut pool1 = pool();\n         let mut pool2 = pool();\n \n-        do pool1.spawn(TaskOpts::new()) {\n+        pool1.spawn(TaskOpts::new(), proc() {\n             let id = sched_id();\n             chan1.send(());\n             port2.recv();\n             assert_eq!(id, sched_id());\n-        }\n+        });\n \n-        do pool2.spawn(TaskOpts::new()) {\n+        pool2.spawn(TaskOpts::new(), proc() {\n             let id = sched_id();\n             port1.recv();\n             assert_eq!(id, sched_id());\n             chan2.send(());\n-        }\n+        });\n \n         pool1.shutdown();\n         pool2.shutdown();\n@@ -1275,13 +1273,13 @@ mod test {\n \n     #[test]\n     fn multithreading() {\n-        do run {\n+        run(proc() {\n             let mut ports = ~[];\n             10.times(|| {\n                 let (port, chan) = Chan::new();\n-                do spawn {\n+                spawn(proc() {\n                     chan.send(());\n-                }\n+                });\n                 ports.push(port);\n             });\n \n@@ -1291,12 +1289,12 @@ mod test {\n                     None => break,\n                 }\n             }\n-        }\n+        });\n     }\n \n      #[test]\n     fn thread_ring() {\n-        do run {\n+        run(proc() {\n             let (end_port, end_chan) = Chan::new();\n \n             let n_tasks = 10;\n@@ -1309,19 +1307,19 @@ mod test {\n                 let (next_p, ch) = Chan::new();\n                 let imm_i = i;\n                 let imm_p = p;\n-                do spawn {\n+                spawn(proc() {\n                     roundtrip(imm_i, n_tasks, &imm_p, &ch);\n-                };\n+                });\n                 p = next_p;\n                 i += 1;\n             }\n             let p = p;\n-            do spawn {\n+            spawn(proc() {\n                 roundtrip(1, n_tasks, &p, &ch1);\n-            }\n+            });\n \n             end_port.recv();\n-        }\n+        });\n \n         fn roundtrip(id: int, n_tasks: int,\n                      p: &Port<(int, Chan<()>)>,\n@@ -1349,7 +1347,7 @@ mod test {\n     fn start_closure_dtor() {\n         // Regression test that the `start` task entrypoint can\n         // contain dtors that use task resources\n-        do run {\n+        run(proc() {\n             struct S { field: () }\n \n             impl Drop for S {\n@@ -1360,10 +1358,10 @@ mod test {\n \n             let s = S { field: () };\n \n-            do spawn {\n+            spawn(proc() {\n                 let _ss = &s;\n-            }\n-        }\n+            });\n+        });\n     }\n \n     // FIXME: #9407: xfail-test\n@@ -1374,46 +1372,46 @@ mod test {\n             threads: 2, // this must be > 1\n             event_loop_factory: Some(basic::event_loop),\n         });\n-        do pool.spawn(TaskOpts::new()) {\n+        pool.spawn(TaskOpts::new(), proc() {\n             let (port, chan) = Chan::new();\n \n             // This task should not be able to starve the sender;\n             // The sender should get stolen to another thread.\n-            do spawn {\n+            spawn(proc() {\n                 while port.try_recv() != comm::Data(()) { }\n-            }\n+            });\n \n             chan.send(());\n-        }\n+        });\n         pool.shutdown();\n     }\n \n     #[test]\n     fn dont_starve_2() {\n-        do run {\n+        run(proc() {\n             let (port, chan) = Chan::new();\n             let (_port2, chan2) = Chan::new();\n \n             // This task should not be able to starve the other task.\n             // The sends should eventually yield.\n-            do spawn {\n+            spawn(proc() {\n                 while port.try_recv() != comm::Data(()) {\n                     chan2.send(());\n                 }\n-            }\n+            });\n \n             chan.send(());\n-        }\n+        });\n     }\n \n     // Regression test for a logic bug that would cause single-threaded\n     // schedulers to sleep forever after yielding and stealing another task.\n     #[test]\n     fn single_threaded_yield() {\n         use std::task::deschedule;\n-        do run {\n+        run(proc() {\n             5.times(deschedule);\n-        }\n+        });\n     }\n \n     #[test]\n@@ -1461,11 +1459,11 @@ mod test {\n \n                 let (setup_po, setup_ch) = Chan::new();\n                 let (parent_po, parent_ch) = Chan::new();\n-                do spawn {\n+                spawn(proc() {\n                     let (child_po, child_ch) = Chan::new();\n                     setup_ch.send(child_ch);\n                     pingpong(&child_po, &parent_ch);\n-                };\n+                });\n \n                 let child_ch = setup_po.recv();\n                 child_ch.send(20);"}, {"sha": "f5dafe578cafdce06e149729fb0846867545b6c8", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bb22ace3f0a3730555b89f19aa7b72d43a6cf892/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb22ace3f0a3730555b89f19aa7b72d43a6cf892/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=bb22ace3f0a3730555b89f19aa7b72d43a6cf892", "patch": "@@ -494,19 +494,19 @@ mod tests {\n     #[test]\n     fn smoke() {\n         let (p, c) = Chan::new();\n-        do spawn_opts(TaskOpts::new()) {\n+        spawn_opts(TaskOpts::new(), proc() {\n             c.send(());\n-        }\n+        });\n         p.recv();\n     }\n \n     #[test]\n     fn smoke_fail() {\n         let (p, c) = Chan::<()>::new();\n-        do spawn_opts(TaskOpts::new()) {\n+        spawn_opts(TaskOpts::new(), proc() {\n             let _c = c;\n             fail!()\n-        }\n+        });\n         assert_eq!(p.recv_opt(), None);\n     }\n \n@@ -533,38 +533,38 @@ mod tests {\n     #[test]\n     fn yield_test() {\n         let (p, c) = Chan::new();\n-        do spawn_opts(TaskOpts::new()) {\n+        spawn_opts(TaskOpts::new(), proc() {\n             10.times(task::deschedule);\n             c.send(());\n-        }\n+        });\n         p.recv();\n     }\n \n     #[test]\n     fn spawn_children() {\n         let (p, c) = Chan::new();\n-        do spawn_opts(TaskOpts::new()) {\n+        spawn_opts(TaskOpts::new(), proc() {\n             let (p, c2) = Chan::new();\n-            do spawn {\n+            spawn(proc() {\n                 let (p, c3) = Chan::new();\n-                do spawn {\n+                spawn(proc() {\n                     c3.send(());\n-                }\n+                });\n                 p.recv();\n                 c2.send(());\n-            }\n+            });\n             p.recv();\n             c.send(());\n-        }\n+        });\n         p.recv();\n     }\n \n     #[test]\n     fn spawn_inherits() {\n         let (p, c) = Chan::new();\n-        do spawn_opts(TaskOpts::new()) {\n+        spawn_opts(TaskOpts::new(), proc() {\n             let c = c;\n-            do spawn {\n+            spawn(proc() {\n                 let mut task: ~Task = Local::take();\n                 match task.maybe_take_runtime::<GreenTask>() {\n                     Some(ops) => {\n@@ -574,8 +574,8 @@ mod tests {\n                 }\n                 Local::put(task);\n                 c.send(());\n-            }\n-        }\n+            });\n+        });\n         p.recv();\n     }\n }"}]}