{"sha": "d98d50832c8520e7e0284c4d199b305ec0066de2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5OGQ1MDgzMmM4NTIwZTdlMDI4NGM0ZDE5OWIzMDVlYzAwNjZkZTI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2015-02-04T16:16:59Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2015-02-06T20:22:41Z"}, "message": "debuginfo: Assign debuginfo source locations to lang-item calls.", "tree": {"sha": "a014f94ec1290cfaa3727d93542cc6a815e6066f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a014f94ec1290cfaa3727d93542cc6a815e6066f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d98d50832c8520e7e0284c4d199b305ec0066de2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d98d50832c8520e7e0284c4d199b305ec0066de2", "html_url": "https://github.com/rust-lang/rust/commit/d98d50832c8520e7e0284c4d199b305ec0066de2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d98d50832c8520e7e0284c4d199b305ec0066de2/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7884eb8e2ff8f0796a95aa0216e69241934ce14f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7884eb8e2ff8f0796a95aa0216e69241934ce14f", "html_url": "https://github.com/rust-lang/rust/commit/7884eb8e2ff8f0796a95aa0216e69241934ce14f"}], "stats": {"total": 326, "additions": 199, "deletions": 127}, "files": [{"sha": "b171f00d74f57269681384d8a5cb103472ce8d69", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 69, "deletions": 44, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=d98d50832c8520e7e0284c4d199b305ec0066de2", "patch": "@@ -244,25 +244,29 @@ impl<'a> ConstantExpr<'a> {\n // An option identifying a branch (either a literal, an enum variant or a range)\n #[derive(Debug)]\n enum Opt<'a, 'tcx> {\n-    ConstantValue(ConstantExpr<'a>),\n-    ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>),\n-    Variant(ty::Disr, Rc<adt::Repr<'tcx>>, ast::DefId),\n-    SliceLengthEqual(uint),\n-    SliceLengthGreaterOrEqual(/* prefix length */ uint, /* suffix length */ uint),\n+    ConstantValue(ConstantExpr<'a>, DebugLoc),\n+    ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>, DebugLoc),\n+    Variant(ty::Disr, Rc<adt::Repr<'tcx>>, ast::DefId, DebugLoc),\n+    SliceLengthEqual(uint, DebugLoc),\n+    SliceLengthGreaterOrEqual(/* prefix length */ uint,\n+                              /* suffix length */ uint,\n+                              DebugLoc),\n }\n \n impl<'a, 'tcx> Opt<'a, 'tcx> {\n     fn eq(&self, other: &Opt<'a, 'tcx>, tcx: &ty::ctxt<'tcx>) -> bool {\n         match (self, other) {\n-            (&ConstantValue(a), &ConstantValue(b)) => a.eq(b, tcx),\n-            (&ConstantRange(a1, a2), &ConstantRange(b1, b2)) => {\n+            (&ConstantValue(a, _), &ConstantValue(b, _)) => a.eq(b, tcx),\n+            (&ConstantRange(a1, a2, _), &ConstantRange(b1, b2, _)) => {\n                 a1.eq(b1, tcx) && a2.eq(b2, tcx)\n             }\n-            (&Variant(a_disr, ref a_repr, a_def), &Variant(b_disr, ref b_repr, b_def)) => {\n+            (&Variant(a_disr, ref a_repr, a_def, _),\n+             &Variant(b_disr, ref b_repr, b_def, _)) => {\n                 a_disr == b_disr && *a_repr == *b_repr && a_def == b_def\n             }\n-            (&SliceLengthEqual(a), &SliceLengthEqual(b)) => a == b,\n-            (&SliceLengthGreaterOrEqual(a1, a2), &SliceLengthGreaterOrEqual(b1, b2)) => {\n+            (&SliceLengthEqual(a, _), &SliceLengthEqual(b, _)) => a == b,\n+            (&SliceLengthGreaterOrEqual(a1, a2, _),\n+             &SliceLengthGreaterOrEqual(b1, b2, _)) => {\n                 a1 == b1 && a2 == b2\n             }\n             _ => false\n@@ -273,29 +277,39 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n         let _icx = push_ctxt(\"match::trans_opt\");\n         let ccx = bcx.ccx();\n         match *self {\n-            ConstantValue(ConstantExpr(lit_expr)) => {\n+            ConstantValue(ConstantExpr(lit_expr), _) => {\n                 let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n                 let (llval, _) = consts::const_expr(ccx, &*lit_expr);\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n-            ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2)) => {\n+            ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n                 let (l1, _) = consts::const_expr(ccx, &**l1);\n                 let (l2, _) = consts::const_expr(ccx, &**l2);\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }\n-            Variant(disr_val, ref repr, _) => {\n+            Variant(disr_val, ref repr, _, _) => {\n                 adt::trans_case(bcx, &**repr, disr_val)\n             }\n-            SliceLengthEqual(length) => {\n+            SliceLengthEqual(length, _) => {\n                 SingleResult(Result::new(bcx, C_uint(ccx, length)))\n             }\n-            SliceLengthGreaterOrEqual(prefix, suffix) => {\n+            SliceLengthGreaterOrEqual(prefix, suffix, _) => {\n                 LowerBound(Result::new(bcx, C_uint(ccx, prefix + suffix)))\n             }\n         }\n     }\n+\n+    fn debug_loc(&self) -> DebugLoc {\n+        match *self {\n+            ConstantValue(_,debug_loc)                 |\n+            ConstantRange(_, _, debug_loc)             |\n+            Variant(_, _, _, debug_loc)                |\n+            SliceLengthEqual(_, debug_loc)             |\n+            SliceLengthGreaterOrEqual(_, _, debug_loc) => debug_loc\n+        }\n+    }\n }\n \n #[derive(Copy, PartialEq)]\n@@ -527,18 +541,18 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n     let _indenter = indenter();\n \n     let ctor = match opt {\n-        &ConstantValue(ConstantExpr(expr)) => check_match::ConstantValue(\n+        &ConstantValue(ConstantExpr(expr), _) => check_match::ConstantValue(\n             const_eval::eval_const_expr(bcx.tcx(), &*expr)\n         ),\n-        &ConstantRange(ConstantExpr(lo), ConstantExpr(hi)) => check_match::ConstantRange(\n+        &ConstantRange(ConstantExpr(lo), ConstantExpr(hi), _) => check_match::ConstantRange(\n             const_eval::eval_const_expr(bcx.tcx(), &*lo),\n             const_eval::eval_const_expr(bcx.tcx(), &*hi)\n         ),\n-        &SliceLengthEqual(n) =>\n+        &SliceLengthEqual(n, _) =>\n             check_match::Slice(n),\n-        &SliceLengthGreaterOrEqual(before, after) =>\n+        &SliceLengthGreaterOrEqual(before, after, _) =>\n             check_match::SliceWithSubslice(before, after),\n-        &Variant(_, _, def_id) =>\n+        &Variant(_, _, def_id, _) =>\n             check_match::Constructor::Variant(def_id)\n     };\n \n@@ -563,27 +577,34 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut found: Vec<Opt> = vec![];\n     for br in m {\n         let cur = br.pats[col];\n+        let debug_loc = DebugLoc::At(cur.id, cur.span);\n+\n         let opt = match cur.node {\n-            ast::PatLit(ref l) => ConstantValue(ConstantExpr(&**l)),\n+            ast::PatLit(ref l) => {\n+                ConstantValue(ConstantExpr(&**l), debug_loc)\n+            }\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n                 let opt_def = tcx.def_map.borrow().get(&cur.id).cloned();\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n                         let variant = ty::enum_variant_with_id(tcx, enum_id, var_id);\n-                        Variant(variant.disr_val, adt::represent_node(bcx, cur.id), var_id)\n+                        Variant(variant.disr_val,\n+                                adt::represent_node(bcx, cur.id),\n+                                var_id,\n+                                debug_loc)\n                     }\n                     _ => continue\n                 }\n             }\n             ast::PatRange(ref l1, ref l2) => {\n-                ConstantRange(ConstantExpr(&**l1), ConstantExpr(&**l2))\n+                ConstantRange(ConstantExpr(&**l1), ConstantExpr(&**l2), debug_loc)\n             }\n             ast::PatVec(ref before, None, ref after) => {\n-                SliceLengthEqual(before.len() + after.len())\n+                SliceLengthEqual(before.len() + after.len(), debug_loc)\n             }\n             ast::PatVec(ref before, Some(_), ref after) => {\n-                SliceLengthGreaterOrEqual(before.len(), after.len())\n+                SliceLengthGreaterOrEqual(before.len(), after.len(), debug_loc)\n             }\n             _ => continue\n         };\n@@ -779,19 +800,21 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               lhs: ValueRef,\n                               rhs: ValueRef,\n-                              rhs_t: Ty<'tcx>)\n+                              rhs_t: Ty<'tcx>,\n+                              debug_loc: DebugLoc)\n                               -> Result<'blk, 'tcx> {\n     fn compare_str<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                lhs: ValueRef,\n                                rhs: ValueRef,\n-                               rhs_t: Ty<'tcx>)\n+                               rhs_t: Ty<'tcx>,\n+                               debug_loc: DebugLoc)\n                                -> Result<'blk, 'tcx> {\n         let did = langcall(cx,\n                            None,\n                            &format!(\"comparison of `{}`\",\n                                    cx.ty_to_string(rhs_t))[],\n                            StrEqFnLangItem);\n-        callee::trans_lang_call(cx, did, &[lhs, rhs], None)\n+        callee::trans_lang_call(cx, did, &[lhs, rhs], None, debug_loc)\n     }\n \n     let _icx = push_ctxt(\"compare_values\");\n@@ -802,7 +825,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n     match rhs_t.sty {\n         ty::ty_rptr(_, mt) => match mt.ty.sty {\n-            ty::ty_str => compare_str(cx, lhs, rhs, rhs_t),\n+            ty::ty_str => compare_str(cx, lhs, rhs, rhs_t, debug_loc),\n             ty::ty_vec(ty, _) => match ty.sty {\n                 ty::ty_uint(ast::TyU8) => {\n                     // NOTE: cast &[u8] to &str and abuse the str_eq lang item,\n@@ -812,7 +835,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                              ast::MutImmutable);\n                     let lhs = BitCast(cx, lhs, type_of::type_of(cx.ccx(), t).ptr_to());\n                     let rhs = BitCast(cx, rhs, type_of::type_of(cx.ccx(), t).ptr_to());\n-                    compare_str(cx, lhs, rhs, rhs_t)\n+                    compare_str(cx, lhs, rhs, rhs_t, debug_loc)\n                 },\n                 _ => cx.sess().bug(\"only byte strings supported in compare_values\"),\n             },\n@@ -1044,20 +1067,20 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));\n     if opts.len() > 0 {\n         match opts[0] {\n-            ConstantValue(_) | ConstantRange(_, _) => {\n+            ConstantValue(..) | ConstantRange(..) => {\n                 test_val = load_if_immediate(bcx, val, left_ty);\n                 kind = if ty::type_is_integral(left_ty) {\n                     Switch\n                 } else {\n                     Compare\n                 };\n             }\n-            Variant(_, ref repr, _) => {\n+            Variant(_, ref repr, _, _) => {\n                 let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val);\n                 kind = the_kind;\n                 if let Some(tval) = val_opt { test_val = tval; }\n             }\n-            SliceLengthEqual(_) | SliceLengthGreaterOrEqual(_, _) => {\n+            SliceLengthEqual(..) | SliceLengthGreaterOrEqual(..) => {\n                 let (_, len) = tvec::get_base_and_len(bcx, val, left_ty);\n                 test_val = len;\n                 kind = Switch;\n@@ -1066,8 +1089,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     }\n     for o in &opts {\n         match *o {\n-            ConstantRange(_, _) => { kind = Compare; break },\n-            SliceLengthGreaterOrEqual(_, _) => { kind = CompareSliceLength; break },\n+            ConstantRange(..) => { kind = Compare; break },\n+            SliceLengthGreaterOrEqual(..) => { kind = CompareSliceLength; break },\n             _ => ()\n         }\n     }\n@@ -1093,10 +1116,12 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         // for the current conditional branch.\n         let mut branch_chk = None;\n         let mut opt_cx = else_cx;\n+        let debug_loc = opt.debug_loc();\n+\n         if !exhaustive || i + 1 < len {\n             opt_cx = bcx.fcx.new_temp_block(\"match_case\");\n             match kind {\n-                Single => Br(bcx, opt_cx.llbb, DebugLoc::None),\n+                Single => Br(bcx, opt_cx.llbb, debug_loc),\n                 Switch => {\n                     match opt.trans(bcx) {\n                         SingleResult(r) => {\n@@ -1119,7 +1144,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     let Result { bcx: after_cx, val: matches } = {\n                         match opt.trans(bcx) {\n                             SingleResult(Result { bcx, val }) => {\n-                                compare_values(bcx, test_val, val, t)\n+                                compare_values(bcx, test_val, val, t, debug_loc)\n                             }\n                             RangeResult(Result { val: vbegin, .. },\n                                         Result { bcx, val: vend }) => {\n@@ -1131,7 +1156,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                     compare_scalar_types(\n                                     bcx, test_val, vend,\n                                     t, ast::BiLe);\n-                                Result::new(bcx, And(bcx, llge, llle, DebugLoc::None))\n+                                Result::new(bcx, And(bcx, llge, llle, debug_loc))\n                             }\n                             LowerBound(Result { bcx, val }) => {\n                                 compare_scalar_types(bcx, test_val, val, t, ast::BiGe)\n@@ -1149,37 +1174,37 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     if i + 1 < len && (guarded || multi_pats || kind == CompareSliceLength) {\n                         branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n                     }\n-                    CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb, DebugLoc::None);\n+                    CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb, debug_loc);\n                 }\n                 _ => ()\n             }\n         } else if kind == Compare || kind == CompareSliceLength {\n-            Br(bcx, else_cx.llbb, DebugLoc::None);\n+            Br(bcx, else_cx.llbb, debug_loc);\n         }\n \n         let mut size = 0;\n         let mut unpacked = Vec::new();\n         match *opt {\n-            Variant(disr_val, ref repr, _) => {\n+            Variant(disr_val, ref repr, _, _) => {\n                 let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n                     extract_variant_args(opt_cx, &**repr, disr_val, val);\n                 size = argvals.len();\n                 unpacked = argvals;\n                 opt_cx = new_bcx;\n             }\n-            SliceLengthEqual(len) => {\n+            SliceLengthEqual(len, _) => {\n                 let args = extract_vec_elems(opt_cx, left_ty, len, 0, val);\n                 size = args.vals.len();\n                 unpacked = args.vals.clone();\n                 opt_cx = args.bcx;\n             }\n-            SliceLengthGreaterOrEqual(before, after) => {\n+            SliceLengthGreaterOrEqual(before, after, _) => {\n                 let args = extract_vec_elems(opt_cx, left_ty, before, after, val);\n                 size = args.vals.len();\n                 unpacked = args.vals.clone();\n                 opt_cx = args.bcx;\n             }\n-            ConstantValue(_) | ConstantRange(_, _) => ()\n+            ConstantValue(..) | ConstantRange(..) => ()\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n         let mut opt_vals = unpacked;"}, {"sha": "6f9dc12a26df66645a3c4187dde8c3b373f63fb8", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d98d50832c8520e7e0284c4d199b305ec0066de2", "patch": "@@ -57,7 +57,7 @@ use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, ExternMap, FunctionContext};\n-use trans::common::{Result};\n+use trans::common::{Result, NodeIdAndSpan};\n use trans::common::{node_id_type, return_type_is_void};\n use trans::common::{tydesc_info, type_is_immediate};\n use trans::common::{type_is_zero_size, val_ty};\n@@ -379,15 +379,17 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   llty_ptr: Type,\n                                   info_ty: Ty<'tcx>,\n                                   size: ValueRef,\n-                                  align: ValueRef)\n+                                  align: ValueRef,\n+                                  debug_loc: DebugLoc)\n                                   -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"malloc_raw_exchange\");\n \n     // Allocate space:\n     let r = callee::trans_lang_call(bcx,\n         require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem),\n         &[size, align],\n-        None);\n+        None,\n+        debug_loc);\n \n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n@@ -851,7 +853,7 @@ pub fn cast_shift_rhs<F, G>(op: ast::BinOp,\n \n pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n                                 cx: Block<'blk, 'tcx>,\n-                                span: Span,\n+                                call_info: NodeIdAndSpan,\n                                 divrem: ast::BinOp,\n                                 lhs: ValueRef,\n                                 rhs: ValueRef,\n@@ -879,7 +881,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n-        controlflow::trans_fail(bcx, span, InternedString::new(zero_text))\n+        controlflow::trans_fail(bcx, call_info, InternedString::new(zero_text))\n     });\n \n     // To quote LLVM's documentation for the sdiv instruction:\n@@ -913,7 +915,8 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             let is_min = ICmp(bcx, llvm::IntEQ, lhs,\n                               C_integral(llty, min, true));\n             with_cond(bcx, is_min, |bcx| {\n-                controlflow::trans_fail(bcx, span,\n+                controlflow::trans_fail(bcx,\n+                                        call_info,\n                                         InternedString::new(overflow_text))\n             })\n         })"}, {"sha": "4a0c2147ddbde093f3d88a224f2f1d53c83581cb", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=d98d50832c8520e7e0284c4d199b305ec0066de2", "patch": "@@ -36,8 +36,8 @@ use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::closure;\n-use trans::common;\n-use trans::common::*;\n+use trans::common::{self, Block, Result, NodeIdAndSpan, ExprId, CrateContext,\n+                    ExprOrMethodCall, FunctionContext, MethodCallKey};\n use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n@@ -136,7 +136,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                              ref_expr: &ast::Expr)\n                              -> Callee<'blk, 'tcx> {\n         debug!(\"trans_def(def={}, ref_expr={})\", def.repr(bcx.tcx()), ref_expr.repr(bcx.tcx()));\n-        let expr_ty = node_id_type(bcx, ref_expr.id);\n+        let expr_ty = common::node_id_type(bcx, ref_expr.id);\n         match def {\n             def::DefFn(did, _) if {\n                 let maybe_def_id = inline::get_local_instance(bcx.ccx(), did);\n@@ -147,8 +147,9 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     _ => false\n                 }\n             } => {\n-                let substs = node_id_substs(bcx.ccx(), ExprId(ref_expr.id),\n-                                            bcx.fcx.param_substs);\n+                let substs = common::node_id_substs(bcx.ccx(),\n+                                                    ExprId(ref_expr.id),\n+                                                    bcx.fcx.param_substs);\n                 Callee {\n                     bcx: bcx,\n                     data: NamedTupleConstructor(substs, 0)\n@@ -158,8 +159,9 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 ty::ty_bare_fn(_, ref f) => f.abi == synabi::RustIntrinsic,\n                 _ => false\n             } => {\n-                let substs = node_id_substs(bcx.ccx(), ExprId(ref_expr.id),\n-                                            bcx.fcx.param_substs);\n+                let substs = common::node_id_substs(bcx.ccx(),\n+                                                    ExprId(ref_expr.id),\n+                                                    bcx.fcx.param_substs);\n                 let def_id = inline::maybe_instantiate_inline(bcx.ccx(), did);\n                 Callee { bcx: bcx, data: Intrinsic(def_id.node, substs) }\n             }\n@@ -178,8 +180,9 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             }\n             def::DefVariant(tid, vid, _) => {\n                 let vinfo = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n-                let substs = node_id_substs(bcx.ccx(), ExprId(ref_expr.id),\n-                                            bcx.fcx.param_substs);\n+                let substs = common::node_id_substs(bcx.ccx(),\n+                                                    ExprId(ref_expr.id),\n+                                                    bcx.fcx.param_substs);\n \n                 // Nullary variants are not callable\n                 assert!(vinfo.args.len() > 0);\n@@ -190,8 +193,9 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 }\n             }\n             def::DefStruct(_) => {\n-                let substs = node_id_substs(bcx.ccx(), ExprId(ref_expr.id),\n-                                            bcx.fcx.param_substs);\n+                let substs = common::node_id_substs(bcx.ccx(),\n+                                                    ExprId(ref_expr.id),\n+                                                    bcx.fcx.param_substs);\n                 Callee {\n                     bcx: bcx,\n                     data: NamedTupleConstructor(substs, 0)\n@@ -226,7 +230,7 @@ pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n-    let substs = node_id_substs(ccx, node, param_substs);\n+    let substs = common::node_id_substs(ccx, node, param_substs);\n     debug!(\"trans_fn_ref(def_id={}, node={:?}, substs={})\",\n            def_id.repr(ccx.tcx()),\n            node,\n@@ -269,7 +273,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_fn_pointer_shim\");\n     let tcx = ccx.tcx();\n \n-    let bare_fn_ty = erase_regions(tcx, &bare_fn_ty);\n+    let bare_fn_ty = common::erase_regions(tcx, &bare_fn_ty);\n     match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty) {\n         Some(&llval) => { return llval; }\n         None => { }\n@@ -352,7 +356,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     );\n \n     bcx = trans_call_inner(bcx,\n-                           None,\n+                           DebugLoc::None,\n                            bare_fn_ty,\n                            |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n                            ArgVals(&llargs[]),\n@@ -515,7 +519,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n                                                           param_substs,\n                                                           &ref_ty);\n             let llptrty = type_of::type_of_fn_from_ty(ccx, ref_ty).ptr_to();\n-            if llptrty != val_ty(val) {\n+            if llptrty != common::val_ty(val) {\n                 let val = consts::ptrcast(val, llptrty);\n                 return Datum::new(val, ref_ty, Rvalue::new(ByValue));\n             }\n@@ -563,7 +567,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     // other weird situations. Annoying.\n     let llty = type_of::type_of_fn_from_ty(ccx, fn_type);\n     let llptrty = llty.ptr_to();\n-    if val_ty(val) != llptrty {\n+    if common::val_ty(val) != llptrty {\n         debug!(\"trans_fn_ref_with_vtables(): casting pointer!\");\n         val = consts::ptrcast(val, llptrty);\n     } else {\n@@ -577,34 +581,34 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n // Translating calls\n \n pub fn trans_call<'a, 'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n-                                  call_ex: &ast::Expr,\n+                                  call_expr: &ast::Expr,\n                                   f: &ast::Expr,\n                                   args: CallArgs<'a, 'tcx>,\n                                   dest: expr::Dest)\n                                   -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n-                     Some(common::expr_info(call_ex)),\n-                     expr_ty_adjusted(in_cx, f),\n+                     call_expr.debug_loc(),\n+                     common::expr_ty_adjusted(in_cx, f),\n                      |cx, _| trans(cx, f),\n                      args,\n                      Some(dest)).bcx\n }\n \n pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                         call_ex: &ast::Expr,\n+                                         call_expr: &ast::Expr,\n                                          rcvr: &ast::Expr,\n                                          args: CallArgs<'a, 'tcx>,\n                                          dest: expr::Dest)\n                                          -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_method_call\");\n-    debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n-    let method_call = MethodCall::expr(call_ex.id);\n+    debug!(\"trans_method_call(call_expr={})\", call_expr.repr(bcx.tcx()));\n+    let method_call = MethodCall::expr(call_expr.id);\n     let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n     trans_call_inner(\n         bcx,\n-        Some(common::expr_info(call_ex)),\n-        monomorphize_type(bcx, method_ty),\n+        call_expr.debug_loc(),\n+        common::monomorphize_type(bcx, method_ty),\n         |cx, arg_cleanup_scope| {\n             meth::trans_method_callee(cx, method_call, Some(rcvr), arg_cleanup_scope)\n         },\n@@ -615,15 +619,16 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    did: ast::DefId,\n                                    args: &[ValueRef],\n-                                   dest: Option<expr::Dest>)\n+                                   dest: Option<expr::Dest>,\n+                                   debug_loc: DebugLoc)\n                                    -> Result<'blk, 'tcx> {\n     let fty = if did.krate == ast::LOCAL_CRATE {\n         ty::node_id_to_type(bcx.tcx(), did.node)\n     } else {\n         csearch::get_type(bcx.tcx(), did).ty\n     };\n     callee::trans_call_inner(bcx,\n-                             None,\n+                             debug_loc,\n                              fty,\n                              |bcx, _| {\n                                 trans_fn_ref_with_substs_to_callee(bcx,\n@@ -646,7 +651,7 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// For non-lang items, `dest` is always Some, and hence the result is written into memory\n /// somewhere. Nonetheless we return the actual return value of the function.\n pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                           call_info: Option<NodeIdAndSpan>,\n+                                           debug_loc: DebugLoc,\n                                            callee_ty: Ty<'tcx>,\n                                            get_callee: F,\n                                            args: CallArgs<'a, 'tcx>,\n@@ -687,7 +692,13 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             assert!(abi == synabi::RustIntrinsic);\n             assert!(dest.is_some());\n \n-            let call_info = call_info.expect(\"no call info for intrinsic call?\");\n+            let call_info = match debug_loc {\n+                DebugLoc::At(id, span) => NodeIdAndSpan { id: id, span: span },\n+                DebugLoc::None => {\n+                    bcx.sess().bug(\"No call info for intrinsic call?\")\n+                }\n+            };\n+\n             return intrinsic::trans_intrinsic_call(bcx, node, callee_ty,\n                                                    arg_cleanup_scope, args,\n                                                    dest.unwrap(), substs,\n@@ -703,7 +714,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                                        disr,\n                                                        args,\n                                                        dest.unwrap(),\n-                                                       call_info.debug_loc());\n+                                                       debug_loc);\n         }\n     };\n \n@@ -724,12 +735,12 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             };\n             if !is_rust_fn ||\n               type_of::return_uses_outptr(ccx, ret_ty) ||\n-              type_needs_drop(bcx.tcx(), ret_ty) {\n+              common::type_needs_drop(bcx.tcx(), ret_ty) {\n                 // Push the out-pointer if we use an out-pointer for this\n                 // return type, otherwise push \"undef\".\n-                if type_is_zero_size(ccx, ret_ty) {\n+                if common::type_is_zero_size(ccx, ret_ty) {\n                     let llty = type_of::type_of(ccx, ret_ty);\n-                    Some(C_undef(llty.ptr_to()))\n+                    Some(common::C_undef(llty.ptr_to()))\n                 } else {\n                     Some(alloc_ty(bcx, ret_ty, \"__llret\"))\n                 }\n@@ -781,7 +792,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                       llfn,\n                                       &llargs[],\n                                       callee_ty,\n-                                      call_info.debug_loc());\n+                                      debug_loc);\n         bcx = b;\n         llresult = llret;\n \n@@ -790,7 +801,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         match (opt_llretslot, ret_ty) {\n             (Some(llretslot), ty::FnConverging(ret_ty)) => {\n                 if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n-                    !type_is_zero_size(bcx.ccx(), ret_ty)\n+                    !common::type_is_zero_size(bcx.ccx(), ret_ty)\n                 {\n                     store_ty(bcx, llret, llretslot, ret_ty)\n                 }\n@@ -804,7 +815,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         let mut llargs = Vec::new();\n         let arg_tys = match args {\n-            ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, &**x)).collect(),\n+            ArgExprs(a) => a.iter().map(|x| common::expr_ty(bcx, &**x)).collect(),\n             _ => panic!(\"expected arg exprs.\")\n         };\n         bcx = trans_args(bcx,\n@@ -831,7 +842,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             bcx = glue::drop_ty(bcx,\n                                 llretslot,\n                                 ret_ty,\n-                                call_info.debug_loc());\n+                                debug_loc);\n             call_lifetime_end(bcx, llretslot);\n         }\n         _ => {}\n@@ -892,7 +903,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n \n     // Now untuple the rest of the arguments.\n     let tuple_expr = &arg_exprs[1];\n-    let tuple_type = node_id_type(bcx, tuple_expr.id);\n+    let tuple_type = common::node_id_type(bcx, tuple_expr.id);\n \n     match tuple_type.sty {\n         ty::ty_tup(ref field_types) => {\n@@ -1014,7 +1025,7 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 }\n                 let arg_ty = if i >= num_formal_args {\n                     assert!(variadic);\n-                    expr_ty_adjusted(cx, &**arg_expr)\n+                    common::expr_ty_adjusted(cx, &**arg_expr)\n                 } else {\n                     arg_tys[i]\n                 };"}, {"sha": "bebba151a0d313dee2db00c21bb38349b54f6b71", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=d98d50832c8520e7e0284c4d199b305ec0066de2", "patch": "@@ -940,11 +940,12 @@ impl<'tcx> Cleanup<'tcx> for FreeValue<'tcx> {\n                    bcx: Block<'blk, 'tcx>,\n                    debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        debug_loc.apply(bcx.fcx);\n-\n         match self.heap {\n             HeapExchange => {\n-                glue::trans_exchange_free_ty(bcx, self.ptr, self.content_ty)\n+                glue::trans_exchange_free_ty(bcx,\n+                                             self.ptr,\n+                                             self.content_ty,\n+                                             debug_loc)\n             }\n         }\n     }\n@@ -975,11 +976,13 @@ impl<'tcx> Cleanup<'tcx> for FreeSlice {\n                    bcx: Block<'blk, 'tcx>,\n                    debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        debug_loc.apply(bcx.fcx);\n-\n         match self.heap {\n             HeapExchange => {\n-                glue::trans_exchange_free_dyn(bcx, self.ptr, self.size, self.align)\n+                glue::trans_exchange_free_dyn(bcx,\n+                                              self.ptr,\n+                                              self.size,\n+                                              self.align,\n+                                              debug_loc)\n             }\n         }\n     }"}, {"sha": "8004726d25ea2bff709c58f4995931b596538058", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=d98d50832c8520e7e0284c4d199b305ec0066de2", "patch": "@@ -28,7 +28,6 @@ use util::ppaux::Repr;\n use syntax::ast;\n use syntax::ast::Ident;\n use syntax::ast_util;\n-use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n@@ -361,39 +360,40 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              sp: Span,\n+                              call_info: NodeIdAndSpan,\n                               fail_str: InternedString)\n                               -> Block<'blk, 'tcx> {\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"trans_fail_value\");\n \n     let v_str = C_str_slice(ccx, fail_str);\n-    let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n+    let loc = bcx.sess().codemap().lookup_char_pos(call_info.span.lo);\n     let filename = token::intern_and_get_ident(&loc.file.name[]);\n     let filename = C_str_slice(ccx, filename);\n     let line = C_uint(ccx, loc.line);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n     let expr_file_line = consts::const_addr_of(ccx, expr_file_line_const, ast::MutImmutable);\n     let args = vec!(expr_file_line);\n-    let did = langcall(bcx, Some(sp), \"\", PanicFnLangItem);\n+    let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n                                       &args[],\n-                                      Some(expr::Ignore)).bcx;\n+                                      Some(expr::Ignore),\n+                                      call_info.debug_loc()).bcx;\n     Unreachable(bcx);\n     return bcx;\n }\n \n pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                           sp: Span,\n+                                           call_info: NodeIdAndSpan,\n                                            index: ValueRef,\n                                            len: ValueRef)\n                                            -> Block<'blk, 'tcx> {\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n \n     // Extract the file/line from the span\n-    let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n+    let loc = bcx.sess().codemap().lookup_char_pos(call_info.span.lo);\n     let filename = token::intern_and_get_ident(&loc.file.name[]);\n \n     // Invoke the lang item\n@@ -402,11 +402,12 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let file_line_const = C_struct(ccx, &[filename, line], false);\n     let file_line = consts::const_addr_of(ccx, file_line_const, ast::MutImmutable);\n     let args = vec!(file_line, index, len);\n-    let did = langcall(bcx, Some(sp), \"\", PanicBoundsCheckFnLangItem);\n+    let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n                                       &args[],\n-                                      Some(expr::Ignore)).bcx;\n+                                      Some(expr::Ignore),\n+                                      call_info.debug_loc()).bcx;\n     Unreachable(bcx);\n     return bcx;\n }"}, {"sha": "a6a7422778a166d83108bf4f5c35431f863507ac", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=d98d50832c8520e7e0284c4d199b305ec0066de2", "patch": "@@ -1113,7 +1113,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum DebugLoc {\n     At(ast::NodeId, Span),\n     None"}, {"sha": "154d54c3d733b5b48fdfcd1bae0931877eec2bb8", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=d98d50832c8520e7e0284c4d199b305ec0066de2", "patch": "@@ -586,7 +586,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let contents_ty = expr_ty(bcx, &**contents);\n             match box_ty.sty {\n                 ty::ty_uniq(..) => {\n-                    trans_uniq_expr(bcx, box_ty, &**contents, contents_ty)\n+                    trans_uniq_expr(bcx, expr, box_ty, &**contents, contents_ty)\n                 }\n                 _ => bcx.sess().span_bug(expr.span,\n                                          \"expected unique box\")\n@@ -787,7 +787,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 index_expr.debug_loc());\n             bcx = with_cond(bcx, expected, |bcx| {\n                 controlflow::trans_fail_bounds_check(bcx,\n-                                                     index_expr.span,\n+                                                     expr_info(index_expr),\n                                                      ix_val,\n                                                      len)\n             });\n@@ -1574,7 +1574,7 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             immediate_rvalue_bcx(bcx, llneg, un_ty).to_expr_datumblock()\n         }\n         ast::UnUniq => {\n-            trans_uniq_expr(bcx, un_ty, sub_expr, expr_ty(bcx, sub_expr))\n+            trans_uniq_expr(bcx, expr, un_ty, sub_expr, expr_ty(bcx, sub_expr))\n         }\n         ast::UnDeref => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n@@ -1584,6 +1584,7 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               box_expr: &ast::Expr,\n                                box_ty: Ty<'tcx>,\n                                contents: &ast::Expr,\n                                contents_ty: Ty<'tcx>)\n@@ -1595,7 +1596,12 @@ fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let size = llsize_of(bcx.ccx(), llty);\n     let align = C_uint(bcx.ccx(), type_of::align_of(bcx.ccx(), contents_ty));\n     let llty_ptr = llty.ptr_to();\n-    let Result { bcx, val } = malloc_raw_dyn(bcx, llty_ptr, box_ty, size, align);\n+    let Result { bcx, val } = malloc_raw_dyn(bcx,\n+                                             llty_ptr,\n+                                             box_ty,\n+                                             size,\n+                                             align,\n+                                             box_expr.debug_loc());\n     // Unique boxes do not allocate for zero-size types. The standard library\n     // may assume that `free` is never called on the pointer returned for\n     // `Box<ZeroSizeType>`.\n@@ -1697,8 +1703,12 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             FDiv(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             // Only zero-check integers; fp /0 is NaN\n-            bcx = base::fail_if_zero_or_overflows(bcx, binop_expr.span,\n-                                                  op, lhs, rhs, rhs_t);\n+            bcx = base::fail_if_zero_or_overflows(bcx,\n+                                                  expr_info(binop_expr),\n+                                                  op,\n+                                                  lhs,\n+                                                  rhs,\n+                                                  rhs_t);\n             if is_signed {\n                 SDiv(bcx, lhs, rhs, binop_debug_loc)\n             } else {\n@@ -1711,7 +1721,8 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             FRem(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             // Only zero-check integers; fp %0 is NaN\n-            bcx = base::fail_if_zero_or_overflows(bcx, binop_expr.span,\n+            bcx = base::fail_if_zero_or_overflows(bcx,\n+                                                  expr_info(binop_expr),\n                                                   op, lhs, rhs, rhs_t);\n             if is_signed {\n                 SRem(bcx, lhs, rhs, binop_debug_loc)\n@@ -1845,7 +1856,7 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    -> Result<'blk, 'tcx> {\n     let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n     callee::trans_call_inner(bcx,\n-                             Some(expr_info(expr)),\n+                             expr.debug_loc(),\n                              monomorphize_type(bcx, method_ty),\n                              |bcx, arg_cleanup_scope| {\n                                 meth::trans_method_callee(bcx,\n@@ -1872,7 +1883,7 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     all_args.extend(args.iter().map(|e| &**e));\n     unpack_result!(bcx,\n                    callee::trans_call_inner(bcx,\n-                                            Some(expr_info(expr)),\n+                                            expr.debug_loc(),\n                                             monomorphize_type(bcx,\n                                                               method_type),\n                                             |bcx, arg_cleanup_scope| {"}, {"sha": "aefa0978dd4bb7d15bac1c9e36e16f54a5a52dda", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=d98d50832c8520e7e0284c4d199b305ec0066de2", "patch": "@@ -45,33 +45,47 @@ use std::ffi::CString;\n use syntax::ast;\n use syntax::parse::token;\n \n-pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n-                                           size: ValueRef, align: ValueRef)\n+pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                           v: ValueRef,\n+                                           size: ValueRef,\n+                                           align: ValueRef,\n+                                           debug_loc: DebugLoc)\n                                            -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     let ccx = cx.ccx();\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n         &[PointerCast(cx, v, Type::i8p(ccx)), size, align],\n-        Some(expr::Ignore)).bcx\n+        Some(expr::Ignore),\n+        debug_loc).bcx\n }\n \n-pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n-                                       size: u64, align: u32) -> Block<'blk, 'tcx> {\n-    trans_exchange_free_dyn(cx, v, C_uint(cx.ccx(), size),\n-                                   C_uint(cx.ccx(), align))\n+pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                       v: ValueRef,\n+                                       size: u64,\n+                                       align: u32,\n+                                       debug_loc: DebugLoc)\n+                                       -> Block<'blk, 'tcx> {\n+    trans_exchange_free_dyn(cx,\n+                            v,\n+                            C_uint(cx.ccx(), size),\n+                            C_uint(cx.ccx(), align),\n+                            debug_loc)\n }\n \n-pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef,\n-                                          content_ty: Ty<'tcx>) -> Block<'blk, 'tcx> {\n+pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          ptr: ValueRef,\n+                                          content_ty: Ty<'tcx>,\n+                                          debug_loc: DebugLoc)\n+                                          -> Block<'blk, 'tcx> {\n     assert!(type_is_sized(bcx.ccx().tcx(), content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n \n     // `Box<ZeroSizeType>` does not allocate.\n     if content_size != 0 {\n         let content_align = align_of(bcx.ccx(), content_ty);\n-        trans_exchange_free(bcx, ptr, content_size, content_align)\n+        trans_exchange_free(bcx, ptr, content_size, content_align, debug_loc)\n     } else {\n         bcx\n     }\n@@ -394,7 +408,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n                         let info = Load(bcx, info);\n                         let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n-                        trans_exchange_free_dyn(bcx, llbox, llsize, llalign)\n+                        trans_exchange_free_dyn(bcx, llbox, llsize, llalign, DebugLoc::None)\n                     })\n                 }\n                 _ => {\n@@ -404,7 +418,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n                         let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n-                        trans_exchange_free_ty(bcx, llbox, content_ty)\n+                        trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n                     })\n                 }\n             }"}, {"sha": "5161382a927ac3c5d1668dab2c42f15b3c2c6202", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=d98d50832c8520e7e0284c4d199b305ec0066de2", "patch": "@@ -667,7 +667,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n            method_offset_in_vtable);\n \n     bcx = trans_call_inner(bcx,\n-                           None,\n+                           DebugLoc::None,\n                            method_bare_fn_ty,\n                            |bcx, _| trans_trait_callee_from_llval(bcx,\n                                                                   method_bare_fn_ty,"}, {"sha": "5930876d15c90db0ef89592e97681340d8945f97", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98d50832c8520e7e0284c4d199b305ec0066de2/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=d98d50832c8520e7e0284c4d199b305ec0066de2", "patch": "@@ -77,7 +77,11 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 with_cond(bcx, not_empty, |bcx| {\n                     let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty));\n                     let size = Mul(bcx, C_uint(ccx, unit_size), len, DebugLoc::None);\n-                    glue::trans_exchange_free_dyn(bcx, dataptr, size, llalign)\n+                    glue::trans_exchange_free_dyn(bcx,\n+                                                  dataptr,\n+                                                  size,\n+                                                  llalign,\n+                                                  DebugLoc::None)\n                 })\n             } else {\n                 bcx"}]}