{"sha": "0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYjg3OGQyYWE2ZTNhMWNiMzE1ZjNmMzI4NjgxYjI2YmI0YmZmZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-28T17:53:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-28T17:53:10Z"}, "message": "Auto merge of #69555 - Centril:rollup-e53lxz4, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #68989 (Update RELEASES.md for 1.42.0)\n - #69340 (instantiate_value_path: on `SelfCtor`, avoid unconstrained tyvars)\n - #69384 (parser: `token` -> `normalized_token`, `nonnormalized_token` -> `token`)\n - #69452 (typeck: use `Pattern` obligation cause more for better diagnostics)\n - #69481 (use char instead of &str for single char patterns)\n - #69522 (error_derive_forbidden_on_non_adt: be more graceful)\n - #69538 (Stabilize `boxed_slice_try_from`)\n - #69539 (late resolve, visit_fn: bail early if there's no body.)\n - #69541 (Remove unneeded calls to format!())\n - #69547 (remove redundant clones, references to operands, explicit boolean comparisons and filter(x).next() calls.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d04ae2e07f7382e6437a0d069e301592864cb2e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d04ae2e07f7382e6437a0d069e301592864cb2e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "html_url": "https://github.com/rust-lang/rust/commit/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaa02f599f651246d5d1b99e7a4c6fa8d04bc9dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaa02f599f651246d5d1b99e7a4c6fa8d04bc9dc", "html_url": "https://github.com/rust-lang/rust/commit/eaa02f599f651246d5d1b99e7a4c6fa8d04bc9dc"}, {"sha": "13e4c6c51f7e239a429456dc62ba694219e591f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/13e4c6c51f7e239a429456dc62ba694219e591f9", "html_url": "https://github.com/rust-lang/rust/commit/13e4c6c51f7e239a429456dc62ba694219e591f9"}], "stats": {"total": 1243, "additions": 853, "deletions": 390}, "files": [{"sha": "7e18f1befddecb3afc8ebbd4f9549912baa15c49", "filename": "RELEASES.md", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,3 +1,100 @@\n+Version 1.42.0 (2020-03-12)\n+==========================\n+\n+Language\n+--------\n+- [You can now use the slice pattern syntax with subslices.][67712] e.g.\n+  ```rust\n+  fn foo(words: &[&str]) {\n+      match words {\n+          [\"Hello\", \"World\", \"!\", ..] => println!(\"Hello World!\"),\n+          [\"Foo\", \"Bar\", ..] => println!(\"Baz\"),\n+          rest => println!(\"{:?}\", rest),\n+      }\n+  }\n+  ```\n+- [You can now use `#[repr(transparent)]` on univariant `enum`s.][68122] Meaning\n+  that you can create an enum that has the exact layout and ABI of the type\n+  it contains.\n+- [There are some *syntax-only* changes:][67131]\n+   - `default` is syntactically allowed before items in `trait` definitions.\n+   - Items in `impl`s (i.e. `const`s, `type`s, and `fn`s) may syntactically\n+     leave out their bodies in favor of `;`.\n+   - Bounds on associated types in `impl`s are now syntactically allowed\n+     (e.g. `type Foo: Ord;`).\n+   - `...` (the C-variadic type) may occur syntactically directly as the type of\n+      any function parameter.\n+  \n+  These are still rejected *semantically*, so you will likely receive an error\n+  but these changes can be seen and parsed by procedural macros and\n+  conditional compilation.\n+\n+Compiler\n+--------\n+- [Added tier 2\\* support for `armv7a-none-eabi`.][68253]\n+- [Added tier 2 support for `riscv64gc-unknown-linux-gnu`.][68339]\n+- [`Option::{expect,unwrap}` and\n+   `Result::{expect, expect_err, unwrap, unwrap_err}` now produce panic messages\n+   pointing to the location where they were called, rather than\n+   `core`'s internals. ][67887]\n+\n+\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+- [`iter::Empty<T>` now implements `Send` and `Sync` for any `T`.][68348]\n+- [`Pin::{map_unchecked, map_unchecked_mut}` no longer require the return type\n+   to implement `Sized`.][67935]\n+- [`io::Cursor` now derives `PartialEq` and `Eq`.][67233]\n+- [`Layout::new` is now `const`.][66254]\n+- [Added Standard Library support for `riscv64gc-unknown-linux-gnu`.][66899]\n+\n+\n+Stabilized APIs\n+---------------\n+- [`CondVar::wait_while`]\n+- [`CondVar::wait_timeout_while`]\n+- [`DebugMap::key`]\n+- [`DebugMap::value`]\n+- [`ManuallyDrop::take`]\n+- [`matches!`]\n+- [`ptr::slice_from_raw_parts_mut`]\n+- [`ptr::slice_from_raw_parts`]\n+\n+Cargo\n+-----\n+- [You no longer need to include `extern crate proc_macro;` to be able to\n+  `use proc_macro;` in the `2018` edition.][cargo/7700]\n+\n+Compatibility Notes\n+-------------------\n+- [`Error::description` has been deprecated, and its use will now produce a\n+  warning.][66919] It's recommended to use `Display`/`to_string` instead.\n+\n+[68253]: https://github.com/rust-lang/rust/pull/68253/\n+[68348]: https://github.com/rust-lang/rust/pull/68348/\n+[67935]: https://github.com/rust-lang/rust/pull/67935/\n+[68339]: https://github.com/rust-lang/rust/pull/68339/\n+[68122]: https://github.com/rust-lang/rust/pull/68122/\n+[67712]: https://github.com/rust-lang/rust/pull/67712/\n+[67887]: https://github.com/rust-lang/rust/pull/67887/\n+[67131]: https://github.com/rust-lang/rust/pull/67131/\n+[67233]: https://github.com/rust-lang/rust/pull/67233/\n+[66899]: https://github.com/rust-lang/rust/pull/66899/\n+[66919]: https://github.com/rust-lang/rust/pull/66919/\n+[66254]: https://github.com/rust-lang/rust/pull/66254/\n+[cargo/7700]: https://github.com/rust-lang/cargo/pull/7700\n+[`DebugMap::key`]: https://doc.rust-lang.org/stable/std/fmt/struct.DebugMap.html#method.key\n+[`DebugMap::value`]: https://doc.rust-lang.org/stable/std/fmt/struct.DebugMap.html#method.value\n+[`ManuallyDrop::take`]: https://doc.rust-lang.org/stable/std/mem/struct.ManuallyDrop.html#method.take\n+[`matches!`]: https://doc.rust-lang.org/stable/std/macro.matches.html\n+[`ptr::slice_from_raw_parts_mut`]: https://doc.rust-lang.org/stable/std/ptr/fn.slice_from_raw_parts_mut.html\n+[`ptr::slice_from_raw_parts`]: https://doc.rust-lang.org/stable/std/ptr/fn.slice_from_raw_parts.html\n+[`CondVar::wait_while`]: https://doc.rust-lang.org/stable/std/sync/struct.Condvar.html#method.wait_while\n+[`CondVar::wait_timeout_while`]: https://doc.rust-lang.org/stable/std/sync/struct.Condvar.html#method.wait_timeout_while\n+\n+\n Version 1.41.1 (2020-02-27)\n ===========================\n \n@@ -8,6 +105,7 @@ Version 1.41.1 (2020-02-27)\n [69225]: https://github.com/rust-lang/rust/issues/69225\n [69145]: https://github.com/rust-lang/rust/pull/69145\n \n+\n Version 1.41.0 (2020-01-30)\n ===========================\n "}, {"sha": "81b0e9817d261f65315f810a10b52a320f065771", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -825,7 +825,7 @@ impl From<Box<str>> for Box<[u8]> {\n     }\n }\n \n-#[unstable(feature = \"boxed_slice_try_from\", issue = \"none\")]\n+#[stable(feature = \"boxed_slice_try_from\", since = \"1.43.0\")]\n impl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]>\n where\n     [T; N]: LengthAtMost32,"}, {"sha": "6ee128f4fa1d2a352968f14faab1172b94a7d434", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1453,7 +1453,7 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n     }\n }\n \n-#[unstable(feature = \"boxed_slice_try_from\", issue = \"none\")]\n+#[stable(feature = \"boxed_slice_try_from\", since = \"1.43.0\")]\n impl<T, const N: usize> TryFrom<Rc<[T]>> for Rc<[T; N]>\n where\n     [T; N]: LengthAtMost32,"}, {"sha": "9bd708c0f595c22df1814489dd1697cedede1e45", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -2002,7 +2002,7 @@ impl<T> From<Vec<T>> for Arc<[T]> {\n     }\n }\n \n-#[unstable(feature = \"boxed_slice_try_from\", issue = \"none\")]\n+#[stable(feature = \"boxed_slice_try_from\", since = \"1.43.0\")]\n impl<T, const N: usize> TryFrom<Arc<[T]>> for Arc<[T; N]>\n where\n     [T; N]: LengthAtMost32,"}, {"sha": "f7301280acd69ba5ead7052e5f9da2d3c9f5f2bc", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -153,17 +153,13 @@ pub struct Map<'hir> {\n     hir_to_node_id: FxHashMap<HirId, NodeId>,\n }\n \n-struct ParentHirIterator<'map, 'hir> {\n+/// An iterator that walks up the ancestor tree of a given `HirId`.\n+/// Constructed using `tcx.hir().parent_iter(hir_id)`.\n+pub struct ParentHirIterator<'map, 'hir> {\n     current_id: HirId,\n     map: &'map Map<'hir>,\n }\n \n-impl<'map, 'hir> ParentHirIterator<'map, 'hir> {\n-    fn new(current_id: HirId, map: &'map Map<'hir>) -> Self {\n-        Self { current_id, map }\n-    }\n-}\n-\n impl<'hir> Iterator for ParentHirIterator<'_, 'hir> {\n     type Item = (HirId, Node<'hir>);\n \n@@ -618,6 +614,12 @@ impl<'hir> Map<'hir> {\n         self.find_entry(hir_id).and_then(|x| x.parent_node()).unwrap_or(hir_id)\n     }\n \n+    /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n+    /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n+    pub fn parent_iter(&self, current_id: HirId) -> ParentHirIterator<'_, 'hir> {\n+        ParentHirIterator { current_id, map: self }\n+    }\n+\n     /// Checks if the node is an argument. An argument is a local variable whose\n     /// immediate parent is an item or a closure.\n     pub fn is_argument(&self, id: HirId) -> bool {\n@@ -684,7 +686,7 @@ impl<'hir> Map<'hir> {\n     /// }\n     /// ```\n     pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n-        let mut iter = ParentHirIterator::new(id, &self).peekable();\n+        let mut iter = self.parent_iter(id).peekable();\n         let mut ignore_tail = false;\n         if let Some(entry) = self.find_entry(id) {\n             if let Node::Expr(Expr { kind: ExprKind::Ret(_), .. }) = entry.node {\n@@ -731,7 +733,7 @@ impl<'hir> Map<'hir> {\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n-        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+        for (hir_id, node) in self.parent_iter(hir_id) {\n             match node {\n                 Node::Crate\n                 | Node::Item(_)\n@@ -753,7 +755,7 @@ impl<'hir> Map<'hir> {\n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n-        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+        for (hir_id, node) in self.parent_iter(hir_id) {\n             if let Node::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n                 return hir_id;\n             }\n@@ -767,7 +769,7 @@ impl<'hir> Map<'hir> {\n     /// Used by error reporting when there's a type error in a match arm caused by the `match`\n     /// expression needing to be unit.\n     pub fn get_match_if_cause(&self, hir_id: HirId) -> Option<&'hir Expr<'hir>> {\n-        for (_, node) in ParentHirIterator::new(hir_id, &self) {\n+        for (_, node) in self.parent_iter(hir_id) {\n             match node {\n                 Node::Item(_) | Node::ForeignItem(_) | Node::TraitItem(_) | Node::ImplItem(_) => {\n                     break;\n@@ -788,7 +790,7 @@ impl<'hir> Map<'hir> {\n \n     /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n     pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n-        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+        for (hir_id, node) in self.parent_iter(hir_id) {\n             if match node {\n                 Node::Item(i) => match i.kind {\n                     ItemKind::Fn(..)"}, {"sha": "9f98cf253c9771f7dfb26e0a64fd04393663df30", "filename": "src/librustc_builtin_macros/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_builtin_macros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_builtin_macros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fasm.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -182,7 +182,7 @@ fn parse_inline_asm<'a>(\n                     };\n \n                     let is_rw = output.is_some();\n-                    let is_indirect = constraint_str.contains(\"*\");\n+                    let is_indirect = constraint_str.contains('*');\n                     outputs.push(ast::InlineAsmOutput {\n                         constraint: output.unwrap_or(constraint),\n                         expr,\n@@ -199,15 +199,15 @@ fn parse_inline_asm<'a>(\n \n                     let constraint = parse_asm_str(&mut p)?;\n \n-                    if constraint.as_str().starts_with(\"=\") {\n+                    if constraint.as_str().starts_with('=') {\n                         struct_span_err!(\n                             cx.parse_sess.span_diagnostic,\n                             p.prev_span,\n                             E0662,\n                             \"input operand constraint contains '='\"\n                         )\n                         .emit();\n-                    } else if constraint.as_str().starts_with(\"+\") {\n+                    } else if constraint.as_str().starts_with('+') {\n                         struct_span_err!(\n                             cx.parse_sess.span_diagnostic,\n                             p.prev_span,\n@@ -234,7 +234,7 @@ fn parse_inline_asm<'a>(\n \n                     if OPTIONS.iter().any(|&opt| s == opt) {\n                         cx.span_warn(p.prev_span, \"expected a clobber, found an option\");\n-                    } else if s.as_str().starts_with(\"{\") || s.as_str().ends_with(\"}\") {\n+                    } else if s.as_str().starts_with('{') || s.as_str().ends_with('}') {\n                         struct_span_err!(\n                             cx.parse_sess.span_diagnostic,\n                             p.prev_span,"}, {"sha": "ad47e09aa671ad4171fd421967dd762038fb854c", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -158,7 +158,7 @@ fn parse_args<'a>(\n         } // accept trailing commas\n         if p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq) {\n             named = true;\n-            let name = if let token::Ident(name, _) = p.token.kind {\n+            let name = if let token::Ident(name, _) = p.normalized_token.kind {\n                 p.bump();\n                 name\n             } else {\n@@ -894,7 +894,7 @@ pub fn expand_preparsed_format_args(\n     };\n \n     let (is_literal, fmt_snippet) = match ecx.source_map().span_to_snippet(fmt_sp) {\n-        Ok(s) => (s.starts_with(\"\\\"\") || s.starts_with(\"r#\"), Some(s)),\n+        Ok(s) => (s.starts_with('\"') || s.starts_with(\"r#\"), Some(s)),\n         _ => (false, None),\n     };\n "}, {"sha": "6b136aeb8d9fb6201bfabac53b952593eb0a0b72", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -917,7 +917,7 @@ impl ThinLTOImports {\n             if line.is_empty() {\n                 let importing_module = current_module.take().expect(\"Importing module not set\");\n                 imports.insert(importing_module, mem::replace(&mut current_imports, vec![]));\n-            } else if line.starts_with(\" \") {\n+            } else if line.starts_with(' ') {\n                 // Space marks an imported module\n                 assert_ne!(current_module, None);\n                 current_imports.push(line.trim().to_string());"}, {"sha": "92cbc42388d61087a1f82911a8f42f16f5815e0c", "filename": "src/librustc_codegen_utils/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_codegen_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_codegen_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flink.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -78,7 +78,7 @@ pub fn find_crate_name(sess: Option<&Session>, attrs: &[ast::Attribute], input:\n     }\n     if let Input::File(ref path) = *input {\n         if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n-            if s.starts_with(\"-\") {\n+            if s.starts_with('-') {\n                 let msg = format!(\n                     \"crate names cannot start with a `-`, but \\\n                                    `{}` has a leading hyphen\","}, {"sha": "5686819c61b402441490e510ce66f40b5333f9a7", "filename": "src/librustc_driver/args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_driver%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_driver%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fargs.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -4,7 +4,7 @@ use std::fs;\n use std::io;\n \n pub fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n-    if arg.starts_with(\"@\") {\n+    if arg.starts_with('@') {\n         let path = &arg[1..];\n         let file = match fs::read_to_string(path) {\n             Ok(file) => file,"}, {"sha": "b00b1656bf7500d890d14e00bfa0fb73369a195f", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -521,7 +521,7 @@ fn stdout_isatty() -> bool {\n \n fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n     let normalised =\n-        if code.starts_with(\"E\") { code.to_string() } else { format!(\"E{0:0>4}\", code) };\n+        if code.starts_with('E') { code.to_string() } else { format!(\"E{0:0>4}\", code) };\n     match registry.find_description(&normalised) {\n         Some(ref description) => {\n             let mut is_in_code_block = false;\n@@ -601,7 +601,7 @@ impl RustcDefaultCalls {\n             });\n             compiler.codegen_backend().link(&sess, Box::new(codegen_results), &outputs)\n         } else {\n-            sess.fatal(&format!(\"rlink must be a file\"))\n+            sess.fatal(\"rlink must be a file\")\n         }\n     }\n "}, {"sha": "dff243a51b39f2f2b8f5fee6e121356dfeb07e92", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -503,13 +503,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     fn error_derive_forbidden_on_non_adt(&self, derives: &[Path], item: &Annotatable) {\n-        let attr =\n-            attr::find_by_name(item.attrs(), sym::derive).expect(\"`derive` attribute should exist\");\n-        let span = attr.span;\n+        let attr = attr::find_by_name(item.attrs(), sym::derive);\n+        let span = attr.map_or(item.span(), |attr| attr.span);\n         let mut err = self\n             .cx\n             .struct_span_err(span, \"`derive` may only be applied to structs, enums and unions\");\n-        if let ast::AttrStyle::Inner = attr.style {\n+        if let Some(ast::Attribute { style: ast::AttrStyle::Inner, .. }) = attr {\n             let trait_list = derives.iter().map(|t| pprust::path_to_string(t)).collect::<Vec<_>>();\n             let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n             err.span_suggestion(\n@@ -1669,10 +1668,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                         }\n                     }\n                 } else {\n-                    let mut err = self.cx.struct_span_err(\n-                        it.span(),\n-                        &format!(\"expected path to external documentation\"),\n-                    );\n+                    let mut err = self\n+                        .cx\n+                        .struct_span_err(it.span(), \"expected path to external documentation\");\n \n                     // Check if the user erroneously used `doc(include(...))` syntax.\n                     let literal = it.meta_item_list().and_then(|list| {"}, {"sha": "2a53d600c5bcf729355af25f3066e4b702f37f3d", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -753,6 +753,12 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n fn get_macro_name(token: &Token) -> Option<(Name, bool)> {\n     match token.kind {\n         token::Ident(name, is_raw) if name != kw::Underscore => Some((name, is_raw)),\n+        token::Interpolated(ref nt) => match **nt {\n+            token::NtIdent(ident, is_raw) if ident.name != kw::Underscore => {\n+                Some((ident.name, is_raw))\n+            }\n+            _ => None,\n+        },\n         _ => None,\n     }\n }\n@@ -883,9 +889,8 @@ fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a,\n         // this could be handled like a token, since it is one\n         sym::ident => {\n             if let Some((name, is_raw)) = get_macro_name(&p.token) {\n-                let span = p.token.span;\n                 p.bump();\n-                token::NtIdent(Ident::new(name, span), is_raw)\n+                token::NtIdent(Ident::new(name, p.normalized_prev_token.span), is_raw)\n             } else {\n                 let token_str = pprust::token_to_string(&p.token);\n                 let msg = &format!(\"expected ident, found {}\", &token_str);"}, {"sha": "ce4e262068c564c85717c8591777c3209e5bff41", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -205,7 +205,7 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n             TokenTree::Literal(self::Literal {\n                 lit: token::Lit { kind: token::Integer, symbol, suffix },\n                 span,\n-            }) if symbol.as_str().starts_with(\"-\") => {\n+            }) if symbol.as_str().starts_with('-') => {\n                 let minus = BinOp(BinOpToken::Minus);\n                 let symbol = Symbol::intern(&symbol.as_str()[1..]);\n                 let integer = TokenKind::lit(token::Integer, symbol, suffix);\n@@ -216,7 +216,7 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n             TokenTree::Literal(self::Literal {\n                 lit: token::Lit { kind: token::Float, symbol, suffix },\n                 span,\n-            }) if symbol.as_str().starts_with(\"-\") => {\n+            }) if symbol.as_str().starts_with('-') => {\n                 let minus = BinOp(BinOpToken::Minus);\n                 let symbol = Symbol::intern(&symbol.as_str()[1..]);\n                 let float = TokenKind::lit(token::Float, symbol, suffix);"}, {"sha": "6cbd8400783b467a0b962e95f5c538afb51ed177", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1504,7 +1504,7 @@ pub fn is_range_literal(sm: &SourceMap, expr: &Expr<'_>) -> bool {\n         let end_point = sm.end_point(*span);\n \n         if let Ok(end_string) = sm.span_to_snippet(end_point) {\n-            !(end_string.ends_with(\"}\") || end_string.ends_with(\")\"))\n+            !(end_string.ends_with('}') || end_string.ends_with(')'))\n         } else {\n             false\n         }"}, {"sha": "4dd08b517e1f214527903f66a35f3945cb7bcd17", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -81,10 +81,7 @@ impl AssertModuleSource<'tcx> {\n         if !self.tcx.sess.opts.debugging_opts.query_dep_graph {\n             self.tcx.sess.span_fatal(\n                 attr.span,\n-                &format!(\n-                    \"found CGU-reuse attribute but `-Zquery-dep-graph` \\\n-                          was not specified\"\n-                ),\n+                \"found CGU-reuse attribute but `-Zquery-dep-graph` was not specified\",\n             );\n         }\n \n@@ -107,7 +104,7 @@ impl AssertModuleSource<'tcx> {\n         }\n \n         // Split of the \"special suffix\" if there is one.\n-        let (user_path, cgu_special_suffix) = if let Some(index) = user_path.rfind(\".\") {\n+        let (user_path, cgu_special_suffix) = if let Some(index) = user_path.rfind('.') {\n             (&user_path[..index], Some(&user_path[index + 1..]))\n         } else {\n             (&user_path[..], None)"}, {"sha": "f6e2956e5b2fc86c82e39c0a174615ebac5d285a", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -537,10 +537,7 @@ impl FindAllAttrs<'tcx> {\n             if !checked_attrs.contains(&attr.id) {\n                 self.tcx.sess.span_err(\n                     attr.span,\n-                    &format!(\n-                        \"found unchecked \\\n-                    `#[rustc_dirty]` / `#[rustc_clean]` attribute\"\n-                    ),\n+                    \"found unchecked `#[rustc_dirty]` / `#[rustc_clean]` attribute\",\n                 );\n             }\n         }"}, {"sha": "8548ad392d2dd3b84ac1cb058fb3b95e473c9e6d", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -152,7 +152,7 @@ pub fn lock_file_path(session_dir: &Path) -> PathBuf {\n     let directory_name = session_dir.file_name().unwrap().to_string_lossy();\n     assert_no_characters_lost(&directory_name);\n \n-    let dash_indices: Vec<_> = directory_name.match_indices(\"-\").map(|(idx, _)| idx).collect();\n+    let dash_indices: Vec<_> = directory_name.match_indices('-').map(|(idx, _)| idx).collect();\n     if dash_indices.len() != 3 {\n         bug!(\n             \"Encountered incremental compilation session directory with \\\n@@ -342,7 +342,7 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n \n     // Keep the 's-{timestamp}-{random-number}' prefix, but replace the\n     // '-working' part with the SVH of the crate\n-    let dash_indices: Vec<_> = old_sub_dir_name.match_indices(\"-\").map(|(idx, _)| idx).collect();\n+    let dash_indices: Vec<_> = old_sub_dir_name.match_indices('-').map(|(idx, _)| idx).collect();\n     if dash_indices.len() != 3 {\n         bug!(\n             \"Encountered incremental compilation session directory with \\\n@@ -594,7 +594,7 @@ fn extract_timestamp_from_session_dir(directory_name: &str) -> Result<SystemTime\n         return Err(());\n     }\n \n-    let dash_indices: Vec<_> = directory_name.match_indices(\"-\").map(|(idx, _)| idx).collect();\n+    let dash_indices: Vec<_> = directory_name.match_indices('-').map(|(idx, _)| idx).collect();\n     if dash_indices.len() != 3 {\n         return Err(());\n     }"}, {"sha": "0dec5ae6da57a3054ae82fa80c5bc63bcab2efda", "filename": "src/librustc_infer/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_infer%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_infer%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fcoherence.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -39,10 +39,10 @@ pub struct OverlapResult<'tcx> {\n }\n \n pub fn add_placeholder_note(err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n-    err.note(&format!(\n+    err.note(\n         \"this behavior recently changed as a result of a bug fix; \\\n-         see rust-lang/rust#56105 for details\"\n-    ));\n+         see rust-lang/rust#56105 for details\",\n+    );\n }\n \n /// If there are types that satisfy both impls, invokes `on_overlap`"}, {"sha": "ca5f6b8b7b20800f97f321b4cbce507f09f4bef8", "filename": "src/librustc_infer/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -935,9 +935,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             // Already reported in the query.\n             ConstEvalFailure(ErrorHandled::Reported) => {\n-                self.tcx\n-                    .sess\n-                    .delay_span_bug(span, &format!(\"constant in type had an ignored error\"));\n+                self.tcx.sess.delay_span_bug(span, \"constant in type had an ignored error\");\n                 return;\n             }\n "}, {"sha": "980a3f04781346d9ec349aeb51d4a959cb830e4b", "filename": "src/librustc_infer/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_infer%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_infer%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fwf.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -232,10 +232,8 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         //                 found type `()`\n                         if let Some(hir::ItemKind::Impl { items, .. }) = item.map(|i| &i.kind) {\n                             let trait_assoc_item = tcx.associated_item(proj.projection_def_id());\n-                            if let Some(impl_item) = items\n-                                .iter()\n-                                .filter(|item| item.ident == trait_assoc_item.ident)\n-                                .next()\n+                            if let Some(impl_item) =\n+                                items.iter().find(|item| item.ident == trait_assoc_item.ident)\n                             {\n                                 cause.span = impl_item.span;\n                                 cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n@@ -285,13 +283,11 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         {\n                             if let Some((impl_item, trait_assoc_item)) = trait_assoc_items\n                                 .iter()\n-                                .filter(|i| i.def_id == *item_def_id)\n-                                .next()\n+                                .find(|i| i.def_id == *item_def_id)\n                                 .and_then(|trait_assoc_item| {\n                                     items\n                                         .iter()\n-                                        .filter(|i| i.ident == trait_assoc_item.ident)\n-                                        .next()\n+                                        .find(|i| i.ident == trait_assoc_item.ident)\n                                         .map(|impl_item| (impl_item, trait_assoc_item))\n                                 })\n                             {"}, {"sha": "b816673a5674e7f912ccf42149fa883a3d04137e", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -244,7 +244,7 @@ pub fn get_codegen_backend(sess: &Session) -> Box<dyn CodegenBackend> {\n             .as_ref()\n             .unwrap_or(&sess.target.target.options.codegen_backend);\n         let backend = match &codegen_name[..] {\n-            filename if filename.contains(\".\") => load_backend_from_dylib(filename.as_ref()),\n+            filename if filename.contains('.') => load_backend_from_dylib(filename.as_ref()),\n             codegen_name => get_builtin_codegen_backend(codegen_name),\n         };\n "}, {"sha": "9b4f03b3fb64b975e4513b2816e2ef0375103113", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -178,7 +178,7 @@ fn main() {\n     for lib in output(&mut cmd).split_whitespace() {\n         let name = if lib.starts_with(\"-l\") {\n             &lib[2..]\n-        } else if lib.starts_with(\"-\") {\n+        } else if lib.starts_with('-') {\n             &lib[1..]\n         } else if Path::new(lib).exists() {\n             // On MSVC llvm-config will print the full name to libraries, but"}, {"sha": "647224bc8d6b7f025e3504cfd9a54d6f6533c6eb", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -680,10 +680,7 @@ impl<'a> CrateLoader<'a> {\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n             if !data.is_profiler_runtime() {\n-                self.sess.err(&format!(\n-                    \"the crate `profiler_builtins` is not \\\n-                                        a profiler runtime\"\n-                ));\n+                self.sess.err(\"the crate `profiler_builtins` is not a profiler runtime\");\n             }\n         }\n     }"}, {"sha": "8cd75d4a2fd27a085c7328882590c410ea407c16", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -612,7 +612,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         } else {\n                             \"'_\".to_string()\n                         };\n-                        let suggestion = if snippet.ends_with(\";\") {\n+                        let suggestion = if snippet.ends_with(';') {\n                             // `type X = impl Trait;`\n                             format!(\"{} + {};\", &snippet[..snippet.len() - 1], suggestable_fr_name)\n                         } else {"}, {"sha": "aa49ab1b722d106b505e84d5df51cc546bb4e68a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -365,7 +365,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         // Skip over locals that begin with an underscore or have no name\n         match mbcx.local_names[local] {\n             Some(name) => {\n-                if name.as_str().starts_with(\"_\") {\n+                if name.as_str().starts_with('_') {\n                     continue;\n                 }\n             }"}, {"sha": "a0d93d6d19ab89b30c0cb1917c0805568edce1a0", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -689,11 +689,7 @@ pub trait BottomValue {\n     /// 3. Override `join` to do the opposite from what it's doing now.\n     #[inline]\n     fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        if Self::BOTTOM_VALUE == false {\n-            inout_set.union(in_set)\n-        } else {\n-            inout_set.intersect(in_set)\n-        }\n+        if !Self::BOTTOM_VALUE { inout_set.union(in_set) } else { inout_set.intersect(in_set) }\n     }\n }\n "}, {"sha": "9ba44a4d18e5813b9c3ada4c5648b47f40b779e1", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -65,10 +65,8 @@ impl NonConstOp for Downcast {\n pub struct FnCallIndirect;\n impl NonConstOp for FnCallIndirect {\n     fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-        let mut err = item\n-            .tcx\n-            .sess\n-            .struct_span_err(span, &format!(\"function pointers are not allowed in const fn\"));\n+        let mut err =\n+            item.tcx.sess.struct_span_err(span, \"function pointers are not allowed in const fn\");\n         err.emit();\n     }\n }"}, {"sha": "c534c2f3bb84cad82c55c9eb9314be326d6a90eb", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -122,7 +122,7 @@ impl<'tcx> MirSource<'tcx> {\n /// type `T`.\n pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n     let name = ::std::any::type_name::<T>();\n-    if let Some(tail) = name.rfind(\":\") { Cow::from(&name[tail + 1..]) } else { Cow::from(name) }\n+    if let Some(tail) = name.rfind(':') { Cow::from(&name[tail + 1..]) } else { Cow::from(name) }\n }\n \n /// A streamlined trait that you can implement to create a pass; the"}, {"sha": "00f5fb9705286e2a9641bac0d136a681b381c2d7", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -13,7 +13,7 @@ use syntax::ast::{\n };\n use syntax::ast::{AttrVec, ItemKind, Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind};\n use syntax::ptr::P;\n-use syntax::token::{self, token_can_begin_expr, TokenKind};\n+use syntax::token::{self, TokenKind};\n use syntax::util::parser::AssocOp;\n \n use log::{debug, trace};\n@@ -192,12 +192,12 @@ impl<'a> Parser<'a> {\n             TokenKind::CloseDelim(token::DelimToken::Brace),\n             TokenKind::CloseDelim(token::DelimToken::Paren),\n         ];\n-        if let token::Ident(name, false) = self.token.kind {\n-            if Ident::new(name, self.token.span).is_raw_guess()\n+        if let token::Ident(name, false) = self.normalized_token.kind {\n+            if Ident::new(name, self.normalized_token.span).is_raw_guess()\n                 && self.look_ahead(1, |t| valid_follow.contains(&t.kind))\n             {\n                 err.span_suggestion(\n-                    self.token.span,\n+                    self.normalized_token.span,\n                     \"you can escape reserved keywords to use them as identifiers\",\n                     format!(\"r#{}\", name),\n                     Applicability::MaybeIncorrect,\n@@ -900,8 +900,7 @@ impl<'a> Parser<'a> {\n         } else if !sm.is_multiline(self.prev_span.until(self.token.span)) {\n             // The current token is in the same line as the prior token, not recoverable.\n         } else if self.look_ahead(1, |t| {\n-            t == &token::CloseDelim(token::Brace)\n-                || token_can_begin_expr(t) && t.kind != token::Colon\n+            t == &token::CloseDelim(token::Brace) || t.can_begin_expr() && t.kind != token::Colon\n         }) && [token::Comma, token::Colon].contains(&self.token.kind)\n         {\n             // Likely typo: `,` \u2192 `;` or `:` \u2192 `;`. This is triggered if the current token is\n@@ -919,7 +918,7 @@ impl<'a> Parser<'a> {\n         } else if self.look_ahead(0, |t| {\n             t == &token::CloseDelim(token::Brace)\n                 || (\n-                    token_can_begin_expr(t) && t != &token::Semi && t != &token::Pound\n+                    t.can_begin_expr() && t != &token::Semi && t != &token::Pound\n                     // Avoid triggering with too many trailing `#` in raw string.\n                 )\n         }) {"}, {"sha": "71ca8fba0b4799195288271d75470ce2df64ac0a", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -97,15 +97,14 @@ impl<'a> Parser<'a> {\n     fn parse_expr_catch_underscore(&mut self) -> PResult<'a, P<Expr>> {\n         match self.parse_expr() {\n             Ok(expr) => Ok(expr),\n-            Err(mut err) => match self.token.kind {\n+            Err(mut err) => match self.normalized_token.kind {\n                 token::Ident(name, false)\n                     if name == kw::Underscore && self.look_ahead(1, |t| t == &token::Comma) =>\n                 {\n                     // Special-case handling of `foo(_, _, _)`\n                     err.emit();\n-                    let sp = self.token.span;\n                     self.bump();\n-                    Ok(self.mk_expr(sp, ExprKind::Err, AttrVec::new()))\n+                    Ok(self.mk_expr(self.prev_token.span, ExprKind::Err, AttrVec::new()))\n                 }\n                 _ => Err(err),\n             },\n@@ -166,7 +165,7 @@ impl<'a> Parser<'a> {\n         while let Some(op) = self.check_assoc_op() {\n             // Adjust the span for interpolated LHS to point to the `$lhs` token\n             // and not to what it refers to.\n-            let lhs_span = match self.unnormalized_prev_token.kind {\n+            let lhs_span = match self.prev_token.kind {\n                 TokenKind::Interpolated(..) => self.prev_span,\n                 _ => lhs.span,\n             };\n@@ -333,7 +332,7 @@ impl<'a> Parser<'a> {\n     /// Also performs recovery for `and` / `or` which are mistaken for `&&` and `||` respectively.\n     fn check_assoc_op(&self) -> Option<Spanned<AssocOp>> {\n         Some(Spanned {\n-            node: match (AssocOp::from_token(&self.token), &self.token.kind) {\n+            node: match (AssocOp::from_token(&self.token), &self.normalized_token.kind) {\n                 (Some(op), _) => op,\n                 (None, token::Ident(sym::and, false)) => {\n                     self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n@@ -345,7 +344,7 @@ impl<'a> Parser<'a> {\n                 }\n                 _ => return None,\n             },\n-            span: self.token.span,\n+            span: self.normalized_token.span,\n         })\n     }\n \n@@ -437,7 +436,7 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_or_use_outer_attributes(attrs)?;\n         let lo = self.token.span;\n         // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n-        let (hi, ex) = match self.token.kind {\n+        let (hi, ex) = match self.normalized_token.kind {\n             token::Not => self.parse_unary_expr(lo, UnOp::Not), // `!expr`\n             token::Tilde => self.recover_tilde_expr(lo),        // `~expr`\n             token::BinOp(token::Minus) => self.parse_unary_expr(lo, UnOp::Neg), // `-expr`\n@@ -523,7 +522,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, (Span, P<Expr>)> {\n         expr.map(|e| {\n             (\n-                match self.unnormalized_prev_token.kind {\n+                match self.prev_token.kind {\n                     TokenKind::Interpolated(..) => self.prev_span,\n                     _ => e.span,\n                 },\n@@ -704,7 +703,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_dot_suffix_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n-        match self.token.kind {\n+        match self.normalized_token.kind {\n             token::Ident(..) => self.parse_dot_suffix(base, lo),\n             token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n                 Ok(self.parse_tuple_field_access_expr(lo, base, symbol, suffix))\n@@ -754,7 +753,7 @@ impl<'a> Parser<'a> {\n                 s.print_usize(float.trunc() as usize);\n                 s.pclose();\n                 s.s.word(\".\");\n-                s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n+                s.s.word(fstr.splitn(2, '.').last().unwrap().to_string())\n             });\n             err.span_suggestion(\n                 lo.to(self.prev_span),\n@@ -773,8 +772,8 @@ impl<'a> Parser<'a> {\n         field: Symbol,\n         suffix: Option<Symbol>,\n     ) -> P<Expr> {\n-        let span = self.token.span;\n         self.bump();\n+        let span = self.prev_token.span;\n         let field = ExprKind::Field(base, Ident::new(field, span));\n         self.expect_no_suffix(span, \"a tuple index\", suffix);\n         self.mk_expr(lo.to(span), field, AttrVec::new())\n@@ -798,7 +797,7 @@ impl<'a> Parser<'a> {\n \n     /// Assuming we have just parsed `.`, continue parsing into an expression.\n     fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        if self.token.span.rust_2018() && self.eat_keyword(kw::Await) {\n+        if self.normalized_token.span.rust_2018() && self.eat_keyword(kw::Await) {\n             return self.mk_await_expr(self_arg, lo);\n         }\n \n@@ -912,7 +911,7 @@ impl<'a> Parser<'a> {\n             //       |             ^ expected expression\n             self.bump();\n             Ok(self.mk_expr_err(self.token.span))\n-        } else if self.token.span.rust_2018() {\n+        } else if self.normalized_token.span.rust_2018() {\n             // `Span::rust_2018()` is somewhat expensive; don't get it repeatedly.\n             if self.check_keyword(kw::Async) {\n                 if self.is_async_block() {\n@@ -1342,7 +1341,7 @@ impl<'a> Parser<'a> {\n             if self.eat_keyword(kw::Static) { Movability::Static } else { Movability::Movable };\n \n         let asyncness =\n-            if self.token.span.rust_2018() { self.parse_asyncness() } else { Async::No };\n+            if self.normalized_token.span.rust_2018() { self.parse_asyncness() } else { Async::No };\n         if asyncness.is_async() {\n             // Feature-gate `async ||` closures.\n             self.sess.gated_spans.gate(sym::async_closure, self.prev_span);\n@@ -1556,9 +1555,8 @@ impl<'a> Parser<'a> {\n \n     fn eat_label(&mut self) -> Option<Label> {\n         self.token.lifetime().map(|ident| {\n-            let span = self.token.span;\n             self.bump();\n-            Label { ident: Ident::new(ident.name, span) }\n+            Label { ident }\n         })\n     }\n \n@@ -1700,7 +1698,7 @@ impl<'a> Parser<'a> {\n     fn is_try_block(&self) -> bool {\n         self.token.is_keyword(kw::Try) &&\n         self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n-        self.token.span.rust_2018() &&\n+        self.normalized_token.span.rust_2018() &&\n         // Prevent `while try {} {}`, `if try {} {} else {}`, etc.\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n@@ -1850,13 +1848,12 @@ impl<'a> Parser<'a> {\n \n     /// Use in case of error after field-looking code: `S { foo: () with a }`.\n     fn find_struct_error_after_field_looking_code(&self) -> Option<Field> {\n-        if let token::Ident(name, _) = self.token.kind {\n+        if let token::Ident(name, _) = self.normalized_token.kind {\n             if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n-                let span = self.token.span;\n                 return Some(ast::Field {\n-                    ident: Ident::new(name, span),\n-                    span,\n-                    expr: self.mk_expr_err(span),\n+                    ident: Ident::new(name, self.normalized_token.span),\n+                    span: self.token.span,\n+                    expr: self.mk_expr_err(self.token.span),\n                     is_shorthand: false,\n                     attrs: AttrVec::new(),\n                     id: DUMMY_NODE_ID,"}, {"sha": "ef01df2ea05b418d6cb994de405719553eff4f06", "filename": "src/librustc_parse/parser/generics.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -121,15 +121,12 @@ impl<'a> Parser<'a> {\n                         .span_label(attrs[0].span, \"attributes must go before parameters\")\n                         .emit();\n                     } else {\n-                        self.struct_span_err(\n-                            attrs[0].span,\n-                            &format!(\"attribute without generic parameters\"),\n-                        )\n-                        .span_label(\n-                            attrs[0].span,\n-                            \"attributes are only permitted when preceding parameters\",\n-                        )\n-                        .emit();\n+                        self.struct_span_err(attrs[0].span, \"attribute without generic parameters\")\n+                            .span_label(\n+                                attrs[0].span,\n+                                \"attributes are only permitted when preceding parameters\",\n+                            )\n+                            .emit();\n                     }\n                 }\n                 break;"}, {"sha": "ef4246609da9a403cd86110282841c70aeb2e632", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -741,11 +741,10 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n-        match self.token.kind {\n+        match self.normalized_token.kind {\n             token::Ident(name @ kw::Underscore, false) => {\n-                let span = self.token.span;\n                 self.bump();\n-                Ok(Ident::new(name, span))\n+                Ok(Ident::new(name, self.normalized_prev_token.span))\n             }\n             _ => self.parse_ident(),\n         }\n@@ -1537,7 +1536,7 @@ impl<'a> Parser<'a> {\n \n         let is_name_required = match self.token.kind {\n             token::DotDotDot => false,\n-            _ => req_name(&self.token),\n+            _ => req_name(&self.normalized_token),\n         };\n         let (pat, ty) = if is_name_required || self.is_named_param() {\n             debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n@@ -1603,12 +1602,11 @@ impl<'a> Parser<'a> {\n     fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n         // Extract an identifier *after* having confirmed that the token is one.\n         let expect_self_ident = |this: &mut Self| {\n-            match this.token.kind {\n+            match this.normalized_token.kind {\n                 // Preserve hygienic context.\n                 token::Ident(name, _) => {\n-                    let span = this.token.span;\n                     this.bump();\n-                    Ident::new(name, span)\n+                    Ident::new(name, this.normalized_prev_token.span)\n                 }\n                 _ => unreachable!(),\n             }\n@@ -1645,7 +1643,7 @@ impl<'a> Parser<'a> {\n         // Only a limited set of initial token sequences is considered `self` parameters; anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n         let eself_lo = self.token.span;\n-        let (eself, eself_ident, eself_hi) = match self.token.kind {\n+        let (eself, eself_ident, eself_hi) = match self.normalized_token.kind {\n             token::BinOp(token::And) => {\n                 let eself = if is_isolated_self(self, 1) {\n                     // `&self`"}, {"sha": "58a03ee2a74b49c8e952cbdee9f433fc27494ba3", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -86,23 +86,22 @@ macro_rules! maybe_recover_from_interpolated_ty_qpath {\n #[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n+    /// The current non-normalized token.\n+    pub token: Token,\n     /// The current normalized token.\n     /// \"Normalized\" means that some interpolated tokens\n     /// (`$i: ident` and `$l: lifetime` meta-variables) are replaced\n     /// with non-interpolated identifier and lifetime tokens they refer to.\n-    /// Use span from this token if you need an isolated span.\n-    pub token: Token,\n-    /// The current non-normalized token if it's different from `token`.\n-    /// Use span from this token if you need to concatenate it with some neighbouring spans.\n-    unnormalized_token: Token,\n+    /// Use this if you need to check for `token::Ident` or `token::Lifetime` specifically,\n+    /// this also includes edition checks for edition-specific keyword identifiers.\n+    pub normalized_token: Token,\n+    /// The previous non-normalized token.\n+    pub prev_token: Token,\n     /// The previous normalized token.\n-    /// Use span from this token if you need an isolated span.\n-    prev_token: Token,\n-    /// The previous non-normalized token if it's different from `prev_token`.\n-    /// Use span from this token if you need to concatenate it with some neighbouring spans.\n-    unnormalized_prev_token: Token,\n-    /// Equivalent to `unnormalized_prev_token.span`.\n-    /// FIXME: Remove in favor of `(unnormalized_)prev_token.span`.\n+    /// Use this if you need to check for `token::Ident` or `token::Lifetime` specifically,\n+    /// this also includes edition checks for edition-specific keyword identifiers.\n+    pub normalized_prev_token: Token,\n+    /// FIXME: Remove in favor of the equivalent `prev_token.span`.\n     pub prev_span: Span,\n     restrictions: Restrictions,\n     /// Used to determine the path to externally loaded source files.\n@@ -375,9 +374,9 @@ impl<'a> Parser<'a> {\n         let mut parser = Parser {\n             sess,\n             token: Token::dummy(),\n-            unnormalized_token: Token::dummy(),\n+            normalized_token: Token::dummy(),\n             prev_token: Token::dummy(),\n-            unnormalized_prev_token: Token::dummy(),\n+            normalized_prev_token: Token::dummy(),\n             prev_span: DUMMY_SP,\n             restrictions: Restrictions::empty(),\n             recurse_into_file_modules,\n@@ -482,7 +481,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, ast::Ident> {\n-        match self.token.kind {\n+        match self.normalized_token.kind {\n             token::Ident(name, _) => {\n                 if self.token.is_reserved_ident() {\n                     let mut err = self.expected_ident_found();\n@@ -492,9 +491,8 @@ impl<'a> Parser<'a> {\n                         return Err(err);\n                     }\n                 }\n-                let span = self.token.span;\n                 self.bump();\n-                Ok(Ident::new(name, span))\n+                Ok(Ident::new(name, self.normalized_prev_token.span))\n             }\n             _ => Err(match self.prev_token.kind {\n                 TokenKind::DocComment(..) => {\n@@ -824,16 +822,16 @@ impl<'a> Parser<'a> {\n     // tokens are replaced with usual identifier and lifetime tokens,\n     // so the former are never encountered during normal parsing.\n     crate fn set_token(&mut self, token: Token) {\n-        self.unnormalized_token = token;\n-        self.token = match &self.unnormalized_token.kind {\n+        self.token = token;\n+        self.normalized_token = match &self.token.kind {\n             token::Interpolated(nt) => match **nt {\n                 token::NtIdent(ident, is_raw) => {\n                     Token::new(token::Ident(ident.name, is_raw), ident.span)\n                 }\n                 token::NtLifetime(ident) => Token::new(token::Lifetime(ident.name), ident.span),\n-                _ => self.unnormalized_token.clone(),\n+                _ => self.token.clone(),\n             },\n-            _ => self.unnormalized_token.clone(),\n+            _ => self.token.clone(),\n         }\n     }\n \n@@ -847,19 +845,19 @@ impl<'a> Parser<'a> {\n \n         // Update the current and previous tokens.\n         self.prev_token = self.token.take();\n-        self.unnormalized_prev_token = self.unnormalized_token.take();\n+        self.normalized_prev_token = self.normalized_token.take();\n         self.set_token(next_token);\n \n         // Update fields derived from the previous token.\n-        self.prev_span = self.unnormalized_prev_token.span;\n+        self.prev_span = self.prev_token.span;\n \n         // Diagnostics.\n         self.expected_tokens.clear();\n     }\n \n     /// Advance the parser by one token.\n     pub fn bump(&mut self) {\n-        let next_token = self.next_tok(self.unnormalized_token.span);\n+        let next_token = self.next_tok(self.token.span);\n         self.bump_with(next_token);\n     }\n \n@@ -890,7 +888,7 @@ impl<'a> Parser<'a> {\n     /// Parses asyncness: `async` or nothing.\n     fn parse_asyncness(&mut self) -> Async {\n         if self.eat_keyword(kw::Async) {\n-            let span = self.prev_span;\n+            let span = self.normalized_prev_token.span;\n             Async::Yes { span, closure_id: DUMMY_NODE_ID, return_impl_trait_id: DUMMY_NODE_ID }\n         } else {\n             Async::No"}, {"sha": "f3a61ad4419785e18d41f3569230a3f95a63cf41", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -134,7 +134,7 @@ impl<'a> Parser<'a> {\n             path\n         });\n \n-        let lo = self.unnormalized_token.span;\n+        let lo = self.token.span;\n         let mut segments = Vec::new();\n         let mod_sep_ctxt = self.token.span.ctxt();\n         if self.eat(&token::ModSep) {\n@@ -238,11 +238,10 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn parse_path_segment_ident(&mut self) -> PResult<'a, Ident> {\n-        match self.token.kind {\n+        match self.normalized_token.kind {\n             token::Ident(name, _) if name.is_path_segment_keyword() => {\n-                let span = self.token.span;\n                 self.bump();\n-                Ok(Ident::new(name, span))\n+                Ok(Ident::new(name, self.normalized_prev_token.span))\n             }\n             _ => self.parse_ident(),\n         }"}, {"sha": "9073e131f700dda25281d4bcbed8b61e9c317152", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -89,7 +89,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_stmt_item(&mut self, attrs: Vec<Attribute>) -> PResult<'a, Option<ast::Item>> {\n         let old = mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n-        let item = self.parse_item_common(attrs.clone(), false, true, |_| true)?;\n+        let item = self.parse_item_common(attrs, false, true, |_| true)?;\n         self.directory.ownership = old;\n         Ok(item)\n     }"}, {"sha": "7b2fdebcfb91051f58995418a0817c366fe6a302", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -5,7 +5,7 @@ use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_errors::{pluralize, struct_span_err, Applicability, PResult};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym};\n-use syntax::ast::{self, BareFnTy, FnRetTy, GenericParam, Ident, Lifetime, MutTy, Ty, TyKind};\n+use syntax::ast::{self, BareFnTy, FnRetTy, GenericParam, Lifetime, MutTy, Ty, TyKind};\n use syntax::ast::{\n     GenericBound, GenericBounds, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax,\n };\n@@ -323,7 +323,7 @@ impl<'a> Parser<'a> {\n     /// Is a `dyn B0 + ... + Bn` type allowed here?\n     fn is_explicit_dyn_type(&mut self) -> bool {\n         self.check_keyword(kw::Dyn)\n-            && (self.token.span.rust_2018()\n+            && (self.normalized_token.span.rust_2018()\n                 || self.look_ahead(1, |t| {\n                     t.can_begin_bound() && !can_continue_type_after_non_fn_ident(t)\n                 }))\n@@ -604,9 +604,8 @@ impl<'a> Parser<'a> {\n     /// Parses a single lifetime `'a` or panics.\n     pub fn expect_lifetime(&mut self) -> Lifetime {\n         if let Some(ident) = self.token.lifetime() {\n-            let span = self.token.span;\n             self.bump();\n-            Lifetime { ident: Ident::new(ident.name, span), id: ast::DUMMY_NODE_ID }\n+            Lifetime { ident, id: ast::DUMMY_NODE_ID }\n         } else {\n             self.span_bug(self.token.span, \"not a lifetime\")\n         }"}, {"sha": "e2749c7bd7c880b0d3f0e6844e64a98e0b6ffa9a", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -553,7 +553,7 @@ impl DeadVisitor<'tcx> {\n         node_type: &str,\n         participle: &str,\n     ) {\n-        if !name.as_str().starts_with(\"_\") {\n+        if !name.as_str().starts_with('_') {\n             self.tcx.struct_span_lint_hir(lint::builtin::DEAD_CODE, id, span, |lint| {\n                 lint.build(&format!(\"{} is never {}: `{}`\", node_type, participle, name)).emit()\n             });"}, {"sha": "1511742446b6ea4ddb05958ffd99f698bd3ed3ab", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -64,9 +64,9 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n     for (name, &item) in WEAK_ITEMS_REFS.iter() {\n         if missing.contains(&item) && !whitelisted(tcx, item) && items.require(item).is_err() {\n             if item == lang_items::PanicImplLangItem {\n-                tcx.sess.err(&format!(\"`#[panic_handler]` function required, but not found\"));\n+                tcx.sess.err(\"`#[panic_handler]` function required, but not found\");\n             } else if item == lang_items::OomLangItem {\n-                tcx.sess.err(&format!(\"`#[alloc_error_handler]` function required, but not found\"));\n+                tcx.sess.err(\"`#[alloc_error_handler]` function required, but not found\");\n             } else {\n                 tcx.sess.err(&format!(\"language item required, but not found: `{}`\", name));\n             }"}, {"sha": "2a9e335e924a2ac9ed350f2f45174e7d6d16a236", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1103,7 +1103,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     // Macro uses will remove items from this set, and the remaining\n     // items will be reported as `unused_macros`.\n     fn insert_unused_macro(&mut self, ident: Ident, node_id: NodeId, span: Span) {\n-        if !ident.as_str().starts_with(\"_\") {\n+        if !ident.as_str().starts_with('_') {\n             self.r.unused_macros.insert(node_id, span);\n         }\n     }"}, {"sha": "b0206bb1a7a1616fee4d66ed9851481a52e93479", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -143,7 +143,7 @@ impl<'a> Resolver<'a> {\n                 if has_generic_params == HasGenericParams::Yes {\n                     // Try to retrieve the span of the function signature and generate a new\n                     // message with a local type or const parameter.\n-                    let sugg_msg = &format!(\"try using a local generic parameter instead\");\n+                    let sugg_msg = \"try using a local generic parameter instead\";\n                     if let Some((sugg_span, snippet)) = sm.generate_local_type_param_snippet(span) {\n                         // Suggest the modification to the user\n                         err.span_suggestion(\n@@ -158,7 +158,7 @@ impl<'a> Resolver<'a> {\n                             format!(\"try adding a local generic parameter in this method instead\"),\n                         );\n                     } else {\n-                        err.help(&format!(\"try using a local generic parameter instead\"));\n+                        err.help(\"try using a local generic parameter instead\");\n                     }\n                 }\n "}, {"sha": "48a2f829d19987e78b755b73f7cf374ec8e3d0e5", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -456,8 +456,9 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n     }\n     fn visit_fn(&mut self, fn_kind: FnKind<'ast>, sp: Span, _: NodeId) {\n         let rib_kind = match fn_kind {\n-            FnKind::Fn(FnCtxt::Foreign, ..) => return visit::walk_fn(self, fn_kind, sp),\n-            FnKind::Fn(FnCtxt::Free, ..) => FnItemRibKind,\n+            // Bail if there's no body.\n+            FnKind::Fn(.., None) => return visit::walk_fn(self, fn_kind, sp),\n+            FnKind::Fn(FnCtxt::Free, ..) | FnKind::Fn(FnCtxt::Foreign, ..) => FnItemRibKind,\n             FnKind::Fn(FnCtxt::Assoc(_), ..) | FnKind::Closure(..) => NormalRibKind,\n         };\n         let previous_value = replace(&mut self.diagnostic_metadata.current_function, Some(sp));"}, {"sha": "e2aa853e78ced6afa11f10428236b5c71752d69a", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -968,18 +968,14 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         for missing in &self.missing_named_lifetime_spots {\n             match missing {\n                 MissingLifetimeSpot::Generics(generics) => {\n-                    let (span, sugg) = if let Some(param) = generics\n-                        .params\n-                        .iter()\n-                        .filter(|p| match p.kind {\n+                    let (span, sugg) = if let Some(param) =\n+                        generics.params.iter().find(|p| match p.kind {\n                             hir::GenericParamKind::Type {\n                                 synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n                                 ..\n                             } => false,\n                             _ => true,\n-                        })\n-                        .next()\n-                    {\n+                        }) {\n                         (param.span.shrink_to_lo(), format!(\"{}, \", lifetime_ref))\n                     } else {\n                         (generics.span, format!(\"<{}>\", lifetime_ref))\n@@ -1053,25 +1049,24 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                     Applicability::MaybeIncorrect,\n                 );\n             };\n-            let suggest_new =\n-                |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n-                    err.span_label(span, \"expected named lifetime parameter\");\n+            let suggest_new = |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n+                err.span_label(span, \"expected named lifetime parameter\");\n \n-                    for missing in self.missing_named_lifetime_spots.iter().rev() {\n-                        let mut introduce_suggestion = vec![];\n-                        let msg;\n-                        let should_break;\n-                        introduce_suggestion.push(match missing {\n+                for missing in self.missing_named_lifetime_spots.iter().rev() {\n+                    let mut introduce_suggestion = vec![];\n+                    let msg;\n+                    let should_break;\n+                    introduce_suggestion.push(match missing {\n                         MissingLifetimeSpot::Generics(generics) => {\n                             msg = \"consider introducing a named lifetime parameter\".to_string();\n                             should_break = true;\n-                            if let Some(param) = generics.params.iter().filter(|p| match p.kind {\n+                            if let Some(param) = generics.params.iter().find(|p| match p.kind {\n                                 hir::GenericParamKind::Type {\n                                     synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n                                     ..\n                                 } => false,\n                                 _ => true,\n-                            }).next() {\n+                            }) {\n                                 (param.span.shrink_to_lo(), \"'a, \".to_string())\n                             } else {\n                                 (generics.span, \"<'a>\".to_string())\n@@ -1090,30 +1085,29 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                             (*span, span_type.suggestion(\"'a\"))\n                         }\n                     });\n-                        for param in params {\n-                            if let Ok(snippet) =\n-                                self.tcx.sess.source_map().span_to_snippet(param.span)\n-                            {\n-                                if snippet.starts_with(\"&\") && !snippet.starts_with(\"&'\") {\n-                                    introduce_suggestion\n-                                        .push((param.span, format!(\"&'a {}\", &snippet[1..])));\n-                                } else if snippet.starts_with(\"&'_ \") {\n-                                    introduce_suggestion\n-                                        .push((param.span, format!(\"&'a {}\", &snippet[4..])));\n-                                }\n+                    for param in params {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span)\n+                        {\n+                            if snippet.starts_with(\"&\") && !snippet.starts_with(\"&'\") {\n+                                introduce_suggestion\n+                                    .push((param.span, format!(\"&'a {}\", &snippet[1..])));\n+                            } else if snippet.starts_with(\"&'_ \") {\n+                                introduce_suggestion\n+                                    .push((param.span, format!(\"&'a {}\", &snippet[4..])));\n                             }\n                         }\n-                        introduce_suggestion.push((span, sugg.to_string()));\n-                        err.multipart_suggestion(\n-                            &msg,\n-                            introduce_suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        if should_break {\n-                            break;\n-                        }\n                     }\n-                };\n+                    introduce_suggestion.push((span, sugg.to_string()));\n+                    err.multipart_suggestion(\n+                        &msg,\n+                        introduce_suggestion,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    if should_break {\n+                        break;\n+                    }\n+                }\n+            };\n \n             match (\n                 lifetime_names.len(),"}, {"sha": "540877d22c2d4df5b44a7b37e2c42a41d77c1005", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -2663,7 +2663,7 @@ impl<'a> Resolver<'a> {\n                                 \"{} as {}{}\",\n                                 &snippet[..pos],\n                                 suggested_name,\n-                                if snippet.ends_with(\";\") { \";\" } else { \"\" }\n+                                if snippet.ends_with(';') { \";\" } else { \"\" }\n                             ))\n                         }\n                     }"}, {"sha": "8392d2b50d22e30d124d5b8e9df93522383e2410", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1500,10 +1500,8 @@ fn parse_libs(\n             {\n                 early_error(\n                     error_format,\n-                    &format!(\n-                        \"the library kind 'static-nobundle' is only \\\n-                         accepted on the nightly compiler\"\n-                    ),\n+                    \"the library kind 'static-nobundle' is only \\\n+                     accepted on the nightly compiler\",\n                 );\n             }\n             let mut name_parts = name.splitn(2, ':');"}, {"sha": "edd0ba46f7565e6f5d846b24f4d8cbead701fe8e", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -101,7 +101,7 @@ impl TargetDataLayout {\n             match &*spec_parts {\n                 [\"e\"] => dl.endian = Endian::Little,\n                 [\"E\"] => dl.endian = Endian::Big,\n-                [p] if p.starts_with(\"P\") => {\n+                [p] if p.starts_with('P') => {\n                     dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n                 }\n                 [\"a\", ref a @ ..] => dl.aggregate_align = align(a, \"a\")?,\n@@ -111,7 +111,7 @@ impl TargetDataLayout {\n                     dl.pointer_size = size(s, p)?;\n                     dl.pointer_align = align(a, p)?;\n                 }\n-                [s, ref a @ ..] if s.starts_with(\"i\") => {\n+                [s, ref a @ ..] if s.starts_with('i') => {\n                     let bits = match s[1..].parse::<u64>() {\n                         Ok(bits) => bits,\n                         Err(_) => {\n@@ -135,7 +135,7 @@ impl TargetDataLayout {\n                         dl.i128_align = a;\n                     }\n                 }\n-                [s, ref a @ ..] if s.starts_with(\"v\") => {\n+                [s, ref a @ ..] if s.starts_with('v') => {\n                     let v_size = size(&s[1..], \"v\")?;\n                     let a = align(a, s)?;\n                     if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {"}, {"sha": "61986dd7b179b830e41006195063b23495ea5061", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -982,10 +982,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 ),\n             );\n         }\n-        err.note(&format!(\n+        err.note(\n             \"because of the default `Self` reference, type parameters must be \\\n-                            specified on object types\"\n-        ));\n+                  specified on object types\",\n+        );\n         err.emit();\n     }\n \n@@ -1876,7 +1876,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             {\n                 let types: Vec<_> =\n                     assoc_items.iter().map(|item| format!(\"{} = Type\", item.ident)).collect();\n-                let code = if snippet.ends_with(\">\") {\n+                let code = if snippet.ends_with('>') {\n                     // The user wrote `Trait<'a>` or similar and we don't have a type we can\n                     // suggest, but at least we can clue them to the correct syntax\n                     // `Trait<'a, Item = Type>` while accounting for the `<'a>` in the"}, {"sha": "761e2fa8eac88326c3f1c1ba76406a67fb295382", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -43,7 +43,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx>> {\n-        let cause = &self.misc(sp);\n+        self.demand_suptype_with_origin(&self.misc(sp), expected, actual)\n+    }\n+\n+    pub fn demand_suptype_with_origin(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+    ) -> Option<DiagnosticBuilder<'tcx>> {\n         match self.at(cause, self.param_env).sup(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n@@ -404,7 +412,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 {\n                     if let hir::ExprKind::Lit(_) = expr.kind {\n                         if let Ok(src) = sm.span_to_snippet(sp) {\n-                            if src.starts_with(\"\\\"\") {\n+                            if src.starts_with('\"') {\n                                 return Some((\n                                     sp,\n                                     \"consider adding a leading `b`\",\n@@ -701,7 +709,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 {\n                     // Remove fractional part from literal, for example `42.0f32` into `42`\n                     let src = src.trim_end_matches(&checked_ty.to_string());\n-                    src.split(\".\").next().unwrap()\n+                    src.split('.').next().unwrap()\n                 } else {\n                     src.trim_end_matches(&checked_ty.to_string())\n                 },"}, {"sha": "ce2af9b96e57cf0faec164a3c30a9ed0b29e0ae5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -4996,7 +4996,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let sugg = if receiver.ends_with(\".clone()\")\n                                 && method_call_list.contains(&method_call.as_str())\n                             {\n-                                let max_len = receiver.rfind(\".\").unwrap();\n+                                let max_len = receiver.rfind('.').unwrap();\n                                 format!(\"{}{}\", &receiver[..max_len], method_call)\n                             } else {\n                                 if expr.precedence().order() < ExprPrecedence::MethodCall.order() {\n@@ -5447,9 +5447,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .unwrap_or(false);\n \n         let (res, self_ctor_substs) = if let Res::SelfCtor(impl_def_id) = res {\n-            let ty = self.impl_self_ty(span, impl_def_id).ty;\n-            let adt_def = ty.ty_adt_def();\n-\n+            let ty = self.normalize_ty(span, tcx.at(span).type_of(impl_def_id));\n             match ty.kind {\n                 ty::Adt(adt_def, substs) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n@@ -5464,7 +5462,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         span,\n                         \"the `Self` constructor can only be used with tuple or unit structs\",\n                     );\n-                    if let Some(adt_def) = adt_def {\n+                    if let Some(adt_def) = ty.ty_adt_def() {\n                         match adt_def.adt_kind() {\n                             AdtKind::Enum => {\n                                 err.help(\"did you mean to use one of the enum's variants?\");"}, {"sha": "2c5dcdde5e8a3657d85ba9c9b5b51b44edddbc42", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -597,12 +597,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Ok(lstring) => {\n                             err.span_suggestion(\n                                 lhs_expr.span,\n-                                if lstring.starts_with(\"&\") {\n+                                if lstring.starts_with('&') {\n                                     remove_borrow_msg\n                                 } else {\n                                     msg\n                                 },\n-                                if lstring.starts_with(\"&\") {\n+                                if lstring.starts_with('&') {\n                                     // let a = String::new();\n                                     // let _ = &a + \"bar\";\n                                     format!(\"{}\", &lstring[1..])\n@@ -630,7 +630,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     is_assign,\n                 ) {\n                     (Ok(l), Ok(r), false) => {\n-                        let to_string = if l.starts_with(\"&\") {\n+                        let to_string = if l.starts_with('&') {\n                             // let a = String::new(); let b = String::new();\n                             // let _ = &a + b;\n                             format!(\"{}\", &l[1..])"}, {"sha": "1df7c64f2c6f0e233475d100aff5a003600b5ab5", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -9,9 +9,9 @@ use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::{HirId, Pat, PatKind};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::traits::Pattern;\n+use rustc_infer::traits::{ObligationCause, Pattern};\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::Span;\n+use rustc_span::source_map::{Span, Spanned};\n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -66,16 +66,19 @@ struct TopInfo<'tcx> {\n }\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n+    fn pattern_cause(&self, ti: TopInfo<'tcx>, cause_span: Span) -> ObligationCause<'tcx> {\n+        let code = Pattern { span: ti.span, root_ty: ti.expected, origin_expr: ti.origin_expr };\n+        self.cause(cause_span, code)\n+    }\n+\n     fn demand_eqtype_pat_diag(\n         &self,\n         cause_span: Span,\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx>> {\n-        let code = Pattern { span: ti.span, root_ty: ti.expected, origin_expr: ti.origin_expr };\n-        let cause = self.cause(cause_span, code);\n-        self.demand_eqtype_with_origin(&cause, expected, actual)\n+        self.demand_eqtype_with_origin(&self.pattern_cause(ti, cause_span), expected, actual)\n     }\n \n     fn demand_eqtype_pat(\n@@ -152,7 +155,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_tuple_struct(pat, qpath, subpats, ddpos, expected, def_bm, ti)\n             }\n             PatKind::Path(ref qpath) => {\n-                self.check_pat_path(pat, path_res.unwrap(), qpath, expected)\n+                self.check_pat_path(pat, path_res.unwrap(), qpath, expected, ti)\n             }\n             PatKind::Struct(ref qpath, fields, etc) => {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, ti)\n@@ -361,16 +364,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Byte string patterns behave the same way as array patterns\n         // They can denote both statically and dynamically-sized byte arrays.\n         let mut pat_ty = ty;\n-        if let hir::ExprKind::Lit(ref lt) = lt.kind {\n-            if let ast::LitKind::ByteStr(_) = lt.node {\n-                let expected_ty = self.structurally_resolved_type(span, expected);\n-                if let ty::Ref(_, r_ty, _) = expected_ty.kind {\n-                    if let ty::Slice(_) = r_ty.kind {\n-                        let tcx = self.tcx;\n-                        pat_ty =\n-                            tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_slice(tcx.types.u8));\n-                    }\n-                }\n+        if let hir::ExprKind::Lit(Spanned { node: ast::LitKind::ByteStr(_), .. }) = lt.kind {\n+            let expected = self.structurally_resolved_type(span, expected);\n+            if let ty::Ref(_, ty::TyS { kind: ty::Slice(_), .. }, _) = expected.kind {\n+                let tcx = self.tcx;\n+                pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_slice(tcx.types.u8));\n             }\n         }\n \n@@ -384,7 +382,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //     &'static str <: expected\n         //\n         // then that's equivalent to there existing a LUB.\n-        if let Some(mut err) = self.demand_suptype_diag(span, expected, pat_ty) {\n+        let cause = self.pattern_cause(ti, span);\n+        if let Some(mut err) = self.demand_suptype_with_origin(&cause, expected, pat_ty) {\n             err.emit_unless(\n                 ti.span\n                     .filter(|&s| {\n@@ -543,8 +542,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // If there are multiple arms, make sure they all agree on\n         // what the type of the binding `x` ought to be.\n         if var_id != pat.hir_id {\n-            let vt = self.local_ty(pat.span, var_id).decl_ty;\n-            self.demand_eqtype_pat(pat.span, vt, local_ty, ti);\n+            self.check_binding_alt_eq_ty(pat.span, var_id, local_ty, ti);\n         }\n \n         if let Some(p) = sub {\n@@ -554,6 +552,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         local_ty\n     }\n \n+    fn check_binding_alt_eq_ty(&self, span: Span, var_id: HirId, ty: Ty<'tcx>, ti: TopInfo<'tcx>) {\n+        let var_ty = self.local_ty(span, var_id).decl_ty;\n+        if let Some(mut err) = self.demand_eqtype_pat_diag(span, var_ty, ty, ti) {\n+            let hir = self.tcx.hir();\n+            let var_ty = self.resolve_vars_with_obligations(var_ty);\n+            let msg = format!(\"first introduced with type `{}` here\", var_ty);\n+            err.span_label(hir.span(var_id), msg);\n+            let in_arm = hir.parent_iter(var_id).any(|(_, n)| matches!(n, hir::Node::Arm(..)));\n+            let pre = if in_arm { \"in the same arm, \" } else { \"\" };\n+            err.note(&format!(\"{}a binding must have the same type in all alternatives\", pre));\n+            err.emit();\n+        }\n+    }\n+\n     fn borrow_pat_suggestion(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -659,6 +671,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]),\n         qpath: &hir::QPath<'_>,\n         expected: Ty<'tcx>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n@@ -684,7 +697,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Type-check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id).0;\n-        self.demand_suptype(pat.span, expected, pat_ty);\n+        if let Some(mut err) =\n+            self.demand_suptype_with_origin(&self.pattern_cause(ti, pat.span), expected, pat_ty)\n+        {\n+            err.emit();\n+        }\n         pat_ty\n     }\n \n@@ -901,7 +918,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         });\n         let element_tys = tcx.mk_substs(element_tys_iter);\n         let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n-        if let Some(mut err) = self.demand_eqtype_diag(span, expected, pat_ty) {\n+        if let Some(mut err) = self.demand_eqtype_pat_diag(span, expected, pat_ty, ti) {\n             err.emit();\n             // Walk subpatterns with an expected type of `err` in this case to silence\n             // further errors being emitted when using the bindings. #50333\n@@ -1205,7 +1222,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     });\n                     let rptr_ty = self.new_ref_ty(pat.span, mutbl, inner_ty);\n                     debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, rptr_ty);\n-                    let err = self.demand_eqtype_diag(pat.span, expected, rptr_ty);\n+                    let err = self.demand_eqtype_pat_diag(pat.span, expected, rptr_ty, ti);\n \n                     // Look for a case like `fn foo(&foo: u32)` and suggest\n                     // `fn foo(foo: &u32)`"}, {"sha": "49fa45836e134317b01862dbc155b87b023c95c2", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -283,10 +283,10 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     \"no base type found for inherent implementation\"\n                 )\n                 .span_label(ty.span, \"impl requires a base type\")\n-                .note(&format!(\n+                .note(\n                     \"either implement a trait on it or create a newtype \\\n-                                    to wrap it instead\"\n-                ))\n+                       to wrap it instead\",\n+                )\n                 .emit();\n                 return;\n             }"}, {"sha": "427bcab632d35592e21dc05eeb9bee0a8d21edfb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1301,10 +1301,10 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                             param.hir_id,\n                             param.span,\n                             |lint| {\n-                                lint.build(&format!(\n+                                lint.build(\n                                     \"defaults for type parameters are only allowed in \\\n-                                        `struct`, `enum`, `type`, or `trait` definitions.\"\n-                                ))\n+                                            `struct`, `enum`, `type`, or `trait` definitions.\",\n+                                )\n                                 .emit();\n                             },\n                         );\n@@ -2224,7 +2224,7 @@ fn from_target_feature(\n                         item.span(),\n                         format!(\"`{}` is not valid for this target\", feature),\n                     );\n-                    if feature.starts_with(\"+\") {\n+                    if feature.starts_with('+') {\n                         let valid = whitelist.contains_key(&feature[1..]);\n                         if valid {\n                             err.help(\"consider removing the leading `+` in the feature name\");\n@@ -2355,7 +2355,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n         } else if attr.check_name(sym::export_name) {\n             if let Some(s) = attr.value_str() {\n-                if s.as_str().contains(\"\\0\") {\n+                if s.as_str().contains('\\0') {\n                     // `#[export_name = ...]` will be converted to a null-terminated string,\n                     // so it may not contain any null characters.\n                     struct_span_err!("}, {"sha": "ff6431640d33e0f8e9acd6a779ea82d87d03dd83", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -707,7 +707,7 @@ impl LangString {\n                 x if x.starts_with(\"edition\") => {\n                     data.edition = x[7..].parse::<Edition>().ok();\n                 }\n-                x if allow_error_code_check && x.starts_with(\"E\") && x.len() == 5 => {\n+                x if allow_error_code_check && x.starts_with('E') && x.len() == 5 => {\n                     if x[1..].parse::<u32>().is_ok() {\n                         data.error_codes.push(x.to_owned());\n                         seen_rust_tags = !seen_other_tags || seen_rust_tags;"}, {"sha": "59677b28245c2be750667f2bbdfa4db51007eb58", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -86,7 +86,7 @@ pub type NameDoc = (String, Option<String>);\n \n crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n     crate::html::format::display_fn(move |f| {\n-        if !v.ends_with(\"/\") && !v.is_empty() { write!(f, \"{}/\", v) } else { write!(f, \"{}\", v) }\n+        if !v.ends_with('/') && !v.is_empty() { write!(f, \"{}/\", v) } else { write!(f, \"{}\", v) }\n     })\n }\n "}, {"sha": "e9ebccb7ec09e0849d5d730b90fe739aa5710669", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -534,7 +534,7 @@ fn extern_location(\n \n     if let Some(url) = extern_url {\n         let mut url = url.to_string();\n-        if !url.ends_with(\"/\") {\n+        if !url.ends_with('/') {\n             url.push('/');\n         }\n         return Remote(url);\n@@ -548,7 +548,7 @@ fn extern_location(\n         .filter_map(|a| a.value_str())\n         .map(|url| {\n             let mut url = url.to_string();\n-            if !url.ends_with(\"/\") {\n+            if !url.ends_with('/') {\n                 url.push('/')\n             }\n             Remote(url)"}, {"sha": "a41fdd2ff17af6cee98ee19915fee4073e38bfcb", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -19,7 +19,7 @@ fn extract_leading_metadata(s: &str) -> (Vec<&str>, &str) {\n     let mut count = 0;\n \n     for line in s.lines() {\n-        if line.starts_with(\"# \") || line.starts_with(\"%\") {\n+        if line.starts_with(\"# \") || line.starts_with('%') {\n             // trim the whitespace after the symbol\n             metadata.push(line[1..].trim_start());\n             count += line.len() + 1;"}, {"sha": "4d51b63b740fd8ee9e0ed5ca94c6e6cbf2ab7342", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -398,7 +398,7 @@ pub fn make_test(\n             use rustc_span::source_map::FilePathMapping;\n \n             let filename = FileName::anon_source_code(s);\n-            let source = crates + &everything_else;\n+            let source = crates + everything_else;\n \n             // Any errors in parsing should also appear when the doctest is compiled for real, so just\n             // send all the errors that libsyntax emits directly into a `Sink` instead of stderr."}, {"sha": "a50dd9575de32f1fdf17bcbd14c7cdecad3221d3", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -2396,9 +2396,9 @@ impl<B: BufRead> Iterator for Lines<B> {\n         match self.buf.read_line(&mut buf) {\n             Ok(0) => None,\n             Ok(_n) => {\n-                if buf.ends_with(\"\\n\") {\n+                if buf.ends_with('\\n') {\n                     buf.pop();\n-                    if buf.ends_with(\"\\r\") {\n+                    if buf.ends_with('\\r') {\n                         buf.pop();\n                     }\n                 }"}, {"sha": "a8a2c9b2fb3187dccfd197c43c506dd8354a9d50", "filename": "src/libsyntax/token.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibsyntax%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibsyntax%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftoken.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -147,36 +147,30 @@ impl Lit {\n \n pub fn ident_can_begin_expr(name: ast::Name, span: Span, is_raw: bool) -> bool {\n     let ident_token = Token::new(Ident(name, is_raw), span);\n-    token_can_begin_expr(&ident_token)\n-}\n \n-pub fn token_can_begin_expr(ident_token: &Token) -> bool {\n     !ident_token.is_reserved_ident()\n         || ident_token.is_path_segment_keyword()\n-        || match ident_token.kind {\n-            TokenKind::Ident(ident, _) => [\n-                kw::Async,\n-                kw::Do,\n-                kw::Box,\n-                kw::Break,\n-                kw::Continue,\n-                kw::False,\n-                kw::For,\n-                kw::If,\n-                kw::Let,\n-                kw::Loop,\n-                kw::Match,\n-                kw::Move,\n-                kw::Return,\n-                kw::True,\n-                kw::Unsafe,\n-                kw::While,\n-                kw::Yield,\n-                kw::Static,\n-            ]\n-            .contains(&ident),\n-            _ => false,\n-        }\n+        || [\n+            kw::Async,\n+            kw::Do,\n+            kw::Box,\n+            kw::Break,\n+            kw::Continue,\n+            kw::False,\n+            kw::For,\n+            kw::If,\n+            kw::Let,\n+            kw::Loop,\n+            kw::Match,\n+            kw::Move,\n+            kw::Return,\n+            kw::True,\n+            kw::Unsafe,\n+            kw::While,\n+            kw::Yield,\n+            kw::Static,\n+        ]\n+        .contains(&name)\n }\n \n fn ident_can_begin_type(name: ast::Name, span: Span, is_raw: bool) -> bool {\n@@ -369,8 +363,8 @@ impl Token {\n             Lifetime(..)                      | // labeled loop\n             Pound                             => true, // expression attributes\n             Interpolated(ref nt) => match **nt {\n+                NtIdent(ident, is_raw) => ident_can_begin_expr(ident.name, ident.span, is_raw),\n                 NtLiteral(..) |\n-                NtIdent(..)   |\n                 NtExpr(..)    |\n                 NtBlock(..)   |\n                 NtPath(..)    |\n@@ -397,7 +391,8 @@ impl Token {\n             Lt | BinOp(Shl)             | // associated path\n             ModSep                      => true, // global path\n             Interpolated(ref nt) => match **nt {\n-                NtIdent(..) | NtTy(..) | NtPath(..) | NtLifetime(..) => true,\n+                NtIdent(ident, is_raw) => ident_can_begin_type(ident.name, ident.span, is_raw),\n+                NtTy(..) | NtPath(..) | NtLifetime(..) => true,\n                 _ => false,\n             },\n             _ => false,\n@@ -442,6 +437,7 @@ impl Token {\n             Literal(..) | BinOp(Minus) => true,\n             Ident(name, false) if name.is_bool_lit() => true,\n             Interpolated(ref nt) => match &**nt {\n+                NtIdent(ident, false) if ident.name.is_bool_lit() => true,\n                 NtExpr(e) | NtLiteral(e) => matches!(e.kind, ast::ExprKind::Lit(_)),\n                 _ => false,\n             },"}, {"sha": "ecf17efc4e0d1ba605215719ca729fb72e1d45cc", "filename": "src/libsyntax/util/literal.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibsyntax%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Flibsyntax%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fliteral.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -197,10 +197,17 @@ impl Lit {\n             }\n             token::Literal(lit) => lit,\n             token::Interpolated(ref nt) => {\n-                if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n-                    if let ast::ExprKind::Lit(lit) = &expr.kind {\n-                        return Ok(lit.clone());\n+                match &**nt {\n+                    token::NtIdent(ident, false) if ident.name.is_bool_lit() => {\n+                        let lit = token::Lit::new(token::Bool, ident.name, None);\n+                        return Lit::from_lit_token(lit, ident.span);\n                     }\n+                    token::NtExpr(expr) | token::NtLiteral(expr) => {\n+                        if let ast::ExprKind::Lit(lit) = &expr.kind {\n+                            return Ok(lit.clone());\n+                        }\n+                    }\n+                    _ => {}\n                 }\n                 return Err(LitError::NotLiteral);\n             }"}, {"sha": "58a90b2fca2ca9b4b94044c0c56d32b7d1e2db72", "filename": "src/test/ui/borrowck/move-error-snippets.stderr", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,14 +1,16 @@\n error[E0507]: cannot move out of static item `D`\n-  --> $DIR/move-error-snippets.rs:16:18\n+  --> $DIR/move-error-snippets-ext.rs:5:17\n    |\n-LL | | #[macro_use]\n-   | |__________________^ move occurs because `D` has type `A`, which does not implement the `Copy` trait\n-...\n-LL |               aaa!(D);\n-   |  __________________^\n-...\n-LL |   sss!();\n-   |   ------- in this macro invocation\n+LL |         let a = $c;\n+   |                 ^^\n+   |                 |\n+   |                 move occurs because `D` has type `A`, which does not implement the `Copy` trait\n+   |                 help: consider borrowing here: `&$c`\n+   | \n+  ::: $DIR/move-error-snippets.rs:21:1\n+   |\n+LL | sss!();\n+   | ------- in this macro invocation\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "1382cf643a17331cd7c18d2a7f8f619da16b3a2c", "filename": "src/test/ui/destructure-trait-ref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -20,7 +20,7 @@ error[E0308]: mismatched types\n   --> $DIR/destructure-trait-ref.rs:32:10\n    |\n LL |     let &&x = &1isize as &dyn T;\n-   |          ^^\n+   |          ^^   ----------------- this expression has type `&dyn T`\n    |          |\n    |          expected trait object `dyn T`, found reference\n    |          help: you can probably remove the explicit borrow: `x`\n@@ -32,7 +32,7 @@ error[E0308]: mismatched types\n   --> $DIR/destructure-trait-ref.rs:36:11\n    |\n LL |     let &&&x = &(&1isize as &dyn T);\n-   |           ^^\n+   |           ^^   -------------------- this expression has type `&&dyn T`\n    |           |\n    |           expected trait object `dyn T`, found reference\n    |           help: you can probably remove the explicit borrow: `x`"}, {"sha": "376c1a9cd66277f94a5936af6559aac8bc0a305e", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,7 +1,7 @@\n // Test that macro-expanded non-inline modules behave correctly\n \n macro_rules! mod_decl {\n-    ($i:ident) => { mod $i; }\n+    ($i:ident) => { mod $i; } //~ ERROR Cannot declare a non-inline module inside a block\n }\n \n mod macro_expanded_mod_helper {\n@@ -10,5 +10,4 @@ mod macro_expanded_mod_helper {\n \n fn main() {\n     mod_decl!(foo);\n-    //~^ ERROR Cannot declare a non-inline module inside a block\n }"}, {"sha": "c7780c869d635c55c9800240145e52c2502b2cf9", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,8 +1,13 @@\n error: Cannot declare a non-inline module inside a block unless it has a path attribute\n-  --> $DIR/macro-expanded-mod.rs:12:15\n+  --> $DIR/macro-expanded-mod.rs:4:25\n    |\n+LL |     ($i:ident) => { mod $i; }\n+   |                         ^^\n+...\n LL |     mod_decl!(foo);\n-   |               ^^^\n+   |     --------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "e0537ff6faaf82e9463c18129d346d87aacdeaf4", "filename": "src/test/ui/elide-errors-on-mismatched-tuple.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Felide-errors-on-mismatched-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Felide-errors-on-mismatched-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Felide-errors-on-mismatched-tuple.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/elide-errors-on-mismatched-tuple.rs:14:9\n    |\n LL |     let (a, b, c) = (A::new(), A::new()); // This tuple is 2 elements, should be three\n-   |         ^^^^^^^^^ expected a tuple with 2 elements, found one with 3 elements\n+   |         ^^^^^^^^^   -------------------- this expression has type `(A, A)`\n+   |         |\n+   |         expected a tuple with 2 elements, found one with 3 elements\n    |\n    = note: expected tuple `(A, A)`\n               found tuple `(_, _, _)`"}, {"sha": "fd8846bb13c88de3193341b760e7645e9f12a021", "filename": "src/test/ui/hygiene/fields-definition.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,10 +1,10 @@\n error[E0124]: field `a` is already declared\n-  --> $DIR/fields-definition.rs:14:17\n+  --> $DIR/fields-definition.rs:14:13\n    |\n LL |             a: u8,\n    |             ----- `a` first declared here\n LL |             $a: u8,\n-   |                 ^^ field already declared\n+   |             ^^^^^^ field already declared\n ...\n LL | legacy!(a);\n    | ----------- in this macro invocation"}, {"sha": "45fede4410630ebdbd5b89d9b6519eb413166064", "filename": "src/test/ui/issues/issue-12552.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -12,6 +12,9 @@ LL |     Some(k) => match k {\n error[E0308]: mismatched types\n   --> $DIR/issue-12552.rs:9:5\n    |\n+LL |   match t {\n+   |         - this expression has type `std::result::Result<_, {integer}>`\n+...\n LL |     None => ()\n    |     ^^^^ expected enum `std::result::Result`, found enum `std::option::Option`\n    |"}, {"sha": "f0285730c5a26cb43d0cb50e19788c2353e496da", "filename": "src/test/ui/issues/issue-37026.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-37026.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-37026.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37026.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-37026.rs:6:9\n    |\n LL |     let empty_struct::XEmpty2 = ();\n-   |         ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `empty_struct::XEmpty2`\n+   |         ^^^^^^^^^^^^^^^^^^^^^   -- this expression has type `()`\n+   |         |\n+   |         expected `()`, found struct `empty_struct::XEmpty2`\n \n error[E0308]: mismatched types\n   --> $DIR/issue-37026.rs:7:9"}, {"sha": "1964d739989ebafa57eb8094b8d341813a005eb1", "filename": "src/test/ui/issues/issue-39848.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-39848.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-39848.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39848.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,10 +1,9 @@\n macro_rules! get_opt {\n     ($tgt:expr, $field:ident) => {\n-        if $tgt.has_$field() {}\n+        if $tgt.has_$field() {} //~ ERROR expected `{`, found `foo`\n     }\n }\n \n fn main() {\n     get_opt!(bar, foo);\n-    //~^ ERROR expected `{`, found `foo`\n }"}, {"sha": "0250c6b1fdd0f16aa040e8b6972c5a752d46c03f", "filename": "src/test/ui/issues/issue-39848.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,13 +1,17 @@\n error: expected `{`, found `foo`\n-  --> $DIR/issue-39848.rs:8:19\n+  --> $DIR/issue-39848.rs:3:21\n    |\n LL |         if $tgt.has_$field() {}\n-   |         --                -- help: try placing this code inside a block: `{ () }`\n-   |         |\n+   |         --          ^^^^^^--\n+   |         |           |\n+   |         |           expected `{`\n+   |         |           help: try placing this code inside a block: `{ $field() }`\n    |         this `if` expression has a condition, but no block\n ...\n LL |     get_opt!(bar, foo);\n-   |                   ^^^ expected `{`\n+   |     ------------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "c81d6dcaf02173df0c0cfec556685c5da3b4cf7b", "filename": "src/test/ui/issues/issue-5100.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:8:9\n    |\n+LL |     match (true, false) {\n+   |           ------------- this expression has type `(bool, bool)`\n LL |         A::B => (),\n    |         ^^^^ expected tuple, found enum `A`\n    |\n@@ -10,6 +12,8 @@ LL |         A::B => (),\n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:17:9\n    |\n+LL |     match (true, false) {\n+   |           ------------- this expression has type `(bool, bool)`\n LL |         (true, false, false) => ()\n    |         ^^^^^^^^^^^^^^^^^^^^ expected a tuple with 2 elements, found one with 3 elements\n    |\n@@ -19,6 +23,8 @@ LL |         (true, false, false) => ()\n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:25:9\n    |\n+LL |     match (true, false) {\n+   |           ------------- this expression has type `(bool, bool)`\n LL |         (true, false, false) => ()\n    |         ^^^^^^^^^^^^^^^^^^^^ expected a tuple with 2 elements, found one with 3 elements\n    |\n@@ -39,6 +45,8 @@ LL |         box (true, false) => ()\n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:40:9\n    |\n+LL |     match (true, false) {\n+   |           ------------- this expression has type `(bool, bool)`\n LL |         &(true, false) => ()\n    |         ^^^^^^^^^^^^^^ expected tuple, found reference\n    |"}, {"sha": "85d60952ac82394e4063a4b5268cb6f3fc8c7c44", "filename": "src/test/ui/issues/issue-69306.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-69306.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-69306.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69306.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -0,0 +1,45 @@\n+fn main() {}\n+\n+struct S0<T>(T);\n+impl<T> S0<T> {\n+    const C: S0<u8> = Self(0);\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+\n+    fn foo() {\n+        Self(0);\n+        //~^ ERROR mismatched types\n+    }\n+}\n+\n+// Testing normalization.\n+trait Fun {\n+    type Out;\n+}\n+impl<T> Fun for S0<T> {\n+    type Out = Self;\n+}\n+trait Foo<T> {\n+    fn foo();\n+}\n+impl<T> Foo<T> for <S0<T> as Fun>::Out {\n+    fn foo() {\n+        Self(0); //~ ERROR mismatched types\n+    }\n+}\n+\n+struct S1<T, U>(T, U);\n+impl<T> S1<T, u8> {\n+    const C: S1<u8, u8> = Self(0, 1);\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+}\n+\n+struct S2<T>(T);\n+impl<T> S2<T> {\n+    fn map<U>(x: U) -> S2<U> {\n+        Self(x)\n+        //~^ ERROR mismatched types\n+        //~| ERROR mismatched types\n+    }\n+}"}, {"sha": "a2a42739ca8be49e1b5e699891e9291f06b45c50", "filename": "src/test/ui/issues/issue-69306.stderr", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-69306.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-69306.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69306.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -0,0 +1,115 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-69306.rs:5:28\n+   |\n+LL | impl<T> S0<T> {\n+   |      - this type parameter\n+LL |     const C: S0<u8> = Self(0);\n+   |                            ^ expected type parameter `T`, found integer\n+   |\n+   = note: expected type parameter `T`\n+                        found type `{integer}`\n+   = help: type parameters must be constrained to match other types\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-69306.rs:5:23\n+   |\n+LL | impl<T> S0<T> {\n+   |      - this type parameter\n+LL |     const C: S0<u8> = Self(0);\n+   |                       ^^^^^^^ expected `u8`, found type parameter `T`\n+   |\n+   = note: expected struct `S0<u8>`\n+              found struct `S0<T>`\n+   = help: type parameters must be constrained to match other types\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-69306.rs:10:14\n+   |\n+LL | impl<T> S0<T> {\n+   |      - this type parameter\n+...\n+LL |         Self(0);\n+   |              ^ expected type parameter `T`, found integer\n+   |\n+   = note: expected type parameter `T`\n+                        found type `{integer}`\n+   = help: type parameters must be constrained to match other types\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-69306.rs:27:14\n+   |\n+LL | impl<T> Foo<T> for <S0<T> as Fun>::Out {\n+   |      - this type parameter\n+LL |     fn foo() {\n+LL |         Self(0);\n+   |              ^ expected type parameter `T`, found integer\n+   |\n+   = note: expected type parameter `T`\n+                        found type `{integer}`\n+   = help: type parameters must be constrained to match other types\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-69306.rs:33:32\n+   |\n+LL | impl<T> S1<T, u8> {\n+   |      - this type parameter\n+LL |     const C: S1<u8, u8> = Self(0, 1);\n+   |                                ^ expected type parameter `T`, found integer\n+   |\n+   = note: expected type parameter `T`\n+                        found type `{integer}`\n+   = help: type parameters must be constrained to match other types\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-69306.rs:33:27\n+   |\n+LL | impl<T> S1<T, u8> {\n+   |      - this type parameter\n+LL |     const C: S1<u8, u8> = Self(0, 1);\n+   |                           ^^^^^^^^^^ expected `u8`, found type parameter `T`\n+   |\n+   = note: expected struct `S1<u8, _>`\n+              found struct `S1<T, _>`\n+   = help: type parameters must be constrained to match other types\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-69306.rs:41:14\n+   |\n+LL | impl<T> S2<T> {\n+   |      - expected type parameter\n+LL |     fn map<U>(x: U) -> S2<U> {\n+   |            - found type parameter\n+LL |         Self(x)\n+   |              ^ expected type parameter `T`, found type parameter `U`\n+   |\n+   = note: expected type parameter `T`\n+              found type parameter `U`\n+   = note: a type parameter was expected, but a different one was found; you might be missing a type parameter or trait bound\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-69306.rs:41:9\n+   |\n+LL | impl<T> S2<T> {\n+   |      - found type parameter\n+LL |     fn map<U>(x: U) -> S2<U> {\n+   |            -           ----- expected `S2<U>` because of return type\n+   |            |\n+   |            expected type parameter\n+LL |         Self(x)\n+   |         ^^^^^^^ expected type parameter `U`, found type parameter `T`\n+   |\n+   = note: expected struct `S2<U>`\n+              found struct `S2<T>`\n+   = note: a type parameter was expected, but a different one was found; you might be missing a type parameter or trait bound\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "4a29464aebd2b6ee7c7ffb0ff5c6b61a4fdcdbf2", "filename": "src/test/ui/issues/issue-7867.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-7867.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fissues%2Fissue-7867.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7867.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-7867.rs:7:9\n    |\n+LL |     match (true, false) {\n+   |           ------------- this expression has type `(bool, bool)`\n LL |         A::B => (),\n    |         ^^^^ expected tuple, found enum `A`\n    |"}, {"sha": "24692f7cf52e1e262920471fec86f9ddc9f37c8d", "filename": "src/test/ui/malformed/issue-69341-malformed-derive-inert.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -0,0 +1,10 @@\n+fn main() {}\n+\n+struct CLI {\n+    #[derive(parse())]\n+    //~^ ERROR traits in `#[derive(...)]` don't accept arguments\n+    //~| ERROR cannot find derive macro `parse` in this scope\n+    //~| ERROR cannot find derive macro `parse` in this scope\n+    path: (),\n+    //~^ ERROR `derive` may only be applied to structs, enums and unions\n+}"}, {"sha": "e8f96178d10bf94e8ed58b9cb5cd18f20ba607a5", "filename": "src/test/ui/malformed/issue-69341-malformed-derive-inert.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -0,0 +1,26 @@\n+error: traits in `#[derive(...)]` don't accept arguments\n+  --> $DIR/issue-69341-malformed-derive-inert.rs:4:19\n+   |\n+LL |     #[derive(parse())]\n+   |                   ^^ help: remove the arguments\n+\n+error: `derive` may only be applied to structs, enums and unions\n+  --> $DIR/issue-69341-malformed-derive-inert.rs:8:5\n+   |\n+LL |     path: (),\n+   |     ^^^^^^^^\n+\n+error: cannot find derive macro `parse` in this scope\n+  --> $DIR/issue-69341-malformed-derive-inert.rs:4:14\n+   |\n+LL |     #[derive(parse())]\n+   |              ^^^^^\n+\n+error: cannot find derive macro `parse` in this scope\n+  --> $DIR/issue-69341-malformed-derive-inert.rs:4:14\n+   |\n+LL |     #[derive(parse())]\n+   |              ^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "5078f03d6017a02adaf92d8eb27d2202f67ea45f", "filename": "src/test/ui/match/match-ill-type2.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmatch%2Fmatch-ill-type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmatch%2Fmatch-ill-type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-ill-type2.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/match-ill-type2.rs:4:9\n    |\n+LL |     match 1i32 {\n+   |           ---- this expression has type `i32`\n+LL |         1i32 => 1,\n LL |         2u32 => 1,\n    |         ^^^^ expected `i32`, found `u32`\n "}, {"sha": "3703a59edb83616d9e6382f854f4e02eaf0d4a91", "filename": "src/test/ui/match/match-tag-nullary.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-nullary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-nullary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-nullary.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/match-tag-nullary.rs:4:40\n    |\n LL | fn main() { let x: A = A::A; match x { B::B => { } } }\n-   |                                        ^^^^ expected enum `A`, found enum `B`\n+   |                                    -   ^^^^ expected enum `A`, found enum `B`\n+   |                                    |\n+   |                                    this expression has type `A`\n \n error: aborting due to previous error\n "}, {"sha": "f5c8b02ae27223c02a5ff9cae43db644e1e7b167", "filename": "src/test/ui/mismatched_types/E0409.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -12,7 +12,11 @@ error[E0308]: mismatched types\n LL |     match x {\n    |           - this expression has type `({integer}, {integer})`\n LL |         (0, ref y) | (y, 0) => {}\n-   |                       ^ expected `&{integer}`, found integer\n+   |             -----     ^ expected `&{integer}`, found integer\n+   |             |\n+   |             first introduced with type `&{integer}` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c2bce305877b4048f3ead8d07f7fcb217917cb4c", "filename": "src/test/ui/mismatched_types/issue-38371.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -3,7 +3,8 @@ error[E0308]: mismatched types\n    |\n LL | fn foo(&foo: Foo) {\n    |        ^^^^------\n-   |        |\n+   |        |     |\n+   |        |     expected due to this\n    |        expected struct `Foo`, found reference\n    |        help: did you mean `foo`: `&Foo`\n    |\n@@ -14,7 +15,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-38371.rs:18:9\n    |\n LL | fn agh(&&bar: &u32) {\n-   |         ^^^^\n+   |         ^^^^  ---- expected due to this\n    |         |\n    |         expected `u32`, found reference\n    |         help: you can probably remove the explicit borrow: `bar`\n@@ -26,7 +27,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-38371.rs:21:8\n    |\n LL | fn bgh(&&bar: u32) {\n-   |        ^^^^^ expected `u32`, found reference\n+   |        ^^^^^  --- expected due to this\n+   |        |\n+   |        expected `u32`, found reference\n    |\n    = note:   expected type `u32`\n            found reference `&_`"}, {"sha": "cad1cef5155d5f1ba54e81808a613ebbaa467129", "filename": "src/test/ui/mut/mut-pattern-mismatched.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmut%2Fmut-pattern-mismatched.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fmut%2Fmut-pattern-mismatched.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmut%2Fmut-pattern-mismatched.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -3,6 +3,9 @@ error[E0308]: mismatched types\n    |\n LL |      let &_\n    |          ^^ types differ in mutability\n+...\n+LL |         = foo;\n+   |           --- this expression has type `&mut {integer}`\n    |\n    = note: expected mutable reference `&mut {integer}`\n                       found reference `&_`\n@@ -12,6 +15,9 @@ error[E0308]: mismatched types\n    |\n LL |     let &mut _\n    |         ^^^^^^ types differ in mutability\n+...\n+LL |          = bar;\n+   |            --- this expression has type `&{integer}`\n    |\n    = note:      expected reference `&{integer}`\n            found mutable reference `&mut _`"}, {"sha": "97933ca12294400a83a5a697be987a29af544d8a", "filename": "src/test/ui/or-patterns/already-bound-name.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -86,12 +86,14 @@ error[E0308]: mismatched types\n   --> $DIR/already-bound-name.rs:32:31\n    |\n LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n-   |                               ^                    ------- this expression has type `E<E<{integer}>>`\n-   |                               |\n-   |                               expected integer, found enum `E`\n+   |             -                 ^                    ------- this expression has type `E<E<{integer}>>`\n+   |             |                 |\n+   |             |                 expected integer, found enum `E`\n+   |             first introduced with type `{integer}` here\n    |\n    = note: expected type `{integer}`\n               found type `E<{integer}>`\n+   = note: a binding must have the same type in all alternatives\n \n error: aborting due to 15 previous errors\n "}, {"sha": "8c01e00bae3530598cdd5e1a1b5fc3fdb13c1ad6", "filename": "src/test/ui/or-patterns/inconsistent-modes.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -52,23 +52,27 @@ error[E0308]: mismatched types\n   --> $DIR/inconsistent-modes.rs:11:25\n    |\n LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n-   |                         ^^^^^^^^^   -------------------- expected due to this\n-   |                         |\n-   |                         types differ in mutability\n+   |            -----        ^^^^^^^^^   -------------------- expected due to this\n+   |            |            |\n+   |            |            types differ in mutability\n+   |            first introduced with type `&&u8` here\n    |\n    = note: expected type `&&u8`\n               found type `&mut &mut u8`\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/inconsistent-modes.rs:14:31\n    |\n LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n-   |                               ^^^^^^^^^            ----------- this expression has type `std::result::Result<({integer}, &{integer}), (_, _)>`\n-   |                               |\n-   |                               types differ in mutability\n+   |             -----             ^^^^^^^^^            ----------- this expression has type `std::result::Result<({integer}, &{integer}), (_, _)>`\n+   |             |                 |\n+   |             |                 types differ in mutability\n+   |             first introduced with type `&{integer}` here\n    |\n    = note: expected type `&{integer}`\n               found type `&mut _`\n+   = note: a binding must have the same type in all alternatives\n \n error: aborting due to 9 previous errors\n "}, {"sha": "d5e029d668d4796a6b2cb7f9b54a176bbaf25801", "filename": "src/test/ui/or-patterns/or-patterns-binding-type-mismatch.stderr", "status": "modified", "additions": 116, "deletions": 42, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -4,179 +4,253 @@ error[E0308]: mismatched types\n LL |     match Blah::A(1, 1, 2) {\n    |           ---------------- this expression has type `main::Blah`\n LL |         Blah::A(_, x, y) | Blah::B(x, y) => {}\n-   |                                       ^ expected `usize`, found `isize`\n+   |                       -               ^ expected `usize`, found `isize`\n+   |                       |\n+   |                       first introduced with type `usize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:17:44\n    |\n LL |     match Some(Blah::A(1, 1, 2)) {\n    |           ---------------------- this expression has type `std::option::Option<main::Blah>`\n LL |         Some(Blah::A(_, x, y) | Blah::B(x, y)) => {}\n-   |                                            ^ expected `usize`, found `isize`\n+   |                            -               ^ expected `usize`, found `isize`\n+   |                            |\n+   |                            first introduced with type `usize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:21:19\n    |\n LL |     match (0u8, 1u16) {\n    |           ----------- this expression has type `(u8, u16)`\n LL |         (x, y) | (y, x) => {}\n-   |                   ^ expected `u16`, found `u8`\n+   |             -     ^ expected `u16`, found `u8`\n+   |             |\n+   |             first introduced with type `u16` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:21:22\n    |\n LL |     match (0u8, 1u16) {\n    |           ----------- this expression has type `(u8, u16)`\n LL |         (x, y) | (y, x) => {}\n-   |                      ^ expected `u8`, found `u16`\n+   |          -           ^ expected `u8`, found `u16`\n+   |          |\n+   |          first introduced with type `u8` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:26:41\n    |\n LL |     match Some((0u8, Some((1u16, 2u32)))) {\n    |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n-   |                                         ^ expected `u16`, found `u8`\n+   |                        -                ^ expected `u16`, found `u8`\n+   |                        |\n+   |                        first introduced with type `u16` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:26:50\n    |\n LL |     match Some((0u8, Some((1u16, 2u32)))) {\n    |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n-   |                                                  ^ expected `u8`, found `u16`\n+   |               -                                  ^ expected `u8`, found `u16`\n+   |               |\n+   |               first introduced with type `u8` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:26:59\n    |\n LL |     match Some((0u8, Some((1u16, 2u32)))) {\n    |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n-   |                                                           ^ expected `u32`, found `u16`\n+   |                           -                               ^ expected `u32`, found `u16`\n+   |                           |\n+   |                           first introduced with type `u32` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:26:62\n    |\n LL |     match Some((0u8, Some((1u16, 2u32)))) {\n    |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n-   |                                                              ^ expected `u8`, found `u32`\n+   |               - first introduced with type `u8` here         ^ expected `u8`, found `u32`\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:34:42\n    |\n LL |     if let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2) {\n-   |                                          ^    ---------------- this expression has type `main::Blah`\n-   |                                          |\n-   |                                          expected `usize`, found `isize`\n+   |                          -               ^    ---------------- this expression has type `main::Blah`\n+   |                          |               |\n+   |                          |               expected `usize`, found `isize`\n+   |                          first introduced with type `usize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:38:47\n    |\n LL |     if let Some(Blah::A(_, x, y) | Blah::B(x, y)) = Some(Blah::A(1, 1, 2)) {\n-   |                                               ^     ---------------------- this expression has type `std::option::Option<main::Blah>`\n-   |                                               |\n-   |                                               expected `usize`, found `isize`\n+   |                               -               ^     ---------------------- this expression has type `std::option::Option<main::Blah>`\n+   |                               |               |\n+   |                               |               expected `usize`, found `isize`\n+   |                               first introduced with type `usize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:42:22\n    |\n LL |     if let (x, y) | (y, x) = (0u8, 1u16) {\n-   |                      ^       ----------- this expression has type `(u8, u16)`\n-   |                      |\n-   |                      expected `u16`, found `u8`\n+   |                -     ^       ----------- this expression has type `(u8, u16)`\n+   |                |     |\n+   |                |     expected `u16`, found `u8`\n+   |                first introduced with type `u16` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:42:25\n    |\n LL |     if let (x, y) | (y, x) = (0u8, 1u16) {\n-   |                         ^    ----------- this expression has type `(u8, u16)`\n-   |                         |\n-   |                         expected `u8`, found `u16`\n+   |             -           ^    ----------- this expression has type `(u8, u16)`\n+   |             |           |\n+   |             |           expected `u8`, found `u16`\n+   |             first introduced with type `u8` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:47:44\n    |\n LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n-   |                                            ^ expected `u16`, found `u8`\n+   |                           -                ^ expected `u16`, found `u8`\n+   |                           |\n+   |                           first introduced with type `u16` here\n ...\n LL |     = Some((0u8, Some((1u16, 2u32))))\n    |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:47:53\n    |\n LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n-   |                                                     ^ expected `u8`, found `u16`\n+   |                  -                                  ^ expected `u8`, found `u16`\n+   |                  |\n+   |                  first introduced with type `u8` here\n ...\n LL |     = Some((0u8, Some((1u16, 2u32))))\n    |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:47:62\n    |\n LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n-   |                                                              ^ expected `u32`, found `u16`\n+   |                              -                               ^ expected `u32`, found `u16`\n+   |                              |\n+   |                              first introduced with type `u32` here\n ...\n LL |     = Some((0u8, Some((1u16, 2u32))))\n    |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:47:65\n    |\n LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n-   |                                                                 ^ expected `u8`, found `u32`\n+   |                  - first introduced with type `u8` here         ^ expected `u8`, found `u32`\n ...\n LL |     = Some((0u8, Some((1u16, 2u32))))\n    |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:55:39\n    |\n LL |     let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2);\n-   |                                       ^    ---------------- this expression has type `main::Blah`\n-   |                                       |\n-   |                                       expected `usize`, found `isize`\n+   |                       -               ^    ---------------- this expression has type `main::Blah`\n+   |                       |               |\n+   |                       |               expected `usize`, found `isize`\n+   |                       first introduced with type `usize` here\n+   |\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:58:19\n    |\n LL |     let (x, y) | (y, x) = (0u8, 1u16);\n-   |                   ^       ----------- this expression has type `(u8, u16)`\n-   |                   |\n-   |                   expected `u16`, found `u8`\n+   |             -     ^       ----------- this expression has type `(u8, u16)`\n+   |             |     |\n+   |             |     expected `u16`, found `u8`\n+   |             first introduced with type `u16` here\n+   |\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:58:22\n    |\n LL |     let (x, y) | (y, x) = (0u8, 1u16);\n-   |                      ^    ----------- this expression has type `(u8, u16)`\n-   |                      |\n-   |                      expected `u8`, found `u16`\n+   |          -           ^    ----------- this expression has type `(u8, u16)`\n+   |          |           |\n+   |          |           expected `u8`, found `u16`\n+   |          first introduced with type `u8` here\n+   |\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:62:42\n    |\n LL |     fn f1((Blah::A(_, x, y) | Blah::B(x, y)): Blah) {}\n-   |                                          ^    ---- expected due to this\n-   |                                          |\n-   |                                          expected `usize`, found `isize`\n+   |                          -               ^    ---- expected due to this\n+   |                          |               |\n+   |                          |               expected `usize`, found `isize`\n+   |                          first introduced with type `usize` here\n+   |\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:65:22\n    |\n LL |     fn f2(((x, y) | (y, x)): (u8, u16)) {}\n-   |                      ^       --------- expected due to this\n-   |                      |\n-   |                      expected `u16`, found `u8`\n+   |                -     ^       --------- expected due to this\n+   |                |     |\n+   |                |     expected `u16`, found `u8`\n+   |                first introduced with type `u16` here\n+   |\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:65:25\n    |\n LL |     fn f2(((x, y) | (y, x)): (u8, u16)) {}\n-   |                         ^    --------- expected due to this\n-   |                         |\n-   |                         expected `u8`, found `u16`\n+   |             -           ^    --------- expected due to this\n+   |             |           |\n+   |             |           expected `u8`, found `u16`\n+   |             first introduced with type `u8` here\n+   |\n+   = note: a binding must have the same type in all alternatives\n \n error: aborting due to 22 previous errors\n "}, {"sha": "598b6a3794ef72a18d9144547447fbee7fcfe634", "filename": "src/test/ui/pattern/pat-tuple-bad-type.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -12,6 +12,8 @@ LL |         (..) => {}\n error[E0308]: mismatched types\n   --> $DIR/pat-tuple-bad-type.rs:10:9\n    |\n+LL |     match 0u8 {\n+   |           --- this expression has type `u8`\n LL |         (..) => {}\n    |         ^^^^ expected `u8`, found `()`\n "}, {"sha": "45b6fd1b4d445e97c662ab9ac0a01ed49072bd25", "filename": "src/test/ui/pattern/pat-tuple-overfield.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-overfield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-overfield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-overfield.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/pat-tuple-overfield.rs:5:9\n    |\n+LL |     match (1, 2, 3) {\n+   |           --------- this expression has type `({integer}, {integer}, {integer})`\n LL |         (1, 2, 3, 4) => {}\n    |         ^^^^^^^^^^^^ expected a tuple with 3 elements, found one with 4 elements\n    |\n@@ -10,6 +12,9 @@ LL |         (1, 2, 3, 4) => {}\n error[E0308]: mismatched types\n   --> $DIR/pat-tuple-overfield.rs:6:9\n    |\n+LL |     match (1, 2, 3) {\n+   |           --------- this expression has type `({integer}, {integer}, {integer})`\n+LL |         (1, 2, 3, 4) => {}\n LL |         (1, 2, .., 3, 4) => {}\n    |         ^^^^^^^^^^^^^^^^ expected a tuple with 3 elements, found one with 4 elements\n    |"}, {"sha": "24b5cdf98d5e202b26cdcf32f58999f660e81589", "filename": "src/test/ui/pattern/pattern-ident-path-generics.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fpattern%2Fpattern-ident-path-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fpattern%2Fpattern-ident-path-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-ident-path-generics.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/pattern-ident-path-generics.rs:3:9\n    |\n+LL |     match Some(\"foo\") {\n+   |           ----------- this expression has type `std::option::Option<&str>`\n LL |         None::<isize> => {}\n    |         ^^^^^^^^^^^^^ expected `&str`, found `isize`\n    |"}, {"sha": "4397baea4a940a76fe06293c69bd5e81959f9220", "filename": "src/test/ui/resolve/issue-69401-trait-fn-no-body-ty-local.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fresolve%2Fissue-69401-trait-fn-no-body-ty-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fresolve%2Fissue-69401-trait-fn-no-body-ty-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-69401-trait-fn-no-body-ty-local.rs?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -0,0 +1,6 @@\n+fn main() {}\n+\n+trait Foo {\n+    fn fn_with_type_named_same_as_local_in_param(b: b);\n+    //~^ ERROR cannot find type `b` in this scope\n+}"}, {"sha": "109409d2731c5b4717b6450ebc7e9bed57f3198f", "filename": "src/test/ui/resolve/issue-69401-trait-fn-no-body-ty-local.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fresolve%2Fissue-69401-trait-fn-no-body-ty-local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fresolve%2Fissue-69401-trait-fn-no-body-ty-local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-69401-trait-fn-no-body-ty-local.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `b` in this scope\n+  --> $DIR/issue-69401-trait-fn-no-body-ty-local.rs:4:53\n+   |\n+LL |     fn fn_with_type_named_same_as_local_in_param(b: b);\n+   |                                                     ^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "2de0b6a496958a2af0ffc39f0ddc391f4001a079", "filename": "src/test/ui/resolve/name-clash-nullary.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fresolve%2Fname-clash-nullary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fresolve%2Fname-clash-nullary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fname-clash-nullary.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/name-clash-nullary.rs:2:7\n    |\n LL |   let None: isize = 42;\n-   |       ^^^^ expected `isize`, found enum `std::option::Option`\n+   |       ^^^^  ----- expected due to this\n+   |       |\n+   |       expected `isize`, found enum `std::option::Option`\n    |\n    = note: expected type `isize`\n               found enum `std::option::Option<_>`"}, {"sha": "749ed131b204eacf85fee158e7fcd1e91041c45e", "filename": "src/test/ui/resolve/resolve-inconsistent-binding-mode.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -26,26 +26,37 @@ error[E0308]: mismatched types\n LL |     match x {\n    |           - this expression has type `Opts`\n LL |       Opts::A(ref i) | Opts::B(i) => {}\n-   |                                ^ expected `&isize`, found `isize`\n+   |               -----            ^ expected `&isize`, found `isize`\n+   |               |\n+   |               first introduced with type `&isize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:16:32\n    |\n LL |     match x {\n    |           - this expression has type `Opts`\n LL |       Opts::A(ref i) | Opts::B(i) => {}\n-   |                                ^ expected `&isize`, found `isize`\n+   |               -----            ^ expected `&isize`, found `isize`\n+   |               |\n+   |               first introduced with type `&isize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:25:36\n    |\n LL |     match x {\n    |           - this expression has type `Opts`\n LL |       Opts::A(ref mut i) | Opts::B(ref i) => {}\n-   |                                    ^^^^^ types differ in mutability\n+   |               ---------            ^^^^^ types differ in mutability\n+   |               |\n+   |               first introduced with type `&mut isize` here\n    |\n    = note: expected type `&mut isize`\n               found type `&isize`\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error: aborting due to 6 previous errors\n "}, {"sha": "1d3079c90baf657693c3d4b68f4fc32f69378dc5", "filename": "src/test/ui/resolve/resolve-inconsistent-names.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -89,7 +89,11 @@ error[E0308]: mismatched types\n LL |     match x {\n    |           - this expression has type `(E, E)`\n LL |         (A, B) | (ref B, c) | (c, A) => ()\n-   |                   ^^^^^ expected enum `E`, found `&E`\n+   |             -     ^^^^^ expected enum `E`, found `&E`\n+   |             |\n+   |             first introduced with type `E` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error: aborting due to 9 previous errors\n "}, {"sha": "27efd450b9471157126a4d22f72003c0dd92ea19", "filename": "src/test/ui/rfc-2005-default-binding-mode/const.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/const.rs:14:9\n    |\n+LL |     match &f {\n+   |           -- this expression has type `&Foo`\n LL |         FOO => {},\n    |         ^^^ expected `&Foo`, found struct `Foo`\n "}, {"sha": "6d18a39606ccf04362eff220d28c3fabb1ffddc8", "filename": "src/test/ui/rfc-2005-default-binding-mode/lit.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Flit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Flit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Flit.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/lit.rs:7:13\n    |\n+LL |     match &s {\n+   |           -- this expression has type `&&str`\n LL |             \"abc\" => true,\n    |             ^^^^^ expected `&str`, found `str`\n    |\n@@ -10,6 +12,8 @@ LL |             \"abc\" => true,\n error[E0308]: mismatched types\n   --> $DIR/lit.rs:16:9\n    |\n+LL |     match &s {\n+   |           -- this expression has type `&&[u8]`\n LL |         b\"abc\" => true,\n    |         ^^^^^^ expected `&[u8]`, found array `[u8; 3]`\n    |"}, {"sha": "14f01f0ebdf7386055fcdec842f0ddce5d53b26c", "filename": "src/test/ui/slightly-nice-generic-literal-messages.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fslightly-nice-generic-literal-messages.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fslightly-nice-generic-literal-messages.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fslightly-nice-generic-literal-messages.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/slightly-nice-generic-literal-messages.rs:7:9\n    |\n+LL |     match Foo(1.1, marker::PhantomData) {\n+   |           ----------------------------- this expression has type `Foo<{float}, _>`\n LL |         1 => {}\n    |         ^ expected struct `Foo`, found integer\n    |"}, {"sha": "559a2d29551d32295bc3e55c642ca7c1fb17cfb2", "filename": "src/test/ui/suggestions/match-ergonomics.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-ergonomics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-ergonomics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-ergonomics.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/match-ergonomics.rs:4:10\n    |\n+LL |     match &x[..] {\n+   |           ------ this expression has type `&[i32]`\n LL |         [&v] => {},\n    |          ^^\n    |          |\n@@ -25,6 +27,8 @@ LL |         [v] => {},\n error[E0308]: mismatched types\n   --> $DIR/match-ergonomics.rs:29:9\n    |\n+LL |     match y {\n+   |           - this expression has type `i32`\n LL |         &v => {},\n    |         ^^\n    |         |\n@@ -38,7 +42,7 @@ error[E0308]: mismatched types\n   --> $DIR/match-ergonomics.rs:40:13\n    |\n LL |     if let [&v] = &x[..] {}\n-   |             ^^\n+   |             ^^    ------ this expression has type `&[i32]`\n    |             |\n    |             expected `i32`, found reference\n    |             help: you can probably remove the explicit borrow: `v`"}, {"sha": "c2874ae9a14b857508c5a494d8e4b605a803127c", "filename": "src/test/ui/suppressed-error.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fsuppressed-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb/src%2Ftest%2Fui%2Fsuppressed-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuppressed-error.stderr?ref=0eb878d2aa6e3a1cb315f3f328681b26bb4bffdb", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/suppressed-error.rs:2:9\n    |\n LL |     let (x, y) = ();\n-   |         ^^^^^^ expected `()`, found tuple\n+   |         ^^^^^^   -- this expression has type `()`\n+   |         |\n+   |         expected `()`, found tuple\n    |\n    = note: expected unit type `()`\n                   found tuple `(_, _)`"}]}