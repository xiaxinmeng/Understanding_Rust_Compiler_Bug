{"sha": "1c7b780787a9b55a139bb140905e907f95ddd5a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjN2I3ODA3ODdhOWI1NWExMzliYjE0MDkwNWU5MDdmOTVkZGQ1YTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-23T00:11:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-23T00:11:39Z"}, "message": "auto merge of #15068 : erickt/rust/mem-inline, r=pcwalton\n\nThis is a couple micro-optimizations I've been sitting on for a while. This inlines a couple functions that are important to the `std::io::mem`. Ultimately, this results in about a 15% performance increase in some micro-benchmarks for my [libserialize](https://github.com/erickt/rust-serde) rewrite.", "tree": {"sha": "9acf4aafd718dcde9aea6af13a4e98ffa232fc5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9acf4aafd718dcde9aea6af13a4e98ffa232fc5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c7b780787a9b55a139bb140905e907f95ddd5a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c7b780787a9b55a139bb140905e907f95ddd5a1", "html_url": "https://github.com/rust-lang/rust/commit/1c7b780787a9b55a139bb140905e907f95ddd5a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c7b780787a9b55a139bb140905e907f95ddd5a1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca3e557ee8a6451847b3bf6024175a2fe4601737", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca3e557ee8a6451847b3bf6024175a2fe4601737", "html_url": "https://github.com/rust-lang/rust/commit/ca3e557ee8a6451847b3bf6024175a2fe4601737"}, {"sha": "b9aeda480255331512ab869689ff9ffd6c101a7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9aeda480255331512ab869689ff9ffd6c101a7c", "html_url": "https://github.com/rust-lang/rust/commit/b9aeda480255331512ab869689ff9ffd6c101a7c"}], "stats": {"total": 247, "additions": 246, "deletions": 1}, "files": [{"sha": "953fa68138a0755ef4930f78f5ef245ebea315c8", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/1c7b780787a9b55a139bb140905e907f95ddd5a1/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7b780787a9b55a139bb140905e907f95ddd5a1/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=1c7b780787a9b55a139bb140905e907f95ddd5a1", "patch": "@@ -85,6 +85,7 @@ impl<T> Vec<T> {\n     /// # use std::vec::Vec;\n     /// let vec: Vec<int> = Vec::with_capacity(10);\n     /// ```\n+    #[inline]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n             Vec { len: 0, cap: uint::MAX, ptr: 0 as *mut T }\n@@ -110,6 +111,7 @@ impl<T> Vec<T> {\n     /// let vec = Vec::from_fn(3, |idx| idx * 2);\n     /// assert_eq!(vec, vec!(0, 2, 4));\n     /// ```\n+    #[inline]\n     pub fn from_fn(length: uint, op: |uint| -> T) -> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n@@ -193,6 +195,7 @@ impl<T: Clone> Vec<T> {\n     /// let slice = [1, 2, 3];\n     /// let vec = Vec::from_slice(slice);\n     /// ```\n+    #[inline]\n     pub fn from_slice(values: &[T]) -> Vec<T> {\n         values.iter().map(|x| x.clone()).collect()\n     }\n@@ -207,6 +210,7 @@ impl<T: Clone> Vec<T> {\n     /// let vec = Vec::from_elem(3, \"hi\");\n     /// println!(\"{}\", vec); // prints [hi, hi, hi]\n     /// ```\n+    #[inline]\n     pub fn from_elem(length: uint, value: T) -> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n@@ -353,6 +357,7 @@ impl<T:Clone> Clone for Vec<T> {\n }\n \n impl<T> FromIterator<T> for Vec<T> {\n+    #[inline]\n     fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n         let (lower, _) = iterator.size_hint();\n         let mut vector = Vec::with_capacity(lower);\n@@ -364,6 +369,7 @@ impl<T> FromIterator<T> for Vec<T> {\n }\n \n impl<T> Extendable<T> for Vec<T> {\n+    #[inline]\n     fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n         let (lower, _) = iterator.size_hint();\n         self.reserve_additional(lower);\n@@ -1029,6 +1035,7 @@ impl<T> Vec<T> {\n     /// vec.push_all_move(vec!(box 2, box 3, box 4));\n     /// assert_eq!(vec, vec!(box 1, box 2, box 3, box 4));\n     /// ```\n+    #[inline]\n     pub fn push_all_move(&mut self, other: Vec<T>) {\n         self.extend(other.move_iter());\n     }\n@@ -1306,6 +1313,7 @@ impl<T:PartialEq> Vec<T> {\n     /// let vec = vec!(1, 2, 3);\n     /// assert!(vec.contains(&1));\n     /// ```\n+    #[inline]\n     pub fn contains(&self, x: &T) -> bool {\n         self.as_slice().contains(x)\n     }\n@@ -1544,8 +1552,11 @@ pub mod raw {\n \n #[cfg(test)]\n mod tests {\n+    extern crate test;\n+\n     use std::prelude::*;\n     use std::mem::size_of;\n+    use test::Bencher;\n     use super::{unzip, raw, Vec};\n \n     #[test]\n@@ -1836,4 +1847,111 @@ mod tests {\n         let mut v = vec![BadElem(1), BadElem(2), BadElem(0xbadbeef), BadElem(4)];\n         v.truncate(0);\n     }\n+\n+    #[bench]\n+    fn bench_new(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::new();\n+            assert_eq!(v.capacity(), 0);\n+            assert!(v.as_slice() == []);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_with_capacity_0(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::with_capacity(0);\n+            assert_eq!(v.capacity(), 0);\n+            assert!(v.as_slice() == []);\n+        })\n+    }\n+\n+\n+    #[bench]\n+    fn bench_with_capacity_5(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::with_capacity(5);\n+            assert_eq!(v.capacity(), 5);\n+            assert!(v.as_slice() == []);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_with_capacity_100(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::with_capacity(100);\n+            assert_eq!(v.capacity(), 100);\n+            assert!(v.as_slice() == []);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_from_fn_0(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::from_fn(0, |_| 5);\n+            assert!(v.as_slice() == []);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_from_fn_5(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::from_fn(5, |_| 5);\n+            assert!(v.as_slice() == [5, 5, 5, 5, 5]);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_from_slice_0(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::from_slice([]);\n+            assert!(v.as_slice() == []);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_from_slice_5(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v: Vec<int> = Vec::from_slice([1, 2, 3, 4, 5]);\n+            assert!(v.as_slice() == [1, 2, 3, 4, 5]);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_from_iter_0(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v0: Vec<int> = vec!();\n+            let v1: Vec<int> = FromIterator::from_iter(v0.move_iter());\n+            assert!(v1.as_slice() == []);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_from_iter_5(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v0: Vec<int> = vec!(1, 2, 3, 4, 5);\n+            let v1: Vec<int> = FromIterator::from_iter(v0.move_iter());\n+            assert!(v1.as_slice() == [1, 2, 3, 4, 5]);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_extend_0(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v0: Vec<int> = vec!();\n+            let mut v1: Vec<int> = vec!(1, 2, 3, 4, 5);\n+            v1.extend(v0.move_iter());\n+            assert!(v1.as_slice() == [1, 2, 3, 4, 5]);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_extend_5(b: &mut Bencher) {\n+        b.iter(|| {\n+            let v0: Vec<int> = vec!(1, 2, 3, 4, 5);\n+            let mut v1: Vec<int> = vec!(1, 2, 3, 4, 5);\n+            v1.extend(v0.move_iter());\n+            assert!(v1.as_slice() == [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]);\n+        })\n+    }\n }"}, {"sha": "0439306ffdeac10750a3c1c570667f86a9c28fab", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c7b780787a9b55a139bb140905e907f95ddd5a1/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7b780787a9b55a139bb140905e907f95ddd5a1/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=1c7b780787a9b55a139bb140905e907f95ddd5a1", "patch": "@@ -71,7 +71,7 @@ fn main() {\n     let to_encode_object = TestStruct{data_str:\"example of string to encode\".to_string()};\n     let mut m = io::MemWriter::new();\n     {\n-        let mut encoder = json::Encoder::new(&mut m as &mut std::io::Writer);\n+        let mut encoder = json::Encoder::new(&mut m as &mut Writer);\n         match to_encode_object.encode(&mut encoder) {\n             Ok(()) => (),\n             Err(e) => fail!(\"json encoding error: {}\", e)"}, {"sha": "ec3d93708331c0b6e47e73348ef5b4cf0c1305f3", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1c7b780787a9b55a139bb140905e907f95ddd5a1/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7b780787a9b55a139bb140905e907f95ddd5a1/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=1c7b780787a9b55a139bb140905e907f95ddd5a1", "patch": "@@ -59,11 +59,13 @@ pub struct MemWriter {\n \n impl MemWriter {\n     /// Create a new `MemWriter`.\n+    #[inline]\n     pub fn new() -> MemWriter {\n         MemWriter::with_capacity(128)\n     }\n     /// Create a new `MemWriter`, allocating at least `n` bytes for\n     /// the internal buffer.\n+    #[inline]\n     pub fn with_capacity(n: uint) -> MemWriter {\n         MemWriter { buf: Vec::with_capacity(n), pos: 0 }\n     }\n@@ -73,13 +75,16 @@ impl MemWriter {\n     ///\n     /// No method is exposed for acquiring a mutable reference to the buffer\n     /// because it could corrupt the state of this `MemWriter`.\n+    #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n \n     /// Unwraps this `MemWriter`, returning the underlying buffer\n+    #[inline]\n     pub fn unwrap(self) -> Vec<u8> { self.buf }\n }\n \n impl Writer for MemWriter {\n+    #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         // Make sure the internal buffer is as least as big as where we\n         // currently are\n@@ -112,7 +117,10 @@ impl Writer for MemWriter {\n }\n \n impl Seek for MemWriter {\n+    #[inline]\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+\n+    #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n         self.pos = new as uint;\n@@ -140,6 +148,7 @@ pub struct MemReader {\n impl MemReader {\n     /// Creates a new `MemReader` which will read the buffer given. The buffer\n     /// can be re-acquired through `unwrap`\n+    #[inline]\n     pub fn new(buf: Vec<u8>) -> MemReader {\n         MemReader {\n             buf: buf,\n@@ -150,20 +159,24 @@ impl MemReader {\n     /// Tests whether this reader has read all bytes in its buffer.\n     ///\n     /// If `true`, then this will no longer return bytes from `read`.\n+    #[inline]\n     pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\n \n     /// Acquires an immutable reference to the underlying buffer of this\n     /// `MemReader`.\n     ///\n     /// No method is exposed for acquiring a mutable reference to the buffer\n     /// because it could corrupt the state of this `MemReader`.\n+    #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n \n     /// Unwraps this `MemReader`, returning the underlying buffer\n+    #[inline]\n     pub fn unwrap(self) -> Vec<u8> { self.buf }\n }\n \n impl Reader for MemReader {\n+    #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         if self.eof() { return Err(io::standard_error(io::EndOfFile)) }\n \n@@ -182,7 +195,10 @@ impl Reader for MemReader {\n }\n \n impl Seek for MemReader {\n+    #[inline]\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+\n+    #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n         self.pos = new as uint;\n@@ -191,13 +207,16 @@ impl Seek for MemReader {\n }\n \n impl Buffer for MemReader {\n+    #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n             Ok(self.buf.slice_from(self.pos))\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n     }\n+\n+    #[inline]\n     fn consume(&mut self, amt: uint) { self.pos += amt; }\n }\n \n@@ -227,6 +246,7 @@ pub struct BufWriter<'a> {\n impl<'a> BufWriter<'a> {\n     /// Creates a new `BufWriter` which will wrap the specified buffer. The\n     /// writer initially starts at position 0.\n+    #[inline]\n     pub fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> {\n         BufWriter {\n             buf: buf,\n@@ -236,6 +256,7 @@ impl<'a> BufWriter<'a> {\n }\n \n impl<'a> Writer for BufWriter<'a> {\n+    #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         // return an error if the entire write does not fit in the buffer\n         let max_size = self.buf.len();\n@@ -254,7 +275,10 @@ impl<'a> Writer for BufWriter<'a> {\n }\n \n impl<'a> Seek for BufWriter<'a> {\n+    #[inline]\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+\n+    #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n         self.pos = new as uint;\n@@ -282,6 +306,7 @@ pub struct BufReader<'a> {\n \n impl<'a> BufReader<'a> {\n     /// Creates a new buffered reader which will read the specified buffer\n+    #[inline]\n     pub fn new<'a>(buf: &'a [u8]) -> BufReader<'a> {\n         BufReader {\n             buf: buf,\n@@ -292,10 +317,12 @@ impl<'a> BufReader<'a> {\n     /// Tests whether this reader has read all bytes in its buffer.\n     ///\n     /// If `true`, then this will no longer return bytes from `read`.\n+    #[inline]\n     pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\n }\n \n impl<'a> Reader for BufReader<'a> {\n+    #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         if self.eof() { return Err(io::standard_error(io::EndOfFile)) }\n \n@@ -314,7 +341,10 @@ impl<'a> Reader for BufReader<'a> {\n }\n \n impl<'a> Seek for BufReader<'a> {\n+    #[inline]\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+\n+    #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n         self.pos = new as uint;\n@@ -323,22 +353,27 @@ impl<'a> Seek for BufReader<'a> {\n }\n \n impl<'a> Buffer for BufReader<'a> {\n+    #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n             Ok(self.buf.slice_from(self.pos))\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n     }\n+\n+    #[inline]\n     fn consume(&mut self, amt: uint) { self.pos += amt; }\n }\n \n #[cfg(test)]\n mod test {\n+    extern crate test;\n     use prelude::*;\n     use super::*;\n     use io::*;\n     use io;\n+    use self::test::Bencher;\n     use str::StrSlice;\n \n     #[test]\n@@ -571,4 +606,59 @@ mod test {\n         assert!(r.read_at_least(buf.len(), buf).is_err());\n         assert_eq!(buf.as_slice(), &[7, 8, 6]);\n     }\n+\n+    #[bench]\n+    fn bench_mem_writer(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut wr = MemWriter::new();\n+            for _i in range(0, 10) {\n+                wr.write([5, .. 10]).unwrap();\n+            }\n+            assert_eq!(wr.unwrap().as_slice(), [5, .. 100].as_slice());\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_mem_reader(b: &mut Bencher) {\n+        b.iter(|| {\n+            let buf = Vec::from_slice([5 as u8, ..100]);\n+            {\n+                let mut rdr = MemReader::new(buf);\n+                for _i in range(0, 10) {\n+                    let mut buf = [0 as u8, .. 10];\n+                    rdr.read(buf).unwrap();\n+                    assert_eq!(buf.as_slice(), [5, .. 10].as_slice());\n+                }\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_buf_writer(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut buf = [0 as u8, ..100];\n+            {\n+                let mut wr = BufWriter::new(buf);\n+                for _i in range(0, 10) {\n+                    wr.write([5, .. 10]).unwrap();\n+                }\n+            }\n+            assert_eq!(buf.as_slice(), [5, .. 100].as_slice());\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_buf_reader(b: &mut Bencher) {\n+        b.iter(|| {\n+            let buf = [5 as u8, ..100];\n+            {\n+                let mut rdr = BufReader::new(buf);\n+                for _i in range(0, 10) {\n+                    let mut buf = [0 as u8, .. 10];\n+                    rdr.read(buf).unwrap();\n+                    assert_eq!(buf.as_slice(), [5, .. 10].as_slice());\n+                }\n+            }\n+        });\n+    }\n }"}, {"sha": "1d6ad7c31e2fd5ff29c3ce7501ed057658b41411", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1c7b780787a9b55a139bb140905e907f95ddd5a1/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7b780787a9b55a139bb140905e907f95ddd5a1/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=1c7b780787a9b55a139bb140905e907f95ddd5a1", "patch": "@@ -1084,6 +1084,7 @@ pub trait Writer {\n     /// If other encodings are desired, it is recommended to compose this stream\n     /// with another performing the conversion, or to use `write` with a\n     /// converted byte-array instead.\n+    #[inline]\n     fn write_str(&mut self, s: &str) -> IoResult<()> {\n         self.write(s.as_bytes())\n     }\n@@ -1095,123 +1096,146 @@ pub trait Writer {\n     ///\n     /// If other encodings or line ending flavors are desired, it is recommended\n     /// that the `write` method is used specifically instead.\n+    #[inline]\n     fn write_line(&mut self, s: &str) -> IoResult<()> {\n         self.write_str(s).and_then(|()| self.write(['\\n' as u8]))\n     }\n \n     /// Write a single char, encoded as UTF-8.\n+    #[inline]\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8, ..4];\n         let n = c.encode_utf8(buf.as_mut_slice());\n         self.write(buf.slice_to(n))\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n+    #[inline]\n     fn write_int(&mut self, n: int) -> IoResult<()> {\n         write!(self, \"{:d}\", n)\n     }\n \n     /// Write the result of passing n through `uint::to_str_bytes`.\n+    #[inline]\n     fn write_uint(&mut self, n: uint) -> IoResult<()> {\n         write!(self, \"{:u}\", n)\n     }\n \n     /// Write a little-endian uint (number of bytes depends on system).\n+    #[inline]\n     fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, uint::BYTES, |v| self.write(v))\n     }\n \n     /// Write a little-endian int (number of bytes depends on system).\n+    #[inline]\n     fn write_le_int(&mut self, n: int) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, int::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian uint (number of bytes depends on system).\n+    #[inline]\n     fn write_be_uint(&mut self, n: uint) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, uint::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian int (number of bytes depends on system).\n+    #[inline]\n     fn write_be_int(&mut self, n: int) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, int::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian u64 (8 bytes).\n+    #[inline]\n     fn write_be_u64(&mut self, n: u64) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n, 8u, |v| self.write(v))\n     }\n \n     /// Write a big-endian u32 (4 bytes).\n+    #[inline]\n     fn write_be_u32(&mut self, n: u32) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a big-endian u16 (2 bytes).\n+    #[inline]\n     fn write_be_u16(&mut self, n: u16) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a big-endian i64 (8 bytes).\n+    #[inline]\n     fn write_be_i64(&mut self, n: i64) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n     }\n \n     /// Write a big-endian i32 (4 bytes).\n+    #[inline]\n     fn write_be_i32(&mut self, n: i32) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a big-endian i16 (2 bytes).\n+    #[inline]\n     fn write_be_i16(&mut self, n: i16) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n+    #[inline]\n     fn write_be_f64(&mut self, f: f64) -> IoResult<()> {\n         unsafe {\n             self.write_be_u64(transmute(f))\n         }\n     }\n \n     /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n+    #[inline]\n     fn write_be_f32(&mut self, f: f32) -> IoResult<()> {\n         unsafe {\n             self.write_be_u32(transmute(f))\n         }\n     }\n \n     /// Write a little-endian u64 (8 bytes).\n+    #[inline]\n     fn write_le_u64(&mut self, n: u64) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n, 8u, |v| self.write(v))\n     }\n \n     /// Write a little-endian u32 (4 bytes).\n+    #[inline]\n     fn write_le_u32(&mut self, n: u32) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a little-endian u16 (2 bytes).\n+    #[inline]\n     fn write_le_u16(&mut self, n: u16) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a little-endian i64 (8 bytes).\n+    #[inline]\n     fn write_le_i64(&mut self, n: i64) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n     }\n \n     /// Write a little-endian i32 (4 bytes).\n+    #[inline]\n     fn write_le_i32(&mut self, n: i32) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a little-endian i16 (2 bytes).\n+    #[inline]\n     fn write_le_i16(&mut self, n: i16) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a little-endian IEEE754 double-precision floating-point\n     /// (8 bytes).\n+    #[inline]\n     fn write_le_f64(&mut self, f: f64) -> IoResult<()> {\n         unsafe {\n             self.write_le_u64(transmute(f))\n@@ -1220,18 +1244,21 @@ pub trait Writer {\n \n     /// Write a little-endian IEEE754 single-precision floating-point\n     /// (4 bytes).\n+    #[inline]\n     fn write_le_f32(&mut self, f: f32) -> IoResult<()> {\n         unsafe {\n             self.write_le_u32(transmute(f))\n         }\n     }\n \n     /// Write a u8 (1 byte).\n+    #[inline]\n     fn write_u8(&mut self, n: u8) -> IoResult<()> {\n         self.write([n])\n     }\n \n     /// Write an i8 (1 byte).\n+    #[inline]\n     fn write_i8(&mut self, n: i8) -> IoResult<()> {\n         self.write([n as u8])\n     }\n@@ -1240,18 +1267,25 @@ pub trait Writer {\n     ///\n     /// This is useful to allow applying wrappers while still\n     /// retaining ownership of the original value.\n+    #[inline]\n     fn by_ref<'a>(&'a mut self) -> RefWriter<'a, Self> {\n         RefWriter { inner: self }\n     }\n }\n \n impl Writer for Box<Writer> {\n+    #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }\n+\n+    #[inline]\n     fn flush(&mut self) -> IoResult<()> { self.flush() }\n }\n \n impl<'a> Writer for &'a mut Writer {\n+    #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }\n+\n+    #[inline]\n     fn flush(&mut self) -> IoResult<()> { self.flush() }\n }\n \n@@ -1285,7 +1319,10 @@ pub struct RefWriter<'a, W> {\n }\n \n impl<'a, W: Writer> Writer for RefWriter<'a, W> {\n+    #[inline]\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write(buf) }\n+\n+    #[inline]\n     fn flush(&mut self) -> IoResult<()> { self.inner.flush() }\n }\n "}]}