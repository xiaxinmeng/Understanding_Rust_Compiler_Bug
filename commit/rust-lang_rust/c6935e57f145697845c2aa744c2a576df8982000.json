{"sha": "c6935e57f145697845c2aa744c2a576df8982000", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2OTM1ZTU3ZjE0NTY5Nzg0NWMyYWE3NDRjMmE1NzZkZjg5ODIwMDA=", "commit": {"author": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-03-06T16:07:27Z"}, "committer": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-03-23T19:19:24Z"}, "message": "Revert \"add universes to type inference variables\"\n\nThis reverts commit 13efaf0481275dba18f1d18f4b59b664b2d2031a.", "tree": {"sha": "a20f99813557579e212889575eaef9c34e693df0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a20f99813557579e212889575eaef9c34e693df0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6935e57f145697845c2aa744c2a576df8982000", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6935e57f145697845c2aa744c2a576df8982000", "html_url": "https://github.com/rust-lang/rust/commit/c6935e57f145697845c2aa744c2a576df8982000", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6935e57f145697845c2aa744c2a576df8982000/comments", "author": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1171ebf6f127cc9c1ca0e537fd460d6f97ef76b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1171ebf6f127cc9c1ca0e537fd460d6f97ef76b0", "html_url": "https://github.com/rust-lang/rust/commit/1171ebf6f127cc9c1ca0e537fd460d6f97ef76b0"}], "stats": {"total": 188, "additions": 55, "deletions": 133}, "files": [{"sha": "eb5df697216a362bd15164efa26b39d8fcaa57b4", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -726,10 +726,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             return anon_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n-        let ty_var = infcx.next_ty_var(\n-            ty::UniverseIndex::ROOT,\n-            TypeVariableOrigin::TypeInference(span),\n-        );\n+        let ty_var = infcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n \n         let predicates_of = tcx.predicates_of(def_id);\n         let bounds = predicates_of.instantiate(tcx, substs);"}, {"sha": "c2167751a27e7d099ec527fa2104357b27ddb6bf", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -407,7 +407,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             drop(variables);\n                             self.relate(&u, &u)\n                         }\n-                        TypeVariableValue::Unknown { universe } => {\n+                        TypeVariableValue::Unknown { .. } => {\n                             match self.ambient_variance {\n                                 // Invariant: no need to make a fresh type variable.\n                                 ty::Invariant => return Ok(t),\n@@ -424,7 +424,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             }\n \n                             let origin = *variables.var_origin(vid);\n-                            let new_var_id = variables.new_var(universe, false, origin);\n+                            let new_var_id = variables.new_var(false, origin);\n                             let u = self.tcx().mk_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);"}, {"sha": "961dd70a4685204b927909c1738f9f3463b73b6b", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -141,11 +141,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n                         // This variable was created during the\n                         // fudging. Recreate it with a fresh variable\n                         // here.\n-                        //\n-                        // The ROOT universe is fine because we only\n-                        // ever invoke this routine at the\n-                        // \"item-level\" of inference.\n-                        self.infcx.next_ty_var(ty::UniverseIndex::ROOT, origin)\n+                        self.infcx.next_ty_var(origin)\n                     }\n                 }\n             }"}, {"sha": "28aba51ab372468b403f4ff62525bb9d176db1c4", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -88,17 +88,13 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n         // is (e.g.) `Box<i32>`. A more obvious solution might be to\n         // iterate on the subtype obligations that are returned, but I\n         // think this suffices. -nmatsakis\n-        (&ty::TyInfer(TyVar(a_vid)), _) => {\n-            let universe = infcx.type_variables.borrow_mut().probe(a_vid).universe().unwrap();\n-            let v = infcx.next_ty_var(universe,\n-                                      TypeVariableOrigin::LatticeVariable(this.cause().span));\n+        (&ty::TyInfer(TyVar(..)), _) => {\n+            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, b, a)?;\n             Ok(v)\n         }\n-        (_, &ty::TyInfer(TyVar(b_vid))) => {\n-            let universe = infcx.type_variables.borrow_mut().probe(b_vid).universe().unwrap();\n-            let v = infcx.next_ty_var(universe,\n-                                      TypeVariableOrigin::LatticeVariable(this.cause().span));\n+        (_, &ty::TyInfer(TyVar(..))) => {\n+            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)\n         }"}, {"sha": "032a5c59d2dcaac063b1e11b2687fab781ad75b9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -837,22 +837,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self,\n-                          universe: ty::UniverseIndex,\n-                          diverging: bool,\n-                          origin: TypeVariableOrigin)\n-                          -> TyVid {\n+    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(universe, diverging, origin)\n+            .new_var(diverging, origin)\n     }\n \n-    pub fn next_ty_var(&self, universe: ty::UniverseIndex, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(universe, false, origin))\n+    pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(false, origin))\n     }\n \n-    pub fn next_diverging_ty_var(&self, universe: ty::UniverseIndex, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(universe, true, origin))\n+    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(true, origin))\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -907,14 +903,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// use an inference variable for `C` with `[T, U]`\n     /// as the substitutions for the default, `(T, U)`.\n     pub fn type_var_for_def(&self,\n-                            universe: ty::UniverseIndex,\n                             span: Span,\n                             def: &ty::TypeParameterDef)\n                             -> Ty<'tcx> {\n         let ty_var_id = self.type_variables\n                             .borrow_mut()\n-                            .new_var(universe,\n-                                     false,\n+                            .new_var(false,\n                                      TypeVariableOrigin::TypeParameterDefinition(span, def.name));\n \n         self.tcx.mk_var(ty_var_id)\n@@ -923,14 +917,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n     pub fn fresh_substs_for_item(&self,\n-                                 universe: ty::UniverseIndex,\n                                  span: Span,\n                                  def_id: DefId)\n                                  -> &'tcx Substs<'tcx> {\n         Substs::for_item(self.tcx, def_id, |def, _| {\n             self.region_var_for_def(span, def)\n         }, |def, _| {\n-            self.type_var_for_def(universe, span, def)\n+            self.type_var_for_def(span, def)\n         })\n     }\n "}, {"sha": "91df6cabf3a8b88c4ae0e5a6a5b947a494638aa7", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -78,33 +78,17 @@ struct TypeVariableData {\n #[derive(Copy, Clone, Debug)]\n pub enum TypeVariableValue<'tcx> {\n     Known { value: Ty<'tcx> },\n-    Unknown { universe: ty::UniverseIndex },\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum ProbeTyValue<'tcx> {\n-    Ty(Ty<'tcx>),\n-    Vid(ty::TyVid),\n+    Unknown,\n }\n \n impl<'tcx> TypeVariableValue<'tcx> {\n-    /// If this value is known, returns the type it is known to be.\n-    /// Otherwise, `None`.\n     pub fn known(&self) -> Option<Ty<'tcx>> {\n         match *self {\n             TypeVariableValue::Unknown { .. } => None,\n             TypeVariableValue::Known { value } => Some(value),\n         }\n     }\n \n-    /// If this value is unknown, returns the universe, otherwise `None`.\n-    pub fn universe(&self) -> Option<ty::UniverseIndex> {\n-        match *self {\n-            TypeVariableValue::Unknown { universe } => Some(universe),\n-            TypeVariableValue::Known { .. } => None,\n-        }\n-    }\n-\n     pub fn is_unknown(&self) -> bool {\n         match *self {\n             TypeVariableValue::Unknown { .. } => true,\n@@ -197,11 +181,10 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///   The code in this module doesn't care, but it can be useful\n     ///   for improving error messages.\n     pub fn new_var(&mut self,\n-                   universe: ty::UniverseIndex,\n                    diverging: bool,\n                    origin: TypeVariableOrigin)\n                    -> ty::TyVid {\n-        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown { universe });\n+        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown);\n \n         let sub_key = self.sub_relations.new_key(());\n         assert_eq!(eq_key.vid, sub_key);\n@@ -453,12 +436,8 @@ impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {\n             (&TypeVariableValue::Known { .. }, &TypeVariableValue::Unknown { .. }) => Ok(*value1),\n             (&TypeVariableValue::Unknown { .. }, &TypeVariableValue::Known { .. }) => Ok(*value2),\n \n-            // If both sides are unknown, we need to pick the most restrictive universe.\n-            (&TypeVariableValue::Unknown { universe: universe1 },\n-             &TypeVariableValue::Unknown { universe: universe2 }) => {\n-                let universe = cmp::min(universe1, universe2);\n-                Ok(TypeVariableValue::Unknown { universe })\n-            }\n+            // If both sides are *unknown*, it hardly matters, does it?\n+            (&TypeVariableValue::Unknown, &TypeVariableValue::Unknown) => Ok(*value1),\n         }\n     }\n }"}, {"sha": "31f8af1f96872a94189d9e9e0ef32da0e801d285", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -92,9 +92,7 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n                                        -> ty::ImplHeader<'tcx>\n {\n     let tcx = selcx.tcx();\n-    let impl_substs = selcx.infcx().fresh_substs_for_item(param_env.universe,\n-                                                          DUMMY_SP,\n-                                                          impl_def_id);\n+    let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n \n     let header = ty::ImplHeader {\n         impl_def_id,"}, {"sha": "1671f5b3876e7375ff835c5c52ce506b788ccddf", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -292,9 +292,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.for_each_relevant_impl(\n             trait_ref.def_id, trait_self_ty, |def_id| {\n-                let impl_substs = self.fresh_substs_for_item(param_env.universe,\n-                                                             obligation.cause.span,\n-                                                             def_id);\n+                let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n                 let impl_trait_ref = tcx\n                     .impl_trait_ref(def_id)\n                     .unwrap()\n@@ -1272,7 +1270,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                            -> bool {\n         struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-            param_env: ty::ParamEnv<'tcx>,\n             var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n         }\n \n@@ -1282,14 +1279,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::TyParam(ty::ParamTy {name, ..}) = ty.sty {\n                     let infcx = self.infcx;\n-                    let param_env = self.param_env;\n-                    self.var_map\n-                        .entry(ty)\n-                        .or_insert_with(|| {\n-                            let origin = TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP,\n-                                                                                     name);\n-                            infcx.next_ty_var(param_env.universe, origin)\n-                        })\n+                    self.var_map.entry(ty).or_insert_with(||\n+                        infcx.next_ty_var(\n+                            TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP, name)))\n                 } else {\n                     ty.super_fold_with(self)\n                 }\n@@ -1301,7 +1293,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n                 infcx: self,\n-                param_env,\n                 var_map: FxHashMap()\n             });\n "}, {"sha": "2a62d0b5ee39a282db94d4fd89611ce153e45d4e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -477,7 +477,6 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             let tcx = selcx.infcx().tcx;\n             let def_id = projection_ty.item_def_id;\n             let ty_var = selcx.infcx().next_ty_var(\n-                param_env.universe,\n                 TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n             let projection = ty::Binder(ty::ProjectionPredicate {\n                 projection_ty,\n@@ -798,7 +797,6 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n     let tcx = selcx.infcx().tcx;\n     let def_id = projection_ty.item_def_id;\n     let new_value = selcx.infcx().next_ty_var(\n-        param_env.universe,\n         TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n     Normalized {\n         value: new_value,"}, {"sha": "57e1ed571f79094de3234e930d359817382589f4", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -3045,8 +3045,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             snapshot);\n         let skol_obligation_trait_ref = skol_obligation.trait_ref;\n \n-        let impl_substs = self.infcx.fresh_substs_for_item(obligation.param_env.universe,\n-                                                           obligation.cause.span,\n+        let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span,\n                                                            impl_def_id);\n \n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),"}, {"sha": "2be1258f1c9f53eb13380dc7ff45ccbe1e48dcc2", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -221,7 +221,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n     let selcx = &mut SelectionContext::new(&infcx);\n-    let target_substs = infcx.fresh_substs_for_item(param_env.universe, DUMMY_SP, target_impl);\n+    let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n     let (target_trait_ref, mut obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                        param_env,\n                                                                        target_impl,"}, {"sha": "a2f9e629594b7b62c76309a75296077277cb8918", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -329,7 +329,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let element_tys_iter = (0..max_len).map(|_| self.next_ty_var(\n                     // FIXME: MiscVariable for now, obtaining the span and name information\n                     //       from all tuple elements isn't trivial.\n-                    ty::UniverseIndex::ROOT,\n                     TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n                 let pat_ty = tcx.mk_ty(ty::TyTuple(element_tys));\n@@ -340,8 +339,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 pat_ty\n             }\n             PatKind::Box(ref inner) => {\n-                let inner_ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                                TypeVariableOrigin::TypeInference(inner.span));\n+                let inner_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(inner.span));\n                 let uniq_ty = tcx.mk_box(inner_ty);\n \n                 if self.check_dereferencable(pat.span, expected, &inner) {\n@@ -374,7 +372,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                         _ => {\n                             let inner_ty = self.next_ty_var(\n-                                ty::UniverseIndex::ROOT,\n                                 TypeVariableOrigin::TypeInference(inner.span));\n                             let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n                             let region = self.next_region_var(infer::PatternRegion(pat.span));\n@@ -633,8 +630,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             // ...but otherwise we want to use any supertype of the\n             // discriminant. This is sort of a workaround, see note (*) in\n             // `check_pat` for some details.\n-            discrim_ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                          TypeVariableOrigin::TypeInference(discrim.span));\n+            discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n             self.check_expr_has_type_or_error(discrim, discrim_ty);\n         };\n \n@@ -695,8 +691,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 // arm for inconsistent arms or to the whole match when a `()` type\n                 // is required).\n                 Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => ety,\n-                _ => self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                      TypeVariableOrigin::MiscVariable(expr.span)),\n+                _ => self.next_ty_var(TypeVariableOrigin::MiscVariable(expr.span)),\n             };\n             CoerceMany::with_coercion_sites(coerce_first, arms)\n         };"}, {"sha": "68b0560355fc3d4ca40c03760eeb2c8bc4199862", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -110,8 +110,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             |_, _| span_bug!(expr.span, \"closure has region param\"),\n             |_, _| {\n                 self.infcx\n-                    .next_ty_var(ty::UniverseIndex::ROOT,\n-                                 TypeVariableOrigin::ClosureSynthetic(expr.span))\n+                    .next_ty_var(TypeVariableOrigin::ClosureSynthetic(expr.span))\n             },\n         );\n         let substs = ty::ClosureSubsts { substs };"}, {"sha": "bc8f107951b144c54ff4d9af452a4c9a285917cf", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -176,7 +176,6 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 // micro-optimization: no need for this if `b` is\n                 // already resolved in some way.\n                 let diverging_ty = self.next_diverging_ty_var(\n-                    ty::UniverseIndex::ROOT,\n                     TypeVariableOrigin::AdjustmentType(self.cause.span));\n                 self.unify_and(&b, &diverging_ty, simple(Adjust::NeverToAny))\n             } else {\n@@ -510,7 +509,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // We only have the latter, so we use an inference variable\n         // for the former and let type inference do the rest.\n         let origin = TypeVariableOrigin::MiscVariable(self.cause.span);\n-        let coerce_target = self.next_ty_var(ty::UniverseIndex::ROOT, origin);\n+        let coerce_target = self.next_ty_var(origin);\n         let mut coercion = self.unify_and(coerce_target, target, |target| {\n             let unsize = Adjustment {\n                 kind: Adjust::Unsize,"}, {"sha": "eeaf9e4973237c9999cfa57e54332e8789766f27", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -90,7 +90,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n         let drop_impl_span = tcx.def_span(drop_impl_did);\n         let fresh_impl_substs =\n-            infcx.fresh_substs_for_item(ty::UniverseIndex::ROOT, drop_impl_span, drop_impl_did);\n+            infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);"}, {"sha": "a3233c8d8659958b86161627cb164d88d9ea1906", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -259,7 +259,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 // the process we will unify the transformed-self-type\n                 // of the method with the actual type in order to\n                 // unify some of these variables.\n-                self.fresh_substs_for_item(ty::UniverseIndex::ROOT, self.span, trait_def_id)\n+                self.fresh_substs_for_item(self.span, trait_def_id)\n             }\n \n             probe::WhereClausePick(ref poly_trait_ref) => {\n@@ -336,7 +336,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             {\n                 self.to_ty(ast_ty)\n             } else {\n-                self.type_var_for_def(ty::UniverseIndex::ROOT, self.span, def)\n+                self.type_var_for_def(self.span, def)\n             }\n         })\n     }"}, {"sha": "82ac87672cf9ba4674746f913af194dd8699bf4c", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -257,7 +257,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             } else if let Some(ref input_types) = opt_input_types {\n                 input_types[def.index as usize - 1]\n             } else {\n-                self.type_var_for_def(ty::UniverseIndex::ROOT, span, def)\n+                self.type_var_for_def(span, def)\n             }\n         });\n "}, {"sha": "b68b6ab28dd9b2c4b9e1e49058e3c59f0bbae3b8", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -729,9 +729,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             Def::Method(def_id) => {\n                 let fty = self.tcx.fn_sig(def_id);\n                 self.probe(|_| {\n-                    let substs = self.fresh_substs_for_item(ty::UniverseIndex::ROOT,\n-                                                            self.span,\n-                                                            method.def_id);\n+                    let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                     let fty = fty.subst(self.tcx, substs);\n                     let (fty, _) = self.replace_late_bound_regions_with_fresh_var(\n                         self.span, infer::FnCall, &fty);\n@@ -1310,7 +1308,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 if i < substs.len() {\n                     substs.type_at(i)\n                 } else {\n-                    self.type_var_for_def(ty::UniverseIndex::ROOT, self.span, def)\n+                    self.type_var_for_def(self.span, def)\n                 }\n             });\n             xform_fn_sig.subst(self.tcx, substs)\n@@ -1327,7 +1325,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                          def_id,\n                          |_, _| self.tcx.types.re_erased,\n                          |_, _| self.next_ty_var(\n-                             ty::UniverseIndex::ROOT,\n                              TypeVariableOrigin::SubstitutionPlaceholder(\n                                  self.tcx.def_span(def_id))))\n     }"}, {"sha": "ed4506747681b7b6f61a8de9924c49138a00631c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -54,8 +54,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.autoderef(span, ty).any(|(ty, _)| {\n                     self.probe(|_| {\n                         let fn_once_substs = tcx.mk_substs_trait(ty,\n-                            &[self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                               TypeVariableOrigin::MiscVariable(span))]);\n+                            &[self.next_ty_var(TypeVariableOrigin::MiscVariable(span))]);\n                         let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                         let obligation ="}, {"sha": "84985c2c08be9981f45e3423f62972283b11a312", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -362,8 +362,7 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     /// hard constraint exists, creates a fresh type variable.\n     fn coercion_target_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, span: Span) -> Ty<'tcx> {\n         self.only_has_type(fcx)\n-            .unwrap_or_else(|| fcx.next_ty_var(ty::UniverseIndex::ROOT,\n-                                               TypeVariableOrigin::MiscVariable(span)))\n+            .unwrap_or_else(|| fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span)))\n     }\n }\n \n@@ -938,8 +937,7 @@ impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n-                let var_ty = self.fcx.next_ty_var(ty::UniverseIndex::ROOT,\n-                                                  TypeVariableOrigin::TypeInference(span));\n+                let var_ty = self.fcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n                 self.fcx.locals.borrow_mut().insert(nid, var_ty);\n                 var_ty\n             }\n@@ -1043,8 +1041,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     let span = body.value.span;\n \n     if body.is_generator && can_be_generator.is_some() {\n-        let yield_ty = fcx.next_ty_var(ty::UniverseIndex::ROOT,\n-                                       TypeVariableOrigin::TypeInference(span));\n+        let yield_ty = fcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n         fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n         fcx.yield_ty = Some(yield_ty);\n     }\n@@ -1077,8 +1074,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // This ensures that all nested generators appear before the entry of this generator.\n     // resolve_generator_interiors relies on this property.\n     let gen_ty = if can_be_generator.is_some() && body.is_generator {\n-        let witness = fcx.next_ty_var(ty::UniverseIndex::ROOT,\n-                                      TypeVariableOrigin::MiscVariable(span));\n+        let witness = fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n         let interior = ty::GeneratorInterior {\n             witness,\n             movable: can_be_generator.unwrap() == hir::GeneratorMovability::Movable,\n@@ -1116,7 +1112,6 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     let mut actual_return_ty = coercion.complete(&fcx);\n     if actual_return_ty.is_never() {\n         actual_return_ty = fcx.next_diverging_ty_var(\n-            ty::UniverseIndex::ROOT,\n             TypeVariableOrigin::DivergingFn(span));\n     }\n     fcx.demand_suptype(span, ret_ty, actual_return_ty);\n@@ -1710,14 +1705,13 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.next_ty_var(ty::UniverseIndex::ROOT,\n-                         TypeVariableOrigin::TypeInference(span))\n+        self.next_ty_var(TypeVariableOrigin::TypeInference(span))\n     }\n \n     fn ty_infer_for_def(&self,\n                         ty_param_def: &ty::TypeParameterDef,\n                         span: Span) -> Ty<'tcx> {\n-        self.type_var_for_def(ty::UniverseIndex::ROOT, span, ty_param_def)\n+        self.type_var_for_def(span, ty_param_def)\n     }\n \n     fn projected_ty_from_poly_trait_ref(&self,\n@@ -2342,8 +2336,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // If some lookup succeeds, write callee into table and extract index/element\n             // type from the method signature.\n             // If some lookup succeeded, install method in table\n-            let input_ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                            TypeVariableOrigin::AutoDeref(base_expr.span));\n+            let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n             let method = self.try_overloaded_place_op(\n                 expr.span, self_ty, &[input_ty], needs, PlaceOp::Index);\n \n@@ -2782,7 +2775,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             assert!(!self.tables.borrow().adjustments().contains_key(expr.hir_id),\n                     \"expression with never type wound up being adjusted\");\n             let adj_ty = self.next_diverging_ty_var(\n-                ty::UniverseIndex::ROOT,\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n             self.apply_adjustments(expr, vec![Adjustment {\n                 kind: Adjust::NeverToAny,\n@@ -2860,7 +2852,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let ity = self.tcx.type_of(did);\n         debug!(\"impl_self_ty: ity={:?}\", ity);\n \n-        let substs = self.fresh_substs_for_item(ty::UniverseIndex::ROOT, span, did);\n+        let substs = self.fresh_substs_for_item(span, did);\n         let substd_ty = self.instantiate_type_scheme(span, &substs, &ity);\n \n         TypeAndSubsts { substs: substs, ty: substd_ty }\n@@ -3993,8 +3985,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n               let element_ty = if !args.is_empty() {\n                   let coerce_to = uty.unwrap_or_else(\n-                      || self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                          TypeVariableOrigin::TypeInference(expr.span)));\n+                      || self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span)));\n                   let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n                   assert_eq!(self.diverges.get(), Diverges::Maybe);\n                   for e in args {\n@@ -4004,8 +3995,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   }\n                   coerce.complete(self)\n               } else {\n-                  self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                   TypeVariableOrigin::TypeInference(expr.span))\n+                  self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n               };\n               tcx.mk_array(element_ty, args.len() as u64)\n           }\n@@ -4045,8 +4035,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     (uty, uty)\n                 }\n                 None => {\n-                    let t: Ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                                 TypeVariableOrigin::MiscVariable(element.span));\n+                    let t: Ty = self.next_ty_var(TypeVariableOrigin::MiscVariable(element.span));\n                     let element_ty = self.check_expr_has_type_or_error(&element, t);\n                     (element_ty, t)\n                 }\n@@ -4825,7 +4814,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Handle Self first, so we can adjust the index to match the AST.\n                 if has_self && i == 0 {\n                     return opt_self_ty.unwrap_or_else(|| {\n-                        self.type_var_for_def(ty::UniverseIndex::ROOT, span, def)\n+                        self.type_var_for_def(span, def)\n                     });\n                 }\n                 i -= has_self as usize;\n@@ -4858,7 +4847,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // This can also be reached in some error cases:\n                 // We prefer to use inference variables instead of\n                 // TyError to let type inference recover somewhat.\n-                self.type_var_for_def(ty::UniverseIndex::ROOT, span, def)\n+                self.type_var_for_def(span, def)\n             }\n         });\n "}, {"sha": "faebb370a6c46eb5a07ff285c3c051d1a2c258c7", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6935e57f145697845c2aa744c2a576df8982000/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=c6935e57f145697845c2aa744c2a576df8982000", "patch": "@@ -174,10 +174,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // trait matching creating lifetime constraints that are too strict.\n         // E.g. adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n         // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n-        let lhs_ty = self.check_expr_coercable_to_type_with_needs(\n-            lhs_expr,\n-            self.next_ty_var(ty::UniverseIndex::ROOT,\n-                             TypeVariableOrigin::MiscVariable(lhs_expr.span)),\n+        let lhs_ty = self.check_expr_coercable_to_type_with_needs(lhs_expr,\n+            self.next_ty_var(TypeVariableOrigin::MiscVariable(lhs_expr.span)),\n             lhs_needs);\n         let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n \n@@ -187,8 +185,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // using this variable as the expected type, which sometimes lets\n         // us do better coercions than we would be able to do otherwise,\n         // particularly for things like `String + &String`.\n-        let rhs_ty_var = self.next_ty_var(ty::UniverseIndex::ROOT,\n-                         TypeVariableOrigin::MiscVariable(rhs_expr.span));\n+        let rhs_ty_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(rhs_expr.span));\n \n         let result = self.lookup_op_method(lhs_ty, &[rhs_ty_var], Op::Binary(op, is_assign));\n "}]}