{"sha": "e43729ccf2577fad114107a336099da75eff0ded", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MzcyOWNjZjI1NzdmYWQxMTQxMDdhMzM2MDk5ZGE3NWVmZjBkZWQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-03T21:36:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-03T21:41:05Z"}, "message": "rustc: Refactor metadata.Encode.* to not require a type abbreviation table if abbreviation isn't enabled", "tree": {"sha": "0ef063c28fc51eae95db8a0ebbb9c0c015ee864c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ef063c28fc51eae95db8a0ebbb9c0c015ee864c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e43729ccf2577fad114107a336099da75eff0ded", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e43729ccf2577fad114107a336099da75eff0ded", "html_url": "https://github.com/rust-lang/rust/commit/e43729ccf2577fad114107a336099da75eff0ded", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e43729ccf2577fad114107a336099da75eff0ded/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f317ede41d69a8fd5e1690c4ed509a4e826ea11", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f317ede41d69a8fd5e1690c4ed509a4e826ea11", "html_url": "https://github.com/rust-lang/rust/commit/3f317ede41d69a8fd5e1690c4ed509a4e826ea11"}], "stats": {"total": 98, "additions": 53, "deletions": 45}, "files": [{"sha": "2b4ad2a2f64cf61b620ec75e8c6a6f274be23903", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e43729ccf2577fad114107a336099da75eff0ded/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43729ccf2577fad114107a336099da75eff0ded/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=e43729ccf2577fad114107a336099da75eff0ded", "patch": "@@ -53,59 +53,72 @@ const uint tag_index_table = 0x15u;\n \n type ty_abbrev = rec(uint pos, uint len, str s);\n \n+tag abbrev_ctxt {\n+    ac_no_abbrevs;\n+    ac_use_abbrevs(hashmap[ty.t, ty_abbrev]);\n+}\n+\n mod Encode {\n \n     type ctxt = rec(\n         fn(ast.def_id) -> str ds,           // Def -> str Callback.\n         ty.ctxt tcx,                        // The type context.\n-        bool use_abbrevs,\n-        hashmap[ty.t, ty_abbrev] abbrevs    // Type abbrevs.\n+        abbrev_ctxt abbrevs\n     );\n \n+    fn cx_uses_abbrevs(@ctxt cx) -> bool {\n+        alt (cx.abbrevs) {\n+            case (ac_no_abbrevs)     { ret false; }\n+            case (ac_use_abbrevs(_)) { ret true; }\n+        }\n+    }\n+\n     fn ty_str(@ctxt cx, ty.t t) -> str {\n-        assert (! cx.use_abbrevs);\n+        assert (!cx_uses_abbrevs(cx));\n         auto sw = io.string_writer();\n         enc_ty(sw.get_writer(), cx, t);\n         ret sw.get_str();\n     }\n \n     fn enc_ty(io.writer w, @ctxt cx, ty.t t) {\n-        if (cx.use_abbrevs) {\n-            alt (cx.abbrevs.find(t)) {\n-                case (some[ty_abbrev](?a)) {\n-                    w.write_str(a.s);\n-                    ret;\n-                }\n-                case (none[ty_abbrev]) {\n-                    auto pos = w.get_buf_writer().tell();\n-                    auto ss = enc_sty(w, cx, ty.struct(cx.tcx, t));\n-                    auto end = w.get_buf_writer().tell();\n-                    auto len = end-pos;\n-                    fn estimate_sz(uint u) -> uint {\n-                        auto n = u;\n-                        auto len = 0u;\n-                        while (n != 0u) {\n-                            len += 1u;\n-                            n = n >> 4u;\n-                        }\n-                        ret len;\n+        alt (cx.abbrevs) {\n+            case (ac_no_abbrevs) { enc_sty(w, cx, ty.struct(cx.tcx, t)); }\n+            case (ac_use_abbrevs(?abbrevs)) {\n+                alt (abbrevs.find(t)) {\n+                    case (some[ty_abbrev](?a)) {\n+                        w.write_str(a.s);\n+                        ret;\n                     }\n-                    auto abbrev_len =\n-                        3u + estimate_sz(pos) + estimate_sz(len);\n-\n-                    if (abbrev_len < len) {\n-                        // I.e. it's actually an abbreviation.\n-                        auto s = (\"#\"\n-                                  + _uint.to_str(pos, 16u) + \":\"\n-                                  + _uint.to_str(len, 16u) + \"#\");\n-                        auto a = rec(pos=pos, len=len, s=s);\n-                        cx.abbrevs.insert(t, a);\n+                    case (none[ty_abbrev]) {\n+                        auto pos = w.get_buf_writer().tell();\n+                        auto ss = enc_sty(w, cx, ty.struct(cx.tcx, t));\n+                        auto end = w.get_buf_writer().tell();\n+                        auto len = end-pos;\n+                        fn estimate_sz(uint u) -> uint {\n+                            auto n = u;\n+                            auto len = 0u;\n+                            while (n != 0u) {\n+                                len += 1u;\n+                                n = n >> 4u;\n+                            }\n+                            ret len;\n+                        }\n+                        auto abbrev_len =\n+                            3u + estimate_sz(pos) + estimate_sz(len);\n+\n+                        if (abbrev_len < len) {\n+                            // I.e. it's actually an abbreviation.\n+                            auto s = (\"#\"\n+                                      + _uint.to_str(pos, 16u) + \":\"\n+                                      + _uint.to_str(len, 16u) + \"#\");\n+                            auto a = rec(pos=pos, len=len, s=s);\n+                            abbrevs.insert(t, a);\n+                        }\n+                        ret;\n                     }\n-                    ret;\n                 }\n             }\n         }\n-        enc_sty(w, cx, ty.struct(cx.tcx, t));\n     }\n \n     fn enc_mt(io.writer w, @ctxt cx, &ty.mt mt) {\n@@ -406,7 +419,7 @@ fn encode_type(@trans.crate_ctxt cx, &ebml.writer ebml_w, ty.t typ) {\n \n     auto f = def_to_str;\n     auto ty_str_ctxt = @rec(ds=f, tcx=cx.tcx,\n-                            use_abbrevs=true, abbrevs=cx.type_abbrevs);\n+                            abbrevs=ac_use_abbrevs(cx.type_abbrevs));\n     Encode.enc_ty(io.new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n     ebml.end_tag(ebml_w);\n }"}, {"sha": "288624daabc2402ae786a79a404d93f37987cdbf", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e43729ccf2577fad114107a336099da75eff0ded/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43729ccf2577fad114107a336099da75eff0ded/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e43729ccf2577fad114107a336099da75eff0ded", "patch": "@@ -193,8 +193,7 @@ fn get_type_sha1(@crate_ctxt ccx, ty.t t) -> str {\n             auto f = metadata.def_to_str;\n             // NB: do *not* use abbrevs here as we want the symbol names\n             // to be independent of one another in the crate.\n-            auto cx = @rec(ds=f, tcx=ccx.tcx,\n-                           use_abbrevs=false, abbrevs=ccx.type_abbrevs);\n+            auto cx = @rec(ds=f, tcx=ccx.tcx, abbrevs=metadata.ac_no_abbrevs);\n             ccx.sha.input_str(metadata.Encode.ty_str(cx, t));\n             hash = _str.substr(ccx.sha.result_str(), 0u, 16u);\n             ccx.type_sha1s.insert(t, hash);\n@@ -210,8 +209,7 @@ fn mangle_name_by_type(@crate_ctxt ccx, vec[str] path, ty.t t) -> str {\n \n fn mangle_name_by_type_only(@crate_ctxt ccx, ty.t t, str name) -> str {\n     auto f = metadata.def_to_str;\n-    auto cx = @rec(ds=f, tcx=ccx.tcx,\n-                   use_abbrevs=false, abbrevs=ccx.type_abbrevs);\n+    auto cx = @rec(ds=f, tcx=ccx.tcx, abbrevs=metadata.ac_no_abbrevs);\n     auto s = metadata.Encode.ty_str(cx, t);\n \n     auto hash = get_type_sha1(ccx, t);\n@@ -816,9 +814,7 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n     }\n \n     assert (llty as int != 0);\n-    llvm.LLVMAddTypeName(cx.llmod,\n-                         _str.buf(ty.ty_to_short_str(cx.tcx,\n-                                                     cx.type_abbrevs, t)),\n+    llvm.LLVMAddTypeName(cx.llmod, _str.buf(ty.ty_to_short_str(cx.tcx, t)),\n                          llty);\n     cx.lltypes.insert(t, llty);\n     ret llty;"}, {"sha": "c5e5ffa3a6e46316d849083359ee764c0bac202e", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e43729ccf2577fad114107a336099da75eff0ded/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e43729ccf2577fad114107a336099da75eff0ded/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=e43729ccf2577fad114107a336099da75eff0ded", "patch": "@@ -648,10 +648,9 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n     ret s;\n }\n \n-fn ty_to_short_str(ctxt cx, hashmap[ty.t, metadata.ty_abbrev] abbrevs,\n-                   t typ) -> str {\n+fn ty_to_short_str(ctxt cx, t typ) -> str {\n     auto f = def_to_str;\n-    auto ecx = @rec(ds=f, tcx=cx,  use_abbrevs=false, abbrevs=abbrevs);\n+    auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata.ac_no_abbrevs);\n     auto s = metadata.Encode.ty_str(ecx, typ);\n     if (_str.byte_len(s) >= 64u) { s = _str.substr(s, 0u, 64u); }\n     ret s;"}]}