{"sha": "8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ODY1NzFhMTBjZTU3YjAyYWUxOWJmYjFiMzE3MzZmYjJhMWI0ZmU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-08-25T13:45:24Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-08-27T10:09:32Z"}, "message": "rustc_target: rename `TyAndLayoutMethods` to `TyAbiInterface`.", "tree": {"sha": "c96cb8d4fc958744e53863191b1d93b0fd65fdbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c96cb8d4fc958744e53863191b1d93b0fd65fdbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "html_url": "https://github.com/rust-lang/rust/commit/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83d986aa28619820e446279c5304a1ea2bd587e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/83d986aa28619820e446279c5304a1ea2bd587e0", "html_url": "https://github.com/rust-lang/rust/commit/83d986aa28619820e446279c5304a1ea2bd587e0"}], "stats": {"total": 155, "additions": 84, "deletions": 71}, "files": [{"sha": "9818905464dce4e8ba8b0d2e6d29f7d233737e99", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Ty, TypeFoldable};\n use rustc_target::abi::{Abi, AddressSpace, Align, FieldsShape};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n-use rustc_target::abi::{LayoutOf, PointeeInfo, Scalar, Size, TyAndLayoutMethods, Variants};\n+use rustc_target::abi::{LayoutOf, PointeeInfo, Scalar, Size, TyAbiInterface, Variants};\n use smallvec::{smallvec, SmallVec};\n use tracing::debug;\n \n@@ -393,12 +393,15 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n         }\n     }\n \n+    // FIXME(eddyb) this having the same name as `TyAndLayout::pointee_info_at`\n+    // (the inherent method, which is lacking this caching logic) can result in\n+    // the uncached version being called - not wrong, but potentially inefficient.\n     fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size) -> Option<PointeeInfo> {\n         if let Some(&pointee) = cx.pointee_infos.borrow().get(&(self.ty, offset)) {\n             return pointee;\n         }\n \n-        let result = Ty::pointee_info_at(*self, cx, offset);\n+        let result = Ty::ty_and_layout_pointee_info_at(*self, cx, offset);\n \n         cx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n         result"}, {"sha": "d8d1f4929adbfa9d9309ce3c166e91169d5be08f", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -2078,11 +2078,11 @@ impl LayoutOf<'tcx> for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx>> {\n     }\n }\n \n-impl<'tcx, C> TyAndLayoutMethods<'tcx, C> for Ty<'tcx>\n+impl<'tcx, C> TyAbiInterface<'tcx, C> for Ty<'tcx>\n where\n     C: LayoutOf<'tcx, Ty = Ty<'tcx>> + HasTyCtxt<'tcx> + HasParamEnv<'tcx>,\n {\n-    fn for_variant(\n+    fn ty_and_layout_for_variant(\n         this: TyAndLayout<'tcx>,\n         cx: &C,\n         variant_index: VariantIdx,\n@@ -2132,7 +2132,7 @@ where\n         TyAndLayout { ty: this.ty, layout }\n     }\n \n-    fn field(this: TyAndLayout<'tcx>, cx: &C, i: usize) -> C::TyAndLayout {\n+    fn ty_and_layout_field(this: TyAndLayout<'tcx>, cx: &C, i: usize) -> C::TyAndLayout {\n         enum TyMaybeWithLayout<'tcx, C: LayoutOf<'tcx>> {\n             Ty(C::Ty),\n             TyAndLayout(C::TyAndLayout),\n@@ -2276,7 +2276,11 @@ where\n         })\n     }\n \n-    fn pointee_info_at(this: TyAndLayout<'tcx>, cx: &C, offset: Size) -> Option<PointeeInfo> {\n+    fn ty_and_layout_pointee_info_at(\n+        this: TyAndLayout<'tcx>,\n+        cx: &C,\n+        offset: Size,\n+    ) -> Option<PointeeInfo> {\n         let addr_space_of_ty = |ty: Ty<'tcx>| {\n             if ty.is_fn() { cx.data_layout().instruction_address_space } else { AddressSpace::DATA }\n         };"}, {"sha": "3d5ca0daca628d92db9df9c7123470df358b123b", "filename": "compiler/rustc_target/src/abi/call/aarch64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Faarch64.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -1,9 +1,9 @@\n use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n@@ -26,7 +26,7 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n@@ -48,7 +48,7 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n@@ -70,7 +70,7 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {"}, {"sha": "289de14068785d2891f115810db51f08fde4ffe4", "filename": "compiler/rustc_target/src/abi/call/amdgpu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Famdgpu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Famdgpu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Famdgpu.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -1,25 +1,25 @@\n use crate::abi::call::{ArgAbi, FnAbi};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n \n fn classify_ret<'a, Ty, C>(_cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     ret.extend_integer_width_to(32);\n }\n \n fn classify_arg<'a, Ty, C>(_cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.extend_integer_width_to(32);\n }\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {"}, {"sha": "4498beaa2dd2777ee6041f5c58e5ec9e8c03f646", "filename": "compiler/rustc_target/src/abi/call/arm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Farm.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -1,10 +1,10 @@\n use crate::abi::call::{ArgAbi, Conv, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n use crate::spec::HasTargetSpec;\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n@@ -27,7 +27,7 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>, vfp: bool)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n@@ -53,7 +53,7 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, vfp: bool)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n@@ -75,7 +75,7 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n {\n     // If this is a target with a hard-float ABI, and the function is not explicitly"}, {"sha": "99e70f216b24a7005704a3724ed24597d948a494", "filename": "compiler/rustc_target/src/abi/call/mips64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n-use crate::abi::{self, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{self, HasDataLayout, LayoutOf, Size, TyAbiInterface, TyAndLayout};\n \n fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n     // Always sign extend u32 values on 64-bit mips\n@@ -19,7 +19,7 @@ fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n \n fn float_reg<'a, Ty, C>(cx: &C, ret: &ArgAbi<'a, Ty>, i: usize) -> Option<Reg>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     match ret.layout.field(cx, i).abi {\n@@ -34,7 +34,7 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n@@ -74,7 +74,7 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n@@ -144,7 +144,7 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {"}, {"sha": "3c0309973908f637697a21c0e22689964b15f86c", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::{self, Abi, Align, FieldsShape, Size};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n use crate::spec::{self, HasTargetSpec};\n \n mod aarch64;\n@@ -316,7 +316,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n     /// specific targets.\n     pub fn homogeneous_aggregate<C>(&self, cx: &C) -> Result<HomogeneousAggregate, Heterogeneous>\n     where\n-        Ty: TyAndLayoutMethods<'a, C> + Copy,\n+        Ty: TyAbiInterface<'a, C> + Copy,\n         C: LayoutOf<'a, Ty = Ty, TyAndLayout = Self>,\n     {\n         match self.abi {\n@@ -603,7 +603,7 @@ pub struct FnAbi<'a, Ty> {\n impl<'a, Ty> FnAbi<'a, Ty> {\n     pub fn adjust_for_cabi<C>(&mut self, cx: &C, abi: spec::abi::Abi) -> Result<(), String>\n     where\n-        Ty: TyAndLayoutMethods<'a, C> + Copy,\n+        Ty: TyAbiInterface<'a, C> + Copy,\n         C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n     {\n         if abi == spec::abi::Abi::X86Interrupt {"}, {"sha": "62570a87f19a2018b4764c6059b0df387e3ad6f3", "filename": "compiler/rustc_target/src/abi/call/powerpc64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc64.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -3,7 +3,7 @@\n // need to be fixed when PowerPC vector support is added.\n \n use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{Endian, HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{Endian, HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n use crate::spec::HasTargetSpec;\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n@@ -19,7 +19,7 @@ fn is_homogeneous_aggregate<'a, Ty, C>(\n     abi: ABI,\n ) -> Option<Uniform>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n@@ -43,7 +43,7 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>, abi: ABI)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n@@ -86,7 +86,7 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, abi: ABI)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n@@ -116,7 +116,7 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n {\n     let abi = if cx.target_spec().env == \"musl\" {"}, {"sha": "c29fc7a08c028083b4b94280bc1a049ed390962a", "filename": "compiler/rustc_target/src/abi/call/riscv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -6,7 +6,7 @@\n \n use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n use crate::abi::{\n-    self, Abi, FieldsShape, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods,\n+    self, Abi, FieldsShape, HasDataLayout, LayoutOf, Size, TyAbiInterface, TyAndLayout,\n };\n use crate::spec::HasTargetSpec;\n \n@@ -43,7 +43,7 @@ fn should_use_fp_conv_helper<'a, Ty, C>(\n     field2_kind: &mut RegPassKind,\n ) -> Result<(), CannotUseFpConv>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n {\n     match arg_layout.abi {\n@@ -130,7 +130,7 @@ fn should_use_fp_conv<'a, Ty, C>(\n     flen: u64,\n ) -> Option<FloatConv>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n {\n     let mut field1_kind = RegPassKind::Unknown;\n@@ -149,7 +149,7 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, xlen: u64, flen: u64) -> bool\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n {\n     if let Some(conv) = should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n@@ -212,7 +212,7 @@ fn classify_arg<'a, Ty, C>(\n     avail_gprs: &mut u64,\n     avail_fprs: &mut u64,\n ) where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>>,\n {\n     if !is_vararg {\n@@ -320,7 +320,7 @@ fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n {\n     let flen = match &cx.target_spec().llvm_abiname[..] {"}, {"sha": "bd4eff5e3217d4657aa6eb063b27cce0c79f1d12", "filename": "compiler/rustc_target/src/abi/call/s390x.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -2,7 +2,7 @@\n // for a pre-z13 machine or using -mno-vx.\n \n use crate::abi::call::{ArgAbi, FnAbi, Reg};\n-use crate::abi::{self, HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{self, HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n \n fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n     if !ret.layout.is_aggregate() && ret.layout.size.bits() <= 64 {\n@@ -14,7 +14,7 @@ fn classify_ret<Ty>(ret: &mut ArgAbi<'_, Ty>) {\n \n fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyAndLayout<'a, Ty>) -> bool\n where\n-    Ty: TyAndLayoutMethods<'a, C>,\n+    Ty: TyAbiInterface<'a, C>,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     match layout.abi {\n@@ -32,7 +32,7 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !arg.layout.is_aggregate() && arg.layout.size.bits() <= 64 {\n@@ -59,7 +59,7 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {"}, {"sha": "1fe7b74c2bcf9014b516ddfc903685730cdb2b54", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -1,11 +1,11 @@\n // FIXME: This needs an audit for correctness and completeness.\n \n use crate::abi::call::{ArgAbi, FnAbi, Reg, RegKind, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n \n fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n@@ -26,7 +26,7 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !ret.layout.is_aggregate() {\n@@ -52,7 +52,7 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !arg.layout.is_aggregate() {\n@@ -76,7 +76,7 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {"}, {"sha": "7f607ebead1d51172cd496c30f6778a8dedeff00", "filename": "compiler/rustc_target/src/abi/call/wasm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -1,9 +1,9 @@\n use crate::abi::call::{ArgAbi, FnAbi, Uniform};\n-use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n \n fn unwrap_trivial_aggregate<'a, Ty, C>(cx: &C, val: &mut ArgAbi<'a, Ty>) -> bool\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if val.layout.is_aggregate() {\n@@ -20,7 +20,7 @@ where\n \n fn classify_ret<'a, Ty, C>(cx: &C, ret: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     ret.extend_integer_width_to(32);\n@@ -31,7 +31,7 @@ where\n \n fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     arg.extend_integer_width_to(32);\n@@ -43,7 +43,7 @@ where\n /// The purpose of this ABI is to match the C ABI (aka clang) exactly.\n pub fn compute_c_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     if !fn_abi.ret.is_ignore() {"}, {"sha": "41e9e84206171980e03023dc934b8e6d66e0e07a", "filename": "compiler/rustc_target/src/abi/call/x86.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -1,5 +1,5 @@\n use crate::abi::call::{ArgAttribute, FnAbi, PassMode, Reg, RegKind};\n-use crate::abi::{self, HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{self, HasDataLayout, LayoutOf, TyAbiInterface, TyAndLayout};\n use crate::spec::HasTargetSpec;\n \n #[derive(PartialEq)]\n@@ -10,7 +10,7 @@ pub enum Flavor {\n \n fn is_single_fp_element<'a, Ty, C>(cx: &C, layout: TyAndLayout<'a, Ty>) -> bool\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     match layout.abi {\n@@ -28,7 +28,7 @@ where\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>, flavor: Flavor)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n {\n     if !fn_abi.ret.is_ignore() {"}, {"sha": "9146839b086a8a00b95144d985ededde0583b987", "filename": "compiler/rustc_target/src/abi/call/x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -2,7 +2,7 @@\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n use crate::abi::call::{ArgAbi, CastTarget, FnAbi, Reg, RegKind};\n-use crate::abi::{self, Abi, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods};\n+use crate::abi::{self, Abi, HasDataLayout, LayoutOf, Size, TyAbiInterface, TyAndLayout};\n \n /// Classification of \"eightbyte\" components.\n // N.B., the order of the variants is from general to specific,\n@@ -26,7 +26,7 @@ fn classify_arg<'a, Ty, C>(\n     arg: &ArgAbi<'a, Ty>,\n ) -> Result<[Option<Class>; MAX_EIGHTBYTES], Memory>\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     fn classify<'a, Ty, C>(\n@@ -36,7 +36,7 @@ where\n         off: Size,\n     ) -> Result<(), Memory>\n     where\n-        Ty: TyAndLayoutMethods<'a, C> + Copy,\n+        Ty: TyAbiInterface<'a, C> + Copy,\n         C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n     {\n         if !off.is_aligned(layout.align.abi) {\n@@ -172,7 +172,7 @@ const MAX_SSE_REGS: usize = 8; // XMM0-7\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n where\n-    Ty: TyAndLayoutMethods<'a, C> + Copy,\n+    Ty: TyAbiInterface<'a, C> + Copy,\n     C: LayoutOf<'a, Ty = Ty, TyAndLayout = TyAndLayout<'a, Ty>> + HasDataLayout,\n {\n     let mut int_regs = MAX_INT_REGS;"}, {"sha": "250afbecd58e0c5c8922239a643d95972ae94091", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8486571a10ce57b02ae19bfb1b31736fb2a1b4fe/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=8486571a10ce57b02ae19bfb1b31736fb2a1b4fe", "patch": "@@ -1236,39 +1236,45 @@ pub struct PointeeInfo {\n     pub address_space: AddressSpace,\n }\n \n-pub trait TyAndLayoutMethods<'a, C: LayoutOf<'a, Ty = Self>>: Sized {\n-    fn for_variant(\n+/// Trait that needs to be implemented by the higher-level type representation\n+/// (e.g. `rustc_middle::ty::Ty`), to provide `rustc_target::abi` functionality.\n+pub trait TyAbiInterface<'a, C: LayoutOf<'a, Ty = Self>>: Sized {\n+    fn ty_and_layout_for_variant(\n         this: TyAndLayout<'a, Self>,\n         cx: &C,\n         variant_index: VariantIdx,\n     ) -> TyAndLayout<'a, Self>;\n-    fn field(this: TyAndLayout<'a, Self>, cx: &C, i: usize) -> C::TyAndLayout;\n-    fn pointee_info_at(this: TyAndLayout<'a, Self>, cx: &C, offset: Size) -> Option<PointeeInfo>;\n+    fn ty_and_layout_field(this: TyAndLayout<'a, Self>, cx: &C, i: usize) -> C::TyAndLayout;\n+    fn ty_and_layout_pointee_info_at(\n+        this: TyAndLayout<'a, Self>,\n+        cx: &C,\n+        offset: Size,\n+    ) -> Option<PointeeInfo>;\n }\n \n impl<'a, Ty> TyAndLayout<'a, Ty> {\n     pub fn for_variant<C>(self, cx: &C, variant_index: VariantIdx) -> Self\n     where\n-        Ty: TyAndLayoutMethods<'a, C>,\n+        Ty: TyAbiInterface<'a, C>,\n         C: LayoutOf<'a, Ty = Ty>,\n     {\n-        Ty::for_variant(self, cx, variant_index)\n+        Ty::ty_and_layout_for_variant(self, cx, variant_index)\n     }\n \n     pub fn field<C>(self, cx: &C, i: usize) -> C::TyAndLayout\n     where\n-        Ty: TyAndLayoutMethods<'a, C>,\n+        Ty: TyAbiInterface<'a, C>,\n         C: LayoutOf<'a, Ty = Ty>,\n     {\n-        Ty::field(self, cx, i)\n+        Ty::ty_and_layout_field(self, cx, i)\n     }\n \n     pub fn pointee_info_at<C>(self, cx: &C, offset: Size) -> Option<PointeeInfo>\n     where\n-        Ty: TyAndLayoutMethods<'a, C>,\n+        Ty: TyAbiInterface<'a, C>,\n         C: LayoutOf<'a, Ty = Ty>,\n     {\n-        Ty::pointee_info_at(self, cx, offset)\n+        Ty::ty_and_layout_pointee_info_at(self, cx, offset)\n     }\n }\n \n@@ -1299,7 +1305,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n     pub fn might_permit_raw_init<C, E>(self, cx: &C, zero: bool) -> Result<bool, E>\n     where\n         Self: Copy,\n-        Ty: TyAndLayoutMethods<'a, C>,\n+        Ty: TyAbiInterface<'a, C>,\n         C: LayoutOf<'a, Ty = Ty, TyAndLayout: MaybeResult<Self, Error = E>> + HasDataLayout,\n     {\n         let scalar_allows_raw_init = move |s: &Scalar| -> bool {"}]}