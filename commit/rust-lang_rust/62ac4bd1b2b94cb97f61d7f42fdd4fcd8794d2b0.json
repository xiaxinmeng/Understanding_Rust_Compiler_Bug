{"sha": "62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYWM0YmQxYjJiOTRjYjk3ZjYxZDdmNDJmZGQ0ZmNkODc5NGQyYjA=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-07T12:35:27Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:13:32Z"}, "message": "create loops dir; arrange manual_flatten lint and utils", "tree": {"sha": "94de167fa714dd39a114cd7a3a761da48705db44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94de167fa714dd39a114cd7a3a761da48705db44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0", "html_url": "https://github.com/rust-lang/rust/commit/62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e50afa43d0ed32fad86514e2cfcc72d20d38448a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e50afa43d0ed32fad86514e2cfcc72d20d38448a", "html_url": "https://github.com/rust-lang/rust/commit/e50afa43d0ed32fad86514e2cfcc72d20d38448a"}], "stats": {"total": 239, "additions": 127, "deletions": 112}, "files": [{"sha": "b5881a1b8c47cc524797de69c9973ae94061c1fb", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0", "patch": "@@ -0,0 +1,78 @@\n+use super::utils::make_iterator_snippet;\n+use crate::utils::{is_ok_ctor, is_some_ctor, path_to_local_id, span_lint_and_then};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, QPath, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+/// Check for unnecessary `if let` usage in a for loop where only the `Some` or `Ok` variant of the\n+/// iterator element is used.\n+pub(super) fn lint<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    span: Span,\n+) {\n+    if let ExprKind::Block(ref block, _) = body.kind {\n+        // Ensure the `if let` statement is the only expression or statement in the for-loop\n+        let inner_expr = if block.stmts.len() == 1 && block.expr.is_none() {\n+            let match_stmt = &block.stmts[0];\n+            if let StmtKind::Semi(inner_expr) = match_stmt.kind {\n+                Some(inner_expr)\n+            } else {\n+                None\n+            }\n+        } else if block.stmts.is_empty() {\n+            block.expr\n+        } else {\n+            None\n+        };\n+\n+        if_chain! {\n+            if let Some(inner_expr) = inner_expr;\n+            if let ExprKind::Match(\n+                ref match_expr, ref match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n+            ) = inner_expr.kind;\n+            // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n+            if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n+            if path_to_local_id(match_expr, pat_hir_id);\n+            // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n+            if let PatKind::TupleStruct(QPath::Resolved(None, path), _, _) = match_arms[0].pat.kind;\n+            let some_ctor = is_some_ctor(cx, path.res);\n+            let ok_ctor = is_ok_ctor(cx, path.res);\n+            if some_ctor || ok_ctor;\n+            let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n+\n+            then {\n+                // Prepare the error message\n+                let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n+\n+                // Prepare the help message\n+                let mut applicability = Applicability::MaybeIncorrect;\n+                let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n+\n+                span_lint_and_then(\n+                    cx,\n+                    super::MANUAL_FLATTEN,\n+                    span,\n+                    &msg,\n+                    |diag| {\n+                        let sugg = format!(\"{}.flatten()\", arg_snippet);\n+                        diag.span_suggestion(\n+                            arg.span,\n+                            \"try\",\n+                            sugg,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        diag.span_help(\n+                            inner_expr.span,\n+                            \"...and remove the `if let` statement in the for loop\",\n+                        );\n+                    }\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "18b7e96d42cb408aed08e8178d59faa0a64a5772", "filename": "clippy_lints/src/loops/mod.rs", "status": "renamed", "additions": 9, "deletions": 112, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0", "patch": "@@ -1,13 +1,16 @@\n+mod manual_flatten;\n+mod utils;\n+\n use crate::consts::constant;\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::mutated_variables;\n use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{\n     contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    indent_of, is_in_panic_handler, is_integer_const, is_no_std_crate, is_ok_ctor, is_refutable, is_some_ctor,\n-    is_type_diagnostic_item, last_path_segment, match_trait_method, match_type, multispan_sugg, path_to_local,\n-    path_to_local_id, paths, single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n-    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n+    indent_of, is_in_panic_handler, is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item,\n+    last_path_segment, match_trait_method, match_type, multispan_sugg, path_to_local, path_to_local_id, paths,\n+    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n+    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -31,6 +34,7 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use std::iter::{once, Iterator};\n use std::mem;\n+use utils::make_iterator_snippet;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for for-loops that manually copy items between\n@@ -862,7 +866,7 @@ fn check_for_loop<'tcx>(\n     check_for_mut_range_bound(cx, arg, body);\n     check_for_single_element_loop(cx, pat, arg, body, expr);\n     detect_same_item_push(cx, pat, arg, body, expr);\n-    check_manual_flatten(cx, pat, arg, body, span);\n+    manual_flatten::lint(cx, pat, arg, body, span);\n }\n \n // this function assumes the given expression is a `for` loop.\n@@ -1839,42 +1843,6 @@ fn check_for_loop_explicit_counter<'tcx>(\n     }\n }\n \n-/// If `arg` was the argument to a `for` loop, return the \"cleanest\" way of writing the\n-/// actual `Iterator` that the loop uses.\n-fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {\n-    let impls_iterator = get_trait_def_id(cx, &paths::ITERATOR).map_or(false, |id| {\n-        implements_trait(cx, cx.typeck_results().expr_ty(arg), id, &[])\n-    });\n-    if impls_iterator {\n-        format!(\n-            \"{}\",\n-            sugg::Sugg::hir_with_applicability(cx, arg, \"_\", applic_ref).maybe_par()\n-        )\n-    } else {\n-        // (&x).into_iter() ==> x.iter()\n-        // (&mut x).into_iter() ==> x.iter_mut()\n-        match &arg.kind {\n-            ExprKind::AddrOf(BorrowKind::Ref, mutability, arg_inner)\n-                if has_iter_method(cx, cx.typeck_results().expr_ty(&arg_inner)).is_some() =>\n-            {\n-                let meth_name = match mutability {\n-                    Mutability::Mut => \"iter_mut\",\n-                    Mutability::Not => \"iter\",\n-                };\n-                format!(\n-                    \"{}.{}()\",\n-                    sugg::Sugg::hir_with_applicability(cx, &arg_inner, \"_\", applic_ref).maybe_par(),\n-                    meth_name,\n-                )\n-            }\n-            _ => format!(\n-                \"{}.into_iter()\",\n-                sugg::Sugg::hir_with_applicability(cx, arg, \"_\", applic_ref).maybe_par()\n-            ),\n-        }\n-    }\n-}\n-\n /// Checks for the `FOR_KV_MAP` lint.\n fn check_for_loop_over_map_kv<'tcx>(\n     cx: &LateContext<'tcx>,\n@@ -1964,77 +1932,6 @@ fn check_for_single_element_loop<'tcx>(\n     }\n }\n \n-/// Check for unnecessary `if let` usage in a for loop where only the `Some` or `Ok` variant of the\n-/// iterator element is used.\n-fn check_manual_flatten<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &'tcx Pat<'_>,\n-    arg: &'tcx Expr<'_>,\n-    body: &'tcx Expr<'_>,\n-    span: Span,\n-) {\n-    if let ExprKind::Block(ref block, _) = body.kind {\n-        // Ensure the `if let` statement is the only expression or statement in the for-loop\n-        let inner_expr = if block.stmts.len() == 1 && block.expr.is_none() {\n-            let match_stmt = &block.stmts[0];\n-            if let StmtKind::Semi(inner_expr) = match_stmt.kind {\n-                Some(inner_expr)\n-            } else {\n-                None\n-            }\n-        } else if block.stmts.is_empty() {\n-            block.expr\n-        } else {\n-            None\n-        };\n-\n-        if_chain! {\n-            if let Some(inner_expr) = inner_expr;\n-            if let ExprKind::Match(\n-                ref match_expr, ref match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n-            ) = inner_expr.kind;\n-            // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n-            if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n-            if path_to_local_id(match_expr, pat_hir_id);\n-            // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n-            if let PatKind::TupleStruct(QPath::Resolved(None, path), _, _) = match_arms[0].pat.kind;\n-            let some_ctor = is_some_ctor(cx, path.res);\n-            let ok_ctor = is_ok_ctor(cx, path.res);\n-            if some_ctor || ok_ctor;\n-            let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n-\n-            then {\n-                // Prepare the error message\n-                let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n-\n-                // Prepare the help message\n-                let mut applicability = Applicability::MaybeIncorrect;\n-                let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n-\n-                span_lint_and_then(\n-                    cx,\n-                    MANUAL_FLATTEN,\n-                    span,\n-                    &msg,\n-                    |diag| {\n-                        let sugg = format!(\"{}.flatten()\", arg_snippet);\n-                        diag.span_suggestion(\n-                            arg.span,\n-                            \"try\",\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        diag.span_help(\n-                            inner_expr.span,\n-                            \"...and remove the `if let` statement in the for loop\",\n-                        );\n-                    }\n-                );\n-            }\n-        }\n-    }\n-}\n-\n struct MutatePairDelegate<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     hir_id_low: Option<HirId>,", "previous_filename": "clippy_lints/src/loops.rs"}, {"sha": "b06df2d75f3bec94392194245fafa87a7c517329", "filename": "clippy_lints/src/loops/utils.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0/clippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0/clippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Futils.rs?ref=62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0", "patch": "@@ -0,0 +1,40 @@\n+use crate::utils::{get_trait_def_id, has_iter_method, implements_trait, paths, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability};\n+use rustc_lint::LateContext;\n+\n+/// If `arg` was the argument to a `for` loop, return the \"cleanest\" way of writing the\n+/// actual `Iterator` that the loop uses.\n+pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {\n+    let impls_iterator = get_trait_def_id(cx, &paths::ITERATOR).map_or(false, |id| {\n+        implements_trait(cx, cx.typeck_results().expr_ty(arg), id, &[])\n+    });\n+    if impls_iterator {\n+        format!(\n+            \"{}\",\n+            sugg::Sugg::hir_with_applicability(cx, arg, \"_\", applic_ref).maybe_par()\n+        )\n+    } else {\n+        // (&x).into_iter() ==> x.iter()\n+        // (&mut x).into_iter() ==> x.iter_mut()\n+        match &arg.kind {\n+            ExprKind::AddrOf(BorrowKind::Ref, mutability, arg_inner)\n+                if has_iter_method(cx, cx.typeck_results().expr_ty(&arg_inner)).is_some() =>\n+            {\n+                let meth_name = match mutability {\n+                    Mutability::Mut => \"iter_mut\",\n+                    Mutability::Not => \"iter\",\n+                };\n+                format!(\n+                    \"{}.{}()\",\n+                    sugg::Sugg::hir_with_applicability(cx, &arg_inner, \"_\", applic_ref).maybe_par(),\n+                    meth_name,\n+                )\n+            }\n+            _ => format!(\n+                \"{}.into_iter()\",\n+                sugg::Sugg::hir_with_applicability(cx, arg, \"_\", applic_ref).maybe_par()\n+            ),\n+        }\n+    }\n+}"}]}