{"sha": "9c525ee95bcc99730003e2d4bbb58520337bdefc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNTI1ZWU5NWJjYzk5NzMwMDAzZTJkNGJiYjU4NTIwMzM3YmRlZmM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-15T20:16:33Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-15T20:55:44Z"}, "message": "review comments", "tree": {"sha": "f561125606b3b3005e1db0850d0989343e6fafc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f561125606b3b3005e1db0850d0989343e6fafc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c525ee95bcc99730003e2d4bbb58520337bdefc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c525ee95bcc99730003e2d4bbb58520337bdefc", "html_url": "https://github.com/rust-lang/rust/commit/9c525ee95bcc99730003e2d4bbb58520337bdefc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c525ee95bcc99730003e2d4bbb58520337bdefc/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cabb425415028e3abad56034e7daef6f05343bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cabb425415028e3abad56034e7daef6f05343bd", "html_url": "https://github.com/rust-lang/rust/commit/8cabb425415028e3abad56034e7daef6f05343bd"}], "stats": {"total": 110, "additions": 51, "deletions": 59}, "files": [{"sha": "8e9a350030c4d3f7cd37a902287c24e1fe22294e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 51, "deletions": 59, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/9c525ee95bcc99730003e2d4bbb58520337bdefc/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c525ee95bcc99730003e2d4bbb58520337bdefc/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=9c525ee95bcc99730003e2d4bbb58520337bdefc", "patch": "@@ -969,9 +969,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         trait_ref: &ty::PolyTraitRef<'_>,\n         body_id: hir::HirId,\n     ) {\n-        let (param_ty, projection) = match &trait_ref.self_ty().kind {\n-            ty::Param(param_ty) => (Some(param_ty), None),\n-            ty::Projection(projection) => (None, Some(projection)),\n+        let self_ty = trait_ref.self_ty();\n+        let (param_ty, projection) = match &self_ty.kind {\n+            ty::Param(_) => (true, None),\n+            ty::Projection(projection) => (false, Some(projection)),\n             _ => return,\n         };\n \n@@ -997,17 +998,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let mut hir_id = body_id;\n         while let Some(node) = self.tcx.hir().find(hir_id) {\n             match node {\n-                hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Fn(_, _, generics, _), ..\n-                }) |\n                 hir::Node::TraitItem(hir::TraitItem {\n                     generics,\n                     kind: hir::TraitItemKind::Method(..), ..\n-                }) |\n-                hir::Node::ImplItem(hir::ImplItem {\n-                    generics,\n-                    kind: hir::ImplItemKind::Method(..), ..\n-                }) if param_ty.map_or(false, |p| p.name.as_str() == \"Self\") => {\n+                }) if param_ty && self_ty == self.tcx.types.self_param => {\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(&generics, \"`Self`\");\n                     return;\n@@ -1058,12 +1052,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }) |\n                 hir::Node::TraitItem(hir::TraitItem { generics, span, .. }) |\n                 hir::Node::ImplItem(hir::ImplItem { generics, span, .. })\n-                if param_ty.is_some() => {\n+                if param_ty => {\n                     // Missing generic type parameter bound.\n                     let restrict_msg = \"consider further restricting this bound\";\n-                    let param_name = param_ty.unwrap().name.as_str();\n+                    let param_name = self_ty.to_string();\n                     for param in generics.params.iter().filter(|p| {\n-                        param_name == p.name.ident().as_str()\n+                        &param_name == p.name.ident().as_str()\n                     }) {\n                         if param_name.starts_with(\"impl \") {\n                             // `impl Trait` in argument:\n@@ -1075,53 +1069,51 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 format!(\"{} + {}\", param.name.ident(), trait_ref),\n                                 Applicability::MachineApplicable,\n                             );\n-                        } else {\n-                            if generics.where_clause.predicates.is_empty() &&\n+                        } else if generics.where_clause.predicates.is_empty() &&\n                                 param.bounds.is_empty()\n-                            {\n-                                // If there are no bounds whatsoever, suggest adding a constraint\n-                                // to the type parameter:\n-                                // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n-                                err.span_suggestion(\n-                                    param.span,\n-                                    \"consider restricting this bound\",\n-                                    format!(\"{}\", trait_ref.to_predicate()),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            } else if !generics.where_clause.predicates.is_empty() {\n-                                // There is a `where` clause, so suggest expanding it:\n-                                // `fn foo<T>(t: T) where T: Debug {}` \u2192\n-                                // `fn foo<T(t: T) where T: Debug, Trait {}`\n-                                err.span_suggestion(\n-                                    generics.where_clause.span().unwrap().shrink_to_hi(),\n-                                    &format!(\n-                                        \"consider further restricting type parameter `{}`\",\n-                                        param_name,\n-                                    ),\n-                                    format!(\", {}\", trait_ref.to_predicate()),\n-                                    Applicability::MachineApplicable,\n-                                );\n+                        {\n+                            // If there are no bounds whatsoever, suggest adding a constraint\n+                            // to the type parameter:\n+                            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+                            err.span_suggestion(\n+                                param.span,\n+                                \"consider restricting this bound\",\n+                                format!(\"{}\", trait_ref.to_predicate()),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else if !generics.where_clause.predicates.is_empty() {\n+                            // There is a `where` clause, so suggest expanding it:\n+                            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+                            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+                            err.span_suggestion(\n+                                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                                &format!(\n+                                    \"consider further restricting type parameter `{}`\",\n+                                    param_name,\n+                                ),\n+                                format!(\", {}\", trait_ref.to_predicate()),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            // If there is no `where` clause lean towards constraining to the\n+                            // type parameter:\n+                            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+                            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+                            let sp = param.span.with_hi(span.hi());\n+                            let span = self.tcx.sess.source_map()\n+                                .span_through_char(sp, ':');\n+                            if sp != param.span && sp != span {\n+                                // Only suggest if we have high certainty that the span\n+                                // covers the colon in `foo<T: Trait>`.\n+                                err.span_suggestion(span, restrict_msg, format!(\n+                                    \"{} + \",\n+                                    trait_ref.to_predicate(),\n+                                ), Applicability::MachineApplicable);\n                             } else {\n-                                // If there is no `where` clause lean towards constraining to the\n-                                // type parameter:\n-                                // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n-                                // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n-                                let sp = param.span.with_hi(span.hi());\n-                                let span = self.tcx.sess.source_map()\n-                                    .span_through_char(sp, ':');\n-                                if sp != param.span && sp != span {\n-                                    // Only suggest if we have high certainty that the span\n-                                    // covers the colon in `foo<T: Trait>`.\n-                                    err.span_suggestion(span, restrict_msg, format!(\n-                                        \"{} + \",\n-                                        trait_ref.to_predicate(),\n-                                    ), Applicability::MachineApplicable);\n-                                } else {\n-                                    err.span_label(param.span, &format!(\n-                                        \"consider adding a `where {}` bound\",\n-                                        trait_ref.to_predicate(),\n-                                    ));\n-                                }\n+                                err.span_label(param.span, &format!(\n+                                    \"consider adding a `where {}` bound\",\n+                                    trait_ref.to_predicate(),\n+                                ));\n                             }\n                         }\n                         return;"}]}