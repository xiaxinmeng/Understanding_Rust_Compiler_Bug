{"sha": "8a068699a24de306334a1f66b9a83552766d853c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMDY4Njk5YTI0ZGUzMDYzMzRhMWY2NmI5YTgzNTUyNzY2ZDg1M2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-11T13:37:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-11T13:37:37Z"}, "message": "Auto merge of #63446 - Centril:refactor-lowering, r=oli-obk\n\nRefactor and categorize lowering wrt. items / exprs\n\nSplit lowering into more files along the lines of \"expression related\" and \"item related\".\nAlso refactor huge methods into smaller ones.\n\nA next step might be to introduce \"type related\" and merge patterns and statements combined with expressions into \"value related\". There's still more work to do but the PR was getting too big :)\n\nr? @oli-obk", "tree": {"sha": "0d78b05bdf7e213ef302c52361f46d8ffbe9e235", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d78b05bdf7e213ef302c52361f46d8ffbe9e235"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a068699a24de306334a1f66b9a83552766d853c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a068699a24de306334a1f66b9a83552766d853c", "html_url": "https://github.com/rust-lang/rust/commit/8a068699a24de306334a1f66b9a83552766d853c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a068699a24de306334a1f66b9a83552766d853c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b78e10ac1454d2d4190c575f6ece03f484ac398", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b78e10ac1454d2d4190c575f6ece03f484ac398", "html_url": "https://github.com/rust-lang/rust/commit/2b78e10ac1454d2d4190c575f6ece03f484ac398"}, {"sha": "eb229bca0dbef988dbed7108c82971e31f739a2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb229bca0dbef988dbed7108c82971e31f739a2a", "html_url": "https://github.com/rust-lang/rust/commit/eb229bca0dbef988dbed7108c82971e31f739a2a"}], "stats": {"total": 5846, "additions": 2989, "deletions": 2857}, "files": [{"sha": "fe69c9e6346351c7bb447932b6d3625ab27304a7", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 82, "deletions": 2857, "changes": 2939, "blob_url": "https://github.com/rust-lang/rust/blob/8a068699a24de306334a1f66b9a83552766d853c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a068699a24de306334a1f66b9a83552766d853c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8a068699a24de306334a1f66b9a83552766d853c"}, {"sha": "d273006fbe07eddb21cfea12a94e7e80bd365995", "filename": "src/librustc/hir/lowering/expr.rs", "status": "added", "additions": 1497, "deletions": 0, "changes": 1497, "blob_url": "https://github.com/rust-lang/rust/blob/8a068699a24de306334a1f66b9a83552766d853c/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a068699a24de306334a1f66b9a83552766d853c/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=8a068699a24de306334a1f66b9a83552766d853c", "patch": "@@ -0,0 +1,1497 @@\n+use super::{LoweringContext, ParamMode, ParenthesizedGenericArgs, ImplTraitContext};\n+use crate::hir::{self, HirVec};\n+use crate::hir::def::Res;\n+use crate::hir::ptr::P;\n+\n+use rustc_data_structures::thin_vec::ThinVec;\n+\n+use syntax::attr;\n+use syntax::ptr::P as AstP;\n+use syntax::ast::*;\n+use syntax::source_map::{respan, DesugaringKind, Span, Spanned};\n+use syntax::symbol::{sym, Symbol};\n+\n+impl LoweringContext<'_> {\n+    fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> HirVec<hir::Expr> {\n+        exprs.iter().map(|x| self.lower_expr(x)).collect()\n+    }\n+\n+    pub(super) fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n+        let kind = match e.node {\n+            ExprKind::Box(ref inner) => hir::ExprKind::Box(P(self.lower_expr(inner))),\n+            ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n+            ExprKind::Repeat(ref expr, ref count) => {\n+                let expr = P(self.lower_expr(expr));\n+                let count = self.lower_anon_const(count);\n+                hir::ExprKind::Repeat(expr, count)\n+            }\n+            ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n+            ExprKind::Call(ref f, ref args) => {\n+                let f = P(self.lower_expr(f));\n+                hir::ExprKind::Call(f, self.lower_exprs(args))\n+            }\n+            ExprKind::MethodCall(ref seg, ref args) => {\n+                let hir_seg = P(self.lower_path_segment(\n+                    e.span,\n+                    seg,\n+                    ParamMode::Optional,\n+                    0,\n+                    ParenthesizedGenericArgs::Err,\n+                    ImplTraitContext::disallowed(),\n+                    None,\n+                ));\n+                let args = self.lower_exprs(args);\n+                hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args)\n+            }\n+            ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+                let binop = self.lower_binop(binop);\n+                let lhs = P(self.lower_expr(lhs));\n+                let rhs = P(self.lower_expr(rhs));\n+                hir::ExprKind::Binary(binop, lhs, rhs)\n+            }\n+            ExprKind::Unary(op, ref ohs) => {\n+                let op = self.lower_unop(op);\n+                let ohs = P(self.lower_expr(ohs));\n+                hir::ExprKind::Unary(op, ohs)\n+            }\n+            ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.node.clone())),\n+            ExprKind::Cast(ref expr, ref ty) => {\n+                let expr = P(self.lower_expr(expr));\n+                hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n+            }\n+            ExprKind::Type(ref expr, ref ty) => {\n+                let expr = P(self.lower_expr(expr));\n+                hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n+            }\n+            ExprKind::AddrOf(m, ref ohs) => {\n+                let m = self.lower_mutability(m);\n+                let ohs = P(self.lower_expr(ohs));\n+                hir::ExprKind::AddrOf(m, ohs)\n+            }\n+            ExprKind::Let(ref pats, ref scrutinee) => self.lower_expr_let(e.span, pats, scrutinee),\n+            ExprKind::If(ref cond, ref then, ref else_opt) => {\n+                self.lower_expr_if(e.span, cond, then, else_opt.as_deref())\n+            }\n+            ExprKind::While(ref cond, ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                this.lower_expr_while_in_loop_scope(e.span, cond, body, opt_label)\n+            }),\n+            ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                hir::ExprKind::Loop(\n+                    this.lower_block(body, false),\n+                    this.lower_label(opt_label),\n+                    hir::LoopSource::Loop,\n+                )\n+            }),\n+            ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n+            ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n+                P(self.lower_expr(expr)),\n+                arms.iter().map(|x| self.lower_arm(x)).collect(),\n+                hir::MatchSource::Normal,\n+            ),\n+            ExprKind::Async(capture_clause, closure_node_id, ref block) => {\n+                self.make_async_expr(capture_clause, closure_node_id, None, block.span, |this| {\n+                    this.with_new_scopes(|this| {\n+                        let block = this.lower_block(block, false);\n+                        this.expr_block(block, ThinVec::new())\n+                    })\n+                })\n+            }\n+            ExprKind::Await(ref expr) => self.lower_expr_await(e.span, expr),\n+            ExprKind::Closure(\n+                capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span\n+            ) => if let IsAsync::Async { closure_id, .. } = asyncness {\n+                self.lower_expr_async_closure(capture_clause, closure_id, decl, body, fn_decl_span)\n+            } else {\n+                self.lower_expr_closure(capture_clause, movability, decl, body, fn_decl_span)\n+            }\n+            ExprKind::Block(ref blk, opt_label) => {\n+                hir::ExprKind::Block(self.lower_block(blk,\n+                                                      opt_label.is_some()),\n+                                                      self.lower_label(opt_label))\n+            }\n+            ExprKind::Assign(ref el, ref er) => {\n+                hir::ExprKind::Assign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n+            }\n+            ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n+                self.lower_binop(op),\n+                P(self.lower_expr(el)),\n+                P(self.lower_expr(er)),\n+            ),\n+            ExprKind::Field(ref el, ident) => hir::ExprKind::Field(P(self.lower_expr(el)), ident),\n+            ExprKind::Index(ref el, ref er) => {\n+                hir::ExprKind::Index(P(self.lower_expr(el)), P(self.lower_expr(er)))\n+            }\n+            ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n+                self.lower_expr_range_closed(e.span, e1, e2)\n+            }\n+            ExprKind::Range(ref e1, ref e2, lims) => {\n+                self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n+            }\n+            ExprKind::Path(ref qself, ref path) => {\n+                let qpath = self.lower_qpath(\n+                    e.id,\n+                    qself,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+                hir::ExprKind::Path(qpath)\n+            }\n+            ExprKind::Break(opt_label, ref opt_expr) => {\n+                hir::ExprKind::Break(\n+                    self.lower_jump_destination(e.id, opt_label),\n+                    opt_expr.as_ref().map(|x| P(self.lower_expr(x))),\n+                )\n+            }\n+            ExprKind::Continue(opt_label) => {\n+                hir::ExprKind::Continue(self.lower_jump_destination(e.id, opt_label))\n+            }\n+            ExprKind::Ret(ref e) => hir::ExprKind::Ret(e.as_ref().map(|x| P(self.lower_expr(x)))),\n+            ExprKind::InlineAsm(ref asm) => self.lower_expr_asm(asm),\n+            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => hir::ExprKind::Struct(\n+                P(self.lower_qpath(\n+                    e.id,\n+                    &None,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                )),\n+                fields.iter().map(|x| self.lower_field(x)).collect(),\n+                maybe_expr.as_ref().map(|x| P(self.lower_expr(x))),\n+            ),\n+            ExprKind::Paren(ref ex) => {\n+                let mut ex = self.lower_expr(ex);\n+                // Include parens in span, but only if it is a super-span.\n+                if e.span.contains(ex.span) {\n+                    ex.span = e.span;\n+                }\n+                // Merge attributes into the inner expression.\n+                let mut attrs = e.attrs.clone();\n+                attrs.extend::<Vec<_>>(ex.attrs.into());\n+                ex.attrs = attrs;\n+                return ex;\n+            }\n+\n+            ExprKind::Yield(ref opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n+\n+            ExprKind::Err => hir::ExprKind::Err,\n+\n+            // Desugar `ExprForLoop`\n+            // from: `[opt_ident]: for <pat> in <head> <body>`\n+            ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n+                return self.lower_expr_for(e, pat, head, body, opt_label);\n+            }\n+            ExprKind::Try(ref sub_expr) => self.lower_expr_try(e.span, sub_expr),\n+            ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n+        };\n+\n+        hir::Expr {\n+            hir_id: self.lower_node_id(e.id),\n+            node: kind,\n+            span: e.span,\n+            attrs: e.attrs.clone(),\n+        }\n+    }\n+\n+    fn lower_unop(&mut self, u: UnOp) -> hir::UnOp {\n+        match u {\n+            UnOp::Deref => hir::UnDeref,\n+            UnOp::Not => hir::UnNot,\n+            UnOp::Neg => hir::UnNeg,\n+        }\n+    }\n+\n+    fn lower_binop(&mut self, b: BinOp) -> hir::BinOp {\n+        Spanned {\n+            node: match b.node {\n+                BinOpKind::Add => hir::BinOpKind::Add,\n+                BinOpKind::Sub => hir::BinOpKind::Sub,\n+                BinOpKind::Mul => hir::BinOpKind::Mul,\n+                BinOpKind::Div => hir::BinOpKind::Div,\n+                BinOpKind::Rem => hir::BinOpKind::Rem,\n+                BinOpKind::And => hir::BinOpKind::And,\n+                BinOpKind::Or => hir::BinOpKind::Or,\n+                BinOpKind::BitXor => hir::BinOpKind::BitXor,\n+                BinOpKind::BitAnd => hir::BinOpKind::BitAnd,\n+                BinOpKind::BitOr => hir::BinOpKind::BitOr,\n+                BinOpKind::Shl => hir::BinOpKind::Shl,\n+                BinOpKind::Shr => hir::BinOpKind::Shr,\n+                BinOpKind::Eq => hir::BinOpKind::Eq,\n+                BinOpKind::Lt => hir::BinOpKind::Lt,\n+                BinOpKind::Le => hir::BinOpKind::Le,\n+                BinOpKind::Ne => hir::BinOpKind::Ne,\n+                BinOpKind::Ge => hir::BinOpKind::Ge,\n+                BinOpKind::Gt => hir::BinOpKind::Gt,\n+            },\n+            span: b.span,\n+        }\n+    }\n+\n+    /// Emit an error and lower `ast::ExprKind::Let(pats, scrutinee)` into:\n+    /// ```rust\n+    /// match scrutinee { pats => true, _ => false }\n+    /// ```\n+    fn lower_expr_let(\n+        &mut self,\n+        span: Span,\n+        pats: &[AstP<Pat>],\n+        scrutinee: &Expr\n+    ) -> hir::ExprKind {\n+        // If we got here, the `let` expression is not allowed.\n+        self.sess\n+            .struct_span_err(span, \"`let` expressions are not supported here\")\n+            .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n+            .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n+            .emit();\n+\n+        // For better recovery, we emit:\n+        // ```\n+        // match scrutinee { pats => true, _ => false }\n+        // ```\n+        // While this doesn't fully match the user's intent, it has key advantages:\n+        // 1. We can avoid using `abort_if_errors`.\n+        // 2. We can typeck both `pats` and `scrutinee`.\n+        // 3. `pats` is allowed to be refutable.\n+        // 4. The return type of the block is `bool` which seems like what the user wanted.\n+        let scrutinee = self.lower_expr(scrutinee);\n+        let then_arm = {\n+            let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+            let expr = self.expr_bool(span, true);\n+            self.arm(pats, P(expr))\n+        };\n+        let else_arm = {\n+            let pats = hir_vec![self.pat_wild(span)];\n+            let expr = self.expr_bool(span, false);\n+            self.arm(pats, P(expr))\n+        };\n+        hir::ExprKind::Match(\n+            P(scrutinee),\n+            vec![then_arm, else_arm].into(),\n+            hir::MatchSource::Normal,\n+        )\n+    }\n+\n+    fn lower_expr_if(\n+        &mut self,\n+        span: Span,\n+        cond: &Expr,\n+        then: &Block,\n+        else_opt: Option<&Expr>,\n+    ) -> hir::ExprKind {\n+        // FIXME(#53667): handle lowering of && and parens.\n+\n+        // `_ => else_block` where `else_block` is `{}` if there's `None`:\n+        let else_pat = self.pat_wild(span);\n+        let (else_expr, contains_else_clause) = match else_opt {\n+            None => (self.expr_block_empty(span), false),\n+            Some(els) => (self.lower_expr(els), true),\n+        };\n+        let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n+\n+        // Handle then + scrutinee:\n+        let then_blk = self.lower_block(then, false);\n+        let then_expr = self.expr_block(then_blk, ThinVec::new());\n+        let (then_pats, scrutinee, desugar) = match cond.node {\n+            // `<pat> => <then>`:\n+            ExprKind::Let(ref pats, ref scrutinee) => {\n+                let scrutinee = self.lower_expr(scrutinee);\n+                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n+                (pats, scrutinee, desugar)\n+            }\n+            // `true => <then>`:\n+            _ => {\n+                // Lower condition:\n+                let cond = self.lower_expr(cond);\n+                let span_block = self.mark_span_with_reason(\n+                    DesugaringKind::CondTemporary,\n+                    cond.span,\n+                    None\n+                );\n+                // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n+                // to preserve drop semantics since `if cond { ... }` does not\n+                // let temporaries live outside of `cond`.\n+                let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n+\n+                let desugar = hir::MatchSource::IfDesugar { contains_else_clause };\n+                let pats = hir_vec![self.pat_bool(span, true)];\n+                (pats, cond, desugar)\n+            }\n+        };\n+        let then_arm = self.arm(then_pats, P(then_expr));\n+\n+        hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n+    }\n+\n+    fn lower_expr_while_in_loop_scope(\n+        &mut self,\n+        span: Span,\n+        cond: &Expr,\n+        body: &Block,\n+        opt_label: Option<Label>\n+    ) -> hir::ExprKind {\n+        // FIXME(#53667): handle lowering of && and parens.\n+\n+        // Note that the block AND the condition are evaluated in the loop scope.\n+        // This is done to allow `break` from inside the condition of the loop.\n+\n+        // `_ => break`:\n+        let else_arm = {\n+            let else_pat = self.pat_wild(span);\n+            let else_expr = self.expr_break(span, ThinVec::new());\n+            self.arm(hir_vec![else_pat], else_expr)\n+        };\n+\n+        // Handle then + scrutinee:\n+        let then_blk = self.lower_block(body, false);\n+        let then_expr = self.expr_block(then_blk, ThinVec::new());\n+        let (then_pats, scrutinee, desugar, source) = match cond.node {\n+            ExprKind::Let(ref pats, ref scrutinee) => {\n+                // to:\n+                //\n+                //   [opt_ident]: loop {\n+                //     match <sub_expr> {\n+                //       <pat> => <body>,\n+                //       _ => break\n+                //     }\n+                //   }\n+                let scrutinee = self.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n+                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                let desugar = hir::MatchSource::WhileLetDesugar;\n+                (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n+            }\n+            _ => {\n+                // We desugar: `'label: while $cond $body` into:\n+                //\n+                // ```\n+                // 'label: loop {\n+                //     match DropTemps($cond) {\n+                //         true => $body,\n+                //         _ => break,\n+                //     }\n+                // }\n+                // ```\n+\n+                // Lower condition:\n+                let cond = self.with_loop_condition_scope(|this| this.lower_expr(cond));\n+                let span_block = self.mark_span_with_reason(\n+                    DesugaringKind::CondTemporary,\n+                    cond.span,\n+                    None,\n+                );\n+                // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n+                // to preserve drop semantics since `while cond { ... }` does not\n+                // let temporaries live outside of `cond`.\n+                let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n+\n+                let desugar = hir::MatchSource::WhileDesugar;\n+                // `true => <then>`:\n+                let pats = hir_vec![self.pat_bool(span, true)];\n+                (pats, cond, desugar, hir::LoopSource::While)\n+            }\n+        };\n+        let then_arm = self.arm(then_pats, P(then_expr));\n+\n+        // `match <scrutinee> { ... }`\n+        let match_expr = self.expr_match(\n+            scrutinee.span,\n+            P(scrutinee),\n+            hir_vec![then_arm, else_arm],\n+            desugar,\n+        );\n+\n+        // `[opt_ident]: loop { ... }`\n+        hir::ExprKind::Loop(\n+            P(self.block_expr(P(match_expr))),\n+            self.lower_label(opt_label),\n+            source\n+        )\n+    }\n+\n+    fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind {\n+        self.with_catch_scope(body.id, |this| {\n+            let unstable_span = this.mark_span_with_reason(\n+                DesugaringKind::TryBlock,\n+                body.span,\n+                this.allow_try_trait.clone(),\n+            );\n+            let mut block = this.lower_block(body, true).into_inner();\n+            let tail = block.expr.take().map_or_else(\n+                || this.expr_unit(this.sess.source_map().end_point(unstable_span)),\n+                |x: P<hir::Expr>| x.into_inner(),\n+            );\n+            block.expr = Some(this.wrap_in_try_constructor(sym::from_ok, tail, unstable_span));\n+            hir::ExprKind::Block(P(block), None)\n+        })\n+    }\n+\n+    fn wrap_in_try_constructor(\n+        &mut self,\n+        method: Symbol,\n+        e: hir::Expr,\n+        unstable_span: Span,\n+    ) -> P<hir::Expr> {\n+        let path = &[sym::ops, sym::Try, method];\n+        let from_err = P(self.expr_std_path(unstable_span, path, None, ThinVec::new()));\n+        P(self.expr_call(e.span, from_err, hir_vec![e]))\n+    }\n+\n+    fn lower_arm(&mut self, arm: &Arm) -> hir::Arm {\n+        hir::Arm {\n+            hir_id: self.next_id(),\n+            attrs: self.lower_attrs(&arm.attrs),\n+            pats: arm.pats.iter().map(|x| self.lower_pat(x)).collect(),\n+            guard: match arm.guard {\n+                Some(ref x) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n+                _ => None,\n+            },\n+            body: P(self.lower_expr(&arm.body)),\n+            span: arm.span,\n+        }\n+    }\n+\n+    pub(super) fn make_async_expr(\n+        &mut self,\n+        capture_clause: CaptureBy,\n+        closure_node_id: NodeId,\n+        ret_ty: Option<AstP<Ty>>,\n+        span: Span,\n+        body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n+    ) -> hir::ExprKind {\n+        let capture_clause = self.lower_capture_clause(capture_clause);\n+        let output = match ret_ty {\n+            Some(ty) => FunctionRetTy::Ty(ty),\n+            None => FunctionRetTy::Default(span),\n+        };\n+        let ast_decl = FnDecl {\n+            inputs: vec![],\n+            output,\n+            c_variadic: false\n+        };\n+        let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n+        let body_id = self.lower_fn_body(&ast_decl, |this| {\n+            this.generator_kind = Some(hir::GeneratorKind::Async);\n+            body(this)\n+        });\n+\n+        // `static || -> <ret_ty> { body }`:\n+        let generator_node = hir::ExprKind::Closure(\n+            capture_clause,\n+            decl,\n+            body_id,\n+            span,\n+            Some(hir::GeneratorMovability::Static)\n+        );\n+        let generator = hir::Expr {\n+            hir_id: self.lower_node_id(closure_node_id),\n+            node: generator_node,\n+            span,\n+            attrs: ThinVec::new(),\n+        };\n+\n+        // `future::from_generator`:\n+        let unstable_span = self.mark_span_with_reason(\n+            DesugaringKind::Async,\n+            span,\n+            self.allow_gen_future.clone(),\n+        );\n+        let gen_future = self.expr_std_path(\n+            unstable_span,\n+            &[sym::future, sym::from_generator],\n+            None,\n+            ThinVec::new()\n+        );\n+\n+        // `future::from_generator(generator)`:\n+        hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n+    }\n+\n+    /// Desugar `<expr>.await` into:\n+    /// ```rust\n+    /// {\n+    ///     let mut pinned = <expr>;\n+    ///     loop {\n+    ///         match ::std::future::poll_with_tls_context(unsafe {\n+    ///             ::std::pin::Pin::new_unchecked(&mut pinned)\n+    ///         }) {\n+    ///             ::std::task::Poll::Ready(result) => break result,\n+    ///             ::std::task::Poll::Pending => {},\n+    ///         }\n+    ///         yield ();\n+    ///     }\n+    /// }\n+    /// ```\n+    fn lower_expr_await(&mut self, await_span: Span, expr: &Expr) -> hir::ExprKind {\n+        match self.generator_kind {\n+            Some(hir::GeneratorKind::Async) => {},\n+            Some(hir::GeneratorKind::Gen) |\n+            None => {\n+                let mut err = struct_span_err!(\n+                    self.sess,\n+                    await_span,\n+                    E0728,\n+                    \"`await` is only allowed inside `async` functions and blocks\"\n+                );\n+                err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n+                if let Some(item_sp) = self.current_item {\n+                    err.span_label(item_sp, \"this is not `async`\");\n+                }\n+                err.emit();\n+            }\n+        }\n+        let span = self.mark_span_with_reason(\n+            DesugaringKind::Await,\n+            await_span,\n+            None,\n+        );\n+        let gen_future_span = self.mark_span_with_reason(\n+            DesugaringKind::Await,\n+            await_span,\n+            self.allow_gen_future.clone(),\n+        );\n+\n+        // let mut pinned = <expr>;\n+        let expr = P(self.lower_expr(expr));\n+        let pinned_ident = Ident::with_empty_ctxt(sym::pinned);\n+        let (pinned_pat, pinned_pat_hid) = self.pat_ident_binding_mode(\n+            span,\n+            pinned_ident,\n+            hir::BindingAnnotation::Mutable,\n+        );\n+        let pinned_let = self.stmt_let_pat(\n+            ThinVec::new(),\n+            span,\n+            Some(expr),\n+            pinned_pat,\n+            hir::LocalSource::AwaitDesugar,\n+        );\n+\n+        // ::std::future::poll_with_tls_context(unsafe {\n+        //     ::std::pin::Pin::new_unchecked(&mut pinned)\n+        // })`\n+        let poll_expr = {\n+            let pinned = P(self.expr_ident(span, pinned_ident, pinned_pat_hid));\n+            let ref_mut_pinned = self.expr_mut_addr_of(span, pinned);\n+            let pin_ty_id = self.next_id();\n+            let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n+                pin_ty_id,\n+                span,\n+                &[sym::pin, sym::Pin],\n+                \"new_unchecked\",\n+                hir_vec![ref_mut_pinned],\n+            );\n+            let new_unchecked = P(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n+            let unsafe_expr = self.expr_unsafe(new_unchecked);\n+            P(self.expr_call_std_path(\n+                gen_future_span,\n+                &[sym::future, sym::poll_with_tls_context],\n+                hir_vec![unsafe_expr],\n+            ))\n+        };\n+\n+        // `::std::task::Poll::Ready(result) => break result`\n+        let loop_node_id = self.sess.next_node_id();\n+        let loop_hir_id = self.lower_node_id(loop_node_id);\n+        let ready_arm = {\n+            let x_ident = Ident::with_empty_ctxt(sym::result);\n+            let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n+            let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n+            let ready_pat = self.pat_std_enum(\n+                span,\n+                &[sym::task, sym::Poll, sym::Ready],\n+                hir_vec![x_pat],\n+            );\n+            let break_x = self.with_loop_scope(loop_node_id, |this| {\n+                let expr_break = hir::ExprKind::Break(\n+                    this.lower_loop_destination(None),\n+                    Some(x_expr),\n+                );\n+                P(this.expr(await_span, expr_break, ThinVec::new()))\n+            });\n+            self.arm(hir_vec![ready_pat], break_x)\n+        };\n+\n+        // `::std::task::Poll::Pending => {}`\n+        let pending_arm = {\n+            let pending_pat = self.pat_std_enum(\n+                span,\n+                &[sym::task, sym::Poll, sym::Pending],\n+                hir_vec![],\n+            );\n+            let empty_block = P(self.expr_block_empty(span));\n+            self.arm(hir_vec![pending_pat], empty_block)\n+        };\n+\n+        let match_stmt = {\n+            let match_expr = self.expr_match(\n+                span,\n+                poll_expr,\n+                hir_vec![ready_arm, pending_arm],\n+                hir::MatchSource::AwaitDesugar,\n+            );\n+            self.stmt_expr(span, match_expr)\n+        };\n+\n+        let yield_stmt = {\n+            let unit = self.expr_unit(span);\n+            let yield_expr = self.expr(\n+                span,\n+                hir::ExprKind::Yield(P(unit), hir::YieldSource::Await),\n+                ThinVec::new(),\n+            );\n+            self.stmt_expr(span, yield_expr)\n+        };\n+\n+        let loop_block = P(self.block_all(\n+            span,\n+            hir_vec![match_stmt, yield_stmt],\n+            None,\n+        ));\n+\n+        let loop_expr = P(hir::Expr {\n+            hir_id: loop_hir_id,\n+            node: hir::ExprKind::Loop(\n+                loop_block,\n+                None,\n+                hir::LoopSource::Loop,\n+            ),\n+            span,\n+            attrs: ThinVec::new(),\n+        });\n+\n+        hir::ExprKind::Block(\n+            P(self.block_all(span, hir_vec![pinned_let], Some(loop_expr))),\n+            None,\n+        )\n+    }\n+\n+    fn lower_expr_closure(\n+        &mut self,\n+        capture_clause: CaptureBy,\n+        movability: Movability,\n+        decl: &FnDecl,\n+        body: &Expr,\n+        fn_decl_span: Span,\n+    ) -> hir::ExprKind {\n+        // Lower outside new scope to preserve `is_in_loop_condition`.\n+        let fn_decl = self.lower_fn_decl(decl, None, false, None);\n+\n+        self.with_new_scopes(|this| {\n+            this.current_item = Some(fn_decl_span);\n+            let mut generator_kind = None;\n+            let body_id = this.lower_fn_body(decl, |this| {\n+                let e = this.lower_expr(body);\n+                generator_kind = this.generator_kind;\n+                e\n+            });\n+            let generator_option = this.generator_movability_for_fn(\n+                &decl,\n+                fn_decl_span,\n+                generator_kind,\n+                movability,\n+            );\n+            hir::ExprKind::Closure(\n+                this.lower_capture_clause(capture_clause),\n+                fn_decl,\n+                body_id,\n+                fn_decl_span,\n+                generator_option,\n+            )\n+        })\n+    }\n+\n+    fn lower_capture_clause(&mut self, c: CaptureBy) -> hir::CaptureClause {\n+        match c {\n+            CaptureBy::Value => hir::CaptureByValue,\n+            CaptureBy::Ref => hir::CaptureByRef,\n+        }\n+    }\n+\n+    fn generator_movability_for_fn(\n+        &mut self,\n+        decl: &FnDecl,\n+        fn_decl_span: Span,\n+        generator_kind: Option<hir::GeneratorKind>,\n+        movability: Movability,\n+    ) -> Option<hir::GeneratorMovability> {\n+        match generator_kind {\n+            Some(hir::GeneratorKind::Gen) =>  {\n+                if !decl.inputs.is_empty() {\n+                    span_err!(\n+                        self.sess,\n+                        fn_decl_span,\n+                        E0628,\n+                        \"generators cannot have explicit arguments\"\n+                    );\n+                    self.sess.abort_if_errors();\n+                }\n+                Some(match movability {\n+                    Movability::Movable => hir::GeneratorMovability::Movable,\n+                    Movability::Static => hir::GeneratorMovability::Static,\n+                })\n+            },\n+            Some(hir::GeneratorKind::Async) => {\n+                bug!(\"non-`async` closure body turned `async` during lowering\");\n+            },\n+            None => {\n+                if movability == Movability::Static {\n+                    span_err!(\n+                        self.sess,\n+                        fn_decl_span,\n+                        E0697,\n+                        \"closures cannot be static\"\n+                    );\n+                }\n+                None\n+            },\n+        }\n+    }\n+\n+    fn lower_expr_async_closure(\n+        &mut self,\n+        capture_clause: CaptureBy,\n+        closure_id: NodeId,\n+        decl: &FnDecl,\n+        body: &Expr,\n+        fn_decl_span: Span,\n+    ) -> hir::ExprKind {\n+        let outer_decl = FnDecl {\n+            inputs: decl.inputs.clone(),\n+            output: FunctionRetTy::Default(fn_decl_span),\n+            c_variadic: false,\n+        };\n+        // We need to lower the declaration outside the new scope, because we\n+        // have to conserve the state of being inside a loop condition for the\n+        // closure argument types.\n+        let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n+\n+        self.with_new_scopes(|this| {\n+            // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n+            if capture_clause == CaptureBy::Ref && !decl.inputs.is_empty() {\n+                struct_span_err!(\n+                    this.sess,\n+                    fn_decl_span,\n+                    E0708,\n+                    \"`async` non-`move` closures with arguments are not currently supported\",\n+                )\n+                .help(\n+                    \"consider using `let` statements to manually capture \\\n+                    variables by reference before entering an `async move` closure\"\n+                )\n+                .emit();\n+            }\n+\n+            // Transform `async |x: u8| -> X { ... }` into\n+            // `|x: u8| future_from_generator(|| -> X { ... })`.\n+            let body_id = this.lower_fn_body(&outer_decl, |this| {\n+                let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n+                    Some(ty.clone())\n+                } else {\n+                    None\n+                };\n+                let async_body = this.make_async_expr(\n+                    capture_clause, closure_id, async_ret_ty, body.span,\n+                    |this| {\n+                        this.with_new_scopes(|this| this.lower_expr(body))\n+                    }\n+                );\n+                this.expr(fn_decl_span, async_body, ThinVec::new())\n+            });\n+            hir::ExprKind::Closure(\n+                this.lower_capture_clause(capture_clause),\n+                fn_decl,\n+                body_id,\n+                fn_decl_span,\n+                None,\n+            )\n+        })\n+    }\n+\n+    /// Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n+    fn lower_expr_range_closed(&mut self, span: Span, e1: &Expr, e2: &Expr) -> hir::ExprKind {\n+        let id = self.next_id();\n+        let e1 = self.lower_expr(e1);\n+        let e2 = self.lower_expr(e2);\n+        self.expr_call_std_assoc_fn(\n+            id,\n+            span,\n+            &[sym::ops, sym::RangeInclusive],\n+            \"new\",\n+            hir_vec![e1, e2],\n+        )\n+    }\n+\n+    fn lower_expr_range(\n+        &mut self,\n+        span: Span,\n+        e1: Option<&Expr>,\n+        e2: Option<&Expr>,\n+        lims: RangeLimits,\n+    ) -> hir::ExprKind {\n+        use syntax::ast::RangeLimits::*;\n+\n+        let path = match (e1, e2, lims) {\n+            (None, None, HalfOpen) => sym::RangeFull,\n+            (Some(..), None, HalfOpen) => sym::RangeFrom,\n+            (None, Some(..), HalfOpen) => sym::RangeTo,\n+            (Some(..), Some(..), HalfOpen) => sym::Range,\n+            (None, Some(..), Closed) => sym::RangeToInclusive,\n+            (Some(..), Some(..), Closed) => unreachable!(),\n+            (_, None, Closed) => self.diagnostic()\n+                .span_fatal(span, \"inclusive range with no end\")\n+                .raise(),\n+        };\n+\n+        let fields = e1.iter()\n+            .map(|e| (\"start\", e))\n+            .chain(e2.iter().map(|e| (\"end\", e)))\n+            .map(|(s, e)| {\n+                let expr = P(self.lower_expr(&e));\n+                let ident = Ident::new(Symbol::intern(s), e.span);\n+                self.field(ident, expr, e.span)\n+            })\n+            .collect::<P<[hir::Field]>>();\n+\n+        let is_unit = fields.is_empty();\n+        let struct_path = [sym::ops, path];\n+        let struct_path = self.std_path(span, &struct_path, None, is_unit);\n+        let struct_path = hir::QPath::Resolved(None, P(struct_path));\n+\n+        if is_unit {\n+            hir::ExprKind::Path(struct_path)\n+        } else {\n+            hir::ExprKind::Struct(P(struct_path), fields, None)\n+        }\n+    }\n+\n+    fn lower_label(&mut self, label: Option<Label>) -> Option<hir::Label> {\n+        label.map(|label| hir::Label {\n+            ident: label.ident,\n+        })\n+    }\n+\n+    fn lower_loop_destination(&mut self, destination: Option<(NodeId, Label)>) -> hir::Destination {\n+        let target_id = match destination {\n+            Some((id, _)) => {\n+                if let Some(loop_id) = self.resolver.get_label_res(id) {\n+                    Ok(self.lower_node_id(loop_id))\n+                } else {\n+                    Err(hir::LoopIdError::UnresolvedLabel)\n+                }\n+            }\n+            None => {\n+                self.loop_scopes\n+                    .last()\n+                    .cloned()\n+                    .map(|id| Ok(self.lower_node_id(id)))\n+                    .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope))\n+                    .into()\n+            }\n+        };\n+        hir::Destination {\n+            label: self.lower_label(destination.map(|(_, label)| label)),\n+            target_id,\n+        }\n+    }\n+\n+    fn lower_jump_destination(&mut self, id: NodeId, opt_label: Option<Label>) -> hir::Destination {\n+        if self.is_in_loop_condition && opt_label.is_none() {\n+            hir::Destination {\n+                label: None,\n+                target_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n+            }\n+        } else {\n+            self.lower_loop_destination(opt_label.map(|label| (id, label)))\n+        }\n+    }\n+\n+    fn with_catch_scope<T, F>(&mut self, catch_id: NodeId, f: F) -> T\n+    where\n+        F: FnOnce(&mut LoweringContext<'_>) -> T,\n+    {\n+        let len = self.catch_scopes.len();\n+        self.catch_scopes.push(catch_id);\n+\n+        let result = f(self);\n+        assert_eq!(\n+            len + 1,\n+            self.catch_scopes.len(),\n+            \"catch scopes should be added and removed in stack order\"\n+        );\n+\n+        self.catch_scopes.pop().unwrap();\n+\n+        result\n+    }\n+\n+    fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n+    where\n+        F: FnOnce(&mut LoweringContext<'_>) -> T,\n+    {\n+        // We're no longer in the base loop's condition; we're in another loop.\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = false;\n+\n+        let len = self.loop_scopes.len();\n+        self.loop_scopes.push(loop_id);\n+\n+        let result = f(self);\n+        assert_eq!(\n+            len + 1,\n+            self.loop_scopes.len(),\n+            \"loop scopes should be added and removed in stack order\"\n+        );\n+\n+        self.loop_scopes.pop().unwrap();\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n+        result\n+    }\n+\n+    fn with_loop_condition_scope<T, F>(&mut self, f: F) -> T\n+    where\n+        F: FnOnce(&mut LoweringContext<'_>) -> T,\n+    {\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = true;\n+\n+        let result = f(self);\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n+        result\n+    }\n+\n+    fn lower_expr_asm(&mut self, asm: &InlineAsm) -> hir::ExprKind {\n+        let hir_asm = hir::InlineAsm {\n+            inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n+            outputs: asm.outputs\n+                .iter()\n+                .map(|out| hir::InlineAsmOutput {\n+                    constraint: out.constraint.clone(),\n+                    is_rw: out.is_rw,\n+                    is_indirect: out.is_indirect,\n+                    span: out.expr.span,\n+                })\n+                .collect(),\n+            asm: asm.asm.clone(),\n+            asm_str_style: asm.asm_str_style,\n+            clobbers: asm.clobbers.clone().into(),\n+            volatile: asm.volatile,\n+            alignstack: asm.alignstack,\n+            dialect: asm.dialect,\n+            ctxt: asm.ctxt,\n+        };\n+\n+        let outputs = asm.outputs\n+            .iter()\n+            .map(|out| self.lower_expr(&out.expr))\n+            .collect();\n+\n+        let inputs = asm.inputs\n+            .iter()\n+            .map(|&(_, ref input)| self.lower_expr(input))\n+            .collect();\n+\n+        hir::ExprKind::InlineAsm(P(hir_asm), outputs, inputs)\n+    }\n+\n+    fn lower_field(&mut self, f: &Field) -> hir::Field {\n+        hir::Field {\n+            hir_id: self.next_id(),\n+            ident: f.ident,\n+            expr: P(self.lower_expr(&f.expr)),\n+            span: f.span,\n+            is_shorthand: f.is_shorthand,\n+        }\n+    }\n+\n+    fn lower_expr_yield(&mut self, span: Span, opt_expr: Option<&Expr>) -> hir::ExprKind {\n+        match self.generator_kind {\n+            Some(hir::GeneratorKind::Gen) => {},\n+            Some(hir::GeneratorKind::Async) => {\n+                span_err!(\n+                    self.sess,\n+                    span,\n+                    E0727,\n+                    \"`async` generators are not yet supported\",\n+                );\n+                self.sess.abort_if_errors();\n+            },\n+            None => self.generator_kind = Some(hir::GeneratorKind::Gen),\n+        }\n+\n+        let expr = opt_expr\n+            .as_ref()\n+            .map(|x| self.lower_expr(x))\n+            .unwrap_or_else(|| self.expr_unit(span));\n+\n+        hir::ExprKind::Yield(P(expr), hir::YieldSource::Yield)\n+    }\n+\n+    /// Desugar `ExprForLoop` from: `[opt_ident]: for <pat> in <head> <body>` into:\n+    /// ```rust\n+    /// {\n+    ///     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n+    ///         mut iter => {\n+    ///             [opt_ident]: loop {\n+    ///                 let mut __next;\n+    ///                 match ::std::iter::Iterator::next(&mut iter) {\n+    ///                     ::std::option::Option::Some(val) => __next = val,\n+    ///                     ::std::option::Option::None => break\n+    ///                 };\n+    ///                 let <pat> = __next;\n+    ///                 StmtKind::Expr(<body>);\n+    ///             }\n+    ///         }\n+    ///     };\n+    ///     result\n+    /// }\n+    /// ```\n+    fn lower_expr_for(\n+        &mut self,\n+        e: &Expr,\n+        pat: &Pat,\n+        head: &Expr,\n+        body: &Block,\n+        opt_label: Option<Label>,\n+    ) -> hir::Expr {\n+        // expand <head>\n+        let mut head = self.lower_expr(head);\n+        let head_sp = head.span;\n+        let desugared_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop,\n+            head_sp,\n+            None,\n+        );\n+        head.span = desugared_span;\n+\n+        let iter = Ident::with_empty_ctxt(sym::iter);\n+\n+        let next_ident = Ident::with_empty_ctxt(sym::__next);\n+        let (next_pat, next_pat_hid) = self.pat_ident_binding_mode(\n+            desugared_span,\n+            next_ident,\n+            hir::BindingAnnotation::Mutable,\n+        );\n+\n+        // `::std::option::Option::Some(val) => __next = val`\n+        let pat_arm = {\n+            let val_ident = Ident::with_empty_ctxt(sym::val);\n+            let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n+            let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n+            let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n+            let assign = P(self.expr(\n+                pat.span,\n+                hir::ExprKind::Assign(next_expr, val_expr),\n+                ThinVec::new(),\n+            ));\n+            let some_pat = self.pat_some(pat.span, val_pat);\n+            self.arm(hir_vec![some_pat], assign)\n+        };\n+\n+        // `::std::option::Option::None => break`\n+        let break_arm = {\n+            let break_expr =\n+                self.with_loop_scope(e.id, |this| this.expr_break(e.span, ThinVec::new()));\n+            let pat = self.pat_none(e.span);\n+            self.arm(hir_vec![pat], break_expr)\n+        };\n+\n+        // `mut iter`\n+        let (iter_pat, iter_pat_nid) = self.pat_ident_binding_mode(\n+            desugared_span,\n+            iter,\n+            hir::BindingAnnotation::Mutable\n+        );\n+\n+        // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+        let match_expr = {\n+            let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n+            let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n+            let next_path = &[sym::iter, sym::Iterator, sym::next];\n+            let next_expr = P(self.expr_call_std_path(\n+                head_sp,\n+                next_path,\n+                hir_vec![ref_mut_iter],\n+            ));\n+            let arms = hir_vec![pat_arm, break_arm];\n+\n+            self.expr_match(head_sp, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n+        };\n+        let match_stmt = self.stmt_expr(head_sp, match_expr);\n+\n+        let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat_hid));\n+\n+        // `let mut __next`\n+        let next_let = self.stmt_let_pat(\n+            ThinVec::new(),\n+            desugared_span,\n+            None,\n+            next_pat,\n+            hir::LocalSource::ForLoopDesugar,\n+        );\n+\n+        // `let <pat> = __next`\n+        let pat = self.lower_pat(pat);\n+        let pat_let = self.stmt_let_pat(\n+            ThinVec::new(),\n+            head_sp,\n+            Some(next_expr),\n+            pat,\n+            hir::LocalSource::ForLoopDesugar,\n+        );\n+\n+        let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n+        let body_expr = self.expr_block(body_block, ThinVec::new());\n+        let body_stmt = self.stmt_expr(body.span, body_expr);\n+\n+        let loop_block = P(self.block_all(\n+            e.span,\n+            hir_vec![next_let, match_stmt, pat_let, body_stmt],\n+            None,\n+        ));\n+\n+        // `[opt_ident]: loop { ... }`\n+        let loop_expr = hir::ExprKind::Loop(\n+            loop_block,\n+            self.lower_label(opt_label),\n+            hir::LoopSource::ForLoop,\n+        );\n+        let loop_expr = P(hir::Expr {\n+            hir_id: self.lower_node_id(e.id),\n+            node: loop_expr,\n+            span: e.span,\n+            attrs: ThinVec::new(),\n+        });\n+\n+        // `mut iter => { ... }`\n+        let iter_arm = self.arm(hir_vec![iter_pat], loop_expr);\n+\n+        // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+        let into_iter_expr = {\n+            let into_iter_path =\n+                &[sym::iter, sym::IntoIterator, sym::into_iter];\n+            P(self.expr_call_std_path(\n+                head_sp,\n+                into_iter_path,\n+                hir_vec![head],\n+            ))\n+        };\n+\n+        let match_expr = P(self.expr_match(\n+            head_sp,\n+            into_iter_expr,\n+            hir_vec![iter_arm],\n+            hir::MatchSource::ForLoopDesugar,\n+        ));\n+\n+        // This is effectively `{ let _result = ...; _result }`.\n+        // The construct was introduced in #21984 and is necessary to make sure that\n+        // temporaries in the `head` expression are dropped and do not leak to the\n+        // surrounding scope of the `match` since the `match` is not a terminating scope.\n+        //\n+        // Also, add the attributes to the outer returned expr node.\n+        self.expr_drop_temps(head_sp, match_expr, e.attrs.clone())\n+    }\n+\n+    /// Desugar `ExprKind::Try` from: `<expr>?` into:\n+    /// ```rust\n+    /// match Try::into_result(<expr>) {\n+    ///     Ok(val) => #[allow(unreachable_code)] val,\n+    ///     Err(err) => #[allow(unreachable_code)]\n+    ///                 // If there is an enclosing `try {...}`:\n+    ///                 break 'catch_target Try::from_error(From::from(err)),\n+    ///                 // Otherwise:\n+    ///                 return Try::from_error(From::from(err)),\n+    /// }\n+    /// ```\n+    fn lower_expr_try(&mut self, span: Span, sub_expr: &Expr) -> hir::ExprKind {\n+        let unstable_span = self.mark_span_with_reason(\n+            DesugaringKind::QuestionMark,\n+            span,\n+            self.allow_try_trait.clone(),\n+        );\n+        let try_span = self.sess.source_map().end_point(span);\n+        let try_span = self.mark_span_with_reason(\n+            DesugaringKind::QuestionMark,\n+            try_span,\n+            self.allow_try_trait.clone(),\n+        );\n+\n+        // `Try::into_result(<expr>)`\n+        let scrutinee = {\n+            // expand <expr>\n+            let sub_expr = self.lower_expr(sub_expr);\n+\n+            let path = &[sym::ops, sym::Try, sym::into_result];\n+            P(self.expr_call_std_path(unstable_span, path, hir_vec![sub_expr]))\n+        };\n+\n+        // `#[allow(unreachable_code)]`\n+        let attr = {\n+            // `allow(unreachable_code)`\n+            let allow = {\n+                let allow_ident = Ident::new(sym::allow, span);\n+                let uc_ident = Ident::new(sym::unreachable_code, span);\n+                let uc_nested = attr::mk_nested_word_item(uc_ident);\n+                attr::mk_list_item(allow_ident, vec![uc_nested])\n+            };\n+            attr::mk_attr_outer(allow)\n+        };\n+        let attrs = vec![attr];\n+\n+        // `Ok(val) => #[allow(unreachable_code)] val,`\n+        let ok_arm = {\n+            let val_ident = Ident::with_empty_ctxt(sym::val);\n+            let (val_pat, val_pat_nid) = self.pat_ident(span, val_ident);\n+            let val_expr = P(self.expr_ident_with_attrs(\n+                span,\n+                val_ident,\n+                val_pat_nid,\n+                ThinVec::from(attrs.clone()),\n+            ));\n+            let ok_pat = self.pat_ok(span, val_pat);\n+\n+            self.arm(hir_vec![ok_pat], val_expr)\n+        };\n+\n+        // `Err(err) => #[allow(unreachable_code)]\n+        //              return Try::from_error(From::from(err)),`\n+        let err_arm = {\n+            let err_ident = Ident::with_empty_ctxt(sym::err);\n+            let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n+            let from_expr = {\n+                let from_path = &[sym::convert, sym::From, sym::from];\n+                let err_expr = self.expr_ident(try_span, err_ident, err_local_nid);\n+                self.expr_call_std_path(try_span, from_path, hir_vec![err_expr])\n+            };\n+            let from_err_expr =\n+                self.wrap_in_try_constructor(sym::from_error, from_expr, unstable_span);\n+            let thin_attrs = ThinVec::from(attrs);\n+            let catch_scope = self.catch_scopes.last().map(|x| *x);\n+            let ret_expr = if let Some(catch_node) = catch_scope {\n+                let target_id = Ok(self.lower_node_id(catch_node));\n+                P(self.expr(\n+                    try_span,\n+                    hir::ExprKind::Break(\n+                        hir::Destination {\n+                            label: None,\n+                            target_id,\n+                        },\n+                        Some(from_err_expr),\n+                    ),\n+                    thin_attrs,\n+                ))\n+            } else {\n+                P(self.expr(try_span, hir::ExprKind::Ret(Some(from_err_expr)), thin_attrs))\n+            };\n+\n+            let err_pat = self.pat_err(try_span, err_local);\n+            self.arm(hir_vec![err_pat], ret_expr)\n+        };\n+\n+        hir::ExprKind::Match(\n+            scrutinee,\n+            hir_vec![err_arm, ok_arm],\n+            hir::MatchSource::TryDesugar,\n+        )\n+    }\n+\n+    // =========================================================================\n+    // Helper methods for building HIR.\n+    // =========================================================================\n+\n+    /// Constructs a `true` or `false` literal expression.\n+    pub(super) fn expr_bool(&mut self, span: Span, val: bool) -> hir::Expr {\n+        let lit = Spanned { span, node: LitKind::Bool(val) };\n+        self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new())\n+    }\n+\n+    /// Wrap the given `expr` in a terminating scope using `hir::ExprKind::DropTemps`.\n+    ///\n+    /// In terms of drop order, it has the same effect as wrapping `expr` in\n+    /// `{ let _t = $expr; _t }` but should provide better compile-time performance.\n+    ///\n+    /// The drop order can be important in e.g. `if expr { .. }`.\n+    fn expr_drop_temps(\n+        &mut self,\n+        span: Span,\n+        expr: P<hir::Expr>,\n+        attrs: ThinVec<Attribute>\n+    ) -> hir::Expr {\n+        self.expr(span, hir::ExprKind::DropTemps(expr), attrs)\n+    }\n+\n+    fn expr_match(\n+        &mut self,\n+        span: Span,\n+        arg: P<hir::Expr>,\n+        arms: hir::HirVec<hir::Arm>,\n+        source: hir::MatchSource,\n+    ) -> hir::Expr {\n+        self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n+    }\n+\n+    fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n+        let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n+        P(self.expr(span, expr_break, attrs))\n+    }\n+\n+    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n+        self.expr(span, hir::ExprKind::AddrOf(hir::MutMutable, e), ThinVec::new())\n+    }\n+\n+    fn expr_unit(&mut self, sp: Span) -> hir::Expr {\n+        self.expr_tuple(sp, hir_vec![])\n+    }\n+\n+    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<hir::Expr>) -> hir::Expr {\n+        self.expr(sp, hir::ExprKind::Tup(exprs), ThinVec::new())\n+    }\n+\n+    fn expr_call(\n+        &mut self,\n+        span: Span,\n+        e: P<hir::Expr>,\n+        args: hir::HirVec<hir::Expr>,\n+    ) -> hir::Expr {\n+        self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new())\n+    }\n+\n+    // Note: associated functions must use `expr_call_std_path`.\n+    fn expr_call_std_path(\n+        &mut self,\n+        span: Span,\n+        path_components: &[Symbol],\n+        args: hir::HirVec<hir::Expr>,\n+    ) -> hir::Expr {\n+        let path = P(self.expr_std_path(span, path_components, None, ThinVec::new()));\n+        self.expr_call(span, path, args)\n+    }\n+\n+    // Create an expression calling an associated function of an std type.\n+    //\n+    // Associated functions cannot be resolved through the normal `std_path` function,\n+    // as they are resolved differently and so cannot use `expr_call_std_path`.\n+    //\n+    // This function accepts the path component (`ty_path_components`) separately from\n+    // the name of the associated function (`assoc_fn_name`) in order to facilitate\n+    // separate resolution of the type and creation of a path referring to its associated\n+    // function.\n+    fn expr_call_std_assoc_fn(\n+        &mut self,\n+        ty_path_id: hir::HirId,\n+        span: Span,\n+        ty_path_components: &[Symbol],\n+        assoc_fn_name: &str,\n+        args: hir::HirVec<hir::Expr>,\n+    ) -> hir::ExprKind {\n+        let ty_path = P(self.std_path(span, ty_path_components, None, false));\n+        let ty = P(self.ty_path(ty_path_id, span, hir::QPath::Resolved(None, ty_path)));\n+        let fn_seg = P(hir::PathSegment::from_ident(Ident::from_str(assoc_fn_name)));\n+        let fn_path = hir::QPath::TypeRelative(ty, fn_seg);\n+        let fn_expr = P(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n+        hir::ExprKind::Call(fn_expr, args)\n+    }\n+\n+    fn expr_std_path(\n+        &mut self,\n+        span: Span,\n+        components: &[Symbol],\n+        params: Option<P<hir::GenericArgs>>,\n+        attrs: ThinVec<Attribute>,\n+    ) -> hir::Expr {\n+        let path = self.std_path(span, components, params, true);\n+        self.expr(\n+            span,\n+            hir::ExprKind::Path(hir::QPath::Resolved(None, P(path))),\n+            attrs,\n+        )\n+    }\n+\n+    pub(super) fn expr_ident(&mut self, sp: Span, ident: Ident, binding: hir::HirId) -> hir::Expr {\n+        self.expr_ident_with_attrs(sp, ident, binding, ThinVec::new())\n+    }\n+\n+    fn expr_ident_with_attrs(\n+        &mut self,\n+        span: Span,\n+        ident: Ident,\n+        binding: hir::HirId,\n+        attrs: ThinVec<Attribute>,\n+    ) -> hir::Expr {\n+        let expr_path = hir::ExprKind::Path(hir::QPath::Resolved(\n+            None,\n+            P(hir::Path {\n+                span,\n+                res: Res::Local(binding),\n+                segments: hir_vec![hir::PathSegment::from_ident(ident)],\n+            }),\n+        ));\n+\n+        self.expr(span, expr_path, attrs)\n+    }\n+\n+    fn expr_unsafe(&mut self, expr: P<hir::Expr>) -> hir::Expr {\n+        let hir_id = self.next_id();\n+        let span = expr.span;\n+        self.expr(\n+            span,\n+            hir::ExprKind::Block(P(hir::Block {\n+                stmts: hir_vec![],\n+                expr: Some(expr),\n+                hir_id,\n+                rules: hir::UnsafeBlock(hir::CompilerGenerated),\n+                span,\n+                targeted_by_break: false,\n+            }), None),\n+            ThinVec::new(),\n+        )\n+    }\n+\n+    fn expr_block_empty(&mut self, span: Span) -> hir::Expr {\n+        let blk = self.block_all(span, hir_vec![], None);\n+        self.expr_block(P(blk), ThinVec::new())\n+    }\n+\n+    pub(super) fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> hir::Expr {\n+        self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n+    }\n+\n+    pub(super) fn expr(\n+        &mut self,\n+        span: Span,\n+        node: hir::ExprKind,\n+        attrs: ThinVec<Attribute>\n+    ) -> hir::Expr {\n+        hir::Expr {\n+            hir_id: self.next_id(),\n+            node,\n+            span,\n+            attrs,\n+        }\n+    }\n+\n+    fn field(&mut self, ident: Ident, expr: P<hir::Expr>, span: Span) -> hir::Field {\n+        hir::Field {\n+            hir_id: self.next_id(),\n+            ident,\n+            span,\n+            expr,\n+            is_shorthand: false,\n+        }\n+    }\n+\n+    fn arm(&mut self, pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+        hir::Arm {\n+            hir_id: self.next_id(),\n+            attrs: hir_vec![],\n+            pats,\n+            guard: None,\n+            span: expr.span,\n+            body: expr,\n+        }\n+    }\n+}"}, {"sha": "6b717e75199c7f99514c2f97bd63f794cce175f0", "filename": "src/librustc/hir/lowering/item.rs", "status": "added", "additions": 1410, "deletions": 0, "changes": 1410, "blob_url": "https://github.com/rust-lang/rust/blob/8a068699a24de306334a1f66b9a83552766d853c/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a068699a24de306334a1f66b9a83552766d853c/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=8a068699a24de306334a1f66b9a83552766d853c", "patch": "@@ -0,0 +1,1410 @@\n+use super::LoweringContext;\n+use super::ImplTraitContext;\n+use super::ImplTraitPosition;\n+use super::ImplTraitTypeIdVisitor;\n+use super::AnonymousLifetimeMode;\n+use super::ParamMode;\n+\n+use crate::hir::{self, HirVec};\n+use crate::hir::ptr::P;\n+use crate::hir::def_id::DefId;\n+use crate::hir::def::{Res, DefKind};\n+use crate::util::nodemap::NodeMap;\n+\n+use rustc_data_structures::thin_vec::ThinVec;\n+\n+use std::collections::BTreeSet;\n+use smallvec::SmallVec;\n+use syntax::attr;\n+use syntax::ast::*;\n+use syntax::visit::{self, Visitor};\n+use syntax::ext::base::SpecialDerives;\n+use syntax::source_map::{respan, DesugaringKind, Spanned};\n+use syntax::symbol::{kw, sym};\n+use syntax_pos::Span;\n+\n+pub(super) struct ItemLowerer<'tcx, 'interner> {\n+    pub(super) lctx: &'tcx mut LoweringContext<'interner>,\n+}\n+\n+impl<'tcx, 'interner> ItemLowerer<'tcx, 'interner> {\n+    fn with_trait_impl_ref<F>(&mut self, trait_impl_ref: &Option<TraitRef>, f: F)\n+    where\n+        F: FnOnce(&mut Self),\n+    {\n+        let old = self.lctx.is_in_trait_impl;\n+        self.lctx.is_in_trait_impl = if let &None = trait_impl_ref {\n+            false\n+        } else {\n+            true\n+        };\n+        f(self);\n+        self.lctx.is_in_trait_impl = old;\n+    }\n+}\n+\n+impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n+    fn visit_mod(&mut self, m: &'tcx Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n+        self.lctx.modules.insert(n, hir::ModuleItems {\n+            items: BTreeSet::new(),\n+            trait_items: BTreeSet::new(),\n+            impl_items: BTreeSet::new(),\n+        });\n+\n+        let old = self.lctx.current_module;\n+        self.lctx.current_module = n;\n+        visit::walk_mod(self, m);\n+        self.lctx.current_module = old;\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx Item) {\n+        let mut item_hir_id = None;\n+        self.lctx.with_hir_id_owner(item.id, |lctx| {\n+            if let Some(hir_item) = lctx.lower_item(item) {\n+                item_hir_id = Some(hir_item.hir_id);\n+                lctx.insert_item(hir_item);\n+            }\n+        });\n+\n+        if let Some(hir_id) = item_hir_id {\n+            self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n+                let this = &mut ItemLowerer { lctx: this };\n+                if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.node {\n+                    this.with_trait_impl_ref(opt_trait_ref, |this| {\n+                        visit::walk_item(this, item)\n+                    });\n+                } else {\n+                    visit::walk_item(this, item);\n+                }\n+            });\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, item: &'tcx TraitItem) {\n+        self.lctx.with_hir_id_owner(item.id, |lctx| {\n+            let hir_item = lctx.lower_trait_item(item);\n+            let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n+            lctx.trait_items.insert(id, hir_item);\n+            lctx.modules.get_mut(&lctx.current_module).unwrap().trait_items.insert(id);\n+        });\n+\n+        visit::walk_trait_item(self, item);\n+    }\n+\n+    fn visit_impl_item(&mut self, item: &'tcx ImplItem) {\n+        self.lctx.with_hir_id_owner(item.id, |lctx| {\n+            let hir_item = lctx.lower_impl_item(item);\n+            let id = hir::ImplItemId { hir_id: hir_item.hir_id };\n+            lctx.impl_items.insert(id, hir_item);\n+            lctx.modules.get_mut(&lctx.current_module).unwrap().impl_items.insert(id);\n+        });\n+        visit::walk_impl_item(self, item);\n+    }\n+}\n+\n+impl LoweringContext<'_> {\n+    // Same as the method above, but accepts `hir::GenericParam`s\n+    // instead of `ast::GenericParam`s.\n+    // This should only be used with generics that have already had their\n+    // in-band lifetimes added. In practice, this means that this function is\n+    // only used when lowering a child item of a trait or impl.\n+    fn with_parent_item_lifetime_defs<T>(\n+        &mut self,\n+        parent_hir_id: hir::HirId,\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> T,\n+    ) -> T {\n+        let old_len = self.in_scope_lifetimes.len();\n+\n+        let parent_generics = match self.items.get(&parent_hir_id).unwrap().node {\n+            hir::ItemKind::Impl(_, _, _, ref generics, ..)\n+            | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n+                &generics.params[..]\n+            }\n+            _ => &[],\n+        };\n+        let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n+            hir::GenericParamKind::Lifetime { .. } => Some(param.name.ident().modern()),\n+            _ => None,\n+        });\n+        self.in_scope_lifetimes.extend(lt_def_names);\n+\n+        let res = f(self);\n+\n+        self.in_scope_lifetimes.truncate(old_len);\n+        res\n+    }\n+\n+    pub(super) fn lower_mod(&mut self, m: &Mod) -> hir::Mod {\n+        hir::Mod {\n+            inner: m.inner,\n+            item_ids: m.items.iter().flat_map(|x| self.lower_item_id(x)).collect(),\n+        }\n+    }\n+\n+    pub(super) fn lower_item_id(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n+        let node_ids = match i.node {\n+            ItemKind::Use(ref use_tree) => {\n+                let mut vec = smallvec![i.id];\n+                self.lower_item_id_use_tree(use_tree, i.id, &mut vec);\n+                vec\n+            }\n+            ItemKind::MacroDef(..) => SmallVec::new(),\n+            ItemKind::Fn(..) |\n+            ItemKind::Impl(.., None, _, _) => smallvec![i.id],\n+            ItemKind::Static(ref ty, ..) => {\n+                let mut ids = smallvec![i.id];\n+                if self.sess.features_untracked().impl_trait_in_bindings {\n+                    let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n+                    visitor.visit_ty(ty);\n+                }\n+                ids\n+            },\n+            ItemKind::Const(ref ty, ..) => {\n+                let mut ids = smallvec![i.id];\n+                if self.sess.features_untracked().impl_trait_in_bindings {\n+                    let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n+                    visitor.visit_ty(ty);\n+                }\n+                ids\n+            },\n+            _ => smallvec![i.id],\n+        };\n+\n+        node_ids.into_iter().map(|node_id| hir::ItemId {\n+            id: self.allocate_hir_id_counter(node_id)\n+        }).collect()\n+    }\n+\n+    fn lower_item_id_use_tree(\n+        &mut self,\n+        tree: &UseTree,\n+        base_id: NodeId,\n+        vec: &mut SmallVec<[NodeId; 1]>\n+    ) {\n+        match tree.kind {\n+            UseTreeKind::Nested(ref nested_vec) => for &(ref nested, id) in nested_vec {\n+                vec.push(id);\n+                self.lower_item_id_use_tree(nested, id, vec);\n+            },\n+            UseTreeKind::Glob => {}\n+            UseTreeKind::Simple(_, id1, id2) => {\n+                for (_, &id) in self.expect_full_res_from_use(base_id)\n+                                    .skip(1)\n+                                    .zip([id1, id2].iter())\n+                {\n+                    vec.push(id);\n+                }\n+            },\n+        }\n+    }\n+\n+    pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item> {\n+        let mut ident = i.ident;\n+        let mut vis = self.lower_visibility(&i.vis, None);\n+        let mut attrs = self.lower_attrs_extendable(&i.attrs);\n+        if self.resolver.has_derives(i.id, SpecialDerives::PARTIAL_EQ | SpecialDerives::EQ) {\n+            // Add `#[structural_match]` if the item derived both `PartialEq` and `Eq`.\n+            let ident = Ident::new(sym::structural_match, i.span);\n+            attrs.push(attr::mk_attr_outer(attr::mk_word_item(ident)));\n+        }\n+        let attrs = attrs.into();\n+\n+        if let ItemKind::MacroDef(ref def) = i.node {\n+            if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n+                let body = self.lower_token_stream(def.stream());\n+                let hir_id = self.lower_node_id(i.id);\n+                self.exported_macros.push(hir::MacroDef {\n+                    name: ident.name,\n+                    vis,\n+                    attrs,\n+                    hir_id,\n+                    span: i.span,\n+                    body,\n+                    legacy: def.legacy,\n+                });\n+            } else {\n+                self.non_exported_macro_attrs.extend(attrs.into_iter());\n+            }\n+            return None;\n+        }\n+\n+        let node = self.lower_item_kind(i.id, &mut ident, &attrs, &mut vis, &i.node);\n+\n+        Some(hir::Item {\n+            hir_id: self.lower_node_id(i.id),\n+            ident,\n+            attrs,\n+            node,\n+            vis,\n+            span: i.span,\n+        })\n+    }\n+\n+    fn lower_item_kind(\n+        &mut self,\n+        id: NodeId,\n+        ident: &mut Ident,\n+        attrs: &hir::HirVec<Attribute>,\n+        vis: &mut hir::Visibility,\n+        i: &ItemKind,\n+    ) -> hir::ItemKind {\n+        match *i {\n+            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n+            ItemKind::Use(ref use_tree) => {\n+                // Start with an empty prefix.\n+                let prefix = Path {\n+                    segments: vec![],\n+                    span: use_tree.span,\n+                };\n+\n+                self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n+            }\n+            ItemKind::Static(ref t, m, ref e) => {\n+                hir::ItemKind::Static(\n+                    self.lower_ty(\n+                        t,\n+                        if self.sess.features_untracked().impl_trait_in_bindings {\n+                            ImplTraitContext::OpaqueTy(None)\n+                        } else {\n+                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+                        }\n+                    ),\n+                    self.lower_mutability(m),\n+                    self.lower_const_body(e),\n+                )\n+            }\n+            ItemKind::Const(ref t, ref e) => {\n+                hir::ItemKind::Const(\n+                    self.lower_ty(\n+                        t,\n+                        if self.sess.features_untracked().impl_trait_in_bindings {\n+                            ImplTraitContext::OpaqueTy(None)\n+                        } else {\n+                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+                        }\n+                    ),\n+                    self.lower_const_body(e)\n+                )\n+            }\n+            ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n+                let fn_def_id = self.resolver.definitions().local_def_id(id);\n+                self.with_new_scopes(|this| {\n+                    this.current_item = Some(ident.span);\n+\n+                    // Note: we don't need to change the return type from `T` to\n+                    // `impl Future<Output = T>` here because lower_body\n+                    // only cares about the input argument patterns in the function\n+                    // declaration (decl), not the return types.\n+                    let body_id = this.lower_maybe_async_body(&decl, header.asyncness.node, body);\n+\n+                    let (generics, fn_decl) = this.add_in_band_defs(\n+                        generics,\n+                        fn_def_id,\n+                        AnonymousLifetimeMode::PassThrough,\n+                        |this, idty| this.lower_fn_decl(\n+                            &decl,\n+                            Some((fn_def_id, idty)),\n+                            true,\n+                            header.asyncness.node.opt_return_id()\n+                        ),\n+                    );\n+\n+                    hir::ItemKind::Fn(\n+                        fn_decl,\n+                        this.lower_fn_header(header),\n+                        generics,\n+                        body_id,\n+                    )\n+                })\n+            }\n+            ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n+            ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n+            ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n+            ItemKind::TyAlias(ref t, ref generics) => hir::ItemKind::TyAlias(\n+                self.lower_ty(t, ImplTraitContext::disallowed()),\n+                self.lower_generics(generics, ImplTraitContext::disallowed()),\n+            ),\n+            ItemKind::OpaqueTy(ref b, ref generics) => hir::ItemKind::OpaqueTy(\n+                hir::OpaqueTy {\n+                    generics: self.lower_generics(generics,\n+                        ImplTraitContext::OpaqueTy(None)),\n+                    bounds: self.lower_param_bounds(b,\n+                        ImplTraitContext::OpaqueTy(None)),\n+                    impl_trait_fn: None,\n+                    origin: hir::OpaqueTyOrigin::TypeAlias,\n+                },\n+            ),\n+            ItemKind::Enum(ref enum_definition, ref generics) => {\n+                hir::ItemKind::Enum(\n+                    hir::EnumDef {\n+                        variants: enum_definition\n+                            .variants\n+                            .iter()\n+                            .map(|x| self.lower_variant(x))\n+                            .collect(),\n+                    },\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                )\n+            },\n+            ItemKind::Struct(ref struct_def, ref generics) => {\n+                let struct_def = self.lower_variant_data(struct_def);\n+                hir::ItemKind::Struct(\n+                    struct_def,\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                )\n+            }\n+            ItemKind::Union(ref vdata, ref generics) => {\n+                let vdata = self.lower_variant_data(vdata);\n+                hir::ItemKind::Union(\n+                    vdata,\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                )\n+            }\n+            ItemKind::Impl(\n+                unsafety,\n+                polarity,\n+                defaultness,\n+                ref ast_generics,\n+                ref trait_ref,\n+                ref ty,\n+                ref impl_items,\n+            ) => {\n+                let def_id = self.resolver.definitions().local_def_id(id);\n+\n+                // Lower the \"impl header\" first. This ordering is important\n+                // for in-band lifetimes! Consider `'a` here:\n+                //\n+                //     impl Foo<'a> for u32 {\n+                //         fn method(&'a self) { .. }\n+                //     }\n+                //\n+                // Because we start by lowering the `Foo<'a> for u32`\n+                // part, we will add `'a` to the list of generics on\n+                // the impl. When we then encounter it later in the\n+                // method, it will not be considered an in-band\n+                // lifetime to be added, but rather a reference to a\n+                // parent lifetime.\n+                let lowered_trait_impl_id = self.lower_node_id(id);\n+                let (generics, (trait_ref, lowered_ty)) = self.add_in_band_defs(\n+                    ast_generics,\n+                    def_id,\n+                    AnonymousLifetimeMode::CreateParameter,\n+                    |this, _| {\n+                        let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n+                            this.lower_trait_ref(trait_ref, ImplTraitContext::disallowed())\n+                        });\n+\n+                        if let Some(ref trait_ref) = trait_ref {\n+                            if let Res::Def(DefKind::Trait, def_id) = trait_ref.path.res {\n+                                this.trait_impls.entry(def_id).or_default().push(\n+                                    lowered_trait_impl_id);\n+                            }\n+                        }\n+\n+                        let lowered_ty = this.lower_ty(ty, ImplTraitContext::disallowed());\n+\n+                        (trait_ref, lowered_ty)\n+                    },\n+                );\n+\n+                let new_impl_items = self.with_in_scope_lifetime_defs(\n+                    &ast_generics.params,\n+                    |this| {\n+                        impl_items\n+                            .iter()\n+                            .map(|item| this.lower_impl_item_ref(item))\n+                            .collect()\n+                    },\n+                );\n+\n+                hir::ItemKind::Impl(\n+                    self.lower_unsafety(unsafety),\n+                    self.lower_impl_polarity(polarity),\n+                    self.lower_defaultness(defaultness, true /* [1] */),\n+                    generics,\n+                    trait_ref,\n+                    lowered_ty,\n+                    new_impl_items,\n+                )\n+            }\n+            ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref items) => {\n+                let bounds = self.lower_param_bounds(bounds, ImplTraitContext::disallowed());\n+                let items = items\n+                    .iter()\n+                    .map(|item| self.lower_trait_item_ref(item))\n+                    .collect();\n+                hir::ItemKind::Trait(\n+                    self.lower_is_auto(is_auto),\n+                    self.lower_unsafety(unsafety),\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                    bounds,\n+                    items,\n+                )\n+            }\n+            ItemKind::TraitAlias(ref generics, ref bounds) => hir::ItemKind::TraitAlias(\n+                self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n+            ),\n+            ItemKind::MacroDef(..)\n+            | ItemKind::Mac(..) => bug!(\"`TyMac` should have been expanded by now\"),\n+        }\n+\n+        // [1] `defaultness.has_value()` is never called for an `impl`, always `true` in order to\n+        //     not cause an assertion failure inside the `lower_defaultness` function.\n+    }\n+\n+    fn lower_use_tree(\n+        &mut self,\n+        tree: &UseTree,\n+        prefix: &Path,\n+        id: NodeId,\n+        vis: &mut hir::Visibility,\n+        ident: &mut Ident,\n+        attrs: &hir::HirVec<Attribute>,\n+    ) -> hir::ItemKind {\n+        debug!(\"lower_use_tree(tree={:?})\", tree);\n+        debug!(\"lower_use_tree: vis = {:?}\", vis);\n+\n+        let path = &tree.prefix;\n+        let segments = prefix\n+            .segments\n+            .iter()\n+            .chain(path.segments.iter())\n+            .cloned()\n+            .collect();\n+\n+        match tree.kind {\n+            UseTreeKind::Simple(rename, id1, id2) => {\n+                *ident = tree.ident();\n+\n+                // First, apply the prefix to the path.\n+                let mut path = Path {\n+                    segments,\n+                    span: path.span,\n+                };\n+\n+                // Correctly resolve `self` imports.\n+                if path.segments.len() > 1\n+                    && path.segments.last().unwrap().ident.name == kw::SelfLower\n+                {\n+                    let _ = path.segments.pop();\n+                    if rename.is_none() {\n+                        *ident = path.segments.last().unwrap().ident;\n+                    }\n+                }\n+\n+                let mut resolutions = self.expect_full_res_from_use(id);\n+                // We want to return *something* from this function, so hold onto the first item\n+                // for later.\n+                let ret_res = self.lower_res(resolutions.next().unwrap_or(Res::Err));\n+\n+                // Here, we are looping over namespaces, if they exist for the definition\n+                // being imported. We only handle type and value namespaces because we\n+                // won't be dealing with macros in the rest of the compiler.\n+                // Essentially a single `use` which imports two names is desugared into\n+                // two imports.\n+                for (res, &new_node_id) in resolutions.zip([id1, id2].iter()) {\n+                    let ident = *ident;\n+                    let mut path = path.clone();\n+                    for seg in &mut path.segments {\n+                        seg.id = self.sess.next_node_id();\n+                    }\n+                    let span = path.span;\n+\n+                    self.with_hir_id_owner(new_node_id, |this| {\n+                        let new_id = this.lower_node_id(new_node_id);\n+                        let res = this.lower_res(res);\n+                        let path =\n+                            this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n+                        let item = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n+                        let vis = this.rebuild_vis(&vis);\n+\n+                        this.insert_item(\n+                            hir::Item {\n+                                hir_id: new_id,\n+                                ident,\n+                                attrs: attrs.into_iter().cloned().collect(),\n+                                node: item,\n+                                vis,\n+                                span,\n+                            },\n+                        );\n+                    });\n+                }\n+\n+                let path =\n+                    P(self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None));\n+                hir::ItemKind::Use(path, hir::UseKind::Single)\n+            }\n+            UseTreeKind::Glob => {\n+                let path = P(self.lower_path(\n+                    id,\n+                    &Path {\n+                        segments,\n+                        span: path.span,\n+                    },\n+                    ParamMode::Explicit,\n+                ));\n+                hir::ItemKind::Use(path, hir::UseKind::Glob)\n+            }\n+            UseTreeKind::Nested(ref trees) => {\n+                // Nested imports are desugared into simple imports.\n+                // So, if we start with\n+                //\n+                // ```\n+                // pub(x) use foo::{a, b};\n+                // ```\n+                //\n+                // we will create three items:\n+                //\n+                // ```\n+                // pub(x) use foo::a;\n+                // pub(x) use foo::b;\n+                // pub(x) use foo::{}; // <-- this is called the `ListStem`\n+                // ```\n+                //\n+                // The first two are produced by recursively invoking\n+                // `lower_use_tree` (and indeed there may be things\n+                // like `use foo::{a::{b, c}}` and so forth).  They\n+                // wind up being directly added to\n+                // `self.items`. However, the structure of this\n+                // function also requires us to return one item, and\n+                // for that we return the `{}` import (called the\n+                // `ListStem`).\n+\n+                let prefix = Path {\n+                    segments,\n+                    span: prefix.span.to(path.span),\n+                };\n+\n+                // Add all the nested `PathListItem`s to the HIR.\n+                for &(ref use_tree, id) in trees {\n+                    let new_hir_id = self.lower_node_id(id);\n+\n+                    let mut prefix = prefix.clone();\n+\n+                    // Give the segments new node-ids since they are being cloned.\n+                    for seg in &mut prefix.segments {\n+                        seg.id = self.sess.next_node_id();\n+                    }\n+\n+                    // Each `use` import is an item and thus are owners of the\n+                    // names in the path. Up to this point the nested import is\n+                    // the current owner, since we want each desugared import to\n+                    // own its own names, we have to adjust the owner before\n+                    // lowering the rest of the import.\n+                    self.with_hir_id_owner(id, |this| {\n+                        let mut vis = this.rebuild_vis(&vis);\n+                        let mut ident = *ident;\n+\n+                        let item = this.lower_use_tree(use_tree,\n+                                                       &prefix,\n+                                                       id,\n+                                                       &mut vis,\n+                                                       &mut ident,\n+                                                       attrs);\n+\n+                        this.insert_item(\n+                            hir::Item {\n+                                hir_id: new_hir_id,\n+                                ident,\n+                                attrs: attrs.into_iter().cloned().collect(),\n+                                node: item,\n+                                vis,\n+                                span: use_tree.span,\n+                            },\n+                        );\n+                    });\n+                }\n+\n+                // Subtle and a bit hacky: we lower the privacy level\n+                // of the list stem to \"private\" most of the time, but\n+                // not for \"restricted\" paths. The key thing is that\n+                // we don't want it to stay as `pub` (with no caveats)\n+                // because that affects rustdoc and also the lints\n+                // about `pub` items. But we can't *always* make it\n+                // private -- particularly not for restricted paths --\n+                // because it contains node-ids that would then be\n+                // unused, failing the check that HirIds are \"densely\n+                // assigned\".\n+                match vis.node {\n+                    hir::VisibilityKind::Public |\n+                    hir::VisibilityKind::Crate(_) |\n+                    hir::VisibilityKind::Inherited => {\n+                        *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n+                    }\n+                    hir::VisibilityKind::Restricted { .. } => {\n+                        // Do nothing here, as described in the comment on the match.\n+                    }\n+                }\n+\n+                let res = self.expect_full_res_from_use(id).next().unwrap_or(Res::Err);\n+                let res = self.lower_res(res);\n+                let path = P(self.lower_path_extra(res, &prefix, ParamMode::Explicit, None));\n+                hir::ItemKind::Use(path, hir::UseKind::ListStem)\n+            }\n+        }\n+    }\n+\n+    /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n+    /// many times in the HIR tree; for each occurrence, we need to assign distinct\n+    /// `NodeId`s. (See, e.g., #56128.)\n+    fn rebuild_use_path(&mut self, path: &hir::Path) -> hir::Path {\n+        debug!(\"rebuild_use_path(path = {:?})\", path);\n+        let segments = path.segments.iter().map(|seg| hir::PathSegment {\n+            ident: seg.ident,\n+            hir_id: seg.hir_id.map(|_| self.next_id()),\n+            res: seg.res,\n+            args: None,\n+            infer_args: seg.infer_args,\n+        }).collect();\n+        hir::Path {\n+            span: path.span,\n+            res: path.res,\n+            segments,\n+        }\n+    }\n+\n+    fn rebuild_vis(&mut self, vis: &hir::Visibility) -> hir::Visibility {\n+        let vis_kind = match vis.node {\n+            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n+            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n+            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n+            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n+                hir::VisibilityKind::Restricted {\n+                    path: P(self.rebuild_use_path(path)),\n+                    hir_id: self.next_id(),\n+                }\n+            }\n+        };\n+        respan(vis.span, vis_kind)\n+    }\n+\n+    fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem {\n+        let def_id = self.resolver.definitions().local_def_id(i.id);\n+        hir::ForeignItem {\n+            hir_id: self.lower_node_id(i.id),\n+            ident: i.ident,\n+            attrs: self.lower_attrs(&i.attrs),\n+            node: match i.node {\n+                ForeignItemKind::Fn(ref fdec, ref generics) => {\n+                    let (generics, (fn_dec, fn_args)) = self.add_in_band_defs(\n+                        generics,\n+                        def_id,\n+                        AnonymousLifetimeMode::PassThrough,\n+                        |this, _| {\n+                            (\n+                                // Disallow impl Trait in foreign items\n+                                this.lower_fn_decl(fdec, None, false, None),\n+                                this.lower_fn_args_to_names(fdec),\n+                            )\n+                        },\n+                    );\n+\n+                    hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n+                }\n+                ForeignItemKind::Static(ref t, m) => {\n+                    hir::ForeignItemKind::Static(\n+                        self.lower_ty(t, ImplTraitContext::disallowed()), self.lower_mutability(m))\n+                }\n+                ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n+                ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n+            },\n+            vis: self.lower_visibility(&i.vis, None),\n+            span: i.span,\n+        }\n+    }\n+\n+    fn lower_foreign_mod(&mut self, fm: &ForeignMod) -> hir::ForeignMod {\n+        hir::ForeignMod {\n+            abi: fm.abi,\n+            items: fm.items\n+                .iter()\n+                .map(|x| self.lower_foreign_item(x))\n+                .collect(),\n+        }\n+    }\n+\n+    fn lower_global_asm(&mut self, ga: &GlobalAsm) -> P<hir::GlobalAsm> {\n+        P(hir::GlobalAsm {\n+            asm: ga.asm,\n+            ctxt: ga.ctxt,\n+        })\n+    }\n+\n+    fn lower_variant(&mut self, v: &Variant) -> hir::Variant {\n+        Spanned {\n+            node: hir::VariantKind {\n+                ident: v.node.ident,\n+                id: self.lower_node_id(v.node.id),\n+                attrs: self.lower_attrs(&v.node.attrs),\n+                data: self.lower_variant_data(&v.node.data),\n+                disr_expr: v.node.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n+            },\n+            span: v.span,\n+        }\n+    }\n+\n+    fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData {\n+        match *vdata {\n+            VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n+                fields.iter().enumerate().map(|f| self.lower_struct_field(f)).collect(),\n+                recovered,\n+            ),\n+            VariantData::Tuple(ref fields, id) => {\n+                hir::VariantData::Tuple(\n+                    fields\n+                        .iter()\n+                        .enumerate()\n+                        .map(|f| self.lower_struct_field(f))\n+                        .collect(),\n+                    self.lower_node_id(id),\n+                )\n+            },\n+            VariantData::Unit(id) => {\n+                hir::VariantData::Unit(self.lower_node_id(id))\n+            },\n+        }\n+    }\n+\n+    fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField {\n+        let ty = if let TyKind::Path(ref qself, ref path) = f.ty.node {\n+            let t = self.lower_path_ty(\n+                &f.ty,\n+                qself,\n+                path,\n+                ParamMode::ExplicitNamed, // no `'_` in declarations (Issue #61124)\n+                ImplTraitContext::disallowed()\n+            );\n+            P(t)\n+        } else {\n+            self.lower_ty(&f.ty, ImplTraitContext::disallowed())\n+        };\n+        hir::StructField {\n+            span: f.span,\n+            hir_id: self.lower_node_id(f.id),\n+            ident: match f.ident {\n+                Some(ident) => ident,\n+                // FIXME(jseyfried): positional field hygiene.\n+                None => Ident::new(sym::integer(index), f.span),\n+            },\n+            vis: self.lower_visibility(&f.vis, None),\n+            ty,\n+            attrs: self.lower_attrs(&f.attrs),\n+        }\n+    }\n+\n+    fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n+        let trait_item_def_id = self.resolver.definitions().local_def_id(i.id);\n+\n+        let (generics, node) = match i.node {\n+            TraitItemKind::Const(ref ty, ref default) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n+                hir::TraitItemKind::Const(\n+                    self.lower_ty(ty, ImplTraitContext::disallowed()),\n+                    default\n+                        .as_ref()\n+                        .map(|x| self.lower_const_body(x)),\n+                ),\n+            ),\n+            TraitItemKind::Method(ref sig, None) => {\n+                let names = self.lower_fn_args_to_names(&sig.decl);\n+                let (generics, sig) = self.lower_method_sig(\n+                    &i.generics,\n+                    sig,\n+                    trait_item_def_id,\n+                    false,\n+                    None,\n+                );\n+                (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n+            }\n+            TraitItemKind::Method(ref sig, Some(ref body)) => {\n+                let body_id = self.lower_fn_body_block(&sig.decl, body);\n+                let (generics, sig) = self.lower_method_sig(\n+                    &i.generics,\n+                    sig,\n+                    trait_item_def_id,\n+                    false,\n+                    None,\n+                );\n+                (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n+            }\n+            TraitItemKind::Type(ref bounds, ref default) => {\n+                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+                let node = hir::TraitItemKind::Type(\n+                    self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n+                    default\n+                        .as_ref()\n+                        .map(|x| self.lower_ty(x, ImplTraitContext::disallowed())),\n+                );\n+\n+                (generics, node)\n+            },\n+            TraitItemKind::Macro(..) => bug!(\"macro item shouldn't exist at this point\"),\n+        };\n+\n+        hir::TraitItem {\n+            hir_id: self.lower_node_id(i.id),\n+            ident: i.ident,\n+            attrs: self.lower_attrs(&i.attrs),\n+            generics,\n+            node,\n+            span: i.span,\n+        }\n+    }\n+\n+    fn lower_trait_item_ref(&mut self, i: &TraitItem) -> hir::TraitItemRef {\n+        let (kind, has_default) = match i.node {\n+            TraitItemKind::Const(_, ref default) => {\n+                (hir::AssocItemKind::Const, default.is_some())\n+            }\n+            TraitItemKind::Type(_, ref default) => {\n+                (hir::AssocItemKind::Type, default.is_some())\n+            }\n+            TraitItemKind::Method(ref sig, ref default) => (\n+                hir::AssocItemKind::Method {\n+                    has_self: sig.decl.has_self(),\n+                },\n+                default.is_some(),\n+            ),\n+            TraitItemKind::Macro(..) => unimplemented!(),\n+        };\n+        hir::TraitItemRef {\n+            id: hir::TraitItemId { hir_id: self.lower_node_id(i.id) },\n+            ident: i.ident,\n+            span: i.span,\n+            defaultness: self.lower_defaultness(Defaultness::Default, has_default),\n+            kind,\n+        }\n+    }\n+\n+    fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n+        let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n+\n+        let (generics, node) = match i.node {\n+            ImplItemKind::Const(ref ty, ref expr) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n+                hir::ImplItemKind::Const(\n+                    self.lower_ty(ty, ImplTraitContext::disallowed()),\n+                    self.lower_const_body(expr),\n+                ),\n+            ),\n+            ImplItemKind::Method(ref sig, ref body) => {\n+                self.current_item = Some(i.span);\n+                let body_id = self.lower_maybe_async_body(\n+                    &sig.decl, sig.header.asyncness.node, body\n+                );\n+                let impl_trait_return_allow = !self.is_in_trait_impl;\n+                let (generics, sig) = self.lower_method_sig(\n+                    &i.generics,\n+                    sig,\n+                    impl_item_def_id,\n+                    impl_trait_return_allow,\n+                    sig.header.asyncness.node.opt_return_id(),\n+                );\n+\n+                (generics, hir::ImplItemKind::Method(sig, body_id))\n+            }\n+            ImplItemKind::TyAlias(ref ty) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n+                hir::ImplItemKind::TyAlias(self.lower_ty(ty, ImplTraitContext::disallowed())),\n+            ),\n+            ImplItemKind::OpaqueTy(ref bounds) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n+                hir::ImplItemKind::OpaqueTy(\n+                    self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n+                ),\n+            ),\n+            ImplItemKind::Macro(..) => bug!(\"`TyMac` should have been expanded by now\"),\n+        };\n+\n+        hir::ImplItem {\n+            hir_id: self.lower_node_id(i.id),\n+            ident: i.ident,\n+            attrs: self.lower_attrs(&i.attrs),\n+            generics,\n+            vis: self.lower_visibility(&i.vis, None),\n+            defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n+            node,\n+            span: i.span,\n+        }\n+\n+        // [1] since `default impl` is not yet implemented, this is always true in impls\n+    }\n+\n+    fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n+        hir::ImplItemRef {\n+            id: hir::ImplItemId { hir_id: self.lower_node_id(i.id) },\n+            ident: i.ident,\n+            span: i.span,\n+            vis: self.lower_visibility(&i.vis, Some(i.id)),\n+            defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n+            kind: match i.node {\n+                ImplItemKind::Const(..) => hir::AssocItemKind::Const,\n+                ImplItemKind::TyAlias(..) => hir::AssocItemKind::Type,\n+                ImplItemKind::OpaqueTy(..) => hir::AssocItemKind::OpaqueTy,\n+                ImplItemKind::Method(ref sig, _) => hir::AssocItemKind::Method {\n+                    has_self: sig.decl.has_self(),\n+                },\n+                ImplItemKind::Macro(..) => unimplemented!(),\n+            },\n+        }\n+\n+        // [1] since `default impl` is not yet implemented, this is always true in impls\n+    }\n+\n+    /// If an `explicit_owner` is given, this method allocates the `HirId` in\n+    /// the address space of that item instead of the item currently being\n+    /// lowered. This can happen during `lower_impl_item_ref()` where we need to\n+    /// lower a `Visibility` value although we haven't lowered the owning\n+    /// `ImplItem` in question yet.\n+    fn lower_visibility(\n+        &mut self,\n+        v: &Visibility,\n+        explicit_owner: Option<NodeId>,\n+    ) -> hir::Visibility {\n+        let node = match v.node {\n+            VisibilityKind::Public => hir::VisibilityKind::Public,\n+            VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n+            VisibilityKind::Restricted { ref path, id } => {\n+                debug!(\"lower_visibility: restricted path id = {:?}\", id);\n+                let lowered_id = if let Some(owner) = explicit_owner {\n+                    self.lower_node_id_with_owner(id, owner)\n+                } else {\n+                    self.lower_node_id(id)\n+                };\n+                let res = self.expect_full_res(id);\n+                let res = self.lower_res(res);\n+                hir::VisibilityKind::Restricted {\n+                    path: P(self.lower_path_extra(\n+                        res,\n+                        path,\n+                        ParamMode::Explicit,\n+                        explicit_owner,\n+                    )),\n+                    hir_id: lowered_id,\n+                }\n+            },\n+            VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n+        };\n+        respan(v.span, node)\n+    }\n+\n+    fn lower_defaultness(&self, d: Defaultness, has_value: bool) -> hir::Defaultness {\n+        match d {\n+            Defaultness::Default => hir::Defaultness::Default {\n+                has_value: has_value,\n+            },\n+            Defaultness::Final => {\n+                assert!(has_value);\n+                hir::Defaultness::Final\n+            }\n+        }\n+    }\n+\n+    fn lower_impl_polarity(&mut self, i: ImplPolarity) -> hir::ImplPolarity {\n+        match i {\n+            ImplPolarity::Positive => hir::ImplPolarity::Positive,\n+            ImplPolarity::Negative => hir::ImplPolarity::Negative,\n+        }\n+    }\n+\n+    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n+        let body = hir::Body {\n+            generator_kind: self.generator_kind,\n+            arguments,\n+            value,\n+        };\n+        let id = body.id();\n+        self.bodies.insert(id, body);\n+        id\n+    }\n+\n+    fn lower_body(\n+        &mut self,\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n+    ) -> hir::BodyId {\n+        let prev_gen_kind = self.generator_kind.take();\n+        let (arguments, result) = f(self);\n+        let body_id = self.record_body(arguments, result);\n+        self.generator_kind = prev_gen_kind;\n+        body_id\n+    }\n+\n+    fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n+        hir::Arg {\n+            attrs: self.lower_attrs(&arg.attrs),\n+            hir_id: self.lower_node_id(arg.id),\n+            pat: self.lower_pat(&arg.pat),\n+            span: arg.span,\n+        }\n+    }\n+\n+    pub(super) fn lower_fn_body(\n+        &mut self,\n+        decl: &FnDecl,\n+        body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n+    ) -> hir::BodyId {\n+        self.lower_body(|this| (\n+            decl.inputs.iter().map(|x| this.lower_arg(x)).collect(),\n+            body(this),\n+        ))\n+    }\n+\n+    fn lower_fn_body_block(&mut self, decl: &FnDecl, body: &Block) -> hir::BodyId {\n+        self.lower_fn_body(decl, |this| {\n+            let body = this.lower_block(body, false);\n+            this.expr_block(body, ThinVec::new())\n+        })\n+    }\n+\n+    pub(super) fn lower_const_body(&mut self, expr: &Expr) -> hir::BodyId {\n+        self.lower_body(|this| (hir_vec![], this.lower_expr(expr)))\n+    }\n+\n+    fn lower_maybe_async_body(\n+        &mut self,\n+        decl: &FnDecl,\n+        asyncness: IsAsync,\n+        body: &Block,\n+    ) -> hir::BodyId {\n+        let closure_id = match asyncness {\n+            IsAsync::Async { closure_id, .. } => closure_id,\n+            IsAsync::NotAsync => return self.lower_fn_body_block(decl, body),\n+        };\n+\n+        self.lower_body(|this| {\n+            let mut arguments: Vec<hir::Arg> = Vec::new();\n+            let mut statements: Vec<hir::Stmt> = Vec::new();\n+\n+            // Async function arguments are lowered into the closure body so that they are\n+            // captured and so that the drop order matches the equivalent non-async functions.\n+            //\n+            // from:\n+            //\n+            //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n+            //       async move {\n+            //       }\n+            //     }\n+            //\n+            // into:\n+            //\n+            //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n+            //       async move {\n+            //         let __arg2 = __arg2;\n+            //         let <pattern> = __arg2;\n+            //         let __arg1 = __arg1;\n+            //         let <pattern> = __arg1;\n+            //         let __arg0 = __arg0;\n+            //         let <pattern> = __arg0;\n+            //       }\n+            //     }\n+            //\n+            // If `<pattern>` is a simple ident, then it is lowered to a single\n+            // `let <pattern> = <pattern>;` statement as an optimization.\n+            for (index, argument) in decl.inputs.iter().enumerate() {\n+                let argument = this.lower_arg(argument);\n+                let span = argument.pat.span;\n+\n+                // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n+                // `let <pat> = __argN;` statement. In this case, we do not rename the argument.\n+                let (ident, is_simple_argument) = match argument.pat.node {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) =>\n+                        (ident, true),\n+                    _ => {\n+                        // Replace the ident for bindings that aren't simple.\n+                        let name = format!(\"__arg{}\", index);\n+                        let ident = Ident::from_str(&name);\n+\n+                        (ident, false)\n+                    },\n+                };\n+\n+                let desugared_span =\n+                    this.mark_span_with_reason(DesugaringKind::Async, span, None);\n+\n+                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n+                // async function.\n+                //\n+                // If this is the simple case, this argument will end up being the same as the\n+                // original argument, but with a different pattern id.\n+                let mut stmt_attrs = ThinVec::new();\n+                stmt_attrs.extend(argument.attrs.iter().cloned());\n+                let (new_argument_pat, new_argument_id) = this.pat_ident(desugared_span, ident);\n+                let new_argument = hir::Arg {\n+                    attrs: argument.attrs,\n+                    hir_id: argument.hir_id,\n+                    pat: new_argument_pat,\n+                    span: argument.span,\n+                };\n+\n+\n+                if is_simple_argument {\n+                    // If this is the simple case, then we only insert one statement that is\n+                    // `let <pat> = <pat>;`. We re-use the original argument's pattern so that\n+                    // `HirId`s are densely assigned.\n+                    let expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let stmt = this.stmt_let_pat(\n+                        stmt_attrs,\n+                        desugared_span,\n+                        Some(P(expr)),\n+                        argument.pat,\n+                        hir::LocalSource::AsyncFn\n+                    );\n+                    statements.push(stmt);\n+                } else {\n+                    // If this is not the simple case, then we construct two statements:\n+                    //\n+                    // ```\n+                    // let __argN = __argN;\n+                    // let <pat> = __argN;\n+                    // ```\n+                    //\n+                    // The first statement moves the argument into the closure and thus ensures\n+                    // that the drop order is correct.\n+                    //\n+                    // The second statement creates the bindings that the user wrote.\n+\n+                    // Construct the `let mut __argN = __argN;` statement. It must be a mut binding\n+                    // because the user may have specified a `ref mut` binding in the next\n+                    // statement.\n+                    let (move_pat, move_id) = this.pat_ident_binding_mode(\n+                        desugared_span, ident, hir::BindingAnnotation::Mutable);\n+                    let move_expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let move_stmt = this.stmt_let_pat(\n+                        ThinVec::new(),\n+                        desugared_span,\n+                        Some(P(move_expr)),\n+                        move_pat,\n+                        hir::LocalSource::AsyncFn\n+                    );\n+\n+                    // Construct the `let <pat> = __argN;` statement. We re-use the original\n+                    // argument's pattern so that `HirId`s are densely assigned.\n+                    let pattern_expr = this.expr_ident(desugared_span, ident, move_id);\n+                    let pattern_stmt = this.stmt_let_pat(\n+                        stmt_attrs,\n+                        desugared_span,\n+                        Some(P(pattern_expr)),\n+                        argument.pat,\n+                        hir::LocalSource::AsyncFn\n+                    );\n+\n+                    statements.push(move_stmt);\n+                    statements.push(pattern_stmt);\n+                };\n+\n+                arguments.push(new_argument);\n+            }\n+\n+            let async_expr = this.make_async_expr(\n+                CaptureBy::Value, closure_id, None, body.span,\n+                |this| {\n+                    let body = this.lower_block_with_stmts(body, false, statements);\n+                    this.expr_block(body, ThinVec::new())\n+                });\n+            (HirVec::from(arguments), this.expr(body.span, async_expr, ThinVec::new()))\n+        })\n+    }\n+\n+    fn lower_method_sig(\n+        &mut self,\n+        generics: &Generics,\n+        sig: &MethodSig,\n+        fn_def_id: DefId,\n+        impl_trait_return_allow: bool,\n+        is_async: Option<NodeId>,\n+    ) -> (hir::Generics, hir::MethodSig) {\n+        let header = self.lower_fn_header(sig.header);\n+        let (generics, decl) = self.add_in_band_defs(\n+            generics,\n+            fn_def_id,\n+            AnonymousLifetimeMode::PassThrough,\n+            |this, idty| this.lower_fn_decl(\n+                &sig.decl,\n+                Some((fn_def_id, idty)),\n+                impl_trait_return_allow,\n+                is_async,\n+            ),\n+        );\n+        (generics, hir::MethodSig { header, decl })\n+    }\n+\n+    fn lower_is_auto(&mut self, a: IsAuto) -> hir::IsAuto {\n+        match a {\n+            IsAuto::Yes => hir::IsAuto::Yes,\n+            IsAuto::No => hir::IsAuto::No,\n+        }\n+    }\n+\n+    fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n+        hir::FnHeader {\n+            unsafety: self.lower_unsafety(h.unsafety),\n+            asyncness: self.lower_asyncness(h.asyncness.node),\n+            constness: self.lower_constness(h.constness),\n+            abi: h.abi,\n+        }\n+    }\n+\n+    pub(super) fn lower_unsafety(&mut self, u: Unsafety) -> hir::Unsafety {\n+        match u {\n+            Unsafety::Unsafe => hir::Unsafety::Unsafe,\n+            Unsafety::Normal => hir::Unsafety::Normal,\n+        }\n+    }\n+\n+    fn lower_constness(&mut self, c: Spanned<Constness>) -> hir::Constness {\n+        match c.node {\n+            Constness::Const => hir::Constness::Const,\n+            Constness::NotConst => hir::Constness::NotConst,\n+        }\n+    }\n+\n+    fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n+        match a {\n+            IsAsync::Async { .. } => hir::IsAsync::Async,\n+            IsAsync::NotAsync => hir::IsAsync::NotAsync,\n+        }\n+    }\n+\n+    pub(super) fn lower_generics(\n+        &mut self,\n+        generics: &Generics,\n+        itctx: ImplTraitContext<'_>)\n+        -> hir::Generics\n+    {\n+        // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n+        // FIXME: this could probably be done with less rightward drift. It also looks like two\n+        // control paths where `report_error` is called are the only paths that advance to after the\n+        // match statement, so the error reporting could probably just be moved there.\n+        let mut add_bounds: NodeMap<Vec<_>> = Default::default();\n+        for pred in &generics.where_clause.predicates {\n+            if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n+                'next_bound: for bound in &bound_pred.bounds {\n+                    if let GenericBound::Trait(_, TraitBoundModifier::Maybe) = *bound {\n+                        let report_error = |this: &mut Self| {\n+                            this.diagnostic().span_err(\n+                                bound_pred.bounded_ty.span,\n+                                \"`?Trait` bounds are only permitted at the \\\n+                                 point where a type parameter is declared\",\n+                            );\n+                        };\n+                        // Check if the where clause type is a plain type parameter.\n+                        match bound_pred.bounded_ty.node {\n+                            TyKind::Path(None, ref path)\n+                                if path.segments.len() == 1\n+                                    && bound_pred.bound_generic_params.is_empty() =>\n+                            {\n+                                if let Some(Res::Def(DefKind::TyParam, def_id)) = self.resolver\n+                                    .get_partial_res(bound_pred.bounded_ty.id)\n+                                    .map(|d| d.base_res())\n+                                {\n+                                    if let Some(node_id) =\n+                                        self.resolver.definitions().as_local_node_id(def_id)\n+                                    {\n+                                        for param in &generics.params {\n+                                            match param.kind {\n+                                                GenericParamKind::Type { .. } => {\n+                                                    if node_id == param.id {\n+                                                        add_bounds.entry(param.id)\n+                                                            .or_default()\n+                                                            .push(bound.clone());\n+                                                        continue 'next_bound;\n+                                                    }\n+                                                }\n+                                                _ => {}\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                report_error(self)\n+                            }\n+                            _ => report_error(self),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        hir::Generics {\n+            params: self.lower_generic_params(&generics.params, &add_bounds, itctx),\n+            where_clause: self.lower_where_clause(&generics.where_clause),\n+            span: generics.span,\n+        }\n+    }\n+\n+    fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause {\n+        self.with_anonymous_lifetime_mode(\n+            AnonymousLifetimeMode::ReportError,\n+            |this| {\n+                hir::WhereClause {\n+                    predicates: wc.predicates\n+                        .iter()\n+                        .map(|predicate| this.lower_where_predicate(predicate))\n+                        .collect(),\n+                    span: wc.span,\n+                }\n+            },\n+        )\n+    }\n+\n+    fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate {\n+        match *pred {\n+            WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                ref bound_generic_params,\n+                ref bounded_ty,\n+                ref bounds,\n+                span,\n+            }) => {\n+                self.with_in_scope_lifetime_defs(\n+                    &bound_generic_params,\n+                    |this| {\n+                        hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                            bound_generic_params: this.lower_generic_params(\n+                                bound_generic_params,\n+                                &NodeMap::default(),\n+                                ImplTraitContext::disallowed(),\n+                            ),\n+                            bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::disallowed()),\n+                            bounds: bounds\n+                                .iter()\n+                                .filter_map(|bound| match *bound {\n+                                    // Ignore `?Trait` bounds.\n+                                    // They were copied into type parameters already.\n+                                    GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n+                                    _ => Some(this.lower_param_bound(\n+                                        bound,\n+                                        ImplTraitContext::disallowed(),\n+                                    )),\n+                                })\n+                                .collect(),\n+                            span,\n+                        })\n+                    },\n+                )\n+            }\n+            WherePredicate::RegionPredicate(WhereRegionPredicate {\n+                ref lifetime,\n+                ref bounds,\n+                span,\n+            }) => hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                span,\n+                lifetime: self.lower_lifetime(lifetime),\n+                bounds: self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n+            }),\n+            WherePredicate::EqPredicate(WhereEqPredicate {\n+                id,\n+                ref lhs_ty,\n+                ref rhs_ty,\n+                span,\n+            }) => {\n+                hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n+                    hir_id: self.lower_node_id(id),\n+                    lhs_ty: self.lower_ty(lhs_ty, ImplTraitContext::disallowed()),\n+                    rhs_ty: self.lower_ty(rhs_ty, ImplTraitContext::disallowed()),\n+                    span,\n+                })\n+            },\n+        }\n+    }\n+}"}]}