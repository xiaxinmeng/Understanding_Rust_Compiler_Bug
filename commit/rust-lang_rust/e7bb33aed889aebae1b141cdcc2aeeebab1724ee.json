{"sha": "e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YmIzM2FlZDg4OWFlYmFlMWIxNDFjZGNjMmFlZWViYWIxNzI0ZWU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-08-04T03:51:29Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-08-04T04:39:48Z"}, "message": "rm obsolete `for` support from the compiler", "tree": {"sha": "528ad739b0c54febc5ee5aaa9baf42f89dca8112", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/528ad739b0c54febc5ee5aaa9baf42f89dca8112"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "html_url": "https://github.com/rust-lang/rust/commit/e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10089455287dcc3652b984ab4bfd6971e1b5f302", "url": "https://api.github.com/repos/rust-lang/rust/commits/10089455287dcc3652b984ab4bfd6971e1b5f302", "html_url": "https://github.com/rust-lang/rust/commit/10089455287dcc3652b984ab4bfd6971e1b5f302"}], "stats": {"total": 338, "additions": 15, "deletions": 323}, "files": [{"sha": "f34b28e1642fca9f0f3e7977832824d8f3cee8ec", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -396,7 +396,6 @@ impl CFGBuilder {\n             }\n \n             ast::expr_addr_of(_, e) |\n-            ast::expr_loop_body(e) |\n             ast::expr_do_body(e) |\n             ast::expr_cast(e, _) |\n             ast::expr_unary(_, _, e) |"}, {"sha": "fb12f97c50cb0156e25425ee174e8565d5470f98", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -45,14 +45,6 @@ pub fn check_crate(tcx: ty::ctxt, crate: &Crate) {\n                                          can_ret: false\n                                       }, v));\n               }\n-              expr_loop_body(@expr {node: expr_fn_block(_, ref b), _}) => {\n-                let sigil = ty::ty_closure_sigil(ty::expr_ty(tcx, e));\n-                let blk = (sigil == BorrowedSigil);\n-                (v.visit_block)(b, (Context {\n-                                         in_loop: true,\n-                                         can_ret: blk\n-                                     }, v));\n-              }\n               expr_break(_) => {\n                 if !cx.in_loop {\n                     tcx.sess.span_err(e.span, \"`break` outside of loop\");"}, {"sha": "008add975d490abf8193c37c184fa7e49fdd55a2", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 45, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -82,19 +82,8 @@ struct PropagationContext<'self, O> {\n     changed: bool\n }\n \n-#[deriving(Eq)]\n-enum LoopKind {\n-    /// A `while` or `loop` loop\n-    TrueLoop,\n-\n-    /// A `for` \"loop\" (i.e., really a func call where `break`, `return`,\n-    /// and `loop` all essentially perform an early return from the closure)\n-    ForLoop\n-}\n-\n struct LoopScope<'self> {\n     loop_id: ast::NodeId,\n-    loop_kind: LoopKind,\n     break_bits: ~[uint]\n }\n \n@@ -509,7 +498,6 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n                     loop_scopes.push(LoopScope {\n                         loop_id: expr.id,\n-                        loop_kind: ForLoop,\n                         break_bits: reslice(in_out).to_owned()\n                     });\n                     for input in decl.inputs.iter() {\n@@ -574,7 +562,6 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 let mut body_bits = reslice(in_out).to_owned();\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n-                    loop_kind: TrueLoop,\n                     break_bits: reslice(in_out).to_owned()\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n@@ -599,7 +586,6 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 self.reset(in_out);\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n-                    loop_kind: TrueLoop,\n                     break_bits: reslice(in_out).to_owned()\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n@@ -646,20 +632,6 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n             ast::expr_ret(o_e) => {\n                 self.walk_opt_expr(o_e, in_out, loop_scopes);\n-\n-                // is this a return from a `for`-loop closure?\n-                match loop_scopes.iter().position(|s| s.loop_kind == ForLoop) {\n-                    Some(i) => {\n-                        // if so, add the in_out bits to the state\n-                        // upon exit. Remember that we cannot count\n-                        // upon the `for` loop function not to invoke\n-                        // the closure again etc.\n-                        self.break_from_to(expr, &mut loop_scopes[i], in_out);\n-                    }\n-\n-                    None => {}\n-                }\n-\n                 self.reset(in_out);\n             }\n \n@@ -671,22 +643,8 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n             ast::expr_again(label) => {\n                 let scope = self.find_scope(expr, label, loop_scopes);\n-\n-                match scope.loop_kind {\n-                    TrueLoop => {\n-                        self.pop_scopes(expr, scope, in_out);\n-                        self.add_to_entry_set(scope.loop_id, reslice(in_out));\n-                    }\n-\n-                    ForLoop => {\n-                        // If this `loop` construct is looping back to a `for`\n-                        // loop, then `loop` is really just a return from the\n-                        // closure. Therefore, we treat it the same as `break`.\n-                        // See case for `expr_fn_block` for more details.\n-                        self.break_from_to(expr, scope, in_out);\n-                    }\n-                }\n-\n+                self.pop_scopes(expr, scope, in_out);\n+                self.add_to_entry_set(scope.loop_id, reslice(in_out));\n                 self.reset(in_out);\n             }\n \n@@ -756,7 +714,6 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_addr_of(_, e) |\n-            ast::expr_loop_body(e) |\n             ast::expr_do_body(e) |\n             ast::expr_cast(e, _) |\n             ast::expr_unary(_, _, e) |"}, {"sha": "0387f344796e26b4f9c58cd05edabe2571262e2d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -512,7 +512,7 @@ fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n       // otherwise, live nodes are not required:\n       expr_index(*) | expr_field(*) | expr_vstore(*) | expr_vec(*) |\n       expr_call(*) | expr_method_call(*) | expr_tup(*) | expr_log(*) |\n-      expr_binary(*) | expr_addr_of(*) | expr_loop_body(*) |\n+      expr_binary(*) | expr_addr_of(*) |\n       expr_do_body(*) | expr_cast(*) | expr_unary(*) | expr_break(_) |\n       expr_again(_) | expr_lit(_) | expr_ret(*) | expr_block(*) |\n       expr_assign(*) | expr_assign_op(*) | expr_mac(*) |\n@@ -1209,7 +1209,6 @@ impl Liveness {\n           }\n \n           expr_addr_of(_, e) |\n-          expr_loop_body(e) |\n           expr_do_body(e) |\n           expr_cast(e, _) |\n           expr_unary(_, _, e) |\n@@ -1483,7 +1482,7 @@ fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n       expr_call(*) | expr_method_call(*) | expr_if(*) | expr_match(*) |\n       expr_while(*) | expr_loop(*) | expr_index(*) | expr_field(*) |\n       expr_vstore(*) | expr_vec(*) | expr_tup(*) | expr_log(*) |\n-      expr_binary(*) | expr_loop_body(*) | expr_do_body(*) |\n+      expr_binary(*) | expr_do_body(*) |\n       expr_cast(*) | expr_unary(*) | expr_ret(*) | expr_break(*) |\n       expr_again(*) | expr_lit(_) | expr_block(*) |\n       expr_mac(*) | expr_addr_of(*) | expr_struct(*) | expr_repeat(*) |"}, {"sha": "6c5209cf504a6ad977d0931134e6a35e6a43157c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -423,7 +423,7 @@ impl mem_categorization_ctxt {\n \n           ast::expr_addr_of(*) | ast::expr_call(*) |\n           ast::expr_assign(*) | ast::expr_assign_op(*) |\n-          ast::expr_fn_block(*) | ast::expr_ret(*) | ast::expr_loop_body(*) |\n+          ast::expr_fn_block(*) | ast::expr_ret(*) |\n           ast::expr_do_body(*) | ast::expr_unary(*) |\n           ast::expr_method_call(*) | ast::expr_cast(*) | ast::expr_vstore(*) |\n           ast::expr_vec(*) | ast::expr_tup(*) | ast::expr_if(*) |"}, {"sha": "0c553843cd1b2dd713eaec618d30ea25da345679", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -541,7 +541,6 @@ impl VisitContext {\n                 self.consume_expr(count, visitor);\n             }\n \n-            expr_loop_body(base) |\n             expr_do_body(base) => {\n                 self.use_expr(base, comp_mode, visitor);\n             }"}, {"sha": "e54724b02ad40efd0225b389488ffb4b20c64e24", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -41,7 +41,6 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n                                    ty::ByCopy,\n                                    out,\n                                    &mut cleanups,\n-                                   None,\n                                    callee::DontAutorefArg)\n         }));\n \n@@ -56,7 +55,6 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n                                    ty::ByCopy,\n                                    e,\n                                    &mut cleanups,\n-                                   None,\n                                    callee::DontAutorefArg)\n         })\n \n@@ -77,7 +75,6 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n                                    ty::ByCopy,\n                                    input,\n                                    &mut cleanups,\n-                                   None,\n                                    callee::DontAutorefArg)\n         })\n "}, {"sha": "581ffa5252cec95a4cc44368a9af6f82a828deb4", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 76, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -27,7 +27,6 @@ use middle::trans::base;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee;\n-use middle::trans::closure;\n use middle::trans::common;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n@@ -556,29 +555,9 @@ pub fn trans_call_inner(in_cx: @mut Block,\n                         autoref_arg: AutorefArg)\n                         -> Result {\n     do base::with_scope_result(in_cx, call_info, \"call\") |cx| {\n-        let ret_in_loop = match args {\n-          ArgExprs(args) => {\n-            args.len() > 0u && match args.last().node {\n-              ast::expr_loop_body(@ast::expr {\n-                node: ast::expr_fn_block(_, ref body),\n-                _\n-              }) =>  body_contains_ret(body),\n-              _ => false\n-            }\n-          }\n-          _ => false\n-        };\n-\n         let callee = get_callee(cx);\n         let mut bcx = callee.bcx;\n         let ccx = cx.ccx();\n-        let ret_flag = if ret_in_loop {\n-            let flag = alloca(bcx, Type::bool(), \"__ret_flag\");\n-            Store(bcx, C_bool(false), flag);\n-            Some(flag)\n-        } else {\n-            None\n-        };\n \n         let (llfn, llenv) = unsafe {\n             match callee.data {\n@@ -611,9 +590,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n         }\n \n         llargs.push(llenv);\n-        bcx = trans_args(bcx, args, fn_expr_ty,\n-                         ret_flag, autoref_arg, &mut llargs);\n-\n+        bcx = trans_args(bcx, args, fn_expr_ty, autoref_arg, &mut llargs);\n \n         // Now that the arguments have finished evaluating, we need to revoke\n         // the cleanup for the self argument\n@@ -667,20 +644,6 @@ pub fn trans_call_inner(in_cx: @mut Block,\n \n         if ty::type_is_bot(ret_ty) {\n             Unreachable(bcx);\n-        } else if ret_in_loop {\n-            let ret_flag_result = bool_to_i1(bcx, Load(bcx, ret_flag.get()));\n-            bcx = do with_cond(bcx, ret_flag_result) |bcx| {\n-                {\n-                    let r = bcx.fcx.loop_ret;\n-                    for &(flagptr, _) in r.iter() {\n-                        Store(bcx, C_bool(true), flagptr);\n-                        Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n-                    }\n-                }\n-                base::cleanup_and_leave(bcx, None, Some(bcx.fcx.get_llreturn()));\n-                Unreachable(bcx);\n-                bcx\n-            }\n         }\n         rslt(bcx, llresult)\n     }\n@@ -713,7 +676,6 @@ pub fn trans_ret_slot(bcx: @mut Block, fn_ty: ty::t, dest: Option<expr::Dest>)\n pub fn trans_args(cx: @mut Block,\n                   args: CallArgs,\n                   fn_ty: ty::t,\n-                  ret_flag: Option<ValueRef>,\n                   autoref_arg: AutorefArg,\n                   llargs: &mut ~[ValueRef]) -> @mut Block\n {\n@@ -728,15 +690,13 @@ pub fn trans_args(cx: @mut Block,\n     // to cast her view of the arguments to the caller's view.\n     match args {\n       ArgExprs(arg_exprs) => {\n-        let last = arg_exprs.len() - 1u;\n         for (i, arg_expr) in arg_exprs.iter().enumerate() {\n             let arg_val = unpack_result!(bcx, {\n                 trans_arg_expr(bcx,\n                                arg_tys[i],\n                                ty::ByCopy,\n                                *arg_expr,\n                                &mut temp_cleanups,\n-                               if i == last { ret_flag } else { None },\n                                autoref_arg)\n             });\n             llargs.push(arg_val);\n@@ -769,49 +729,17 @@ pub fn trans_arg_expr(bcx: @mut Block,\n                       self_mode: ty::SelfMode,\n                       arg_expr: @ast::expr,\n                       temp_cleanups: &mut ~[ValueRef],\n-                      ret_flag: Option<ValueRef>,\n                       autoref_arg: AutorefArg) -> Result {\n     let _icx = push_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_expr(formal_arg_ty=(%s), self_mode=%?, arg_expr=%s, \\\n-            ret_flag=%?)\",\n+    debug!(\"trans_arg_expr(formal_arg_ty=(%s), self_mode=%?, arg_expr=%s)\",\n            formal_arg_ty.repr(bcx.tcx()),\n            self_mode,\n-           arg_expr.repr(bcx.tcx()),\n-           ret_flag.map(|v| bcx.val_to_str(*v)));\n+           arg_expr.repr(bcx.tcx()));\n \n     // translate the arg expr to a datum\n-    let arg_datumblock = match ret_flag {\n-        None => expr::trans_to_datum(bcx, arg_expr),\n-\n-        // If there is a ret_flag, this *must* be a loop body\n-        Some(_) => {\n-            match arg_expr.node {\n-                ast::expr_loop_body(\n-                    blk @ @ast::expr {\n-                        node: ast::expr_fn_block(ref decl, ref body),\n-                        _\n-                    }) => {\n-                    let scratch_ty = expr_ty(bcx, arg_expr);\n-                    let scratch = alloc_ty(bcx, scratch_ty, \"__ret_flag\");\n-                    let arg_ty = expr_ty(bcx, arg_expr);\n-                    let sigil = ty::ty_closure_sigil(arg_ty);\n-                    let bcx = closure::trans_expr_fn(\n-                        bcx, sigil, decl, body, arg_expr.id,\n-                        blk.id, Some(ret_flag), expr::SaveIn(scratch));\n-                    DatumBlock {bcx: bcx,\n-                                datum: Datum {val: scratch,\n-                                              ty: scratch_ty,\n-                                              mode: ByRef(RevokeClean)}}\n-                }\n-                _ => {\n-                    bcx.sess().impossible_case(\n-                        arg_expr.span, \"ret_flag with non-loop-body expr\");\n-                }\n-            }\n-        }\n-    };\n+    let arg_datumblock = expr::trans_to_datum(bcx, arg_expr);\n     let arg_datum = arg_datumblock.datum;\n     let bcx = arg_datumblock.bcx;\n "}, {"sha": "a44f93214881b3b7e0898e19f70488f4148a701d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -605,27 +605,6 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::expr,\n                                           expr.id, expr.id,\n                                           None, dest);\n         }\n-        ast::expr_loop_body(blk) => {\n-            let expr_ty = expr_ty(bcx, expr);\n-            let sigil = ty::ty_closure_sigil(expr_ty);\n-            match blk.node {\n-                ast::expr_fn_block(ref decl, ref body) => {\n-                    return closure::trans_expr_fn(bcx,\n-                                                  sigil,\n-                                                  decl,\n-                                                  body,\n-                                                  expr.id,\n-                                                  blk.id,\n-                                                  Some(None),\n-                                                  dest);\n-                }\n-                _ => {\n-                    bcx.sess().impossible_case(\n-                        expr.span,\n-                        \"loop_body has the wrong kind of contents\")\n-                }\n-            }\n-        }\n         ast::expr_do_body(blk) => {\n             return trans_into(bcx, blk, dest);\n         }"}, {"sha": "b67d88c07e1e6207dae5da20f96ed72150f33ff7", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -137,7 +137,6 @@ pub fn trans_self_arg(bcx: @mut Block,\n                    mentry.self_mode,\n                    base,\n                    temp_cleanups,\n-                   None,\n                    DontAutorefArg)\n }\n "}, {"sha": "42d5527ee43bc39bced200bcb0eed0737d7e792f", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -400,7 +400,7 @@ pub fn mark_for_expr(cx: &Context, e: &expr) {\n       expr_match(*) | expr_block(_) | expr_if(*) | expr_while(*) |\n       expr_break(_) | expr_again(_) | expr_unary(*) | expr_lit(_) |\n       expr_mac(_) | expr_addr_of(*) | expr_ret(_) | expr_loop(*) |\n-      expr_loop_body(_) | expr_do_body(_) => (),\n+      expr_do_body(_) => (),\n \n       expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\")\n     }"}, {"sha": "29b975cdf99f8908a49ababec5b18eaf5a68374a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -3192,7 +3192,6 @@ pub fn expr_kind(tcx: ctxt,\n         ast::expr_if(*) |\n         ast::expr_match(*) |\n         ast::expr_fn_block(*) |\n-        ast::expr_loop_body(*) |\n         ast::expr_do_body(*) |\n         ast::expr_block(*) |\n         ast::expr_repeat(*) |"}, {"sha": "7f486f77447cb8c6c6d32c3d1370611c75e2c5e7", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 142, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -170,10 +170,6 @@ pub struct inherited {\n \n #[deriving(Clone)]\n pub enum FnKind {\n-    // This is a for-closure.  The ty::t is the return type of the\n-    // enclosing function.\n-    ForLoop(ty::t),\n-\n     // A do-closure.\n     DoBlock,\n \n@@ -230,8 +226,6 @@ pub struct FnCtxt {\n     err_count_on_creation: uint,\n \n     ret_ty: ty::t,\n-    // Used by loop bodies that return from the outer function\n-    indirect_ret_ty: Option<ty::t>,\n     ps: PurityState,\n \n     // Sometimes we generate region pointers where the precise region\n@@ -283,7 +277,6 @@ pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n     @mut FnCtxt {\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n-        indirect_ret_ty: None,\n         ps: PurityState::function(ast::impure_fn, 0),\n         region_lb: region_bnd,\n         in_scope_regions: @Nil,\n@@ -390,17 +383,9 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n     let fcx: @mut FnCtxt = {\n-        // In a for-loop, you have an 'indirect return' because return\n-        // does not return out of the directly enclosing fn\n-        let indirect_ret_ty = match fn_kind {\n-            ForLoop(t) => Some(t),\n-            DoBlock | Vanilla => None\n-        };\n-\n         @mut FnCtxt {\n             err_count_on_creation: err_count_on_creation,\n             ret_ty: ret_ty,\n-            indirect_ret_ty: indirect_ret_ty,\n             ps: PurityState::function(purity, id),\n             region_lb: body.id,\n             in_scope_regions: isr,\n@@ -958,11 +943,6 @@ impl FnCtxt {\n             return;\n         }\n         match self.fn_kind {\n-            ForLoop(_) if !ty::type_is_bool(e) && !ty::type_is_nil(a) =>\n-                    self.tcx().sess.span_err(sp, fmt!(\"A for-loop body must \\\n-                        return (), but it returns %s here. \\\n-                        Perhaps you meant to write a `do`-block?\",\n-                                            ppaux::ty_to_str(self.tcx(), a))),\n             DoBlock if ty::type_is_bool(e) && ty::type_is_nil(a) =>\n                 // If we expected bool and got ()...\n                     self.tcx().sess.span_err(sp, fmt!(\"Do-block body must \\\n@@ -1274,7 +1254,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n             for (i, arg) in args.iter().enumerate() {\n                 let is_block = match arg.node {\n-                    ast::expr_fn_block(*) | ast::expr_loop_body(*) |\n+                    ast::expr_fn_block(*) |\n                     ast::expr_do_body(*) => true,\n                     _ => false\n                 };\n@@ -2126,121 +2106,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, enum_type);\n     }\n \n-    fn check_loop_body(fcx: @mut FnCtxt,\n-                       expr: @ast::expr,\n-                       expected: Option<ty::t>,\n-                       loop_body: @ast::expr) {\n-        // a loop body is the special argument to a `for` loop.  We know that\n-        // there will be an expected type in this context because it can only\n-        // appear in the context of a call, so we get the expected type of the\n-        // parameter. The catch here is that we need to validate two things:\n-        // 1. a closure that returns a bool is expected\n-        // 2. the closure that was given returns unit\n-        let tcx = fcx.tcx();\n-        let mut err_happened = false;\n-        let expected_sty = unpack_expected(fcx,\n-                                           expected,\n-                                           |x| Some((*x).clone()));\n-        let inner_ty = match expected_sty {\n-            Some(ty::ty_closure(ref fty)) => {\n-                match fcx.mk_subty(false, infer::Misc(expr.span),\n-                                   fty.sig.output, ty::mk_bool()) {\n-                    result::Ok(_) => {\n-                        ty::mk_closure(tcx, ty::ClosureTy {\n-                            sig: FnSig {\n-                                output: ty::mk_nil(),\n-                                ..fty.sig.clone()\n-                            },\n-                            ..(*fty).clone()\n-                        })\n-                    }\n-                    result::Err(_) => {\n-                        fcx.type_error_message(\n-                            expr.span,\n-                            |actual| {\n-                                let did_you_mean = {\n-                                    if ty::type_is_nil(fty.sig.output) {\n-                                        \"\\nDid you mean to use \\\n-                                             `do` instead of `for`?\"\n-                                     } else {\n-                                         \"\"\n-                                     }\n-                                };\n-                                fmt!(\"A `for` loop iterator should expect a \\\n-                                      closure that returns `bool`. This \\\n-                                      iterator expects a closure that \\\n-                                      returns `%s`.%s\",\n-                                     actual, did_you_mean)\n-                            },\n-                            fty.sig.output,\n-                            None);\n-                        err_happened = true;\n-                        fcx.write_error(expr.id);\n-                        ty::mk_err()\n-                    }\n-                }\n-            }\n-            _ => {\n-                match expected {\n-                    Some(expected_t) => {\n-                        fcx.type_error_message(\n-                            expr.span,\n-                            |actual| {\n-                                fmt!(\"last argument in `for` call \\\n-                                      has non-closure type: %s\",\n-                                     actual)\n-                            },\n-                            expected_t, None);\n-                        let err_ty = ty::mk_err();\n-                        fcx.write_error(expr.id);\n-                        err_happened = true;\n-                        err_ty\n-                    }\n-                    None => fcx.tcx().sess.impossible_case(\n-                        expr.span,\n-                        \"loop body must have an expected type\")\n-                }\n-            }\n-        };\n-\n-        match loop_body.node {\n-            ast::expr_fn_block(ref decl, ref body) => {\n-                // If an error occurred, we pretend this isn't a for\n-                // loop, so as to assign types to all nodes while also\n-                // propagating ty_err throughout so as to suppress\n-                // derived errors. If we passed in ForLoop in the\n-                // error case, we'd potentially emit a spurious error\n-                // message because of the indirect_ret_ty.\n-                let fn_kind = if err_happened {\n-                    Vanilla\n-                } else {\n-                    let indirect_ret_ty =\n-                        fcx.indirect_ret_ty.get_or_default(fcx.ret_ty);\n-                    ForLoop(indirect_ret_ty)\n-                };\n-                check_expr_fn(fcx, loop_body, None,\n-                              decl, body, fn_kind, Some(inner_ty));\n-                demand::suptype(fcx, loop_body.span,\n-                                inner_ty, fcx.expr_ty(loop_body));\n-            }\n-            ref n => {\n-                fail!(\"check_loop_body expected expr_fn_block, not %?\", n)\n-            }\n-        }\n-\n-        let block_ty = structurally_resolved_type(\n-            fcx, expr.span, fcx.node_ty(loop_body.id));\n-        if err_happened {\n-            fcx.write_error(expr.id);\n-            fcx.write_error(loop_body.id);\n-        } else {\n-            let loop_body_ty =\n-                ty::replace_closure_return_type(\n-                    tcx, block_ty, ty::mk_bool());\n-            fcx.write_ty(expr.id, loop_body_ty);\n-        }\n-    }\n-\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     match expr.node {\n@@ -2494,9 +2359,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       ast::expr_break(_) => { fcx.write_bot(id); }\n       ast::expr_again(_) => { fcx.write_bot(id); }\n       ast::expr_ret(expr_opt) => {\n-        let ret_ty = match fcx.indirect_ret_ty {\n-          Some(t) =>  t, None => fcx.ret_ty\n-        };\n+        let ret_ty = fcx.ret_ty;\n         match expr_opt {\n           None => match fcx.mk_eqty(false, infer::Misc(expr.span),\n                                     ret_ty, ty::mk_nil()) {\n@@ -2581,9 +2444,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         check_expr_fn(fcx, expr, None,\n                       decl, body, Vanilla, expected);\n       }\n-      ast::expr_loop_body(loop_body) => {\n-          check_loop_body(fcx, expr, expected, loop_body);\n-      }\n       ast::expr_do_body(b) => {\n         let expected_sty = unpack_expected(fcx,\n                                            expected,"}, {"sha": "18e7295d61a0528f1cf86fe6f4b543a5a19a55ae", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -426,10 +426,6 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n             oldvisit::visit_expr(expr, (rcx, v));\n         }\n \n-        ast::expr_loop_body(subexpr) => {\n-            check_expr_fn_block(rcx, subexpr, v, true);\n-        }\n-\n         ast::expr_fn_block(*) => {\n             check_expr_fn_block(rcx, expr, v, false);\n         }\n@@ -1031,7 +1027,6 @@ pub mod guarantor {\n             ast::expr_if(*) |\n             ast::expr_match(*) |\n             ast::expr_fn_block(*) |\n-            ast::expr_loop_body(*) |\n             ast::expr_do_body(*) |\n             ast::expr_block(*) |\n             ast::expr_repeat(*) |"}, {"sha": "26c22eed08c812ae87407d2df0124738a7bd902a", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -70,8 +70,7 @@ pub fn loop_query(b: &ast::Block, p: @fn(&ast::expr_) -> bool) -> bool {\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n-          ast::expr_loop(*) | ast::expr_while(*)\n-          | ast::expr_loop_body(*) => {}\n+          ast::expr_loop(*) | ast::expr_while(*) => {}\n           _ => oldvisit::visit_expr(e, (flag, v))\n         }\n     };"}, {"sha": "cf7a1e51798ac56ee3499dab5dfded7b797894e9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -472,11 +472,6 @@ pub enum expr_ {\n     expr_loop(Block, Option<ident>),\n     expr_match(@expr, ~[arm]),\n     expr_fn_block(fn_decl, Block),\n-    // Inner expr is always an expr_fn_block. We need the wrapping node to\n-    // easily type this (a function returning nil on the inside but bool on\n-    // the outside).\n-    expr_loop_body(@expr),\n-    // Like expr_loop_body but for 'do' blocks\n     expr_do_body(@expr),\n     expr_block(Block),\n "}, {"sha": "7ffed13940e8a6f144c3a9a92c7ce9efe0f6c28a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -541,7 +541,6 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n                 fld.fold_expr(ohs)\n             )\n         }\n-        expr_loop_body(f) => expr_loop_body(fld.fold_expr(f)),\n         expr_do_body(f) => expr_do_body(fld.fold_expr(f)),\n         expr_lit(_) => (*e).clone(),\n         expr_cast(expr, ref ty) => {"}, {"sha": "295003c6ef5383e2827f8baa615a16e4b990bb66", "filename": "src/libsyntax/oldvisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibsyntax%2Foldvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibsyntax%2Foldvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Foldvisit.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -501,7 +501,7 @@ pub fn visit_expr<E:Clone>(ex: @expr, (e, v): (E, vt<E>)) {\n             (v.visit_expr)(b, (e.clone(), v));\n         }\n         expr_addr_of(_, x) | expr_unary(_, _, x) |\n-        expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, (e.clone(), v)),\n+        expr_do_body(x) => (v.visit_expr)(x, (e.clone(), v)),\n         expr_lit(_) => (),\n         expr_cast(x, ref t) => {\n             (v.visit_expr)(x, (e.clone(), v));"}, {"sha": "174b0f8e4517cba240162b4cfadec27f40876390", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -1087,7 +1087,7 @@ pub fn print_call_post(s: @ps,\n         nbsp(s);\n         match blk.get().node {\n           // need to handle closures specifically\n-          ast::expr_do_body(e) | ast::expr_loop_body(e) => {\n+          ast::expr_do_body(e) => {\n             end(s); // we close our head box; closure\n                     // will create it's own.\n             print_expr(s, e);\n@@ -1338,9 +1338,6 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         // empty box to satisfy the close.\n         ibox(s, 0);\n       }\n-      ast::expr_loop_body(body) => {\n-        print_expr(s, body);\n-      }\n       ast::expr_do_body(body) => {\n         print_expr(s, body);\n       }"}, {"sha": "7aa52bc13e341af01b30b4d3703c8ef3f460238e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7bb33aed889aebae1b141cdcc2aeeebab1724ee/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e7bb33aed889aebae1b141cdcc2aeeebab1724ee", "patch": "@@ -513,7 +513,6 @@ pub fn visit_expr<E:Clone>(visitor: @Visitor<E>, expression: @expr, env: E) {\n         }\n         expr_addr_of(_, subexpression) |\n         expr_unary(_, _, subexpression) |\n-        expr_loop_body(subexpression) |\n         expr_do_body(subexpression) => {\n             visitor.visit_expr(subexpression, env.clone())\n         }"}]}