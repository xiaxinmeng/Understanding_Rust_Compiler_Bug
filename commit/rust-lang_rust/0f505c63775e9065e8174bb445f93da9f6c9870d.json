{"sha": "0f505c63775e9065e8174bb445f93da9f6c9870d", "node_id": "C_kwDOAAsO6NoAKDBmNTA1YzYzNzc1ZTkwNjVlODE3NGJiNDQ1ZjkzZGE5ZjZjOTg3MGQ", "commit": {"author": {"name": "Josh Triplett", "email": "josh@joshtriplett.org", "date": "2022-03-02T00:06:06Z"}, "committer": {"name": "Josh Triplett", "email": "josh@joshtriplett.org", "date": "2022-03-02T00:24:10Z"}, "message": "Add a copy of cfg_if to core's internal_macros.rs\n\ncore can't depend on external crates the way std can. Rather than revert\nusage of cfg_if, add a copy of it to core. This does not export our\ncopy, even unstably; such a change could occur in a later commit.", "tree": {"sha": "f6c7e0ccbf257e0989d06794a1f09b974606816b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6c7e0ccbf257e0989d06794a1f09b974606816b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f505c63775e9065e8174bb445f93da9f6c9870d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f505c63775e9065e8174bb445f93da9f6c9870d", "html_url": "https://github.com/rust-lang/rust/commit/0f505c63775e9065e8174bb445f93da9f6c9870d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f505c63775e9065e8174bb445f93da9f6c9870d/comments", "author": {"login": "joshtriplett", "id": 162737, "node_id": "MDQ6VXNlcjE2MjczNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshtriplett", "html_url": "https://github.com/joshtriplett", "followers_url": "https://api.github.com/users/joshtriplett/followers", "following_url": "https://api.github.com/users/joshtriplett/following{/other_user}", "gists_url": "https://api.github.com/users/joshtriplett/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshtriplett/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshtriplett/subscriptions", "organizations_url": "https://api.github.com/users/joshtriplett/orgs", "repos_url": "https://api.github.com/users/joshtriplett/repos", "events_url": "https://api.github.com/users/joshtriplett/events{/privacy}", "received_events_url": "https://api.github.com/users/joshtriplett/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joshtriplett", "id": 162737, "node_id": "MDQ6VXNlcjE2MjczNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshtriplett", "html_url": "https://github.com/joshtriplett", "followers_url": "https://api.github.com/users/joshtriplett/followers", "following_url": "https://api.github.com/users/joshtriplett/following{/other_user}", "gists_url": "https://api.github.com/users/joshtriplett/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshtriplett/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshtriplett/subscriptions", "organizations_url": "https://api.github.com/users/joshtriplett/orgs", "repos_url": "https://api.github.com/users/joshtriplett/repos", "events_url": "https://api.github.com/users/joshtriplett/events{/privacy}", "received_events_url": "https://api.github.com/users/joshtriplett/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0c4da49983aa699f715caf681e3154b445fb60b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0c4da49983aa699f715caf681e3154b445fb60b", "html_url": "https://github.com/rust-lang/rust/commit/f0c4da49983aa699f715caf681e3154b445fb60b"}], "stats": {"total": 93, "additions": 93, "deletions": 0}, "files": [{"sha": "417ed51c6b6a23063b3a84355397aea07d1cca20", "filename": "library/core/src/internal_macros.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/0f505c63775e9065e8174bb445f93da9f6c9870d/library%2Fcore%2Fsrc%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f505c63775e9065e8174bb445f93da9f6c9870d/library%2Fcore%2Fsrc%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Finternal_macros.rs?ref=0f505c63775e9065e8174bb445f93da9f6c9870d", "patch": "@@ -187,3 +187,96 @@ macro_rules! impl_fn_for_zst {\n         )+\n     }\n }\n+\n+/// A macro for defining `#[cfg]` if-else statements.\n+///\n+/// `cfg_if` is similar to the `if/elif` C preprocessor macro by allowing definition of a cascade\n+/// of `#[cfg]` cases, emitting the implementation which matches first.\n+///\n+/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code without having to\n+/// rewrite each clause multiple times.\n+///\n+/// # Example\n+///\n+/// ```\n+/// cfg_if! {\n+///     if #[cfg(unix)] {\n+///         fn foo() { /* unix specific functionality */ }\n+///     } else if #[cfg(target_pointer_width = \"32\")] {\n+///         fn foo() { /* non-unix, 32-bit functionality */ }\n+///     } else {\n+///         fn foo() { /* fallback implementation */ }\n+///     }\n+/// }\n+///\n+/// # fn main() {}\n+/// ```\n+// This is a copy of `cfg_if!` from the `cfg_if` crate.\n+// The recursive invocations should use $crate if this is ever exported.\n+macro_rules! cfg_if {\n+    // match if/else chains with a final `else`\n+    (\n+        $(\n+            if #[cfg( $i_meta:meta )] { $( $i_tokens:tt )* }\n+        ) else+\n+        else { $( $e_tokens:tt )* }\n+    ) => {\n+        cfg_if! {\n+            @__items () ;\n+            $(\n+                (( $i_meta ) ( $( $i_tokens )* )) ,\n+            )+\n+            (() ( $( $e_tokens )* )) ,\n+        }\n+    };\n+\n+    // match if/else chains lacking a final `else`\n+    (\n+        if #[cfg( $i_meta:meta )] { $( $i_tokens:tt )* }\n+        $(\n+            else if #[cfg( $e_meta:meta )] { $( $e_tokens:tt )* }\n+        )*\n+    ) => {\n+        cfg_if! {\n+            @__items () ;\n+            (( $i_meta ) ( $( $i_tokens )* )) ,\n+            $(\n+                (( $e_meta ) ( $( $e_tokens )* )) ,\n+            )*\n+        }\n+    };\n+\n+    // Internal and recursive macro to emit all the items\n+    //\n+    // Collects all the previous cfgs in a list at the beginning, so they can be\n+    // negated. After the semicolon is all the remaining items.\n+    (@__items ( $( $_:meta , )* ) ; ) => {};\n+    (\n+        @__items ( $( $no:meta , )* ) ;\n+        (( $( $yes:meta )? ) ( $( $tokens:tt )* )) ,\n+        $( $rest:tt , )*\n+    ) => {\n+        // Emit all items within one block, applying an appropriate #[cfg]. The\n+        // #[cfg] will require all `$yes` matchers specified and must also negate\n+        // all previous matchers.\n+        #[cfg(all(\n+            $( $yes , )?\n+            not(any( $( $no ),* ))\n+        ))]\n+        cfg_if! { @__identity $( $tokens )* }\n+\n+        // Recurse to emit all other items in `$rest`, and when we do so add all\n+        // our `$yes` matchers to the list of `$no` matchers as future emissions\n+        // will have to negate everything we just matched as well.\n+        cfg_if! {\n+            @__items ( $( $no , )* $( $yes , )? ) ;\n+            $( $rest , )*\n+        }\n+    };\n+\n+    // Internal macro to make __apply work out right for different match types,\n+    // because of how macros match/expand stuff.\n+    (@__identity $( $tokens:tt )* ) => {\n+        $( $tokens )*\n+    };\n+}"}]}