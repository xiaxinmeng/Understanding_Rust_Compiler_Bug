{"sha": "8c8fc361d8998acf87a916db34707cdca9630338", "node_id": "C_kwDOAAsO6NoAKDhjOGZjMzYxZDg5OThhY2Y4N2E5MTZkYjM0NzA3Y2RjYTk2MzAzMzg", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-03-23T07:33:19Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-03-23T07:33:19Z"}, "message": "Merge from rustc", "tree": {"sha": "f49b087ac23840522501487e4f9f0832281a2f87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f49b087ac23840522501487e4f9f0832281a2f87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c8fc361d8998acf87a916db34707cdca9630338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c8fc361d8998acf87a916db34707cdca9630338", "html_url": "https://github.com/rust-lang/rust/commit/8c8fc361d8998acf87a916db34707cdca9630338", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c8fc361d8998acf87a916db34707cdca9630338/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b00302e2884fe28c710b6d7513b477455ad14e82", "url": "https://api.github.com/repos/rust-lang/rust/commits/b00302e2884fe28c710b6d7513b477455ad14e82", "html_url": "https://github.com/rust-lang/rust/commit/b00302e2884fe28c710b6d7513b477455ad14e82"}, {"sha": "415a3ca909084e83441306b21db5232ee8952fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/415a3ca909084e83441306b21db5232ee8952fc4", "html_url": "https://github.com/rust-lang/rust/commit/415a3ca909084e83441306b21db5232ee8952fc4"}], "stats": {"total": 4131, "additions": 2429, "deletions": 1702}, "files": [{"sha": "3495f4d51afdb90c40b9a336896d6b05a16ff38d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -5294,6 +5294,7 @@ name = \"rustc_span\"\n version = \"0.0.0\"\n dependencies = [\n  \"cfg-if\",\n+ \"indexmap\",\n  \"md-5\",\n  \"rustc_arena\",\n  \"rustc_data_structures\","}, {"sha": "c4771115cacf2b868a584e42a31873ea346dc432", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -180,6 +180,12 @@ impl Attribute {\n         self.doc_str().map_or(false, |s| comments::may_have_doc_links(s.as_str()))\n     }\n \n+    pub fn is_proc_macro_attr(&self) -> bool {\n+        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n+            .iter()\n+            .any(|kind| self.has_name(*kind))\n+    }\n+\n     /// Extracts the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> Option<MetaItem> {\n         match &self.kind {\n@@ -627,6 +633,22 @@ pub fn mk_attr_name_value_str(\n     mk_attr(g, style, path, args, span)\n }\n \n+pub fn filter_by_name(attrs: &[Attribute], name: Symbol) -> impl Iterator<Item = &Attribute> {\n+    attrs.iter().filter(move |attr| attr.has_name(name))\n+}\n+\n+pub fn find_by_name(attrs: &[Attribute], name: Symbol) -> Option<&Attribute> {\n+    filter_by_name(attrs, name).next()\n+}\n+\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: Symbol) -> Option<Symbol> {\n+    find_by_name(attrs, name).and_then(|attr| attr.value_str())\n+}\n+\n+pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {\n+    find_by_name(attrs, name).is_some()\n+}\n+\n pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n     items.iter().any(|item| item.has_name(name))\n }"}, {"sha": "0b6b02ba00fb59f6e5f3c7fc2839e4eed983d3be", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -2185,7 +2185,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             def_id: self.local_def_id(param.id),\n             name,\n             span: self.lower_span(param.span()),\n-            pure_wrt_drop: self.tcx.sess.contains_name(&param.attrs, sym::may_dangle),\n+            pure_wrt_drop: attr::contains_name(&param.attrs, sym::may_dangle),\n             kind,\n             colon_span: param.colon_span.map(|s| self.lower_span(s)),\n             source,"}, {"sha": "93c854cc8094286560acfbfc133c4171e7220188", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -799,11 +799,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_item(&mut self, item: &'a Item) {\n-        if item.attrs.iter().any(|attr| self.session.is_proc_macro_attr(attr)) {\n+        if item.attrs.iter().any(|attr| attr.is_proc_macro_attr()) {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if self.session.contains_name(&item.attrs, sym::no_mangle) {\n+        if attr::contains_name(&item.attrs, sym::no_mangle) {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n \n@@ -973,7 +973,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n                 if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _))\n-                    && !self.session.contains_name(&item.attrs, sym::path)\n+                    && !attr::contains_name(&item.attrs, sym::path)\n                 {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n@@ -1248,7 +1248,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n-        if self.session.contains_name(&item.attrs, sym::no_mangle) {\n+        if attr::contains_name(&item.attrs, sym::no_mangle) {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n "}, {"sha": "344a1e7f5e795d2bd8078421f4f62f103780ac32", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n-use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n+use rustc_ast::{attr, AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd};\n use rustc_errors::{Applicability, StashKey};\n use rustc_feature::{AttributeGate, BuiltinAttribute, Features, GateIssue, BUILTIN_ATTRIBUTE_MAP};\n@@ -232,7 +232,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Fn(..) => {\n-                if self.sess.contains_name(&i.attrs, sym::start) {\n+                if attr::contains_name(&i.attrs, sym::start) {\n                     gate_feature_post!(\n                         &self,\n                         start,\n@@ -245,7 +245,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Struct(..) => {\n-                for attr in self.sess.filter_by_name(&i.attrs, sym::repr) {\n+                for attr in attr::filter_by_name(&i.attrs, sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n                         if item.has_name(sym::simd) {\n                             gate_feature_post!(\n@@ -306,7 +306,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n         match i.kind {\n             ast::ForeignItemKind::Fn(..) | ast::ForeignItemKind::Static(..) => {\n-                let link_name = self.sess.first_attr_value_str_by_name(&i.attrs, sym::link_name);\n+                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n                 let links_to_llvm =\n                     link_name.map_or(false, |val| val.as_str().starts_with(\"llvm.\"));\n                 if links_to_llvm {"}, {"sha": "d6dbdd3975e93e3fba93551b4529d2ff7de307c8", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,6 +1,6 @@\n //! Parsing and validation of builtin attributes\n \n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_ast::{Attribute, LitKind, MetaItem, MetaItemKind, MetaItemLit, NestedMetaItem, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n@@ -556,8 +556,8 @@ where\n     (stab, const_stab, body_stab)\n }\n \n-pub fn find_crate_name(sess: &Session, attrs: &[Attribute]) -> Option<Symbol> {\n-    sess.first_attr_value_str_by_name(attrs, sym::crate_name)\n+pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n+    attr::first_attr_value_str_by_name(attrs, sym::crate_name)\n }\n \n #[derive(Clone, Debug)]\n@@ -1177,7 +1177,7 @@ fn allow_unstable<'a>(\n     attrs: &'a [Attribute],\n     symbol: Symbol,\n ) -> impl Iterator<Item = Symbol> + 'a {\n-    let attrs = sess.filter_by_name(attrs, symbol);\n+    let attrs = attr::filter_by_name(attrs, symbol);\n     let list = attrs\n         .filter_map(move |attr| {\n             attr.meta_item_list().or_else(|| {"}, {"sha": "a8c216407f931c01169d2b4204d386afd42c3d92", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -120,9 +120,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     && !self.upvars.is_empty()\n                 {\n                     item_msg = access_place_desc;\n-                    debug_assert!(\n-                        self.body.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty.is_region_ptr()\n-                    );\n+                    debug_assert!(self.body.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty.is_ref());\n                     debug_assert!(is_closure_or_generator(\n                         Place::ty_from(\n                             the_place_err.local,\n@@ -470,11 +468,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             {\n                 let local_decl = &self.body.local_decls[local];\n \n-                let (pointer_sigil, pointer_desc) = if local_decl.ty.is_region_ptr() {\n-                    (\"&\", \"reference\")\n-                } else {\n-                    (\"*const\", \"pointer\")\n-                };\n+                let (pointer_sigil, pointer_desc) =\n+                    if local_decl.ty.is_ref() { (\"&\", \"reference\") } else { (\"*const\", \"pointer\") };\n \n                 match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n@@ -1258,7 +1253,7 @@ fn suggest_ampmut<'tcx>(\n     (\n         suggestability,\n         highlight_span,\n-        if local_decl.ty.is_region_ptr() {\n+        if local_decl.ty.is_ref() {\n             format!(\"&mut {}\", ty_mut.ty)\n         } else {\n             format!(\"*mut {}\", ty_mut.ty)"}, {"sha": "b7ce3afce7bb2712b3689db1152e07aa8b0aff00", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -19,7 +19,6 @@ extern crate tracing;\n \n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::graph::dominators::Dominators;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n@@ -141,7 +140,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Bor\n         debug!(\"Skipping borrowck because of injected body\");\n         // Let's make up a borrowck result! Fun times!\n         let result = BorrowCheckResult {\n-            concrete_opaque_types: VecMap::new(),\n+            concrete_opaque_types: FxIndexMap::default(),\n             closure_requirements: None,\n             used_mut_upvars: SmallVec::new(),\n             tainted_by_errors: None,\n@@ -511,16 +510,11 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n             .as_var()\n             .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n \n-        if cfg!(debug_assertions) {\n+        if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n             let ctxt = get_ctxt_fn();\n             let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n-            let prev = var_to_origin.insert(vid, ctxt);\n-\n-            // This only makes sense if not called in a canonicalization context. If this\n-            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n-            // or modify how we track nll region vars for that map.\n-            assert!(matches!(prev, None));\n+            var_to_origin.insert(vid, ctxt);\n         }\n \n         next_region\n@@ -540,16 +534,11 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n             .as_var()\n             .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n \n-        if cfg!(debug_assertions) {\n+        if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n             let ctxt = get_ctxt_fn();\n             let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n-            let prev = var_to_origin.insert(vid, ctxt);\n-\n-            // This only makes sense if not called in a canonicalization context. If this\n-            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n-            // or modify how we track nll region vars for that map.\n-            assert!(matches!(prev, None));\n+            var_to_origin.insert(vid, ctxt);\n         }\n \n         next_region"}, {"sha": "f0068fc9226be0282d84eeeb25c020145ba7e33a", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -2,7 +2,7 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n //! The entry point of the NLL borrow checker.\n \n-use rustc_data_structures::vec_map::VecMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::{create_dump_file, dump_enabled, dump_mir, PassWhere};\n@@ -44,7 +44,7 @@ pub type PoloniusOutput = Output<RustcFacts>;\n /// closure requirements to propagate, and any generated errors.\n pub(crate) struct NllOutput<'tcx> {\n     pub regioncx: RegionInferenceContext<'tcx>,\n-    pub opaque_type_values: VecMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n+    pub opaque_type_values: FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n     pub polonius_input: Option<Box<AllFacts>>,\n     pub polonius_output: Option<Rc<PoloniusOutput>>,\n     pub opt_closure_req: Option<ClosureRegionRequirements<'tcx>>,\n@@ -377,7 +377,7 @@ pub(super) fn dump_annotation<'tcx>(\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'tcx>>,\n-    opaque_type_values: &VecMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n+    opaque_type_values: &FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n     errors: &mut crate::error::BorrowckErrors<'tcx>,\n ) {\n     let tcx = infcx.tcx;"}, {"sha": "03f175daca9e8d26e4237d778df738453a0e0348", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -256,11 +256,12 @@ fn sccs_info<'cx, 'tcx>(\n \n     let mut var_to_origin_sorted = var_to_origin.clone().into_iter().collect::<Vec<_>>();\n     var_to_origin_sorted.sort_by_key(|vto| vto.0);\n-    let mut debug_str = \"region variables to origins:\\n\".to_string();\n+\n+    let mut reg_vars_to_origins_str = \"region variables to origins:\\n\".to_string();\n     for (reg_var, origin) in var_to_origin_sorted.into_iter() {\n-        debug_str.push_str(&format!(\"{:?}: {:?}\\n\", reg_var, origin));\n+        reg_vars_to_origins_str.push_str(&format!(\"{:?}: {:?}\\n\", reg_var, origin));\n     }\n-    debug!(debug_str);\n+    debug!(\"{}\", reg_vars_to_origins_str);\n \n     let num_components = sccs.scc_data().ranges().len();\n     let mut components = vec![FxIndexSet::default(); num_components];\n@@ -275,12 +276,12 @@ fn sccs_info<'cx, 'tcx>(\n     for (scc_idx, reg_vars_origins) in components.iter().enumerate() {\n         let regions_info = reg_vars_origins.clone().into_iter().collect::<Vec<_>>();\n         components_str.push_str(&format!(\n-            \"{:?}: {:?})\",\n+            \"{:?}: {:?},\\n)\",\n             ConstraintSccIndex::from_usize(scc_idx),\n             regions_info,\n         ))\n     }\n-    debug!(components_str);\n+    debug!(\"{}\", components_str);\n \n     // calculate the best representative for each component\n     let components_representatives = components"}, {"sha": "2b16655cf7d5a91a0ff85d14142654bc43e827af", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,5 +1,4 @@\n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n@@ -61,9 +60,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'tcx>,\n-        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n-    ) -> VecMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n-        let mut result: VecMap<LocalDefId, OpaqueHiddenType<'tcx>> = VecMap::new();\n+        opaque_ty_decls: FxIndexMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n+    ) -> FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n+        let mut result: FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>> = FxIndexMap::default();\n \n         let member_constraints: FxIndexMap<_, _> = self\n             .member_constraints"}, {"sha": "f67dae9beb92537b89420683ff72c8272bb84070", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -10,7 +10,6 @@ use either::Either;\n use hir::OpaqueTyOrigin;\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n@@ -894,7 +893,7 @@ pub(crate) struct MirTypeckResults<'tcx> {\n     pub(crate) constraints: MirTypeckRegionConstraints<'tcx>,\n     pub(crate) universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n     pub(crate) opaque_type_values:\n-        VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n+        FxIndexMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n }\n \n /// A collection of region constraints that must be satisfied for the"}, {"sha": "305e2c8fe8ebbcc539e7d24a00cc7ab414bda503", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -132,9 +132,12 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n \n         let reg_var =\n             reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n-        let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-        let prev = var_to_origin.insert(reg_var, RegionCtxt::Placeholder(reg_info));\n-        assert!(matches!(prev, None));\n+\n+        if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n+            let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n+            debug!(?reg_var);\n+            var_to_origin.insert(reg_var, RegionCtxt::Placeholder(reg_info));\n+        }\n \n         reg\n     }\n@@ -149,14 +152,9 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         let reg_var =\n             reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n \n-        if cfg!(debug_assertions) {\n+        if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            let prev = var_to_origin.insert(reg_var, RegionCtxt::Existential(None));\n-\n-            // It only makes sense to track region vars in non-canonicalization contexts. If this\n-            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n-            // or modify how we track nll region vars for that map.\n-            assert!(matches!(prev, None));\n+            var_to_origin.insert(reg_var, RegionCtxt::Existential(None));\n         }\n \n         reg"}, {"sha": "cc32739d083c729f09dc6fe1b1b678a8093f02af", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,7 +1,7 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use rustc_ast as ast;\n-use rustc_ast::{walk_list, EnumDef, VariantData};\n+use rustc_ast::{attr, walk_list, EnumDef, VariantData};\n use rustc_errors::Applicability;\n use rustc_expand::base::{Annotatable, DummyResult, ExtCtxt};\n use rustc_span::symbol::Ident;\n@@ -106,7 +106,7 @@ fn extract_default_variant<'a>(\n     let default_variants: SmallVec<[_; 1]> = enum_def\n         .variants\n         .iter()\n-        .filter(|variant| cx.sess.contains_name(&variant.attrs, kw::Default))\n+        .filter(|variant| attr::contains_name(&variant.attrs, kw::Default))\n         .collect();\n \n     let variant = match default_variants.as_slice() {\n@@ -116,7 +116,7 @@ fn extract_default_variant<'a>(\n                 .variants\n                 .iter()\n                 .filter(|variant| matches!(variant.data, VariantData::Unit(..)))\n-                .filter(|variant| !cx.sess.contains_name(&variant.attrs, sym::non_exhaustive));\n+                .filter(|variant| !attr::contains_name(&variant.attrs, sym::non_exhaustive));\n \n             let mut diag = cx.struct_span_err(trait_span, \"no default declared\");\n             diag.help(\"make a unit variant default by placing `#[default]` above it\");\n@@ -146,7 +146,7 @@ fn extract_default_variant<'a>(\n                         if v.span == variant.span {\n                             None\n                         } else {\n-                            Some((cx.sess.find_by_name(&v.attrs, kw::Default)?.span, String::new()))\n+                            Some((attr::find_by_name(&v.attrs, kw::Default)?.span, String::new()))\n                         }\n                     })\n                     .collect();\n@@ -174,7 +174,7 @@ fn extract_default_variant<'a>(\n         return Err(());\n     }\n \n-    if let Some(non_exhaustive_attr) = cx.sess.find_by_name(&variant.attrs, sym::non_exhaustive) {\n+    if let Some(non_exhaustive_attr) = attr::find_by_name(&variant.attrs, sym::non_exhaustive) {\n         cx.struct_span_err(variant.ident.span, \"default variant must be exhaustive\")\n             .span_label(non_exhaustive_attr.span, \"declared `#[non_exhaustive]` here\")\n             .help(\"consider a manual implementation of `Default`\")\n@@ -191,7 +191,7 @@ fn validate_default_attribute(\n     default_variant: &rustc_ast::Variant,\n ) -> Result<(), ()> {\n     let attrs: SmallVec<[_; 1]> =\n-        cx.sess.filter_by_name(&default_variant.attrs, kw::Default).collect();\n+        attr::filter_by_name(&default_variant.attrs, kw::Default).collect();\n \n     let attr = match attrs.as_slice() {\n         [attr] => attr,"}, {"sha": "a73fed6ccb222e466c66bccda77848729b222759", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{self as ast, NodeId};\n+use rustc_ast::{self as ast, attr, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{parse_macro_name_and_helper_attrs, ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n@@ -34,7 +34,6 @@ enum ProcMacro {\n }\n \n struct CollectProcMacros<'a> {\n-    sess: &'a Session,\n     macros: Vec<ProcMacro>,\n     in_root: bool,\n     handler: &'a rustc_errors::Handler,\n@@ -56,7 +55,6 @@ pub fn inject(\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver, None);\n \n     let mut collect = CollectProcMacros {\n-        sess,\n         macros: Vec::new(),\n         in_root: true,\n         handler,\n@@ -160,7 +158,7 @@ impl<'a> CollectProcMacros<'a> {\n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         if let ast::ItemKind::MacroDef(..) = item.kind {\n-            if self.is_proc_macro_crate && self.sess.contains_name(&item.attrs, sym::macro_export) {\n+            if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n                 self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n@@ -176,7 +174,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         let mut found_attr: Option<&'a ast::Attribute> = None;\n \n         for attr in &item.attrs {\n-            if self.sess.is_proc_macro_attr(&attr) {\n+            if attr.is_proc_macro_attr() {\n                 if let Some(prev_attr) = found_attr {\n                     let prev_item = prev_attr.get_normal_item();\n                     let item = attr.get_normal_item();"}, {"sha": "caed40d9fa81b02e5e00e160ca43e7b0132a840c", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::ExpansionConfig;\n use rustc_session::Session;\n@@ -16,10 +16,10 @@ pub fn inject(\n     let edition = sess.parse_sess.edition;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[Symbol] = if sess.contains_name(&krate.attrs, sym::no_core) {\n+    let names: &[Symbol] = if attr::contains_name(&krate.attrs, sym::no_core) {\n         return krate;\n-    } else if sess.contains_name(&krate.attrs, sym::no_std) {\n-        if sess.contains_name(&krate.attrs, sym::compiler_builtins) {\n+    } else if attr::contains_name(&krate.attrs, sym::no_std) {\n+        if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n             &[sym::core]\n         } else {\n             &[sym::core, sym::compiler_builtins]"}, {"sha": "44b9c4718a75feec636591e387204d5afb3b36c3", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,12 +1,11 @@\n /// The expansion from a test function to the appropriate test struct for libtest\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n use crate::util::{check_builtin_macro_attribute, warn_on_duplicate_attribute};\n-use rustc_ast as ast;\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, attr};\n use rustc_ast_pretty::pprust;\n use rustc_errors::Applicability;\n use rustc_expand::base::*;\n-use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{FileNameDisplayPreference, Span};\n use std::iter;\n@@ -291,14 +290,11 @@ pub fn expand_test_or_bench(\n                                         ),\n                                     ),\n                                     // ignore: true | false\n-                                    field(\n-                                        \"ignore\",\n-                                        cx.expr_bool(sp, should_ignore(&cx.sess, &item)),\n-                                    ),\n+                                    field(\"ignore\", cx.expr_bool(sp, should_ignore(&item)),),\n                                     // ignore_message: Some(\"...\") | None\n                                     field(\n                                         \"ignore_message\",\n-                                        if let Some(msg) = should_ignore_message(cx, &item) {\n+                                        if let Some(msg) = should_ignore_message(&item) {\n                                             cx.expr_some(sp, cx.expr_str(sp, msg))\n                                         } else {\n                                             cx.expr_none(sp)\n@@ -425,12 +421,12 @@ enum ShouldPanic {\n     Yes(Option<Symbol>),\n }\n \n-fn should_ignore(sess: &Session, i: &ast::Item) -> bool {\n-    sess.contains_name(&i.attrs, sym::ignore)\n+fn should_ignore(i: &ast::Item) -> bool {\n+    attr::contains_name(&i.attrs, sym::ignore)\n }\n \n-fn should_ignore_message(cx: &ExtCtxt<'_>, i: &ast::Item) -> Option<Symbol> {\n-    match cx.sess.find_by_name(&i.attrs, sym::ignore) {\n+fn should_ignore_message(i: &ast::Item) -> Option<Symbol> {\n+    match attr::find_by_name(&i.attrs, sym::ignore) {\n         Some(attr) => {\n             match attr.meta_item_list() {\n                 // Handle #[ignore(bar = \"foo\")]\n@@ -444,7 +440,7 @@ fn should_ignore_message(cx: &ExtCtxt<'_>, i: &ast::Item) -> Option<Symbol> {\n }\n \n fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n-    match cx.sess.find_by_name(&i.attrs, sym::should_panic) {\n+    match attr::find_by_name(&i.attrs, sym::should_panic) {\n         Some(attr) => {\n             let sd = &cx.sess.parse_sess.span_diagnostic;\n \n@@ -510,7 +506,7 @@ fn test_type(cx: &ExtCtxt<'_>) -> TestType {\n }\n \n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_should_panic_attr = cx.sess.contains_name(&i.attrs, sym::should_panic);\n+    let has_should_panic_attr = attr::contains_name(&i.attrs, sym::should_panic);\n     let sd = &cx.sess.parse_sess.span_diagnostic;\n     match &i.kind {\n         ast::ItemKind::Fn(box ast::Fn { sig, generics, .. }) => {"}, {"sha": "2d491b2dac8b250bbfdb410c4aa5a352415ddad7", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -47,11 +47,11 @@ pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        sess.first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n+        attr::first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n \n     // Do this here so that the test_runner crate attribute gets marked as used\n     // even in non-test builds\n-    let test_runner = get_test_runner(sess, span_diagnostic, &krate);\n+    let test_runner = get_test_runner(span_diagnostic, &krate);\n \n     if sess.opts.test {\n         let panic_strategy = match (panic_strategy, sess.opts.unstable_opts.panic_abort_tests) {\n@@ -123,7 +123,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let mut item = i.into_inner();\n-        if let Some(name) = get_test_name(&self.cx.ext_cx.sess, &item) {\n+        if let Some(name) = get_test_name(&item) {\n             debug!(\"this is a test item\");\n \n             let test = Test { span: item.span, ident: item.ident, name };\n@@ -145,12 +145,12 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n // Beware, this is duplicated in librustc_passes/entry.rs (with\n // `rustc_hir::Item`), so make sure to keep them in sync.\n-fn entry_point_type(sess: &Session, item: &ast::Item, depth: usize) -> EntryPointType {\n+fn entry_point_type(item: &ast::Item, depth: usize) -> EntryPointType {\n     match item.kind {\n         ast::ItemKind::Fn(..) => {\n-            if sess.contains_name(&item.attrs, sym::start) {\n+            if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if sess.contains_name(&item.attrs, sym::rustc_main) {\n+            } else if attr::contains_name(&item.attrs, sym::rustc_main) {\n                 EntryPointType::RustcMainAttr\n             } else if item.ident.name == sym::main {\n                 if depth == 0 {\n@@ -184,7 +184,7 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n         // Remove any #[rustc_main] or #[start] from the AST so it doesn't\n         // clash with the one we're going to add, but mark it as\n         // #[allow(dead_code)] to avoid printing warnings.\n-        let item = match entry_point_type(self.sess, &item, self.depth) {\n+        let item = match entry_point_type(&item, self.depth) {\n             EntryPointType::MainNamed | EntryPointType::RustcMainAttr | EntryPointType::Start => {\n                 item.map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n                     let allow_dead_code = attr::mk_attr_nested_word(\n@@ -373,16 +373,12 @@ fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     )\n }\n \n-fn get_test_name(sess: &Session, i: &ast::Item) -> Option<Symbol> {\n-    sess.first_attr_value_str_by_name(&i.attrs, sym::rustc_test_marker)\n+fn get_test_name(i: &ast::Item) -> Option<Symbol> {\n+    attr::first_attr_value_str_by_name(&i.attrs, sym::rustc_test_marker)\n }\n \n-fn get_test_runner(\n-    sess: &Session,\n-    sd: &rustc_errors::Handler,\n-    krate: &ast::Crate,\n-) -> Option<ast::Path> {\n-    let test_attr = sess.find_by_name(&krate.attrs, sym::test_runner)?;\n+fn get_test_runner(sd: &rustc_errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n+    let test_attr = attr::find_by_name(&krate.attrs, sym::test_runner)?;\n     let meta_list = test_attr.meta_item_list()?;\n     let span = test_attr.span;\n     match &*meta_list {"}, {"sha": "9463a1418ce31bc5242c3288155c51a2d8a482c7", "filename": "compiler/rustc_builtin_macros/src/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::{AttrStyle, Attribute, MetaItem};\n+use rustc_ast::{attr, AttrStyle, Attribute, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_feature::AttributeTemplate;\n use rustc_lint_defs::builtin::DUPLICATE_MACRO_ATTRIBUTES;\n@@ -36,7 +36,7 @@ pub fn warn_on_duplicate_attribute(ecx: &ExtCtxt<'_>, item: &Annotatable, name:\n         _ => None,\n     };\n     if let Some(attrs) = attrs {\n-        if let Some(attr) = ecx.sess.find_by_name(attrs, name) {\n+        if let Some(attr) = attr::find_by_name(attrs, name) {\n             ecx.parse_sess().buffer_lint(\n                 DUPLICATE_MACRO_ATTRIBUTES,\n                 attr.span,"}, {"sha": "94806e0d798ed5a239c40aab8be54d771e453c53", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -48,9 +48,7 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n ) -> (Pointer, Value) {\n     let (ptr, vtable) = 'block: {\n         if let Abi::Scalar(_) = arg.layout().abi {\n-            'descend_newtypes: while !arg.layout().ty.is_unsafe_ptr()\n-                && !arg.layout().ty.is_region_ptr()\n-            {\n+            'descend_newtypes: while !arg.layout().ty.is_unsafe_ptr() && !arg.layout().ty.is_ref() {\n                 for i in 0..arg.layout().fields.count() {\n                     let field = arg.value_field(fx, mir::Field::new(i));\n                     if !field.layout().is_zst() {"}, {"sha": "ff2b005d757672cf666734e0890cba1c5abc8e40", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -5,12 +5,12 @@ use crate::llvm;\n use crate::builder::Builder;\n use crate::common::CodegenCx;\n use crate::value::Value;\n+use rustc_ast::attr;\n use rustc_codegen_ssa::base::collect_debugger_visualizers_transitive;\n use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n use rustc_session::config::{CrateType, DebugInfo};\n-\n use rustc_span::symbol::sym;\n use rustc_span::DebuggerVisualizerType;\n \n@@ -87,7 +87,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global<'ll>(cx: &CodegenCx<'ll, '\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        cx.tcx.sess.contains_name(cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n+        attr::contains_name(cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n \n     // To ensure the section `__rustc_debug_gdb_scripts_section__` will not create\n     // ODR violations at link time, this section will not be emitted for rlibs since"}, {"sha": "46692fd5e8bcfadd23e27842b5fc137db3c87a71", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -424,7 +424,7 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n         .filter_map(|s| {\n             let enable_disable = match s.chars().next() {\n                 None => return None,\n-                Some(c @ '+' | c @ '-') => c,\n+                Some(c @ ('+' | '-')) => c,\n                 Some(_) => {\n                     if diagnostics {\n                         sess.emit_warning(UnknownCTargetFeaturePrefix { feature: s });"}, {"sha": "7ce72d2172799ceaeb85ce9f0345f29d04cfbb82", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -8,6 +8,7 @@ use crate::{\n     CachedModuleCodegen, CodegenResults, CompiledModule, CrateInfo, ModuleCodegen, ModuleKind,\n };\n use jobserver::{Acquired, Client};\n+use rustc_ast::attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n@@ -447,8 +448,8 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n \n     let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n-    let no_builtins = tcx.sess.contains_name(crate_attrs, sym::no_builtins);\n-    let is_compiler_builtins = tcx.sess.contains_name(crate_attrs, sym::compiler_builtins);\n+    let no_builtins = attr::contains_name(crate_attrs, sym::no_builtins);\n+    let is_compiler_builtins = attr::contains_name(crate_attrs, sym::compiler_builtins);\n \n     let crate_info = CrateInfo::new(tcx, target_cpu);\n "}, {"sha": "4d34b3da5f501e82750fc61188390eefa953650f", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -809,7 +809,7 @@ impl CrateInfo {\n             .collect();\n         let local_crate_name = tcx.crate_name(LOCAL_CRATE);\n         let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n-        let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n+        let subsystem = attr::first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n         let windows_subsystem = subsystem.map(|subsystem| {\n             if subsystem != sym::windows && subsystem != sym::console {\n                 tcx.sess.emit_fatal(errors::InvalidWindowsSubsystem { subsystem });"}, {"sha": "de1e00bd7a3e383b9548df7369baa5b971b58479", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -917,7 +917,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         //\n                         // This is also relevant for `Pin<&mut Self>`, where we need to peel the `Pin`.\n                         'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n-                            && !op.layout.ty.is_region_ptr()\n+                            && !op.layout.ty.is_ref()\n                         {\n                             for i in 0..op.layout.fields.count() {\n                                 let field = op.extract_field(bx, i);\n@@ -959,7 +959,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     Immediate(_) => {\n                         // See comment above explaining why we peel these newtypes\n                         'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n-                            && !op.layout.ty.is_region_ptr()\n+                            && !op.layout.ty.is_ref()\n                         {\n                             for i in 0..op.layout.fields.count() {\n                                 let field = op.extract_field(bx, i);"}, {"sha": "350ce529ef538855dd996453804a6935b932214c", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::{LangItem, CRATE_HIR_ID};\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::PointerArithmetic;\n-use rustc_middle::ty::layout::FnAbiOf;\n+use rustc_middle::ty::layout::{FnAbiOf, TyAndLayout};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::builtin::INVALID_ALIGNMENT;\n use std::borrow::Borrow;\n@@ -335,8 +335,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     #[inline(always)]\n-    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n-        ecx.tcx.sess.opts.unstable_opts.extra_const_ub_checks\n+    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>, layout: TyAndLayout<'tcx>) -> bool {\n+        ecx.tcx.sess.opts.unstable_opts.extra_const_ub_checks || layout.abi.is_uninhabited()\n     }\n \n     fn alignment_check_failed("}, {"sha": "aca68dc454beeeb6c32e1790c2a9a4e724863b6c", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -8,6 +8,7 @@ use std::hash::Hash;\n \n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_middle::mir;\n+use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::DefId;\n use rustc_target::abi::{Align, Size};\n@@ -145,8 +146,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         check: CheckAlignment,\n     ) -> InterpResult<'tcx, ()>;\n \n-    /// Whether to enforce the validity invariant\n-    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n+    /// Whether to enforce the validity invariant for a specific layout.\n+    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>, layout: TyAndLayout<'tcx>) -> bool;\n \n     /// Whether function calls should be [ABI](CallAbi)-checked.\n     fn enforce_abi(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {"}, {"sha": "ff6db143ddfd974979fb1efac580cebf064e13c5", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -461,7 +461,7 @@ where\n     ) -> InterpResult<'tcx> {\n         self.write_immediate_no_validate(src, dest)?;\n \n-        if M::enforce_validity(self) {\n+        if M::enforce_validity(self, dest.layout) {\n             // Data got changed, better make sure it matches the type!\n             self.validate_operand(&self.place_to_op(dest)?)?;\n         }\n@@ -616,7 +616,7 @@ where\n     ) -> InterpResult<'tcx> {\n         self.copy_op_no_validate(src, dest, allow_transmute)?;\n \n-        if M::enforce_validity(self) {\n+        if M::enforce_validity(self, dest.layout) {\n             // Data got changed, better make sure it matches the type!\n             self.validate_operand(&self.place_to_op(dest)?)?;\n         }"}, {"sha": "0339fb925d4587870037fb09cab5dcb091c63646", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -79,7 +79,6 @@ pub mod sync;\n pub mod tiny_list;\n pub mod transitive_relation;\n pub mod vec_linked_list;\n-pub mod vec_map;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;"}, {"sha": "d1a99bcaeb75452a28b497c99f1bddddea8ecd3e", "filename": "compiler/rustc_data_structures/src/vec_map.rs", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/b00302e2884fe28c710b6d7513b477455ad14e82/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00302e2884fe28c710b6d7513b477455ad14e82/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs?ref=b00302e2884fe28c710b6d7513b477455ad14e82", "patch": "@@ -1,192 +0,0 @@\n-use std::borrow::Borrow;\n-use std::fmt::Debug;\n-use std::slice::Iter;\n-use std::vec::IntoIter;\n-\n-use crate::stable_hasher::{HashStable, StableHasher};\n-\n-/// A map type implemented as a vector of pairs `K` (key) and `V` (value).\n-/// It currently provides a subset of all the map operations, the rest could be added as needed.\n-#[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct VecMap<K, V>(Vec<(K, V)>);\n-\n-impl<K, V> VecMap<K, V>\n-where\n-    K: Debug + PartialEq,\n-    V: Debug,\n-{\n-    pub fn new() -> Self {\n-        VecMap(Default::default())\n-    }\n-\n-    /// Sets the value of the entry, and returns the entry's old value.\n-    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n-        if let Some(elem) = self.0.iter_mut().find(|(key, _)| *key == k) {\n-            Some(std::mem::replace(&mut elem.1, v))\n-        } else {\n-            self.0.push((k, v));\n-            None\n-        }\n-    }\n-\n-    /// Removes the entry from the map and returns the removed value\n-    pub fn remove(&mut self, k: &K) -> Option<V> {\n-        self.0.iter().position(|(k2, _)| k2 == k).map(|pos| self.0.remove(pos).1)\n-    }\n-\n-    /// Gets a reference to the value in the entry.\n-    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-    where\n-        K: Borrow<Q>,\n-        Q: Eq,\n-    {\n-        self.0.iter().find(|(key, _)| k == key.borrow()).map(|elem| &elem.1)\n-    }\n-\n-    /// Gets a mutable reference to the value in the entry.\n-    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-    where\n-        K: Borrow<Q>,\n-        Q: Eq,\n-    {\n-        self.0.iter_mut().find(|(key, _)| k == key.borrow()).map(|elem| &mut elem.1)\n-    }\n-\n-    /// Returns the any value corresponding to the supplied predicate filter.\n-    ///\n-    /// The supplied predicate will be applied to each (key, value) pair and it will return a\n-    /// reference to the values where the predicate returns `true`.\n-    pub fn any_value_matching(&self, mut predicate: impl FnMut(&(K, V)) -> bool) -> Option<&V> {\n-        self.0.iter().find(|kv| predicate(kv)).map(|elem| &elem.1)\n-    }\n-\n-    /// Returns the value corresponding to the supplied predicate filter. It crashes if there's\n-    /// more than one matching element.\n-    ///\n-    /// The supplied predicate will be applied to each (key, value) pair and it will return a\n-    /// reference to the value where the predicate returns `true`.\n-    pub fn get_value_matching(&self, mut predicate: impl FnMut(&(K, V)) -> bool) -> Option<&V> {\n-        let mut filter = self.0.iter().filter(|kv| predicate(kv));\n-        let (_, value) = filter.next()?;\n-        // This should return just one element, otherwise it's a bug\n-        assert!(\n-            filter.next().is_none(),\n-            \"Collection {self:#?} should have just one matching element\"\n-        );\n-        Some(value)\n-    }\n-\n-    /// Returns `true` if the map contains a value for the specified key.\n-    ///\n-    /// The key may be any borrowed form of the map's key type,\n-    /// [`Eq`] on the borrowed form *must* match those for\n-    /// the key type.\n-    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-    where\n-        K: Borrow<Q>,\n-        Q: Eq,\n-    {\n-        self.get(k).is_some()\n-    }\n-\n-    /// Returns `true` if the map contains no elements.\n-    pub fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n-    }\n-\n-    pub fn iter(&self) -> Iter<'_, (K, V)> {\n-        self.into_iter()\n-    }\n-\n-    pub fn iter_mut(&mut self) -> impl Iterator<Item = (&K, &mut V)> {\n-        self.into_iter()\n-    }\n-\n-    pub fn retain(&mut self, f: impl Fn(&(K, V)) -> bool) {\n-        self.0.retain(f)\n-    }\n-}\n-\n-impl<K, V> Default for VecMap<K, V> {\n-    #[inline]\n-    fn default() -> Self {\n-        Self(Default::default())\n-    }\n-}\n-\n-impl<K, V> From<Vec<(K, V)>> for VecMap<K, V> {\n-    fn from(vec: Vec<(K, V)>) -> Self {\n-        Self(vec)\n-    }\n-}\n-\n-impl<K, V> Into<Vec<(K, V)>> for VecMap<K, V> {\n-    fn into(self) -> Vec<(K, V)> {\n-        self.0\n-    }\n-}\n-\n-impl<K, V> FromIterator<(K, V)> for VecMap<K, V> {\n-    fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self {\n-        Self(iter.into_iter().collect())\n-    }\n-}\n-\n-impl<'a, K, V> IntoIterator for &'a VecMap<K, V> {\n-    type Item = &'a (K, V);\n-    type IntoIter = Iter<'a, (K, V)>;\n-\n-    #[inline]\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.0.iter()\n-    }\n-}\n-\n-impl<'a, K: 'a, V: 'a> IntoIterator for &'a mut VecMap<K, V> {\n-    type Item = (&'a K, &'a mut V);\n-    type IntoIter = impl Iterator<Item = Self::Item>;\n-\n-    #[inline]\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.0.iter_mut().map(|(k, v)| (&*k, v))\n-    }\n-}\n-\n-impl<K, V> IntoIterator for VecMap<K, V> {\n-    type Item = (K, V);\n-    type IntoIter = IntoIter<(K, V)>;\n-\n-    #[inline]\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.0.into_iter()\n-    }\n-}\n-\n-impl<K: PartialEq + Debug, V: Debug> Extend<(K, V)> for VecMap<K, V> {\n-    fn extend<I: IntoIterator<Item = (K, V)>>(&mut self, iter: I) {\n-        for (k, v) in iter {\n-            self.insert(k, v);\n-        }\n-    }\n-\n-    fn extend_one(&mut self, (k, v): (K, V)) {\n-        self.insert(k, v);\n-    }\n-\n-    fn extend_reserve(&mut self, additional: usize) {\n-        self.0.extend_reserve(additional);\n-    }\n-}\n-\n-impl<K, V, CTX> HashStable<CTX> for VecMap<K, V>\n-where\n-    K: HashStable<CTX> + Eq,\n-    V: HashStable<CTX>,\n-{\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        self.0.hash_stable(hcx, hasher)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "458b60077dc75a76d5c3f63e31cf8bfbdb10012e", "filename": "compiler/rustc_data_structures/src/vec_map/tests.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b00302e2884fe28c710b6d7513b477455ad14e82/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00302e2884fe28c710b6d7513b477455ad14e82/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs?ref=b00302e2884fe28c710b6d7513b477455ad14e82", "patch": "@@ -1,48 +0,0 @@\n-use super::*;\n-\n-impl<K, V> VecMap<K, V> {\n-    fn into_vec(self) -> Vec<(K, V)> {\n-        self.0.into()\n-    }\n-}\n-\n-#[test]\n-fn test_from_iterator() {\n-    assert_eq!(\n-        std::iter::empty().collect::<VecMap<i32, bool>>().into_vec(),\n-        Vec::<(i32, bool)>::new()\n-    );\n-    assert_eq!(std::iter::once((42, true)).collect::<VecMap<_, _>>().into_vec(), vec![(42, true)]);\n-    assert_eq!(\n-        [(1, true), (2, false)].into_iter().collect::<VecMap<_, _>>().into_vec(),\n-        vec![(1, true), (2, false)]\n-    );\n-}\n-\n-#[test]\n-fn test_into_iterator_owned() {\n-    assert_eq!(VecMap::new().into_iter().collect::<Vec<(i32, bool)>>(), Vec::<(i32, bool)>::new());\n-    assert_eq!(VecMap::from(vec![(1, true)]).into_iter().collect::<Vec<_>>(), vec![(1, true)]);\n-    assert_eq!(\n-        VecMap::from(vec![(1, true), (2, false)]).into_iter().collect::<Vec<_>>(),\n-        vec![(1, true), (2, false)]\n-    );\n-}\n-\n-#[test]\n-fn test_insert() {\n-    let mut v = VecMap::new();\n-    assert_eq!(v.insert(1, true), None);\n-    assert_eq!(v.insert(2, false), None);\n-    assert_eq!(v.clone().into_vec(), vec![(1, true), (2, false)]);\n-    assert_eq!(v.insert(1, false), Some(true));\n-    assert_eq!(v.into_vec(), vec![(1, false), (2, false)]);\n-}\n-\n-#[test]\n-fn test_get() {\n-    let v = [(1, true), (2, false)].into_iter().collect::<VecMap<_, _>>();\n-    assert_eq!(v.get(&1), Some(&true));\n-    assert_eq!(v.get(&2), Some(&false));\n-    assert_eq!(v.get(&3), None);\n-}"}, {"sha": "71d6c6fe2ef2c5377fcf625456ab26d630665330", "filename": "compiler/rustc_error_codes/src/error_codes/E0080.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0080.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0080.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0080.md?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -15,9 +15,8 @@ or causing an integer overflow are two ways to induce this error.\n \n Ensure that the expressions given can be evaluated as the desired integer type.\n \n-See the [Custom Discriminants][custom-discriminants] section of the Reference\n-for more information about setting custom integer types on fieldless enums\n-using the [`repr` attribute][repr-attribute].\n+See the [Discriminants] section of the Reference for more information about\n+setting custom integer types on enums using the [`repr` attribute][repr-attribute].\n \n-[custom-discriminants]: https://doc.rust-lang.org/reference/items/enumerations.html#custom-discriminant-values-for-field-less-enumerations\n-[repr-attribute]: https://doc.rust-lang.org/reference/type-layout.html#reprc-enums\n+[discriminants]: https://doc.rust-lang.org/reference/items/enumerations.html#discriminants\n+[repr-attribute]: https://doc.rust-lang.org/reference/type-layout.html#representations"}, {"sha": "4377a292473319ccd11ff91f53e5a66073a1dcff", "filename": "compiler/rustc_error_codes/src/error_codes/E0794.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0794.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0794.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0794.md?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -59,6 +59,6 @@ In the definition of `bar`, the lifetime parameter `'a` is late-bound, while\n where `'a` is universally quantified and `'b` is substituted by a specific\n lifetime. It is not allowed to explicitly specify early-bound lifetime\n arguments when late-bound lifetime parameters are present (as for `bar_fn2`,\n-see issue #42868: https://github.com/rust-lang/rust/issues/42868), although the\n+see [issue #42868](https://github.com/rust-lang/rust/issues/42868)), although the\n types that are constrained by early-bound parameters can be specified (as for\n `bar_fn3`)."}, {"sha": "6eb0d24eb976ea253a8007c428540dacfb68bf92", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -776,16 +776,14 @@ impl SyntaxExtension {\n         let allow_internal_unstable =\n             attr::allow_internal_unstable(sess, &attrs).collect::<Vec<Symbol>>();\n \n-        let allow_internal_unsafe = sess.contains_name(attrs, sym::allow_internal_unsafe);\n-        let local_inner_macros = sess\n-            .find_by_name(attrs, sym::macro_export)\n+        let allow_internal_unsafe = attr::contains_name(attrs, sym::allow_internal_unsafe);\n+        let local_inner_macros = attr::find_by_name(attrs, sym::macro_export)\n             .and_then(|macro_export| macro_export.meta_item_list())\n             .map_or(false, |l| attr::list_contains_name(&l, sym::local_inner_macros));\n-        let collapse_debuginfo = sess.contains_name(attrs, sym::collapse_debuginfo);\n+        let collapse_debuginfo = attr::contains_name(attrs, sym::collapse_debuginfo);\n         tracing::debug!(?local_inner_macros, ?collapse_debuginfo, ?allow_internal_unsafe);\n \n-        let (builtin_name, helper_attrs) = sess\n-            .find_by_name(attrs, sym::rustc_builtin_macro)\n+        let (builtin_name, helper_attrs) = attr::find_by_name(attrs, sym::rustc_builtin_macro)\n             .map(|attr| {\n                 // Override `helper_attrs` passed above if it's a built-in macro,\n                 // marking `proc_macro_derive` macros as built-in is not a realistic use case."}, {"sha": "0863d65d8f9c8a4bdbafab19d6d8a04962f56755", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -301,6 +301,7 @@ language_item_table! {\n     Context,                 sym::Context,             context,                    Target::Struct,         GenericRequirement::None;\n     FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n+    Option,                  sym::Option,              option_type,                Target::Enum,           GenericRequirement::None;\n     OptionSome,              sym::Some,                option_some_variant,        Target::Variant,        GenericRequirement::None;\n     OptionNone,              sym::None,                option_none_variant,        Target::Variant,        GenericRequirement::None;\n "}, {"sha": "894995c1bfca7c37b9257b7fda2689e0da05fa37", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 51, "deletions": 31, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -31,6 +31,7 @@ use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::middle::stability::AllowUnstable;\n+use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n@@ -2225,47 +2226,66 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let param_env = tcx.param_env(block.owner.to_def_id());\n         let cause = ObligationCause::misc(span, block.owner.def_id);\n+\n         let mut fulfillment_errors = Vec::new();\n-        let mut applicable_candidates: Vec<_> = candidates\n-            .iter()\n-            .filter_map(|&(impl_, (assoc_item, def_scope))| {\n-                infcx.probe(|_| {\n-                    let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n+        let mut applicable_candidates: Vec<_> = infcx.probe(|_| {\n+            let universe = infcx.create_next_universe();\n+\n+            // Regions are not considered during selection.\n+            let self_ty = tcx.replace_escaping_bound_vars_uncached(\n+                self_ty,\n+                FnMutDelegate {\n+                    regions: &mut |_| tcx.lifetimes.re_erased,\n+                    types: &mut |bv| {\n+                        tcx.mk_placeholder(ty::PlaceholderType { universe, name: bv.kind })\n+                    },\n+                    consts: &mut |bv, ty| {\n+                        tcx.mk_const(ty::PlaceholderConst { universe, name: bv }, ty)\n+                    },\n+                },\n+            );\n \n-                    let impl_ty = tcx.type_of(impl_);\n-                    let impl_substs = infcx.fresh_item_substs(impl_);\n-                    let impl_ty = impl_ty.subst(tcx, impl_substs);\n-                    let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n+            candidates\n+                .iter()\n+                .filter_map(|&(impl_, (assoc_item, def_scope))| {\n+                    infcx.probe(|_| {\n+                        let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n \n-                    // Check that the Self-types can be related.\n-                    // FIXME(fmease): Should we use `eq` here?\n-                    ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n+                        let impl_ty = tcx.type_of(impl_);\n+                        let impl_substs = infcx.fresh_item_substs(impl_);\n+                        let impl_ty = impl_ty.subst(tcx, impl_substs);\n+                        let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n \n-                    // Check whether the impl imposes obligations we have to worry about.\n-                    let impl_bounds = tcx.predicates_of(impl_);\n-                    let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n+                        // Check that the Self-types can be related.\n+                        // FIXME(fmease): Should we use `eq` here?\n+                        ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n \n-                    let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n+                        // Check whether the impl imposes obligations we have to worry about.\n+                        let impl_bounds = tcx.predicates_of(impl_);\n+                        let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n \n-                    let impl_obligations = traits::predicates_for_generics(\n-                        |_, _| cause.clone(),\n-                        param_env,\n-                        impl_bounds,\n-                    );\n+                        let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n \n-                    ocx.register_obligations(impl_obligations);\n+                        let impl_obligations = traits::predicates_for_generics(\n+                            |_, _| cause.clone(),\n+                            param_env,\n+                            impl_bounds,\n+                        );\n \n-                    let mut errors = ocx.select_where_possible();\n-                    if !errors.is_empty() {\n-                        fulfillment_errors.append(&mut errors);\n-                        return None;\n-                    }\n+                        ocx.register_obligations(impl_obligations);\n+\n+                        let mut errors = ocx.select_where_possible();\n+                        if !errors.is_empty() {\n+                            fulfillment_errors.append(&mut errors);\n+                            return None;\n+                        }\n \n-                    // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n-                    Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                        // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n+                        Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                    })\n                 })\n-            })\n-            .collect();\n+                .collect()\n+        });\n \n         if applicable_candidates.len() > 1 {\n             return Err(self.complain_about_ambiguous_inherent_assoc_type("}, {"sha": "d8dda7a93be1369d36d13c9e718b6c3d74168cf7", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -305,7 +305,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n     }) = item.kind\n     {\n         let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-        let opaque_identity_ty = if in_trait {\n+        let opaque_identity_ty = if in_trait && !tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n             tcx.mk_projection(def_id.to_def_id(), substs)\n         } else {\n             tcx.mk_opaque(def_id.to_def_id(), substs)\n@@ -554,7 +554,15 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n             check_union(tcx, id.owner_id.def_id);\n         }\n         DefKind::OpaqueTy => {\n-            check_opaque(tcx, id);\n+            let opaque = tcx.hir().expect_item(id.owner_id.def_id).expect_opaque_ty();\n+            if let hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id) = opaque.origin\n+                && let hir::Node::TraitItem(trait_item) = tcx.hir().get_by_def_id(fn_def_id)\n+                && let (_, hir::TraitFn::Required(..)) = trait_item.expect_fn()\n+            {\n+                // Skip opaques from RPIT in traits with no default body.\n+            } else {\n+                check_opaque(tcx, id);\n+            }\n         }\n         DefKind::ImplTraitPlaceholder => {\n             let parent = tcx.impl_trait_in_trait_parent_fn(id.owner_id.to_def_id());"}, {"sha": "1b7475486dceace01728f805f507c1139fbc6d73", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -223,6 +223,21 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 ],\n                 tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Not }),\n             ),\n+            sym::option_payload_ptr => {\n+                let option_def_id = tcx.require_lang_item(hir::LangItem::Option, None);\n+                let p0 = param(0);\n+                (\n+                    1,\n+                    vec![tcx.mk_ptr(ty::TypeAndMut {\n+                        ty: tcx.mk_adt(\n+                            tcx.adt_def(option_def_id),\n+                            tcx.mk_substs_from_iter([ty::GenericArg::from(p0)].into_iter()),\n+                        ),\n+                        mutbl: hir::Mutability::Not,\n+                    })],\n+                    tcx.mk_ptr(ty::TypeAndMut { ty: p0, mutbl: hir::Mutability::Not }),\n+                )\n+            }\n             sym::ptr_mask => (\n                 1,\n                 vec!["}, {"sha": "8fe4c44fca43a6f0056a899067f749c2c09d4f96", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -202,8 +202,11 @@ fn missing_items_err(\n     missing_items: &[ty::AssocItem],\n     full_impl_span: Span,\n ) {\n+    let missing_items =\n+        missing_items.iter().filter(|trait_item| tcx.opt_rpitit_info(trait_item.def_id).is_none());\n+\n     let missing_items_msg = missing_items\n-        .iter()\n+        .clone()\n         .map(|trait_item| trait_item.name.to_string())\n         .collect::<Vec<_>>()\n         .join(\"`, `\");"}, {"sha": "c41e96290df1632f95635926afe9133efc523974", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1208,7 +1208,7 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n                     fn_sig,\n                     Applicability::MachineApplicable,\n                 );\n-            } else if let Some(sugg) = suggest_impl_trait(tcx, ret_ty, ty.span, hir_id, def_id) {\n+            } else if let Some(sugg) = suggest_impl_trait(tcx, ret_ty, ty.span, def_id) {\n                 diag.span_suggestion(\n                     ty.span,\n                     \"replace with an appropriate return type\",\n@@ -1240,12 +1240,10 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n     }\n }\n \n-// FIXME(vincenzopalazzo): remove the hir item when the refactoring is stable\n fn suggest_impl_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ret_ty: Ty<'tcx>,\n     span: Span,\n-    _hir_id: hir::HirId,\n     def_id: LocalDefId,\n ) -> Option<String> {\n     let format_as_assoc: fn(_, _, _, _, _) -> _ ="}, {"sha": "225b1550580761773ccf860456777cc3bb71557b", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -778,7 +778,7 @@ fn find_opaque_ty_constraints_for_rpit(\n             // Use borrowck to get the type with unerased regions.\n             let concrete_opaque_types = &self.tcx.mir_borrowck(def_id).concrete_opaque_types;\n             debug!(?concrete_opaque_types);\n-            for &(def_id, concrete_type) in concrete_opaque_types {\n+            for (&def_id, &concrete_type) in concrete_opaque_types {\n                 if def_id != self.def_id {\n                     // Ignore constraints for other opaque types.\n                     continue;"}, {"sha": "4846579b9809b041487a705ca652c97e5c0ace36", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1487,7 +1487,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     {\n                         let deref_kind = if checked_ty.is_box() {\n                             \"unboxing the value\"\n-                        } else if checked_ty.is_region_ptr() {\n+                        } else if checked_ty.is_ref() {\n                             \"dereferencing the borrow\"\n                         } else {\n                             \"dereferencing the type\""}, {"sha": "fb7cb86d734eff2c13603ff3a0ab16c5b057db13", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let ty = ensure_sufficient_stack(|| match &expr.kind {\n             hir::ExprKind::Path(\n-                qpath @ hir::QPath::Resolved(..) | qpath @ hir::QPath::TypeRelative(..),\n+                qpath @ (hir::QPath::Resolved(..) | hir::QPath::TypeRelative(..)),\n             ) => self.check_expr_path(qpath, expr, args),\n             _ => self.check_expr_kind(expr, expected),\n         });"}, {"sha": "18a49ef2f0162daae349a10f8afe4b6d2154f49b", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -165,8 +165,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         ty: Ty<'tcx>,\n     ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)> {\n-        let body_hir_id = self.tcx.hir().local_def_id_to_hir_id(self.body_id);\n-        self.err_ctxt().extract_callable_info(body_hir_id, self.param_env, ty)\n+        self.err_ctxt().extract_callable_info(self.body_id, self.param_env, ty)\n     }\n \n     pub fn suggest_two_fn_call("}, {"sha": "b219be4ae199219a6980f35b5e9070ab76298c41", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1182,7 +1182,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 .inputs()\n                                 .skip_binder()\n                                 .get(0)\n-                                .filter(|ty| ty.is_region_ptr() && !rcvr_ty.is_region_ptr())\n+                                .filter(|ty| ty.is_ref() && !rcvr_ty.is_ref())\n                                 .copied()\n                                 .unwrap_or(rcvr_ty),\n                         };"}, {"sha": "d240d8e491fafb3aa3f29920670e71782cb3a85b", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -30,6 +30,8 @@ use super::*;\n use rustc_middle::ty::relate::{Relate, TypeRelation};\n use rustc_middle::ty::{Const, ImplSubject};\n \n+use std::cell::Cell;\n+\n /// Whether we should define opaque types or just treat them opaquely.\n ///\n /// Currently only used to prevent predicate matching from matching anything\n@@ -82,6 +84,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             in_snapshot: self.in_snapshot.clone(),\n             universe: self.universe.clone(),\n             intercrate: self.intercrate,\n+            inside_canonicalization_ctxt: Cell::new(self.inside_canonicalization_ctxt()),\n         }\n     }\n }"}, {"sha": "96a5f6532fecdadc0aa2a9f1dcbad2de4a60e305", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -561,6 +561,8 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     where\n         V: TypeFoldable<TyCtxt<'tcx>>,\n     {\n+        let _inside_canonical_ctxt_guard = infcx.set_canonicalization_ctxt();\n+\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::NEEDS_INFER |\n             TypeFlags::HAS_FREE_REGIONS | // `HAS_RE_PLACEHOLDER` implies `HAS_FREE_REGIONS`"}, {"sha": "268896b671adf50a9ff5cc429ff30c2c120ff53e", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -159,9 +159,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             .opaque_type_storage\n             .opaque_types\n             .iter()\n-            .map(|&(k, ref v)| {\n-                (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty)\n-            })\n+            .map(|(k, v)| (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty))\n             .collect()\n     }\n "}, {"sha": "9afe9cc1e760e2312b43c9283128ed993ee48ccc", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -39,6 +39,7 @@ use rustc_span::Span;\n \n use std::cell::{Cell, RefCell};\n use std::fmt;\n+use std::ops::Drop;\n \n use self::combine::CombineFields;\n use self::error_reporting::TypeErrCtxt;\n@@ -342,6 +343,11 @@ pub struct InferCtxt<'tcx> {\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n     pub intercrate: bool,\n+\n+    /// Flag that is set when we enter canonicalization. Used for debugging to ensure\n+    /// that we only collect region information for `BorrowckInferCtxt::reg_var_to_origin`\n+    /// inside non-canonicalization contexts.\n+    inside_canonicalization_ctxt: Cell<bool>,\n }\n \n /// See the `error_reporting` module for more details.\n@@ -585,8 +591,8 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n-    pub fn intercrate(mut self) -> Self {\n-        self.intercrate = true;\n+    pub fn intercrate(mut self, intercrate: bool) -> Self {\n+        self.intercrate = intercrate;\n         self\n     }\n \n@@ -633,6 +639,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             skip_leak_check: Cell::new(false),\n             universe: Cell::new(ty::UniverseIndex::ROOT),\n             intercrate,\n+            inside_canonicalization_ctxt: Cell::new(false),\n         }\n     }\n }\n@@ -1728,6 +1735,31 @@ impl<'tcx> InferCtxt<'tcx> {\n             }\n         }\n     }\n+\n+    pub fn inside_canonicalization_ctxt(&self) -> bool {\n+        self.inside_canonicalization_ctxt.get()\n+    }\n+\n+    pub fn set_canonicalization_ctxt(&self) -> CanonicalizationCtxtGuard<'_, 'tcx> {\n+        let prev_ctxt = self.inside_canonicalization_ctxt();\n+        self.inside_canonicalization_ctxt.set(true);\n+        CanonicalizationCtxtGuard { prev_ctxt, infcx: self }\n+    }\n+\n+    fn set_canonicalization_ctxt_to(&self, ctxt: bool) {\n+        self.inside_canonicalization_ctxt.set(ctxt);\n+    }\n+}\n+\n+pub struct CanonicalizationCtxtGuard<'cx, 'tcx> {\n+    prev_ctxt: bool,\n+    infcx: &'cx InferCtxt<'tcx>,\n+}\n+\n+impl<'cx, 'tcx> Drop for CanonicalizationCtxtGuard<'cx, 'tcx> {\n+    fn drop(&mut self) {\n+        self.infcx.set_canonicalization_ctxt_to(self.prev_ctxt)\n+    }\n }\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {"}, {"sha": "2320f6bfb1674a434c493896e850870210fddff3", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 104, "deletions": 170, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -28,6 +28,7 @@ use crate::traits::{Obligation, PredicateObligations};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor};\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n@@ -55,21 +56,6 @@ where\n     ambient_variance: ty::Variance,\n \n     ambient_variance_info: ty::VarianceDiagInfo<'tcx>,\n-\n-    /// When we pass through a set of binders (e.g., when looking into\n-    /// a `fn` type), we push a new bound region scope onto here. This\n-    /// will contain the instantiated region for each region in those\n-    /// binders. When we then encounter a `ReLateBound(d, br)`, we can\n-    /// use the De Bruijn index `d` to find the right scope, and then\n-    /// bound region name `br` to find the specific instantiation from\n-    /// within that scope. See `replace_bound_region`.\n-    ///\n-    /// This field stores the instantiations for late-bound regions in\n-    /// the `a` type.\n-    a_scopes: Vec<BoundRegionScope<'tcx>>,\n-\n-    /// Same as `a_scopes`, but for the `b` type.\n-    b_scopes: Vec<BoundRegionScope<'tcx>>,\n }\n \n pub trait TypeRelatingDelegate<'tcx> {\n@@ -147,8 +133,6 @@ where\n             delegate,\n             ambient_variance,\n             ambient_variance_info: ty::VarianceDiagInfo::default(),\n-            a_scopes: vec![],\n-            b_scopes: vec![],\n         }\n     }\n \n@@ -166,88 +150,6 @@ where\n         }\n     }\n \n-    fn create_scope(\n-        &mut self,\n-        value: ty::Binder<'tcx, impl Relate<'tcx>>,\n-        universally_quantified: UniversallyQuantified,\n-    ) -> BoundRegionScope<'tcx> {\n-        let mut scope = BoundRegionScope::default();\n-\n-        // Create a callback that creates (via the delegate) either an\n-        // existential or placeholder region as needed.\n-        let mut next_region = {\n-            let delegate = &mut self.delegate;\n-            let mut lazy_universe = None;\n-            move |br: ty::BoundRegion| {\n-                if universally_quantified.0 {\n-                    // The first time this closure is called, create a\n-                    // new universe for the placeholders we will make\n-                    // from here out.\n-                    let universe = lazy_universe.unwrap_or_else(|| {\n-                        let universe = delegate.create_next_universe();\n-                        lazy_universe = Some(universe);\n-                        universe\n-                    });\n-\n-                    let placeholder = ty::PlaceholderRegion { universe, name: br.kind };\n-                    delegate.next_placeholder_region(placeholder)\n-                } else {\n-                    delegate.next_existential_region_var(true, br.kind.get_name())\n-                }\n-            }\n-        };\n-\n-        value.skip_binder().visit_with(&mut ScopeInstantiator {\n-            next_region: &mut next_region,\n-            target_index: ty::INNERMOST,\n-            bound_region_scope: &mut scope,\n-        });\n-\n-        scope\n-    }\n-\n-    /// When we encounter binders during the type traversal, we record\n-    /// the value to substitute for each of the things contained in\n-    /// that binder. (This will be either a universal placeholder or\n-    /// an existential inference variable.) Given the De Bruijn index\n-    /// `debruijn` (and name `br`) of some binder we have now\n-    /// encountered, this routine finds the value that we instantiated\n-    /// the region with; to do so, it indexes backwards into the list\n-    /// of ambient scopes `scopes`.\n-    fn lookup_bound_region(\n-        debruijn: ty::DebruijnIndex,\n-        br: &ty::BoundRegion,\n-        first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope<'tcx>],\n-    ) -> ty::Region<'tcx> {\n-        // The debruijn index is a \"reverse index\" into the\n-        // scopes listing. So when we have INNERMOST (0), we\n-        // want the *last* scope pushed, and so forth.\n-        let debruijn_index = debruijn.index() - first_free_index.index();\n-        let scope = &scopes[scopes.len() - debruijn_index - 1];\n-\n-        // Find this bound region in that scope to map to a\n-        // particular region.\n-        scope.map[br]\n-    }\n-\n-    /// If `r` is a bound region, find the scope in which it is bound\n-    /// (from `scopes`) and return the value that we instantiated it\n-    /// with. Otherwise just return `r`.\n-    fn replace_bound_region(\n-        &self,\n-        r: ty::Region<'tcx>,\n-        first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope<'tcx>],\n-    ) -> ty::Region<'tcx> {\n-        debug!(\"replace_bound_regions(scopes={:?})\", scopes);\n-        if let ty::ReLateBound(debruijn, br) = *r {\n-            Self::lookup_bound_region(debruijn, &br, first_free_index, scopes)\n-        } else {\n-            r\n-        }\n-    }\n-\n     /// Push a new outlives requirement into our output set of\n     /// constraints.\n     fn push_outlives(\n@@ -314,18 +216,9 @@ where\n \n         self.infcx.inner.borrow_mut().type_variables().instantiate(vid, generalized_ty);\n \n-        // The generalized values we extract from `canonical_var_values` have\n-        // been fully instantiated and hence the set of scopes we have\n-        // doesn't matter -- just to be sure, put an empty vector\n-        // in there.\n-        let old_a_scopes = std::mem::take(pair.vid_scopes(self));\n-\n         // Relate the generalized kind to the original one.\n         let result = pair.relate_generalized_ty(self, generalized_ty);\n \n-        // Restore the old scopes now.\n-        *pair.vid_scopes(self) = old_a_scopes;\n-\n         debug!(\"relate_ty_var: complete, result = {:?}\", result);\n         result\n     }\n@@ -379,6 +272,97 @@ where\n         trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n         Ok(a)\n     }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn instantiate_binder_with_placeholders<T>(&mut self, binder: ty::Binder<'tcx, T>) -> T\n+    where\n+        T: ty::TypeFoldable<TyCtxt<'tcx>> + Copy,\n+    {\n+        if let Some(inner) = binder.no_bound_vars() {\n+            return inner;\n+        }\n+\n+        let mut next_region = {\n+            let nll_delegate = &mut self.delegate;\n+            let mut lazy_universe = None;\n+\n+            move |br: ty::BoundRegion| {\n+                // The first time this closure is called, create a\n+                // new universe for the placeholders we will make\n+                // from here out.\n+                let universe = lazy_universe.unwrap_or_else(|| {\n+                    let universe = nll_delegate.create_next_universe();\n+                    lazy_universe = Some(universe);\n+                    universe\n+                });\n+\n+                let placeholder = ty::PlaceholderRegion { universe, name: br.kind };\n+                debug!(?placeholder);\n+                let placeholder_reg = nll_delegate.next_placeholder_region(placeholder);\n+                debug!(?placeholder_reg);\n+\n+                placeholder_reg\n+            }\n+        };\n+\n+        let delegate = FnMutDelegate {\n+            regions: &mut next_region,\n+            types: &mut |_bound_ty: ty::BoundTy| {\n+                unreachable!(\"we only replace regions in nll_relate, not types\")\n+            },\n+            consts: &mut |_bound_var: ty::BoundVar, _ty| {\n+                unreachable!(\"we only replace regions in nll_relate, not consts\")\n+            },\n+        };\n+\n+        let replaced = self.infcx.tcx.replace_bound_vars_uncached(binder, delegate);\n+        debug!(?replaced);\n+\n+        replaced\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn instantiate_binder_with_existentials<T>(&mut self, binder: ty::Binder<'tcx, T>) -> T\n+    where\n+        T: ty::TypeFoldable<TyCtxt<'tcx>> + Copy,\n+    {\n+        if let Some(inner) = binder.no_bound_vars() {\n+            return inner;\n+        }\n+\n+        let mut next_region = {\n+            let nll_delegate = &mut self.delegate;\n+            let mut reg_map = FxHashMap::default();\n+\n+            move |br: ty::BoundRegion| {\n+                if let Some(ex_reg_var) = reg_map.get(&br) {\n+                    return *ex_reg_var;\n+                } else {\n+                    let ex_reg_var =\n+                        nll_delegate.next_existential_region_var(true, br.kind.get_name());\n+                    debug!(?ex_reg_var);\n+                    reg_map.insert(br, ex_reg_var);\n+\n+                    ex_reg_var\n+                }\n+            }\n+        };\n+\n+        let delegate = FnMutDelegate {\n+            regions: &mut next_region,\n+            types: &mut |_bound_ty: ty::BoundTy| {\n+                unreachable!(\"we only replace regions in nll_relate, not types\")\n+            },\n+            consts: &mut |_bound_var: ty::BoundVar, _ty| {\n+                unreachable!(\"we only replace regions in nll_relate, not consts\")\n+            },\n+        };\n+\n+        let replaced = self.infcx.tcx.replace_bound_vars_uncached(binder, delegate);\n+        debug!(?replaced);\n+\n+        replaced\n+    }\n }\n \n /// When we instantiate an inference variable with a value in\n@@ -396,14 +380,6 @@ trait VidValuePair<'tcx>: Debug {\n     /// opposite part of the tuple from the vid).\n     fn value_ty(&self) -> Ty<'tcx>;\n \n-    /// Extract the scopes that apply to whichever side of the tuple\n-    /// the vid was found on. See the comment where this is called\n-    /// for more details on why we want them.\n-    fn vid_scopes<'r, D: TypeRelatingDelegate<'tcx>>(\n-        &self,\n-        relate: &'r mut TypeRelating<'_, 'tcx, D>,\n-    ) -> &'r mut Vec<BoundRegionScope<'tcx>>;\n-\n     /// Given a generalized type G that should replace the vid, relate\n     /// G to the value, putting G on whichever side the vid would have\n     /// appeared.\n@@ -425,16 +401,6 @@ impl<'tcx> VidValuePair<'tcx> for (ty::TyVid, Ty<'tcx>) {\n         self.1\n     }\n \n-    fn vid_scopes<'r, D>(\n-        &self,\n-        relate: &'r mut TypeRelating<'_, 'tcx, D>,\n-    ) -> &'r mut Vec<BoundRegionScope<'tcx>>\n-    where\n-        D: TypeRelatingDelegate<'tcx>,\n-    {\n-        &mut relate.a_scopes\n-    }\n-\n     fn relate_generalized_ty<D>(\n         &self,\n         relate: &mut TypeRelating<'_, 'tcx, D>,\n@@ -457,16 +423,6 @@ impl<'tcx> VidValuePair<'tcx> for (Ty<'tcx>, ty::TyVid) {\n         self.0\n     }\n \n-    fn vid_scopes<'r, D>(\n-        &self,\n-        relate: &'r mut TypeRelating<'_, 'tcx, D>,\n-    ) -> &'r mut Vec<BoundRegionScope<'tcx>>\n-    where\n-        D: TypeRelatingDelegate<'tcx>,\n-    {\n-        &mut relate.b_scopes\n-    }\n-\n     fn relate_generalized_ty<D>(\n         &self,\n         relate: &mut TypeRelating<'_, 'tcx, D>,\n@@ -602,20 +558,14 @@ where\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(?self.ambient_variance);\n \n-        let v_a = self.replace_bound_region(a, ty::INNERMOST, &self.a_scopes);\n-        let v_b = self.replace_bound_region(b, ty::INNERMOST, &self.b_scopes);\n-\n-        debug!(?v_a);\n-        debug!(?v_b);\n-\n         if self.ambient_covariance() {\n             // Covariant: &'a u8 <: &'b u8. Hence, `'a: 'b`.\n-            self.push_outlives(v_a, v_b, self.ambient_variance_info);\n+            self.push_outlives(a, b, self.ambient_variance_info);\n         }\n \n         if self.ambient_contravariance() {\n             // Contravariant: &'b u8 <: &'a u8. Hence, `'b: 'a`.\n-            self.push_outlives(v_b, v_a, self.ambient_variance_info);\n+            self.push_outlives(b, a, self.ambient_variance_info);\n         }\n \n         Ok(a)\n@@ -689,15 +639,6 @@ where\n             // instantiation of B (i.e., B instantiated with\n             // universals).\n \n-            let b_scope = self.create_scope(b, UniversallyQuantified(true));\n-            let a_scope = self.create_scope(a, UniversallyQuantified(false));\n-\n-            debug!(?a_scope, \"(existential)\");\n-            debug!(?b_scope, \"(universal)\");\n-\n-            self.b_scopes.push(b_scope);\n-            self.a_scopes.push(a_scope);\n-\n             // Reset the ambient variance to covariant. This is needed\n             // to correctly handle cases like\n             //\n@@ -718,12 +659,14 @@ where\n             //   subtyping (i.e., `&'b u32 <: &{P} u32`).\n             let variance = std::mem::replace(&mut self.ambient_variance, ty::Variance::Covariant);\n \n-            self.relate(a.skip_binder(), b.skip_binder())?;\n+            // Note: the order here is important. Create the placeholders first, otherwise\n+            // we assign the wrong universe to the existential!\n+            let b_replaced = self.instantiate_binder_with_placeholders(b);\n+            let a_replaced = self.instantiate_binder_with_existentials(a);\n \n-            self.ambient_variance = variance;\n+            self.relate(a_replaced, b_replaced)?;\n \n-            self.b_scopes.pop().unwrap();\n-            self.a_scopes.pop().unwrap();\n+            self.ambient_variance = variance;\n         }\n \n         if self.ambient_contravariance() {\n@@ -733,26 +676,17 @@ where\n             // instantiation of B (i.e., B instantiated with\n             // existentials). Opposite of above.\n \n-            let a_scope = self.create_scope(a, UniversallyQuantified(true));\n-            let b_scope = self.create_scope(b, UniversallyQuantified(false));\n-\n-            debug!(?a_scope, \"(universal)\");\n-            debug!(?b_scope, \"(existential)\");\n-\n-            self.a_scopes.push(a_scope);\n-            self.b_scopes.push(b_scope);\n-\n             // Reset ambient variance to contravariance. See the\n             // covariant case above for an explanation.\n             let variance =\n                 std::mem::replace(&mut self.ambient_variance, ty::Variance::Contravariant);\n \n-            self.relate(a.skip_binder(), b.skip_binder())?;\n+            let a_replaced = self.instantiate_binder_with_placeholders(a);\n+            let b_replaced = self.instantiate_binder_with_existentials(b);\n \n-            self.ambient_variance = variance;\n+            self.relate(a_replaced, b_replaced)?;\n \n-            self.b_scopes.pop().unwrap();\n-            self.a_scopes.pop().unwrap();\n+            self.ambient_variance = variance;\n         }\n \n         Ok(a)"}, {"sha": "3a0a0494a7ed33dc1c90a59d142b50936fd22e41", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -5,8 +5,8 @@ use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n use hir::def_id::{DefId, LocalDefId};\n use hir::OpaqueTyOrigin;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n@@ -21,7 +21,7 @@ use std::ops::ControlFlow;\n \n mod table;\n \n-pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n+pub type OpaqueTypeMap<'tcx> = FxIndexMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n pub use table::{OpaqueTypeStorage, OpaqueTypeTable};\n \n /// Information about the opaque types whose values we"}, {"sha": "1c58caa03532eaaf5ecf7e3868a02e619d021360", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,3 +1,4 @@\n+use rustc_ast::attr;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n@@ -8,7 +9,7 @@ fn proc_macro_decls_static(tcx: TyCtxt<'_>, (): ()) -> Option<LocalDefId> {\n \n     for id in tcx.hir().items() {\n         let attrs = tcx.hir().attrs(id.hir_id());\n-        if tcx.sess.contains_name(attrs, sym::rustc_proc_macro_decls) {\n+        if attr::contains_name(attrs, sym::rustc_proc_macro_decls) {\n             decls = Some(id.owner_id.def_id);\n         }\n     }"}, {"sha": "8abdcebb7516d373796c4d53471fab75ce75b59b", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -505,7 +505,7 @@ pub fn build_output_filenames(attrs: &[ast::Attribute], sess: &Session) -> Outpu\n                 .opts\n                 .crate_name\n                 .clone()\n-                .or_else(|| rustc_attr::find_crate_name(sess, attrs).map(|n| n.to_string()))\n+                .or_else(|| rustc_attr::find_crate_name(attrs).map(|n| n.to_string()))\n                 .unwrap_or_else(|| sess.io.input.filestem().to_owned());\n \n             OutputFilenames::new("}, {"sha": "29ba480cdd20e4505f3701c5b9342f35096d76f1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -358,29 +358,29 @@ impl EarlyLintPass for UnsafeCode {\n             }\n \n             ast::ItemKind::Fn(..) => {\n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleFn);\n                 }\n \n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::export_name) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameFn);\n                 }\n \n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::link_section) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::LinkSectionFn);\n                 }\n             }\n \n             ast::ItemKind::Static(..) => {\n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleStatic);\n                 }\n \n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::export_name) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameStatic);\n                 }\n \n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::link_section) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::LinkSectionStatic);\n                 }\n             }\n@@ -391,10 +391,10 @@ impl EarlyLintPass for UnsafeCode {\n \n     fn check_impl_item(&mut self, cx: &EarlyContext<'_>, it: &ast::AssocItem) {\n         if let ast::AssocItemKind::Fn(..) = it.kind {\n-            if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+            if let Some(attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                 self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleMethod);\n             }\n-            if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n+            if let Some(attr) = attr::find_by_name(&it.attrs, sym::export_name) {\n                 self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameMethod);\n             }\n         }\n@@ -1123,12 +1123,12 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n         };\n         match it.kind {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n-                if let Some(no_mangle_attr) = cx.sess().find_by_name(attrs, sym::no_mangle) {\n+                if let Some(no_mangle_attr) = attr::find_by_name(attrs, sym::no_mangle) {\n                     check_no_mangle_on_generic_fn(no_mangle_attr, None, generics, it.span);\n                 }\n             }\n             hir::ItemKind::Const(..) => {\n-                if cx.sess().contains_name(attrs, sym::no_mangle) {\n+                if attr::contains_name(attrs, sym::no_mangle) {\n                     // account for \"pub const\" (#45562)\n                     let start = cx\n                         .tcx\n@@ -1152,9 +1152,8 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n             hir::ItemKind::Impl(hir::Impl { generics, items, .. }) => {\n                 for it in *items {\n                     if let hir::AssocItemKind::Fn { .. } = it.kind {\n-                        if let Some(no_mangle_attr) = cx\n-                            .sess()\n-                            .find_by_name(cx.tcx.hir().attrs(it.id.hir_id()), sym::no_mangle)\n+                        if let Some(no_mangle_attr) =\n+                            attr::find_by_name(cx.tcx.hir().attrs(it.id.hir_id()), sym::no_mangle)\n                         {\n                             check_no_mangle_on_generic_fn(\n                                 no_mangle_attr,\n@@ -1836,7 +1835,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n         }\n \n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n-        if let Some(attr) = cx.sess().find_by_name(attrs, sym::rustc_test_marker) {\n+        if let Some(attr) = attr::find_by_name(attrs, sym::rustc_test_marker) {\n             cx.emit_spanned_lint(UNNAMEABLE_TEST_ITEMS, attr.span, BuiltinUnnameableTestItems);\n         }\n     }"}, {"sha": "9efc14849c76fb1fcb004df4b6f4431d8512aa64", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -328,8 +328,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n         let crate_ident = if let Some(name) = &cx.tcx.sess.opts.crate_name {\n             Some(Ident::from_str(name))\n         } else {\n-            cx.sess()\n-                .find_by_name(&cx.tcx.hir().attrs(hir::CRATE_HIR_ID), sym::crate_name)\n+            attr::find_by_name(&cx.tcx.hir().attrs(hir::CRATE_HIR_ID), sym::crate_name)\n                 .and_then(|attr| attr.meta())\n                 .and_then(|meta| {\n                     meta.name_value_literal().and_then(|lit| {\n@@ -489,7 +488,7 @@ impl<'tcx> LateLintPass<'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n         match it.kind {\n-            hir::ItemKind::Static(..) if !cx.sess().contains_name(attrs, sym::no_mangle) => {\n+            hir::ItemKind::Static(..) if !attr::contains_name(attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n             }\n             hir::ItemKind::Const(..) => {"}, {"sha": "23c1aebb8ae38a1af5a40fc87ee59d202b7955c1", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 38, "deletions": 74, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -6,11 +6,11 @@ use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob\n \n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_ast::{self as ast, *};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{MappedReadGuard, MappedWriteGuard, ReadGuard, WriteGuard};\n use rustc_expand::base::SyntaxExtension;\n-use rustc_hir::def_id::{CrateNum, LocalDefId, StableCrateId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, LocalDefId, StableCrateId, StableCrateIdMap, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::TyCtxt;\n@@ -46,9 +46,8 @@ pub struct CStore {\n     /// This crate has a `#[alloc_error_handler]` item.\n     has_alloc_error_handler: bool,\n \n-    /// This map is used to verify we get no hash conflicts between\n-    /// `StableCrateId` values.\n-    pub(crate) stable_crate_ids: FxHashMap<StableCrateId, CrateNum>,\n+    /// The interned [StableCrateId]s.\n+    pub(crate) stable_crate_ids: StableCrateIdMap,\n \n     /// Unused externs of the crate\n     unused_externs: Vec<Symbol>,\n@@ -144,9 +143,21 @@ impl CStore {\n         })\n     }\n \n-    fn alloc_new_crate_num(&mut self) -> CrateNum {\n-        self.metas.push(None);\n-        CrateNum::new(self.metas.len() - 1)\n+    fn intern_stable_crate_id(&mut self, root: &CrateRoot) -> Result<CrateNum, CrateError> {\n+        assert_eq!(self.metas.len(), self.stable_crate_ids.len());\n+        let num = CrateNum::new(self.stable_crate_ids.len());\n+        if let Some(&existing) = self.stable_crate_ids.get(&root.stable_crate_id()) {\n+            let crate_name0 = root.name();\n+            if let Some(crate_name1) = self.metas[existing].as_ref().map(|data| data.name()) {\n+                Err(CrateError::StableCrateIdCollision(crate_name0, crate_name1))\n+            } else {\n+                Err(CrateError::SymbolConflictsCurrent(crate_name0))\n+            }\n+        } else {\n+            self.metas.push(None);\n+            self.stable_crate_ids.insert(root.stable_crate_id(), num);\n+            Ok(num)\n+        }\n     }\n \n     pub fn has_crate_data(&self, cnum: CrateNum) -> bool {\n@@ -247,7 +258,7 @@ impl CStore {\n     }\n \n     pub fn new(sess: &Session) -> CStore {\n-        let mut stable_crate_ids = FxHashMap::default();\n+        let mut stable_crate_ids = StableCrateIdMap::default();\n         stable_crate_ids.insert(sess.local_stable_crate_id(), LOCAL_CRATE);\n         CStore {\n             // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n@@ -342,42 +353,6 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         None\n     }\n \n-    fn verify_no_symbol_conflicts(&self, root: &CrateRoot) -> Result<(), CrateError> {\n-        // Check for (potential) conflicts with the local crate\n-        if self.sess.local_stable_crate_id() == root.stable_crate_id() {\n-            return Err(CrateError::SymbolConflictsCurrent(root.name()));\n-        }\n-\n-        // Check for conflicts with any crate loaded so far\n-        for (_, other) in self.cstore.iter_crate_data() {\n-            // Same stable crate id but different SVH\n-            if other.stable_crate_id() == root.stable_crate_id() && other.hash() != root.hash() {\n-                bug!(\n-                    \"Previously returned E0523 here. \\\n-                     See https://github.com/rust-lang/rust/pull/100599 for additional discussion.\\\n-                     root.name() = {}.\",\n-                    root.name()\n-                );\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn verify_no_stable_crate_id_hash_conflicts(\n-        &mut self,\n-        root: &CrateRoot,\n-        cnum: CrateNum,\n-    ) -> Result<(), CrateError> {\n-        if let Some(existing) = self.cstore.stable_crate_ids.insert(root.stable_crate_id(), cnum) {\n-            let crate_name0 = root.name();\n-            let crate_name1 = self.cstore.get_crate_data(existing).name();\n-            return Err(CrateError::StableCrateIdCollision(crate_name0, crate_name1));\n-        }\n-\n-        Ok(())\n-    }\n-\n     fn register_crate(\n         &mut self,\n         host_lib: Option<Library>,\n@@ -396,7 +371,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n             self.sess.opts.externs.get(name.as_str()).map_or(false, |e| e.is_private_dep);\n \n         // Claim this crate number and cache it\n-        let cnum = self.cstore.alloc_new_crate_num();\n+        let cnum = self.cstore.intern_stable_crate_id(&crate_root)?;\n \n         info!(\n             \"register crate `{}` (cnum = {}. private_dep = {})\",\n@@ -432,14 +407,6 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n             None\n         };\n \n-        // Perform some verification *after* resolve_crate_deps() above is\n-        // known to have been successful. It seems that - in error cases - the\n-        // cstore can be in a temporarily invalid state between cnum allocation\n-        // and dependency resolution and the verification code would produce\n-        // ICEs in that case (see #83045).\n-        self.verify_no_symbol_conflicts(&crate_root)?;\n-        self.verify_no_stable_crate_id_hash_conflicts(&crate_root, cnum)?;\n-\n         let crate_metadata = CrateMetadata::new(\n             self.sess,\n             &self.cstore,\n@@ -720,8 +687,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         // compilation mode also comes into play.\n         let desired_strategy = self.sess.panic_strategy();\n         let mut runtime_found = false;\n-        let mut needs_panic_runtime =\n-            self.sess.contains_name(&krate.attrs, sym::needs_panic_runtime);\n+        let mut needs_panic_runtime = attr::contains_name(&krate.attrs, sym::needs_panic_runtime);\n \n         for (cnum, data) in self.cstore.iter_crate_data() {\n             needs_panic_runtime = needs_panic_runtime || data.needs_panic_runtime();\n@@ -789,7 +755,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         info!(\"loading profiler\");\n \n         let name = Symbol::intern(&self.sess.opts.unstable_opts.profiler_runtime);\n-        if name == sym::profiler_builtins && self.sess.contains_name(&krate.attrs, sym::no_core) {\n+        if name == sym::profiler_builtins && attr::contains_name(&krate.attrs, sym::no_core) {\n             self.sess.emit_err(errors::ProfilerBuiltinsNeedsCore);\n         }\n \n@@ -803,14 +769,14 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n-        self.cstore.has_global_allocator = match &*global_allocator_spans(&self.sess, krate) {\n+        self.cstore.has_global_allocator = match &*global_allocator_spans(krate) {\n             [span1, span2, ..] => {\n                 self.sess.emit_err(errors::NoMultipleGlobalAlloc { span2: *span2, span1: *span1 });\n                 true\n             }\n             spans => !spans.is_empty(),\n         };\n-        self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(&self.sess, krate) {\n+        self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(krate) {\n             [span1, span2, ..] => {\n                 self.sess\n                     .emit_err(errors::NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });\n@@ -822,7 +788,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         // Check to see if we actually need an allocator. This desire comes\n         // about through the `#![needs_allocator]` attribute and is typically\n         // written down in liballoc.\n-        if !self.sess.contains_name(&krate.attrs, sym::needs_allocator)\n+        if !attr::contains_name(&krate.attrs, sym::needs_allocator)\n             && !self.cstore.iter_crate_data().any(|(_, data)| data.needs_allocator())\n         {\n             return;\n@@ -881,7 +847,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n             // allocator. At this point our allocator request is typically fulfilled\n             // by the standard library, denoted by the `#![default_lib_allocator]`\n             // attribute.\n-            if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n+            if !attr::contains_name(&krate.attrs, sym::default_lib_allocator)\n                 && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n             {\n                 self.sess.emit_err(errors::GlobalAllocRequired);\n@@ -1003,7 +969,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n                     }\n                     None => item.ident.name,\n                 };\n-                let dep_kind = if self.sess.contains_name(&item.attrs, sym::no_link) {\n+                let dep_kind = if attr::contains_name(&item.attrs, sym::no_link) {\n                     CrateDepKind::MacrosOnly\n                 } else {\n                     CrateDepKind::Explicit\n@@ -1049,16 +1015,15 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n     }\n }\n \n-fn global_allocator_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n-    struct Finder<'a> {\n-        sess: &'a Session,\n+fn global_allocator_spans(krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder {\n         name: Symbol,\n         spans: Vec<Span>,\n     }\n-    impl<'ast, 'a> visit::Visitor<'ast> for Finder<'a> {\n+    impl<'ast> visit::Visitor<'ast> for Finder {\n         fn visit_item(&mut self, item: &'ast ast::Item) {\n             if item.ident.name == self.name\n-                && self.sess.contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n+                && attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n             {\n                 self.spans.push(item.span);\n             }\n@@ -1067,21 +1032,20 @@ fn global_allocator_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n     }\n \n     let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::alloc));\n-    let mut f = Finder { sess, name, spans: Vec::new() };\n+    let mut f = Finder { name, spans: Vec::new() };\n     visit::walk_crate(&mut f, krate);\n     f.spans\n }\n \n-fn alloc_error_handler_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n-    struct Finder<'a> {\n-        sess: &'a Session,\n+fn alloc_error_handler_spans(krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder {\n         name: Symbol,\n         spans: Vec<Span>,\n     }\n-    impl<'ast, 'a> visit::Visitor<'ast> for Finder<'a> {\n+    impl<'ast> visit::Visitor<'ast> for Finder {\n         fn visit_item(&mut self, item: &'ast ast::Item) {\n             if item.ident.name == self.name\n-                && self.sess.contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n+                && attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n             {\n                 self.spans.push(item.span);\n             }\n@@ -1090,7 +1054,7 @@ fn alloc_error_handler_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n     }\n \n     let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::oom));\n-    let mut f = Finder { sess, name, spans: Vec::new() };\n+    let mut f = Finder { name, spans: Vec::new() };\n     visit::walk_crate(&mut f, krate);\n     f.spans\n }"}, {"sha": "cabc144077fd518987c2f14ff6cf06c2ff8fc825", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1709,10 +1709,6 @@ impl CrateMetadata {\n         self.root.name\n     }\n \n-    pub(crate) fn stable_crate_id(&self) -> StableCrateId {\n-        self.root.stable_crate_id\n-    }\n-\n     pub(crate) fn hash(&self) -> Svh {\n         self.root.hash\n     }"}, {"sha": "caff01498d91aaf14dcdcbc264c5dbf5952090e2", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -595,7 +595,10 @@ impl CrateStore for CStore {\n     }\n \n     fn stable_crate_id_to_crate_num(&self, stable_crate_id: StableCrateId) -> CrateNum {\n-        self.stable_crate_ids[&stable_crate_id]\n+        *self\n+            .stable_crate_ids\n+            .get(&stable_crate_id)\n+            .unwrap_or_else(|| bug!(\"uninterned StableCrateId: {stable_crate_id:?}\"))\n     }\n \n     /// Returns the `DefKey` for a given `DefId`. This indicates the"}, {"sha": "0b438d1ffad812d5cc956de19a31e42ad2ff2630", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -681,17 +681,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 has_global_allocator: tcx.has_global_allocator(LOCAL_CRATE),\n                 has_alloc_error_handler: tcx.has_alloc_error_handler(LOCAL_CRATE),\n                 has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n-                has_default_lib_allocator: tcx\n-                    .sess\n-                    .contains_name(&attrs, sym::default_lib_allocator),\n+                has_default_lib_allocator: attr::contains_name(&attrs, sym::default_lib_allocator),\n                 proc_macro_data,\n                 debugger_visualizers,\n-                compiler_builtins: tcx.sess.contains_name(&attrs, sym::compiler_builtins),\n-                needs_allocator: tcx.sess.contains_name(&attrs, sym::needs_allocator),\n-                needs_panic_runtime: tcx.sess.contains_name(&attrs, sym::needs_panic_runtime),\n-                no_builtins: tcx.sess.contains_name(&attrs, sym::no_builtins),\n-                panic_runtime: tcx.sess.contains_name(&attrs, sym::panic_runtime),\n-                profiler_runtime: tcx.sess.contains_name(&attrs, sym::profiler_runtime),\n+                compiler_builtins: attr::contains_name(&attrs, sym::compiler_builtins),\n+                needs_allocator: attr::contains_name(&attrs, sym::needs_allocator),\n+                needs_panic_runtime: attr::contains_name(&attrs, sym::needs_panic_runtime),\n+                no_builtins: attr::contains_name(&attrs, sym::no_builtins),\n+                panic_runtime: attr::contains_name(&attrs, sym::panic_runtime),\n+                profiler_runtime: attr::contains_name(&attrs, sym::profiler_runtime),\n                 symbol_mangling_version: tcx.sess.opts.get_symbol_mangling_version(),\n \n                 crate_deps,\n@@ -1016,7 +1014,6 @@ fn should_encode_type(tcx: TyCtxt<'_>, def_id: LocalDefId, def_kind: DefKind) ->\n         | DefKind::Const\n         | DefKind::Static(..)\n         | DefKind::TyAlias\n-        | DefKind::OpaqueTy\n         | DefKind::ForeignTy\n         | DefKind::Impl { .. }\n         | DefKind::AssocFn\n@@ -1027,6 +1024,18 @@ fn should_encode_type(tcx: TyCtxt<'_>, def_id: LocalDefId, def_kind: DefKind) ->\n         | DefKind::AnonConst\n         | DefKind::InlineConst => true,\n \n+        DefKind::OpaqueTy => {\n+            let opaque = tcx.hir().expect_item(def_id).expect_opaque_ty();\n+            if let hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id) = opaque.origin\n+                && let hir::Node::TraitItem(trait_item) = tcx.hir().get_by_def_id(fn_def_id)\n+                && let (_, hir::TraitFn::Required(..)) = trait_item.expect_fn()\n+            {\n+                false\n+            } else {\n+                true\n+            }\n+        }\n+\n         DefKind::ImplTraitPlaceholder => {\n             let parent_def_id = tcx.impl_trait_in_trait_parent_fn(def_id.to_def_id());\n             let assoc_item = tcx.associated_item(parent_def_id);\n@@ -1044,7 +1053,13 @@ fn should_encode_type(tcx: TyCtxt<'_>, def_id: LocalDefId, def_kind: DefKind) ->\n             let assoc_item = tcx.associated_item(def_id);\n             match assoc_item.container {\n                 ty::AssocItemContainer::ImplContainer => true,\n-                ty::AssocItemContainer::TraitContainer => assoc_item.defaultness(tcx).has_value(),\n+                // FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty) always encode RPITITs,\n+                // since we need to be able to \"project\" from an RPITIT associated item\n+                // to an opaque when installing the default projection predicates in\n+                // default trait methods with RPITITs.\n+                ty::AssocItemContainer::TraitContainer => {\n+                    assoc_item.defaultness(tcx).has_value() || assoc_item.opt_rpitit_info.is_some()\n+                }\n             }\n         }\n         DefKind::TyParam => {\n@@ -1730,11 +1745,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 // Proc-macros may have attributes like `#[allow_internal_unstable]`,\n                 // so downstream crates need access to them.\n                 let attrs = hir.attrs(proc_macro);\n-                let macro_kind = if tcx.sess.contains_name(attrs, sym::proc_macro) {\n+                let macro_kind = if attr::contains_name(attrs, sym::proc_macro) {\n                     MacroKind::Bang\n-                } else if tcx.sess.contains_name(attrs, sym::proc_macro_attribute) {\n+                } else if attr::contains_name(attrs, sym::proc_macro_attribute) {\n                     MacroKind::Attr\n-                } else if let Some(attr) = tcx.sess.find_by_name(attrs, sym::proc_macro_derive) {\n+                } else if let Some(attr) = attr::find_by_name(attrs, sym::proc_macro_derive) {\n                     // This unwrap chain should have been checked by the proc-macro harness.\n                     name = attr.meta_item_list().unwrap()[0]\n                         .meta_item()"}, {"sha": "89a485b47ca8c03318187d27258db4a486eb3304", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -188,7 +188,7 @@ impl<'hir> Map<'hir> {\n                 ItemKind::Macro(_, macro_kind) => DefKind::Macro(macro_kind),\n                 ItemKind::Mod(..) => DefKind::Mod,\n                 ItemKind::OpaqueTy(ref opaque) => {\n-                    if opaque.in_trait {\n+                    if opaque.in_trait && !self.tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n                         DefKind::ImplTraitPlaceholder\n                     } else {\n                         DefKind::OpaqueTy"}, {"sha": "786c2e9cd943e426cbc1a9e789b4730360fb9f1a", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -2,8 +2,8 @@\n \n use crate::mir::{Body, ConstantKind, Promoted};\n use crate::ty::{self, OpaqueHiddenType, Ty, TyCtxt};\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::unord::UnordSet;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -227,7 +227,7 @@ pub struct BorrowCheckResult<'tcx> {\n     /// All the opaque types that are restricted to concrete types\n     /// by this function. Unlike the value in `TypeckResults`, this has\n     /// unerased regions.\n-    pub concrete_opaque_types: VecMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n+    pub concrete_opaque_types: FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n     pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n     pub tainted_by_errors: Option<ErrorGuaranteed>,"}, {"sha": "512d67f34b97d6f49ca13468cc37a9895c15e16d", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -63,15 +63,14 @@ impl Certainty {\n             (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n             (Certainty::Yes, Certainty::Maybe(_)) => other,\n             (Certainty::Maybe(_), Certainty::Yes) => self,\n-            (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n-                Certainty::Maybe(MaybeCause::Overflow)\n-            }\n-            // If at least one of the goals is ambiguous, hide the overflow as the ambiguous goal\n-            // may still result in failure.\n-            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(_))\n-            | (Certainty::Maybe(_), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n+            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n                 Certainty::Maybe(MaybeCause::Ambiguity)\n             }\n+            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(MaybeCause::Overflow))\n+            | (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Ambiguity))\n+            | (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n+                Certainty::Maybe(MaybeCause::Overflow)\n+            }\n         }\n     }\n }"}, {"sha": "a1c1acc4a25414754a010d900f31dade4af3b851", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -28,7 +28,7 @@ use crate::ty::{\n     TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, TypeckResults, UintTy, Visibility,\n };\n use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::intern::Interned;\n@@ -2520,9 +2520,9 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     providers.extern_mod_stmt_cnum =\n         |tcx, id| tcx.resolutions(()).extern_crate_map.get(&id).cloned();\n     providers.is_panic_runtime =\n-        |tcx, LocalCrate| tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::panic_runtime);\n+        |tcx, LocalCrate| attr::contains_name(tcx.hir().krate_attrs(), sym::panic_runtime);\n     providers.is_compiler_builtins =\n-        |tcx, LocalCrate| tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins);\n+        |tcx, LocalCrate| attr::contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins);\n     providers.has_panic_handler = |tcx, LocalCrate| {\n         // We want to check if the panic handler was defined in this crate\n         tcx.lang_items().panic_impl().map_or(false, |did| did.is_local())"}, {"sha": "9b0c6e25d16b4903baaf7dde4f5bcafef8a60c7c", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -2525,7 +2525,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         ident\n     }\n \n-    // FIXME(vincenzoapalzzo): move the HirId to a LocalDefId\n+    // FIXME(vincenzopalazzo): move the HirId to a LocalDefId\n     pub fn adjust_ident_and_get_scope(\n         self,\n         mut ident: Ident,"}, {"sha": "35a581d314cd471ce76a21715f409083a53c1287", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1925,11 +1925,6 @@ impl<'tcx> Ty<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    pub fn is_region_ptr(self) -> bool {\n-        matches!(self.kind(), Ref(..))\n-    }\n-\n     #[inline]\n     pub fn is_mutable_ptr(self) -> bool {\n         matches!(\n@@ -1956,7 +1951,7 @@ impl<'tcx> Ty<'tcx> {\n     /// Tests if this is any kind of primitive pointer type (reference, raw pointer, fn pointer).\n     #[inline]\n     pub fn is_any_ptr(self) -> bool {\n-        self.is_region_ptr() || self.is_unsafe_ptr() || self.is_fn_ptr()\n+        self.is_ref() || self.is_unsafe_ptr() || self.is_fn_ptr()\n     }\n \n     #[inline]"}, {"sha": "2b0fb4dc2b7d6ce90488f69486545bbc45642b3a", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -8,10 +8,9 @@ use crate::{\n     },\n };\n use rustc_data_structures::{\n-    fx::FxHashMap,\n+    fx::{FxHashMap, FxIndexMap},\n     sync::Lrc,\n     unord::{UnordItems, UnordSet},\n-    vec_map::VecMap,\n };\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n@@ -155,7 +154,7 @@ pub struct TypeckResults<'tcx> {\n     /// by this function. We also store the\n     /// type here, so that mir-borrowck can use it as a hint for figuring out hidden types,\n     /// even if they are only set in dead code (which doesn't show up in MIR).\n-    pub concrete_opaque_types: VecMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n+    pub concrete_opaque_types: FxIndexMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details."}, {"sha": "1923e10ddb5865afd09dbe85ce2be51b604aee83", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -3,6 +3,7 @@ use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n+use rustc_ast::attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n use rustc_errors::ErrorGuaranteed;\n@@ -680,7 +681,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are codegened in.\n-        let mut check_overflow = tcx.sess.contains_name(attrs, sym::rustc_inherit_overflow_checks);\n+        let mut check_overflow = attr::contains_name(attrs, sym::rustc_inherit_overflow_checks);\n         // Respect -C overflow-checks.\n         check_overflow |= tcx.sess.overflow_checks();\n         // Constants always need overflow checks."}, {"sha": "6fd9b9dbb5755f106e54cf42f4ac249e3fb159fd", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -185,7 +185,7 @@ impl<'tcx> Cx<'tcx> {\n         if self.typeck_results().is_coercion_cast(source.hir_id) {\n             // Convert the lexpr to a vexpr.\n             ExprKind::Use { source: self.mirror_expr(source) }\n-        } else if self.typeck_results().expr_ty(source).is_region_ptr() {\n+        } else if self.typeck_results().expr_ty(source).is_ref() {\n             // Special cased so that we can type check that the element\n             // type of the source matches the pointed to type of the\n             // destination."}, {"sha": "8b81abb23b0aa87c143b77a36e11dac6ade6bb09", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -180,7 +180,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     }\n \n     #[inline(always)]\n-    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>, _layout: TyAndLayout<'tcx>) -> bool {\n         false // for now, we don't enforce validity\n     }\n     fn alignment_check_failed("}, {"sha": "a7218a4f2500d97b91792b6a19facbc446943257", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -8,6 +8,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::DefKind;\n use rustc_middle::mir::visit::{MutVisitor, Visitor};\n use rustc_middle::mir::*;\n+use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_mir_dataflow::value_analysis::{Map, State, TrackElem, ValueAnalysis, ValueOrPlace};\n use rustc_mir_dataflow::{lattice::FlatSet, Analysis, ResultsVisitor, SwitchIntEdgeEffects};\n@@ -548,7 +549,7 @@ impl<'mir, 'tcx> rustc_const_eval::interpret::Machine<'mir, 'tcx> for DummyMachi\n         unimplemented!()\n     }\n \n-    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>, _layout: TyAndLayout<'tcx>) -> bool {\n         unimplemented!()\n     }\n     fn alignment_check_failed("}, {"sha": "46eab1184bdad1d45254cd74376ec085506e6f4f", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n+use rustc_target::abi::VariantIdx;\n \n pub struct LowerIntrinsics;\n \n@@ -191,6 +192,35 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                             terminator.kind = TerminatorKind::Goto { target };\n                         }\n                     }\n+                    sym::option_payload_ptr => {\n+                        if let (Some(target), Some(arg)) = (*target, args[0].place()) {\n+                            let ty::RawPtr(ty::TypeAndMut { ty: dest_ty, .. }) =\n+                                destination.ty(local_decls, tcx).ty.kind()\n+                            else { bug!(); };\n+\n+                            block.statements.push(Statement {\n+                                source_info: terminator.source_info,\n+                                kind: StatementKind::Assign(Box::new((\n+                                    *destination,\n+                                    Rvalue::AddressOf(\n+                                        Mutability::Not,\n+                                        arg.project_deeper(\n+                                            &[\n+                                                PlaceElem::Deref,\n+                                                PlaceElem::Downcast(\n+                                                    Some(sym::Some),\n+                                                    VariantIdx::from_u32(1),\n+                                                ),\n+                                                PlaceElem::Field(Field::from_u32(0), *dest_ty),\n+                                            ],\n+                                            tcx,\n+                                        ),\n+                                    ),\n+                                ))),\n+                            });\n+                            terminator.kind = TerminatorKind::Goto { target };\n+                        }\n+                    }\n                     _ if intrinsic_name.as_str().starts_with(\"simd_shuffle\") => {\n                         validate_simd_shuffle(tcx, args, terminator.source_info.span);\n                     }"}, {"sha": "96765c296e79bdc0b266710380853c5b4c103d1c", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -336,7 +336,7 @@ parse_expected_identifier_found_reserved_keyword = expected identifier, found re\n parse_expected_identifier_found_doc_comment = expected identifier, found doc comment\n parse_expected_identifier = expected identifier\n \n-parse_sugg_escape_to_use_as_identifier = escape `{$ident_name}` to use it as an identifier\n+parse_sugg_escape_identifier = escape `{$ident_name}` to use it as an identifier\n \n parse_sugg_remove_comma = remove this comma\n "}, {"sha": "a9d116012ae5bf680dfb337568739e436342fc0e", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -888,12 +888,12 @@ pub(crate) struct InvalidMetaItem {\n \n #[derive(Subdiagnostic)]\n #[suggestion(\n-    parse_sugg_escape_to_use_as_identifier,\n+    parse_sugg_escape_identifier,\n     style = \"verbose\",\n     applicability = \"maybe-incorrect\",\n     code = \"r#\"\n )]\n-pub(crate) struct SuggEscapeToUseAsIdentifier {\n+pub(crate) struct SuggEscapeIdentifier {\n     #[primary_span]\n     pub span: Span,\n     pub ident_name: String,\n@@ -937,7 +937,7 @@ impl ExpectedIdentifierFound {\n pub(crate) struct ExpectedIdentifier {\n     pub span: Span,\n     pub token: Token,\n-    pub suggest_raw: Option<SuggEscapeToUseAsIdentifier>,\n+    pub suggest_raw: Option<SuggEscapeIdentifier>,\n     pub suggest_remove_comma: Option<SuggRemoveComma>,\n     pub help_cannot_start_number: Option<HelpIdentifierStartsWithNumber>,\n }\n@@ -986,7 +986,10 @@ impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedIdentifier {\n \n #[derive(Subdiagnostic)]\n #[help(parse_invalid_identifier_with_leading_number)]\n-pub(crate) struct HelpIdentifierStartsWithNumber;\n+pub(crate) struct HelpIdentifierStartsWithNumber {\n+    #[primary_span]\n+    pub num_span: Span,\n+}\n \n pub(crate) struct ExpectedSemi {\n     pub span: Span,"}, {"sha": "9544afd3d6df941e23e8c52f6671de6b2bec7cca", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 89, "deletions": 34, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -6,14 +6,14 @@ use super::{\n use crate::errors::{\n     AmbiguousPlus, AttributeOnParamType, BadQPathStage2, BadTypePlus, BadTypePlusSub,\n     ComparisonOperatorsCannotBeChained, ComparisonOperatorsCannotBeChainedSugg,\n-    ConstGenericWithoutBraces, ConstGenericWithoutBracesSugg, DocCommentOnParamType,\n-    DoubleColonInBound, ExpectedIdentifier, ExpectedSemi, ExpectedSemiSugg,\n+    ConstGenericWithoutBraces, ConstGenericWithoutBracesSugg, DocCommentDoesNotDocumentAnything,\n+    DocCommentOnParamType, DoubleColonInBound, ExpectedIdentifier, ExpectedSemi, ExpectedSemiSugg,\n     GenericParamsWithoutAngleBrackets, GenericParamsWithoutAngleBracketsSugg,\n     HelpIdentifierStartsWithNumber, InInTypo, IncorrectAwait, IncorrectSemicolon,\n     IncorrectUseOfAwait, ParenthesesInForHead, ParenthesesInForHeadSugg,\n     PatternMethodParamWithoutBody, QuestionMarkInType, QuestionMarkInTypeSugg, SelfParamNotFirst,\n     StructLiteralBodyWithoutPath, StructLiteralBodyWithoutPathSugg, StructLiteralNeedingParens,\n-    StructLiteralNeedingParensSugg, SuggEscapeToUseAsIdentifier, SuggRemoveComma,\n+    StructLiteralNeedingParensSugg, SuggEscapeIdentifier, SuggRemoveComma,\n     UnexpectedConstInGenericParam, UnexpectedConstParamDeclaration,\n     UnexpectedConstParamDeclarationSugg, UnmatchedAngleBrackets, UseEqInstead,\n };\n@@ -38,7 +38,7 @@ use rustc_errors::{\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{Span, SpanSnippetError, DUMMY_SP};\n+use rustc_span::{Span, SpanSnippetError, Symbol, DUMMY_SP};\n use std::mem::take;\n use std::ops::{Deref, DerefMut};\n use thin_vec::{thin_vec, ThinVec};\n@@ -268,7 +268,21 @@ impl<'a> Parser<'a> {\n         self.sess.source_map().span_to_snippet(span)\n     }\n \n-    pub(super) fn expected_ident_found(&mut self) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+    /// Emits an error with suggestions if an identifier was expected but not found.\n+    ///\n+    /// Returns a possibly recovered identifier.\n+    pub(super) fn expected_ident_found(\n+        &mut self,\n+        recover: bool,\n+    ) -> PResult<'a, (Ident, /* is_raw */ bool)> {\n+        if let TokenKind::DocComment(..) = self.prev_token.kind {\n+            return Err(DocCommentDoesNotDocumentAnything {\n+                span: self.prev_token.span,\n+                missing_comma: None,\n+            }\n+            .into_diagnostic(&self.sess.span_diagnostic));\n+        }\n+\n         let valid_follow = &[\n             TokenKind::Eq,\n             TokenKind::Colon,\n@@ -281,31 +295,51 @@ impl<'a> Parser<'a> {\n             TokenKind::CloseDelim(Delimiter::Parenthesis),\n         ];\n \n-        let suggest_raw = match self.token.ident() {\n-            Some((ident, false))\n-                if ident.is_raw_guess()\n-                    && self.look_ahead(1, |t| valid_follow.contains(&t.kind)) =>\n-            {\n-                Some(SuggEscapeToUseAsIdentifier {\n-                    span: ident.span.shrink_to_lo(),\n-                    // `Symbol::to_string()` is different from `Symbol::into_diagnostic_arg()`,\n-                    // which uses `Symbol::to_ident_string()` and \"helpfully\" adds an implicit `r#`\n-                    ident_name: ident.name.to_string(),\n-                })\n-            }\n-            _ => None,\n-        };\n+        let mut recovered_ident = None;\n+        // we take this here so that the correct original token is retained in\n+        // the diagnostic, regardless of eager recovery.\n+        let bad_token = self.token.clone();\n+\n+        // suggest prepending a keyword in identifier position with `r#`\n+        let suggest_raw = if let Some((ident, false)) = self.token.ident()\n+            && ident.is_raw_guess()\n+            && self.look_ahead(1, |t| valid_follow.contains(&t.kind))\n+        {\n+            recovered_ident = Some((ident, true));\n+\n+            // `Symbol::to_string()` is different from `Symbol::into_diagnostic_arg()`,\n+            // which uses `Symbol::to_ident_string()` and \"helpfully\" adds an implicit `r#`\n+            let ident_name = ident.name.to_string();\n+\n+            Some(SuggEscapeIdentifier {\n+                span: ident.span.shrink_to_lo(),\n+                ident_name\n+            })\n+        } else { None };\n+\n+        let suggest_remove_comma =\n+            if self.token == token::Comma && self.look_ahead(1, |t| t.is_ident()) {\n+                if recover {\n+                    self.bump();\n+                    recovered_ident = self.ident_or_err(false).ok();\n+                };\n \n-        let suggest_remove_comma = (self.token == token::Comma\n-            && self.look_ahead(1, |t| t.is_ident()))\n-        .then_some(SuggRemoveComma { span: self.token.span });\n+                Some(SuggRemoveComma { span: bad_token.span })\n+            } else {\n+                None\n+            };\n \n-        let help_cannot_start_number =\n-            self.is_lit_bad_ident().then_some(HelpIdentifierStartsWithNumber);\n+        let help_cannot_start_number = self.is_lit_bad_ident().map(|(len, valid_portion)| {\n+            let (invalid, valid) = self.token.span.split_at(len as u32);\n+\n+            recovered_ident = Some((Ident::new(valid_portion, valid), false));\n+\n+            HelpIdentifierStartsWithNumber { num_span: invalid }\n+        });\n \n         let err = ExpectedIdentifier {\n-            span: self.token.span,\n-            token: self.token.clone(),\n+            span: bad_token.span,\n+            token: bad_token,\n             suggest_raw,\n             suggest_remove_comma,\n             help_cannot_start_number,\n@@ -314,6 +348,7 @@ impl<'a> Parser<'a> {\n \n         // if the token we have is a `<`\n         // it *might* be a misplaced generic\n+        // FIXME: could we recover with this?\n         if self.token == token::Lt {\n             // all keywords that could have generic applied\n             let valid_prev_keywords =\n@@ -364,18 +399,38 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        err\n+        if let Some(recovered_ident) = recovered_ident && recover {\n+            err.emit();\n+            Ok(recovered_ident)\n+        } else {\n+            Err(err)\n+        }\n+    }\n+\n+    pub(super) fn expected_ident_found_err(&mut self) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        self.expected_ident_found(false).unwrap_err()\n     }\n \n     /// Checks if the current token is a integer or float literal and looks like\n     /// it could be a invalid identifier with digits at the start.\n-    pub(super) fn is_lit_bad_ident(&mut self) -> bool {\n-        matches!(self.token.uninterpolate().kind, token::Literal(Lit { kind: token::LitKind::Integer | token::LitKind::Float, .. })\n-            // ensure that the integer literal is followed by a *invalid*\n-            // suffix: this is how we know that it is a identifier with an\n-            // invalid beginning.\n-            if rustc_ast::MetaItemLit::from_token(&self.token).is_none()\n-        )\n+    ///\n+    /// Returns the number of characters (bytes) composing the invalid portion\n+    /// of the identifier and the valid portion of the identifier.\n+    pub(super) fn is_lit_bad_ident(&mut self) -> Option<(usize, Symbol)> {\n+        // ensure that the integer literal is followed by a *invalid*\n+        // suffix: this is how we know that it is a identifier with an\n+        // invalid beginning.\n+        if let token::Literal(Lit {\n+            kind: token::LitKind::Integer | token::LitKind::Float,\n+            symbol,\n+            suffix,\n+        }) = self.token.kind\n+            && rustc_ast::MetaItemLit::from_token(&self.token).is_none()\n+        {\n+            Some((symbol.as_str().len(), suffix.unwrap()))\n+        } else {\n+            None\n+        }\n     }\n \n     pub(super) fn expected_one_of_not_found("}, {"sha": "ae8fe90e9d6116bddbc9328bdf8b0194fd3c1c94", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1181,7 +1181,7 @@ impl<'a> Parser<'a> {\n         defaultness: Defaultness,\n     ) -> PResult<'a, ItemInfo> {\n         let impl_span = self.token.span;\n-        let mut err = self.expected_ident_found();\n+        let mut err = self.expected_ident_found_err();\n \n         // Only try to recover if this is implementing a trait for a type\n         let mut impl_info = match self.parse_item_impl(attrs, defaultness) {\n@@ -1744,7 +1744,7 @@ impl<'a> Parser<'a> {\n     /// Parses a field identifier. Specialized version of `parse_ident_common`\n     /// for better diagnostics and suggestions.\n     fn parse_field_ident(&mut self, adt_ty: &str, lo: Span) -> PResult<'a, Ident> {\n-        let (ident, is_raw) = self.ident_or_err()?;\n+        let (ident, is_raw) = self.ident_or_err(true)?;\n         if !is_raw && ident.is_reserved() {\n             let snapshot = self.create_snapshot_for_diagnostic();\n             let err = if self.check_fn_front_matter(false, Case::Sensitive) {\n@@ -1776,7 +1776,7 @@ impl<'a> Parser<'a> {\n                     Err(err) => {\n                         err.cancel();\n                         self.restore_snapshot(snapshot);\n-                        self.expected_ident_found()\n+                        self.expected_ident_found_err()\n                     }\n                 }\n             } else if self.eat_keyword(kw::Struct) {\n@@ -1792,11 +1792,11 @@ impl<'a> Parser<'a> {\n                     Err(err) => {\n                         err.cancel();\n                         self.restore_snapshot(snapshot);\n-                        self.expected_ident_found()\n+                        self.expected_ident_found_err()\n                     }\n                 }\n             } else {\n-                let mut err = self.expected_ident_found();\n+                let mut err = self.expected_ident_found_err();\n                 if self.eat_keyword_noexpect(kw::Let)\n                     && let removal_span = self.prev_token.span.until(self.token.span)\n                     && let Ok(ident) = self.parse_ident_common(false)"}, {"sha": "53c25a80c4bf32752ce306607e3577ac8fd22b6a", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -42,8 +42,7 @@ use thin_vec::ThinVec;\n use tracing::debug;\n \n use crate::errors::{\n-    DocCommentDoesNotDocumentAnything, IncorrectVisibilityRestriction, MismatchedClosingDelimiter,\n-    NonStringAbiLiteral,\n+    IncorrectVisibilityRestriction, MismatchedClosingDelimiter, NonStringAbiLiteral,\n };\n \n bitflags::bitflags! {\n@@ -552,21 +551,11 @@ impl<'a> Parser<'a> {\n         self.parse_ident_common(true)\n     }\n \n-    fn ident_or_err(&mut self) -> PResult<'a, (Ident, /* is_raw */ bool)> {\n-        self.token.ident().ok_or_else(|| match self.prev_token.kind {\n-            TokenKind::DocComment(..) => DocCommentDoesNotDocumentAnything {\n-                span: self.prev_token.span,\n-                missing_comma: None,\n-            }\n-            .into_diagnostic(&self.sess.span_diagnostic),\n-            _ => self.expected_ident_found(),\n-        })\n-    }\n-\n     fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, Ident> {\n-        let (ident, is_raw) = self.ident_or_err()?;\n+        let (ident, is_raw) = self.ident_or_err(recover)?;\n+\n         if !is_raw && ident.is_reserved() {\n-            let mut err = self.expected_ident_found();\n+            let mut err = self.expected_ident_found_err();\n             if recover {\n                 err.emit();\n             } else {\n@@ -577,6 +566,21 @@ impl<'a> Parser<'a> {\n         Ok(ident)\n     }\n \n+    fn ident_or_err(&mut self, recover: bool) -> PResult<'a, (Ident, /* is_raw */ bool)> {\n+        let result = self.token.ident().ok_or_else(|| self.expected_ident_found(recover));\n+\n+        let (ident, is_raw) = match result {\n+            Ok(ident) => ident,\n+            Err(err) => match err {\n+                // we recovered!\n+                Ok(ident) => ident,\n+                Err(err) => return Err(err),\n+            },\n+        };\n+\n+        Ok((ident, is_raw))\n+    }\n+\n     /// Checks if the next token is `tok`, and returns `true` if so.\n     ///\n     /// This method will automatically add `tok` to `expected_tokens` if `tok` is not"}, {"sha": "2246002f5d32a432ce891c64b438c1370bcdf9f2", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -348,10 +348,6 @@ impl<'a> Parser<'a> {\n             lo = self.token.span;\n         }\n \n-        if self.is_lit_bad_ident() {\n-            return Err(self.expected_ident_found());\n-        }\n-\n         let pat = if self.check(&token::BinOp(token::And)) || self.token.kind == token::AndAnd {\n             self.parse_pat_deref(expected)?\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n@@ -395,7 +391,13 @@ impl<'a> Parser<'a> {\n             } else {\n                 PatKind::Lit(const_expr)\n             }\n-        } else if self.can_be_ident_pat() {\n+        // Don't eagerly error on semantically invalid tokens when matching\n+        // declarative macros, as the input to those doesn't have to be\n+        // semantically valid. For attribute/derive proc macros this is not the\n+        // case, so doing the recovery for them is fine.\n+        } else if self.can_be_ident_pat()\n+            || (self.is_lit_bad_ident().is_some() && self.may_recover())\n+        {\n             // Parse `ident @ pat`\n             // This can give false positives and parse nullary enums,\n             // they are dealt with later in resolve.\n@@ -594,7 +596,7 @@ impl<'a> Parser<'a> {\n         // Make sure we don't allow e.g. `let mut $p;` where `$p:pat`.\n         if let token::Interpolated(nt) = &self.token.kind {\n             if let token::NtPat(_) = **nt {\n-                self.expected_ident_found().emit();\n+                self.expected_ident_found_err().emit();\n             }\n         }\n "}, {"sha": "1c459edabb89e1082fc6b4c6f724380fe7aebf54", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1907,7 +1907,7 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Fn => {\n                 for attr in attrs {\n-                    if self.tcx.sess.is_proc_macro_attr(attr) {\n+                    if attr.is_proc_macro_attr() {\n                         debug!(\"Is proc macro attr\");\n                         return true;\n                     }"}, {"sha": "f3e683f4b3a0af4545159ee1d7159d9e543e02ed", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,3 +1,4 @@\n+use rustc_ast::attr;\n use rustc_ast::entry::EntryPointType;\n use rustc_errors::error_code;\n use rustc_hir::def::DefKind;\n@@ -37,7 +38,7 @@ fn entry_fn(tcx: TyCtxt<'_>, (): ()) -> Option<(DefId, EntryFnType)> {\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if tcx.sess.contains_name(&tcx.hir().attrs(CRATE_HIR_ID), sym::no_main) {\n+    if attr::contains_name(&tcx.hir().attrs(CRATE_HIR_ID), sym::no_main) {\n         return None;\n     }\n \n@@ -57,9 +58,9 @@ fn entry_fn(tcx: TyCtxt<'_>, (): ()) -> Option<(DefId, EntryFnType)> {\n // An equivalent optimization was not applied to the duplicated code in test_harness.rs.\n fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> EntryPointType {\n     let attrs = ctxt.tcx.hir().attrs(id.hir_id());\n-    if ctxt.tcx.sess.contains_name(attrs, sym::start) {\n+    if attr::contains_name(attrs, sym::start) {\n         EntryPointType::Start\n-    } else if ctxt.tcx.sess.contains_name(attrs, sym::rustc_main) {\n+    } else if attr::contains_name(attrs, sym::rustc_main) {\n         EntryPointType::RustcMainAttr\n     } else {\n         if let Some(name) = ctxt.tcx.opt_item_name(id.owner_id.to_def_id())\n@@ -78,7 +79,7 @@ fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> Entry\n \n fn attr_span_by_symbol(ctxt: &EntryContext<'_>, id: ItemId, sym: Symbol) -> Option<Span> {\n     let attrs = ctxt.tcx.hir().attrs(id.hir_id());\n-    ctxt.tcx.sess.find_by_name(attrs, sym).map(|attr| attr.span)\n+    attr::find_by_name(attrs, sym).map(|attr| attr.span)\n }\n \n fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {"}, {"sha": "f79807fee3957f17ef296711f77ce28845006a70", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -570,7 +570,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             }\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n-                    is_prelude: self.r.tcx.sess.contains_name(&item.attrs, sym::prelude_import),\n+                    is_prelude: attr::contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(None),\n                     id,\n                 };\n@@ -685,7 +685,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     expansion.to_expn_id(),\n                     item.span,\n                     parent.no_implicit_prelude\n-                        || self.r.tcx.sess.contains_name(&item.attrs, sym::no_implicit_prelude),\n+                        || attr::contains_name(&item.attrs, sym::no_implicit_prelude),\n                 );\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n@@ -750,7 +750,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     // If the structure is marked as non_exhaustive then lower the visibility\n                     // to within the crate.\n                     let mut ctor_vis = if vis.is_public()\n-                        && self.r.tcx.sess.contains_name(&item.attrs, sym::non_exhaustive)\n+                        && attr::contains_name(&item.attrs, sym::non_exhaustive)\n                     {\n                         ty::Visibility::Restricted(CRATE_DEF_ID)\n                     } else {\n@@ -1168,12 +1168,11 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     }\n \n     fn proc_macro_stub(&self, item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n-        if self.r.tcx.sess.contains_name(&item.attrs, sym::proc_macro) {\n+        if attr::contains_name(&item.attrs, sym::proc_macro) {\n             return Some((MacroKind::Bang, item.ident, item.span));\n-        } else if self.r.tcx.sess.contains_name(&item.attrs, sym::proc_macro_attribute) {\n+        } else if attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n             return Some((MacroKind::Attr, item.ident, item.span));\n-        } else if let Some(attr) = self.r.tcx.sess.find_by_name(&item.attrs, sym::proc_macro_derive)\n-        {\n+        } else if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n             if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                 if let Some(ident) = nested_meta.ident() {\n                     return Some((MacroKind::Derive, ident, ident.span));\n@@ -1228,7 +1227,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         if macro_rules {\n             let ident = ident.normalize_to_macros_2_0();\n             self.r.macro_names.insert(ident);\n-            let is_macro_export = self.r.tcx.sess.contains_name(&item.attrs, sym::macro_export);\n+            let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n@@ -1488,13 +1487,12 @@ impl<'a, 'b, 'tcx> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         self.r.visibilities.insert(def_id, vis);\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the crate.\n-        let ctor_vis = if vis.is_public()\n-            && self.r.tcx.sess.contains_name(&variant.attrs, sym::non_exhaustive)\n-        {\n-            ty::Visibility::Restricted(CRATE_DEF_ID)\n-        } else {\n-            vis\n-        };\n+        let ctor_vis =\n+            if vis.is_public() && attr::contains_name(&variant.attrs, sym::non_exhaustive) {\n+                ty::Visibility::Restricted(CRATE_DEF_ID)\n+            } else {\n+                vis\n+            };\n \n         // Define a constructor name in the value namespace.\n         if let Some((ctor_kind, ctor_node_id)) = CtorKind::from_ast(&variant.data) {"}, {"sha": "a0b9188c3159e6543c03b7c4ce915eaaa668fe52", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -23,7 +23,7 @@ extern crate tracing;\n \n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n-use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n+use rustc_ast::{self as ast, attr, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n@@ -1190,7 +1190,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty),\n             ExpnId::root(),\n             krate.spans.inner_span,\n-            tcx.sess.contains_name(&krate.attrs, sym::no_implicit_prelude),\n+            attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n             &mut module_map,\n         );\n         let empty_module = arenas.new_module(\n@@ -1222,9 +1222,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             .map(|(name, _)| (Ident::from_str(name), Default::default()))\n             .collect();\n \n-        if !tcx.sess.contains_name(&krate.attrs, sym::no_core) {\n+        if !attr::contains_name(&krate.attrs, sym::no_core) {\n             extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n-            if !tcx.sess.contains_name(&krate.attrs, sym::no_std) {\n+            if !attr::contains_name(&krate.attrs, sym::no_std) {\n                 extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n             }\n         }"}, {"sha": "c540682d8db385b1097d64c2b6dae1ff27e61a93", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -5,7 +5,7 @@ use crate::Namespace::*;\n use crate::{BuiltinMacroState, Determinacy};\n use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment};\n-use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n+use rustc_ast::{self as ast, attr, Inline, ItemKind, ModKind, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n use rustc_data_structures::intern::Interned;\n@@ -113,7 +113,7 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n pub(crate) fn registered_tools(tcx: TyCtxt<'_>, (): ()) -> RegisteredTools {\n     let mut registered_tools = RegisteredTools::default();\n     let krate = tcx.crate_for_resolver(()).borrow();\n-    for attr in tcx.sess.filter_by_name(&krate.attrs, sym::register_tool) {\n+    for attr in attr::filter_by_name(&krate.attrs, sym::register_tool) {\n         for nested_meta in attr.meta_item_list().unwrap_or_default() {\n             match nested_meta.ident() {\n                 Some(ident) => {\n@@ -703,7 +703,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 PathResult::NonModule(path_res) if let Some(res) = path_res.full_res() => {\n                     check_consistency(self, &path, path_span, kind, initial_res, res)\n                 }\n-                path_res @ PathResult::NonModule(..) | path_res @ PathResult::Failed { .. } => {\n+                path_res @ (PathResult::NonModule(..) | PathResult::Failed { .. }) => {\n                     let mut suggestion = None;\n                     let (span, label) = if let PathResult::Failed { span, label, .. } = path_res {\n                         // try to suggest if it's not a macro, maybe a function"}, {"sha": "0e40f794f18608f6d5ae839cbdfe244680439cab", "filename": "compiler/rustc_resolve/src/rustdoc.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -26,11 +26,13 @@ pub enum DocFragmentKind {\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct DocFragment {\n     pub span: Span,\n-    /// The module this doc-comment came from.\n-    ///\n-    /// This allows distinguishing between the original documentation and a pub re-export.\n-    /// If it is `None`, the item was not re-exported.\n-    pub parent_module: Option<DefId>,\n+    /// The item this doc-comment came from.\n+    /// Used to determine the scope in which doc links in this fragment are resolved.\n+    /// Typically filled for reexport docs when they are merged into the docs of the\n+    /// original reexported item.\n+    /// If the id is not filled, which happens for the original reexported item, then\n+    /// it has to be taken from somewhere else during doc link resolution.\n+    pub item_id: Option<DefId>,\n     pub doc: Symbol,\n     pub kind: DocFragmentKind,\n     pub indent: usize,\n@@ -186,15 +188,15 @@ pub fn attrs_to_doc_fragments<'a>(\n ) -> (Vec<DocFragment>, ast::AttrVec) {\n     let mut doc_fragments = Vec::new();\n     let mut other_attrs = ast::AttrVec::new();\n-    for (attr, parent_module) in attrs {\n+    for (attr, item_id) in attrs {\n         if let Some((doc_str, comment_kind)) = attr.doc_str_and_comment_kind() {\n             let doc = beautify_doc_string(doc_str, comment_kind);\n             let kind = if attr.is_doc_comment() {\n                 DocFragmentKind::SugaredDoc\n             } else {\n                 DocFragmentKind::RawDoc\n             };\n-            let fragment = DocFragment { span: attr.span, doc, kind, parent_module, indent: 0 };\n+            let fragment = DocFragment { span: attr.span, doc, kind, item_id, indent: 0 };\n             doc_fragments.push(fragment);\n         } else if !doc_only {\n             other_attrs.push(attr.clone());\n@@ -216,7 +218,7 @@ pub fn prepare_to_doc_link_resolution(\n ) -> FxHashMap<Option<DefId>, String> {\n     let mut res = FxHashMap::default();\n     for fragment in doc_fragments {\n-        let out_str = res.entry(fragment.parent_module).or_default();\n+        let out_str = res.entry(fragment.item_id).or_default();\n         add_doc_fragment(out_str, fragment);\n     }\n     res"}, {"sha": "fdb9fae44e153b4fce833ae0efda61c276b84df6", "filename": "compiler/rustc_session/src/output.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foutput.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -5,7 +5,7 @@ use crate::errors::{\n     InvalidCharacterInCrateName,\n };\n use crate::Session;\n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n use std::path::{Path, PathBuf};\n@@ -56,7 +56,7 @@ pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute]) -> Symbol {\n     // the command line over one found in the #[crate_name] attribute. If we\n     // find both we ensure that they're the same later on as well.\n     let attr_crate_name =\n-        sess.find_by_name(attrs, sym::crate_name).and_then(|at| at.value_str().map(|s| (at, s)));\n+        attr::find_by_name(attrs, sym::crate_name).and_then(|at| at.value_str().map(|s| (at, s)));\n \n     if let Some(ref s) = sess.opts.crate_name {\n         let s = Symbol::intern(s);"}, {"sha": "700a059c368ba8164f63b4417ec716c2d9aded79", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -30,7 +30,7 @@ use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{FileLoader, RealFileLoader, SourceMap, Span};\n-use rustc_span::{sym, SourceFileHashAlgorithm, Symbol};\n+use rustc_span::{SourceFileHashAlgorithm, Symbol};\n use rustc_target::asm::InlineAsmArch;\n use rustc_target::spec::{CodeModel, PanicStrategy, RelocModel, RelroLevel};\n use rustc_target::spec::{\n@@ -1003,40 +1003,6 @@ impl Session {\n         || self.opts.unstable_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::KERNELADDRESS | SanitizerSet::MEMORY | SanitizerSet::HWADDRESS)\n     }\n \n-    pub fn is_proc_macro_attr(&self, attr: &Attribute) -> bool {\n-        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n-            .iter()\n-            .any(|kind| attr.has_name(*kind))\n-    }\n-\n-    pub fn contains_name(&self, attrs: &[Attribute], name: Symbol) -> bool {\n-        attrs.iter().any(|item| item.has_name(name))\n-    }\n-\n-    pub fn find_by_name<'a>(\n-        &'a self,\n-        attrs: &'a [Attribute],\n-        name: Symbol,\n-    ) -> Option<&'a Attribute> {\n-        attrs.iter().find(|attr| attr.has_name(name))\n-    }\n-\n-    pub fn filter_by_name<'a>(\n-        &'a self,\n-        attrs: &'a [Attribute],\n-        name: Symbol,\n-    ) -> impl Iterator<Item = &'a Attribute> {\n-        attrs.iter().filter(move |attr| attr.has_name(name))\n-    }\n-\n-    pub fn first_attr_value_str_by_name(\n-        &self,\n-        attrs: &[Attribute],\n-        name: Symbol,\n-    ) -> Option<Symbol> {\n-        attrs.iter().find(|at| at.has_name(name)).and_then(|at| at.value_str())\n-    }\n-\n     pub fn diagnostic_width(&self) -> usize {\n         let default_column_width = 140;\n         if let Some(width) = self.opts.diagnostic_width {"}, {"sha": "98d6e0ab117a3968a4eb80d2b93adc4d95b017ed", "filename": "compiler/rustc_span/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_span%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_span%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2FCargo.toml?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -18,3 +18,4 @@ tracing = \"0.1\"\n sha1 = \"0.10.0\"\n sha2 = \"0.10.1\"\n md5 = { package = \"md-5\", version = \"0.10.0\" }\n+indexmap = { version = \"1.9.1\" }"}, {"sha": "b2c58caff2ec440ded5130858e41866b906e9d26", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,13 +1,17 @@\n use crate::{HashStableContext, Symbol};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n+use rustc_data_structures::unhash::Unhasher;\n use rustc_data_structures::AtomicRef;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable_Generic;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::borrow::Borrow;\n use std::fmt;\n-use std::hash::{Hash, Hasher};\n+use std::hash::{BuildHasherDefault, Hash, Hasher};\n+\n+pub type StableCrateIdMap =\n+    indexmap::IndexMap<StableCrateId, CrateNum, BuildHasherDefault<Unhasher>>;\n \n rustc_index::newtype_index! {\n     #[custom_encodable]"}, {"sha": "02cffc762bed32597274febc1332400af944eebd", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -795,6 +795,18 @@ impl Span {\n         })\n     }\n \n+    /// Splits a span into two composite spans around a certain position.\n+    pub fn split_at(self, pos: u32) -> (Span, Span) {\n+        let len = self.hi().0 - self.lo().0;\n+        debug_assert!(pos <= len);\n+\n+        let split_pos = BytePos(self.lo().0 + pos);\n+        (\n+            Span::new(self.lo(), split_pos, self.ctxt(), self.parent()),\n+            Span::new(split_pos, self.hi(), self.ctxt(), self.parent()),\n+        )\n+    }\n+\n     /// Returns a `Span` that would enclose both `self` and `end`.\n     ///\n     /// Note that this can also be used to extend the span \"backwards\":"}, {"sha": "4a1abdf63180a1c5cd61a57a1c2bfc89418be661", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1044,6 +1044,7 @@ symbols! {\n         optin_builtin_traits,\n         option,\n         option_env,\n+        option_payload_ptr,\n         options,\n         or,\n         or_patterns,"}, {"sha": "8cb09108e83ca5e3bb4a53cf3cb882a0b82e2048", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -2,7 +2,8 @@\n \n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n-use super::EvalCtxt;\n+use super::{EvalCtxt, SolverMode};\n+use crate::traits::coherence;\n use itertools::Itertools;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n@@ -87,6 +88,8 @@ pub(super) enum CandidateSource {\n pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n     fn self_ty(self) -> Ty<'tcx>;\n \n+    fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx>;\n+\n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self;\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n@@ -244,15 +247,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         self.assemble_object_bound_candidates(goal, &mut candidates);\n \n+        self.assemble_coherence_unknowable_candidates(goal, &mut candidates);\n+\n         candidates\n     }\n \n     /// If the self type of a goal is a projection, computing the relevant candidates is difficult.\n     ///\n     /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n-    /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n-    /// this case as projections as self types add\n-    // FIXME complete the unfinished sentence above\n+    /// self type to the list of candidates in case that succeeds. We also have to consider candidates with the\n+    /// projection as a self type as well\n     fn assemble_candidates_after_normalizing_self_ty<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n@@ -468,25 +472,49 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    fn assemble_coherence_unknowable_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        match self.solver_mode() {\n+            SolverMode::Normal => return,\n+            SolverMode::Coherence => {\n+                let trait_ref = goal.predicate.trait_ref(self.tcx());\n+                match coherence::trait_ref_is_knowable(self.tcx(), trait_ref) {\n+                    Ok(()) => {}\n+                    Err(_) => match self\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                    {\n+                        Ok(result) => candidates\n+                            .push(Candidate { source: CandidateSource::BuiltinImpl, result }),\n+                        // FIXME: This will be reachable at some point if we're in\n+                        // `assemble_candidates_after_normalizing_self_ty` and we get a\n+                        // universe error. We'll deal with it at this point.\n+                        Err(NoSolution) => bug!(\"coherence candidate resulted in NoSolution\"),\n+                    },\n+                }\n+            }\n+        }\n+    }\n+\n     #[instrument(level = \"debug\", skip(self), ret)]\n-    pub(super) fn merge_candidates_and_discard_reservation_impls(\n+    pub(super) fn merge_candidates(\n         &mut self,\n         mut candidates: Vec<Candidate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         match candidates.len() {\n             0 => return Err(NoSolution),\n-            1 => return Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result),\n+            1 => return Ok(candidates.pop().unwrap().result),\n             _ => {}\n         }\n \n         if candidates.len() > 1 {\n             let mut i = 0;\n             'outer: while i < candidates.len() {\n                 for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.trait_candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                    ) {\n+                    if self.candidate_should_be_dropped_in_favor_of(&candidates[i], &candidates[j])\n+                    {\n                         debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n                         candidates.swap_remove(i);\n                         continue 'outer;\n@@ -511,11 +539,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             }\n         }\n \n-        // FIXME: What if there are >1 candidates left with the same response, and one is a reservation impl?\n-        Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result)\n+        Ok(candidates.pop().unwrap().result)\n     }\n \n-    fn trait_candidate_should_be_dropped_in_favor_of(\n+    fn candidate_should_be_dropped_in_favor_of(\n         &self,\n         candidate: &Candidate<'tcx>,\n         other: &Candidate<'tcx>,\n@@ -528,20 +555,4 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             | (CandidateSource::BuiltinImpl, _) => false,\n         }\n     }\n-\n-    fn discard_reservation_impl(&mut self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n-        if let CandidateSource::Impl(def_id) = candidate.source {\n-            if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n-                debug!(\"Selected reservation impl\");\n-                // We assemble all candidates inside of a probe so by\n-                // making a new canonical response here our result will\n-                // have no constraints.\n-                candidate.result = self\n-                    .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n-                    .unwrap();\n-            }\n-        }\n-\n-        candidate\n-    }\n }"}, {"sha": "c492c8c0aea0510328b5ba70d009cdf6aad96fbf", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -17,6 +17,7 @@ use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n \n use super::search_graph::{self, OverflowHandler};\n+use super::SolverMode;\n use super::{search_graph::SearchGraph, Goal};\n \n pub struct EvalCtxt<'a, 'tcx> {\n@@ -78,7 +79,9 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n     ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut search_graph = search_graph::SearchGraph::new(self.tcx);\n+        let mode = if self.intercrate { SolverMode::Coherence } else { SolverMode::Normal };\n+\n+        let mut search_graph = search_graph::SearchGraph::new(self.tcx, mode);\n \n         let mut ecx = EvalCtxt {\n             search_graph: &mut search_graph,\n@@ -101,6 +104,10 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n }\n \n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n+    pub(super) fn solver_mode(&self) -> SolverMode {\n+        self.search_graph.solver_mode()\n+    }\n+\n     /// The entry point of the solver.\n     ///\n     /// This function deals with (coinductive) cycles, overflow, and caching\n@@ -120,8 +127,14 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         //\n         // The actual solver logic happens in `ecx.compute_goal`.\n         search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n-            let (ref infcx, goal, var_values) =\n-                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+            let intercrate = match search_graph.solver_mode() {\n+                SolverMode::Normal => false,\n+                SolverMode::Coherence => true,\n+            };\n+            let (ref infcx, goal, var_values) = tcx\n+                .infer_ctxt()\n+                .intercrate(intercrate)\n+                .build_with_canonical(DUMMY_SP, &canonical_goal);\n             let mut ecx = EvalCtxt {\n                 infcx,\n                 var_values,"}, {"sha": "89f4056a58db42436eb204d98f1584e1a50f31dd", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -9,10 +9,6 @@\n //! FIXME(@lcnr): Write that section. If you read this before then ask me\n //! about it on zulip.\n \n-// FIXME: Instead of using `infcx.canonicalize_query` we have to add a new routine which\n-// preserves universes and creates a unique var (in the highest universe) for each\n-// appearance of a region.\n-\n // FIXME: uses of `infcx.at` need to enable deferred projection equality once that's implemented.\n \n use rustc_hir::def_id::DefId;\n@@ -41,6 +37,19 @@ mod trait_goals;\n pub use eval_ctxt::{EvalCtxt, InferCtxtEvalExt};\n pub use fulfill::FulfillmentCtxt;\n \n+#[derive(Debug, Clone, Copy)]\n+enum SolverMode {\n+    /// Ordinary trait solving, using everywhere except for coherence.\n+    Normal,\n+    /// Trait solving during coherence. There are a few notable differences\n+    /// between coherence and ordinary trait solving.\n+    ///\n+    /// Most importantly, trait solving during coherence must not be incomplete,\n+    /// i.e. return `Err(NoSolution)` for goals for which a solution exists.\n+    /// This means that we must not make any guesses or arbitrary choices.\n+    Coherence,\n+}\n+\n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n }\n@@ -255,7 +264,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             return Err(NoSolution);\n         }\n \n-        // FIXME(-Ztreat-solver=next): We should instead try to find a `Certainty::Yes` response with\n+        // FIXME(-Ztrait-solver=next): We should instead try to find a `Certainty::Yes` response with\n         // a subset of the constraints that all the other responses have.\n         let one = candidates[0];\n         if candidates[1..].iter().all(|resp| resp == &one) {"}, {"sha": "998859966528b2e1b8a19cc31ff39855271f62e8", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         // projection cache in the solver.\n         if self.term_is_fully_unconstrained(goal) {\n             let candidates = self.assemble_and_evaluate_candidates(goal);\n-            self.merge_candidates_and_discard_reservation_impls(candidates)\n+            self.merge_candidates(candidates)\n         } else {\n             let predicate = goal.predicate;\n             let unconstrained_rhs = self.next_term_infer_of_kind(predicate.term);\n@@ -56,6 +56,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         self.self_ty()\n     }\n \n+    fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n+        self.projection_ty.trait_ref(tcx)\n+    }\n+\n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n         self.with_self_ty(tcx, self_ty)\n     }"}, {"sha": "219890b9dc42c1726110306d19a2800d87fedae5", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,8 +1,9 @@\n mod cache;\n mod overflow;\n \n+pub(super) use overflow::OverflowHandler;\n+\n use self::cache::ProvisionalEntry;\n-pub(super) use crate::solve::search_graph::overflow::OverflowHandler;\n use cache::ProvisionalCache;\n use overflow::OverflowData;\n use rustc_index::vec::IndexVec;\n@@ -11,6 +12,8 @@ use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryRes\n use rustc_middle::ty::TyCtxt;\n use std::{collections::hash_map::Entry, mem};\n \n+use super::SolverMode;\n+\n rustc_index::newtype_index! {\n     pub struct StackDepth {}\n }\n@@ -21,6 +24,7 @@ struct StackElem<'tcx> {\n }\n \n pub(super) struct SearchGraph<'tcx> {\n+    mode: SolverMode,\n     /// The stack of goals currently being computed.\n     ///\n     /// An element is *deeper* in the stack if its index is *lower*.\n@@ -30,14 +34,19 @@ pub(super) struct SearchGraph<'tcx> {\n }\n \n impl<'tcx> SearchGraph<'tcx> {\n-    pub(super) fn new(tcx: TyCtxt<'tcx>) -> SearchGraph<'tcx> {\n+    pub(super) fn new(tcx: TyCtxt<'tcx>, mode: SolverMode) -> SearchGraph<'tcx> {\n         Self {\n+            mode,\n             stack: Default::default(),\n             overflow_data: OverflowData::new(tcx),\n             provisional_cache: ProvisionalCache::empty(),\n         }\n     }\n \n+    pub(super) fn solver_mode(&self) -> SolverMode {\n+        self.mode\n+    }\n+\n     pub(super) fn is_empty(&self) -> bool {\n         self.stack.is_empty() && self.provisional_cache.is_empty()\n     }\n@@ -245,7 +254,8 @@ impl<'tcx> SearchGraph<'tcx> {\n             // dependencies, our non-root goal may no longer appear as child of the root goal.\n             //\n             // See https://github.com/rust-lang/rust/pull/108071 for some additional context.\n-            let should_cache_globally = !self.overflow_data.did_overflow() || self.stack.is_empty();\n+            let should_cache_globally = matches!(self.solver_mode(), SolverMode::Normal)\n+                && (!self.overflow_data.did_overflow() || self.stack.is_empty());\n             if should_cache_globally {\n                 tcx.new_solver_evaluation_cache.insert(\n                     current_goal.goal,"}, {"sha": "2ebdfc8fe72a168e6747cd86a86b55e189100bbc", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -2,7 +2,7 @@\n \n use std::iter;\n \n-use super::{assembly, EvalCtxt};\n+use super::{assembly, EvalCtxt, SolverMode};\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n use rustc_infer::traits::query::NoSolution;\n@@ -20,6 +20,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         self.self_ty()\n     }\n \n+    fn trait_ref(self, _: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n+        self.trait_ref\n+    }\n+\n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n         self.with_self_ty(tcx, self_ty)\n     }\n@@ -43,6 +47,22 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             return Err(NoSolution);\n         }\n \n+        let impl_polarity = tcx.impl_polarity(impl_def_id);\n+        // An upper bound of the certainty of this goal, used to lower the certainty\n+        // of reservation impl to ambiguous during coherence.\n+        let maximal_certainty = match impl_polarity {\n+            ty::ImplPolarity::Positive | ty::ImplPolarity::Negative => {\n+                match impl_polarity == goal.predicate.polarity {\n+                    true => Certainty::Yes,\n+                    false => return Err(NoSolution),\n+                }\n+            }\n+            ty::ImplPolarity::Reservation => match ecx.solver_mode() {\n+                SolverMode::Normal => return Err(NoSolution),\n+                SolverMode::Coherence => Certainty::AMBIGUOUS,\n+            },\n+        };\n+\n         ecx.probe(|ecx| {\n             let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n@@ -55,7 +75,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n             ecx.add_goals(where_clause_bounds);\n-            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+\n+            ecx.evaluate_added_goals_and_make_canonical_response(maximal_certainty)\n         })\n     }\n \n@@ -547,6 +568,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let candidates = self.assemble_and_evaluate_candidates(goal);\n-        self.merge_candidates_and_discard_reservation_impls(candidates)\n+        self.merge_candidates(candidates)\n     }\n }"}, {"sha": "98e00e8223bbce9f43abcc124337588dfe072865", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -95,8 +95,11 @@ pub fn overlapping_impls(\n         return None;\n     }\n \n-    let infcx =\n-        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).intercrate().build();\n+    let infcx = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bubble)\n+        .intercrate(true)\n+        .build();\n     let selcx = &mut SelectionContext::new(&infcx);\n     let overlaps =\n         overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some();\n@@ -107,8 +110,11 @@ pub fn overlapping_impls(\n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    let infcx =\n-        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).intercrate().build();\n+    let infcx = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bubble)\n+        .intercrate(true)\n+        .build();\n     let selcx = &mut SelectionContext::new(&infcx);\n     selcx.enable_tracking_intercrate_ambiguity_causes();\n     Some(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap())"}, {"sha": "af108ab6f309f0df5800f0273dbaaee053588a21", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -212,7 +212,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n \n     fn extract_callable_info(\n         &self,\n-        hir_id: HirId,\n+        body_id: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n         found: Ty<'tcx>,\n     ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)>;\n@@ -909,9 +909,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             trait_pred.self_ty(),\n         );\n \n-        let body_hir_id = self.tcx.hir().local_def_id_to_hir_id(obligation.cause.body_id);\n         let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(\n-            body_hir_id,\n+            obligation.cause.body_id,\n             obligation.param_env,\n             self_ty,\n         ) else { return false; };\n@@ -1113,10 +1112,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     /// Extracts information about a callable type for diagnostics. This is a\n     /// heuristic -- it doesn't necessarily mean that a type is always callable,\n     /// because the callable type must also be well-formed to be called.\n-    // FIXME(vincenzopalazzo): move the HirId to a LocalDefId\n     fn extract_callable_info(\n         &self,\n-        hir_id: HirId,\n+        body_id: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n         found: Ty<'tcx>,\n     ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)> {\n@@ -1168,7 +1166,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     })\n                 }\n                 ty::Param(param) => {\n-                    let generics = self.tcx.generics_of(hir_id.owner.to_def_id());\n+                    let generics = self.tcx.generics_of(body_id);\n                     let name = if generics.count() > param.index as usize\n                         && let def = generics.param_at(param.index as usize, self.tcx)\n                         && matches!(def.kind, ty::GenericParamDefKind::Type { .. })"}, {"sha": "e89706067046a9073406a8985b5ce2870a533010", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -4,7 +4,7 @@\n \n pub mod auto_trait;\n mod chalk_fulfill;\n-mod coherence;\n+pub(crate) mod coherence;\n pub mod const_evaluatable;\n mod engine;\n pub mod error_reporting;"}, {"sha": "ee5a7909ba3dc66c3d88c5b9238e850ccd67834a", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -539,7 +539,7 @@ fn make_thin_self_ptr<'tcx>(\n         // get a built-in pointer type\n         let mut fat_pointer_layout = layout;\n         'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n-            && !fat_pointer_layout.ty.is_region_ptr()\n+            && !fat_pointer_layout.ty.is_ref()\n         {\n             for i in 0..fat_pointer_layout.fields.count() {\n                 let field_layout = fat_pointer_layout.field(cx, i);"}, {"sha": "bf0bc202852e4fa00e85ae9ecf81c4e9eb4659af", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -254,13 +254,16 @@ fn associated_type_for_impl_trait_in_trait(\n     tcx: TyCtxt<'_>,\n     opaque_ty_def_id: LocalDefId,\n ) -> LocalDefId {\n-    let fn_def_id = tcx.impl_trait_in_trait_parent_fn(opaque_ty_def_id.to_def_id());\n-    let trait_def_id = tcx.parent(fn_def_id);\n+    let (hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id)) =\n+        tcx.hir().expect_item(opaque_ty_def_id).expect_opaque_ty().origin\n+    else {\n+        bug!(\"expected opaque for {opaque_ty_def_id:?}\");\n+    };\n+    let trait_def_id = tcx.local_parent(fn_def_id);\n     assert_eq!(tcx.def_kind(trait_def_id), DefKind::Trait);\n \n     let span = tcx.def_span(opaque_ty_def_id);\n-    let trait_assoc_ty =\n-        tcx.at(span).create_def(trait_def_id.expect_local(), DefPathData::ImplTraitAssocTy);\n+    let trait_assoc_ty = tcx.at(span).create_def(trait_def_id, DefPathData::ImplTraitAssocTy);\n \n     let local_def_id = trait_assoc_ty.def_id();\n     let def_id = local_def_id.to_def_id();\n@@ -282,7 +285,7 @@ fn associated_type_for_impl_trait_in_trait(\n         container: ty::TraitContainer,\n         fn_has_self_parameter: false,\n         opt_rpitit_info: Some(ImplTraitInTraitData::Trait {\n-            fn_def_id,\n+            fn_def_id: fn_def_id.to_def_id(),\n             opaque_def_id: opaque_ty_def_id.to_def_id(),\n         }),\n     });\n@@ -324,7 +327,7 @@ fn associated_type_for_impl_trait_in_trait(\n             params.iter().map(|param| (param.def_id, param.index)).collect();\n \n         ty::Generics {\n-            parent: Some(trait_def_id),\n+            parent: Some(trait_def_id.to_def_id()),\n             parent_count,\n             params,\n             param_def_id_to_index,\n@@ -335,7 +338,7 @@ fn associated_type_for_impl_trait_in_trait(\n \n     // There are no predicates for the synthesized associated type.\n     trait_assoc_ty.explicit_predicates_of(ty::GenericPredicates {\n-        parent: Some(trait_def_id),\n+        parent: Some(trait_def_id.to_def_id()),\n         predicates: &[],\n     });\n \n@@ -356,7 +359,6 @@ fn associated_type_for_impl_trait_in_impl(\n     impl_fn_def_id: LocalDefId,\n ) -> LocalDefId {\n     let impl_local_def_id = tcx.local_parent(impl_fn_def_id);\n-    let impl_def_id = impl_local_def_id.to_def_id();\n \n     // FIXME fix the span, we probably want the def_id of the return type of the function\n     let span = tcx.def_span(impl_fn_def_id);\n@@ -384,10 +386,6 @@ fn associated_type_for_impl_trait_in_impl(\n         opt_rpitit_info: Some(ImplTraitInTraitData::Impl { fn_def_id: impl_fn_def_id.to_def_id() }),\n     });\n \n-    // Copy param_env of the containing function. The synthesized associated type doesn't have\n-    // extra predicates to assume.\n-    impl_assoc_ty.param_env(tcx.param_env(impl_fn_def_id));\n-\n     // Copy visility of the containing function.\n     impl_assoc_ty.visibility(tcx.visibility(impl_fn_def_id));\n \n@@ -402,7 +400,7 @@ fn associated_type_for_impl_trait_in_impl(\n         let trait_assoc_parent_count = trait_assoc_generics.parent_count;\n         let mut params = trait_assoc_generics.params.clone();\n \n-        let parent_generics = tcx.generics_of(impl_def_id);\n+        let parent_generics = tcx.generics_of(impl_local_def_id.to_def_id());\n         let parent_count = parent_generics.parent_count + parent_generics.params.len();\n \n         for param in &mut params {\n@@ -413,7 +411,7 @@ fn associated_type_for_impl_trait_in_impl(\n             params.iter().map(|param| (param.def_id, param.index)).collect();\n \n         ty::Generics {\n-            parent: Some(impl_def_id),\n+            parent: Some(impl_local_def_id.to_def_id()),\n             parent_count,\n             params,\n             param_def_id_to_index,\n@@ -424,7 +422,7 @@ fn associated_type_for_impl_trait_in_impl(\n \n     // There are no predicates for the synthesized associated type.\n     impl_assoc_ty.explicit_predicates_of(ty::GenericPredicates {\n-        parent: Some(impl_def_id),\n+        parent: Some(impl_local_def_id.to_def_id()),\n         predicates: &[],\n     });\n "}, {"sha": "50aeb7f440faf204aaaa24b6a5e8e0d23f634b70", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -130,7 +130,9 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     // FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty): I don't like this, we should\n     // at least be making sure that the generics in RPITITs and their parent fn don't\n     // get out of alignment, or else we do actually need to substitute these predicates.\n-    if let Some(ImplTraitInTraitData::Trait { fn_def_id, .. }) = tcx.opt_rpitit_info(def_id) {\n+    if let Some(ImplTraitInTraitData::Trait { fn_def_id, .. })\n+    | Some(ImplTraitInTraitData::Impl { fn_def_id, .. }) = tcx.opt_rpitit_info(def_id)\n+    {\n         predicates = tcx.predicates_of(fn_def_id).instantiate_identity(tcx).predicates;\n     }\n "}, {"sha": "c1dbbde08b6b9ad390590630f246656616fe3670", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1499,13 +1499,25 @@ fn test_split_whitespace() {\n \n #[test]\n fn test_lines() {\n-    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\r\\nLittle l\u00e4mb\\n\";\n-    let lines: Vec<&str> = data.lines().collect();\n-    assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n-\n-    let data = \"\\r\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\"; // no trailing \\n\n-    let lines: Vec<&str> = data.lines().collect();\n-    assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+    fn t(data: &str, expected: &[&str]) {\n+        let lines: Vec<&str> = data.lines().collect();\n+        assert_eq!(lines, expected);\n+    }\n+    t(\"\", &[]);\n+    t(\"\\n\", &[\"\"]);\n+    t(\"\\n2nd\", &[\"\", \"2nd\"]);\n+    t(\"\\r\\n\", &[\"\"]);\n+    t(\"bare\\r\", &[\"bare\\r\"]);\n+    t(\"bare\\rcr\", &[\"bare\\rcr\"]);\n+    t(\"Text\\n\\r\", &[\"Text\", \"\\r\"]);\n+    t(\n+        \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\r\\nLittle l\u00e4mb\\n\",\n+        &[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"],\n+    );\n+    t(\n+        \"\\r\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\",\n+        &[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"],\n+    );\n }\n \n #[test]"}, {"sha": "7482b8b0862e259a81f7522c708b8845ada71dd1", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -2214,6 +2214,12 @@ extern \"rust-intrinsic\" {\n     where\n         G: FnOnce<ARG, Output = RET>,\n         F: FnOnce<ARG, Output = RET>;\n+\n+    #[cfg(not(bootstrap))]\n+    /// This method creates a pointer to any `Some` value. If the argument is\n+    /// `None`, an invalid within-bounds pointer (that is still acceptable for\n+    /// constructing an empty slice) is returned.\n+    pub fn option_payload_ptr<T>(arg: *const Option<T>) -> *const T;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "3061f76df04d0e9a1429a77a2559b0869477a81c", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -49,6 +49,8 @@\n //!\n //! The input to the [`mir!`] macro is:\n //!\n+//!  - An optional return type annotation in the form of `type RET = ...;`. This may be required\n+//!    if the compiler cannot infer the type of RET.\n //!  - A possibly empty list of local declarations. Locals can also be declared inline on\n //!    assignments via `let`. Type inference generally works. Shadowing does not.\n //!  - A list of basic blocks. The first of these is the start block and is where execution begins.\n@@ -124,6 +126,18 @@\n //!         }\n //!     )\n //! }\n+//!\n+//! #[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+//! fn annotated_return_type() -> (i32, bool) {\n+//!     mir!(\n+//!         type RET = (i32, bool);\n+//!         {\n+//!             RET.0 = 1;\n+//!             RET.1 = true;\n+//!             Return()\n+//!         }\n+//!     )\n+//! }\n //! ```\n //!\n //! We can also set off compilation failures that happen in sufficiently late stages of the\n@@ -342,6 +356,7 @@ define!(\n #[rustc_macro_transparency = \"transparent\"]\n pub macro mir {\n     (\n+        $(type RET = $ret_ty:ty ;)?\n         $(let $local_decl:ident $(: $local_decl_ty:ty)? ;)*\n \n         {\n@@ -362,7 +377,7 @@ pub macro mir {\n         {\n             // Now all locals\n             #[allow(non_snake_case)]\n-            let RET;\n+            let RET $(: $ret_ty)?;\n             $(\n                 let $local_decl $(: $local_decl_ty)? ;\n             )*"}, {"sha": "a6b9acb576eb454dbf66fbd3693b451208b524a9", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -209,6 +209,7 @@\n #![feature(derive_const)]\n #![feature(doc_cfg)]\n #![feature(doc_notable_trait)]\n+#![feature(generic_arg_infer)]\n #![feature(rustdoc_internals)]\n #![feature(exhaustive_patterns)]\n #![feature(doc_cfg_hide)]"}, {"sha": "cba597e66aa136c90e8e4d3a36d99d4f2e70370a", "filename": "library/core/src/option.rs", "status": "modified", "additions": 36, "deletions": 72, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -559,6 +559,7 @@ use crate::{\n /// The `Option` type. See [the module level documentation](self) for more.\n #[derive(Copy, PartialOrd, Eq, Ord, Debug, Hash)]\n #[rustc_diagnostic_item = \"Option\"]\n+#[cfg_attr(not(bootstrap), lang = \"Option\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {\n     /// No value.\n@@ -735,48 +736,6 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// This is a guess at how many bytes into the option the payload can be found.\n-    ///\n-    /// For niche-optimized types it's correct because it's pigeon-holed to only\n-    /// one possible place.  For other types, it's usually correct today, but\n-    /// tweaks to the layout algorithm (particularly expansions of\n-    /// `-Z randomize-layout`) might make it incorrect at any point.\n-    ///\n-    /// It's guaranteed to be a multiple of alignment (so will always give a\n-    /// correctly-aligned location) and to be within the allocated object, so\n-    /// is valid to use with `offset` and to use for a zero-sized read.\n-    ///\n-    /// FIXME: This is a horrible hack, but allows a nice optimization.  It should\n-    /// be replaced with `offset_of!` once that works on enum variants.\n-    const SOME_BYTE_OFFSET_GUESS: isize = {\n-        let some_uninit = Some(mem::MaybeUninit::<T>::uninit());\n-        let payload_ref = some_uninit.as_ref().unwrap();\n-        // SAFETY: `as_ref` gives an address inside the existing `Option`,\n-        // so both pointers are derived from the same thing and the result\n-        // cannot overflow an `isize`.\n-        let offset = unsafe { <*const _>::byte_offset_from(payload_ref, &some_uninit) };\n-\n-        // The offset is into the object, so it's guaranteed to be non-negative.\n-        assert!(offset >= 0);\n-\n-        // The payload and the overall option are aligned,\n-        // so the offset will be a multiple of the alignment too.\n-        assert!((offset as usize) % mem::align_of::<T>() == 0);\n-\n-        let max_offset = mem::size_of::<Self>() - mem::size_of::<T>();\n-        if offset as usize <= max_offset {\n-            // There's enough space after this offset for a `T` to exist without\n-            // overflowing the bounds of the object, so let's try it.\n-            offset\n-        } else {\n-            // The offset guess is definitely wrong, so use the address\n-            // of the original option since we have it already.\n-            // This also correctly handles the case of layout-optimized enums\n-            // where `max_offset == 0` and thus this is the only possibility.\n-            0\n-        }\n-    };\n-\n     /// Returns a slice of the contained value, if any. If this is `None`, an\n     /// empty slice is returned. This can be useful to have a single type of\n     /// iterator over an `Option` or slice.\n@@ -809,28 +768,29 @@ impl<T> Option<T> {\n     #[must_use]\n     #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n     pub fn as_slice(&self) -> &[T] {\n-        let payload_ptr: *const T =\n-            // The goal here is that both arms here are calculating exactly\n-            // the same pointer, and thus it'll be folded away when the guessed\n-            // offset is correct, but if the guess is wrong for some reason\n-            // it'll at least still be sound, just no longer optimal.\n-            if let Some(payload) = self {\n-                payload\n-            } else {\n-                let self_ptr: *const Self = self;\n-                // SAFETY: `SOME_BYTE_OFFSET_GUESS` guarantees that its value is\n-                // such that this will be in-bounds of the object.\n-                unsafe { self_ptr.byte_offset(Self::SOME_BYTE_OFFSET_GUESS).cast() }\n-            };\n-        let len = usize::from(self.is_some());\n+        #[cfg(bootstrap)]\n+        match self {\n+            Some(value) => slice::from_ref(value),\n+            None => &[],\n+        }\n \n+        #[cfg(not(bootstrap))]\n         // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n         // to the payload, with a length of 1, so this is equivalent to\n         // `slice::from_ref`, and thus is safe.\n         // When the `Option` is `None`, the length used is 0, so to be safe it\n         // just needs to be aligned, which it is because `&self` is aligned and\n         // the offset used is a multiple of alignment.\n-        unsafe { slice::from_raw_parts(payload_ptr, len) }\n+        //\n+        // In the new version, the intrinsic always returns a pointer to an\n+        // in-bounds and correctly aligned position for a `T` (even if in the\n+        // `None` case it's just padding).\n+        unsafe {\n+            slice::from_raw_parts(\n+                crate::intrinsics::option_payload_ptr(crate::ptr::from_ref(self)),\n+                usize::from(self.is_some()),\n+            )\n+        }\n     }\n \n     /// Returns a mutable slice of the contained value, if any. If this is\n@@ -875,28 +835,32 @@ impl<T> Option<T> {\n     #[must_use]\n     #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        let payload_ptr: *mut T =\n-            // The goal here is that both arms here are calculating exactly\n-            // the same pointer, and thus it'll be folded away when the guessed\n-            // offset is correct, but if the guess is wrong for some reason\n-            // it'll at least still be sound, just no longer optimal.\n-            if let Some(payload) = self {\n-                payload\n-            } else {\n-                let self_ptr: *mut Self = self;\n-                // SAFETY: `SOME_BYTE_OFFSET_GUESS` guarantees that its value is\n-                // such that this will be in-bounds of the object.\n-                unsafe { self_ptr.byte_offset(Self::SOME_BYTE_OFFSET_GUESS).cast() }\n-            };\n-        let len = usize::from(self.is_some());\n+        #[cfg(bootstrap)]\n+        match self {\n+            Some(value) => slice::from_mut(value),\n+            None => &mut [],\n+        }\n \n+        #[cfg(not(bootstrap))]\n         // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n         // to the payload, with a length of 1, so this is equivalent to\n         // `slice::from_mut`, and thus is safe.\n         // When the `Option` is `None`, the length used is 0, so to be safe it\n         // just needs to be aligned, which it is because `&self` is aligned and\n         // the offset used is a multiple of alignment.\n-        unsafe { slice::from_raw_parts_mut(payload_ptr, len) }\n+        //\n+        // In the new version, the intrinsic creates a `*const T` from a\n+        // mutable reference  so it is safe to cast back to a mutable pointer\n+        // here. As with `as_slice`, the intrinsic always returns a pointer to\n+        // an in-bounds and correctly aligned position for a `T` (even if in\n+        // the `None` case it's just padding).\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                crate::intrinsics::option_payload_ptr(crate::ptr::from_mut(self).cast_const())\n+                    .cast_mut(),\n+                usize::from(self.is_some()),\n+            )\n+        }\n     }\n \n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "772c3605562cfa1ab006f5a7d45fc1c0814ee3bf", "filename": "library/core/src/str/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -13,7 +13,7 @@ use super::from_utf8_unchecked;\n use super::pattern::Pattern;\n use super::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n use super::validations::{next_code_point, next_code_point_reverse};\n-use super::LinesAnyMap;\n+use super::LinesMap;\n use super::{BytesIsNotEmpty, UnsafeBytesToStr};\n use super::{CharEscapeDebugContinue, CharEscapeDefault, CharEscapeUnicode};\n use super::{IsAsciiWhitespace, IsNotEmpty, IsWhitespace};\n@@ -1104,7 +1104,7 @@ generate_pattern_iterators! {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[derive(Clone, Debug)]\n-pub struct Lines<'a>(pub(super) Map<SplitTerminator<'a, char>, LinesAnyMap>);\n+pub struct Lines<'a>(pub(super) Map<SplitInclusive<'a, char>, LinesMap>);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Lines<'a> {"}, {"sha": "2b23f64732b03b9680cb793300ec0984f3c8d0ec", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1011,7 +1011,7 @@ impl str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn lines(&self) -> Lines<'_> {\n-        Lines(self.split_terminator('\\n').map(LinesAnyMap))\n+        Lines(self.split_inclusive('\\n').map(LinesMap))\n     }\n \n     /// An iterator over the lines of a string.\n@@ -2604,10 +2604,10 @@ impl Default for &mut str {\n impl_fn_for_zst! {\n     /// A nameable, cloneable fn type\n     #[derive(Clone)]\n-    struct LinesAnyMap impl<'a> Fn = |line: &'a str| -> &'a str {\n-        let l = line.len();\n-        if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n-        else { line }\n+    struct LinesMap impl<'a> Fn = |line: &'a str| -> &'a str {\n+        let Some(line) = line.strip_suffix('\\n') else { return line };\n+        let Some(line) = line.strip_suffix('\\r') else { return line };\n+        line\n     };\n \n     #[derive(Clone)]"}, {"sha": "b655243782c18d3419439daa523782e0818ecf26", "filename": "library/stdarch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstdarch?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1 +1 @@\n-Subproject commit a0c30f3e3c75adcd6ee7efc94014ebcead61c507\n+Subproject commit b655243782c18d3419439daa523782e0818ecf26"}, {"sha": "83a6d0ad29279afd500fc3e98b500f8726095385", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -919,9 +919,9 @@ impl<'a> Builder<'a> {\n         host: TargetSelection,\n         target: TargetSelection,\n     ) -> Compiler {\n-        if self.build.force_use_stage2() {\n+        if self.build.force_use_stage2(stage) {\n             self.compiler(2, self.config.build)\n-        } else if self.build.force_use_stage1(Compiler { stage, host }, target) {\n+        } else if self.build.force_use_stage1(stage, target) {\n             self.compiler(1, self.config.build)\n         } else {\n             self.compiler(stage, host)"}, {"sha": "36f9aaa595d0ff0632efefcf46177695bfcfc773", "filename": "src/bootstrap/download-ci-llvm-stamp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Fbootstrap%2Fdownload-ci-llvm-stamp", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Fbootstrap%2Fdownload-ci-llvm-stamp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload-ci-llvm-stamp?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,4 +1,4 @@\n Change this file to make users of the `download-ci-llvm` configuration download\n a new version of LLVM from CI, even if the LLVM submodule hasn\u2019t changed.\n \n-Last change is for: https://github.com/rust-lang/rust/pull/104748\n+Last change is for: https://github.com/rust-lang/rust/pull/109373"}, {"sha": "54aa5a585bbcb2ff3e16a3ff02610555e419a977", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1204,19 +1204,20 @@ impl Build {\n     ///\n     /// When all of these conditions are met the build will lift artifacts from\n     /// the previous stage forward.\n-    fn force_use_stage1(&self, compiler: Compiler, target: TargetSelection) -> bool {\n+    fn force_use_stage1(&self, stage: u32, target: TargetSelection) -> bool {\n         !self.config.full_bootstrap\n-            && compiler.stage >= 2\n+            && !self.config.download_rustc()\n+            && stage >= 2\n             && (self.hosts.iter().any(|h| *h == target) || target == self.build)\n     }\n \n     /// Checks whether the `compiler` compiling for `target` should be forced to\n     /// use a stage2 compiler instead.\n     ///\n-    /// When we download the pre-compiled version of rustc it should be forced to\n-    /// use a stage2 compiler.\n-    fn force_use_stage2(&self) -> bool {\n-        self.config.download_rustc()\n+    /// When we download the pre-compiled version of rustc and compiler stage is >= 2,\n+    /// it should be forced to use a stage2 compiler.\n+    fn force_use_stage2(&self, stage: u32) -> bool {\n+        self.config.download_rustc() && stage >= 2\n     }\n \n     /// Given `num` in the form \"a.b.c\" return a \"release string\" which"}, {"sha": "f27db5c91e221f8adcd07bda6bd71243b627155f", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -309,6 +309,7 @@ impl Step for Llvm {\n         cfg.out_dir(&out_dir)\n             .profile(profile)\n             .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n+            .define(\"LLVM_UNREACHABLE_OPTIMIZE\", \"OFF\")\n             .define(\"LLVM_ENABLE_PLUGINS\", plugins)\n             .define(\"LLVM_TARGETS_TO_BUILD\", llvm_targets)\n             .define(\"LLVM_EXPERIMENTAL_TARGETS_TO_BUILD\", llvm_exp_targets)"}, {"sha": "6fd113fcfd8aae914eb08b99fbe556feb340e324", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/browser-ui-test.version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1 +1 @@\n-0.14.4\n\\ No newline at end of file\n+0.14.5\n\\ No newline at end of file"}, {"sha": "f71aceff4550c121d8c965ee4f72174db6a28246", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -213,7 +213,7 @@ See the [Clang ControlFlowIntegrity documentation][clang-cfi] for more details.\n \n ## Example\n \n-```text\n+```rust,ignore\n #![feature(naked_functions)]\n \n use std::arch::asm;\n@@ -238,7 +238,7 @@ pub extern \"C\" fn add_two(x: i32) {\n              nop\n              nop\n              nop\n-             lea rax, [rdi+2]\n+             lea eax, [edi+2]\n              ret\n         \",\n             options(noreturn)"}, {"sha": "768f8bb7bc899aa7b42da8b7d6c641da4f05f4d3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 23, "deletions": 52, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -36,15 +36,11 @@ use crate::formats::item_type::ItemType;\n ///\n /// The returned value is `None` if the definition could not be inlined,\n /// and `Some` of a vector of items if it was successfully expanded.\n-///\n-/// `parent_module` refers to the parent of the *re-export*, not the original item.\n pub(crate) fn try_inline(\n     cx: &mut DocContext<'_>,\n-    parent_module: DefId,\n-    import_def_id: Option<DefId>,\n     res: Res,\n     name: Symbol,\n-    attrs: Option<&[ast::Attribute]>,\n+    attrs: Option<(&[ast::Attribute], Option<DefId>)>,\n     visited: &mut DefIdSet,\n ) -> Option<Vec<clean::Item>> {\n     let did = res.opt_def_id()?;\n@@ -55,38 +51,17 @@ pub(crate) fn try_inline(\n \n     debug!(\"attrs={:?}\", attrs);\n \n-    let attrs_without_docs = attrs.map(|attrs| {\n-        attrs.into_iter().filter(|a| a.doc_str().is_none()).cloned().collect::<Vec<_>>()\n+    let attrs_without_docs = attrs.map(|(attrs, def_id)| {\n+        (attrs.into_iter().filter(|a| a.doc_str().is_none()).cloned().collect::<Vec<_>>(), def_id)\n     });\n-    // We need this ugly code because:\n-    //\n-    // ```\n-    // attrs_without_docs.map(|a| a.as_slice())\n-    // ```\n-    //\n-    // will fail because it returns a temporary slice and:\n-    //\n-    // ```\n-    // attrs_without_docs.map(|s| {\n-    //     vec = s.as_slice();\n-    //     vec\n-    // })\n-    // ```\n-    //\n-    // will fail because we're moving an uninitialized variable into a closure.\n-    let vec;\n-    let attrs_without_docs = match attrs_without_docs {\n-        Some(s) => {\n-            vec = s;\n-            Some(vec.as_slice())\n-        }\n-        None => None,\n-    };\n+    let attrs_without_docs =\n+        attrs_without_docs.as_ref().map(|(attrs, def_id)| (&attrs[..], *def_id));\n \n+    let import_def_id = attrs.and_then(|(_, def_id)| def_id);\n     let kind = match res {\n         Res::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, ItemType::Trait);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::TraitItem(Box::new(build_external_trait(cx, did)))\n         }\n         Res::Def(DefKind::Fn, did) => {\n@@ -95,27 +70,27 @@ pub(crate) fn try_inline(\n         }\n         Res::Def(DefKind::Struct, did) => {\n             record_extern_fqn(cx, did, ItemType::Struct);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::StructItem(build_struct(cx, did))\n         }\n         Res::Def(DefKind::Union, did) => {\n             record_extern_fqn(cx, did, ItemType::Union);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::UnionItem(build_union(cx, did))\n         }\n         Res::Def(DefKind::TyAlias, did) => {\n             record_extern_fqn(cx, did, ItemType::Typedef);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::TypedefItem(build_type_alias(cx, did))\n         }\n         Res::Def(DefKind::Enum, did) => {\n             record_extern_fqn(cx, did, ItemType::Enum);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::EnumItem(build_enum(cx, did))\n         }\n         Res::Def(DefKind::ForeignTy, did) => {\n             record_extern_fqn(cx, did, ItemType::ForeignType);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::ForeignTypeItem\n         }\n         // Never inline enum variants but leave them shown as re-exports.\n@@ -149,7 +124,7 @@ pub(crate) fn try_inline(\n         _ => return None,\n     };\n \n-    let (attrs, cfg) = merge_attrs(cx, Some(parent_module), load_attrs(cx, did), attrs);\n+    let (attrs, cfg) = merge_attrs(cx, load_attrs(cx, did), attrs);\n     cx.inlined.insert(did.into());\n     let mut item =\n         clean::Item::from_def_id_and_attrs_and_parts(did, Some(name), kind, Box::new(attrs), cfg);\n@@ -316,17 +291,16 @@ fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> Box<clean::Typedef>\n /// Builds all inherent implementations of an ADT (struct/union/enum) or Trait item/path/reexport.\n pub(crate) fn build_impls(\n     cx: &mut DocContext<'_>,\n-    parent_module: Option<DefId>,\n     did: DefId,\n-    attrs: Option<&[ast::Attribute]>,\n+    attrs: Option<(&[ast::Attribute], Option<DefId>)>,\n     ret: &mut Vec<clean::Item>,\n ) {\n     let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_inherent_impls\");\n     let tcx = cx.tcx;\n \n     // for each implementation of an item represented by `did`, build the clean::Item for that impl\n     for &did in tcx.inherent_impls(did).iter() {\n-        build_impl(cx, parent_module, did, attrs, ret);\n+        build_impl(cx, did, attrs, ret);\n     }\n \n     // This pretty much exists expressly for `dyn Error` traits that exist in the `alloc` crate.\n@@ -340,28 +314,26 @@ pub(crate) fn build_impls(\n         let type_ =\n             if tcx.is_trait(did) { TraitSimplifiedType(did) } else { AdtSimplifiedType(did) };\n         for &did in tcx.incoherent_impls(type_) {\n-            build_impl(cx, parent_module, did, attrs, ret);\n+            build_impl(cx, did, attrs, ret);\n         }\n     }\n }\n \n-/// `parent_module` refers to the parent of the re-export, not the original item\n pub(crate) fn merge_attrs(\n     cx: &mut DocContext<'_>,\n-    parent_module: Option<DefId>,\n     old_attrs: &[ast::Attribute],\n-    new_attrs: Option<&[ast::Attribute]>,\n+    new_attrs: Option<(&[ast::Attribute], Option<DefId>)>,\n ) -> (clean::Attributes, Option<Arc<clean::cfg::Cfg>>) {\n     // NOTE: If we have additional attributes (from a re-export),\n     // always insert them first. This ensure that re-export\n     // doc comments show up before the original doc comments\n     // when we render them.\n-    if let Some(inner) = new_attrs {\n+    if let Some((inner, item_id)) = new_attrs {\n         let mut both = inner.to_vec();\n         both.extend_from_slice(old_attrs);\n         (\n-            if let Some(new_id) = parent_module {\n-                Attributes::from_ast_with_additional(old_attrs, (inner, new_id))\n+            if let Some(item_id) = item_id {\n+                Attributes::from_ast_with_additional(old_attrs, (inner, item_id))\n             } else {\n                 Attributes::from_ast(&both)\n             },\n@@ -375,9 +347,8 @@ pub(crate) fn merge_attrs(\n /// Inline an `impl`, inherent or of a trait. The `did` must be for an `impl`.\n pub(crate) fn build_impl(\n     cx: &mut DocContext<'_>,\n-    parent_module: Option<DefId>,\n     did: DefId,\n-    attrs: Option<&[ast::Attribute]>,\n+    attrs: Option<(&[ast::Attribute], Option<DefId>)>,\n     ret: &mut Vec<clean::Item>,\n ) {\n     if !cx.inlined.insert(did.into()) {\n@@ -539,7 +510,7 @@ pub(crate) fn build_impl(\n         record_extern_trait(cx, did);\n     }\n \n-    let (merged_attrs, cfg) = merge_attrs(cx, parent_module, load_attrs(cx, did), attrs);\n+    let (merged_attrs, cfg) = merge_attrs(cx, load_attrs(cx, did), attrs);\n     trace!(\"merged_attrs={:?}\", merged_attrs);\n \n     trace!(\n@@ -635,7 +606,7 @@ fn build_module_items(\n                     cfg: None,\n                     inline_stmt_id: None,\n                 });\n-            } else if let Some(i) = try_inline(cx, did, None, res, item.ident.name, None, visited) {\n+            } else if let Some(i) = try_inline(cx, res, item.ident.name, None, visited) {\n                 items.extend(i)\n             }\n         }"}, {"sha": "2e1f456f50e2f4f6c4a65504214b817d6e399771", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -2388,12 +2388,12 @@ fn clean_maybe_renamed_item<'tcx>(\n             target_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n         }\n \n-        let import_parent = import_id.map(|import_id| cx.tcx.local_parent(import_id).to_def_id());\n-        let (attrs, cfg) =  merge_attrs(cx, import_parent, &target_attrs, Some(&import_attrs));\n+        let import_id = import_id.map(|def_id| def_id.to_def_id());\n+        let (attrs, cfg) =  merge_attrs(cx, &target_attrs, Some((&import_attrs, import_id)));\n \n         let mut item =\n             Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);\n-        item.inline_stmt_id = import_id.map(|def_id| def_id.to_def_id());\n+        item.inline_stmt_id = import_id;\n         vec![item]\n     })\n }\n@@ -2478,18 +2478,12 @@ fn clean_extern_crate<'tcx>(\n \n     let krate_owner_def_id = krate.owner_id.to_def_id();\n     if please_inline {\n-        let mut visited = DefIdSet::default();\n-\n-        let res = Res::Def(DefKind::Mod, crate_def_id);\n-\n         if let Some(items) = inline::try_inline(\n             cx,\n-            cx.tcx.parent_module(krate.hir_id()).to_def_id(),\n-            Some(krate_owner_def_id),\n-            res,\n+            Res::Def(DefKind::Mod, crate_def_id),\n             name,\n-            Some(attrs),\n-            &mut visited,\n+            Some((attrs, Some(krate_owner_def_id))),\n+            &mut Default::default(),\n         ) {\n             return items;\n         }\n@@ -2613,17 +2607,13 @@ fn clean_use_statement_inner<'tcx>(\n             denied = true;\n         }\n         if !denied {\n-            let mut visited = DefIdSet::default();\n             let import_def_id = import.owner_id.to_def_id();\n-\n             if let Some(mut items) = inline::try_inline(\n                 cx,\n-                cx.tcx.parent_module(import.hir_id()).to_def_id(),\n-                Some(import_def_id),\n                 path.res,\n                 name,\n-                Some(attrs),\n-                &mut visited,\n+                Some((attrs, Some(import_def_id))),\n+                &mut Default::default(),\n             ) {\n                 items.push(Item::from_def_id_and_parts(\n                     import_def_id,"}, {"sha": "7dbb3f76a0a8366826f9e39d099b69a4649d9b62", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1471,27 +1471,68 @@ impl Type {\n         result\n     }\n \n-    /// Check if two types are \"potentially the same\".\n+    pub(crate) fn is_borrowed_ref(&self) -> bool {\n+        matches!(self, Type::BorrowedRef { .. })\n+    }\n+\n+    /// Check if two types are \"the same\" for documentation purposes.\n+    ///\n     /// This is different from `Eq`, because it knows that things like\n     /// `Placeholder` are possible matches for everything.\n-    pub(crate) fn is_same(&self, other: &Self, cache: &Cache) -> bool {\n-        match (self, other) {\n+    ///\n+    /// This relation is not commutative when generics are involved:\n+    ///\n+    /// ```ignore(private)\n+    /// # // see types/tests.rs:is_same_generic for the real test\n+    /// use rustdoc::format::cache::Cache;\n+    /// use rustdoc::clean::types::{Type, PrimitiveType};\n+    /// let cache = Cache::new(false);\n+    /// let generic = Type::Generic(rustc_span::symbol::sym::Any);\n+    /// let unit = Type::Primitive(PrimitiveType::Unit);\n+    /// assert!(!generic.is_same(&unit, &cache));\n+    /// assert!(unit.is_same(&generic, &cache));\n+    /// ```\n+    ///\n+    /// An owned type is also the same as its borrowed variants (this is commutative),\n+    /// but `&T` is not the same as `&mut T`.\n+    pub(crate) fn is_doc_subtype_of(&self, other: &Self, cache: &Cache) -> bool {\n+        // Strip the references so that it can compare the actual types, unless both are references.\n+        // If both are references, leave them alone and compare the mutabilities later.\n+        let (self_cleared, other_cleared) = if !self.is_borrowed_ref() || !other.is_borrowed_ref() {\n+            (self.without_borrowed_ref(), other.without_borrowed_ref())\n+        } else {\n+            (self, other)\n+        };\n+        match (self_cleared, other_cleared) {\n             // Recursive cases.\n             (Type::Tuple(a), Type::Tuple(b)) => {\n-                a.len() == b.len() && a.iter().zip(b).all(|(a, b)| a.is_same(b, cache))\n+                a.len() == b.len() && a.iter().zip(b).all(|(a, b)| a.is_doc_subtype_of(b, cache))\n             }\n-            (Type::Slice(a), Type::Slice(b)) => a.is_same(b, cache),\n-            (Type::Array(a, al), Type::Array(b, bl)) => al == bl && a.is_same(b, cache),\n+            (Type::Slice(a), Type::Slice(b)) => a.is_doc_subtype_of(b, cache),\n+            (Type::Array(a, al), Type::Array(b, bl)) => al == bl && a.is_doc_subtype_of(b, cache),\n             (Type::RawPointer(mutability, type_), Type::RawPointer(b_mutability, b_type_)) => {\n-                mutability == b_mutability && type_.is_same(b_type_, cache)\n+                mutability == b_mutability && type_.is_doc_subtype_of(b_type_, cache)\n             }\n             (\n                 Type::BorrowedRef { mutability, type_, .. },\n                 Type::BorrowedRef { mutability: b_mutability, type_: b_type_, .. },\n-            ) => mutability == b_mutability && type_.is_same(b_type_, cache),\n-            // Placeholders and generics are equal to all other types.\n+            ) => mutability == b_mutability && type_.is_doc_subtype_of(b_type_, cache),\n+            // Placeholders are equal to all other types.\n             (Type::Infer, _) | (_, Type::Infer) => true,\n-            (Type::Generic(_), _) | (_, Type::Generic(_)) => true,\n+            // Generics match everything on the right, but not on the left.\n+            // If both sides are generic, this returns true.\n+            (_, Type::Generic(_)) => true,\n+            (Type::Generic(_), _) => false,\n+            // Paths account for both the path itself and its generics.\n+            (Type::Path { path: a }, Type::Path { path: b }) => {\n+                a.def_id() == b.def_id()\n+                    && a.generics()\n+                        .zip(b.generics())\n+                        .map(|(ag, bg)| {\n+                            ag.iter().zip(bg.iter()).all(|(at, bt)| at.is_doc_subtype_of(bt, cache))\n+                        })\n+                        .unwrap_or(true)\n+            }\n             // Other cases, such as primitives, just use recursion.\n             (a, b) => a\n                 .def_id(cache)"}, {"sha": "d8c91a9680479fd81c18e4525b2ae2f9ef2ed91a", "filename": "src/librustdoc/clean/types/tests.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -10,7 +10,7 @@ use rustc_span::symbol::Symbol;\n fn create_doc_fragment(s: &str) -> Vec<DocFragment> {\n     vec![DocFragment {\n         span: DUMMY_SP,\n-        parent_module: None,\n+        item_id: None,\n         doc: Symbol::intern(s),\n         kind: DocFragmentKind::SugaredDoc,\n         indent: 0,\n@@ -69,3 +69,14 @@ fn should_not_trim() {\n     run_test(\"\\t    line1  \\n\\t    line2\", \"line1  \\nline2\");\n     run_test(\"    \\tline1  \\n    \\tline2\", \"line1  \\nline2\");\n }\n+\n+#[test]\n+fn is_same_generic() {\n+    use crate::clean::types::{PrimitiveType, Type};\n+    use crate::formats::cache::Cache;\n+    let cache = Cache::new(false);\n+    let generic = Type::Generic(rustc_span::symbol::sym::Any);\n+    let unit = Type::Primitive(PrimitiveType::Unit);\n+    assert!(!generic.is_doc_subtype_of(&unit, &cache));\n+    assert!(unit.is_doc_subtype_of(&generic, &cache));\n+}"}, {"sha": "cca50df0db2136caf765307222c515d65eb8f097", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -195,12 +195,12 @@ pub(crate) fn build_deref_target_impls(\n         if let Some(prim) = target.primitive_type() {\n             let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n             for did in prim.impls(tcx).filter(|did| !did.is_local()) {\n-                inline::build_impl(cx, None, did, None, ret);\n+                inline::build_impl(cx, did, None, ret);\n             }\n         } else if let Type::Path { path } = target {\n             let did = path.def_id();\n             if !did.is_local() {\n-                inline::build_impls(cx, None, did, None, ret);\n+                inline::build_impls(cx, did, None, ret);\n             }\n         }\n     }"}, {"sha": "c099d0e4f3f4707b94808ea7dbc5e620ecd0fe2c", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 21, "deletions": 38, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -65,23 +65,6 @@ pub(crate) fn render_item_decl_with_highlighting(src: &str, out: &mut Buffer) {\n     write!(out, \"</pre>\");\n }\n \n-/// Highlights `src` as a source code page, returning the HTML output.\n-pub(crate) fn render_source_with_highlighting(\n-    src: &str,\n-    out: &mut Buffer,\n-    line_numbers: Buffer,\n-    href_context: HrefContext<'_, '_>,\n-    decoration_info: DecorationInfo,\n-    extra: Option<&str>,\n-) {\n-    write_header(out, \"\", Some(line_numbers), Tooltip::None);\n-    if let Some(extra) = extra {\n-        out.push_str(extra);\n-    }\n-    write_code(out, src, Some(href_context), Some(decoration_info));\n-    write_footer(out, None);\n-}\n-\n fn write_header(out: &mut Buffer, class: &str, extra_content: Option<Buffer>, tooltip: Tooltip) {\n     write!(\n         out,\n@@ -143,8 +126,8 @@ fn can_merge(class1: Option<Class>, class2: Option<Class>, text: &str) -> bool {\n \n /// This type is used as a conveniency to prevent having to pass all its fields as arguments into\n /// the various functions (which became its methods).\n-struct TokenHandler<'a, 'tcx> {\n-    out: &'a mut Buffer,\n+struct TokenHandler<'a, 'tcx, F: Write> {\n+    out: &'a mut F,\n     /// It contains the closing tag and the associated `Class`.\n     closing_tags: Vec<(&'static str, Class)>,\n     /// This is used because we don't automatically generate the closing tag on `ExitSpan` in\n@@ -159,7 +142,7 @@ struct TokenHandler<'a, 'tcx> {\n     href_context: Option<HrefContext<'a, 'tcx>>,\n }\n \n-impl<'a, 'tcx> TokenHandler<'a, 'tcx> {\n+impl<'a, 'tcx, F: Write> TokenHandler<'a, 'tcx, F> {\n     fn handle_exit_span(&mut self) {\n         // We can't get the last `closing_tags` element using `pop()` because `closing_tags` is\n         // being used in `write_pending_elems`.\n@@ -211,7 +194,7 @@ impl<'a, 'tcx> TokenHandler<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Drop for TokenHandler<'a, 'tcx> {\n+impl<'a, 'tcx, F: Write> Drop for TokenHandler<'a, 'tcx, F> {\n     /// When leaving, we need to flush all pending data to not have missing content.\n     fn drop(&mut self) {\n         if self.pending_exit_span.is_some() {\n@@ -233,8 +216,8 @@ impl<'a, 'tcx> Drop for TokenHandler<'a, 'tcx> {\n /// item definition.\n ///\n /// More explanations about spans and how we use them here are provided in the\n-fn write_code(\n-    out: &mut Buffer,\n+pub(super) fn write_code(\n+    out: &mut impl Write,\n     src: &str,\n     href_context: Option<HrefContext<'_, '_>>,\n     decoration_info: Option<DecorationInfo>,\n@@ -883,7 +866,7 @@ impl<'src> Classifier<'src> {\n /// Called when we start processing a span of text that should be highlighted.\n /// The `Class` argument specifies how it should be highlighted.\n fn enter_span(\n-    out: &mut Buffer,\n+    out: &mut impl Write,\n     klass: Class,\n     href_context: &Option<HrefContext<'_, '_>>,\n ) -> &'static str {\n@@ -894,8 +877,8 @@ fn enter_span(\n }\n \n /// Called at the end of a span of highlighted text.\n-fn exit_span(out: &mut Buffer, closing_tag: &str) {\n-    out.write_str(closing_tag);\n+fn exit_span(out: &mut impl Write, closing_tag: &str) {\n+    out.write_str(closing_tag).unwrap();\n }\n \n /// Called for a span of text. If the text should be highlighted differently\n@@ -915,15 +898,15 @@ fn exit_span(out: &mut Buffer, closing_tag: &str) {\n /// will then try to find this `span` in the `span_correspondance_map`. If found, it'll then\n /// generate a link for this element (which corresponds to where its definition is located).\n fn string<T: Display>(\n-    out: &mut Buffer,\n+    out: &mut impl Write,\n     text: T,\n     klass: Option<Class>,\n     href_context: &Option<HrefContext<'_, '_>>,\n     open_tag: bool,\n ) {\n     if let Some(closing_tag) = string_without_closing_tag(out, text, klass, href_context, open_tag)\n     {\n-        out.write_str(closing_tag);\n+        out.write_str(closing_tag).unwrap();\n     }\n }\n \n@@ -937,24 +920,24 @@ fn string<T: Display>(\n ///   in `span_map.rs::collect_spans_and_sources`. If it cannot retrieve the information, then it's\n ///   the same as the second point (`klass` is `Some` but doesn't have a [`rustc_span::Span`]).\n fn string_without_closing_tag<T: Display>(\n-    out: &mut Buffer,\n+    out: &mut impl Write,\n     text: T,\n     klass: Option<Class>,\n     href_context: &Option<HrefContext<'_, '_>>,\n     open_tag: bool,\n ) -> Option<&'static str> {\n     let Some(klass) = klass\n     else {\n-        write!(out, \"{}\", text);\n+        write!(out, \"{}\", text).unwrap();\n         return None;\n     };\n     let Some(def_span) = klass.get_span()\n     else {\n         if !open_tag {\n-            write!(out, \"{}\", text);\n+            write!(out, \"{}\", text).unwrap();\n             return None;\n         }\n-        write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text);\n+        write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text).unwrap();\n         return Some(\"</span>\");\n     };\n \n@@ -1009,28 +992,28 @@ fn string_without_closing_tag<T: Display>(\n             if !open_tag {\n                 // We're already inside an element which has the same klass, no need to give it\n                 // again.\n-                write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s);\n+                write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s).unwrap();\n             } else {\n                 let klass_s = klass.as_html();\n                 if klass_s.is_empty() {\n-                    write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s);\n+                    write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s).unwrap();\n                 } else {\n-                    write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}\", klass_s, href, text_s);\n+                    write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}\", klass_s, href, text_s).unwrap();\n                 }\n             }\n             return Some(\"</a>\");\n         }\n     }\n     if !open_tag {\n-        write!(out, \"{}\", text_s);\n+        write!(out, \"{}\", text_s).unwrap();\n         return None;\n     }\n     let klass_s = klass.as_html();\n     if klass_s.is_empty() {\n-        write!(out, \"{}\", text_s);\n+        out.write_str(&text_s).unwrap();\n         Some(\"\")\n     } else {\n-        write!(out, \"<span class=\\\"{}\\\">{}\", klass_s, text_s);\n+        write!(out, \"<span class=\\\"{}\\\">{}\", klass_s, text_s).unwrap();\n         Some(\"</span>\")\n     }\n }"}, {"sha": "d75d03071f892b3089e344e1fe261382a1efe0a5", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1294,7 +1294,7 @@ pub(crate) fn notable_traits_button(ty: &clean::Type, cx: &mut Context<'_>) -> O\n     if let Some(impls) = cx.cache().impls.get(&did) {\n         for i in impls {\n             let impl_ = i.inner_impl();\n-            if !impl_.for_.without_borrowed_ref().is_same(ty.without_borrowed_ref(), cx.cache()) {\n+            if !ty.is_doc_subtype_of(&impl_.for_, cx.cache()) {\n                 // Two different types might have the same did,\n                 // without actually being the same.\n                 continue;\n@@ -1330,7 +1330,7 @@ fn notable_traits_decl(ty: &clean::Type, cx: &Context<'_>) -> (String, String) {\n \n     for i in impls {\n         let impl_ = i.inner_impl();\n-        if !impl_.for_.without_borrowed_ref().is_same(ty.without_borrowed_ref(), cx.cache()) {\n+        if !ty.is_doc_subtype_of(&impl_.for_, cx.cache()) {\n             // Two different types might have the same did,\n             // without actually being the same.\n             continue;"}, {"sha": "1d298f52f7588d2b08b163d6bd986beb665c5044", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,12 +1,14 @@\n use crate::clean;\n use crate::docfs::PathError;\n use crate::error::Error;\n+use crate::html::format;\n use crate::html::format::Buffer;\n use crate::html::highlight;\n use crate::html::layout;\n use crate::html::render::Context;\n use crate::visit::DocVisitor;\n \n+use askama::Template;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::TyCtxt;\n@@ -16,6 +18,7 @@ use rustc_span::source_map::FileName;\n use std::cell::RefCell;\n use std::ffi::OsStr;\n use std::fs;\n+use std::ops::RangeInclusive;\n use std::path::{Component, Path, PathBuf};\n use std::rc::Rc;\n \n@@ -299,39 +302,32 @@ pub(crate) fn print_src(\n     decoration_info: highlight::DecorationInfo,\n     source_context: SourceContext,\n ) {\n+    #[derive(Template)]\n+    #[template(path = \"source.html\")]\n+    struct Source<Code: std::fmt::Display> {\n+        embedded: bool,\n+        needs_expansion: bool,\n+        lines: RangeInclusive<usize>,\n+        code_html: Code,\n+    }\n     let lines = s.lines().count();\n-    let mut line_numbers = Buffer::empty_from(buf);\n-    let extra;\n-    line_numbers.write_str(\"<pre class=\\\"src-line-numbers\\\">\");\n+    let (embedded, needs_expansion, lines) = match source_context {\n+        SourceContext::Standalone => (false, false, 1..=lines),\n+        SourceContext::Embedded { offset, needs_expansion } => {\n+            (true, needs_expansion, (1 + offset)..=(lines + offset))\n+        }\n+    };\n     let current_href = context\n         .href_from_span(clean::Span::new(file_span), false)\n         .expect(\"only local crates should have sources emitted\");\n-    match source_context {\n-        SourceContext::Standalone => {\n-            extra = None;\n-            for line in 1..=lines {\n-                writeln!(line_numbers, \"<a href=\\\"#{line}\\\" id=\\\"{line}\\\">{line}</a>\")\n-            }\n-        }\n-        SourceContext::Embedded { offset, needs_expansion } => {\n-            extra = if needs_expansion {\n-                Some(r#\"<button class=\"expand\">&varr;</button>\"#)\n-            } else {\n-                None\n-            };\n-            for line_number in 1..=lines {\n-                let line = line_number + offset;\n-                writeln!(line_numbers, \"<span>{line}</span>\")\n-            }\n-        }\n-    }\n-    line_numbers.write_str(\"</pre>\");\n-    highlight::render_source_with_highlighting(\n-        s,\n-        buf,\n-        line_numbers,\n-        highlight::HrefContext { context, file_span, root_path, current_href },\n-        decoration_info,\n-        extra,\n-    );\n+    let code = format::display_fn(move |fmt| {\n+        highlight::write_code(\n+            fmt,\n+            s,\n+            Some(highlight::HrefContext { context, file_span, root_path, current_href }),\n+            Some(decoration_info),\n+        );\n+        Ok(())\n+    });\n+    Source { embedded, needs_expansion, lines, code_html: code }.render_into(buf).unwrap();\n }"}, {"sha": "7d578b5c7754a152138e43866ff419bad835c49c", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -217,7 +217,7 @@ ul.all-items {\n a.anchor,\n .small-section-header a,\n #source-sidebar a,\n-pre.rust a,\n+.rust a,\n .sidebar h2 a,\n .sidebar h3 a,\n .mobile-topbar h2 a,\n@@ -228,43 +228,43 @@ h1 a,\n \tcolor: var(--main-color);\n }\n \n-.content span.enum, .content a.enum,\n-.content span.struct, .content a.struct,\n-.content span.union, .content a.union,\n-.content span.primitive, .content a.primitive,\n-.content span.type, .content a.type,\n-.content span.foreigntype, .content a.foreigntype {\n+span.enum, a.enum,\n+span.struct, a.struct,\n+span.union, a.union,\n+span.primitive, a.primitive,\n+span.type, a.type,\n+span.foreigntype, a.foreigntype {\n \tcolor: var(--type-link-color);\n }\n \n-.content span.trait, .content a.trait,\n-.content span.traitalias, .content a.traitalias {\n+span.trait, a.trait,\n+span.traitalias, a.traitalias {\n \tcolor: var(--trait-link-color);\n }\n \n-.content span.associatedtype, .content a.associatedtype,\n-.content span.constant, .content a.constant,\n-.content span.static, .content a.static {\n+span.associatedtype, a.associatedtype,\n+span.constant, a.constant,\n+span.static, a.static {\n \tcolor: var(--assoc-item-link-color);\n }\n \n-.content span.fn, .content a.fn,\n-.content span.method, .content a.method,\n-.content span.tymethod, .content a.tymethod {\n+span.fn, a.fn,\n+span.method, a.method,\n+span.tymethod, a.tymethod {\n \tcolor: var(--function-link-color);\n }\n \n-.content span.attr, .content a.attr,\n-.content span.derive, .content a.derive,\n-.content span.macro, .content a.macro {\n+span.attr, a.attr,\n+span.derive, a.derive,\n+span.macro, a.macro {\n \tcolor: var(--macro-link-color);\n }\n \n-.content span.mod, .content a.mod {\n+span.mod, a.mod {\n \tcolor: var(--mod-link-color);\n }\n \n-.content span.keyword, .content a.keyword {\n+span.keyword, a.keyword {\n \tcolor: var(--keyword-link-color);\n }\n \n@@ -713,7 +713,7 @@ h2.small-section-header > .anchor {\n }\n \n .main-heading a:hover,\n-.example-wrap > pre.rust a:hover,\n+.example-wrap > .rust a:hover,\n .all-items a:hover,\n .docblock a:not(.test-arrow):not(.scrape-help):not(.tooltip):hover,\n .docblock-short a:not(.test-arrow):not(.scrape-help):not(.tooltip):hover,"}, {"sha": "a224ff12f448eea51ad06ee29d42dfc7af61d75f", "filename": "src/librustdoc/html/templates/source.html", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsource.html", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsource.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsource.html?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,19 @@\n+<div class=\"example-wrap\"> {# #}\n+    <pre class=\"src-line-numbers\">\n+        {% for line in lines.clone() %}\n+            {% if embedded %}\n+                <span>{{line|safe}}</span>\n+            {%~ else %}\n+                <a href=\"#{{line|safe}}\" id=\"{{line|safe}}\">{{line|safe}}</a>\n+            {%~ endif %}\n+        {% endfor %}\n+    </pre> {# #}\n+    <pre class=\"rust\"> {# #}\n+        <code>\n+            {% if needs_expansion %}\n+                <button class=\"expand\">&varr;</button>\n+            {% endif %}\n+            {{code_html|safe}}\n+        </code> {# #}\n+    </pre> {# #}\n+</div>"}, {"sha": "0da56e70ed582e40d1aeb11bfb95d310b0b87fb8", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 304, "deletions": 241, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -28,7 +28,7 @@ use std::mem;\n use std::ops::Range;\n \n use crate::clean::{self, utils::find_nearest_parent_module};\n-use crate::clean::{Crate, Item, ItemId, ItemLink, PrimitiveType};\n+use crate::clean::{Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::html::markdown::{markdown_links, MarkdownLink};\n use crate::lint::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS};\n@@ -42,13 +42,23 @@ pub(crate) const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n };\n \n fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    let mut collector =\n-        LinkCollector { cx, mod_ids: Vec::new(), visited_links: FxHashMap::default() };\n+    let mut collector = LinkCollector { cx, visited_links: FxHashMap::default() };\n     collector.visit_crate(&krate);\n     krate\n }\n \n-#[derive(Copy, Clone, Debug, Hash)]\n+fn filter_assoc_items_by_name_and_namespace<'a>(\n+    tcx: TyCtxt<'a>,\n+    assoc_items_of: DefId,\n+    ident: Ident,\n+    ns: Namespace,\n+) -> impl Iterator<Item = &ty::AssocItem> + 'a {\n+    tcx.associated_items(assoc_items_of).filter_by_name_unhygienic(ident.name).filter(move |item| {\n+        item.kind.namespace() == ns && tcx.hygienic_eq(ident, item.ident(tcx), assoc_items_of)\n+    })\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq)]\n enum Res {\n     Def(DefKind, DefId),\n     Primitive(PrimitiveType),\n@@ -60,7 +70,7 @@ impl Res {\n     fn descr(self) -> &'static str {\n         match self {\n             Res::Def(kind, id) => ResolveRes::Def(kind, id).descr(),\n-            Res::Primitive(_) => \"builtin type\",\n+            Res::Primitive(_) => \"primitive type\",\n         }\n     }\n \n@@ -149,7 +159,7 @@ impl TryFrom<ResolveRes> for Res {\n #[derive(Debug)]\n struct UnresolvedPath<'a> {\n     /// Item on which the link is resolved, used for resolving `Self`.\n-    item_id: ItemId,\n+    item_id: DefId,\n     /// The scope the link was resolved in.\n     module_id: DefId,\n     /// If part of the link resolved, this has the `Res`.\n@@ -225,7 +235,7 @@ impl UrlFragment {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n struct ResolutionInfo {\n-    item_id: ItemId,\n+    item_id: DefId,\n     module_id: DefId,\n     dis: Option<Disambiguator>,\n     path_str: Box<str>,\n@@ -242,11 +252,6 @@ struct DiagnosticInfo<'a> {\n \n struct LinkCollector<'a, 'tcx> {\n     cx: &'a mut DocContext<'tcx>,\n-    /// A stack of modules used to decide what scope to resolve in.\n-    ///\n-    /// The last module will be used if the parent scope of the current item is\n-    /// unknown.\n-    mod_ids: Vec<DefId>,\n     /// Cache the resolved links so we can avoid resolving (and emitting errors for) the same link.\n     /// The link will be `None` if it could not be resolved (i.e. the error was cached).\n     visited_links: FxHashMap<ResolutionInfo, Option<(Res, Option<UrlFragment>)>>,\n@@ -262,7 +267,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn variant_field<'path>(\n         &self,\n         path_str: &'path str,\n-        item_id: ItemId,\n+        item_id: DefId,\n         module_id: DefId,\n     ) -> Result<(Res, DefId), UnresolvedPath<'path>> {\n         let tcx = self.cx.tcx;\n@@ -323,45 +328,50 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         prim_ty: PrimitiveType,\n         ns: Namespace,\n         item_name: Symbol,\n-    ) -> Option<(Res, DefId)> {\n+    ) -> Vec<(Res, DefId)> {\n         let tcx = self.cx.tcx;\n \n-        prim_ty.impls(tcx).find_map(|impl_| {\n-            tcx.associated_items(impl_)\n-                .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n+        prim_ty\n+            .impls(tcx)\n+            .flat_map(|impl_| {\n+                filter_assoc_items_by_name_and_namespace(\n+                    tcx,\n+                    impl_,\n+                    Ident::with_dummy_span(item_name),\n+                    ns,\n+                )\n                 .map(|item| (Res::Primitive(prim_ty), item.def_id))\n-        })\n+            })\n+            .collect::<Vec<_>>()\n     }\n \n-    fn resolve_self_ty(&self, path_str: &str, ns: Namespace, item_id: ItemId) -> Option<Res> {\n+    fn resolve_self_ty(&self, path_str: &str, ns: Namespace, item_id: DefId) -> Option<Res> {\n         if ns != TypeNS || path_str != \"Self\" {\n             return None;\n         }\n \n         let tcx = self.cx.tcx;\n-        item_id\n-            .as_def_id()\n-            .map(|def_id| match tcx.def_kind(def_id) {\n-                def_kind @ (DefKind::AssocFn\n-                | DefKind::AssocConst\n-                | DefKind::AssocTy\n-                | DefKind::Variant\n-                | DefKind::Field) => {\n-                    let parent_def_id = tcx.parent(def_id);\n-                    if def_kind == DefKind::Field && tcx.def_kind(parent_def_id) == DefKind::Variant\n-                    {\n-                        tcx.parent(parent_def_id)\n-                    } else {\n-                        parent_def_id\n-                    }\n+        let self_id = match tcx.def_kind(item_id) {\n+            def_kind @ (DefKind::AssocFn\n+            | DefKind::AssocConst\n+            | DefKind::AssocTy\n+            | DefKind::Variant\n+            | DefKind::Field) => {\n+                let parent_def_id = tcx.parent(item_id);\n+                if def_kind == DefKind::Field && tcx.def_kind(parent_def_id) == DefKind::Variant {\n+                    tcx.parent(parent_def_id)\n+                } else {\n+                    parent_def_id\n                 }\n-                _ => def_id,\n-            })\n-            .and_then(|self_id| match tcx.def_kind(self_id) {\n-                DefKind::Impl { .. } => self.def_id_to_res(self_id),\n-                DefKind::Use => None,\n-                def_kind => Some(Res::Def(def_kind, self_id)),\n-            })\n+            }\n+            _ => item_id,\n+        };\n+\n+        match tcx.def_kind(self_id) {\n+            DefKind::Impl { .. } => self.def_id_to_res(self_id),\n+            DefKind::Use => None,\n+            def_kind => Some(Res::Def(def_kind, self_id)),\n+        }\n     }\n \n     /// Convenience wrapper around `doc_link_resolutions`.\n@@ -373,7 +383,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &self,\n         path_str: &str,\n         ns: Namespace,\n-        item_id: ItemId,\n+        item_id: DefId,\n         module_id: DefId,\n     ) -> Option<Res> {\n         if let res @ Some(..) = self.resolve_self_ty(path_str, ns, item_id) {\n@@ -400,16 +410,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &mut self,\n         path_str: &'path str,\n         ns: Namespace,\n-        item_id: ItemId,\n+        item_id: DefId,\n         module_id: DefId,\n-    ) -> Result<(Res, Option<DefId>), UnresolvedPath<'path>> {\n+    ) -> Result<Vec<(Res, Option<DefId>)>, UnresolvedPath<'path>> {\n         if let Some(res) = self.resolve_path(path_str, ns, item_id, module_id) {\n             return Ok(match res {\n                 Res::Def(\n                     DefKind::AssocFn | DefKind::AssocConst | DefKind::AssocTy | DefKind::Variant,\n                     def_id,\n-                ) => (Res::from_def_id(self.cx.tcx, self.cx.tcx.parent(def_id)), Some(def_id)),\n-                _ => (res, None),\n+                ) => {\n+                    vec![(Res::from_def_id(self.cx.tcx, self.cx.tcx.parent(def_id)), Some(def_id))]\n+                }\n+                _ => vec![(res, None)],\n             });\n         } else if ns == MacroNS {\n             return Err(UnresolvedPath {\n@@ -444,14 +456,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // links to primitives when `#[doc(primitive)]` is present. It should give an ambiguity\n         // error instead and special case *only* modules with `#[doc(primitive)]`, not all\n         // primitives.\n-        resolve_primitive(&path_root, TypeNS)\n+        match resolve_primitive(&path_root, TypeNS)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, item_id, module_id))\n             .and_then(|ty_res| {\n-                self.resolve_associated_item(ty_res, item_name, ns, module_id).map(Ok)\n-            })\n-            .unwrap_or_else(|| {\n+                let candidates = self\n+                    .resolve_associated_item(ty_res, item_name, ns, module_id)\n+                    .into_iter()\n+                    .map(|(res, def_id)| (res, Some(def_id)))\n+                    .collect::<Vec<_>>();\n+                if !candidates.is_empty() { Some(candidates) } else { None }\n+            }) {\n+            Some(r) => Ok(r),\n+            None => {\n                 if ns == Namespace::ValueNS {\n                     self.variant_field(path_str, item_id, module_id)\n+                        .map(|(res, def_id)| vec![(res, Some(def_id))])\n                 } else {\n                     Err(UnresolvedPath {\n                         item_id,\n@@ -460,8 +479,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         unresolved: path_root.into(),\n                     })\n                 }\n-            })\n-            .map(|(res, def_id)| (res, Some(def_id)))\n+            }\n+        }\n     }\n \n     /// Convert a DefId to a Res, where possible.\n@@ -543,24 +562,31 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         item_name: Symbol,\n         ns: Namespace,\n         module_id: DefId,\n-    ) -> Option<(Res, DefId)> {\n+    ) -> Vec<(Res, DefId)> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n             Res::Primitive(prim) => {\n-                self.resolve_primitive_associated_item(prim, ns, item_name).or_else(|| {\n+                let items = self.resolve_primitive_associated_item(prim, ns, item_name);\n+                if !items.is_empty() {\n+                    items\n+                // Inherent associated items take precedence over items that come from trait impls.\n+                } else {\n                     self.primitive_type_to_ty(prim)\n-                        .and_then(|ty| {\n+                        .map(|ty| {\n                             resolve_associated_trait_item(ty, module_id, item_name, ns, self.cx)\n+                                .iter()\n+                                .map(|item| (root_res, item.def_id))\n+                                .collect::<Vec<_>>()\n                         })\n-                        .map(|item| (root_res, item.def_id))\n-                })\n+                        .unwrap_or(Vec::new())\n+                }\n             }\n             Res::Def(DefKind::TyAlias, did) => {\n                 // Resolve the link on the type the alias points to.\n                 // FIXME: if the associated item is defined directly on the type alias,\n                 // it will show up on its documentation page, we should link there instead.\n-                let res = self.def_id_to_res(did)?;\n+                let Some(res) = self.def_id_to_res(did) else { return Vec::new() };\n                 self.resolve_associated_item(res, item_name, ns, module_id)\n             }\n             Res::Def(\n@@ -574,7 +600,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::Adt(adt_def, _) => {\n                             for variant in adt_def.variants() {\n                                 if variant.name == item_name {\n-                                    return Some((root_res, variant.def_id));\n+                                    return vec![(root_res, variant.def_id)];\n                                 }\n                             }\n                         }\n@@ -583,43 +609,46 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n \n                 // Checks if item_name belongs to `impl SomeItem`\n-                let assoc_item = tcx\n+                let mut assoc_items: Vec<_> = tcx\n                     .inherent_impls(did)\n                     .iter()\n                     .flat_map(|&imp| {\n-                        tcx.associated_items(imp).find_by_name_and_namespace(\n+                        filter_assoc_items_by_name_and_namespace(\n                             tcx,\n+                            imp,\n                             Ident::with_dummy_span(item_name),\n                             ns,\n-                            imp,\n                         )\n                     })\n-                    .copied()\n-                    // There should only ever be one associated item that matches from any inherent impl\n-                    .next()\n+                    .map(|item| (root_res, item.def_id))\n+                    .collect();\n+\n+                if assoc_items.is_empty() {\n                     // Check if item_name belongs to `impl SomeTrait for SomeItem`\n                     // FIXME(#74563): This gives precedence to `impl SomeItem`:\n                     // Although having both would be ambiguous, use impl version for compatibility's sake.\n                     // To handle that properly resolve() would have to support\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n-                    .or_else(|| {\n-                        resolve_associated_trait_item(\n-                            tcx.type_of(did).subst_identity(),\n-                            module_id,\n-                            item_name,\n-                            ns,\n-                            self.cx,\n-                        )\n-                    });\n+                    assoc_items = resolve_associated_trait_item(\n+                        tcx.type_of(did).subst_identity(),\n+                        module_id,\n+                        item_name,\n+                        ns,\n+                        self.cx,\n+                    )\n+                    .into_iter()\n+                    .map(|item| (root_res, item.def_id))\n+                    .collect::<Vec<_>>();\n+                }\n \n-                debug!(\"got associated item {:?}\", assoc_item);\n+                debug!(\"got associated item {:?}\", assoc_items);\n \n-                if let Some(item) = assoc_item {\n-                    return Some((root_res, item.def_id));\n+                if !assoc_items.is_empty() {\n+                    return assoc_items;\n                 }\n \n                 if ns != Namespace::ValueNS {\n-                    return None;\n+                    return Vec::new();\n                 }\n                 debug!(\"looking for fields named {} for {:?}\", item_name, did);\n                 // FIXME: this doesn't really belong in `associated_item` (maybe `variant_field` is better?)\n@@ -639,20 +668,27 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 // field syntax) and are handled by the compiler's resolver.\n                 let def = match tcx.type_of(did).subst_identity().kind() {\n                     ty::Adt(def, _) if !def.is_enum() => def,\n-                    _ => return None,\n+                    _ => return Vec::new(),\n                 };\n-                let field =\n-                    def.non_enum_variant().fields.iter().find(|item| item.name == item_name)?;\n-                Some((root_res, field.did))\n+                def.non_enum_variant()\n+                    .fields\n+                    .iter()\n+                    .filter(|field| field.name == item_name)\n+                    .map(|field| (root_res, field.did))\n+                    .collect::<Vec<_>>()\n             }\n-            Res::Def(DefKind::Trait, did) => tcx\n-                .associated_items(did)\n-                .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n-                .map(|item| {\n-                    let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                    (res, item.def_id)\n-                }),\n-            _ => None,\n+            Res::Def(DefKind::Trait, did) => filter_assoc_items_by_name_and_namespace(\n+                tcx,\n+                did,\n+                Ident::with_dummy_span(item_name),\n+                ns,\n+            )\n+            .map(|item| {\n+                let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n+                (res, item.def_id)\n+            })\n+            .collect::<Vec<_>>(),\n+            _ => Vec::new(),\n         }\n     }\n }\n@@ -672,27 +708,34 @@ fn resolve_associated_trait_item<'a>(\n     item_name: Symbol,\n     ns: Namespace,\n     cx: &mut DocContext<'a>,\n-) -> Option<ty::AssocItem> {\n+) -> Vec<ty::AssocItem> {\n     // FIXME: this should also consider blanket impls (`impl<T> X for T`). Unfortunately\n     // `get_auto_trait_and_blanket_impls` is broken because the caching behavior is wrong. In the\n     // meantime, just don't look for these blanket impls.\n \n     // Next consider explicit impls: `impl MyTrait for MyType`\n     // Give precedence to inherent impls.\n     let traits = trait_impls_for(cx, ty, module);\n+    let tcx = cx.tcx;\n     debug!(\"considering traits {:?}\", traits);\n-    let mut candidates = traits.iter().filter_map(|&(impl_, trait_)| {\n-        cx.tcx\n-            .associated_items(trait_)\n-            .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n-            .map(|trait_assoc| {\n-                trait_assoc_to_impl_assoc_item(cx.tcx, impl_, trait_assoc.def_id)\n+    let candidates = traits\n+        .iter()\n+        .flat_map(|&(impl_, trait_)| {\n+            filter_assoc_items_by_name_and_namespace(\n+                cx.tcx,\n+                trait_,\n+                Ident::with_dummy_span(item_name),\n+                ns,\n+            )\n+            .map(move |trait_assoc| {\n+                trait_assoc_to_impl_assoc_item(tcx, impl_, trait_assoc.def_id)\n                     .unwrap_or(*trait_assoc)\n             })\n-    });\n+        })\n+        .collect::<Vec<_>>();\n     // FIXME(#74563): warn about ambiguity\n-    debug!(\"the candidates were {:?}\", candidates.clone().collect::<Vec<_>>());\n-    candidates.next()\n+    debug!(\"the candidates were {:?}\", candidates);\n+    candidates\n }\n \n /// Find the associated item in the impl `impl_id` that corresponds to the\n@@ -766,61 +809,21 @@ fn trait_impls_for<'a>(\n /// Check for resolve collisions between a trait and its derive.\n ///\n /// These are common and we should just resolve to the trait in that case.\n-fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_>>>) -> bool {\n-    matches!(\n-        *ns,\n-        PerNS {\n-            type_ns: Ok((Res::Def(DefKind::Trait, _), _)),\n-            macro_ns: Ok((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n-            ..\n-        }\n-    )\n+fn is_derive_trait_collision<T>(ns: &PerNS<Result<Vec<(Res, T)>, ResolutionFailure<'_>>>) -> bool {\n+    if let (&Ok(ref type_ns), &Ok(ref macro_ns)) = (&ns.type_ns, &ns.macro_ns) {\n+        type_ns.iter().any(|(res, _)| matches!(res, Res::Def(DefKind::Trait, _)))\n+            && macro_ns\n+                .iter()\n+                .any(|(res, _)| matches!(res, Res::Def(DefKind::Macro(MacroKind::Derive), _)))\n+    } else {\n+        false\n+    }\n }\n \n impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n-        let parent_node =\n-            item.item_id.as_def_id().and_then(|did| find_nearest_parent_module(self.cx.tcx, did));\n-        if parent_node.is_some() {\n-            trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.item_id);\n-        }\n-\n-        let inner_docs = item.inner_docs(self.cx.tcx);\n-\n-        if item.is_mod() && inner_docs {\n-            self.mod_ids.push(item.item_id.expect_def_id());\n-        }\n-\n-        // We want to resolve in the lexical scope of the documentation.\n-        // In the presence of re-exports, this is not the same as the module of the item.\n-        // Rather than merging all documentation into one, resolve it one attribute at a time\n-        // so we know which module it came from.\n-        for (parent_module, doc) in prepare_to_doc_link_resolution(&item.attrs.doc_strings) {\n-            if !may_have_doc_links(&doc) {\n-                continue;\n-            }\n-            debug!(\"combined_docs={}\", doc);\n-            // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n-            // This is a degenerate case and it's not supported by rustdoc.\n-            let parent_node = parent_module.or(parent_node);\n-            for md_link in preprocessed_markdown_links(&doc) {\n-                let link = self.resolve_link(item, &doc, parent_node, &md_link);\n-                if let Some(link) = link {\n-                    self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n-                }\n-            }\n-        }\n-\n-        if item.is_mod() {\n-            if !inner_docs {\n-                self.mod_ids.push(item.item_id.expect_def_id());\n-            }\n-\n-            self.visit_item_recur(item);\n-            self.mod_ids.pop();\n-        } else {\n-            self.visit_item_recur(item)\n-        }\n+        self.resolve_links(item);\n+        self.visit_item_recur(item)\n     }\n }\n \n@@ -946,14 +949,41 @@ fn preprocessed_markdown_links(s: &str) -> Vec<PreprocessedMarkdownLink> {\n }\n \n impl LinkCollector<'_, '_> {\n+    fn resolve_links(&mut self, item: &Item) {\n+        // We want to resolve in the lexical scope of the documentation.\n+        // In the presence of re-exports, this is not the same as the module of the item.\n+        // Rather than merging all documentation into one, resolve it one attribute at a time\n+        // so we know which module it came from.\n+        for (item_id, doc) in prepare_to_doc_link_resolution(&item.attrs.doc_strings) {\n+            if !may_have_doc_links(&doc) {\n+                continue;\n+            }\n+            debug!(\"combined_docs={}\", doc);\n+            // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n+            // This is a degenerate case and it's not supported by rustdoc.\n+            let item_id = item_id.unwrap_or_else(|| item.item_id.expect_def_id());\n+            let module_id = match self.cx.tcx.def_kind(item_id) {\n+                DefKind::Mod if item.inner_docs(self.cx.tcx) => item_id,\n+                _ => find_nearest_parent_module(self.cx.tcx, item_id).unwrap(),\n+            };\n+            for md_link in preprocessed_markdown_links(&doc) {\n+                let link = self.resolve_link(item, item_id, module_id, &doc, &md_link);\n+                if let Some(link) = link {\n+                    self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n+                }\n+            }\n+        }\n+    }\n+\n     /// This is the entry point for resolving an intra-doc link.\n     ///\n     /// FIXME(jynelson): this is way too many arguments\n     fn resolve_link(\n         &mut self,\n         item: &Item,\n+        item_id: DefId,\n+        module_id: DefId,\n         dox: &str,\n-        parent_node: Option<DefId>,\n         link: &PreprocessedMarkdownLink,\n     ) -> Option<ItemLink> {\n         let PreprocessedMarkdownLink(pp_link, ori_link) = link;\n@@ -970,25 +1000,9 @@ impl LinkCollector<'_, '_> {\n             pp_link.as_ref().map_err(|err| err.report(self.cx, diag_info.clone())).ok()?;\n         let disambiguator = *disambiguator;\n \n-        // In order to correctly resolve intra-doc links we need to\n-        // pick a base AST node to work from.  If the documentation for\n-        // this module came from an inner comment (//!) then we anchor\n-        // our name resolution *inside* the module.  If, on the other\n-        // hand it was an outer comment (///) then we anchor the name\n-        // resolution in the parent module on the basis that the names\n-        // used are more likely to be intended to be parent names.  For\n-        // this, we set base_node to None for inner comments since\n-        // we've already pushed this node onto the resolution stack but\n-        // for outer comments we explicitly try and resolve against the\n-        // parent_node first.\n-        let inner_docs = item.inner_docs(self.cx.tcx);\n-        let base_node =\n-            if item.is_mod() && inner_docs { self.mod_ids.last().copied() } else { parent_node };\n-        let module_id = base_node.expect(\"doc link without parent module\");\n-\n         let (mut res, fragment) = self.resolve_with_disambiguator_cached(\n             ResolutionInfo {\n-                item_id: item.item_id,\n+                item_id,\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.clone(),\n@@ -1015,15 +1029,15 @@ impl LinkCollector<'_, '_> {\n                     res = prim;\n                 } else {\n                     // `[char]` when a `char` module is in scope\n-                    let candidates = vec![res, prim];\n-                    ambiguity_error(self.cx, diag_info, path_str, candidates);\n+                    let candidates = &[(res, res.def_id(self.cx.tcx)), (prim, None)];\n+                    ambiguity_error(self.cx, &diag_info, path_str, candidates);\n                     return None;\n                 }\n             }\n         }\n \n         match res {\n-            Res::Primitive(prim) => {\n+            Res::Primitive(_) => {\n                 if let Some(UrlFragment::Item(id)) = fragment {\n                     // We're actually resolving an associated item of a primitive, so we need to\n                     // verify the disambiguator (if any) matches the type of the associated item.\n@@ -1043,15 +1057,6 @@ impl LinkCollector<'_, '_> {\n                         item,\n                         &diag_info,\n                     )?;\n-\n-                    // FIXME: it would be nice to check that the feature gate was enabled in the original crate, not just ignore it altogether.\n-                    // However I'm not sure how to check that across crates.\n-                    if prim == PrimitiveType::RawPointer\n-                        && item.item_id.is_local()\n-                        && !self.cx.tcx.features().intra_doc_pointers\n-                    {\n-                        self.report_rawptr_assoc_feature_gate(dox, ori_link, item);\n-                    }\n                 } else {\n                     match disambiguator {\n                         Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {}\n@@ -1172,10 +1177,9 @@ impl LinkCollector<'_, '_> {\n         report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, diag_info, callback);\n     }\n \n-    fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &MarkdownLink, item: &Item) {\n-        let span =\n-            super::source_span_for_markdown_range(self.cx.tcx, dox, &ori_link.range, &item.attrs)\n-                .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n+    fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &Range<usize>, item: &Item) {\n+        let span = super::source_span_for_markdown_range(self.cx.tcx, dox, ori_link, &item.attrs)\n+            .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n         rustc_session::parse::feature_err(\n             &self.cx.tcx.sess.parse_sess,\n             sym::intra_doc_pointers,\n@@ -1200,7 +1204,31 @@ impl LinkCollector<'_, '_> {\n             }\n         }\n \n-        let res = self.resolve_with_disambiguator(&key, diag.clone()).and_then(|(res, def_id)| {\n+        let mut candidates = self.resolve_with_disambiguator(&key, diag.clone());\n+\n+        // FIXME: it would be nice to check that the feature gate was enabled in the original crate, not just ignore it altogether.\n+        // However I'm not sure how to check that across crates.\n+        if let Some(candidate) = candidates.get(0) &&\n+            candidate.0 == Res::Primitive(PrimitiveType::RawPointer) &&\n+            key.path_str.contains(\"::\") // We only want to check this if this is an associated item.\n+        {\n+            if key.item_id.is_local() && !self.cx.tcx.features().intra_doc_pointers {\n+                self.report_rawptr_assoc_feature_gate(diag.dox, &diag.link_range, diag.item);\n+                return None;\n+            } else {\n+                candidates = vec![candidates[0]];\n+            }\n+        }\n+\n+        // If there are multiple items with the same \"kind\" (for example, both \"associated types\")\n+        // and after removing duplicated kinds, only one remains, the `ambiguity_error` function\n+        // won't emit an error. So at this point, we can just take the first candidate as it was\n+        // the first retrieved and use it to generate the link.\n+        if candidates.len() > 1 && !ambiguity_error(self.cx, &diag, &key.path_str, &candidates) {\n+            candidates = vec![candidates[0]];\n+        }\n+\n+        if let &[(res, def_id)] = candidates.as_slice() {\n             let fragment = match (&key.extra_fragment, def_id) {\n                 (Some(_), Some(def_id)) => {\n                     report_anchor_conflict(self.cx, diag, def_id);\n@@ -1210,13 +1238,15 @@ impl LinkCollector<'_, '_> {\n                 (None, Some(def_id)) => Some(UrlFragment::Item(def_id)),\n                 (None, None) => None,\n             };\n-            Some((res, fragment))\n-        });\n+            let r = Some((res, fragment));\n+            self.visited_links.insert(key, r.clone());\n+            return r;\n+        }\n \n-        if res.is_some() || cache_errors {\n-            self.visited_links.insert(key, res.clone());\n+        if cache_errors {\n+            self.visited_links.insert(key, None);\n         }\n-        res\n+        None\n     }\n \n     /// After parsing the disambiguator, resolve the main part of the link.\n@@ -1225,16 +1255,16 @@ impl LinkCollector<'_, '_> {\n         &mut self,\n         key: &ResolutionInfo,\n         diag: DiagnosticInfo<'_>,\n-    ) -> Option<(Res, Option<DefId>)> {\n+    ) -> Vec<(Res, Option<DefId>)> {\n         let disambiguator = key.dis;\n         let path_str = &key.path_str;\n         let item_id = key.item_id;\n-        let base_node = key.module_id;\n+        let module_id = key.module_id;\n \n         match disambiguator.map(Disambiguator::ns) {\n             Some(expected_ns) => {\n-                match self.resolve(path_str, expected_ns, item_id, base_node) {\n-                    Ok(res) => Some(res),\n+                match self.resolve(path_str, expected_ns, item_id, module_id) {\n+                    Ok(candidates) => candidates,\n                     Err(err) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n                         // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`.\n@@ -1243,10 +1273,11 @@ impl LinkCollector<'_, '_> {\n                         for other_ns in [TypeNS, ValueNS, MacroNS] {\n                             if other_ns != expected_ns {\n                                 if let Ok(res) =\n-                                    self.resolve(path_str, other_ns, item_id, base_node)\n+                                    self.resolve(path_str, other_ns, item_id, module_id) &&\n+                                    !res.is_empty()\n                                 {\n                                     err = ResolutionFailure::WrongNamespace {\n-                                        res: full_res(self.cx.tcx, res),\n+                                        res: full_res(self.cx.tcx, res[0]),\n                                         expected_ns,\n                                     };\n                                     break;\n@@ -1260,25 +1291,33 @@ impl LinkCollector<'_, '_> {\n             None => {\n                 // Try everything!\n                 let mut candidate = |ns| {\n-                    self.resolve(path_str, ns, item_id, base_node)\n+                    self.resolve(path_str, ns, item_id, module_id)\n                         .map_err(ResolutionFailure::NotResolved)\n                 };\n \n                 let candidates = PerNS {\n                     macro_ns: candidate(MacroNS),\n                     type_ns: candidate(TypeNS),\n-                    value_ns: candidate(ValueNS).and_then(|(res, def_id)| {\n-                        match res {\n-                            // Constructors are picked up in the type namespace.\n-                            Res::Def(DefKind::Ctor(..), _) => {\n-                                Err(ResolutionFailure::WrongNamespace { res, expected_ns: TypeNS })\n+                    value_ns: candidate(ValueNS).and_then(|v_res| {\n+                        for (res, _) in v_res.iter() {\n+                            match res {\n+                                // Constructors are picked up in the type namespace.\n+                                Res::Def(DefKind::Ctor(..), _) => {\n+                                    return Err(ResolutionFailure::WrongNamespace {\n+                                        res: *res,\n+                                        expected_ns: TypeNS,\n+                                    });\n+                                }\n+                                _ => {}\n                             }\n-                            _ => Ok((res, def_id)),\n                         }\n+                        Ok(v_res)\n                     }),\n                 };\n \n-                let len = candidates.iter().filter(|res| res.is_ok()).count();\n+                let len = candidates\n+                    .iter()\n+                    .fold(0, |acc, res| if let Ok(res) = res { acc + res.len() } else { acc });\n \n                 if len == 0 {\n                     return resolution_failure(\n@@ -1288,22 +1327,21 @@ impl LinkCollector<'_, '_> {\n                         disambiguator,\n                         candidates.into_iter().filter_map(|res| res.err()).collect(),\n                     );\n-                }\n-\n-                if len == 1 {\n-                    Some(candidates.into_iter().find_map(|res| res.ok()).unwrap())\n-                } else if len == 2 && is_derive_trait_collision(&candidates) {\n-                    Some(candidates.type_ns.unwrap())\n+                } else if len == 1 {\n+                    candidates.into_iter().filter_map(|res| res.ok()).flatten().collect::<Vec<_>>()\n                 } else {\n-                    let ignore_macro = is_derive_trait_collision(&candidates);\n-                    // If we're reporting an ambiguity, don't mention the namespaces that failed\n-                    let mut candidates =\n-                        candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n-                    if ignore_macro {\n-                        candidates.macro_ns = None;\n+                    let has_derive_trait_collision = is_derive_trait_collision(&candidates);\n+                    if len == 2 && has_derive_trait_collision {\n+                        candidates.type_ns.unwrap()\n+                    } else {\n+                        // If we're reporting an ambiguity, don't mention the namespaces that failed\n+                        let mut candidates = candidates.map(|candidate| candidate.ok());\n+                        // If there a collision between a trait and a derive, we ignore the derive.\n+                        if has_derive_trait_collision {\n+                            candidates.macro_ns = None;\n+                        }\n+                        candidates.into_iter().filter_map(|res| res).flatten().collect::<Vec<_>>()\n                     }\n-                    ambiguity_error(self.cx, diag, path_str, candidates.present_items().collect());\n-                    None\n                 }\n             }\n         }\n@@ -1591,7 +1629,7 @@ fn resolution_failure(\n     path_str: &str,\n     disambiguator: Option<Disambiguator>,\n     kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n-) -> Option<(Res, Option<DefId>)> {\n+) -> Vec<(Res, Option<DefId>)> {\n     let tcx = collector.cx.tcx;\n     let mut recovered_res = None;\n     report_diagnostic(\n@@ -1650,11 +1688,13 @@ fn resolution_failure(\n                         };\n                         name = start;\n                         for ns in [TypeNS, ValueNS, MacroNS] {\n-                            if let Ok(res) = collector.resolve(start, ns, item_id, module_id) {\n-                                debug!(\"found partial_res={:?}\", res);\n-                                *partial_res = Some(full_res(collector.cx.tcx, res));\n-                                *unresolved = end.into();\n-                                break 'outer;\n+                            if let Ok(v_res) = collector.resolve(start, ns, item_id, module_id) {\n+                                debug!(\"found partial_res={:?}\", v_res);\n+                                if !v_res.is_empty() {\n+                                    *partial_res = Some(full_res(collector.cx.tcx, v_res[0]));\n+                                    *unresolved = end.into();\n+                                    break 'outer;\n+                                }\n                             }\n                         }\n                         *unresolved = end.into();\n@@ -1802,7 +1842,10 @@ fn resolution_failure(\n         },\n     );\n \n-    recovered_res\n+    match recovered_res {\n+        Some(r) => vec![r],\n+        None => Vec::new(),\n+    }\n }\n \n fn report_multiple_anchors(cx: &DocContext<'_>, diag_info: DiagnosticInfo<'_>) {\n@@ -1887,28 +1930,47 @@ fn report_malformed_generics(\n }\n \n /// Report an ambiguity error, where there were multiple possible resolutions.\n+///\n+/// If all `candidates` have the same kind, it's not possible to disambiguate so in this case,\n+/// the function won't emit an error and will return `false`. Otherwise, it'll emit the error and\n+/// return `true`.\n fn ambiguity_error(\n     cx: &DocContext<'_>,\n-    diag_info: DiagnosticInfo<'_>,\n+    diag_info: &DiagnosticInfo<'_>,\n     path_str: &str,\n-    candidates: Vec<Res>,\n-) {\n-    let mut msg = format!(\"`{}` is \", path_str);\n+    candidates: &[(Res, Option<DefId>)],\n+) -> bool {\n+    let mut descrs = FxHashSet::default();\n+    let kinds = candidates\n+        .iter()\n+        .map(\n+            |(res, def_id)| {\n+                if let Some(def_id) = def_id { Res::from_def_id(cx.tcx, *def_id) } else { *res }\n+            },\n+        )\n+        .filter(|res| descrs.insert(res.descr()))\n+        .collect::<Vec<_>>();\n+    if descrs.len() == 1 {\n+        // There is no way for users to disambiguate at this point, so better return the first\n+        // candidate and not show a warning.\n+        return false;\n+    }\n \n-    match candidates.as_slice() {\n-        [first_def, second_def] => {\n+    let mut msg = format!(\"`{}` is \", path_str);\n+    match kinds.as_slice() {\n+        [res1, res2] => {\n             msg += &format!(\n                 \"both {} {} and {} {}\",\n-                first_def.article(),\n-                first_def.descr(),\n-                second_def.article(),\n-                second_def.descr(),\n+                res1.article(),\n+                res1.descr(),\n+                res2.article(),\n+                res2.descr()\n             );\n         }\n         _ => {\n-            let mut candidates = candidates.iter().peekable();\n-            while let Some(res) = candidates.next() {\n-                if candidates.peek().is_some() {\n+            let mut kinds = kinds.iter().peekable();\n+            while let Some(res) = kinds.next() {\n+                if kinds.peek().is_some() {\n                     msg += &format!(\"{} {}, \", res.article(), res.descr());\n                 } else {\n                     msg += &format!(\"and {} {}\", res.article(), res.descr());\n@@ -1917,17 +1979,18 @@ fn ambiguity_error(\n         }\n     }\n \n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, &diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, diag_info, |diag, sp| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"ambiguous link\");\n         } else {\n             diag.note(\"ambiguous link\");\n         }\n \n-        for res in candidates {\n+        for res in kinds {\n             suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n         }\n     });\n+    true\n }\n \n /// In case of an ambiguity or mismatched disambiguator, suggest the correct"}, {"sha": "8d204ddb79e3976f5e63749e0faf5042a3e071d7", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -49,7 +49,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n         let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n         for &cnum in cx.tcx.crates(()) {\n             for &impl_def_id in cx.tcx.trait_impls_in_crate(cnum) {\n-                inline::build_impl(cx, None, impl_def_id, None, &mut new_items_external);\n+                inline::build_impl(cx, impl_def_id, None, &mut new_items_external);\n             }\n         }\n     }\n@@ -75,7 +75,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n                 );\n                 parent = cx.tcx.opt_parent(did);\n             }\n-            inline::build_impl(cx, None, impl_def_id, Some(&attr_buf), &mut new_items_local);\n+            inline::build_impl(cx, impl_def_id, Some((&attr_buf, None)), &mut new_items_local);\n             attr_buf.clear();\n         }\n     }\n@@ -84,7 +84,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n         for def_id in PrimitiveType::all_impls(cx.tcx) {\n             // Try to inline primitive impls from other crates.\n             if !def_id.is_local() {\n-                inline::build_impl(cx, None, def_id, None, &mut new_items_external);\n+                inline::build_impl(cx, def_id, None, &mut new_items_external);\n             }\n         }\n         for (prim, did) in PrimitiveType::primitive_locations(cx.tcx) {"}, {"sha": "8a33e51b3beb1acac3dc621db268dd738235787b", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -57,7 +57,8 @@ impl<'a, 'tcx> CfgPropagator<'a, 'tcx> {\n             next_def_id = parent_def_id;\n         }\n \n-        let (_, cfg) = merge_attrs(self.cx, None, item.attrs.other_attrs.as_slice(), Some(&attrs));\n+        let (_, cfg) =\n+            merge_attrs(self.cx, item.attrs.other_attrs.as_slice(), Some((&attrs, None)));\n         item.cfg = cfg;\n     }\n }"}, {"sha": "67877780c0e901652d4f8c7acef783019013f99d", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -28,7 +28,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n-        } else if is_public && !is_proc_macro(cx.sess(), attrs) && !attrs.iter().any(|a| a.has_name(sym::no_mangle)) {\n+        } else if is_public && !is_proc_macro(attrs) && !attrs.iter().any(|a| a.has_name(sym::no_mangle)) {\n             check_must_use_candidate(\n                 cx,\n                 sig.decl,\n@@ -51,7 +51,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n         } else if is_public\n-            && !is_proc_macro(cx.sess(), attrs)\n+            && !is_proc_macro(attrs)\n             && trait_ref_of_method(cx, item.owner_id.def_id).is_none()\n         {\n             check_must_use_candidate(\n@@ -78,7 +78,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Tr\n             check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n         } else if let hir::TraitFn::Provided(eid) = *eid {\n             let body = cx.tcx.hir().body(eid);\n-            if attr.is_none() && is_public && !is_proc_macro(cx.sess(), attrs) {\n+            if attr.is_none() && is_public && !is_proc_macro(attrs) {\n                 check_must_use_candidate(\n                     cx,\n                     sig.decl,"}, {"sha": "bc3d774540a51ca494a60f1dfdf3c94f3f35d97c", "filename": "src/tools/clippy/clippy_utils/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -145,8 +145,8 @@ pub fn get_unique_attr<'a>(\n \n /// Return true if the attributes contain any of `proc_macro`,\n /// `proc_macro_derive` or `proc_macro_attribute`, false otherwise\n-pub fn is_proc_macro(sess: &Session, attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(|attr| sess.is_proc_macro_attr(attr))\n+pub fn is_proc_macro(attrs: &[ast::Attribute]) -> bool {\n+    attrs.iter().any(|attr| attr.is_proc_macro_attr())\n }\n \n /// Return true if the attributes contain `#[doc(hidden)]`"}, {"sha": "cc1964de332c2183daeed04465116d58f5a5e164", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -812,7 +812,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     }\n \n     #[inline(always)]\n-    fn enforce_validity(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n+    fn enforce_validity(ecx: &MiriInterpCx<'mir, 'tcx>, _layout: TyAndLayout<'tcx>) -> bool {\n         ecx.machine.validate\n     }\n "}, {"sha": "22e45082a9f71b1d86e5e1f8d65feb493cb89ce2", "filename": "src/tools/rustfmt/src/attr.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_ast::ast;\n use rustc_ast::HasAttrs;\n-use rustc_span::{symbol::sym, Span, Symbol};\n+use rustc_span::{symbol::sym, Span};\n \n use self::doc_comment::DocCommentFormatter;\n use crate::comment::{contains_comment, rewrite_doc_comment, CommentStyle};\n@@ -19,20 +19,6 @@ use crate::utils::{count_newlines, mk_sp};\n \n mod doc_comment;\n \n-pub(crate) fn contains_name(attrs: &[ast::Attribute], name: Symbol) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(name))\n-}\n-\n-pub(crate) fn first_attr_value_str_by_name(\n-    attrs: &[ast::Attribute],\n-    name: Symbol,\n-) -> Option<Symbol> {\n-    attrs\n-        .iter()\n-        .find(|attr| attr.has_name(name))\n-        .and_then(|attr| attr.value_str())\n-}\n-\n /// Returns attributes on the given statement.\n pub(crate) fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n     stmt.attrs()"}, {"sha": "6bc53159b38ba50e97895aedd2c1c5b72f7c3b86", "filename": "src/tools/rustfmt/src/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -2,13 +2,12 @@ use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::path::{Path, PathBuf};\n \n use rustc_ast::token::TokenKind;\n-use rustc_ast::{ast, ptr};\n+use rustc_ast::{ast, attr, ptr};\n use rustc_errors::Diagnostic;\n use rustc_parse::{new_parser_from_file, parser::Parser as RawParser};\n use rustc_span::{sym, Span};\n use thin_vec::ThinVec;\n \n-use crate::attr::first_attr_value_str_by_name;\n use crate::parse::session::ParseSess;\n use crate::Input;\n \n@@ -93,7 +92,7 @@ pub(crate) enum ParserError {\n \n impl<'a> Parser<'a> {\n     pub(crate) fn submod_path_from_attr(attrs: &[ast::Attribute], path: &Path) -> Option<PathBuf> {\n-        let path_sym = first_attr_value_str_by_name(attrs, sym::path)?;\n+        let path_sym = attr::first_attr_value_str_by_name(attrs, sym::path)?;\n         let path_str = path_sym.as_str();\n \n         // On windows, the base path might have the form"}, {"sha": "3bddf4c1b6a41d82f827d1e3733e12341eb7ba74", "filename": "src/tools/rustfmt/src/reorder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -8,7 +8,7 @@\n \n use std::cmp::{Ord, Ordering};\n \n-use rustc_ast::ast;\n+use rustc_ast::{ast, attr};\n use rustc_span::{symbol::sym, Span};\n \n use crate::config::{Config, GroupImportsTactic};\n@@ -167,7 +167,7 @@ fn rewrite_reorderable_or_regroupable_items(\n }\n \n fn contains_macro_use_attr(item: &ast::Item) -> bool {\n-    crate::attr::contains_name(&item.attrs, sym::macro_use)\n+    attr::contains_name(&item.attrs, sym::macro_use)\n }\n \n /// Divides imports into three groups, corresponding to standard, external"}, {"sha": "67a4df19fcc7aafb8144ac842e16b5fa21c0298b", "filename": "src/tools/tidy/src/walk.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Ftidy%2Fsrc%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/src%2Ftools%2Ftidy%2Fsrc%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fwalk.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -29,6 +29,7 @@ pub fn filter_dirs(path: &Path) -> bool {\n         // Filter RLS output directories\n         \"target/rls\",\n         \"src/bootstrap/target\",\n+        \"vendor\",\n     ];\n     skip.iter().any(|p| path.ends_with(p))\n }"}, {"sha": "afb0dc42f443a8938cce94c2ca301a1cb1a7a9f3", "filename": "tests/codegen/issues/auxiliary/static_dllimport_aux.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fauxiliary%2Fstatic_dllimport_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fauxiliary%2Fstatic_dllimport_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fauxiliary%2Fstatic_dllimport_aux.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/auxiliary/static_dllimport_aux.rs"}, {"sha": "a3499babea21b07d40c2b232d14ca2b986b1ce95", "filename": "tests/codegen/issues/issue-103285-ptr-addr-overflow-check.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-103285-ptr-addr-overflow-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-103285-ptr-addr-overflow-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-103285-ptr-addr-overflow-check.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-103285-ptr-addr-overflow-check.rs"}, {"sha": "f19d7031bb3864c70704550db247d22f8a920fae", "filename": "tests/codegen/issues/issue-103840.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-103840.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-103840.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-103840.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-103840.rs"}, {"sha": "d54ac9e33bce27c865b75cfe9ee4e859e43a2488", "filename": "tests/codegen/issues/issue-105386-ub-in-debuginfo.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-105386-ub-in-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-105386-ub-in-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-105386-ub-in-debuginfo.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-105386-ub-in-debuginfo.rs"}, {"sha": "b70ea1f48c8ceae013c7f4154de2861e15459e78", "filename": "tests/codegen/issues/issue-13018.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-13018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-13018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-13018.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-13018.rs"}, {"sha": "28d28428904f525543c780f237803a52982b7e2a", "filename": "tests/codegen/issues/issue-15953.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-15953.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-15953.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-15953.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-15953.rs"}, {"sha": "e5ee94e1f45e137263d0971028e79dff857a52fb", "filename": "tests/codegen/issues/issue-27130.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-27130.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-27130.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-27130.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-27130.rs"}, {"sha": "abef92c19b610b612da29d6c5fbad049c2ddd695", "filename": "tests/codegen/issues/issue-32031.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-32031.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-32031.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-32031.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-32031.rs"}, {"sha": "85493a4bb73950f3c9b7701def58bcec990bd325", "filename": "tests/codegen/issues/issue-32364.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-32364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-32364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-32364.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-32364.rs"}, {"sha": "f53fa240cd1adba3e52e9a9a92fe6af0aeae0a78", "filename": "tests/codegen/issues/issue-34634.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-34634.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-34634.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-34634.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-34634.rs"}, {"sha": "653da8e8b5f7bff2112f97d12ebccedf3dea137b", "filename": "tests/codegen/issues/issue-34947-pow-i32.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-34947-pow-i32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-34947-pow-i32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-34947-pow-i32.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-34947-pow-i32.rs"}, {"sha": "fe54375bbf6aa6d31e41a16400125f697d5b63f6", "filename": "tests/codegen/issues/issue-37945.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-37945.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-37945.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-37945.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-37945.rs"}, {"sha": "1a3923f1bb1ab7b51497a471ab7f4c3d83e03d0c", "filename": "tests/codegen/issues/issue-44056-macos-tls-align.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-44056-macos-tls-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-44056-macos-tls-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-44056-macos-tls-align.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-44056-macos-tls-align.rs"}, {"sha": "e9b05e648b442776de8cae7d6fb77e537b2f104d", "filename": "tests/codegen/issues/issue-45222.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-45222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-45222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-45222.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-45222.rs"}, {"sha": "c79542767774a3d7557e261868f5d65dde2315c5", "filename": "tests/codegen/issues/issue-45466.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-45466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-45466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-45466.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-45466.rs"}, {"sha": "1daa213fc821392f6ebefe5ce99ca36387af7c17", "filename": "tests/codegen/issues/issue-45964-bounds-check-slice-pos.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-45964-bounds-check-slice-pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-45964-bounds-check-slice-pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-45964-bounds-check-slice-pos.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-45964-bounds-check-slice-pos.rs"}, {"sha": "9076274f45e94e19393c2ea424b88c5afa8d9bc2", "filename": "tests/codegen/issues/issue-47278.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-47278.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-47278.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-47278.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-47278.rs"}, {"sha": "6944336d33560bcd48dc5c3422b6be348a8cd93a", "filename": "tests/codegen/issues/issue-47442.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-47442.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-47442.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-47442.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-47442.rs"}, {"sha": "4dc9ebfebbcdf2af63c7f11d213dacfc4820638b", "filename": "tests/codegen/issues/issue-56267-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-56267-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-56267-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-56267-2.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-56267-2.rs"}, {"sha": "7bdd2577998327d62837556010a7cac2658e53e6", "filename": "tests/codegen/issues/issue-56267.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-56267.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-56267.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-56267.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-56267.rs"}, {"sha": "044d721814bd345565615596019aa216ae2f17e3", "filename": "tests/codegen/issues/issue-56927.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-56927.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-56927.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-56927.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-56927.rs"}, {"sha": "00f8953d94952f1c1ec7a521f49510c09b1d8acb", "filename": "tests/codegen/issues/issue-58881.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-58881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-58881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-58881.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-58881.rs"}, {"sha": "d271fe027e309d5f609856242af52dd9f12f3d97", "filename": "tests/codegen/issues/issue-59352.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-59352.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-59352.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-59352.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-59352.rs"}, {"sha": "a3aca3a2912a6c2cc31b0bc0829200dae96f817e", "filename": "tests/codegen/issues/issue-69101-bounds-check.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-69101-bounds-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-69101-bounds-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-69101-bounds-check.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-69101-bounds-check.rs"}, {"sha": "a09c4bcfbeac539242fd388fcea324cb266afe37", "filename": "tests/codegen/issues/issue-73031.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-73031.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-73031.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-73031.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-73031.rs"}, {"sha": "85c2bbfd040bdb7b7d8993a93c509cb58506af5b", "filename": "tests/codegen/issues/issue-73338-effecient-cmp.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-73338-effecient-cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-73338-effecient-cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-73338-effecient-cmp.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-73338-effecient-cmp.rs"}, {"sha": "8d07a67a1b451807d84bc90a70a302bdcb2dc04f", "filename": "tests/codegen/issues/issue-73396-bounds-check-after-position.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-73396-bounds-check-after-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-73396-bounds-check-after-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-73396-bounds-check-after-position.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-73396-bounds-check-after-position.rs"}, {"sha": "1ad05906e21abe61ad351258e12569ff81d09a16", "filename": "tests/codegen/issues/issue-73827-bounds-check-index-in-subexpr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-73827-bounds-check-index-in-subexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-73827-bounds-check-index-in-subexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-73827-bounds-check-index-in-subexpr.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-73827-bounds-check-index-in-subexpr.rs"}, {"sha": "2d363d8f73be9161fc3a27cd2851292a1b505fbf", "filename": "tests/codegen/issues/issue-75525-bounds-checks.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-75525-bounds-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-75525-bounds-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-75525-bounds-checks.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-75525-bounds-checks.rs"}, {"sha": "470a9e04096050d321bafd74e899ba3a8a07084d", "filename": "tests/codegen/issues/issue-75546.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-75546.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-75546.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-75546.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-75546.rs"}, {"sha": "9394868c08db51995ea1bde2472fec0f0673c554", "filename": "tests/codegen/issues/issue-75659.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-75659.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-75659.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-75659.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-75659.rs"}, {"sha": "4cc82414546b298c664be37db0e83a8b0fd9f0ca", "filename": "tests/codegen/issues/issue-77812.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-77812.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-77812.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-77812.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-77812.rs"}, {"sha": "0b6ab4f7ecb3bb9342d255df88aa7344531c59d1", "filename": "tests/codegen/issues/issue-81408-dllimport-thinlto-windows.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-81408-dllimport-thinlto-windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-81408-dllimport-thinlto-windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-81408-dllimport-thinlto-windows.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-81408-dllimport-thinlto-windows.rs"}, {"sha": "7ca1954470075ded1d98c43ee52b523624c4364b", "filename": "tests/codegen/issues/issue-84268.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-84268.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-84268.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-84268.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-84268.rs"}, {"sha": "591a1aca74747e77e0ec5d8e30049714576a3bed", "filename": "tests/codegen/issues/issue-85872-multiple-reverse.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-85872-multiple-reverse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-85872-multiple-reverse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-85872-multiple-reverse.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-85872-multiple-reverse.rs"}, {"sha": "9ccbcb24f5621f76fb0cc6782be8998f8374208f", "filename": "tests/codegen/issues/issue-86106.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-86106.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-86106.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-86106.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-86106.rs"}, {"sha": "28bfcce0d7be26d9be2f1fc534e82b4a3be8c1d9", "filename": "tests/codegen/issues/issue-96274.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-96274.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-96274.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-96274.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-96274.rs"}, {"sha": "0413ed6b26f360d59817257595f0bfac463b46bc", "filename": "tests/codegen/issues/issue-96497-slice-size-nowrap.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-96497-slice-size-nowrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-96497-slice-size-nowrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-96497-slice-size-nowrap.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-96497-slice-size-nowrap.rs"}, {"sha": "12ace5fff6b6eb69285714c2efe6cc9dae5692c4", "filename": "tests/codegen/issues/issue-98156-const-arg-temp-lifetime.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-98156-const-arg-temp-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-98156-const-arg-temp-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-98156-const-arg-temp-lifetime.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-98156-const-arg-temp-lifetime.rs"}, {"sha": "7da29cd7952971e8c8f3ff2faa7bc7f8c3efd4b4", "filename": "tests/codegen/issues/issue-98294-get-mut-copy-from-slice-opt.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-98294-get-mut-copy-from-slice-opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fissues%2Fissue-98294-get-mut-copy-from-slice-opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-98294-get-mut-copy-from-slice-opt.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/codegen/issue-98294-get-mut-copy-from-slice-opt.rs"}, {"sha": "b3c3483fea9824fdf0401059e0b148c18cbf648a", "filename": "tests/codegen/vec-shrink-panik.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fvec-shrink-panik.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fcodegen%2Fvec-shrink-panik.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fvec-shrink-panik.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,3 +1,8 @@\n+// revisions: old new\n+// LLVM 17 realizes double panic is not possible and doesn't generate calls\n+// to panic_cannot_unwind.\n+// [old]ignore-llvm-version: 17 - 99\n+// [new]min-llvm-version: 17\n // compile-flags: -O\n // ignore-debug: the debug assertions get in the way\n #![crate_type = \"lib\"]\n@@ -18,11 +23,11 @@ pub fn shrink_to_fit(vec: &mut Vec<u32>) {\n pub fn issue71861(vec: Vec<u32>) -> Box<[u32]> {\n     // CHECK-NOT: panic\n \n-    // Call to panic_cannot_unwind in case of double-panic is expected,\n-    // but other panics are not.\n+    // Call to panic_cannot_unwind in case of double-panic is expected\n+    // on LLVM 16 and older, but other panics are not.\n     // CHECK: cleanup\n-    // CHECK-NEXT: ; call core::panicking::panic_cannot_unwind\n-    // CHECK-NEXT: panic_cannot_unwind\n+    // old-NEXT: ; call core::panicking::panic_cannot_unwind\n+    // old-NEXT: panic_cannot_unwind\n \n     // CHECK-NOT: panic\n     vec.into_boxed_slice()\n@@ -34,14 +39,14 @@ pub fn issue75636<'a>(iter: &[&'a str]) -> Box<[&'a str]> {\n     // CHECK-NOT: panic\n \n     // Call to panic_cannot_unwind in case of double-panic is expected,\n-    // but other panics are not.\n+    // on LLVM 16 and older, but other panics are not.\n     // CHECK: cleanup\n-    // CHECK-NEXT: ; call core::panicking::panic_cannot_unwind\n-    // CHECK-NEXT: panic_cannot_unwind\n+    // old-NEXT: ; call core::panicking::panic_cannot_unwind\n+    // old-NEXT: panic_cannot_unwind\n \n     // CHECK-NOT: panic\n     iter.iter().copied().collect()\n }\n \n-// CHECK: ; core::panicking::panic_cannot_unwind\n-// CHECK: declare void @{{.*}}panic_cannot_unwind\n+// old: ; core::panicking::panic_cannot_unwind\n+// old: declare void @{{.*}}panic_cannot_unwind"}, {"sha": "701d6b1ab71312feac4e39be94f66c80d03d4cb3", "filename": "tests/mir-opt/building/custom/composite_return.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fcomposite_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fcomposite_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fcomposite_return.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,21 @@\n+#![feature(custom_mir, core_intrinsics)]\n+\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+// EMIT_MIR composite_return.tuple.built.after.mir\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+fn tuple() -> (i32, bool) {\n+    mir!(\n+        type RET = (i32, bool);\n+        {\n+            RET.0 = 1;\n+            RET.1 = true;\n+            Return()\n+        }\n+    )\n+}\n+\n+fn main() {\n+    assert_eq!(tuple(), (1, true));\n+}"}, {"sha": "d159c1a655eb574e712cc7dc61f98a517d52de9f", "filename": "tests/mir-opt/building/custom/composite_return.tuple.built.after.mir", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fcomposite_return.tuple.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fcomposite_return.tuple.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fcustom%2Fcomposite_return.tuple.built.after.mir?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,11 @@\n+// MIR for `tuple` after built\n+\n+fn tuple() -> (i32, bool) {\n+    let mut _0: (i32, bool);             // return place in scope 0 at $DIR/composite_return.rs:+0:15: +0:26\n+\n+    bb0: {\n+        (_0.0: i32) = const 1_i32;       // scope 0 at $DIR/composite_return.rs:+4:13: +4:22\n+        (_0.1: bool) = const true;       // scope 0 at $DIR/composite_return.rs:+5:13: +5:25\n+        return;                          // scope 0 at $DIR/composite_return.rs:+6:13: +6:21\n+    }\n+}"}, {"sha": "e535141e772f816770805a0b1336592a27653338", "filename": "tests/mir-opt/lower_intrinsics.option_payload.LowerIntrinsics.diff", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,54 @@\n+- // MIR for `option_payload` before LowerIntrinsics\n++ // MIR for `option_payload` after LowerIntrinsics\n+  \n+  fn option_payload(_1: &Option<usize>, _2: &Option<String>) -> () {\n+      debug o => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:23: +0:24\n+      debug p => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:42: +0:43\n+      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:62: +0:62\n+      let mut _4: *const std::option::Option<usize>; // in scope 0 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n+      let mut _6: *const std::option::Option<std::string::String>; // in scope 0 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n+      scope 1 {\n+          let _3: *const usize;            // in scope 1 at $DIR/lower_intrinsics.rs:+2:13: +2:15\n+          scope 2 {\n+              debug _x => _3;              // in scope 2 at $DIR/lower_intrinsics.rs:+2:13: +2:15\n+              let _5: *const std::string::String; // in scope 2 at $DIR/lower_intrinsics.rs:+3:13: +3:15\n+              scope 3 {\n+                  debug _y => _5;          // in scope 3 at $DIR/lower_intrinsics.rs:+3:13: +3:15\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:13: +2:15\n+          StorageLive(_4);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n+          _4 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n+-         _3 = option_payload_ptr::<usize>(move _4) -> bb1; // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:99:18: 99:54\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<usize>) -> *const usize {option_payload_ptr::<usize>}, val: Value(<ZST>) }\n++         _3 = &raw const (((*_4) as Some).0: usize); // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n++         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n+      }\n+  \n+      bb1: {\n+          StorageDead(_4);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:56: +2:57\n+          StorageLive(_5);                 // scope 2 at $DIR/lower_intrinsics.rs:+3:13: +3:15\n+          StorageLive(_6);                 // scope 2 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n+          _6 = &raw const (*_2);           // scope 2 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n+-         _5 = option_payload_ptr::<String>(move _6) -> bb2; // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:100:18: 100:54\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<String>) -> *const String {option_payload_ptr::<String>}, val: Value(<ZST>) }\n++         _5 = &raw const (((*_6) as Some).0: std::string::String); // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n++         goto -> bb2;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n+      }\n+  \n+      bb2: {\n+          StorageDead(_6);                 // scope 2 at $DIR/lower_intrinsics.rs:+3:56: +3:57\n+          _0 = const ();                   // scope 1 at $DIR/lower_intrinsics.rs:+1:5: +4:6\n+          StorageDead(_5);                 // scope 2 at $DIR/lower_intrinsics.rs:+4:5: +4:6\n+          StorageDead(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+4:5: +4:6\n+          return;                          // scope 0 at $DIR/lower_intrinsics.rs:+5:2: +5:2\n+      }\n+  }\n+  "}, {"sha": "f07e2816f4f41196761acd4859dd2e6869c1d65d", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -91,3 +91,12 @@ pub fn read_via_copy_uninhabited(r: &Never) -> Never {\n }\n \n pub enum Never {}\n+\n+// EMIT_MIR lower_intrinsics.option_payload.LowerIntrinsics.diff\n+#[cfg(not(bootstrap))]\n+pub fn option_payload(o: &Option<usize>, p: &Option<String>) {\n+    unsafe {\n+        let _x = core::intrinsics::option_payload_ptr(o);\n+        let _y = core::intrinsics::option_payload_ptr(p);\n+    }\n+}"}, {"sha": "fc180ccfe28e2448844e50f6aa32fc9cc22c2235", "filename": "tests/run-make-fulldeps/issue-83045/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frun-make-fulldeps%2Fissue-83045%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frun-make-fulldeps%2Fissue-83045%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fissue-83045%2FMakefile?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -29,5 +29,5 @@ all:\n \t\t\t\t  --crate-type=rlib \\\n \t\t\t\t  --edition=2018 \\\n \t\t\t\t  c.rs 2>&1 | tee $(TMPDIR)/output.txt || exit 0\n-\t$(CGREP) E0463 < $(TMPDIR)/output.txt\n+\t$(CGREP) E0519 < $(TMPDIR)/output.txt\n \t$(CGREP) -v \"internal compiler error\" < $(TMPDIR)/output.txt"}, {"sha": "0ebb96d787046ffdc53864694ddd7a9c09d39eb9", "filename": "tests/rustdoc-gui/setting-auto-hide-content-large-items.goml", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-gui%2Fsetting-auto-hide-content-large-items.goml", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-gui%2Fsetting-auto-hide-content-large-items.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsetting-auto-hide-content-large-items.goml?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,51 @@\n+// This test ensures that the \"Auto-hide item contents for large items\" setting is working as\n+// expected.\n+\n+// We need to disable this check because `implementors/test_docs/trait.Iterator.js` doesn't exist.\n+fail-on-request-error: false\n+\n+define-function: (\n+    \"check-setting\",\n+    (storage_value, setting_attribute_value, toggle_attribute_value),\n+    block {\n+        assert-local-storage: {\"rustdoc-auto-hide-large-items\": |storage_value|}\n+        click: \"#settings-menu\"\n+        wait-for: \"#settings\"\n+        assert-property: (\"#auto-hide-large-items\", {\"checked\": |setting_attribute_value|})\n+        assert-attribute: (\".item-decl .type-contents-toggle\", {\"open\": |toggle_attribute_value|})\n+    }\n+)\n+\n+goto: \"file://\" + |DOC_PATH| + \"/lib2/scroll_traits/trait.Iterator.html\"\n+\n+// We check that the setting is enabled by default and is working.\n+call-function: (\"check-setting\", {\n+    \"storage_value\": null,\n+    \"setting_attribute_value\": \"true\",\n+    \"toggle_attribute_value\": null,\n+})\n+\n+// Now we change its value.\n+click: \"#auto-hide-large-items\"\n+assert-local-storage: {\"rustdoc-auto-hide-large-items\": \"false\"}\n+\n+// We check that the changes were applied as expected.\n+reload:\n+\n+call-function: (\"check-setting\", {\n+    \"storage_value\": \"false\",\n+    \"setting_attribute_value\": \"false\",\n+    \"toggle_attribute_value\": \"\",\n+})\n+\n+// And now we re-enable the setting.\n+click: \"#auto-hide-large-items\"\n+assert-local-storage: {\"rustdoc-auto-hide-large-items\": \"true\"}\n+\n+// And we check everything is back the way it was before.\n+reload:\n+call-function: (\"check-setting\", {\n+    \"storage_value\": \"true\",\n+    \"setting_attribute_value\": \"true\",\n+    \"toggle_attribute_value\": null,\n+})"}, {"sha": "0290b8582042c0628ce3b2d545b18e405439e374", "filename": "tests/rustdoc-ui/intra-doc/ambiguity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fambiguity.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -35,6 +35,6 @@ pub mod foo {\n /// Ambiguous non-implied shortcut link [`foo::bar`]. //~ERROR `foo::bar`\n pub struct Docs {}\n \n-/// [true] //~ ERROR `true` is both a module and a builtin type\n+/// [true] //~ ERROR `true` is both a module and a primitive type\n /// [primitive@true]\n pub mod r#true {}"}, {"sha": "47853e0b5899d10c3ae3792adac6af311a3b8d33", "filename": "tests/rustdoc-ui/intra-doc/ambiguity.stderr", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fambiguity.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,4 +1,4 @@\n-error: `true` is both a module and a builtin type\n+error: `true` is both a module and a primitive type\n   --> $DIR/ambiguity.rs:38:6\n    |\n LL | /// [true]\n@@ -13,89 +13,89 @@ help: to link to the module, prefix with `mod@`\n    |\n LL | /// [mod@true]\n    |      ++++\n-help: to link to the builtin type, prefix with `prim@`\n+help: to link to the primitive type, prefix with `prim@`\n    |\n LL | /// [prim@true]\n    |      +++++\n \n-error: `ambiguous` is both a struct and a function\n+error: `ambiguous` is both a function and a struct\n   --> $DIR/ambiguity.rs:27:7\n    |\n LL | /// [`ambiguous`] is ambiguous.\n    |       ^^^^^^^^^ ambiguous link\n    |\n-help: to link to the struct, prefix with `struct@`\n-   |\n-LL | /// [`struct@ambiguous`] is ambiguous.\n-   |       +++++++\n help: to link to the function, add parentheses\n    |\n LL | /// [`ambiguous()`] is ambiguous.\n    |                ++\n+help: to link to the struct, prefix with `struct@`\n+   |\n+LL | /// [`struct@ambiguous`] is ambiguous.\n+   |       +++++++\n \n-error: `ambiguous` is both a struct and a function\n+error: `ambiguous` is both a function and a struct\n   --> $DIR/ambiguity.rs:29:6\n    |\n LL | /// [ambiguous] is ambiguous.\n    |      ^^^^^^^^^ ambiguous link\n    |\n-help: to link to the struct, prefix with `struct@`\n-   |\n-LL | /// [struct@ambiguous] is ambiguous.\n-   |      +++++++\n help: to link to the function, add parentheses\n    |\n LL | /// [ambiguous()] is ambiguous.\n    |               ++\n+help: to link to the struct, prefix with `struct@`\n+   |\n+LL | /// [struct@ambiguous] is ambiguous.\n+   |      +++++++\n \n-error: `multi_conflict` is a struct, a function, and a macro\n+error: `multi_conflict` is a function, a struct, and a macro\n   --> $DIR/ambiguity.rs:31:7\n    |\n LL | /// [`multi_conflict`] is a three-way conflict.\n    |       ^^^^^^^^^^^^^^ ambiguous link\n    |\n-help: to link to the struct, prefix with `struct@`\n-   |\n-LL | /// [`struct@multi_conflict`] is a three-way conflict.\n-   |       +++++++\n help: to link to the function, add parentheses\n    |\n LL | /// [`multi_conflict()`] is a three-way conflict.\n    |                     ++\n+help: to link to the struct, prefix with `struct@`\n+   |\n+LL | /// [`struct@multi_conflict`] is a three-way conflict.\n+   |       +++++++\n help: to link to the macro, add an exclamation mark\n    |\n LL | /// [`multi_conflict!`] is a three-way conflict.\n    |                     +\n \n-error: `type_and_value` is both a module and a constant\n+error: `type_and_value` is both a constant and a module\n   --> $DIR/ambiguity.rs:33:16\n    |\n LL | /// Ambiguous [type_and_value].\n    |                ^^^^^^^^^^^^^^ ambiguous link\n    |\n-help: to link to the module, prefix with `mod@`\n-   |\n-LL | /// Ambiguous [mod@type_and_value].\n-   |                ++++\n help: to link to the constant, prefix with `const@`\n    |\n LL | /// Ambiguous [const@type_and_value].\n    |                ++++++\n+help: to link to the module, prefix with `mod@`\n+   |\n+LL | /// Ambiguous [mod@type_and_value].\n+   |                ++++\n \n-error: `foo::bar` is both an enum and a function\n+error: `foo::bar` is both a function and an enum\n   --> $DIR/ambiguity.rs:35:43\n    |\n LL | /// Ambiguous non-implied shortcut link [`foo::bar`].\n    |                                           ^^^^^^^^ ambiguous link\n    |\n-help: to link to the enum, prefix with `enum@`\n-   |\n-LL | /// Ambiguous non-implied shortcut link [`enum@foo::bar`].\n-   |                                           +++++\n help: to link to the function, add parentheses\n    |\n LL | /// Ambiguous non-implied shortcut link [`foo::bar()`].\n    |                                                   ++\n+help: to link to the enum, prefix with `enum@`\n+   |\n+LL | /// Ambiguous non-implied shortcut link [`enum@foo::bar`].\n+   |                                           +++++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "15bf51e6f8e2b6319f8ab39ea95955d41b22e1a1", "filename": "tests/rustdoc-ui/intra-doc/auxiliary/inner-crate-doc.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fauxiliary%2Finner-crate-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fauxiliary%2Finner-crate-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fauxiliary%2Finner-crate-doc.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1 @@\n+//! Inner doc comment"}, {"sha": "f37f49c24ccc5c70619ef06eaf41fbe355520a0e", "filename": "tests/rustdoc-ui/intra-doc/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -54,11 +54,11 @@\n \n /// [u8::not_found]\n //~^ ERROR unresolved link\n-//~| NOTE the builtin type `u8` has no associated item named `not_found`\n+//~| NOTE the primitive type `u8` has no associated item named `not_found`\n \n /// [std::primitive::u8::not_found]\n //~^ ERROR unresolved link\n-//~| NOTE the builtin type `u8` has no associated item named `not_found`\n+//~| NOTE the primitive type `u8` has no associated item named `not_found`\n \n /// [type@Vec::into_iter]\n //~^ ERROR unresolved link"}, {"sha": "a982bba0095915134c46ea5b2601e09adc28cf42", "filename": "tests/rustdoc-ui/intra-doc/errors.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -80,13 +80,13 @@ error: unresolved link to `u8::not_found`\n   --> $DIR/errors.rs:55:6\n    |\n LL | /// [u8::not_found]\n-   |      ^^^^^^^^^^^^^ the builtin type `u8` has no associated item named `not_found`\n+   |      ^^^^^^^^^^^^^ the primitive type `u8` has no associated item named `not_found`\n \n error: unresolved link to `std::primitive::u8::not_found`\n   --> $DIR/errors.rs:59:6\n    |\n LL | /// [std::primitive::u8::not_found]\n-   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the builtin type `u8` has no associated item named `not_found`\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the primitive type `u8` has no associated item named `not_found`\n \n error: unresolved link to `Vec::into_iter`\n   --> $DIR/errors.rs:63:6"}, {"sha": "4d6a325664578da09545bcadea3df882f133faab", "filename": "tests/rustdoc-ui/intra-doc/import-inline-merge-module.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge-module.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,10 @@\n+// Test for issue #108501.\n+// Module parent scope doesn't hijack import's parent scope for the import's doc links.\n+\n+// check-pass\n+// aux-build: inner-crate-doc.rs\n+// compile-flags: --extern inner_crate_doc --edition 2018\n+\n+/// Import doc comment [inner_crate_doc]\n+#[doc(inline)]\n+pub use inner_crate_doc;"}, {"sha": "464c5f0d5439c4ee60f51f309021aedf9165a2c7", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-10.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-10.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,22 @@\n+// This test ensures that this warning doesn't show up:\n+// warning: `PartialEq` is both a trait and a derive macro\n+//  --> tests/rustdoc-ui/intra-doc/issue-108653-associated-items-10.rs:1:7\n+//   |\n+// 1 | //! [`PartialEq`]\n+//   |       ^^^^^^^^^ ambiguous link\n+//   |\n+//   = note: `#[warn(rustdoc::broken_intra_doc_links)]` on by default\n+// help: to link to the trait, prefix with `trait@`\n+//   |\n+// 1 | //! [`trait@PartialEq`]\n+//   |       ++++++\n+// help: to link to the derive macro, prefix with `derive@`\n+//   |\n+// 1 | //! [`derive@PartialEq`]\n+//   |       +++++++\n+\n+// check-pass\n+\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+//! [`PartialEq`]"}, {"sha": "cbe60f746b682a42febea1f0ea41e22bb1673250", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-2.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,17 @@\n+// This is ensuring that the UI output for associated items is as expected.\n+\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+/// [`Trait::IDENT`]\n+//~^ ERROR both an associated constant and an associated type\n+pub trait Trait {\n+    type IDENT;\n+    const IDENT: usize;\n+}\n+\n+/// [`Trait2::IDENT`]\n+//~^ ERROR both an associated function and an associated type\n+pub trait Trait2 {\n+    type IDENT;\n+    fn IDENT() {}\n+}"}, {"sha": "952392548da8a34a6de94a6696b92d1045a50da6", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-2.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-2.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,37 @@\n+error: `Trait::IDENT` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items-2.rs:5:7\n+   |\n+LL | /// [`Trait::IDENT`]\n+   |       ^^^^^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-2.rs:3:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@Trait::IDENT`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Trait::IDENT`]\n+   |       +++++\n+\n+error: `Trait2::IDENT` is both an associated function and an associated type\n+  --> $DIR/issue-108653-associated-items-2.rs:12:7\n+   |\n+LL | /// [`Trait2::IDENT`]\n+   |       ^^^^^^^^^^^^^ ambiguous link\n+   |\n+help: to link to the associated function, add parentheses\n+   |\n+LL | /// [`Trait2::IDENT()`]\n+   |                    ++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Trait2::IDENT`]\n+   |       +++++\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7ffd0a40e7cfe15d5d452b97822cacf8fd4f0a65", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-3.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,16 @@\n+// This is ensuring that the UI output for associated items works when it's being documented\n+// from another item.\n+\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(nonstandard_style)]\n+\n+pub trait Trait {\n+    type Trait;\n+    const Trait: usize;\n+}\n+\n+/// [`Trait`]\n+//~^ ERROR both a constant and a trait\n+/// [`Trait::Trait`]\n+//~^ ERROR both an associated constant and an associated type\n+pub const Trait: usize = 0;"}, {"sha": "6401dacb57a8e02d9f0564896fdbc15c7adeaac7", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-3.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-3.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,37 @@\n+error: `Trait` is both a constant and a trait\n+  --> $DIR/issue-108653-associated-items-3.rs:12:7\n+   |\n+LL | /// [`Trait`]\n+   |       ^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-3.rs:4:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the constant, prefix with `const@`\n+   |\n+LL | /// [`const@Trait`]\n+   |       ++++++\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [`trait@Trait`]\n+   |       ++++++\n+\n+error: `Trait::Trait` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items-3.rs:14:7\n+   |\n+LL | /// [`Trait::Trait`]\n+   |       ^^^^^^^^^^^^ ambiguous link\n+   |\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@Trait::Trait`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Trait::Trait`]\n+   |       +++++\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "537d61364bb1a19b1b7ce828fc661b2d3c4f6f89", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-4.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-4.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,21 @@\n+// This is ensuring that the UI output for associated items works when it's being documented\n+// from another item.\n+\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(nonstandard_style)]\n+\n+pub trait Trait {\n+    type Trait;\n+}\n+\n+/// [`Struct::Trait`]\n+//~^ ERROR both an associated constant and an associated type\n+pub struct Struct;\n+\n+impl Trait for Struct {\n+    type Trait = Struct;\n+}\n+\n+impl Struct {\n+    pub const Trait: usize = 0;\n+}"}, {"sha": "a8dc91204c0836887959ec0d487d03cfce4ca226", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-4.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-4.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,22 @@\n+error: `Struct::Trait` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items-4.rs:11:7\n+   |\n+LL | /// [`Struct::Trait`]\n+   |       ^^^^^^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-4.rs:4:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@Struct::Trait`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Struct::Trait`]\n+   |       +++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "bc28bc5442181c0a47a386aca23304b2e6e82df4", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-5.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-5.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,8 @@\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(nonstandard_style)]\n+\n+/// [`u32::MAX`]\n+//~^ ERROR both an associated constant and a trait\n+pub mod u32 {\n+    pub trait MAX {}\n+}"}, {"sha": "7430044ac3f1bc698364f7731774c343a313ab15", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-5.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-5.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,22 @@\n+error: `u32::MAX` is both an associated constant and a trait\n+  --> $DIR/issue-108653-associated-items-5.rs:4:7\n+   |\n+LL | /// [`u32::MAX`]\n+   |       ^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-5.rs:1:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@u32::MAX`]\n+   |       ++++++\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [`trait@u32::MAX`]\n+   |       ++++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "8fde74d0ddb47ea326251c30ec50b2d6e6f5c69e", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-6.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-6.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,8 @@\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(nonstandard_style)]\n+\n+/// [`u32::MAX`]\n+//~^ ERROR both an associated constant and a primitive type\n+pub mod u32 {\n+    pub use std::primitive::u32 as MAX;\n+}"}, {"sha": "fe2d8cafa30262b04cb6d29337be3404c1bd9b04", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-6.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-6.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,22 @@\n+error: `u32::MAX` is both an associated constant and a primitive type\n+  --> $DIR/issue-108653-associated-items-6.rs:4:7\n+   |\n+LL | /// [`u32::MAX`]\n+   |       ^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-6.rs:1:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@u32::MAX`]\n+   |       ++++++\n+help: to link to the primitive type, prefix with `prim@`\n+   |\n+LL | /// [`prim@u32::MAX`]\n+   |       +++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "6e99f4365a78d0dcc580d1f8a09da3042b7b87c5", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-7.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-7.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,12 @@\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(nonstandard_style)]\n+\n+pub trait Trait {\n+    type MAX;\n+}\n+\n+/// [`u32::MAX`]\n+//~^ ERROR both an associated constant and an associated type\n+impl Trait for u32 {\n+    type MAX = u32;\n+}"}, {"sha": "1d302ff42e86f1b89e5f5adffc7160ce25f8e9e7", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-7.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-7.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,22 @@\n+error: `u32::MAX` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items-7.rs:8:7\n+   |\n+LL | /// [`u32::MAX`]\n+   |       ^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-7.rs:1:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@u32::MAX`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@u32::MAX`]\n+   |       +++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "2f8ee1566bd4e76cf3dc2c21f87b8fbd08b752f6", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-8.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-8.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,12 @@\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![allow(nonstandard_style)]\n+\n+/// [`u32::MAX`]\n+//~^ ERROR both an associated constant and an associated type\n+pub trait T {\n+    type MAX;\n+}\n+\n+impl T for u32 {\n+    type MAX = ();\n+}"}, {"sha": "efed0e2ce0ff54fdda62860991725ef899582bee", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-8.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-8.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,22 @@\n+error: `u32::MAX` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items-8.rs:4:7\n+   |\n+LL | /// [`u32::MAX`]\n+   |       ^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items-8.rs:1:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@u32::MAX`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@u32::MAX`]\n+   |       +++++\n+\n+error: aborting due to previous error\n+"}, {"sha": "3357ccf2460d819a21344a491b253e55efa25d44", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items-9.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items-9.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+#![deny(warnings)]\n+\n+//! [usize::Item]\n+\n+pub trait Foo { type Item; }\n+pub trait Bar { type Item; }\n+\n+impl Foo for usize { type Item = u32; }\n+impl Bar for usize { type Item = i32; }"}, {"sha": "0a393e26d6a96ee2f3007593f9fbeb8dcde3a95a", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,35 @@\n+// This is ensuring that the UI output for associated items is as expected.\n+\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+pub enum Enum {\n+    IDENT,\n+}\n+\n+/// [`Self::IDENT`]\n+//~^ ERROR both an associated function and an associated type\n+pub trait Trait {\n+    type IDENT;\n+    fn IDENT();\n+}\n+\n+/// [`Self::IDENT`]\n+//~^ ERROR both an associated function and a variant\n+impl Trait for Enum {\n+    type IDENT = usize;\n+    fn IDENT() {}\n+}\n+\n+/// [`Self::IDENT2`]\n+//~^ ERROR both an associated constant and an associated type\n+pub trait Trait2 {\n+    type IDENT2;\n+    const IDENT2: usize;\n+}\n+\n+/// [`Self::IDENT2`]\n+//~^ ERROR both an associated constant and an associated type\n+impl Trait2 for Enum {\n+    type IDENT2 = usize;\n+    const IDENT2: usize = 0;\n+}"}, {"sha": "084aefc97c8348f72f4f91e616fd4f26669330fb", "filename": "tests/rustdoc-ui/intra-doc/issue-108653-associated-items.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-108653-associated-items.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,67 @@\n+error: `Self::IDENT` is both an associated function and an associated type\n+  --> $DIR/issue-108653-associated-items.rs:9:7\n+   |\n+LL | /// [`Self::IDENT`]\n+   |       ^^^^^^^^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-108653-associated-items.rs:3:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the associated function, add parentheses\n+   |\n+LL | /// [`Self::IDENT()`]\n+   |                  ++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Self::IDENT`]\n+   |       +++++\n+\n+error: `Self::IDENT2` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items.rs:23:7\n+   |\n+LL | /// [`Self::IDENT2`]\n+   |       ^^^^^^^^^^^^ ambiguous link\n+   |\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@Self::IDENT2`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Self::IDENT2`]\n+   |       +++++\n+\n+error: `Self::IDENT2` is both an associated constant and an associated type\n+  --> $DIR/issue-108653-associated-items.rs:30:7\n+   |\n+LL | /// [`Self::IDENT2`]\n+   |       ^^^^^^^^^^^^ ambiguous link\n+   |\n+help: to link to the associated constant, prefix with `const@`\n+   |\n+LL | /// [`const@Self::IDENT2`]\n+   |       ++++++\n+help: to link to the associated type, prefix with `type@`\n+   |\n+LL | /// [`type@Self::IDENT2`]\n+   |       +++++\n+\n+error: `Self::IDENT` is both an associated function and a variant\n+  --> $DIR/issue-108653-associated-items.rs:16:7\n+   |\n+LL | /// [`Self::IDENT`]\n+   |       ^^^^^^^^^^^ ambiguous link\n+   |\n+help: to link to the associated function, add parentheses\n+   |\n+LL | /// [`Self::IDENT()`]\n+   |                  ++\n+help: to link to the variant, prefix with `type@`\n+   |\n+LL | /// [`type@Self::IDENT`]\n+   |       +++++\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "6e08a923963c4e1cb70988d420c41b8ab140231f", "filename": "tests/rustdoc-ui/intra-doc/non-path-primitives.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -39,25 +39,25 @@ error: unresolved link to `unit::eq`\n   --> $DIR/non-path-primitives.rs:28:6\n    |\n LL | //! [unit::eq]\n-   |      ^^^^^^^^ the builtin type `unit` has no associated item named `eq`\n+   |      ^^^^^^^^ the primitive type `unit` has no associated item named `eq`\n \n error: unresolved link to `tuple::eq`\n   --> $DIR/non-path-primitives.rs:29:6\n    |\n LL | //! [tuple::eq]\n-   |      ^^^^^^^^^ the builtin type `tuple` has no associated item named `eq`\n+   |      ^^^^^^^^^ the primitive type `tuple` has no associated item named `eq`\n \n error: unresolved link to `fn::eq`\n   --> $DIR/non-path-primitives.rs:30:6\n    |\n LL | //! [fn::eq]\n-   |      ^^^^^^ the builtin type `fn` has no associated item named `eq`\n+   |      ^^^^^^ the primitive type `fn` has no associated item named `eq`\n \n error: unresolved link to `reference::deref`\n   --> $DIR/non-path-primitives.rs:34:6\n    |\n LL | //! [reference::deref]\n-   |      ^^^^^^^^^^^^^^^^ the builtin type `reference` has no associated item named `deref`\n+   |      ^^^^^^^^^^^^^^^^ the primitive type `reference` has no associated item named `deref`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "e87ce095cd4341c949adabe86f111f94ce5dc398", "filename": "tests/rustdoc-ui/intra-doc/prim-conflict.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fprim-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fprim-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fprim-conflict.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -2,16 +2,16 @@\n //~^ NOTE lint level is defined\n \n /// [char]\n-//~^ ERROR both a module and a builtin type\n+//~^ ERROR both a module and a primitive type\n //~| NOTE ambiguous link\n //~| HELP to link to the module\n-//~| HELP to link to the builtin type\n+//~| HELP to link to the primitive type\n \n /// [type@char]\n-//~^ ERROR both a module and a builtin type\n+//~^ ERROR both a module and a primitive type\n //~| NOTE ambiguous link\n //~| HELP to link to the module\n-//~| HELP to link to the builtin type\n+//~| HELP to link to the primitive type\n \n /// [mod@char] // ok\n /// [prim@char] // ok\n@@ -26,5 +26,5 @@ pub mod inner {\n     //! [struct@char]\n     //~^ ERROR incompatible link\n     //~| HELP prefix with `prim@`\n-    //~| NOTE resolved to a builtin type\n+    //~| NOTE resolved to a primitive type\n }"}, {"sha": "03ce8f15f0a5e8699b5d231f0596b4ea00554c2a", "filename": "tests/rustdoc-ui/intra-doc/prim-conflict.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fprim-conflict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc-ui%2Fintra-doc%2Fprim-conflict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fprim-conflict.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,4 +1,4 @@\n-error: `char` is both a module and a builtin type\n+error: `char` is both a module and a primitive type\n   --> $DIR/prim-conflict.rs:4:6\n    |\n LL | /// [char]\n@@ -13,12 +13,12 @@ help: to link to the module, prefix with `mod@`\n    |\n LL | /// [mod@char]\n    |      ++++\n-help: to link to the builtin type, prefix with `prim@`\n+help: to link to the primitive type, prefix with `prim@`\n    |\n LL | /// [prim@char]\n    |      +++++\n \n-error: `char` is both a module and a builtin type\n+error: `char` is both a module and a primitive type\n   --> $DIR/prim-conflict.rs:10:6\n    |\n LL | /// [type@char]\n@@ -28,7 +28,7 @@ help: to link to the module, prefix with `mod@`\n    |\n LL | /// [mod@char]\n    |      ~~~~\n-help: to link to the builtin type, prefix with `prim@`\n+help: to link to the primitive type, prefix with `prim@`\n    |\n LL | /// [prim@char]\n    |      ~~~~~\n@@ -48,9 +48,9 @@ error: incompatible link kind for `char`\n   --> $DIR/prim-conflict.rs:26:10\n    |\n LL |     //! [struct@char]\n-   |          ^^^^^^^^^^^ this link resolved to a builtin type, which is not a struct\n+   |          ^^^^^^^^^^^ this link resolved to a primitive type, which is not a struct\n    |\n-help: to link to the builtin type, prefix with `prim@`\n+help: to link to the primitive type, prefix with `prim@`\n    |\n LL |     //! [prim@char]\n    |          ~~~~~"}, {"sha": "bfce46cf4444af0442dc41e8bb8d3b428462bfc9", "filename": "tests/rustdoc/notable-trait/doc-notable_trait-mut_t_is_not_an_iterator.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-mut_t_is_not_an_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-mut_t_is_not_an_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-mut_t_is_not_an_iterator.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/rustdoc/doc-notable_trait-mut_t_is_not_an_iterator.rs"}, {"sha": "b359dcea0ff471bd768f366a6a13a3b45a9d7110", "filename": "tests/rustdoc/notable-trait/doc-notable_trait-mut_t_is_not_ref_t.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-mut_t_is_not_ref_t.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-mut_t_is_not_ref_t.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-mut_t_is_not_ref_t.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/rustdoc/doc-notable_trait-mut_t_is_not_ref_t.rs"}, {"sha": "46be00a080482818f4af2c588dbdf6612953ea4a", "filename": "tests/rustdoc/notable-trait/doc-notable_trait-slice.bare_fn_matches.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-slice.bare_fn_matches.html", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-slice.bare_fn_matches.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-slice.bare_fn_matches.html?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/rustdoc/doc-notable_trait-slice.bare_fn_matches.html"}, {"sha": "ef206710b4b0829b9a757b1dbd36695fb3d8703f", "filename": "tests/rustdoc/notable-trait/doc-notable_trait-slice.rs", "status": "renamed", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-slice.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -18,3 +18,9 @@ pub fn bare_fn_matches() -> &'static [SomeStruct] {\n pub fn bare_fn_no_matches() -> &'static [OtherStruct] {\n     &[]\n }\n+\n+// @has doc_notable_trait_slice/fn.bare_fn_mut_no_matches.html\n+// @count - '//script[@id=\"notable-traits-data\"]' 0\n+pub fn bare_fn_mut_no_matches() -> &'static mut [SomeStruct] {\n+    &mut []\n+}", "previous_filename": "tests/rustdoc/doc-notable_trait-slice.rs"}, {"sha": "f592e3b375c026061ec0fb7274a8eef453f201b5", "filename": "tests/rustdoc/notable-trait/doc-notable_trait.bare-fn.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.bare-fn.html", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.bare-fn.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.bare-fn.html?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/rustdoc/doc-notable_trait.bare-fn.html"}, {"sha": "d8941769fa67ab2aad23682979a892fd6b803d63", "filename": "tests/rustdoc/notable-trait/doc-notable_trait.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/rustdoc/doc-notable_trait.rs"}, {"sha": "e8f4f6000457dcaee93238ded6d67463ecf74304", "filename": "tests/rustdoc/notable-trait/doc-notable_trait.some-struct-new.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.some-struct-new.html", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.some-struct-new.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.some-struct-new.html?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/rustdoc/doc-notable_trait.some-struct-new.html"}, {"sha": "e7909669b150a2720e172d0079f428f88ff9199f", "filename": "tests/rustdoc/notable-trait/doc-notable_trait.wrap-me.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.wrap-me.html", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.wrap-me.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.wrap-me.html?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/rustdoc/doc-notable_trait.wrap-me.html"}, {"sha": "3fb00c7db84115b3661fd87b6ac4a3e5f9305f7b", "filename": "tests/rustdoc/notable-trait/doc-notable_trait_box_is_not_an_iterator.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait_box_is_not_an_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait_box_is_not_an_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait_box_is_not_an_iterator.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/rustdoc/doc-notable_trait_box_is_not_an_iterator.rs"}, {"sha": "611902abad65b99fd7cf44a0dce276d86c35a8d7", "filename": "tests/rustdoc/notable-trait/notable-trait-generics.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fnotable-trait-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fnotable-trait-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fnotable-trait-generics.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,35 @@\n+#![feature(doc_notable_trait)]\n+\n+// Notable traits SHOULD NOT be shown when the `impl` has a concrete type and\n+// the return type has a generic type.\n+pub mod generic_return {\n+    pub struct Wrapper<T>(T);\n+\n+    #[doc(notable_trait)]\n+    pub trait NotableTrait {}\n+\n+    impl NotableTrait for Wrapper<u8> {}\n+\n+    // @has notable_trait_generics/generic_return/fn.returning.html\n+    // @!has - '//a[@class=\"tooltip\"]/@data-notable-ty' 'Wrapper<T>'\n+    pub fn returning<T>() -> Wrapper<T> {\n+        loop {}\n+    }\n+}\n+\n+// Notable traits SHOULD be shown when the `impl` has a generic type and the\n+// return type has a concrete type.\n+pub mod generic_impl {\n+    pub struct Wrapper<T>(T);\n+\n+    #[doc(notable_trait)]\n+    pub trait NotableTrait {}\n+\n+    impl<T> NotableTrait for Wrapper<T> {}\n+\n+    // @has notable_trait_generics/generic_impl/fn.returning.html\n+    // @has - '//a[@class=\"tooltip\"]/@data-notable-ty' 'Wrapper<u8>'\n+    pub fn returning() -> Wrapper<u8> {\n+        loop {}\n+    }\n+}"}, {"sha": "5f54b7522ae38774e61e4c8cd7c44dc775ad410b", "filename": "tests/rustdoc/notable-trait/spotlight-from-dependency.odd.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fspotlight-from-dependency.odd.html", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fspotlight-from-dependency.odd.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fspotlight-from-dependency.odd.html?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/rustdoc/spotlight-from-dependency.odd.html"}, {"sha": "426759c7bf8a218aca6c3a699782b037e8deccdb", "filename": "tests/rustdoc/notable-trait/spotlight-from-dependency.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fspotlight-from-dependency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Frustdoc%2Fnotable-trait%2Fspotlight-from-dependency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fspotlight-from-dependency.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "previous_filename": "tests/rustdoc/spotlight-from-dependency.rs"}, {"sha": "a3b570ad8c40c5e572ba483eb4963980dfda68af", "filename": "tests/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b00302e2884fe28c710b6d7513b477455ad14e82/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00302e2884fe28c710b6d7513b477455ad14e82/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=b00302e2884fe28c710b6d7513b477455ad14e82", "patch": "@@ -1,80 +0,0 @@\n-// force-host\n-\n-#![feature(rustc_private)]\n-\n-extern crate rustc_driver;\n-extern crate rustc_hir;\n-extern crate rustc_lint;\n-extern crate rustc_span;\n-#[macro_use]\n-extern crate rustc_session;\n-extern crate rustc_ast;\n-\n-use rustc_ast::attr;\n-use rustc_driver::plugin::Registry;\n-use rustc_lint::{LateContext, LateLintPass, LintContext, LintPass};\n-use rustc_span::def_id::CRATE_DEF_ID;\n-use rustc_span::symbol::Symbol;\n-\n-macro_rules! fake_lint_pass {\n-    ($struct:ident, $($attr:expr),*) => {\n-        struct $struct;\n-\n-        impl LintPass for $struct {\n-            fn name(&self) -> &'static str {\n-                stringify!($struct)\n-            }\n-        }\n-\n-        impl LateLintPass<'_> for $struct {\n-            fn check_crate(&mut self, cx: &LateContext) {\n-                let attrs = cx.tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n-                let span = cx.tcx.def_span(CRATE_DEF_ID);\n-                $(\n-                    if !cx.sess().contains_name(attrs, $attr) {\n-                        cx.lint(CRATE_NOT_OKAY, |lint| {\n-                             let msg = format!(\"crate is not marked with #![{}]\", $attr);\n-                             lint.build(&msg).set_span(span).emit();\n-                        });\n-                    }\n-                )*\n-            }\n-        }\n-\n-    }\n-}\n-\n-declare_lint!(CRATE_NOT_OKAY, Warn, \"crate not marked with #![crate_okay]\");\n-declare_lint!(CRATE_NOT_RED, Warn, \"crate not marked with #![crate_red]\");\n-declare_lint!(CRATE_NOT_BLUE, Warn, \"crate not marked with #![crate_blue]\");\n-declare_lint!(CRATE_NOT_GREY, Warn, \"crate not marked with #![crate_grey]\");\n-declare_lint!(CRATE_NOT_GREEN, Warn, \"crate not marked with #![crate_green]\");\n-\n-fake_lint_pass! {\n-    PassOkay,\n-    Symbol::intern(\"crate_okay\")\n-}\n-\n-fake_lint_pass! {\n-    PassRedBlue,\n-    Symbol::intern(\"crate_red\"), Symbol::intern(\"crate_blue\")\n-}\n-\n-fake_lint_pass! {\n-    PassGreyGreen,\n-    Symbol::intern(\"crate_grey\"), Symbol::intern(\"crate_green\")\n-}\n-\n-#[no_mangle]\n-fn __rustc_plugin_registrar(reg: &mut Registry) {\n-    reg.lint_store.register_lints(&[\n-        &CRATE_NOT_OKAY,\n-        &CRATE_NOT_RED,\n-        &CRATE_NOT_BLUE,\n-        &CRATE_NOT_GREY,\n-        &CRATE_NOT_GREEN,\n-    ]);\n-    reg.lint_store.register_late_pass(|_| Box::new(PassOkay));\n-    reg.lint_store.register_late_pass(|_| Box::new(PassRedBlue));\n-    reg.lint_store.register_late_pass(|_| Box::new(PassGreyGreen));\n-}"}, {"sha": "6304c07d2c7ce6fe88118d7e3f41f3ae7d5a314e", "filename": "tests/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -4,13 +4,13 @@\n \n extern crate rustc_driver;\n extern crate rustc_hir;\n-#[macro_use]\n extern crate rustc_lint;\n #[macro_use]\n extern crate rustc_session;\n extern crate rustc_ast;\n extern crate rustc_span;\n \n+use rustc_ast::attr;\n use rustc_driver::plugin::Registry;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_span::def_id::CRATE_DEF_ID;\n@@ -28,12 +28,10 @@ impl<'tcx> LateLintPass<'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext) {\n         let attrs = cx.tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n         let span = cx.tcx.def_span(CRATE_DEF_ID);\n-        if !cx.sess().contains_name(attrs, Symbol::intern(\"crate_okay\")) {\n-            cx.lint(\n-                CRATE_NOT_OKAY,\n-                \"crate is not marked with #![crate_okay]\",\n-                |lint| lint.set_span(span)\n-            );\n+        if !attr::contains_name(attrs, Symbol::intern(\"crate_okay\")) {\n+            cx.lint(CRATE_NOT_OKAY, \"crate is not marked with #![crate_okay]\", |lint| {\n+                lint.set_span(span)\n+            });\n         }\n     }\n }"}, {"sha": "6f95273116b78af569216574bb78c975cede43e2", "filename": "tests/ui/associated-inherent-types/issue-109299-1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types, non_lifetime_binders, type_alias_impl_trait)]\n+#![allow(incomplete_features)]\n+\n+struct Lexer<T>(T);\n+\n+impl Lexer<i32> {\n+    type Cursor = ();\n+}\n+\n+type X = impl for<T> Fn() -> Lexer<T>::Cursor; //~ ERROR associated type `Cursor` not found for `Lexer<T>` in the current scope\n+\n+fn main() {}"}, {"sha": "dc59b56ee207dc1fec88cca04487dd9af07e481a", "filename": "tests/ui/associated-inherent-types/issue-109299-1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,15 @@\n+error[E0220]: associated type `Cursor` not found for `Lexer<T>` in the current scope\n+  --> $DIR/issue-109299-1.rs:10:40\n+   |\n+LL | struct Lexer<T>(T);\n+   | --------------- associated item `Cursor` not found for this struct\n+...\n+LL | type X = impl for<T> Fn() -> Lexer<T>::Cursor;\n+   |                                        ^^^^^^ associated item not found in `Lexer<T>`\n+   |\n+   = note: the associated type was found for\n+           - `Lexer<i32>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "84e4f9e72527aa21025ab3b061ceb17b1a47afbd", "filename": "tests/ui/associated-inherent-types/issue-109299.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Lexer<'d>(&'d ());\n+\n+impl Lexer<'d> { //~ ERROR use of undeclared lifetime name `'d`\n+    type Cursor = ();\n+}\n+\n+fn test(_: Lexer::Cursor) {}\n+\n+fn main() {}"}, {"sha": "63f50732d3c50985b420dfa33b4686e6f88c97d5", "filename": "tests/ui/associated-inherent-types/issue-109299.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,11 @@\n+error[E0261]: use of undeclared lifetime name `'d`\n+  --> $DIR/issue-109299.rs:6:12\n+   |\n+LL | impl Lexer<'d> {\n+   |     -      ^^ undeclared lifetime\n+   |     |\n+   |     help: consider introducing lifetime `'d` here: `<'d>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0261`."}, {"sha": "3d010f18009d1102f05d084561f093132e17ae8d", "filename": "tests/ui/async-await/in-trait/issue-104678.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-104678.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-104678.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-104678.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,5 +1,7 @@\n // edition:2021\n // check-pass\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "10edae437ee74283ab235c68f54142f1c24da29c", "filename": "tests/ui/consts/const-eval/ub-uninhabit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -14,12 +14,12 @@ union MaybeUninit<T: Copy> {\n }\n \n const BAD_BAD_BAD: Bar = unsafe { MaybeUninit { uninit: () }.init };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n \n const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n const BAD_BAD_ARRAY: [Bar; 1] = unsafe { MaybeUninit { uninit: () }.init };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n \n fn main() {}"}, {"sha": "733975fc0e9ce5e3011048f7e66f6a5860f54948", "filename": "tests/ui/consts/const-eval/ub-uninhabit.stderr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,11 +1,8 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:16:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-uninhabit.rs:16:35\n    |\n LL | const BAD_BAD_BAD: Bar = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Bar\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {}\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Bar\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:19:1\n@@ -18,14 +15,11 @@ LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n                HEX_DUMP\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:22:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-uninhabit.rs:22:42\n    |\n LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered a value of uninhabited type Bar\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {}\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered a value of uninhabited type Bar\n \n error: aborting due to 3 previous errors\n "}, {"sha": "231005d7e3975dc8bfe47d3a9f34abc7869efcf3", "filename": "tests/ui/consts/const-eval/validate_uninhabited_zsts.32bit.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -24,14 +24,11 @@ note: inside `FOO`\n LL | const FOO: [empty::Empty; 3] = [foo(); 3];\n    |                                 ^^^^^\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_uninhabited_zsts.rs:21:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/validate_uninhabited_zsts.rs:21:42\n    |\n LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0].0: encountered a value of uninhabited type empty::Void\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered a value of uninhabited type empty::Void\n \n warning: the type `empty::Empty` does not permit zero-initialization\n   --> $DIR/validate_uninhabited_zsts.rs:21:42"}, {"sha": "231005d7e3975dc8bfe47d3a9f34abc7869efcf3", "filename": "tests/ui/consts/const-eval/validate_uninhabited_zsts.64bit.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -24,14 +24,11 @@ note: inside `FOO`\n LL | const FOO: [empty::Empty; 3] = [foo(); 3];\n    |                                 ^^^^^\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_uninhabited_zsts.rs:21:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/validate_uninhabited_zsts.rs:21:42\n    |\n LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0].0: encountered a value of uninhabited type empty::Void\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered a value of uninhabited type empty::Void\n \n warning: the type `empty::Empty` does not permit zero-initialization\n   --> $DIR/validate_uninhabited_zsts.rs:21:42"}, {"sha": "b6783175dd3795bfc0b0eebb20e453bee4c5977d", "filename": "tests/ui/consts/const-eval/validate_uninhabited_zsts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -19,7 +19,7 @@ pub mod empty {\n const FOO: [empty::Empty; 3] = [foo(); 3];\n \n const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n //~| WARN the type `empty::Empty` does not permit zero-initialization\n \n fn main() {"}, {"sha": "9275a8a072ddecb68274ef93346854ee23296d6b", "filename": "tests/ui/consts/issue-64506.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fissue-64506.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fissue-64506.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-64506.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// check-fail\n \n #[derive(Copy, Clone)]\n pub struct ChildStdin {\n@@ -14,6 +14,7 @@ const FOO: () = {\n         b: (),\n     }\n     let x = unsafe { Foo { b: () }.a };\n+    //~^ ERROR: evaluation of constant value failed\n     let x = &x.inner;\n };\n "}, {"sha": "31a5b1df837c5b186927af14c0593d7ef428f433", "filename": "tests/ui/consts/issue-64506.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fissue-64506.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fconsts%2Fissue-64506.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-64506.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,9 @@\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-64506.rs:16:22\n+   |\n+LL |     let x = unsafe { Foo { b: () }.a };\n+   |                      ^^^^^^^^^^^^^^^ constructing invalid value at .inner: encountered a value of uninhabited type AnonPipe\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "74f7bc603aafcb1f782ef26c0ce5ed327d709435", "filename": "tests/ui/impl-trait/in-trait/auxiliary/rpitit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fauxiliary%2Frpitit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fauxiliary%2Frpitit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fauxiliary%2Frpitit.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,3 +1,5 @@\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+\n #![feature(return_position_impl_trait_in_trait)]\n \n pub trait Foo {"}, {"sha": "b8a793e1a7bb5314feaa8b000c7610f1fa59e7ee", "filename": "tests/ui/impl-trait/in-trait/dont-project-to-rpitit-with-no-value.current.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.current.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `return_position_impl_trait_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/dont-project-to-rpitit-with-no-value.rs:1:12\n+  --> $DIR/dont-project-to-rpitit-with-no-value.rs:4:12\n    |\n LL | #![feature(return_position_impl_trait_in_trait)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL | #![feature(return_position_impl_trait_in_trait)]\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0046]: not all trait items implemented, missing: `foo`\n-  --> $DIR/dont-project-to-rpitit-with-no-value.rs:9:1\n+  --> $DIR/dont-project-to-rpitit-with-no-value.rs:12:1\n    |\n LL |     fn foo(&self) -> impl Sized;\n    |     ---------------------------- `foo` from trait", "previous_filename": "tests/ui/impl-trait/in-trait/dont-project-to-rpitit-with-no-value.stderr"}, {"sha": "b8a793e1a7bb5314feaa8b000c7610f1fa59e7ee", "filename": "tests/ui/impl-trait/in-trait/dont-project-to-rpitit-with-no-value.next.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.next.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,21 @@\n+warning: the feature `return_position_impl_trait_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/dont-project-to-rpitit-with-no-value.rs:4:12\n+   |\n+LL | #![feature(return_position_impl_trait_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0046]: not all trait items implemented, missing: `foo`\n+  --> $DIR/dont-project-to-rpitit-with-no-value.rs:12:1\n+   |\n+LL |     fn foo(&self) -> impl Sized;\n+   |     ---------------------------- `foo` from trait\n+...\n+LL | impl MyTrait for i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^ missing `foo` in implementation\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0046`."}, {"sha": "8329ce1f835d04c8e58ab61ebb90a46844891971", "filename": "tests/ui/impl-trait/in-trait/dont-project-to-rpitit-with-no-value.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,3 +1,6 @@\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n+\n #![feature(return_position_impl_trait_in_trait)]\n //~^ WARN the feature `return_position_impl_trait_in_trait` is incomplete\n \n@@ -7,7 +10,7 @@ trait MyTrait {\n }\n \n impl MyTrait for i32 {\n-//~^ ERROR not all trait items implemented, missing: `foo`\n+    //~^ ERROR not all trait items implemented, missing: `foo`\n     fn bar(&self) -> impl Sized {\n         self.foo()\n     }"}, {"sha": "7575372b940fdfa7cb85b674dc45ca7affe11137", "filename": "tests/ui/parser/ident-recovery.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fparser%2Fident-recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fparser%2Fident-recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fident-recovery.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,16 @@\n+fn ,comma() {\n+    //~^ ERROR expected identifier, found `,`\n+    struct Foo {\n+        x: i32,,\n+        //~^ ERROR expected identifier, found `,`\n+        y: u32,\n+    }\n+}\n+\n+fn break() {\n+//~^ ERROR expected identifier, found keyword `break`\n+    let continue = 5;\n+    //~^ ERROR expected identifier, found keyword `continue`\n+}\n+\n+fn main() {}"}, {"sha": "e9a55026d12450ffd7feb846d29db272058710d1", "filename": "tests/ui/parser/ident-recovery.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fparser%2Fident-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fparser%2Fident-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fident-recovery.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,42 @@\n+error: expected identifier, found `,`\n+  --> $DIR/ident-recovery.rs:1:4\n+   |\n+LL | fn ,comma() {\n+   |    ^\n+   |    |\n+   |    expected identifier\n+   |    help: remove this comma\n+\n+error: expected identifier, found `,`\n+  --> $DIR/ident-recovery.rs:4:16\n+   |\n+LL |         x: i32,,\n+   |                ^\n+   |                |\n+   |                expected identifier\n+   |                help: remove this comma\n+\n+error: expected identifier, found keyword `break`\n+  --> $DIR/ident-recovery.rs:10:4\n+   |\n+LL | fn break() {\n+   |    ^^^^^ expected identifier, found keyword\n+   |\n+help: escape `break` to use it as an identifier\n+   |\n+LL | fn r#break() {\n+   |    ++\n+\n+error: expected identifier, found keyword `continue`\n+  --> $DIR/ident-recovery.rs:12:9\n+   |\n+LL |     let continue = 5;\n+   |         ^^^^^^^^ expected identifier, found keyword\n+   |\n+help: escape `continue` to use it as an identifier\n+   |\n+LL |     let r#continue = 5;\n+   |         ++\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "b2c6612965608ed45307849ed034d9ce480ac0dc", "filename": "tests/ui/parser/integer-literal-start-ident.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fparser%2Finteger-literal-start-ident.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fparser%2Finteger-literal-start-ident.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Finteger-literal-start-ident.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -4,7 +4,11 @@ error: expected identifier, found `1main`\n LL | fn 1main() {}\n    |    ^^^^^ expected identifier\n    |\n-   = help: identifiers cannot start with a number\n+help: identifiers cannot start with a number\n+  --> $DIR/integer-literal-start-ident.rs:1:4\n+   |\n+LL | fn 1main() {}\n+   |    ^\n \n error: aborting due to previous error\n "}, {"sha": "3dc636b6a33bd5db95805b44a321838b934f6f75", "filename": "tests/ui/parser/issues/issue-104088.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fparser%2Fissues%2Fissue-104088.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fparser%2Fissues%2Fissue-104088.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-104088.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,26 +1,19 @@\n-fn test() {\n+fn 1234test() {\n+//~^ ERROR expected identifier, found `1234test`\n     if let 123 = 123 { println!(\"yes\"); }\n-}\n-\n-fn test_2() {\n-    let 1x = 123;\n-    //~^ ERROR expected identifier, found `1x`\n-}\n-\n-fn test_3() {\n-    let 2x: i32 = 123;\n-    //~^ ERROR expected identifier, found `2x`\n-}\n \n-fn test_4() {\n     if let 2e1 = 123 {\n         //~^ ERROR mismatched types\n     }\n-}\n \n-fn test_5() {\n     let 23name = 123;\n     //~^ ERROR expected identifier, found `23name`\n+\n+    let 2x: i32 = 123;\n+    //~^ ERROR expected identifier, found `2x`\n+\n+    let 1x = 123;\n+    //~^ ERROR expected identifier, found `1x`\n }\n \n fn main() {}"}, {"sha": "8b751759d69a667314fef024e0be03a1356b5198", "filename": "tests/ui/parser/issues/issue-104088.stderr", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fparser%2Fissues%2Fissue-104088.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Fparser%2Fissues%2Fissue-104088.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-104088.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,35 +1,59 @@\n-error: expected identifier, found `1x`\n-  --> $DIR/issue-104088.rs:6:9\n+error: expected identifier, found `1234test`\n+  --> $DIR/issue-104088.rs:1:4\n    |\n-LL |     let 1x = 123;\n-   |         ^^ expected identifier\n+LL | fn 1234test() {\n+   |    ^^^^^^^^ expected identifier\n+   |\n+help: identifiers cannot start with a number\n+  --> $DIR/issue-104088.rs:1:4\n+   |\n+LL | fn 1234test() {\n+   |    ^^^^\n+\n+error: expected identifier, found `23name`\n+  --> $DIR/issue-104088.rs:9:9\n+   |\n+LL |     let 23name = 123;\n+   |         ^^^^^^ expected identifier\n+   |\n+help: identifiers cannot start with a number\n+  --> $DIR/issue-104088.rs:9:9\n    |\n-   = help: identifiers cannot start with a number\n+LL |     let 23name = 123;\n+   |         ^^\n \n error: expected identifier, found `2x`\n-  --> $DIR/issue-104088.rs:11:9\n+  --> $DIR/issue-104088.rs:12:9\n    |\n LL |     let 2x: i32 = 123;\n    |         ^^ expected identifier\n    |\n-   = help: identifiers cannot start with a number\n+help: identifiers cannot start with a number\n+  --> $DIR/issue-104088.rs:12:9\n+   |\n+LL |     let 2x: i32 = 123;\n+   |         ^\n \n-error: expected identifier, found `23name`\n-  --> $DIR/issue-104088.rs:22:9\n+error: expected identifier, found `1x`\n+  --> $DIR/issue-104088.rs:15:9\n    |\n-LL |     let 23name = 123;\n-   |         ^^^^^^ expected identifier\n+LL |     let 1x = 123;\n+   |         ^^ expected identifier\n    |\n-   = help: identifiers cannot start with a number\n+help: identifiers cannot start with a number\n+  --> $DIR/issue-104088.rs:15:9\n+   |\n+LL |     let 1x = 123;\n+   |         ^\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-104088.rs:16:12\n+  --> $DIR/issue-104088.rs:5:12\n    |\n LL |     if let 2e1 = 123 {\n    |            ^^^   --- this expression has type `{integer}`\n    |            |\n    |            expected integer, found floating-point number\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "11636bfeb55095bef82786977005e554f45b2dd9", "filename": "tests/ui/traits/new-solver/coherence/issue-102048.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,44 @@\n+// This must fail coherence.\n+//\n+// Getting this to pass was fairly difficult, so here's an explanation\n+// of what's happening:\n+//\n+// Normalizing projections currently tries to replace them with inference variables\n+// while emitting a nested `Projection` obligation. This cannot be done if the projection\n+// has bound variables which is the case here.\n+//\n+// So the projections stay until after normalization. When unifying two projections we\n+// currently treat them as if they are injective, so we **incorrectly** unify their\n+// substs. This means that coherence for the two impls ends up unifying `?T` and `?U`\n+// as it tries to unify `<?T as WithAssoc1<'a>>::Assoc` with `<?U as WithAssoc1<'a>>::Assoc`.\n+//\n+// `impl1` therefore has the projection `<?T as WithAssoc2<'a>>::Assoc` and we have the\n+// assumption `?T: for<'a> WithAssoc2<'a, Assoc = i32>` in the `param_env`, so we normalize\n+// that to `i32`. We then try to unify `i32` from `impl1` with `u32` from `impl2` which fails,\n+// causing coherence to consider these two impls distinct.\n+\n+// compile-flags: -Ztrait-solver=next\n+pub trait Trait<T> {}\n+\n+pub trait WithAssoc1<'a> {\n+    type Assoc;\n+}\n+pub trait WithAssoc2<'a> {\n+    type Assoc;\n+}\n+\n+// impl 1\n+impl<T, U> Trait<for<'a> fn(<T as WithAssoc1<'a>>::Assoc, <U as WithAssoc2<'a>>::Assoc)> for (T, U)\n+where\n+    T: for<'a> WithAssoc1<'a> + for<'a> WithAssoc2<'a, Assoc = i32>,\n+    U: for<'a> WithAssoc2<'a>,\n+{\n+}\n+\n+// impl 2\n+impl<T, U> Trait<for<'a> fn(<U as WithAssoc1<'a>>::Assoc, u32)> for (T, U) where\n+    U: for<'a> WithAssoc1<'a> //~^ ERROR conflicting implementations of trait\n+{\n+}\n+\n+fn main() {}"}, {"sha": "17a43838fe2754d9c6bd20e23375e6fcbf24aec9", "filename": "tests/ui/traits/new-solver/coherence/issue-102048.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,12 @@\n+error[E0119]: conflicting implementations of trait `Trait<for<'a> fn(<_ as WithAssoc1<'a>>::Assoc, <_ as WithAssoc2<'a>>::Assoc)>` for type `(_, _)`\n+  --> $DIR/issue-102048.rs:39:1\n+   |\n+LL | impl<T, U> Trait<for<'a> fn(<T as WithAssoc1<'a>>::Assoc, <U as WithAssoc2<'a>>::Assoc)> for (T, U)\n+   | --------------------------------------------------------------------------------------------------- first implementation here\n+...\n+LL | impl<T, U> Trait<for<'a> fn(<U as WithAssoc1<'a>>::Assoc, u32)> for (T, U) where\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(_, _)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "e5a3c3f5cc4b79db1bfd9d367e22c929caaa9984", "filename": "tests/ui/traits/reservation-impl/coherence-conflict.next.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.next.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,11 @@\n+error[E0119]: conflicting implementations of trait `OtherTrait` for type `()`\n+  --> $DIR/coherence-conflict.rs:12:1\n+   |\n+LL | impl OtherTrait for () {}\n+   | ---------------------- first implementation here\n+LL | impl<T: MyTrait> OtherTrait for T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "393350ea3f12a52f2a4b3a104566d671d242fc47", "filename": "tests/ui/traits/reservation-impl/coherence-conflict.old.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.old.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,5 +1,5 @@\n error[E0119]: conflicting implementations of trait `OtherTrait` for type `()`\n-  --> $DIR/coherence-conflict.rs:11:1\n+  --> $DIR/coherence-conflict.rs:12:1\n    |\n LL | impl OtherTrait for () {}\n    | ---------------------- first implementation here", "previous_filename": "tests/ui/traits/reservation-impl/coherence-conflict.stderr"}, {"sha": "6bbd90f94dc392a121f8b875bc34884ae87e2559", "filename": "tests/ui/traits/reservation-impl/coherence-conflict.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,5 +1,6 @@\n // check that reservation impls are accounted for in negative reasoning.\n-\n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n #![feature(rustc_attrs)]\n \n trait MyTrait {}"}, {"sha": "542e3a28adf280889af0e8607e11d88a67da5985", "filename": "tests/ui/traits/reservation-impl/no-use.next.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.next.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `(): MyTrait` is not satisfied\n-  --> $DIR/no-use.rs:10:26\n+  --> $DIR/no-use.rs:11:26\n    |\n LL |     <() as MyTrait>::foo(&());\n    |     -------------------- ^^^ the trait `MyTrait` is not implemented for `()`", "previous_filename": "tests/ui/traits/reservation-impl/no-use.stderr"}, {"sha": "542e3a28adf280889af0e8607e11d88a67da5985", "filename": "tests/ui/traits/reservation-impl/no-use.old.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.old.stderr?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -0,0 +1,13 @@\n+error[E0277]: the trait bound `(): MyTrait` is not satisfied\n+  --> $DIR/no-use.rs:11:26\n+   |\n+LL |     <() as MyTrait>::foo(&());\n+   |     -------------------- ^^^ the trait `MyTrait` is not implemented for `()`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `MyTrait` is implemented for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "864f1791fd0a79ab3d1d184b3f72813a51a9dba5", "filename": "tests/ui/traits/reservation-impl/no-use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -1,5 +1,6 @@\n // check that reservation impls can't be used as normal impls in positive reasoning.\n-\n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n #![feature(rustc_attrs)]\n \n trait MyTrait { fn foo(&self); }"}, {"sha": "7787904d9b22d581ce12b00a566e4526dfcdd340", "filename": "tests/ui/traits/reservation-impl/non-lattice-ok.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -30,6 +30,12 @@\n //\n // [ii]: https://smallcultfollowing.com/babysteps/blog/2016/09/24/intersection-impls/\n \n+\n+// check that reservation impls can't be used as normal impls in positive reasoning.\n+\n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n+\n #![feature(rustc_attrs, never_type)]\n \n trait MyTrait {}"}, {"sha": "8ff6645a2b3d38d3398470c80cf9bd4ef2d5edb0", "filename": "tests/ui/traits/reservation-impl/ok.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8fc361d8998acf87a916db34707cdca9630338/tests%2Fui%2Ftraits%2Freservation-impl%2Fok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fok.rs?ref=8c8fc361d8998acf87a916db34707cdca9630338", "patch": "@@ -3,6 +3,9 @@\n // rpass test for reservation impls. Not 100% required because `From` uses them,\n // but still.\n \n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n+\n #![feature(rustc_attrs)]\n \n use std::mem;"}]}