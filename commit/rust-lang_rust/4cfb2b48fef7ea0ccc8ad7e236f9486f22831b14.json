{"sha": "4cfb2b48fef7ea0ccc8ad7e236f9486f22831b14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZmIyYjQ4ZmVmN2VhMGNjYzhhZDdlMjM2Zjk0ODZmMjI4MzFiMTQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-12-20T19:16:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-20T19:16:26Z"}, "message": "Rollup merge of #38236 - GuillaumeGomez:unix_socket_doc, r=frewsxcv\n\nUnix socket doc\n\nr? @frewsxcv", "tree": {"sha": "0cbfd3456ccd45558efa58b86684c92652457f87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cbfd3456ccd45558efa58b86684c92652457f87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cfb2b48fef7ea0ccc8ad7e236f9486f22831b14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cfb2b48fef7ea0ccc8ad7e236f9486f22831b14", "html_url": "https://github.com/rust-lang/rust/commit/4cfb2b48fef7ea0ccc8ad7e236f9486f22831b14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cfb2b48fef7ea0ccc8ad7e236f9486f22831b14/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70e1275a1affc599e335cd6eee2d84dd594a1f9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/70e1275a1affc599e335cd6eee2d84dd594a1f9e", "html_url": "https://github.com/rust-lang/rust/commit/70e1275a1affc599e335cd6eee2d84dd594a1f9e"}, {"sha": "2938e6a41172d1c71f5c58e9a71958f2d5c1a262", "url": "https://api.github.com/repos/rust-lang/rust/commits/2938e6a41172d1c71f5c58e9a71958f2d5c1a262", "html_url": "https://github.com/rust-lang/rust/commit/2938e6a41172d1c71f5c58e9a71958f2d5c1a262"}], "stats": {"total": 592, "additions": 566, "deletions": 26}, "files": [{"sha": "e822488c01851a7107c1e30f12313f93e5373e14", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 566, "deletions": 26, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb2b48fef7ea0ccc8ad7e236f9486f22831b14/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb2b48fef7ea0ccc8ad7e236f9486f22831b14/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=4cfb2b48fef7ea0ccc8ad7e236f9486f22831b14", "patch": "@@ -85,6 +85,21 @@ enum AddressKind<'a> {\n }\n \n /// An address associated with a Unix socket.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::os::unix::net::UnixListener;\n+///\n+/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n+///     Ok(sock) => sock,\n+///     Err(e) => {\n+///         println!(\"Couldn't bind: {:?}\", e);\n+///         return\n+///     }\n+/// };\n+/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+/// ```\n #[derive(Clone)]\n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct SocketAddr {\n@@ -121,6 +136,28 @@ impl SocketAddr {\n     }\n \n     /// Returns true if and only if the address is unnamed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A named address:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.is_unnamed(), false);\n+    /// ```\n+    ///\n+    /// An unnamed address:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.is_unnamed(), true);\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn is_unnamed(&self) -> bool {\n         if let AddressKind::Unnamed = self.address() {\n@@ -131,6 +168,30 @@ impl SocketAddr {\n     }\n \n     /// Returns the contents of this address if it is a `pathname` address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// With a pathname:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixListener;\n+    /// use std::path::Path;\n+    ///\n+    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n+    /// ```\n+    ///\n+    /// Without a pathname:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::path::Path;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.as_pathname(), None);\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn as_pathname(&self) -> Option<&Path> {\n         if let AddressKind::Pathname(path) = self.address() {\n@@ -182,7 +243,7 @@ impl<'a> fmt::Display for AsciiEscaped<'a> {\n ///\n /// # Examples\n ///\n-/// ```rust,no_run\n+/// ```no_run\n /// use std::os::unix::net::UnixStream;\n /// use std::io::prelude::*;\n ///\n@@ -212,6 +273,20 @@ impl fmt::Debug for UnixStream {\n \n impl UnixStream {\n     /// Connects to the socket named by `path`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n         fn inner(path: &Path) -> io::Result<UnixStream> {\n@@ -229,6 +304,20 @@ impl UnixStream {\n     /// Creates an unnamed pair of connected sockets.\n     ///\n     /// Returns two `UnixStream`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let (sock1, sock2) = match UnixStream::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n         let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n@@ -241,62 +330,159 @@ impl UnixStream {\n     /// object references. Both handles will read and write the same stream of\n     /// data, and options set on one stream will be propogated to the other\n     /// stream.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixStream> {\n         self.0.duplicate().map(UnixStream)\n     }\n \n     /// Returns the socket address of the local half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Returns the socket address of the remote half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Sets the read timeout for the socket.\n     ///\n-    /// If the provided value is `None`, then `read` calls will block\n-    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the provided value is [`None`], then [`read()`] calls will block\n+    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`read()`]: ../../../../std/io/trait.Read.html#tymethod.read\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n     }\n \n     /// Sets the write timeout for the socket.\n     ///\n-    /// If the provided value is `None`, then `write` calls will block\n-    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the provided value is [`None`], then [`write()`] calls will block\n+    /// indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`read()`]: ../../../../std/io/trait.Write.html#tymethod.write\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n     }\n \n     /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_RCVTIMEO)\n     }\n \n     /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n+    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_SNDTIMEO)\n     }\n \n     /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n \n     /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// if let Ok(Some(err)) = socket.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -306,7 +492,19 @@ impl UnixStream {\n     ///\n     /// This function will cause all pending and future I/O calls on the\n     /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of `Shutdown`).\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         self.0.shutdown(how)\n@@ -382,7 +580,7 @@ impl IntoRawFd for UnixStream {\n ///\n /// # Examples\n ///\n-/// ```rust,no_run\n+/// ```no_run\n /// use std::thread;\n /// use std::os::unix::net::{UnixStream, UnixListener};\n ///\n@@ -405,9 +603,6 @@ impl IntoRawFd for UnixStream {\n ///         }\n ///     }\n /// }\n-///\n-/// // close the listener socket\n-/// drop(listener);\n /// ```\n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct UnixListener(Socket);\n@@ -426,6 +621,20 @@ impl fmt::Debug for UnixListener {\n \n impl UnixListener {\n     /// Creates a new `UnixListener` bound to the specified socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n         fn inner(path: &Path) -> io::Result<UnixListener> {\n@@ -445,8 +654,23 @@ impl UnixListener {\n     /// Accepts a new incoming connection to this listener.\n     ///\n     /// This function will block the calling thread until a new Unix connection\n-    /// is established. When established, the corersponding `UnixStream` and\n+    /// is established. When established, the corersponding [`UnixStream`] and\n     /// the remote peer's address will be returned.\n+    ///\n+    /// [`UnixStream`]: ../../../../std/os/unix/net/struct.UnixStream.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// match listener.accept() {\n+    ///     Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n+    ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n         let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n@@ -461,33 +685,102 @@ impl UnixListener {\n     /// The returned `UnixListener` is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming\n     /// connections and options set on one listener will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixListener> {\n         self.0.duplicate().map(UnixListener)\n     }\n \n     /// Returns the local socket address of this listener.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n \n     /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    ///\n+    /// if let Ok(Some(err)) = listener.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n     }\n \n     /// Returns an iterator over incoming connections.\n     ///\n-    /// The iterator will never return `None` and will also not yield the\n-    /// peer's `SocketAddr` structure.\n+    /// The iterator will never return [`None`] and will also not yield the\n+    /// peer's [`SocketAddr`] structure.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`SocketAddr`]: struct.SocketAddr.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::thread;\n+    /// use std::os::unix::net::{UnixStream, UnixListener};\n+    ///\n+    /// fn handle_client(stream: UnixStream) {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// for stream in listener.incoming() {\n+    ///     match stream {\n+    ///         Ok(stream) => {\n+    ///             thread::spawn(|| handle_client(stream));\n+    ///         }\n+    ///         Err(err) => {\n+    ///             break;\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n         Incoming { listener: self }\n@@ -525,9 +818,36 @@ impl<'a> IntoIterator for &'a UnixListener {\n     }\n }\n \n-/// An iterator over incoming connections to a `UnixListener`.\n+/// An iterator over incoming connections to a [`UnixListener`].\n+///\n+/// It will never return [`None`].\n+///\n+/// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+/// [`UnixListener`]: struct.UnixListener.html\n+///\n+/// # Examples\n ///\n-/// It will never return `None`.\n+/// ```no_run\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+///\n+/// for stream in listener.incoming() {\n+///     match stream {\n+///         Ok(stream) => {\n+///             thread::spawn(|| handle_client(stream));\n+///         }\n+///         Err(err) => {\n+///             break;\n+///         }\n+///     }\n+/// }\n+/// ```\n #[derive(Debug)]\n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct Incoming<'a> {\n@@ -551,7 +871,7 @@ impl<'a> Iterator for Incoming<'a> {\n ///\n /// # Examples\n ///\n-/// ```rust,no_run\n+/// ```no_run\n /// use std::os::unix::net::UnixDatagram;\n ///\n /// let socket = UnixDatagram::bind(\"/path/to/my/socket\").unwrap();\n@@ -580,6 +900,20 @@ impl fmt::Debug for UnixDatagram {\n \n impl UnixDatagram {\n     /// Creates a Unix datagram socket bound to the given path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = match UnixDatagram::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't bind: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n         fn inner(path: &Path) -> io::Result<UnixDatagram> {\n@@ -596,6 +930,20 @@ impl UnixDatagram {\n     }\n \n     /// Creates a Unix Datagram socket which is not bound to any address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = match UnixDatagram::unbound() {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't unbound: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn unbound() -> io::Result<UnixDatagram> {\n         let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n@@ -605,6 +953,20 @@ impl UnixDatagram {\n     /// Create an unnamed pair of connected sockets.\n     ///\n     /// Returns two `UnixDatagrams`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let (sock1, sock2) = match UnixDatagram::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't unbound: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n         let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n@@ -613,8 +975,27 @@ impl UnixDatagram {\n \n     /// Connects the socket to the specified address.\n     ///\n-    /// The `send` method may be used to send data to the specified address.\n-    /// `recv` and `recv_from` will only receive data from that address.\n+    /// The [`send()`] method may be used to send data to the specified address.\n+    /// [`recv()`] and [`recv_from()`] will only receive data from that address.\n+    ///\n+    /// [`send()`]: #method.send\n+    /// [`recv()`]: #method.recv\n+    /// [`recv_from()`]: #method.recv_from\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// match sock.connect(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n         fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> {\n@@ -631,23 +1012,56 @@ impl UnixDatagram {\n \n     /// Creates a new independently owned handle to the underlying socket.\n     ///\n-    /// The returned `UnixListener` is a reference to the same socket that this\n+    /// The returned `UnixDatagram` is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one listener will affect the other.\n+    /// connections and options set on one side will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let sock_copy = sock.try_clone().expect(\"try_clone failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixDatagram> {\n         self.0.duplicate().map(UnixDatagram)\n     }\n \n     /// Returns the address of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = sock.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Returns the address of this socket's peer.\n     ///\n-    /// The `connect` method will connect the socket to a peer.\n+    /// The [`connect()`] method will connect the socket to a peer.\n+    ///\n+    /// [`connect()`]: #method.connect\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.connect(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = sock.peer_addr().expect(\"Couldn't get peer address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n@@ -657,6 +1071,19 @@ impl UnixDatagram {\n     ///\n     /// On success, returns the number of bytes read and the address from\n     /// whence the data came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// let mut buf = vec![0; 10];\n+    /// match sock.recv_from(buf.as_mut_slice()) {\n+    ///     Ok((size, sender)) => println!(\"received {} bytes from {:?}\", size, sender),\n+    ///     Err(e) => println!(\"recv_from function failed: {:?}\", e),\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         let mut count = 0;\n@@ -684,6 +1111,16 @@ impl UnixDatagram {\n     /// Receives data from the socket.\n     ///\n     /// On success, returns the number of bytes read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n+    /// let mut buf = vec![0; 10];\n+    /// sock.recv(buf.as_mut_slice()).expect(\"recv function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.0.read(buf)\n@@ -692,6 +1129,15 @@ impl UnixDatagram {\n     /// Sends data on the socket to the specified address.\n     ///\n     /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.send_to(b\"omelette au fromage\", \"/some/sock\").expect(\"send_to function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n         fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> {\n@@ -716,50 +1162,134 @@ impl UnixDatagram {\n     /// will return an error if the socket has not already been connected.\n     ///\n     /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.connect(\"/some/sock\").expect(\"Couldn't connect\");\n+    /// sock.send(b\"omelette au fromage\").expect(\"send_to function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n     }\n \n     /// Sets the read timeout for the socket.\n     ///\n-    /// If the provided value is `None`, then `recv` and `recv_from` calls will\n-    /// block indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the provided value is [`None`], then [`recv()`] and [`recv_from()`] calls will\n+    /// block indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`recv()`]: #method.recv\n+    /// [`recv_from()`]: #method.recv_from\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n     }\n \n     /// Sets the write timeout for the socket.\n     ///\n-    /// If the provided value is `None`, then `send` and `send_to` calls will\n-    /// block indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the provided value is [`None`], then [`send()`] and [`send_to()`] calls will\n+    /// block indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`send()`]: #method.send\n+    /// [`send_to()`]: #method.send_to\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///     .expect(\"set_write_timeout function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n     }\n \n     /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n+    /// assert_eq!(sock.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_RCVTIMEO)\n     }\n \n     /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///     .expect(\"set_write_timeout function failed\");\n+    /// assert_eq!(sock.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_SNDTIMEO)\n     }\n \n     /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_nonblocking(true).expect(\"set_nonblocking function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n \n     /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// if let Ok(Some(err)) = sock.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -769,7 +1299,17 @@ impl UnixDatagram {\n     ///\n     /// This function will cause all pending and future I/O calls on the\n     /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of `Shutdown`).\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         self.0.shutdown(how)"}]}