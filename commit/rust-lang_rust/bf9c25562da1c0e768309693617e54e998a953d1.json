{"sha": "bf9c25562da1c0e768309693617e54e998a953d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmOWMyNTU2MmRhMWMwZTc2ODMwOTY5MzYxN2U1NGU5OThhOTUzZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-24T03:56:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-24T03:56:35Z"}, "message": "auto merge of #11686 : mankyKitty/rust/rename-invert-to-flip-issue-10632, r=alexcrichton\n\nRenamed the ```invert()``` function in ```iter.rs``` to ```flip()```, from #10632 \r\n\r\nAlso renamed the ```Invert<T>``` type to ```Flip<T>```.\r\n\r\nSome related code comments changed. Documentation that I could find has\r\nbeen updated, and all the instances I could locate where the\r\nfunction/type were called have been updated as well.\r\n\r\nThis is my first contribution to Rust! Apologies in advance if I've snarfed the \r\nPR process, I'm not used to rebase.\r\n\r\nI initially had issues with the ```codegen``` section of the tests failing, however\r\nthe ```make check``` process is not reporting any failures at this time. I think\r\nthat was a local env issue more than me facerolling my changes. :)", "tree": {"sha": "f078fbc7fb349c83179c29139da51ea3b7213e20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f078fbc7fb349c83179c29139da51ea3b7213e20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf9c25562da1c0e768309693617e54e998a953d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf9c25562da1c0e768309693617e54e998a953d1", "html_url": "https://github.com/rust-lang/rust/commit/bf9c25562da1c0e768309693617e54e998a953d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf9c25562da1c0e768309693617e54e998a953d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b62371c205d408cf5a833d12dc937012047a506", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b62371c205d408cf5a833d12dc937012047a506", "html_url": "https://github.com/rust-lang/rust/commit/2b62371c205d408cf5a833d12dc937012047a506"}, {"sha": "292ed3e55c595505069a589e104e365779c27933", "url": "https://api.github.com/repos/rust-lang/rust/commits/292ed3e55c595505069a589e104e365779c27933", "html_url": "https://github.com/rust-lang/rust/commit/292ed3e55c595505069a589e104e365779c27933"}], "stats": {"total": 192, "additions": 96, "deletions": 96}, "files": [{"sha": "628e4f223b446b19396c3fc08f2d5e54cea26c9f", "filename": "doc/guide-container.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/doc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/doc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-container.md?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -336,8 +336,8 @@ The `DoubleEndedIterator` trait represents an iterator able to yield elements\n from either end of a range. It inherits from the `Iterator` trait and extends\n it with the `next_back` function.\n \n-A `DoubleEndedIterator` can be flipped with the `invert` adaptor, returning\n-another `DoubleEndedIterator` with `next` and `next_back` exchanged.\n+A `DoubleEndedIterator` can have its direction changed with the `rev` adaptor,\n+returning another `DoubleEndedIterator` with `next` and `next_back` exchanged.\n \n ~~~\n let xs = [1, 2, 3, 4, 5, 6];\n@@ -347,7 +347,7 @@ println!(\"{:?}\", it.next()); // prints `Some(&2)`\n println!(\"{:?}\", it.next_back()); // prints `Some(&6)`\n \n // prints `5`, `4` and `3`\n-for &x in it.invert() {\n+for &x in it.rev() {\n     println!(\"{}\", x)\n }\n ~~~\n@@ -366,7 +366,7 @@ let mut it = xs.iter().chain(ys.iter()).map(|&x| x * 2);\n println!(\"{:?}\", it.next()); // prints `Some(2)`\n \n // prints `16`, `14`, `12`, `10`, `8`, `6`, `4`\n-for x in it.invert() {\n+for x in it.rev() {\n     println!(\"{}\", x);\n }\n ~~~"}, {"sha": "9df75ff044ab300fd74bd6f780ef3fb49c9b0986", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -13,7 +13,7 @@\n \n use std::cmp;\n use std::iter::RandomAccessIterator;\n-use std::iter::{Invert, Enumerate, Repeat, Map, Zip};\n+use std::iter::{Rev, Enumerate, Repeat, Map, Zip};\n use std::num;\n use std::ops;\n use std::uint;\n@@ -387,7 +387,7 @@ impl Bitv {\n         }\n     }\n \n-    /// Invert all bits\n+    /// Flip all bits\n     #[inline]\n     pub fn negate(&mut self) {\n         match self.rep {\n@@ -428,8 +428,8 @@ impl Bitv {\n     }\n \n     #[inline]\n-    pub fn rev_iter<'a>(&'a self) -> Invert<Bits<'a>> {\n-        self.iter().invert()\n+    pub fn rev_iter<'a>(&'a self) -> Rev<Bits<'a>> {\n+        self.iter().rev()\n     }\n \n     /// Returns `true` if all bits are 0"}, {"sha": "fa6e7c15ee01801641b4e175445261328211f1b3", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -25,7 +25,7 @@\n use std::cast;\n use std::ptr;\n use std::util;\n-use std::iter::Invert;\n+use std::iter::Rev;\n use std::iter;\n \n use container::Deque;\n@@ -368,8 +368,8 @@ impl<T> DList<T> {\n \n     /// Provide a reverse iterator\n     #[inline]\n-    pub fn rev_iter<'a>(&'a self) -> Invert<Items<'a, T>> {\n-        self.iter().invert()\n+    pub fn rev_iter<'a>(&'a self) -> Rev<Items<'a, T>> {\n+        self.iter().rev()\n     }\n \n     /// Provide a forward iterator with mutable references\n@@ -388,8 +388,8 @@ impl<T> DList<T> {\n     }\n     /// Provide a reverse iterator with mutable references\n     #[inline]\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> Invert<MutItems<'a, T>> {\n-        self.mut_iter().invert()\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> Rev<MutItems<'a, T>> {\n+        self.mut_iter().rev()\n     }\n \n \n@@ -401,8 +401,8 @@ impl<T> DList<T> {\n \n     /// Consume the list into an iterator yielding elements by value, in reverse\n     #[inline]\n-    pub fn move_rev_iter(self) -> Invert<MoveItems<T>> {\n-        self.move_iter().invert()\n+    pub fn move_rev_iter(self) -> Rev<MoveItems<T>> {\n+        self.move_iter().rev()\n     }\n }\n "}, {"sha": "684aafd250090352437ec49f487750c159264f13", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -15,7 +15,7 @@\n \n use std::num;\n use std::vec;\n-use std::iter::{Invert, RandomAccessIterator};\n+use std::iter::{Rev, RandomAccessIterator};\n \n use container::Deque;\n \n@@ -192,8 +192,8 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Back-to-front iterator.\n-    pub fn rev_iter<'a>(&'a self) -> Invert<Items<'a, T>> {\n-        self.iter().invert()\n+    pub fn rev_iter<'a>(&'a self) -> Rev<Items<'a, T>> {\n+        self.iter().rev()\n     }\n \n     /// Front-to-back iterator which returns mutable values.\n@@ -223,8 +223,8 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> Invert<MutItems<'a, T>> {\n-        self.mut_iter().invert()\n+    pub fn mut_rev_iter<'a>(&'a mut self) -> Rev<MutItems<'a, T>> {\n+        self.mut_iter().rev()\n     }\n }\n "}, {"sha": "abbd987a9c404d157941480124314593c0cd9842", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -15,7 +15,7 @@\n \n #[allow(missing_doc)];\n \n-use std::iter::{Enumerate, FilterMap, Invert};\n+use std::iter::{Enumerate, FilterMap, Rev};\n use std::util::replace;\n use std::vec;\n \n@@ -140,14 +140,14 @@ impl<V> SmallIntMap<V> {\n     /// An iterator visiting all key-value pairs in descending order by the keys.\n     /// Iterator element type is (uint, &'r V)\n     pub fn rev_iter<'r>(&'r self) -> RevEntries<'r, V> {\n-        self.iter().invert()\n+        self.iter().rev()\n     }\n \n     /// An iterator visiting all key-value pairs in descending order by the keys,\n     /// with mutable references to the values\n     /// Iterator element type is (uint, &'r mut V)\n     pub fn mut_rev_iter<'r>(&'r mut self) -> RevMutEntries <'r, V> {\n-        self.mut_iter().invert()\n+        self.mut_iter().rev()\n     }\n \n     /// Empties the hash map, moving all values into the specified closure\n@@ -241,7 +241,7 @@ pub struct Entries<'a, T> {\n \n iterator!(impl Entries -> (uint, &'a T), get_ref)\n double_ended_iterator!(impl Entries -> (uint, &'a T), get_ref)\n-pub type RevEntries<'a, T> = Invert<Entries<'a, T>>;\n+pub type RevEntries<'a, T> = Rev<Entries<'a, T>>;\n \n pub struct MutEntries<'a, T> {\n     priv front: uint,\n@@ -251,7 +251,7 @@ pub struct MutEntries<'a, T> {\n \n iterator!(impl MutEntries -> (uint, &'a mut T), get_mut_ref)\n double_ended_iterator!(impl MutEntries -> (uint, &'a mut T), get_mut_ref)\n-pub type RevMutEntries<'a, T> = Invert<MutEntries<'a, T>>;\n+pub type RevMutEntries<'a, T> = Rev<MutEntries<'a, T>>;\n \n #[cfg(test)]\n mod test_map {"}, {"sha": "ee4ee29505575d74007c63cd1ee7db2b40bbd999", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -460,7 +460,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             fail!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n         }\n         // close all other fds\n-        for fd in range(3, getdtablesize()).invert() {\n+        for fd in range(3, getdtablesize()).rev() {\n             if fd != output.fd() {\n                 close(fd as c_int);\n             }"}, {"sha": "020b840e5b2ef01d3e7e50eb2a0c45d75d2922ba", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -203,7 +203,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         let scopes = self.scopes.borrow();\n-        for scope in scopes.get().iter().invert() {\n+        for scope in scopes.get().iter().rev() {\n             match scope.kind {\n                 LoopScopeKind(id, _) => {\n                     return id;\n@@ -325,7 +325,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                cleanup_scope);\n \n         let mut scopes = self.scopes.borrow_mut();\n-        for scope in scopes.get().mut_iter().invert() {\n+        for scope in scopes.get().mut_iter().rev() {\n             if scope.kind.is_ast_with_id(cleanup_scope) {\n                 scope.cleanups.push(cleanup);\n                 scope.clear_cached_exits();\n@@ -368,7 +368,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         let scopes = self.scopes.borrow();\n-        scopes.get().iter().invert().any(|s| s.needs_invoke())\n+        scopes.get().iter().rev().any(|s| s.needs_invoke())\n     }\n \n     fn get_landing_pad(&self) -> BasicBlockRef {\n@@ -415,7 +415,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n          * Returns the id of the current top-most AST scope, if any.\n          */\n         let scopes = self.scopes.borrow();\n-        for scope in scopes.get().iter().invert() {\n+        for scope in scopes.get().iter().rev() {\n             match scope.kind {\n                 CustomScopeKind | LoopScopeKind(..) => {}\n                 AstScopeKind(i) => {\n@@ -428,7 +428,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n \n     fn top_nonempty_cleanup_scope(&self) -> Option<uint> {\n         let scopes = self.scopes.borrow();\n-        scopes.get().iter().invert().position(|s| !s.cleanups.is_empty())\n+        scopes.get().iter().rev().position(|s| !s.cleanups.is_empty())\n     }\n \n     fn is_valid_to_pop_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n@@ -450,7 +450,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n \n         let mut bcx = bcx;\n         if !bcx.unreachable.get() {\n-            for cleanup in scope.cleanups.iter().invert() {\n+            for cleanup in scope.cleanups.iter().rev() {\n                 bcx = cleanup.trans(bcx);\n             }\n         }\n@@ -619,7 +619,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n                 debug!(\"generating cleanups for {}\", name);\n                 let bcx_in = self.new_block(label.is_unwind(), name, None);\n                 let mut bcx_out = bcx_in;\n-                for cleanup in scope.cleanups.iter().invert() {\n+                for cleanup in scope.cleanups.iter().rev() {\n                     if cleanup_is_suitable_for(*cleanup, label) {\n                         bcx_out = cleanup.trans(bcx_out);\n                     }"}, {"sha": "a65da91437313b9b334712157539e35351a97744", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -670,21 +670,21 @@ pub trait DoubleEndedIterator<A>: Iterator<A> {\n     /// Yield an element from the end of the range, returning `None` if the range is empty.\n     fn next_back(&mut self) -> Option<A>;\n \n-    /// Flip the direction of the iterator\n+    /// Change the direction of the iterator\n     ///\n-    /// The inverted iterator flips the ends on an iterator that can already\n+    /// The flipped iterator swaps the ends on an iterator that can already\n     /// be iterated from the front and from the back.\n     ///\n     ///\n-    /// If the iterator also implements RandomAccessIterator, the inverted\n+    /// If the iterator also implements RandomAccessIterator, the flipped\n     /// iterator is also random access, with the indices starting at the back\n     /// of the original iterator.\n     ///\n-    /// Note: Random access with inverted indices still only applies to the first\n+    /// Note: Random access with flipped indices still only applies to the first\n     /// `uint::max_value` elements of the original iterator.\n     #[inline]\n-    fn invert(self) -> Invert<Self> {\n-        Invert{iter: self}\n+    fn rev(self) -> Rev<Self> {\n+        Rev{iter: self}\n     }\n }\n \n@@ -759,30 +759,30 @@ pub trait ExactSize<A> : DoubleEndedIterator<A> {\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n impl<A, T: ExactSize<A>> ExactSize<(uint, A)> for Enumerate<T> {}\n impl<'a, A, T: ExactSize<A>> ExactSize<A> for Inspect<'a, A, T> {}\n-impl<A, T: ExactSize<A>> ExactSize<A> for Invert<T> {}\n+impl<A, T: ExactSize<A>> ExactSize<A> for Rev<T> {}\n impl<'a, A, B, T: ExactSize<A>> ExactSize<B> for Map<'a, A, B, T> {}\n impl<A, B, T: ExactSize<A>, U: ExactSize<B>> ExactSize<(A, B)> for Zip<T, U> {}\n \n /// An double-ended iterator with the direction inverted\n #[deriving(Clone)]\n-pub struct Invert<T> {\n+pub struct Rev<T> {\n     priv iter: T\n }\n \n-impl<A, T: DoubleEndedIterator<A>> Iterator<A> for Invert<T> {\n+impl<A, T: DoubleEndedIterator<A>> Iterator<A> for Rev<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.iter.next_back() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Invert<T> {\n+impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Rev<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.iter.next() }\n }\n \n impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterator<A>\n-    for Invert<T> {\n+    for Rev<T> {\n     #[inline]\n     fn indexable(&self) -> uint { self.iter.indexable() }\n     #[inline]\n@@ -2590,12 +2590,12 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_invert() {\n+    fn test_rev() {\n         let xs = [2, 4, 6, 8, 10, 12, 14, 16];\n         let mut it = xs.iter();\n         it.next();\n         it.next();\n-        assert_eq!(it.invert().map(|&x| x).collect::<~[int]>(), ~[16, 14, 12, 10, 8, 6]);\n+        assert_eq!(it.rev().map(|&x| x).collect::<~[int]>(), ~[16, 14, 12, 10, 8, 6]);\n     }\n \n     #[test]\n@@ -2662,7 +2662,7 @@ mod tests {\n     fn test_double_ended_chain() {\n         let xs = [1, 2, 3, 4, 5];\n         let ys = ~[7, 9, 11];\n-        let mut it = xs.iter().chain(ys.iter()).invert();\n+        let mut it = xs.iter().chain(ys.iter()).rev();\n         assert_eq!(it.next().unwrap(), &11)\n         assert_eq!(it.next().unwrap(), &9)\n         assert_eq!(it.next_back().unwrap(), &1)\n@@ -2764,10 +2764,10 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_random_access_invert() {\n+    fn test_random_access_rev() {\n         let xs = [1, 2, 3, 4, 5];\n-        check_randacc_iter(xs.iter().invert(), xs.len());\n-        let mut it = xs.iter().invert();\n+        check_randacc_iter(xs.iter().rev(), xs.len());\n+        let mut it = xs.iter().rev();\n         it.next();\n         it.next_back();\n         it.next();\n@@ -2833,13 +2833,13 @@ mod tests {\n \n     #[test]\n     fn test_double_ended_range() {\n-        assert_eq!(range(11i, 14).invert().collect::<~[int]>(), ~[13i, 12, 11]);\n-        for _ in range(10i, 0).invert() {\n+        assert_eq!(range(11i, 14).rev().collect::<~[int]>(), ~[13i, 12, 11]);\n+        for _ in range(10i, 0).rev() {\n             fail!(\"unreachable\");\n         }\n \n-        assert_eq!(range(11u, 14).invert().collect::<~[uint]>(), ~[13u, 12, 11]);\n-        for _ in range(10u, 0).invert() {\n+        assert_eq!(range(11u, 14).rev().collect::<~[uint]>(), ~[13u, 12, 11]);\n+        for _ in range(10u, 0).rev() {\n             fail!(\"unreachable\");\n         }\n     }\n@@ -2886,11 +2886,11 @@ mod tests {\n \n         assert_eq!(range(0i, 5).collect::<~[int]>(), ~[0i, 1, 2, 3, 4]);\n         assert_eq!(range(-10i, -1).collect::<~[int]>(), ~[-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n-        assert_eq!(range(0i, 5).invert().collect::<~[int]>(), ~[4, 3, 2, 1, 0]);\n+        assert_eq!(range(0i, 5).rev().collect::<~[int]>(), ~[4, 3, 2, 1, 0]);\n         assert_eq!(range(200, -5).collect::<~[int]>(), ~[]);\n-        assert_eq!(range(200, -5).invert().collect::<~[int]>(), ~[]);\n+        assert_eq!(range(200, -5).rev().collect::<~[int]>(), ~[]);\n         assert_eq!(range(200, 200).collect::<~[int]>(), ~[]);\n-        assert_eq!(range(200, 200).invert().collect::<~[int]>(), ~[]);\n+        assert_eq!(range(200, 200).rev().collect::<~[int]>(), ~[]);\n \n         assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n         // this test is only meaningful when sizeof uint < sizeof u64\n@@ -2902,11 +2902,11 @@ mod tests {\n     #[test]\n     fn test_range_inclusive() {\n         assert_eq!(range_inclusive(0i, 5).collect::<~[int]>(), ~[0i, 1, 2, 3, 4, 5]);\n-        assert_eq!(range_inclusive(0i, 5).invert().collect::<~[int]>(), ~[5i, 4, 3, 2, 1, 0]);\n+        assert_eq!(range_inclusive(0i, 5).rev().collect::<~[int]>(), ~[5i, 4, 3, 2, 1, 0]);\n         assert_eq!(range_inclusive(200, -5).collect::<~[int]>(), ~[]);\n-        assert_eq!(range_inclusive(200, -5).invert().collect::<~[int]>(), ~[]);\n+        assert_eq!(range_inclusive(200, -5).rev().collect::<~[int]>(), ~[]);\n         assert_eq!(range_inclusive(200, 200).collect::<~[int]>(), ~[200]);\n-        assert_eq!(range_inclusive(200, 200).invert().collect::<~[int]>(), ~[200]);\n+        assert_eq!(range_inclusive(200, 200).rev().collect::<~[int]>(), ~[200]);\n     }\n \n     #[test]"}, {"sha": "cc0705ee76fb4f4c91f4330f744ddcc188a9569c", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -17,7 +17,7 @@ use clone::Clone;\n use container::Container;\n use cmp::Eq;\n use from_str::FromStr;\n-use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Invert, Iterator, Map};\n+use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Rev, Iterator, Map};\n use option::{Option, Some, None};\n use str;\n use str::{CharSplits, OwnedStr, Str, StrVector, StrSlice};\n@@ -35,7 +35,7 @@ pub type StrComponents<'a> = Map<'a, &'a str, Option<&'a str>,\n ///\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n /// every component in WindowsPath is guaranteed to be Some.\n-pub type RevStrComponents<'a> = Invert<Map<'a, &'a str, Option<&'a str>,\n+pub type RevStrComponents<'a> = Rev<Map<'a, &'a str, Option<&'a str>,\n                                                  CharSplits<'a, char>>>;\n \n /// Iterator that yields successive components of a Path as &[u8]\n@@ -571,8 +571,8 @@ impl GenericPath for Path {\n \n     fn ends_with_path(&self, child: &Path) -> bool {\n         if !child.is_relative() { return false; }\n-        let mut selfit = self.str_components().invert();\n-        let mut childit = child.str_components().invert();\n+        let mut selfit = self.str_components().rev();\n+        let mut childit = child.str_components().rev();\n         loop {\n             match (selfit.next(), childit.next()) {\n                 (Some(a), Some(b)) => if a != b { return false; },\n@@ -628,7 +628,7 @@ impl Path {\n     /// Returns an iterator that yields each component of the path in reverse as an Option<&str>\n     /// See str_components() for details.\n     pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> {\n-        self.str_components().invert()\n+        self.str_components().rev()\n     }\n \n     /// Returns an iterator that yields each component of the path in turn as a &[u8]."}, {"sha": "22c9ae606d37aeb7efb31323240703196368c1bd", "filename": "src/libstd/str.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -102,7 +102,7 @@ use clone::{Clone, DeepClone};\n use container::{Container, Mutable};\n use iter::{Iterator, FromIterator, Extendable, range};\n use iter::{Filter, AdditiveIterator, Map};\n-use iter::{Invert, DoubleEndedIterator, ExactSize};\n+use iter::{Rev, DoubleEndedIterator, ExactSize};\n use libc;\n use num::{Saturating};\n use option::{None, Option, Some};\n@@ -376,11 +376,11 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n \n /// External iterator for a string's characters in reverse order.\n /// Use with the `std::iter` module.\n-pub type RevChars<'a> = Invert<Chars<'a>>;\n+pub type RevChars<'a> = Rev<Chars<'a>>;\n \n /// External iterator for a string's characters and their byte offsets in reverse order.\n /// Use with the `std::iter` module.\n-pub type RevCharOffsets<'a> = Invert<CharOffsets<'a>>;\n+pub type RevCharOffsets<'a> = Rev<CharOffsets<'a>>;\n \n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n@@ -389,7 +389,7 @@ pub type Bytes<'a> =\n \n /// External iterator for a string's bytes in reverse order.\n /// Use with the `std::iter` module.\n-pub type RevBytes<'a> = Invert<Bytes<'a>>;\n+pub type RevBytes<'a> = Rev<Bytes<'a>>;\n \n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n@@ -405,7 +405,7 @@ pub struct CharSplits<'a, Sep> {\n \n /// An iterator over the substrings of a string, separated by `sep`,\n /// starting from the back of the string.\n-pub type RevCharSplits<'a, Sep> = Invert<CharSplits<'a, Sep>>;\n+pub type RevCharSplits<'a, Sep> = Rev<CharSplits<'a, Sep>>;\n \n /// An iterator over the substrings of a string, separated by `sep`,\n /// splitting at most `count` times.\n@@ -486,7 +486,7 @@ for CharSplits<'a, Sep> {\n         let mut next_split = None;\n \n         if self.only_ascii {\n-            for (idx, byte) in self.string.bytes().enumerate().invert() {\n+            for (idx, byte) in self.string.bytes().enumerate().rev() {\n                 if self.sep.matches(byte as char) && byte < 128u8 {\n                     next_split = Some((idx, idx + 1));\n                     break;\n@@ -1980,7 +1980,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn chars_rev(&self) -> RevChars<'a> {\n-        self.chars().invert()\n+        self.chars().rev()\n     }\n \n     #[inline]\n@@ -1990,7 +1990,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn bytes_rev(&self) -> RevBytes<'a> {\n-        self.bytes().invert()\n+        self.bytes().rev()\n     }\n \n     #[inline]\n@@ -2000,7 +2000,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn char_indices_rev(&self) -> RevCharOffsets<'a> {\n-        self.char_indices().invert()\n+        self.char_indices().rev()\n     }\n \n     #[inline]\n@@ -2035,7 +2035,7 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep> {\n-        self.split(sep).invert()\n+        self.split(sep).rev()\n     }\n \n     #[inline]\n@@ -3789,11 +3789,11 @@ mod tests {\n     fn test_rev_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let mut split: ~[&str] = data.split('\\n').invert().collect();\n+        let mut split: ~[&str] = data.split('\\n').rev().collect();\n         split.reverse();\n         assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n-        let mut split: ~[&str] = data.split_terminator('\\n').invert().collect();\n+        let mut split: ~[&str] = data.split_terminator('\\n').rev().collect();\n         split.reverse();\n         assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }"}, {"sha": "8b9b41f027c178176315462c6e8065b26bfe51eb", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -728,7 +728,7 @@ mod test_map {\n     fn test_each_reverse_break() {\n         let mut m = TrieMap::new();\n \n-        for x in range(uint::max_value - 10000, uint::max_value).invert() {\n+        for x in range(uint::max_value - 10000, uint::max_value).rev() {\n             m.insert(x, x / 2);\n         }\n \n@@ -781,7 +781,7 @@ mod test_map {\n         let last = uint::max_value;\n \n         let mut map = TrieMap::new();\n-        for x in range(first, last).invert() {\n+        for x in range(first, last).rev() {\n             map.insert(x, x / 2);\n         }\n \n@@ -803,7 +803,7 @@ mod test_map {\n         let last = uint::max_value;\n \n         let mut map = TrieMap::new();\n-        for x in range(first, last).invert() {\n+        for x in range(first, last).rev() {\n             map.insert(x, x / 2);\n         }\n "}, {"sha": "41cae372dbbe1f7761d9cf3146c72c23e05509f6", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -1067,7 +1067,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n \n     #[inline]\n     fn rev_iter(self) -> RevItems<'a, T> {\n-        self.iter().invert()\n+        self.iter().rev()\n     }\n \n     #[inline]\n@@ -1464,7 +1464,7 @@ impl<T> OwnedVector<T> for ~[T] {\n \n     #[inline]\n     fn move_rev_iter(self) -> RevMoveItems<T> {\n-        self.move_iter().invert()\n+        self.move_iter().rev()\n     }\n \n     fn reserve(&mut self, n: uint) {\n@@ -2300,7 +2300,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n \n     #[inline]\n     fn mut_rev_iter(self) -> RevMutItems<'a, T> {\n-        self.mut_iter().invert()\n+        self.mut_iter().rev()\n     }\n \n     #[inline]\n@@ -2714,7 +2714,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n }\n \n iterator!{struct Items -> *T, &'a T}\n-pub type RevItems<'a, T> = Invert<Items<'a, T>>;\n+pub type RevItems<'a, T> = Rev<Items<'a, T>>;\n \n impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n@@ -2724,7 +2724,7 @@ impl<'a, T> Clone for Items<'a, T> {\n }\n \n iterator!{struct MutItems -> *mut T, &'a mut T}\n-pub type RevMutItems<'a, T> = Invert<MutItems<'a, T>>;\n+pub type RevMutItems<'a, T> = Rev<MutItems<'a, T>>;\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n@@ -2882,7 +2882,7 @@ impl<T> Drop for MoveItems<T> {\n }\n \n /// An iterator that moves out of a vector in reverse order.\n-pub type RevMoveItems<T> = Invert<MoveItems<T>>;\n+pub type RevMoveItems<T> = Rev<MoveItems<T>>;\n \n impl<A> FromIterator<A> for ~[A] {\n     fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> ~[A] {\n@@ -3985,7 +3985,7 @@ mod tests {\n         assert_eq!(v.chunks(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[4,5]]);\n         assert_eq!(v.chunks(6).collect::<~[&[int]]>(), ~[&[1i,2,3,4,5]]);\n \n-        assert_eq!(v.chunks(2).invert().collect::<~[&[int]]>(), ~[&[5i], &[3,4], &[1,2]]);\n+        assert_eq!(v.chunks(2).rev().collect::<~[&[int]]>(), ~[&[5i], &[3,4], &[1,2]]);\n         let it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n         assert_eq!(it.idx(0).unwrap(), &[1,2]);\n@@ -4241,9 +4241,9 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_mut_splitator_invert() {\n+    fn test_mut_splitator_rev() {\n         let mut xs = [1,2,0,3,4,0,0,5,6,0];\n-        for slice in xs.mut_split(|x| *x == 0).invert().take(4) {\n+        for slice in xs.mut_split(|x| *x == 0).rev().take(4) {\n             slice.reverse();\n         }\n         assert_eq!(xs, [1,2,0,4,3,0,0,6,5,0]);\n@@ -4262,9 +4262,9 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_mut_chunks_invert() {\n+    fn test_mut_chunks_rev() {\n         let mut v = [0u8, 1, 2, 3, 4, 5, 6];\n-        for (i, chunk) in v.mut_chunks(3).invert().enumerate() {\n+        for (i, chunk) in v.mut_chunks(3).rev().enumerate() {\n             for x in chunk.mut_iter() {\n                 *x = i as u8;\n             }"}, {"sha": "a6ad7b2a5506b70b550f031cb39bf6e8a4d4a2c9", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -556,7 +556,7 @@ impl SyntaxEnv {\n     }\n \n     fn find_escape_frame<'a>(&'a mut self) -> &'a mut MapChainFrame {\n-        for (i, frame) in self.chain.mut_iter().enumerate().invert() {\n+        for (i, frame) in self.chain.mut_iter().enumerate().rev() {\n             if !frame.info.macros_escape || i == 0 {\n                 return frame\n             }\n@@ -565,7 +565,7 @@ impl SyntaxEnv {\n     }\n \n     pub fn find<'a>(&'a self, k: &Name) -> Option<&'a SyntaxExtension> {\n-        for frame in self.chain.iter().invert() {\n+        for frame in self.chain.iter().rev() {\n             match frame.map.find(k) {\n                 Some(v) => return Some(v),\n                 None => {}"}, {"sha": "4c75ca494ffbfb71fffb0ed1fcb63e5448b5aa8a", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -52,13 +52,13 @@ fn descending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n     println!(\" Descending integers:\");\n \n     timed(\"insert\", || {\n-        for i in range(0, n_keys).invert() {\n+        for i in range(0, n_keys).rev() {\n             map.insert(i, i + 1);\n         }\n     });\n \n     timed(\"search\", || {\n-        for i in range(0, n_keys).invert() {\n+        for i in range(0, n_keys).rev() {\n             assert_eq!(map.find(&i).unwrap(), &(i + 1));\n         }\n     });"}, {"sha": "53d188962e849ee26b9e15f7db3bd9ed0c5124d4", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c25562da1c0e768309693617e54e998a953d1/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c25562da1c0e768309693617e54e998a953d1/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=bf9c25562da1c0e768309693617e54e998a953d1", "patch": "@@ -220,7 +220,7 @@ fn handle_sol(raw_sol: &List<u64>, data: &mut Data) -> bool {\n     // reverse order, i.e. the board rotated by half a turn.\n     data.nb += 2;\n     let sol1 = to_utf8(raw_sol);\n-    let sol2: ~str = sol1.chars().invert().collect();\n+    let sol2: ~str = sol1.chars().rev().collect();\n \n     if data.nb == 2 {\n         data.min = sol1.clone();"}]}