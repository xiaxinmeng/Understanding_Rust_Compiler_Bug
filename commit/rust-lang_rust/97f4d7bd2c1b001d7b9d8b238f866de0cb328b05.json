{"sha": "97f4d7bd2c1b001d7b9d8b238f866de0cb328b05", "node_id": "C_kwDOAAsO6NoAKDk3ZjRkN2JkMmMxYjAwMWQ3YjlkOGIyMzhmODY2ZGUwY2IzMjhiMDU", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-06-24T07:43:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-24T07:43:41Z"}, "message": "Rollup merge of #91264 - GuillaumeGomez:macro-jump-to-def, r=jsha\n\nAdd macro support in jump to definition feature\n\nFixes #91174.\n\nTo do so, I check if the span comes from an expansion, and if so, I infer the original macro `DefId` or `Span` depending if it's a defined in the current crate or not.\n\nThere is one limitation due to macro expansion though:\n\n```rust\nmacro_rules! yolo { () => {}}\n\nfn foo() {\n    yolo!();\n}\n```\n\nIn `foo`, `yolo!` won't be linked because after expansion, it is replaced by nothing (which seems logical). So I can't get an item from the `Visitor` from which I could tell if its `Span` comes from an expansion.\n\nI added a test for this specific limitation alongside others.\n\nDemo: https://rustdoc.crud.net/imperio/macro-jump-to-def/src/foo/check-source-code-urls-to-def-std.rs.html\n\nAs for the empty macro issue that cannot create a jump to definition, you can see it [here](https://rustdoc.crud.net/imperio/macro-jump-to-def/src/foo/check-source-code-urls-to-def-std.rs.html#35).\n\nr? ```@jyn514```", "tree": {"sha": "5d49138356fca3df1820d004dff2c2a8b0d4ca53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d49138356fca3df1820d004dff2c2a8b0d4ca53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJitWstCRBK7hj4Ov3rIwAAz7MIABE68HLox2O0zZqGHwdM4ojT\ndqmHIEIM1RZR3rIGWdwo+ITV0ga83KSxRBvKsDubS7qCWIrPH6Vb18Lo91YAaTPB\nbCxttjnZTSf7a6TCRjfrNxTfOr6e+81VnoGNx9/bhrlFgt3NjCnFaOubXoxOQ2HA\nSLkQcPqPVf+nA5m1UoDqYl5wG+NfexkfZFZsMnlpDp8lZ8RCUqi9LiW0wRpNInjC\nVMZayAn2IlD2nK6Z3eOvwm/y0zBt8H5gZCQ64iTUYo/GEQQ7dycPE84aTa9+2OWY\nnS44XPpCqexq8I3+ZKEfk2PG6z9JzF/e+AS6Q4tEkmw0lW4lRF2vkBICU+lVpN8=\n=qVLC\n-----END PGP SIGNATURE-----\n", "payload": "tree 5d49138356fca3df1820d004dff2c2a8b0d4ca53\nparent fc96600bf6a52f92aeeee60a92a161a82b61c0ef\nparent beb2f364cc85b4408da1d043f875d159003558e4\nauthor Yuki Okushi <jtitor@2k36.org> 1656056621 +0900\ncommitter GitHub <noreply@github.com> 1656056621 +0900\n\nRollup merge of #91264 - GuillaumeGomez:macro-jump-to-def, r=jsha\n\nAdd macro support in jump to definition feature\n\nFixes #91174.\n\nTo do so, I check if the span comes from an expansion, and if so, I infer the original macro `DefId` or `Span` depending if it's a defined in the current crate or not.\n\nThere is one limitation due to macro expansion though:\n\n```rust\nmacro_rules! yolo { () => {}}\n\nfn foo() {\n    yolo!();\n}\n```\n\nIn `foo`, `yolo!` won't be linked because after expansion, it is replaced by nothing (which seems logical). So I can't get an item from the `Visitor` from which I could tell if its `Span` comes from an expansion.\n\nI added a test for this specific limitation alongside others.\n\nDemo: https://rustdoc.crud.net/imperio/macro-jump-to-def/src/foo/check-source-code-urls-to-def-std.rs.html\n\nAs for the empty macro issue that cannot create a jump to definition, you can see it [here](https://rustdoc.crud.net/imperio/macro-jump-to-def/src/foo/check-source-code-urls-to-def-std.rs.html#35).\n\nr? ```@jyn514```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05", "html_url": "https://github.com/rust-lang/rust/commit/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc96600bf6a52f92aeeee60a92a161a82b61c0ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc96600bf6a52f92aeeee60a92a161a82b61c0ef", "html_url": "https://github.com/rust-lang/rust/commit/fc96600bf6a52f92aeeee60a92a161a82b61c0ef"}, {"sha": "beb2f364cc85b4408da1d043f875d159003558e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/beb2f364cc85b4408da1d043f875d159003558e4", "html_url": "https://github.com/rust-lang/rust/commit/beb2f364cc85b4408da1d043f875d159003558e4"}], "stats": {"total": 309, "additions": 258, "deletions": 51}, "files": [{"sha": "555db5846edd09978a5ecfab7a7ac1eb6dc62798", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=97f4d7bd2c1b001d7b9d8b238f866de0cb328b05", "patch": "@@ -133,6 +133,10 @@ impl CStore {\n         CrateNum::new(self.metas.len() - 1)\n     }\n \n+    pub fn has_crate_data(&self, cnum: CrateNum) -> bool {\n+        self.metas[cnum].is_some()\n+    }\n+\n     pub(crate) fn get_crate_data(&self, cnum: CrateNum) -> CrateMetadataRef<'_> {\n         let cdata = self.metas[cnum]\n             .as_ref()"}, {"sha": "056eda089c1de6b8c7003e39113c0ae71cda304a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=97f4d7bd2c1b001d7b9d8b238f866de0cb328b05", "patch": "@@ -8,14 +8,16 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::fmt;\n-use std::iter;\n+use std::iter::{self, once};\n \n+use rustc_ast as ast;\n use rustc_attr::{ConstStability, StabilityLevel};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n+use rustc_metadata::creader::{CStore, LoadedMacro};\n use rustc_middle::ty;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::ty::TyCtxt;\n@@ -519,6 +521,7 @@ impl clean::GenericArgs {\n }\n \n // Possible errors when computing href link source for a `DefId`\n+#[derive(PartialEq, Eq)]\n pub(crate) enum HrefError {\n     /// This item is known to rustdoc, but from a crate that does not have documentation generated.\n     ///\n@@ -556,6 +559,79 @@ pub(crate) fn join_with_double_colon(syms: &[Symbol]) -> String {\n     s\n }\n \n+/// This function is to get the external macro path because they are not in the cache used in\n+/// `href_with_root_path`.\n+fn generate_macro_def_id_path(\n+    def_id: DefId,\n+    cx: &Context<'_>,\n+    root_path: Option<&str>,\n+) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n+    let tcx = cx.shared.tcx;\n+    let crate_name = tcx.crate_name(def_id.krate).to_string();\n+    let cache = cx.cache();\n+\n+    let fqp: Vec<Symbol> = tcx\n+        .def_path(def_id)\n+        .data\n+        .into_iter()\n+        .filter_map(|elem| {\n+            // extern blocks (and a few others things) have an empty name.\n+            match elem.data.get_opt_name() {\n+                Some(s) if !s.is_empty() => Some(s),\n+                _ => None,\n+            }\n+        })\n+        .collect();\n+    let relative = fqp.iter().map(|elem| elem.to_string());\n+    let cstore = CStore::from_tcx(tcx);\n+    // We need this to prevent a `panic` when this function is used from intra doc links...\n+    if !cstore.has_crate_data(def_id.krate) {\n+        debug!(\"No data for crate {}\", crate_name);\n+        return Err(HrefError::NotInExternalCache);\n+    }\n+    // Check to see if it is a macro 2.0 or built-in macro.\n+    // More information in <https://rust-lang.github.io/rfcs/1584-macros.html>.\n+    let is_macro_2 = match cstore.load_macro_untracked(def_id, tcx.sess) {\n+        LoadedMacro::MacroDef(def, _) => {\n+            // If `ast_def.macro_rules` is `true`, then it's not a macro 2.0.\n+            matches!(&def.kind, ast::ItemKind::MacroDef(ast_def) if !ast_def.macro_rules)\n+        }\n+        _ => false,\n+    };\n+\n+    let mut path = if is_macro_2 {\n+        once(crate_name.clone()).chain(relative).collect()\n+    } else {\n+        vec![crate_name.clone(), relative.last().unwrap()]\n+    };\n+    if path.len() < 2 {\n+        // The minimum we can have is the crate name followed by the macro name. If shorter, then\n+        // it means that that `relative` was empty, which is an error.\n+        debug!(\"macro path cannot be empty!\");\n+        return Err(HrefError::NotInExternalCache);\n+    }\n+\n+    if let Some(last) = path.last_mut() {\n+        *last = format!(\"macro.{}.html\", last);\n+    }\n+\n+    let url = match cache.extern_locations[&def_id.krate] {\n+        ExternalLocation::Remote(ref s) => {\n+            // `ExternalLocation::Remote` always end with a `/`.\n+            format!(\"{}{}\", s, path.join(\"/\"))\n+        }\n+        ExternalLocation::Local => {\n+            // `root_path` always end with a `/`.\n+            format!(\"{}{}/{}\", root_path.unwrap_or(\"\"), crate_name, path.join(\"/\"))\n+        }\n+        ExternalLocation::Unknown => {\n+            debug!(\"crate {} not in cache when linkifying macros\", crate_name);\n+            return Err(HrefError::NotInExternalCache);\n+        }\n+    };\n+    Ok((url, ItemType::Macro, fqp))\n+}\n+\n pub(crate) fn href_with_root_path(\n     did: DefId,\n     cx: &Context<'_>,\n@@ -611,6 +687,8 @@ pub(crate) fn href_with_root_path(\n                         ExternalLocation::Unknown => return Err(HrefError::DocumentationNotBuilt),\n                     },\n                 )\n+            } else if matches!(def_kind, DefKind::Macro(_)) {\n+                return generate_macro_def_id_path(did, cx, root_path);\n             } else {\n                 return Err(HrefError::NotInExternalCache);\n             }"}, {"sha": "d2ef89078bf6d131751c33f49267359336fa8619", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 83, "deletions": 32, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=97f4d7bd2c1b001d7b9d8b238f866de0cb328b05", "patch": "@@ -22,7 +22,7 @@ use super::format::{self, Buffer};\n use super::render::LinkFromSrc;\n \n /// This type is needed in case we want to render links on items to allow to go to their definition.\n-pub(crate) struct ContextInfo<'a, 'b, 'c> {\n+pub(crate) struct HrefContext<'a, 'b, 'c> {\n     pub(crate) context: &'a Context<'b>,\n     /// This span contains the current file we're going through.\n     pub(crate) file_span: Span,\n@@ -44,7 +44,7 @@ pub(crate) fn render_with_highlighting(\n     tooltip: Option<(Option<Edition>, &str)>,\n     edition: Edition,\n     extra_content: Option<Buffer>,\n-    context_info: Option<ContextInfo<'_, '_, '_>>,\n+    href_context: Option<HrefContext<'_, '_, '_>>,\n     decoration_info: Option<DecorationInfo>,\n ) {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n@@ -62,7 +62,7 @@ pub(crate) fn render_with_highlighting(\n     }\n \n     write_header(out, class, extra_content);\n-    write_code(out, src, edition, context_info, decoration_info);\n+    write_code(out, src, edition, href_context, decoration_info);\n     write_footer(out, playground_button);\n }\n \n@@ -85,31 +85,36 @@ fn write_header(out: &mut Buffer, class: Option<&str>, extra_content: Option<Buf\n ///\n /// Some explanations on the last arguments:\n ///\n-/// In case we are rendering a code block and not a source code file, `context_info` will be `None`.\n-/// To put it more simply: if `context_info` is `None`, the code won't try to generate links to an\n+/// In case we are rendering a code block and not a source code file, `href_context` will be `None`.\n+/// To put it more simply: if `href_context` is `None`, the code won't try to generate links to an\n /// item definition.\n ///\n /// More explanations about spans and how we use them here are provided in the\n fn write_code(\n     out: &mut Buffer,\n     src: &str,\n     edition: Edition,\n-    context_info: Option<ContextInfo<'_, '_, '_>>,\n+    href_context: Option<HrefContext<'_, '_, '_>>,\n     decoration_info: Option<DecorationInfo>,\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n+    let mut closing_tags: Vec<&'static str> = Vec::new();\n     Classifier::new(\n         &src,\n         edition,\n-        context_info.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),\n+        href_context.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),\n         decoration_info,\n     )\n     .highlight(&mut |highlight| {\n         match highlight {\n-            Highlight::Token { text, class } => string(out, Escape(text), class, &context_info),\n-            Highlight::EnterSpan { class } => enter_span(out, class),\n-            Highlight::ExitSpan => exit_span(out),\n+            Highlight::Token { text, class } => string(out, Escape(text), class, &href_context),\n+            Highlight::EnterSpan { class } => {\n+                closing_tags.push(enter_span(out, class, &href_context))\n+            }\n+            Highlight::ExitSpan => {\n+                exit_span(out, closing_tags.pop().expect(\"ExitSpan without EnterSpan\"))\n+            }\n         };\n     });\n }\n@@ -129,7 +134,7 @@ enum Class {\n     RefKeyWord,\n     Self_(Span),\n     Op,\n-    Macro,\n+    Macro(Span),\n     MacroNonTerminal,\n     String,\n     Number,\n@@ -153,7 +158,7 @@ impl Class {\n             Class::RefKeyWord => \"kw-2\",\n             Class::Self_(_) => \"self\",\n             Class::Op => \"op\",\n-            Class::Macro => \"macro\",\n+            Class::Macro(_) => \"macro\",\n             Class::MacroNonTerminal => \"macro-nonterminal\",\n             Class::String => \"string\",\n             Class::Number => \"number\",\n@@ -171,8 +176,22 @@ impl Class {\n     /// a \"span\" (a tuple representing `(lo, hi)` equivalent of `Span`).\n     fn get_span(self) -> Option<Span> {\n         match self {\n-            Self::Ident(sp) | Self::Self_(sp) => Some(sp),\n-            _ => None,\n+            Self::Ident(sp) | Self::Self_(sp) | Self::Macro(sp) => Some(sp),\n+            Self::Comment\n+            | Self::DocComment\n+            | Self::Attribute\n+            | Self::KeyWord\n+            | Self::RefKeyWord\n+            | Self::Op\n+            | Self::MacroNonTerminal\n+            | Self::String\n+            | Self::Number\n+            | Self::Bool\n+            | Self::Lifetime\n+            | Self::PreludeTy\n+            | Self::PreludeVal\n+            | Self::QuestionMark\n+            | Self::Decoration(_) => None,\n         }\n     }\n }\n@@ -611,7 +630,7 @@ impl<'a> Classifier<'a> {\n             },\n             TokenKind::Ident | TokenKind::RawIdent if lookahead == Some(TokenKind::Bang) => {\n                 self.in_macro = true;\n-                sink(Highlight::EnterSpan { class: Class::Macro });\n+                sink(Highlight::EnterSpan { class: Class::Macro(self.new_span(before, text)) });\n                 sink(Highlight::Token { text, class: None });\n                 return;\n             }\n@@ -658,13 +677,20 @@ impl<'a> Classifier<'a> {\n \n /// Called when we start processing a span of text that should be highlighted.\n /// The `Class` argument specifies how it should be highlighted.\n-fn enter_span(out: &mut Buffer, klass: Class) {\n-    write!(out, \"<span class=\\\"{}\\\">\", klass.as_html());\n+fn enter_span(\n+    out: &mut Buffer,\n+    klass: Class,\n+    href_context: &Option<HrefContext<'_, '_, '_>>,\n+) -> &'static str {\n+    string_without_closing_tag(out, \"\", Some(klass), href_context).expect(\n+        \"internal error: enter_span was called with Some(klass) but did not return a \\\n+            closing HTML tag\",\n+    )\n }\n \n /// Called at the end of a span of highlighted text.\n-fn exit_span(out: &mut Buffer) {\n-    out.write_str(\"</span>\");\n+fn exit_span(out: &mut Buffer, closing_tag: &str) {\n+    out.write_str(closing_tag);\n }\n \n /// Called for a span of text. If the text should be highlighted differently\n@@ -687,15 +713,39 @@ fn string<T: Display>(\n     out: &mut Buffer,\n     text: T,\n     klass: Option<Class>,\n-    context_info: &Option<ContextInfo<'_, '_, '_>>,\n+    href_context: &Option<HrefContext<'_, '_, '_>>,\n ) {\n+    if let Some(closing_tag) = string_without_closing_tag(out, text, klass, href_context) {\n+        out.write_str(closing_tag);\n+    }\n+}\n+\n+/// This function writes `text` into `out` with some modifications depending on `klass`:\n+///\n+/// * If `klass` is `None`, `text` is written into `out` with no modification.\n+/// * If `klass` is `Some` but `klass.get_span()` is `None`, it writes the text wrapped in a\n+///   `<span>` with the provided `klass`.\n+/// * If `klass` is `Some` and has a [`rustc_span::Span`], it then tries to generate a link (`<a>`\n+///   element) by retrieving the link information from the `span_correspondance_map` that was filled\n+///   in `span_map.rs::collect_spans_and_sources`. If it cannot retrieve the information, then it's\n+///   the same as the second point (`klass` is `Some` but doesn't have a [`rustc_span::Span`]).\n+fn string_without_closing_tag<T: Display>(\n+    out: &mut Buffer,\n+    text: T,\n+    klass: Option<Class>,\n+    href_context: &Option<HrefContext<'_, '_, '_>>,\n+) -> Option<&'static str> {\n     let Some(klass) = klass\n-    else { return write!(out, \"{}\", text) };\n+    else {\n+        write!(out, \"{}\", text);\n+        return None;\n+    };\n     let Some(def_span) = klass.get_span()\n     else {\n-        write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text);\n-        return;\n+        write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text);\n+        return Some(\"</span>\");\n     };\n+\n     let mut text_s = text.to_string();\n     if text_s.contains(\"::\") {\n         text_s = text_s.split(\"::\").intersperse(\"::\").fold(String::new(), |mut path, t| {\n@@ -715,10 +765,10 @@ fn string<T: Display>(\n             path\n         });\n     }\n-    if let Some(context_info) = context_info {\n+    if let Some(href_context) = href_context {\n         if let Some(href) =\n-            context_info.context.shared.span_correspondance_map.get(&def_span).and_then(|href| {\n-                let context = context_info.context;\n+            href_context.context.shared.span_correspondance_map.get(&def_span).and_then(|href| {\n+                let context = href_context.context;\n                 // FIXME: later on, it'd be nice to provide two links (if possible) for all items:\n                 // one to the documentation page and one to the source definition.\n                 // FIXME: currently, external items only generate a link to their documentation,\n@@ -727,27 +777,28 @@ fn string<T: Display>(\n                 match href {\n                     LinkFromSrc::Local(span) => context\n                         .href_from_span(*span, true)\n-                        .map(|s| format!(\"{}{}\", context_info.root_path, s)),\n+                        .map(|s| format!(\"{}{}\", href_context.root_path, s)),\n                     LinkFromSrc::External(def_id) => {\n-                        format::href_with_root_path(*def_id, context, Some(context_info.root_path))\n+                        format::href_with_root_path(*def_id, context, Some(href_context.root_path))\n                             .ok()\n                             .map(|(url, _, _)| url)\n                     }\n                     LinkFromSrc::Primitive(prim) => format::href_with_root_path(\n                         PrimitiveType::primitive_locations(context.tcx())[prim],\n                         context,\n-                        Some(context_info.root_path),\n+                        Some(href_context.root_path),\n                     )\n                     .ok()\n                     .map(|(url, _, _)| url),\n                 }\n             })\n         {\n-            write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}</a>\", klass.as_html(), href, text_s);\n-            return;\n+            write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}\", klass.as_html(), href, text_s);\n+            return Some(\"</a>\");\n         }\n     }\n-    write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text_s);\n+    write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text_s);\n+    Some(\"</span>\")\n }\n \n #[cfg(test)]"}, {"sha": "34d590fb2448c553a7f3f271c1e1f81dd8538ea8", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 66, "deletions": 17, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=97f4d7bd2c1b001d7b9d8b238f866de0cb328b05", "patch": "@@ -8,7 +8,8 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{ExprKind, HirId, Mod, Node};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::Span;\n+use rustc_span::hygiene::MacroKind;\n+use rustc_span::{BytePos, ExpnKind, Span};\n \n use std::path::{Path, PathBuf};\n \n@@ -63,33 +64,72 @@ struct SpanMapVisitor<'tcx> {\n \n impl<'tcx> SpanMapVisitor<'tcx> {\n     /// This function is where we handle `hir::Path` elements and add them into the \"span map\".\n-    fn handle_path(&mut self, path: &rustc_hir::Path<'_>, path_span: Option<Span>) {\n+    fn handle_path(&mut self, path: &rustc_hir::Path<'_>) {\n         let info = match path.res {\n-            // FIXME: For now, we only handle `DefKind` if it's not `DefKind::TyParam` or\n-            // `DefKind::Macro`. Would be nice to support them too alongside the other `DefKind`\n+            // FIXME: For now, we handle `DefKind` if it's not a `DefKind::TyParam`.\n+            // Would be nice to support them too alongside the other `DefKind`\n             // (such as primitive types!).\n-            Res::Def(kind, def_id) if kind != DefKind::TyParam => {\n-                if matches!(kind, DefKind::Macro(_)) {\n-                    return;\n-                }\n-                Some(def_id)\n-            }\n+            Res::Def(kind, def_id) if kind != DefKind::TyParam => Some(def_id),\n             Res::Local(_) => None,\n             Res::PrimTy(p) => {\n                 // FIXME: Doesn't handle \"path-like\" primitives like arrays or tuples.\n-                let span = path_span.unwrap_or(path.span);\n-                self.matches.insert(span, LinkFromSrc::Primitive(PrimitiveType::from(p)));\n+                self.matches.insert(path.span, LinkFromSrc::Primitive(PrimitiveType::from(p)));\n                 return;\n             }\n             Res::Err => return,\n             _ => return,\n         };\n         if let Some(span) = self.tcx.hir().res_span(path.res) {\n-            self.matches\n-                .insert(path_span.unwrap_or(path.span), LinkFromSrc::Local(clean::Span::new(span)));\n+            self.matches.insert(path.span, LinkFromSrc::Local(clean::Span::new(span)));\n         } else if let Some(def_id) = info {\n-            self.matches.insert(path_span.unwrap_or(path.span), LinkFromSrc::External(def_id));\n+            self.matches.insert(path.span, LinkFromSrc::External(def_id));\n+        }\n+    }\n+\n+    /// Adds the macro call into the span map. Returns `true` if the `span` was inside a macro\n+    /// expansion, whether or not it was added to the span map.\n+    ///\n+    /// The idea for the macro support is to check if the current `Span` comes from expansion. If\n+    /// so, we loop until we find the macro definition by using `outer_expn_data` in a loop.\n+    /// Finally, we get the information about the macro itself (`span` if \"local\", `DefId`\n+    /// otherwise) and store it inside the span map.\n+    fn handle_macro(&mut self, span: Span) -> bool {\n+        if !span.from_expansion() {\n+            return false;\n+        }\n+        // So if the `span` comes from a macro expansion, we need to get the original\n+        // macro's `DefId`.\n+        let mut data = span.ctxt().outer_expn_data();\n+        let mut call_site = data.call_site;\n+        // Macros can expand to code containing macros, which will in turn be expanded, etc.\n+        // So the idea here is to \"go up\" until we're back to code that was generated from\n+        // macro expansion so that we can get the `DefId` of the original macro that was at the\n+        // origin of this expansion.\n+        while call_site.from_expansion() {\n+            data = call_site.ctxt().outer_expn_data();\n+            call_site = data.call_site;\n         }\n+\n+        let macro_name = match data.kind {\n+            ExpnKind::Macro(MacroKind::Bang, macro_name) => macro_name,\n+            // Even though we don't handle this kind of macro, this `data` still comes from\n+            // expansion so we return `true` so we don't go any deeper in this code.\n+            _ => return true,\n+        };\n+        let link_from_src = match data.macro_def_id {\n+            Some(macro_def_id) if macro_def_id.is_local() => {\n+                LinkFromSrc::Local(clean::Span::new(data.def_site))\n+            }\n+            Some(macro_def_id) => LinkFromSrc::External(macro_def_id),\n+            None => return true,\n+        };\n+        let new_span = data.call_site;\n+        let macro_name = macro_name.as_str();\n+        // The \"call_site\" includes the whole macro with its \"arguments\". We only want\n+        // the macro name.\n+        let new_span = new_span.with_hi(new_span.lo() + BytePos(macro_name.len() as u32));\n+        self.matches.insert(new_span, link_from_src);\n+        true\n     }\n }\n \n@@ -101,7 +141,10 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &'tcx rustc_hir::Path<'tcx>, _id: HirId) {\n-        self.handle_path(path, None);\n+        if self.handle_macro(path.span) {\n+            return;\n+        }\n+        self.handle_path(path);\n         intravisit::walk_path(self, path);\n     }\n \n@@ -143,12 +186,18 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n                     );\n                 }\n             }\n+        } else if self.handle_macro(expr.span) {\n+            // We don't want to go deeper into the macro.\n+            return;\n         }\n         intravisit::walk_expr(self, expr);\n     }\n \n     fn visit_use(&mut self, path: &'tcx rustc_hir::Path<'tcx>, id: HirId) {\n-        self.handle_path(path, None);\n+        if self.handle_macro(path.span) {\n+            return;\n+        }\n+        self.handle_path(path);\n         intravisit::walk_use(self, path, id);\n     }\n }"}, {"sha": "d0fd637ba884322c6eea9ef8c630cffb672b7124", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=97f4d7bd2c1b001d7b9d8b238f866de0cb328b05", "patch": "@@ -297,7 +297,7 @@ pub(crate) fn print_src(\n         None,\n         edition,\n         Some(line_numbers),\n-        Some(highlight::ContextInfo { context, file_span, root_path }),\n+        Some(highlight::HrefContext { context, file_span, root_path }),\n         decoration_info,\n     );\n }"}, {"sha": "3396b234a77b19de0d311d8c34ea05cdda056c89", "filename": "src/test/rustdoc/check-source-code-urls-to-def-std.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f4d7bd2c1b001d7b9d8b238f866de0cb328b05/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def-std.rs?ref=97f4d7bd2c1b001d7b9d8b238f866de0cb328b05", "patch": "@@ -15,3 +15,28 @@ pub fn foo(a: u32, b: &str, c: String) {\n     let y: bool = true;\n     babar();\n }\n+\n+macro_rules! yolo { () => {}}\n+\n+fn bar(a: i32) {}\n+\n+macro_rules! bar {\n+    ($a:ident) => { bar($a) }\n+}\n+\n+macro_rules! data {\n+    ($x:expr) => { $x * 2 }\n+}\n+\n+pub fn another_foo() {\n+    // This is known limitation: if the macro doesn't generate anything, the visitor\n+    // can't find any item or anything that could tell us that it comes from expansion.\n+    // @!has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def-std.rs.html#19\"]' 'yolo!'\n+    yolo!();\n+    // @has - '//a[@href=\"{{channel}}/std/macro.eprintln.html\"]' 'eprintln!'\n+    eprintln!();\n+    // @has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def-std.rs.html#27-29\"]' 'data!'\n+    let x = data!(4);\n+    // @has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def-std.rs.html#23-25\"]' 'bar!'\n+    bar!(x);\n+}"}]}