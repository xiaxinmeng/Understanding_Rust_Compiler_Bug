{"sha": "dc1a094b40e73af21a267378f1fa6c880b097d61", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMWEwOTRiNDBlNzNhZjIxYTI2NzM3OGYxZmE2Yzg4MGIwOTdkNjE=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2016-12-12T19:10:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-12T19:10:32Z"}, "message": "Rollup merge of #37052 - srinivasreddy:hair_cx, r=pnkfelix\n\nRun rustfmt on librustc_mir/hair/cx", "tree": {"sha": "eb2841a63199dd5bb5277318b81164da4924c281", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb2841a63199dd5bb5277318b81164da4924c281"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc1a094b40e73af21a267378f1fa6c880b097d61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc1a094b40e73af21a267378f1fa6c880b097d61", "html_url": "https://github.com/rust-lang/rust/commit/dc1a094b40e73af21a267378f1fa6c880b097d61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc1a094b40e73af21a267378f1fa6c880b097d61/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4b1e5ece21fb497877350c3d6defa143c88076c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4b1e5ece21fb497877350c3d6defa143c88076c", "html_url": "https://github.com/rust-lang/rust/commit/b4b1e5ece21fb497877350c3d6defa143c88076c"}, {"sha": "f78aa4d46c4aa45eff8c25cc0b2825ef2a3a428e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f78aa4d46c4aa45eff8c25cc0b2825ef2a3a428e", "html_url": "https://github.com/rust-lang/rust/commit/f78aa4d46c4aa45eff8c25cc0b2825ef2a3a428e"}], "stats": {"total": 692, "additions": 373, "deletions": 319}, "files": [{"sha": "b355c8f2c4c6f57be318a2143a50e7cb61c31220", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/dc1a094b40e73af21a267378f1fa6c880b097d61/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1a094b40e73af21a267378f1fa6c880b097d61/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=dc1a094b40e73af21a267378f1fa6c880b097d61", "patch": "@@ -26,47 +26,52 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n             extent: cx.tcx.region_maps.node_extent(self.id),\n             span: self.span,\n             stmts: stmts,\n-            expr: self.expr.to_ref()\n+            expr: self.expr.to_ref(),\n         }\n     }\n }\n \n fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 block_id: ast::NodeId,\n                                 stmts: &'tcx [hir::Stmt])\n-                                -> Vec<StmtRef<'tcx>>\n-{\n+                                -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n         match stmt.node {\n-            hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) =>\n+            hir::StmtExpr(ref expr, id) |\n+            hir::StmtSemi(ref expr, id) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     span: stmt.span,\n                     kind: StmtKind::Expr {\n                         scope: cx.tcx.region_maps.node_extent(id),\n-                        expr: expr.to_ref()\n+                        expr: expr.to_ref(),\n+                    },\n+                })))\n+            }\n+            hir::StmtDecl(ref decl, id) => {\n+                match decl.node {\n+                    hir::DeclItem(..) => {\n+                        // ignore for purposes of the MIR\n                     }\n-                }))),\n-            hir::StmtDecl(ref decl, id) => match decl.node {\n-                hir::DeclItem(..) => { /* ignore for purposes of the MIR */ }\n-                hir::DeclLocal(ref local) => {\n-                    let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n-                        block: block_id,\n-                        first_statement_index: index as u32,\n-                    });\n-                    let remainder_extent =\n-                        cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n+                    hir::DeclLocal(ref local) => {\n+                        let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n+                            block: block_id,\n+                            first_statement_index: index as u32,\n+                        });\n+                        let remainder_extent =\n+                            cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n \n-                    let pattern = Pattern::from_hir(cx.tcx, &local.pat);\n-                    result.push(StmtRef::Mirror(Box::new(Stmt {\n-                        span: stmt.span,\n-                        kind: StmtKind::Let {\n-                            remainder_scope: remainder_extent,\n-                            init_scope: cx.tcx.region_maps.node_extent(id),\n-                            pattern: pattern,\n-                            initializer: local.init.to_ref(),\n-                        },\n-                    })));\n+                        let pattern = Pattern::from_hir(cx.tcx, &local.pat);\n+                        result.push(StmtRef::Mirror(Box::new(Stmt {\n+                            span: stmt.span,\n+                            kind: StmtKind::Let {\n+                                remainder_scope: remainder_extent,\n+                                init_scope: cx.tcx.region_maps.node_extent(id),\n+                                pattern: pattern,\n+                                initializer: local.init.to_ref(),\n+                            },\n+                        })));\n+                    }\n                 }\n             }\n         }"}, {"sha": "d579cdb042fb3f3b7d4075beacff0eef321d121b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 307, "deletions": 258, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/dc1a094b40e73af21a267378f1fa6c880b097d61/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1a094b40e73af21a267378f1fa6c880b097d61/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=dc1a094b40e73af21a267378f1fa6c880b097d61", "patch": "@@ -36,7 +36,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         let adj = cx.tcx.tables().adjustments.get(&self.id).cloned();\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n-               expr, adj);\n+               expr,\n+               adj);\n \n         // Now apply adjustments, if any.\n         match adj.map(|adj| (adj.kind, adj.target)) {\n@@ -78,41 +79,44 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 for i in 0..autoderefs {\n                     let i = i as u32;\n                     let adjusted_ty =\n-                        expr.ty.adjust_for_autoderef(\n-                            cx.tcx,\n-                            self.id,\n-                            self.span,\n-                            i,\n-                            |mc| cx.tcx.tables().method_map.get(&mc).map(|m| m.ty));\n-                    debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\", i, adjusted_ty);\n+                        expr.ty.adjust_for_autoderef(cx.tcx, self.id, self.span, i, |mc| {\n+                            cx.tcx.tables().method_map.get(&mc).map(|m| m.ty)\n+                        });\n+                    debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\",\n+                           i,\n+                           adjusted_ty);\n                     let method_key = ty::MethodCall::autoderef(self.id, i);\n-                    let meth_ty =\n-                        cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n+                    let meth_ty = cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n                     let kind = if let Some(meth_ty) = meth_ty {\n                         debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n \n                         let ref_ty = cx.tcx.no_late_bound_regions(&meth_ty.fn_ret());\n                         let (region, mutbl) = match ref_ty {\n-                            Some(&ty::TyS {\n-                                sty: ty::TyRef(region, mt), ..\n-                            }) => (region, mt.mutbl),\n-                            _ => span_bug!(expr.span, \"autoderef returned bad type\")\n+                            Some(&ty::TyS { sty: ty::TyRef(region, mt), .. }) => (region, mt.mutbl),\n+                            _ => span_bug!(expr.span, \"autoderef returned bad type\"),\n                         };\n \n                         expr = Expr {\n                             temp_lifetime: temp_lifetime,\n-                            ty: cx.tcx.mk_ref(\n-                                region, ty::TypeAndMut { ty: expr.ty, mutbl: mutbl }),\n+                            ty: cx.tcx.mk_ref(region,\n+                                              ty::TypeAndMut {\n+                                                  ty: expr.ty,\n+                                                  mutbl: mutbl,\n+                                              }),\n                             span: expr.span,\n                             kind: ExprKind::Borrow {\n                                 region: region,\n                                 borrow_kind: to_borrow_kind(mutbl),\n-                                arg: expr.to_ref()\n-                            }\n+                                arg: expr.to_ref(),\n+                            },\n                         };\n \n-                        overloaded_lvalue(cx, self, method_key,\n-                                          PassArgs::ByRef, expr.to_ref(), vec![])\n+                        overloaded_lvalue(cx,\n+                                          self,\n+                                          method_key,\n+                                          PassArgs::ByRef,\n+                                          expr.to_ref(),\n+                                          vec![])\n                     } else {\n                         debug!(\"make_mirror: built-in autoderef\");\n                         ExprKind::Deref { arg: expr.to_ref() }\n@@ -148,7 +152,11 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                             let region = cx.tcx.mk_region(region);\n                             expr = Expr {\n                                 temp_lifetime: temp_lifetime,\n-                                ty: cx.tcx.mk_ref(region, ty::TypeAndMut { ty: expr.ty, mutbl: m }),\n+                                ty: cx.tcx.mk_ref(region,\n+                                                  ty::TypeAndMut {\n+                                                      ty: expr.ty,\n+                                                      mutbl: m,\n+                                                  }),\n                                 span: self.span,\n                                 kind: ExprKind::Borrow {\n                                     region: region,\n@@ -240,57 +248,62 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n                 let sig = match method.ty.sty {\n                     ty::TyFnDef(.., fn_ty) => &fn_ty.sig,\n-                    _ => span_bug!(expr.span, \"type of method is not an fn\")\n+                    _ => span_bug!(expr.span, \"type of method is not an fn\"),\n                 };\n \n-                let sig = cx.tcx.no_late_bound_regions(sig).unwrap_or_else(|| {\n-                    span_bug!(expr.span, \"method call has late-bound regions\")\n-                });\n+                let sig = cx.tcx\n+                    .no_late_bound_regions(sig)\n+                    .unwrap_or_else(|| span_bug!(expr.span, \"method call has late-bound regions\"));\n \n                 assert_eq!(sig.inputs().len(), 2);\n \n                 let tupled_args = Expr {\n                     ty: sig.inputs()[1],\n                     temp_lifetime: temp_lifetime,\n                     span: expr.span,\n-                    kind: ExprKind::Tuple {\n-                        fields: args.iter().map(ToRef::to_ref).collect()\n-                    }\n+                    kind: ExprKind::Tuple { fields: args.iter().map(ToRef::to_ref).collect() },\n                 };\n \n                 ExprKind::Call {\n                     ty: method.ty,\n                     fun: method.to_ref(),\n-                    args: vec![fun.to_ref(), tupled_args.to_ref()]\n+                    args: vec![fun.to_ref(), tupled_args.to_ref()],\n                 }\n             } else {\n                 let adt_data = if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = fun.node {\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n-                    expr_ty.ty_adt_def().and_then(|adt_def|{\n+                    expr_ty.ty_adt_def().and_then(|adt_def| {\n                         match path.def {\n                             Def::VariantCtor(variant_id, CtorKind::Fn) => {\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n-                            },\n-                            Def::StructCtor(_, CtorKind::Fn) => {\n-                                Some((adt_def, 0))\n-                            },\n-                            _ => None\n+                            }\n+                            Def::StructCtor(_, CtorKind::Fn) => Some((adt_def, 0)),\n+                            _ => None,\n                         }\n                     })\n-                } else { None };\n+                } else {\n+                    None\n+                };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tcx.tables().node_id_item_substs(fun.id)\n+                    let substs = cx.tcx\n+                        .tables()\n+                        .node_id_item_substs(fun.id)\n                         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n-                    let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n-                        name: Field::new(idx),\n-                        expr: e.to_ref()\n-                    }).collect();\n+                    let field_refs = args.iter()\n+                        .enumerate()\n+                        .map(|(idx, e)| {\n+                            FieldExprRef {\n+                                name: Field::new(idx),\n+                                expr: e.to_ref(),\n+                            }\n+                        })\n+                        .collect();\n                     ExprKind::Adt {\n                         adt_def: adt_def,\n                         substs: substs,\n                         variant_index: index,\n                         fields: field_refs,\n-                        base: None\n+                        base: None,\n                     }\n                 } else {\n                     ExprKind::Call {\n@@ -314,9 +327,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprBlock(ref blk) => {\n-            ExprKind::Block { body: &blk }\n-        }\n+        hir::ExprBlock(ref blk) => ExprKind::Block { body: &blk },\n \n         hir::ExprAssign(ref lhs, ref rhs) => {\n             ExprKind::Assign {\n@@ -332,8 +343,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 } else {\n                     PassArgs::ByRef\n                 };\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    pass_args, lhs.to_ref(), vec![rhs])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    pass_args,\n+                                    lhs.to_ref(),\n+                                    vec![rhs])\n             } else {\n                 ExprKind::AssignOp {\n                     op: bin_op(op.node),\n@@ -343,9 +358,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprLit(..) => ExprKind::Literal {\n-            literal: cx.const_eval_literal(expr)\n-        },\n+        hir::ExprLit(..) => ExprKind::Literal { literal: cx.const_eval_literal(expr) },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n@@ -354,8 +367,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 } else {\n                     PassArgs::ByRef\n                 };\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    pass_args, lhs.to_ref(), vec![rhs])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    pass_args,\n+                                    lhs.to_ref(),\n+                                    vec![rhs])\n             } else {\n                 // FIXME overflow\n                 match (op.node, cx.constness) {\n@@ -405,8 +422,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprIndex(ref lhs, ref index) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n-                                  PassArgs::ByValue, lhs.to_ref(), vec![index])\n+                overloaded_lvalue(cx,\n+                                  expr,\n+                                  ty::MethodCall::expr(expr.id),\n+                                  PassArgs::ByValue,\n+                                  lhs.to_ref(),\n+                                  vec![index])\n             } else {\n                 ExprKind::Index {\n                     lhs: lhs.to_ref(),\n@@ -417,17 +438,25 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n-                                  PassArgs::ByValue, arg.to_ref(), vec![])\n+                overloaded_lvalue(cx,\n+                                  expr,\n+                                  ty::MethodCall::expr(expr.id),\n+                                  PassArgs::ByValue,\n+                                  arg.to_ref(),\n+                                  vec![])\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    PassArgs::ByValue, arg.to_ref(), vec![])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    PassArgs::ByValue,\n+                                    arg.to_ref(),\n+                                    vec![])\n             } else {\n                 ExprKind::Unary {\n                     op: UnOp::Not,\n@@ -438,14 +467,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    PassArgs::ByValue, arg.to_ref(), vec![])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    PassArgs::ByValue,\n+                                    arg.to_ref(),\n+                                    vec![])\n             } else {\n                 // FIXME runtime-overflow\n                 if let hir::ExprLit(_) = arg.node {\n-                    ExprKind::Literal {\n-                        literal: cx.const_eval_literal(expr),\n-                    }\n+                    ExprKind::Literal { literal: cx.const_eval_literal(expr) }\n                 } else {\n                     ExprKind::Unary {\n                         op: UnOp::Neg,\n@@ -457,56 +488,54 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprStruct(ref qpath, ref fields, ref base) => {\n             match expr_ty.sty {\n-                ty::TyAdt(adt, substs) => match adt.adt_kind() {\n-                    AdtKind::Struct | AdtKind::Union => {\n-                        let field_refs = field_refs(&adt.variants[0], fields);\n-                        ExprKind::Adt {\n-                            adt_def: adt,\n-                            variant_index: 0,\n-                            substs: substs,\n-                            fields: field_refs,\n-                            base: base.as_ref().map(|base| {\n-                                FruInfo {\n-                                    base: base.to_ref(),\n-                                    field_types:\n-                                        cx.tcx.tables().fru_field_types[&expr.id].clone()\n-                                }\n-                            })\n+                ty::TyAdt(adt, substs) => {\n+                    match adt.adt_kind() {\n+                        AdtKind::Struct | AdtKind::Union => {\n+                            let field_refs = field_refs(&adt.variants[0], fields);\n+                            ExprKind::Adt {\n+                                adt_def: adt,\n+                                variant_index: 0,\n+                                substs: substs,\n+                                fields: field_refs,\n+                                base: base.as_ref().map(|base| {\n+                                    FruInfo {\n+                                        base: base.to_ref(),\n+                                        field_types: cx.tcx.tables().fru_field_types[&expr.id]\n+                                            .clone(),\n+                                    }\n+                                }),\n+                            }\n                         }\n-                    }\n-                    AdtKind::Enum => {\n-                        let def = match *qpath {\n-                            hir::QPath::Resolved(_, ref path) => path.def,\n-                            hir::QPath::TypeRelative(..) => Def::Err\n-                        };\n-                        match def {\n-                            Def::Variant(variant_id) => {\n-                                assert!(base.is_none());\n-\n-                                let index = adt.variant_index_with_id(variant_id);\n-                                let field_refs = field_refs(&adt.variants[index], fields);\n-                                ExprKind::Adt {\n-                                    adt_def: adt,\n-                                    variant_index: index,\n-                                    substs: substs,\n-                                    fields: field_refs,\n-                                    base: None\n+                        AdtKind::Enum => {\n+                            let def = match *qpath {\n+                                hir::QPath::Resolved(_, ref path) => path.def,\n+                                hir::QPath::TypeRelative(..) => Def::Err,\n+                            };\n+                            match def {\n+                                Def::Variant(variant_id) => {\n+                                    assert!(base.is_none());\n+\n+                                    let index = adt.variant_index_with_id(variant_id);\n+                                    let field_refs = field_refs(&adt.variants[index], fields);\n+                                    ExprKind::Adt {\n+                                        adt_def: adt,\n+                                        variant_index: index,\n+                                        substs: substs,\n+                                        fields: field_refs,\n+                                        base: None,\n+                                    }\n+                                }\n+                                _ => {\n+                                    span_bug!(expr.span, \"unexpected def: {:?}\", def);\n                                 }\n-                            }\n-                            _ => {\n-                                span_bug!(\n-                                    expr.span,\n-                                    \"unexpected def: {:?}\",\n-                                    def);\n                             }\n                         }\n                     }\n-                },\n+                }\n                 _ => {\n-                    span_bug!(\n-                        expr.span,\n-                        \"unexpected type for struct literal: {:?}\",\n-                        expr_ty);\n+                    span_bug!(expr.span,\n+                              \"unexpected type for struct literal: {:?}\",\n+                              expr_ty);\n                 }\n             }\n         }\n@@ -516,9 +545,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let (def_id, substs) = match closure_ty.sty {\n                 ty::TyClosure(def_id, substs) => (def_id, substs),\n                 _ => {\n-                    span_bug!(expr.span,\n-                              \"closure expr w/o closure type: {:?}\",\n-                              closure_ty);\n+                    span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n             };\n             let upvars = cx.tcx.with_freevars(expr.id, |freevars| {\n@@ -543,69 +570,81 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::InlineAsm {\n                 asm: asm,\n                 outputs: outputs.to_ref(),\n-                inputs: inputs.to_ref()\n+                inputs: inputs.to_ref(),\n             }\n         }\n \n         // Now comes the rote stuff:\n-\n-        hir::ExprRepeat(ref v, ref c) => ExprKind::Repeat {\n-            value: v.to_ref(),\n-            count: TypedConstVal {\n-                ty: cx.tcx.tables().expr_ty(c),\n-                span: c.span,\n-                value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n-                    ConstVal::Integral(ConstInt::Usize(u)) => u,\n-                    other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n+        hir::ExprRepeat(ref v, ref c) => {\n+            ExprKind::Repeat {\n+                value: v.to_ref(),\n+                count: TypedConstVal {\n+                    ty: cx.tcx.tables().expr_ty(c),\n+                    span: c.span,\n+                    value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n+                        ConstVal::Integral(ConstInt::Usize(u)) => u,\n+                        other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n+                    },\n                 },\n             }\n-        },\n-        hir::ExprRet(ref v) =>\n-            ExprKind::Return { value: v.to_ref() },\n-        hir::ExprBreak(label, ref value) =>\n+        }\n+        hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n+        hir::ExprBreak(label, ref value) => {\n             ExprKind::Break {\n-                label: label.map(|label| {\n-                    cx.tcx.region_maps.node_extent(label.loop_id)\n-                }),\n-                value: value.to_ref()\n-            },\n-        hir::ExprAgain(label) =>\n+                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n+                value: value.to_ref(),\n+            }\n+        }\n+        hir::ExprAgain(label) => {\n             ExprKind::Continue {\n-                label: label.map(|label| {\n-                    cx.tcx.region_maps.node_extent(label.loop_id)\n-                })\n-            },\n-        hir::ExprMatch(ref discr, ref arms, _) =>\n-            ExprKind::Match { discriminant: discr.to_ref(),\n-                              arms: arms.iter().map(|a| convert_arm(cx, a)).collect() },\n-        hir::ExprIf(ref cond, ref then, ref otherwise) =>\n-            ExprKind::If { condition: cond.to_ref(),\n-                           then: block::to_expr_ref(cx, then),\n-                           otherwise: otherwise.to_ref() },\n-        hir::ExprWhile(ref cond, ref body, _) =>\n-            ExprKind::Loop { condition: Some(cond.to_ref()),\n-                             body: block::to_expr_ref(cx, body) },\n-        hir::ExprLoop(ref body, _, _) =>\n-            ExprKind::Loop { condition: None,\n-                             body: block::to_expr_ref(cx, body) },\n+                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n+            }\n+        }\n+        hir::ExprMatch(ref discr, ref arms, _) => {\n+            ExprKind::Match {\n+                discriminant: discr.to_ref(),\n+                arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n+            }\n+        }\n+        hir::ExprIf(ref cond, ref then, ref otherwise) => {\n+            ExprKind::If {\n+                condition: cond.to_ref(),\n+                then: block::to_expr_ref(cx, then),\n+                otherwise: otherwise.to_ref(),\n+            }\n+        }\n+        hir::ExprWhile(ref cond, ref body, _) => {\n+            ExprKind::Loop {\n+                condition: Some(cond.to_ref()),\n+                body: block::to_expr_ref(cx, body),\n+            }\n+        }\n+        hir::ExprLoop(ref body, _, _) => {\n+            ExprKind::Loop {\n+                condition: None,\n+                body: block::to_expr_ref(cx, body),\n+            }\n+        }\n         hir::ExprField(ref source, name) => {\n             let index = match cx.tcx.tables().expr_ty_adjusted(source).sty {\n-                ty::TyAdt(adt_def, _) =>\n-                    adt_def.variants[0].index_of_field_named(name.node),\n-                ref ty =>\n-                    span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n+                ty::TyAdt(adt_def, _) => adt_def.variants[0].index_of_field_named(name.node),\n+                ref ty => span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n             };\n-            let index = index.unwrap_or_else(|| {\n-                span_bug!(\n-                    expr.span,\n-                    \"no index found for field `{}`\",\n-                    name.node)\n-            });\n-            ExprKind::Field { lhs: source.to_ref(), name: Field::new(index) }\n+            let index =\n+                index.unwrap_or_else(|| {\n+                    span_bug!(expr.span, \"no index found for field `{}`\", name.node)\n+                });\n+            ExprKind::Field {\n+                lhs: source.to_ref(),\n+                name: Field::new(index),\n+            }\n+        }\n+        hir::ExprTupField(ref source, index) => {\n+            ExprKind::Field {\n+                lhs: source.to_ref(),\n+                name: Field::new(index.node as usize),\n+            }\n         }\n-        hir::ExprTupField(ref source, index) =>\n-            ExprKind::Field { lhs: source.to_ref(),\n-                              name: Field::new(index.node as usize) },\n         hir::ExprCast(ref source, _) => {\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n@@ -616,17 +655,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ExprKind::Cast { source: source.to_ref() }\n             }\n         }\n-        hir::ExprType(ref source, _) =>\n-            return source.make_mirror(cx),\n-        hir::ExprBox(ref value) =>\n+        hir::ExprType(ref source, _) => return source.make_mirror(cx),\n+        hir::ExprBox(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),\n-                value_extents: cx.tcx.region_maps.node_extent(value.id)\n-            },\n-        hir::ExprArray(ref fields) =>\n-            ExprKind::Vec { fields: fields.to_ref() },\n-        hir::ExprTup(ref fields) =>\n-            ExprKind::Tuple { fields: fields.to_ref() },\n+                value_extents: cx.tcx.region_maps.node_extent(value.id),\n+            }\n+        }\n+        hir::ExprArray(ref fields) => ExprKind::Vec { fields: fields.to_ref() },\n+        hir::ExprTup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n     };\n \n     Expr {\n@@ -663,8 +700,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                               arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n         patterns: arm.pats.iter().map(|p| Pattern::from_hir(cx.tcx, p)).collect(),\n         guard: arm.guard.to_ref(),\n@@ -676,41 +712,48 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tcx.tables().node_id_item_substs(expr.id)\n+    let substs = cx.tcx\n+        .tables()\n+        .node_id_item_substs(expr.id)\n         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n     let def_id = match def {\n         // A regular function, constructor function or a constant.\n-        Def::Fn(def_id) | Def::Method(def_id) |\n+        Def::Fn(def_id) |\n+        Def::Method(def_id) |\n         Def::StructCtor(def_id, CtorKind::Fn) |\n         Def::VariantCtor(def_id, CtorKind::Fn) |\n-        Def::Const(def_id) | Def::AssociatedConst(def_id) => def_id,\n+        Def::Const(def_id) |\n+        Def::AssociatedConst(def_id) => def_id,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n             match cx.tcx.tables().node_id_to_type(expr.id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n-                ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n-                    adt_def: adt_def,\n-                    variant_index: adt_def.variant_index_with_id(def_id),\n-                    substs: substs,\n-                    fields: vec![],\n-                    base: None,\n-                },\n-                ref sty => bug!(\"unexpected sty: {:?}\", sty)\n+                ty::TyAdt(adt_def, substs) => {\n+                    return ExprKind::Adt {\n+                        adt_def: adt_def,\n+                        variant_index: adt_def.variant_index_with_id(def_id),\n+                        substs: substs,\n+                        fields: vec![],\n+                        base: None,\n+                    }\n+                }\n+                ref sty => bug!(\"unexpected sty: {:?}\", sty),\n             }\n         }\n \n-        Def::Static(node_id, _) => return ExprKind::StaticRef {\n-            id: node_id,\n-        },\n+        Def::Static(node_id, _) => return ExprKind::StaticRef { id: node_id },\n \n         Def::Local(..) | Def::Upvar(..) => return convert_var(cx, expr, def),\n \n         _ => span_bug!(expr.span, \"def `{:?}` not yet implemented\", def),\n     };\n     ExprKind::Literal {\n-        literal: Literal::Item { def_id: def_id, substs: substs }\n+        literal: Literal::Item {\n+            def_id: def_id,\n+            substs: substs,\n+        },\n     }\n }\n \n@@ -723,14 +766,15 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     match def {\n         Def::Local(def_id) => {\n             let node_id = cx.tcx.map.as_local_node_id(def_id).unwrap();\n-            ExprKind::VarRef {\n-                id: node_id,\n-            }\n+            ExprKind::VarRef { id: node_id }\n         }\n \n         Def::Upvar(def_id, index, closure_expr_id) => {\n             let id_var = cx.tcx.map.as_local_node_id(def_id).unwrap();\n-            debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\", id_var, index, closure_expr_id);\n+            debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\",\n+                   id_var,\n+                   index,\n+                   closure_expr_id);\n             let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n \n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n@@ -761,41 +805,45 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n             let self_expr = match cx.tcx.closure_kind(cx.tcx.map.local_def_id(closure_expr_id)) {\n                 ty::ClosureKind::Fn => {\n-                    let ref_closure_ty =\n-                        cx.tcx.mk_ref(region,\n-                                   ty::TypeAndMut { ty: closure_ty,\n-                                                    mutbl: hir::MutImmutable });\n+                    let ref_closure_ty = cx.tcx.mk_ref(region,\n+                                                       ty::TypeAndMut {\n+                                                           ty: closure_ty,\n+                                                           mutbl: hir::MutImmutable,\n+                                                       });\n                     Expr {\n                         ty: closure_ty,\n                         temp_lifetime: temp_lifetime,\n                         span: expr.span,\n                         kind: ExprKind::Deref {\n                             arg: Expr {\n-                                ty: ref_closure_ty,\n-                                temp_lifetime: temp_lifetime,\n-                                span: expr.span,\n-                                kind: ExprKind::SelfRef\n-                            }.to_ref()\n-                        }\n+                                    ty: ref_closure_ty,\n+                                    temp_lifetime: temp_lifetime,\n+                                    span: expr.span,\n+                                    kind: ExprKind::SelfRef,\n+                                }\n+                                .to_ref(),\n+                        },\n                     }\n                 }\n                 ty::ClosureKind::FnMut => {\n-                    let ref_closure_ty =\n-                        cx.tcx.mk_ref(region,\n-                                   ty::TypeAndMut { ty: closure_ty,\n-                                                    mutbl: hir::MutMutable });\n+                    let ref_closure_ty = cx.tcx.mk_ref(region,\n+                                                       ty::TypeAndMut {\n+                                                           ty: closure_ty,\n+                                                           mutbl: hir::MutMutable,\n+                                                       });\n                     Expr {\n                         ty: closure_ty,\n                         temp_lifetime: temp_lifetime,\n                         span: expr.span,\n                         kind: ExprKind::Deref {\n                             arg: Expr {\n-                                ty: ref_closure_ty,\n-                                temp_lifetime: temp_lifetime,\n-                                span: expr.span,\n-                                kind: ExprKind::SelfRef\n-                            }.to_ref()\n-                        }\n+                                    ty: ref_closure_ty,\n+                                    temp_lifetime: temp_lifetime,\n+                                    span: expr.span,\n+                                    kind: ExprKind::SelfRef,\n+                                }\n+                                .to_ref(),\n+                        },\n                     }\n                 }\n                 ty::ClosureKind::FnOnce => {\n@@ -823,26 +871,24 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let upvar_capture = match cx.tcx.tables().upvar_capture(upvar_id) {\n                 Some(c) => c,\n                 None => {\n-                    span_bug!(\n-                        expr.span,\n-                        \"no upvar_capture for {:?}\",\n-                        upvar_id);\n+                    span_bug!(expr.span, \"no upvar_capture for {:?}\", upvar_id);\n                 }\n             };\n             match upvar_capture {\n                 ty::UpvarCapture::ByValue => field_kind,\n                 ty::UpvarCapture::ByRef(borrow) => {\n                     ExprKind::Deref {\n                         arg: Expr {\n-                            temp_lifetime: temp_lifetime,\n-                            ty: cx.tcx.mk_ref(borrow.region,\n-                                ty::TypeAndMut {\n-                                    ty: var_ty,\n-                                    mutbl: borrow.kind.to_mutbl_lossy()\n-                                }),\n-                            span: expr.span,\n-                            kind: field_kind,\n-                        }.to_ref()\n+                                temp_lifetime: temp_lifetime,\n+                                ty: cx.tcx.mk_ref(borrow.region,\n+                                                  ty::TypeAndMut {\n+                                                      ty: var_ty,\n+                                                      mutbl: borrow.kind.to_mutbl_lossy(),\n+                                                  }),\n+                                span: expr.span,\n+                                kind: field_kind,\n+                            }\n+                            .to_ref(),\n                     }\n                 }\n             }\n@@ -894,30 +940,31 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // the arguments, unfortunately, do not, so if this is a ByRef\n     // operator, we have to gin up the autorefs (but by value is easy)\n     match pass_args {\n-        PassArgs::ByValue => {\n-            argrefs.extend(args.iter().map(|arg| arg.to_ref()))\n-        }\n+        PassArgs::ByValue => argrefs.extend(args.iter().map(|arg| arg.to_ref())),\n \n         PassArgs::ByRef => {\n             let region = cx.tcx.node_scope_region(expr.id);\n             let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n-            argrefs.extend(\n-                args.iter()\n-                    .map(|arg| {\n-                        let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n-                        let adjusted_ty =\n-                            cx.tcx.mk_ref(region,\n-                                       ty::TypeAndMut { ty: arg_ty,\n-                                                        mutbl: hir::MutImmutable });\n-                        Expr {\n+            argrefs.extend(args.iter()\n+                .map(|arg| {\n+                    let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n+                    let adjusted_ty = cx.tcx.mk_ref(region,\n+                                                    ty::TypeAndMut {\n+                                                        ty: arg_ty,\n+                                                        mutbl: hir::MutImmutable,\n+                                                    });\n+                    Expr {\n                             temp_lifetime: temp_lifetime,\n                             ty: adjusted_ty,\n                             span: expr.span,\n-                            kind: ExprKind::Borrow { region: region,\n-                                                     borrow_kind: BorrowKind::Shared,\n-                                                     arg: arg.to_ref() }\n-                        }.to_ref()\n-                    }))\n+                            kind: ExprKind::Borrow {\n+                                region: region,\n+                                borrow_kind: BorrowKind::Shared,\n+                                arg: arg.to_ref(),\n+                            },\n+                        }\n+                        .to_ref()\n+                }))\n         }\n     }\n \n@@ -981,36 +1028,38 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         kind: convert_var(cx, closure_expr, freevar.def),\n     };\n     match upvar_capture {\n-        ty::UpvarCapture::ByValue => {\n-            captured_var.to_ref()\n-        }\n+        ty::UpvarCapture::ByValue => captured_var.to_ref(),\n         ty::UpvarCapture::ByRef(upvar_borrow) => {\n             let borrow_kind = match upvar_borrow.kind {\n                 ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n                 ty::BorrowKind::UniqueImmBorrow => BorrowKind::Unique,\n                 ty::BorrowKind::MutBorrow => BorrowKind::Mut,\n             };\n             Expr {\n-                temp_lifetime: temp_lifetime,\n-                ty: freevar_ty,\n-                span: closure_expr.span,\n-                kind: ExprKind::Borrow { region: upvar_borrow.region,\n-                                         borrow_kind: borrow_kind,\n-                                         arg: captured_var.to_ref() }\n-            }.to_ref()\n+                    temp_lifetime: temp_lifetime,\n+                    ty: freevar_ty,\n+                    span: closure_expr.span,\n+                    kind: ExprKind::Borrow {\n+                        region: upvar_borrow.region,\n+                        borrow_kind: borrow_kind,\n+                        arg: captured_var.to_ref(),\n+                    },\n+                }\n+                .to_ref()\n         }\n     }\n }\n \n /// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n fn field_refs<'tcx>(variant: &'tcx VariantDef,\n                     fields: &'tcx [hir::Field])\n-                    -> Vec<FieldExprRef<'tcx>>\n-{\n+                    -> Vec<FieldExprRef<'tcx>> {\n     fields.iter()\n-          .map(|field| FieldExprRef {\n-              name: Field::new(variant.index_of_field_named(field.name.node).unwrap()),\n-              expr: field.expr.to_ref(),\n-          })\n-          .collect()\n+        .map(|field| {\n+            FieldExprRef {\n+                name: Field::new(variant.index_of_field_named(field.name.node).unwrap()),\n+                expr: field.expr.to_ref(),\n+            }\n+        })\n+        .collect()\n }"}, {"sha": "7d111fccd0056c5801671605153d863ed33918d7", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/dc1a094b40e73af21a267378f1fa6c880b097d61/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1a094b40e73af21a267378f1fa6c880b097d61/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=dc1a094b40e73af21a267378f1fa6c880b097d61", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * This module contains the code to convert from the wacky tcx data\n- * structures into the hair. The `builder` is generally ignorant of\n- * the tcx etc, and instead goes through the `Cx` for most of its\n- * work.\n- */\n+//! This module contains the code to convert from the wacky tcx data\n+//! structures into the hair. The `builder` is generally ignorant of\n+//! the tcx etc, and instead goes through the `Cx` for most of its\n+//! work.\n+//!\n \n use hair::*;\n use rustc::mir::transform::MirSource;\n@@ -32,27 +31,25 @@ use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n \n #[derive(Copy, Clone)]\n-pub struct Cx<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     constness: hir::Constness,\n \n     /// True if this constant/function needs overflow checks.\n-    check_overflow: bool\n+    check_overflow: bool,\n }\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               src: MirSource)\n-               -> Cx<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, src: MirSource) -> Cx<'a, 'gcx, 'tcx> {\n         let constness = match src {\n             MirSource::Const(_) |\n             MirSource::Static(..) => hir::Constness::Const,\n             MirSource::Fn(id) => {\n                 let fn_like = FnLikeNode::from_node(infcx.tcx.map.get(id));\n                 fn_like.map_or(hir::Constness::NotConst, |f| f.constness())\n             }\n-            MirSource::Promoted(..) => bug!()\n+            MirSource::Promoted(..) => bug!(),\n         };\n \n         let src_node_id = src.item_id();\n@@ -70,13 +67,16 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are translated in.\n-        let mut check_overflow = attrs.iter().any(|item| {\n-            item.check_name(\"rustc_inherit_overflow_checks\")\n-        });\n+        let mut check_overflow = attrs.iter()\n+            .any(|item| item.check_name(\"rustc_inherit_overflow_checks\"));\n \n         // Respect -Z force-overflow-checks=on and -C debug-assertions.\n-        check_overflow |= infcx.tcx.sess.opts.debugging_opts.force_overflow_checks\n-               .unwrap_or(infcx.tcx.sess.opts.debug_assertions);\n+        check_overflow |= infcx.tcx\n+            .sess\n+            .opts\n+            .debugging_opts\n+            .force_overflow_checks\n+            .unwrap_or(infcx.tcx.sess.opts.debug_assertions);\n \n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n@@ -85,7 +85,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             tcx: infcx.tcx,\n             infcx: infcx,\n             constness: constness,\n-            check_overflow: check_overflow\n+            check_overflow: check_overflow,\n         }\n     }\n }\n@@ -102,7 +102,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n         match ConstUsize::new(value, self.tcx.sess.target.uint_type) {\n-            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val))},\n+            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val)) },\n             Err(_) => bug!(\"usize literal out of range for target\"),\n         }\n     }\n@@ -128,9 +128,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n-        Literal::Value {\n-            value: const_eval::eval_const_expr(self.tcx.global_tcx(), e)\n-        }\n+        Literal::Value { value: const_eval::eval_const_expr(self.tcx.global_tcx(), e) }\n     }\n \n     pub fn trait_method(&mut self,\n@@ -145,10 +143,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n                 let method_ty = self.tcx.item_type(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n-                return (method_ty, Literal::Item {\n-                    def_id: item.def_id,\n-                    substs: substs,\n-                });\n+                return (method_ty,\n+                        Literal::Item {\n+                            def_id: item.def_id,\n+                            substs: substs,\n+                        });\n             }\n         }\n \n@@ -168,7 +167,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty = self.tcx.lift_to_global(&ty).unwrap_or_else(|| {\n             bug!(\"MIR: Cx::needs_drop({}) got \\\n-                  type with inference types/regions\", ty);\n+                  type with inference types/regions\",\n+                 ty);\n         });\n         self.tcx.type_needs_drop_given_env(ty, &self.infcx.parameter_environment)\n     }"}, {"sha": "6930a959d6515ce2365e26e1a47574e15794b857", "filename": "src/librustc_mir/hair/cx/to_ref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dc1a094b40e73af21a267378f1fa6c880b097d61/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc1a094b40e73af21a267378f1fa6c880b097d61/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs?ref=dc1a094b40e73af21a267378f1fa6c880b097d61", "patch": "@@ -18,32 +18,32 @@ pub trait ToRef {\n     fn to_ref(self) -> Self::Output;\n }\n \n-impl<'a,'tcx:'a> ToRef for &'tcx hir::Expr {\n+impl<'a, 'tcx: 'a> ToRef for &'tcx hir::Expr {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(self)\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef for &'tcx P<hir::Expr> {\n+impl<'a, 'tcx: 'a> ToRef for &'tcx P<hir::Expr> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(&**self)\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef for Expr<'tcx> {\n+impl<'a, 'tcx: 'a> ToRef for Expr<'tcx> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Mirror(Box::new(self))\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef for &'tcx Option<T>\n-    where &'tcx T: ToRef<Output=U>\n+impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx Option<T>\n+    where &'tcx T: ToRef<Output = U>\n {\n     type Output = Option<U>;\n \n@@ -52,8 +52,8 @@ impl<'a,'tcx:'a,T,U> ToRef for &'tcx Option<T>\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef for &'tcx Vec<T>\n-    where &'tcx T: ToRef<Output=U>\n+impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx Vec<T>\n+    where &'tcx T: ToRef<Output = U>\n {\n     type Output = Vec<U>;\n \n@@ -62,8 +62,8 @@ impl<'a,'tcx:'a,T,U> ToRef for &'tcx Vec<T>\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef for &'tcx P<[T]>\n-    where &'tcx T: ToRef<Output=U>\n+impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx P<[T]>\n+    where &'tcx T: ToRef<Output = U>\n {\n     type Output = Vec<U>;\n "}]}