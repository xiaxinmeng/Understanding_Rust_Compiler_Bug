{"sha": "027a99fc700e9e0c49ee4cebffb8f9f635955e4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyN2E5OWZjNzAwZTllMGM0OWVlNGNlYmZmYjhmOWY2MzU5NTVlNGE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-03T15:39:49Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-03T15:39:49Z"}, "message": "Do no tear comments apart in extract_function assist", "tree": {"sha": "16a53dc8b5009027b1e2b97725d909bf8b3f7f5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16a53dc8b5009027b1e2b97725d909bf8b3f7f5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/027a99fc700e9e0c49ee4cebffb8f9f635955e4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/027a99fc700e9e0c49ee4cebffb8f9f635955e4a", "html_url": "https://github.com/rust-lang/rust/commit/027a99fc700e9e0c49ee4cebffb8f9f635955e4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/027a99fc700e9e0c49ee4cebffb8f9f635955e4a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b96f1adf5cbfaaa0e0538bae63b20caa09484635", "url": "https://api.github.com/repos/rust-lang/rust/commits/b96f1adf5cbfaaa0e0538bae63b20caa09484635", "html_url": "https://github.com/rust-lang/rust/commit/b96f1adf5cbfaaa0e0538bae63b20caa09484635"}], "stats": {"total": 69, "additions": 50, "deletions": 19}, "files": [{"sha": "523e0f7f7d708fc484e73a72e431bfcd0582ad90", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 50, "deletions": 19, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/027a99fc700e9e0c49ee4cebffb8f9f635955e4a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027a99fc700e9e0c49ee4cebffb8f9f635955e4a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=027a99fc700e9e0c49ee4cebffb8f9f635955e4a", "patch": "@@ -8,6 +8,7 @@ use ide_db::{\n     search::{FileReference, ReferenceAccess, SearchScope},\n     RootDatabase,\n };\n+use itertools::Itertools;\n use rustc_hash::FxHasher;\n use stdx::format_to;\n use syntax::{\n@@ -389,8 +390,23 @@ impl FunctionBody {\n         }\n     }\n \n-    fn from_range(parent: ast::BlockExpr, text_range: TextRange) -> FunctionBody {\n-        Self::Span { parent, text_range }\n+    fn from_range(parent: ast::BlockExpr, selected: TextRange) -> FunctionBody {\n+        let mut text_range = parent\n+            .statements()\n+            .map(|stmt| stmt.syntax().text_range())\n+            .filter(|&stmt| selected.intersect(stmt).filter(|it| !it.is_empty()).is_some())\n+            .fold1(|acc, stmt| acc.cover(stmt));\n+        if let Some(tail_range) = parent\n+            .tail_expr()\n+            .map(|it| it.syntax().text_range())\n+            .filter(|&it| selected.intersect(it).is_some())\n+        {\n+            text_range = Some(match text_range {\n+                Some(text_range) => text_range.cover(tail_range),\n+                None => tail_range,\n+            });\n+        }\n+        Self::Span { parent, text_range: text_range.unwrap_or(selected) }\n     }\n \n     fn indent_level(&self) -> IndentLevel {\n@@ -546,17 +562,7 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n     // Covering element returned the parent block of one or multiple statements that have been selected\n     if let ast::Expr::BlockExpr(block) = expr {\n         // Extract the full statements.\n-        let mut statements_range = block\n-            .statements()\n-            .filter(|stmt| selection_range.intersect(stmt.syntax().text_range()).is_some())\n-            .fold(selection_range, |acc, stmt| acc.cover(stmt.syntax().text_range()));\n-        if let Some(e) = block\n-            .tail_expr()\n-            .filter(|it| selection_range.intersect(it.syntax().text_range()).is_some())\n-        {\n-            statements_range = statements_range.cover(e.syntax().text_range());\n-        }\n-        return Some(FunctionBody::from_range(block, statements_range));\n+        return Some(FunctionBody::from_range(block, selection_range));\n     }\n \n     node.ancestors().find_map(ast::Expr::cast).and_then(FunctionBody::from_expr)\n@@ -586,7 +592,6 @@ fn analyze_body(\n                 | NameRefClass::FieldShorthand { local_ref, field_ref: _ },\n             ) = NameRefClass::classify(sema, &name_ref)\n             {\n-                res.insert(local_ref);\n                 if local_ref.is_self(sema.db) {\n                     match local_ref.source(sema.db).value {\n                         Either::Right(it) => {\n@@ -599,6 +604,8 @@ fn analyze_body(\n                             stdx::never!(\"Local::is_self returned true, but source is IdentPat\");\n                         }\n                     }\n+                } else {\n+                    res.insert(local_ref);\n                 }\n             }\n         }\n@@ -615,7 +622,6 @@ fn extracted_function_params(\n     locals: impl Iterator<Item = Local>,\n ) -> Vec<Param> {\n     locals\n-        .filter(|local| !local.is_self(ctx.db()))\n         .map(|local| (local, local.source(ctx.db())))\n         .filter(|(_, src)| is_defined_outside_of_body(ctx, body, src))\n         .filter_map(|(local, src)| {\n@@ -3230,8 +3236,7 @@ fn $0fun_name(n: i32) -> bool {\n             r#\"\n fn foo() {\n     loop {\n-        let n = 1;\n-        $0\n+        let n = 1;$0\n         let k = 1;\n         loop {\n             return;\n@@ -3435,8 +3440,7 @@ fn $0fun_name() -> Option<i32> {\n             r#\"\n fn foo() -> i64 {\n     loop {\n-        let n = 1;\n-        $0\n+        let n = 1;$0\n         let k = 1;\n         if k == 42 {\n             break 3;\n@@ -3830,6 +3834,33 @@ fn main() {\n fn $0fun_name() -> i32 {\n     100\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_does_not_tear_comments_apart() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    /*$0*/\n+    foo();\n+    foo();\n+    /*$0*/\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    /**/\n+    fun_name();\n+    /**/\n+}\n+\n+fn $0fun_name() {\n+    foo();\n+    foo();\n+}\n \"#,\n         );\n     }"}]}