{"sha": "cefb2204cb109529fd9d138d9b21dddd8c30ff3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZmIyMjA0Y2IxMDk1MjlmZDlkMTM4ZDliMjFkZGRkOGMzMGZmM2Q=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-24T15:45:38Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-24T15:45:38Z"}, "message": "Make `iterate_method_candidates` non-generic", "tree": {"sha": "66734c1823cf3380308ff7a3e657f8353a29a375", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66734c1823cf3380308ff7a3e657f8353a29a375"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cefb2204cb109529fd9d138d9b21dddd8c30ff3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cefb2204cb109529fd9d138d9b21dddd8c30ff3d", "html_url": "https://github.com/rust-lang/rust/commit/cefb2204cb109529fd9d138d9b21dddd8c30ff3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cefb2204cb109529fd9d138d9b21dddd8c30ff3d/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "html_url": "https://github.com/rust-lang/rust/commit/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9"}], "stats": {"total": 129, "additions": 73, "deletions": 56}, "files": [{"sha": "8b59a8bd6e2bf3291ef40e7de729cf0212607c39", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 73, "deletions": 56, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/cefb2204cb109529fd9d138d9b21dddd8c30ff3d/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cefb2204cb109529fd9d138d9b21dddd8c30ff3d/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=cefb2204cb109529fd9d138d9b21dddd8c30ff3d", "patch": "@@ -271,6 +271,33 @@ pub fn iterate_method_candidates<T>(\n     mode: LookupMode,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n+    let mut slot = None;\n+    iterate_method_candidates_impl(\n+        ty,\n+        db,\n+        env,\n+        krate,\n+        traits_in_scope,\n+        name,\n+        mode,\n+        &mut |ty, item| {\n+            slot = callback(ty, item);\n+            slot.is_some()\n+        },\n+    );\n+    slot\n+}\n+\n+pub fn iterate_method_candidates_impl(\n+    ty: &Canonical<Ty>,\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    krate: CrateId,\n+    traits_in_scope: &FxHashSet<TraitId>,\n+    name: Option<&Name>,\n+    mode: LookupMode,\n+    callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+) -> bool {\n     match mode {\n         LookupMode::MethodCall => {\n             // For method calls, rust first does any number of autoderef, and then one\n@@ -298,19 +325,19 @@ pub fn iterate_method_candidates<T>(\n \n             let deref_chain = autoderef_method_receiver(db, krate, ty);\n             for i in 0..deref_chain.len() {\n-                if let Some(result) = iterate_method_candidates_with_autoref(\n+                if iterate_method_candidates_with_autoref(\n                     &deref_chain[i..],\n                     db,\n                     env.clone(),\n                     krate,\n                     traits_in_scope,\n                     name,\n-                    &mut callback,\n+                    callback,\n                 ) {\n-                    return Some(result);\n+                    return true;\n                 }\n             }\n-            None\n+            false\n         }\n         LookupMode::Path => {\n             // No autoderef for path lookups\n@@ -321,22 +348,22 @@ pub fn iterate_method_candidates<T>(\n                 krate,\n                 traits_in_scope,\n                 name,\n-                &mut callback,\n+                callback,\n             )\n         }\n     }\n }\n \n-fn iterate_method_candidates_with_autoref<T>(\n+fn iterate_method_candidates_with_autoref(\n     deref_chain: &[Canonical<Ty>],\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n-    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n-) -> Option<T> {\n-    if let Some(result) = iterate_method_candidates_by_receiver(\n+    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+) -> bool {\n+    if iterate_method_candidates_by_receiver(\n         &deref_chain[0],\n         &deref_chain[1..],\n         db,\n@@ -346,13 +373,13 @@ fn iterate_method_candidates_with_autoref<T>(\n         name,\n         &mut callback,\n     ) {\n-        return Some(result);\n+        return true;\n     }\n     let refed = Canonical {\n         num_vars: deref_chain[0].num_vars,\n         value: Ty::apply_one(TypeCtor::Ref(Mutability::Shared), deref_chain[0].value.clone()),\n     };\n-    if let Some(result) = iterate_method_candidates_by_receiver(\n+    if iterate_method_candidates_by_receiver(\n         &refed,\n         deref_chain,\n         db,\n@@ -362,13 +389,13 @@ fn iterate_method_candidates_with_autoref<T>(\n         name,\n         &mut callback,\n     ) {\n-        return Some(result);\n+        return true;\n     }\n     let ref_muted = Canonical {\n         num_vars: deref_chain[0].num_vars,\n         value: Ty::apply_one(TypeCtor::Ref(Mutability::Mut), deref_chain[0].value.clone()),\n     };\n-    if let Some(result) = iterate_method_candidates_by_receiver(\n+    if iterate_method_candidates_by_receiver(\n         &ref_muted,\n         deref_chain,\n         db,\n@@ -378,33 +405,31 @@ fn iterate_method_candidates_with_autoref<T>(\n         name,\n         &mut callback,\n     ) {\n-        return Some(result);\n+        return true;\n     }\n-    None\n+    false\n }\n \n-fn iterate_method_candidates_by_receiver<T>(\n+fn iterate_method_candidates_by_receiver(\n     receiver_ty: &Canonical<Ty>,\n     rest_of_deref_chain: &[Canonical<Ty>],\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n-    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n-) -> Option<T> {\n+    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+) -> bool {\n     // We're looking for methods with *receiver* type receiver_ty. These could\n     // be found in any of the derefs of receiver_ty, so we have to go through\n     // that.\n     for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n-        if let Some(result) =\n-            iterate_inherent_methods(self_ty, db, name, Some(receiver_ty), krate, &mut callback)\n-        {\n-            return Some(result);\n+        if iterate_inherent_methods(self_ty, db, name, Some(receiver_ty), krate, &mut callback) {\n+            return true;\n         }\n     }\n     for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n-        if let Some(result) = iterate_trait_method_candidates(\n+        if iterate_trait_method_candidates(\n             self_ty,\n             db,\n             env.clone(),\n@@ -414,49 +439,37 @@ fn iterate_method_candidates_by_receiver<T>(\n             Some(receiver_ty),\n             &mut callback,\n         ) {\n-            return Some(result);\n+            return true;\n         }\n     }\n-    None\n+    false\n }\n \n-fn iterate_method_candidates_for_self_ty<T>(\n+fn iterate_method_candidates_for_self_ty(\n     self_ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n-    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n-) -> Option<T> {\n-    if let Some(result) = iterate_inherent_methods(self_ty, db, name, None, krate, &mut callback) {\n-        return Some(result);\n-    }\n-    if let Some(result) = iterate_trait_method_candidates(\n-        self_ty,\n-        db,\n-        env,\n-        krate,\n-        traits_in_scope,\n-        name,\n-        None,\n-        &mut callback,\n-    ) {\n-        return Some(result);\n+    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+) -> bool {\n+    if iterate_inherent_methods(self_ty, db, name, None, krate, &mut callback) {\n+        return true;\n     }\n-    None\n+    iterate_trait_method_candidates(self_ty, db, env, krate, traits_in_scope, name, None, callback)\n }\n \n-fn iterate_trait_method_candidates<T>(\n+fn iterate_trait_method_candidates(\n     self_ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n-    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n-) -> Option<T> {\n+    callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+) -> bool {\n     // if ty is `dyn Trait`, the trait doesn't need to be in scope\n     let inherent_trait =\n         self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n@@ -489,23 +502,27 @@ fn iterate_trait_method_candidates<T>(\n                 }\n             }\n             known_implemented = true;\n-            if let Some(result) = callback(&self_ty.value, *item) {\n-                return Some(result);\n+            if callback(&self_ty.value, *item) {\n+                return true;\n             }\n         }\n     }\n-    None\n+    false\n }\n \n-fn iterate_inherent_methods<T>(\n+fn iterate_inherent_methods(\n     self_ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n     krate: CrateId,\n-    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n-) -> Option<T> {\n-    for krate in self_ty.value.def_crates(db, krate)? {\n+    callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+) -> bool {\n+    let def_crates = match self_ty.value.def_crates(db, krate) {\n+        Some(k) => k,\n+        None => return false,\n+    };\n+    for krate in def_crates {\n         let impls = db.impls_in_crate(krate);\n \n         for impl_def in impls.lookup_impl_defs(&self_ty.value) {\n@@ -521,13 +538,13 @@ fn iterate_inherent_methods<T>(\n                     test_utils::mark::hit!(impl_self_type_match_without_receiver);\n                     continue;\n                 }\n-                if let Some(result) = callback(&self_ty.value, item) {\n-                    return Some(result);\n+                if callback(&self_ty.value, item) {\n+                    return true;\n                 }\n             }\n         }\n     }\n-    None\n+    false\n }\n \n /// Returns the self type for the index trait call."}]}