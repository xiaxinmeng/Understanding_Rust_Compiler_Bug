{"sha": "38bd207626fa46445d58404099b0a2f0bf8e0934", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4YmQyMDc2MjZmYTQ2NDQ1ZDU4NDA0MDk5YjBhMmYwYmY4ZTA5MzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-31T18:54:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-31T18:54:31Z"}, "message": "Auto merge of #38482 - est31:i128, r=eddyb\n\ni128 and u128 support\n\nBrings i128 and u128 support to nightly rust, behind a feature flag. The goal of this PR is to do the bulk of the work for 128 bit integer support. Smaller but just as tricky features needed for stabilisation like 128 bit enum discriminants are left for future PRs.\n\nRebased version of  #37900, which in turn was a rebase + improvement of #35954 . Sadly I couldn't reopen #37900 due to github. There goes my premium position in the homu queue...\n\n[plugin-breaking-change]\n\ncc #35118 (tracking issue)", "tree": {"sha": "0763e040e47b547921f654e31894f7a67145df6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0763e040e47b547921f654e31894f7a67145df6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38bd207626fa46445d58404099b0a2f0bf8e0934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38bd207626fa46445d58404099b0a2f0bf8e0934", "html_url": "https://github.com/rust-lang/rust/commit/38bd207626fa46445d58404099b0a2f0bf8e0934", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38bd207626fa46445d58404099b0a2f0bf8e0934/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6185c5445210966cfd1acb011b4faf4b4eaf9d97", "url": "https://api.github.com/repos/rust-lang/rust/commits/6185c5445210966cfd1acb011b4faf4b4eaf9d97", "html_url": "https://github.com/rust-lang/rust/commit/6185c5445210966cfd1acb011b4faf4b4eaf9d97"}, {"sha": "29e01af6a68817a12c1fc5fa04c483d2200c3cbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e01af6a68817a12c1fc5fa04c483d2200c3cbb", "html_url": "https://github.com/rust-lang/rust/commit/29e01af6a68817a12c1fc5fa04c483d2200c3cbb"}], "stats": {"total": 2717, "additions": 2232, "deletions": 485}, "files": [{"sha": "9624a51dda01b3a0fd2f88858dc1755c4f73f38a", "filename": "mk/crates.mk", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -54,7 +54,7 @@ TARGET_CRATES := libc std term \\\n                  compiler_builtins core alloc \\\n                  std_unicode rustc_bitflags \\\n \t\t alloc_system alloc_jemalloc \\\n-\t\t panic_abort panic_unwind unwind\n+\t\t panic_abort panic_unwind unwind rustc_i128\n RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures rustc_platform_intrinsics rustc_errors \\\n@@ -92,23 +92,26 @@ DEPS_getopts := std\n DEPS_graphviz := std\n DEPS_log := std\n DEPS_num := std\n-DEPS_serialize := std log\n+DEPS_serialize := std log rustc_i128\n DEPS_term := std\n DEPS_test := std getopts term native:rust_test_helpers\n+DEPS_rustc_i128 = std\n \n-DEPS_syntax := std term serialize log arena libc rustc_bitflags std_unicode rustc_errors syntax_pos rustc_data_structures\n+DEPS_syntax := std term serialize log arena libc rustc_bitflags std_unicode rustc_errors \\\n+\t\t\tsyntax_pos rustc_data_structures rustc_i128\n DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros proc_macro\n+DEPS_proc_macro := syntax syntax_pos rustc_plugin log\n DEPS_syntax_pos := serialize\n DEPS_proc_macro_tokens := syntax syntax_pos log\n DEPS_proc_macro_plugin := syntax syntax_pos rustc_plugin log proc_macro_tokens\n \n-DEPS_rustc_const_math := std syntax log serialize\n+DEPS_rustc_const_math := std syntax log serialize rustc_i128\n DEPS_rustc_const_eval := rustc_const_math rustc syntax log serialize \\\n-\t\t\t     rustc_back graphviz syntax_pos\n+\t\t\t     rustc_back graphviz syntax_pos rustc_i128\n \n DEPS_rustc := syntax fmt_macros flate arena serialize getopts \\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\\\n-\t      rustc_const_math syntax_pos rustc_errors\n+\t      rustc_const_math syntax_pos rustc_errors rustc_i128\n DEPS_rustc_back := std syntax flate log libc\n DEPS_rustc_borrowck := rustc log graphviz syntax syntax_pos rustc_errors rustc_mir\n DEPS_rustc_data_structures := std log serialize libc\n@@ -119,19 +122,20 @@ DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_bo\n                      rustc_passes rustc_save_analysis rustc_const_eval \\\n                      rustc_incremental syntax_pos rustc_errors proc_macro rustc_data_structures\n DEPS_rustc_errors := log libc serialize syntax_pos\n-DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval\n+DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval rustc_i128\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_proc_macro := std syntax\n DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rustc_const_math \\\n-\t\t\tproc_macro syntax_ext\n+\t\t\tproc_macro syntax_ext rustc_i128\n DEPS_rustc_passes := syntax syntax_pos rustc core rustc_const_eval rustc_errors\n-DEPS_rustc_mir := rustc syntax syntax_pos rustc_const_math rustc_const_eval rustc_bitflags\n+DEPS_rustc_mir := rustc syntax syntax_pos rustc_const_math rustc_const_eval rustc_bitflags \\\n+\t\t\t\t\trustc_i128\n DEPS_rustc_resolve := arena rustc log syntax syntax_pos rustc_errors\n DEPS_rustc_platform_intrinsics := std\n DEPS_rustc_plugin := rustc rustc_metadata syntax syntax_pos rustc_errors\n DEPS_rustc_privacy := rustc log syntax syntax_pos\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n-                    log syntax serialize rustc_llvm rustc_platform_intrinsics \\\n+                    log syntax serialize rustc_llvm rustc_platform_intrinsics rustc_i128 \\\n                     rustc_const_math rustc_const_eval rustc_incremental rustc_errors syntax_pos\n DEPS_rustc_incremental := rustc syntax_pos serialize rustc_data_structures\n DEPS_rustc_save_analysis := rustc log syntax syntax_pos serialize\n@@ -159,6 +163,7 @@ ONLY_RLIB_alloc := 1\n ONLY_RLIB_rand := 1\n ONLY_RLIB_collections := 1\n ONLY_RLIB_std_unicode := 1\n+ONLY_RLIB_rustc_i128 := 1\n ONLY_RLIB_rustc_bitflags := 1\n ONLY_RLIB_alloc_system := 1\n ONLY_RLIB_alloc_jemalloc := 1"}, {"sha": "3da29933c812e7a4615ccea8b8300ea72d354d9c", "filename": "src/Cargo.lock", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -249,6 +249,7 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -308,6 +309,7 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -318,6 +320,7 @@ name = \"rustc_const_math\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n ]\n@@ -327,6 +330,7 @@ name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"serialize 0.0.0\",\n ]\n \n@@ -372,6 +376,10 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_i128\"\n+version = \"0.0.0\"\n+\n [[package]]\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n@@ -380,6 +388,7 @@ dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -393,6 +402,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -418,6 +428,7 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -437,6 +448,7 @@ dependencies = [\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -519,6 +531,7 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n@@ -574,6 +587,7 @@ name = \"serialize\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n ]\n \n [[package]]\n@@ -619,6 +633,7 @@ dependencies = [\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "1bc9b660001242f04769f22eb500dbe82b92cfb0", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 784, "deletions": 1, "changes": 785, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -16,4 +16,787 @@\n             issue = \"0\")]\n #![crate_name = \"compiler_builtins\"]\n #![crate_type = \"rlib\"]\n-#![feature(staged_api)]\n+#![allow(unused_features)]\n+#![feature(staged_api, core_intrinsics, repr_simd,\n+           i128_type, core_float, abi_unadjusted, associated_consts)]\n+#![allow(non_camel_case_types, unused_variables, unused_imports)]\n+#![cfg_attr(stage0, allow(dead_code))]\n+\n+#[cfg(any(target_pointer_width=\"32\", target_pointer_width=\"16\", target_os=\"windows\",\n+          target_arch=\"mips64\"))]\n+pub mod reimpls {\n+\n+    #![allow(unused_comparisons)]\n+\n+    use core::intrinsics::unchecked_div;\n+    use core::intrinsics::unchecked_rem;\n+    use core::ptr;\n+\n+    // C API is expected to tolerate some amount of size mismatch in ABI. Hopefully the amount of\n+    // handling is sufficient for bootstrapping.\n+    #[cfg(stage0)]\n+    type u128_ = u64;\n+    #[cfg(stage0)]\n+    type i128_ = i64;\n+    #[cfg(not(stage0))]\n+    type u128_ = u128;\n+    #[cfg(not(stage0))]\n+    type i128_ = i128;\n+\n+    macro_rules! ashl {\n+        ($a:expr, $b:expr, $ty:ty) => {{\n+            let (a, b) = ($a, $b);\n+            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n+            let half_bits = bits >> 1;\n+            if b & half_bits != 0 {\n+                <$ty>::from_parts(0, a.low().wrapping_shl(\n+                                        b.wrapping_sub(half_bits) as u32))\n+            } else if b == 0 {\n+                a\n+            } else {\n+                <$ty>::from_parts(a.low().wrapping_shl(b as u32),\n+                                  a.high().wrapping_shl(b as u32)\n+                                  | a.low()\n+                                     .wrapping_shr(half_bits.wrapping_sub(b) as u32))\n+            }\n+        }}\n+    }\n+\n+    #[export_name=\"__ashlti3\"]\n+    pub extern \"C\" fn shl(a: u128_, b: u128_) -> u128_ {\n+        ashl!(a, b, u128_)\n+    }\n+\n+    macro_rules! ashr {\n+        ($a: expr, $b: expr, $ty:ty) => {{\n+            let (a, b) = ($a, $b);\n+            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n+            let half_bits = bits >> 1;\n+            if b & half_bits != 0 {\n+                <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32)\n+                                  as <$ty as LargeInt>::LowHalf,\n+                                  a.high().wrapping_shr(half_bits.wrapping_sub(1) as u32))\n+            } else if b == 0 {\n+                a\n+            } else {\n+                let high_unsigned = a.high() as <$ty as LargeInt>::LowHalf;\n+                <$ty>::from_parts(high_unsigned.wrapping_shl(half_bits.wrapping_sub(b) as u32)\n+                                  | a.low().wrapping_shr(b as u32),\n+                                  a.high().wrapping_shr(b as u32))\n+            }\n+        }}\n+    }\n+\n+    #[export_name=\"__ashrti3\"]\n+    pub extern \"C\" fn shr(a: i128_, b: i128_) -> i128_ {\n+        ashr!(a, b, i128_)\n+    }\n+\n+    macro_rules! lshr {\n+        ($a: expr, $b: expr, $ty:ty) => {{\n+            let (a, b) = ($a, $b);\n+            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n+            let half_bits = bits >> 1;\n+            if b & half_bits != 0 {\n+                <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32), 0)\n+            } else if b == 0 {\n+                a\n+            } else {\n+                <$ty>::from_parts(a.high().wrapping_shl(half_bits.wrapping_sub(b) as u32)\n+                                  | a.low().wrapping_shr(b as u32),\n+                                  a.high().wrapping_shr(b as u32))\n+            }\n+        }}\n+    }\n+\n+\n+    #[export_name=\"__lshrti3\"]\n+    pub extern \"C\" fn lshr(a: u128_, b: u128_) -> u128_ {\n+        lshr!(a, b, u128_)\n+    }\n+\n+    #[cfg(stage0)]\n+    pub extern \"C\" fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128_ {\n+        unsafe {\n+        if !rem.is_null() {\n+            *rem = unchecked_rem(n, d);\n+        }\n+        unchecked_div(n, d)\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    pub extern \"C\" fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128_ {\n+        // Translated from Figure 3-40 of The PowerPC Compiler Writer's Guide\n+        unsafe {\n+        // special cases, X is unknown, K != 0\n+        if n.high() == 0 {\n+            if d.high() == 0 {\n+                // 0 X\n+                // ---\n+                // 0 X\n+                if !rem.is_null() {\n+                    *rem = u128::from(unchecked_rem(n.low(), d.low()));\n+                }\n+                return u128::from(unchecked_div(n.low(), d.low()));\n+            } else {\n+                // 0 X\n+                // ---\n+                // K X\n+                if !rem.is_null() {\n+                    *rem = n;\n+                }\n+                return 0;\n+            };\n+        }\n+\n+        let mut sr;\n+        let mut q;\n+        let mut r;\n+\n+        if d.low() == 0 {\n+            if d.high() == 0 {\n+                // K X\n+                // ---\n+                // 0 0\n+                if !rem.is_null() {\n+                    *rem = u128::from(unchecked_rem(n.high(), d.low()));\n+                }\n+                return u128::from(unchecked_div(n.high(), d.low()));\n+            }\n+\n+            if n.low() == 0 {\n+                // K 0\n+                // ---\n+                // K 0\n+                if !rem.is_null() {\n+                    *rem = u128::from_parts(0, unchecked_rem(n.high(), d.high()));\n+                }\n+                return u128::from(unchecked_div(n.high(), d.high()));\n+            }\n+\n+            // K K\n+            // ---\n+            // K 0\n+\n+            if d.high().is_power_of_two() {\n+                if !rem.is_null() {\n+                    *rem = u128::from_parts(n.low(),\n+                                            n.high() & (d.high().wrapping_sub(1)));\n+                }\n+                return u128::from(n.high().wrapping_shr(d.high().trailing_zeros()));\n+            }\n+\n+            // K K\n+            // ---\n+            // K 0\n+            sr = d.high().leading_zeros().wrapping_sub(n.high().leading_zeros());\n+\n+            // D > N\n+            if sr > 64 - 2 {\n+                if !rem.is_null() {\n+                    *rem = n;\n+                }\n+                return 0;\n+            }\n+\n+            sr = sr.wrapping_add(1);\n+\n+            // 1 <= sr <= u64::bits() - 1\n+            q = n.wrapping_shl(64u32.wrapping_sub(sr));\n+            r = n.wrapping_shr(sr);\n+        } else {\n+            if d.high() == 0 {\n+                // K X\n+                // ---\n+                // 0 K\n+                if d.low().is_power_of_two() {\n+                    if !rem.is_null() {\n+                        *rem = u128::from(n.low() & (d.low().wrapping_sub(1)));\n+                    }\n+\n+                    if d.low() == 1 {\n+                        return n;\n+                    } else {\n+                        let sr = d.low().trailing_zeros();\n+                        return n.wrapping_shr(sr);\n+                    };\n+                }\n+\n+                sr = (1 + 64u32)\n+                    .wrapping_add(d.low().leading_zeros())\n+                    .wrapping_sub(n.high().leading_zeros());\n+\n+                // 2 <= sr <= u64::bits() - 1\n+                q = n.wrapping_shl(128u32.wrapping_sub(sr));\n+                r = n.wrapping_shr(sr);\n+                // FIXME the C compiler-rt implementation has something here\n+                // that looks like a speed optimisation.\n+                // It would be worth a try to port it to Rust too and\n+                // compare the speed.\n+            } else {\n+                // K X\n+                // ---\n+                // K K\n+                sr = d.high().leading_zeros().wrapping_sub(n.high().leading_zeros());\n+\n+                // D > N\n+                if sr > 64 - 1 {\n+                    if !rem.is_null() {\n+                        *rem = n;\n+                    }\n+                    return 0;\n+                }\n+\n+                sr = sr.wrapping_add(1);\n+\n+                // 1 <= sr <= u32::bits()\n+                q = n.wrapping_shl(128u32.wrapping_sub(sr));\n+                r = n.wrapping_shr(sr);\n+            }\n+        }\n+\n+        // Not a special case\n+        // q and r are initialized with\n+        // q = n << (u64::bits() - sr)\n+        // r = n >> sr\n+        // 1 <= sr <= u64::bits() - 1\n+        let mut carry = 0;\n+\n+        // FIXME: replace this with a for loop\n+        // (atm not doable as this generates call to\n+        // eh_personality when optimisations are turned off,\n+        // which in turn gives a linker error in later\n+        // compilation steps)\n+        while sr > 0 {\n+            // r:q = ((r:q) << 1) | carry\n+            r = r.wrapping_shl(1) | q.wrapping_shr(128 - 1);\n+            q = q.wrapping_shl(1) | carry as u128;\n+\n+            // carry = 0\n+            // if r >= d {\n+            //     r -= d;\n+            //     carry = 1;\n+            // }\n+            let s = ((d.wrapping_sub(r).wrapping_sub(1)) as i128).wrapping_shr(128 - 1);\n+            carry = (s & 1) as u64;\n+            r = r.wrapping_sub(d & s as u128);\n+            sr = sr.wrapping_sub(1);\n+        }\n+\n+        if !rem.is_null() {\n+            *rem = r;\n+        }\n+        (q.wrapping_shl(1)) | carry as u128\n+        }\n+    }\n+\n+    fn i128_mod(a: i128_, b: i128_) -> i128_ {\n+        let b = b.uabs();\n+        let sa = a.signum();\n+        let a = a.uabs();\n+        unsafe {\n+            let mut r = ::core::mem::zeroed();\n+            u128_div_mod(a, b, &mut r);\n+            if sa == -1 { (r as i128_).unchecked_neg() } else { r as i128_ }\n+        }\n+    }\n+\n+    fn i128_div(a: i128_, b: i128_) -> i128_ {\n+        let sa = a.signum();\n+        let sb = b.signum();\n+        let a = a.uabs();\n+        let b = b.uabs();\n+        let sr = sa.wrapping_mul(sb); // sign of quotient\n+        (if sr == -1 {\n+            (u128_div_mod(a, b, ptr::null_mut()) as i128_).unchecked_neg()\n+        } else {\n+            u128_div_mod(a, b, ptr::null_mut()) as i128_\n+        })\n+    }\n+\n+    #[cfg(stage0)]\n+    #[export_name=\"__udivti3\"]\n+    pub extern \"C\" fn u128_div(a: u128_, b: u128_) -> u128_ {\n+        (a / b)\n+    }\n+\n+    macro_rules! mulo {\n+        ($a:expr, $b:expr, $o: expr, $ty: ty) => {{\n+            let (a, b, overflow) = ($a, $b, $o);\n+            *overflow = 0;\n+            let result = a.wrapping_mul(b);\n+            if a == <$ty>::min_value() {\n+                if b != 0 && b != 1 {\n+                    *overflow = 1;\n+                }\n+                return result;\n+            }\n+            if b == <$ty>::min_value() {\n+                if a != 0 && a != 1 {\n+                    *overflow = 1;\n+                }\n+                return result;\n+            }\n+\n+            let sa = a.signum();\n+            let abs_a = a.iabs();\n+            let sb = b.signum();\n+            let abs_b = b.iabs();\n+            if abs_a < 2 || abs_b < 2 {\n+                return result;\n+            }\n+            if sa == sb {\n+                if abs_a > unchecked_div(<$ty>::max_value(), abs_b) {\n+                    *overflow = 1;\n+                }\n+            } else {\n+                if abs_a > unchecked_div(<$ty>::min_value(), abs_b.unchecked_neg()) {\n+                    *overflow = 1;\n+                }\n+            }\n+            result\n+        }}\n+    }\n+\n+    pub trait LargeInt {\n+        type LowHalf;\n+        type HighHalf;\n+\n+        fn low(self) -> Self::LowHalf;\n+        fn high(self) -> Self::HighHalf;\n+        fn from_parts(low: Self::LowHalf, high: Self::HighHalf) -> Self;\n+    }\n+    impl LargeInt for u64 {\n+        type LowHalf = u32;\n+        type HighHalf = u32;\n+\n+        fn low(self) -> u32 {\n+            self as u32\n+        }\n+        fn high(self) -> u32 {\n+            (self.wrapping_shr(32)) as u32\n+        }\n+        fn from_parts(low: u32, high: u32) -> u64 {\n+            low as u64 | (high as u64).wrapping_shl(32)\n+        }\n+    }\n+    impl LargeInt for i64 {\n+        type LowHalf = u32;\n+        type HighHalf = i32;\n+\n+        fn low(self) -> u32 {\n+            self as u32\n+        }\n+        fn high(self) -> i32 {\n+            self.wrapping_shr(32) as i32\n+        }\n+        fn from_parts(low: u32, high: i32) -> i64 {\n+            low as i64 | (high as i64).wrapping_shl(32)\n+        }\n+    }\n+    #[cfg(not(stage0))]\n+    impl LargeInt for u128 {\n+        type LowHalf = u64;\n+        type HighHalf = u64;\n+\n+        fn low(self) -> u64 {\n+            self as u64\n+        }\n+        fn high(self) -> u64 {\n+            unsafe { *(&self as *const u128 as *const u64).offset(1) }\n+        }\n+        fn from_parts(low: u64, high: u64) -> u128 {\n+            #[repr(C, packed)] struct Parts(u64, u64);\n+            unsafe { ::core::mem::transmute(Parts(low, high)) }\n+        }\n+    }\n+    #[cfg(not(stage0))]\n+    impl LargeInt for i128 {\n+        type LowHalf = u64;\n+        type HighHalf = i64;\n+\n+        fn low(self) -> u64 {\n+            self as u64\n+        }\n+        fn high(self) -> i64 {\n+            unsafe { *(&self as *const i128 as *const i64).offset(1) }\n+        }\n+        fn from_parts(low: u64, high: i64) -> i128 {\n+            u128::from_parts(low, high as u64) as i128\n+        }\n+    }\n+\n+    macro_rules! mul {\n+        ($a:expr, $b:expr, $ty: ty, $tyh: ty) => {{\n+            let (a, b) = ($a, $b);\n+            let half_bits = ((::core::mem::size_of::<$tyh>() * 8) / 2) as u32;\n+            let lower_mask = (!0u64).wrapping_shr(half_bits);\n+            let mut low = (a.low() & lower_mask).wrapping_mul(b.low() & lower_mask);\n+            let mut t = low.wrapping_shr(half_bits);\n+            low &= lower_mask;\n+            t = t.wrapping_add(a.low().wrapping_shr(half_bits)\n+                                      .wrapping_mul(b.low() & lower_mask));\n+            low = low.wrapping_add((t & lower_mask).wrapping_shl(half_bits));\n+            let mut high = t.wrapping_shr(half_bits) as $tyh;\n+            t = low.wrapping_shr(half_bits);\n+            low &= lower_mask;\n+            t = t.wrapping_add(b.low().wrapping_shr(half_bits)\n+                                      .wrapping_mul(a.low() & lower_mask));\n+            low = low.wrapping_add((t & lower_mask).wrapping_shl(half_bits));\n+            high = high.wrapping_add(t.wrapping_shr(half_bits) as $tyh);\n+            high = high.wrapping_add(a.low().wrapping_shr(half_bits)\n+                           .wrapping_mul(b.low().wrapping_shr(half_bits)) as $tyh);\n+            high = high\n+                .wrapping_add(a.high()\n+                .wrapping_mul(b.low() as $tyh))\n+                .wrapping_add((a.low() as $tyh)\n+                .wrapping_mul(b.high()));\n+            <$ty>::from_parts(low, high)\n+        }}\n+    }\n+\n+    #[cfg(stage0)]\n+    #[export_name=\"__multi3\"]\n+    pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128_ {\n+        ((a as i64).wrapping_mul(b as i64) as i128_)\n+    }\n+\n+    #[cfg(not(stage0))]\n+    #[export_name=\"__multi3\"]\n+    pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128_ {\n+        mul!(a, b, i128_, i64)\n+    }\n+\n+    trait AbsExt: Sized {\n+        fn uabs(self) -> u128_ {\n+            self.iabs() as u128_\n+        }\n+        fn iabs(self) -> i128_;\n+    }\n+\n+    #[cfg(stage0)]\n+    impl AbsExt for i128_ {\n+        fn iabs(self) -> i128_ {\n+            let s = self >> 63;\n+            ((self ^ s).wrapping_sub(s))\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    impl AbsExt for i128_ {\n+        fn iabs(self) -> i128_ {\n+            let s = self >> 127;\n+            ((self ^ s).wrapping_sub(s))\n+        }\n+    }\n+\n+    trait NegExt: Sized {\n+        fn unchecked_neg(self) -> i128_;\n+    }\n+\n+    impl NegExt for i128_ {\n+        fn unchecked_neg(self) -> i128_ {\n+            (!self).wrapping_add(1)\n+        }\n+    }\n+\n+    trait FloatStuff: Sized {\n+        type ToBytes;\n+\n+        const MANTISSA_BITS: u32;\n+        const MAX_EXP: i32;\n+        const EXP_MASK: Self::ToBytes;\n+        const MANTISSA_MASK: Self::ToBytes;\n+        const MANTISSA_LEAD_BIT: Self::ToBytes;\n+\n+        fn to_bytes(self) -> Self::ToBytes;\n+        fn get_exponent(self) -> i32;\n+    }\n+\n+    impl FloatStuff for f32 {\n+        type ToBytes = u32;\n+        const MANTISSA_BITS: u32 = 23;\n+        const MAX_EXP: i32 = 127;\n+        const EXP_MASK: u32 = 0x7F80_0000;\n+        const MANTISSA_MASK: u32 = 0x007F_FFFF;\n+        const MANTISSA_LEAD_BIT: u32 = 0x0080_0000;\n+\n+        fn to_bytes(self) -> u32 { unsafe { ::core::mem::transmute(self) } }\n+        fn get_exponent(self) -> i32 {\n+            ((self.to_bytes() & Self::EXP_MASK).wrapping_shr(Self::MANTISSA_BITS) as i32)\n+            .wrapping_sub(Self::MAX_EXP)\n+        }\n+    }\n+\n+    impl FloatStuff for f64 {\n+        type ToBytes = u64;\n+        const MANTISSA_BITS: u32 = 52;\n+        const MAX_EXP: i32 = 1023;\n+        const EXP_MASK: u64 = 0x7FF0_0000_0000_0000;\n+        const MANTISSA_MASK: u64 = 0x000F_FFFF_FFFF_FFFF;\n+        const MANTISSA_LEAD_BIT: u64 = 0x0010_0000_0000_0000;\n+\n+        fn to_bytes(self) -> u64 { unsafe { ::core::mem::transmute(self) } }\n+        fn get_exponent(self) -> i32 {\n+            ((self.to_bytes() & Self::EXP_MASK).wrapping_shr(Self::MANTISSA_BITS) as i32)\n+            .wrapping_sub(Self::MAX_EXP)\n+        }\n+    }\n+\n+    macro_rules! float_as_unsigned {\n+        ($from: expr, $fromty: ty, $outty: ty) => { {\n+            use core::num::Float;\n+            let repr = $from.to_bytes();\n+            let sign = $from.signum();\n+            let exponent = $from.get_exponent();\n+            let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n+            let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n+            if sign == -1.0 || exponent < 0 { return 0 as u128_; }\n+            if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n+                return !(0 as u128_);\n+            }\n+            (if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n+                (mantissa as $outty)\n+                    .wrapping_shr((<$fromty as FloatStuff>::MANTISSA_BITS as i32)\n+                                  .wrapping_sub(exponent) as u32)\n+            } else {\n+                (mantissa as $outty)\n+                    .wrapping_shl(exponent.wrapping_sub(\n+                        <$fromty as FloatStuff>::MANTISSA_BITS as i32) as u32)\n+            })\n+        } }\n+    }\n+\n+    macro_rules! float_as_signed {\n+        ($from: expr, $fromty: ty, $outty: ty) => {{\n+            use core::num::Float;\n+            let repr = $from.to_bytes();\n+            let sign = $from.signum();\n+            let exponent = $from.get_exponent();\n+            let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n+            let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n+\n+            if exponent < 0 { return 0 as i128_; }\n+            if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n+                let ret = if sign > 0.0 { <$outty>::max_value() } else { <$outty>::min_value() };\n+                return ret\n+            }\n+            let r = if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n+                (mantissa as $outty)\n+                    .wrapping_shr((<$fromty as FloatStuff>::MANTISSA_BITS as i32)\n+                                  .wrapping_sub(exponent) as u32)\n+            } else {\n+                (mantissa as $outty)\n+                    .wrapping_shl(exponent.wrapping_sub(\n+                        <$fromty as FloatStuff>::MANTISSA_BITS as i32) as u32)\n+            };\n+            (if sign >= 0.0 { r } else { r.unchecked_neg() })\n+        }}\n+    }\n+\n+\n+    fn i128_as_f64(a: i128_) -> f64 {\n+        match a.signum() {\n+            1 => u128_as_f64(a.uabs()),\n+            0 => 0.0,\n+            _ => -u128_as_f64(a.uabs()),\n+        }\n+    }\n+\n+    fn i128_as_f32(a: i128_) -> f32 {\n+        match a.signum() {\n+            1 => u128_as_f32(a.uabs()),\n+            0 => 0.0,\n+            _ => -u128_as_f32(a.uabs()),\n+        }\n+    }\n+\n+    fn u128_as_f64(mut a: u128_) -> f64 {\n+        use ::core::f64::MANTISSA_DIGITS;\n+        if a == 0 { return 0.0; }\n+        let sd = 128u32.wrapping_sub(a.leading_zeros());\n+        let mut e = sd.wrapping_sub(1);\n+        const MD1 : u32 = MANTISSA_DIGITS + 1;\n+        const MD2 : u32 = MANTISSA_DIGITS + 2;\n+\n+        // SNAP: replace this with !0u128\n+        let negn :u128_ = !0;\n+\n+        if sd > MANTISSA_DIGITS {\n+            a = match sd {\n+                MD1 => a.wrapping_shl(1),\n+                MD2 => a,\n+                _ => a.wrapping_shr(sd.wrapping_sub(MANTISSA_DIGITS + 2)) |\n+                     (if (a & (negn.wrapping_shr(128 + MANTISSA_DIGITS + 2)\n+                                   .wrapping_sub(sd as u128_))) == 0 { 0 } else { 1 })\n+            };\n+            a |= if (a & 4) == 0 { 0 } else { 1 };\n+            a = a.wrapping_add(1);\n+            a = a.wrapping_shr(2);\n+            if a & (1 << MANTISSA_DIGITS) != 0 {\n+                a = a.wrapping_shr(1);\n+                e = e.wrapping_add(1);\n+            }\n+        } else {\n+            a = a.wrapping_shl(MANTISSA_DIGITS.wrapping_sub(sd));\n+        }\n+        unsafe {\n+            ::core::mem::transmute((e as u64).wrapping_add(1023).wrapping_shl(52)\n+                                   | (a as u64 & 0x000f_ffff_ffff_ffff))\n+        }\n+    }\n+\n+    fn u128_as_f32(mut a: u128_) -> f32 {\n+        use ::core::f32::MANTISSA_DIGITS;\n+        if a == 0 { return 0.0; }\n+        let sd = 128u32.wrapping_sub(a.leading_zeros());\n+        let mut e = sd.wrapping_sub(1);\n+        const MD1 : u32 = MANTISSA_DIGITS + 1;\n+        const MD2 : u32 = MANTISSA_DIGITS + 2;\n+\n+        // SNAP: replace this with !0u128\n+        let negn :u128_ = !0;\n+\n+        if sd > MANTISSA_DIGITS {\n+            a = match sd {\n+                MD1 => a.wrapping_shl(1),\n+                MD2 => a,\n+                _ => a.wrapping_shr(sd.wrapping_sub(MANTISSA_DIGITS + 2)) |\n+                     (if (a & (negn.wrapping_shr(128 + MANTISSA_DIGITS + 2)\n+                                   .wrapping_sub(sd as u128_))) == 0 { 0 } else { 1 })\n+            };\n+            a |= if (a & 4) == 0 { 0 } else { 1 };\n+            a = a.wrapping_add(1);\n+            a = a.wrapping_shr(2);\n+            if a & (1 << MANTISSA_DIGITS) != 0 {\n+                a = a.wrapping_shr(1);\n+                e = e.wrapping_add(1);\n+            }\n+        } else {\n+            a = a.wrapping_shl(MANTISSA_DIGITS.wrapping_sub(sd));\n+        }\n+        unsafe {\n+            ::core::mem::transmute((e as u32).wrapping_add(127).wrapping_shl(23)\n+                                   | (a as u32 & 0x007f_ffff))\n+        }\n+    }\n+\n+\n+    macro_rules! why_are_abi_strings_checked_by_parser { ($cret:ty, $conv:expr, $unadj:tt) => {\n+    mod imp {\n+        use super::{i128_, u128_, LargeInt, FloatStuff, NegExt, AbsExt};\n+        use super::{i128_as_f64, i128_as_f32, u128_as_f64, u128_as_f32,\n+                    i128_div, i128_mod, u128_div_mod, unchecked_div, ptr};\n+        // For x64\n+        // rdx:rcx, r9:r8, stack -> rdx:rax\n+        // aka.\n+        // define i128 @__muloti4(i128, i128, i32*)\n+        #[export_name=\"__muloti4\"]\n+        pub unsafe extern $unadj fn i128_mul_oflow(a: i128_, b: i128_, o: *mut i32) -> i128_ {\n+            mulo!(a, b, o, i128_)\n+        }\n+\n+        // For x64\n+        // rdx:rax -> xmm0\n+        // aka.\n+        // define double @__muloti4(i128)\n+        #[export_name=\"__floattidf\"]\n+        pub extern $unadj fn i128_as_f64_(a: i128_) -> f64 {\n+            i128_as_f64(a)\n+        }\n+        #[export_name=\"__floattisf\"]\n+        pub extern $unadj fn i128_as_f32_(a: i128_) -> f32 {\n+            i128_as_f32(a)\n+        }\n+        #[export_name=\"__floatuntidf\"]\n+        pub extern $unadj fn u128_as_f64_(a: u128_) -> f64 {\n+            u128_as_f64(a)\n+        }\n+        #[export_name=\"__floatuntisf\"]\n+        pub extern $unadj fn u128_as_f32_(a: u128_) -> f32 {\n+            u128_as_f32(a)\n+        }\n+\n+        // For x64\n+        // xmm0 -> rdx:rax\n+        // aka.\n+        // define i128 @stuff(double)\n+        #[export_name=\"__fixunsdfti\"]\n+        pub extern $unadj fn f64_as_u128(a: f64) -> u128_ {\n+            float_as_unsigned!(a, f64, u128_)\n+        }\n+\n+        #[export_name=\"__fixunssfti\"]\n+        pub extern \"unadjusted\" fn f32_as_u128(a: f32) -> u128_ {\n+            float_as_unsigned!(a, f32, u128_)\n+        }\n+\n+        #[export_name=\"__fixdfti\"]\n+        pub extern \"unadjusted\" fn f64_as_i128(a: f64) -> i128_ {\n+            float_as_signed!(a, f64, i128_)\n+        }\n+\n+        #[export_name=\"__fixsfti\"]\n+        pub extern \"unadjusted\" fn f32_as_i128(a: f32) -> i128_ {\n+            float_as_signed!(a, f32, i128_)\n+        }\n+\n+        #[repr(simd)]\n+        pub struct u64x2(u64, u64);\n+\n+        // For x64\n+        // pointers -> xmm0\n+        // aka.\n+        // define <2 x u64> @stuff(i128*, i128*, i128*)\n+        //\n+        // That almost matches the C ABI, so we simply use the C ABI\n+        #[export_name=\"__udivmodti4\"]\n+        pub extern \"C\" fn u128_div_mod_(n: u128_, d: u128_, rem: *mut u128_) -> $cret {\n+            let x = u128_div_mod(n, d, rem);\n+            ($conv)(x)\n+        }\n+\n+        #[export_name=\"__udivti3\"]\n+        pub extern \"C\" fn u128_div_(a: u128_, b: u128_) -> $cret {\n+            let x = u128_div_mod(a, b, ptr::null_mut());\n+            ($conv)(x)\n+        }\n+\n+        #[export_name=\"__umodti3\"]\n+        pub extern \"C\" fn u128_mod_(a: u128_, b: u128_) -> $cret {\n+            unsafe {\n+                let mut r = ::core::mem::zeroed();\n+                u128_div_mod(a, b, &mut r);\n+                ($conv)(r)\n+            }\n+        }\n+\n+        #[export_name=\"__divti3\"]\n+        pub extern \"C\" fn i128_div_(a: i128_, b: i128_) -> $cret {\n+            let x = i128_div(a, b);\n+            ($conv)(x as u128_)\n+        }\n+\n+        #[export_name=\"__modti3\"]\n+        pub extern \"C\" fn i128_mod_(a: i128_, b: i128_) -> $cret {\n+            let x = i128_mod(a, b);\n+            ($conv)(x as u128_)\n+        }\n+    }\n+    } }\n+\n+    // LLVM expectations for ABI on windows x64 are pure madness.\n+    #[cfg(not(stage0))]\n+    #[cfg(all(windows, target_pointer_width=\"64\"))]\n+    why_are_abi_strings_checked_by_parser!(u64x2,\n+                                           |i: u128_| u64x2(i.low(), i.high()),\n+                                           \"unadjusted\");\n+\n+    #[cfg(not(stage0))]\n+    #[cfg(not(all(windows, target_pointer_width=\"64\")))]\n+    why_are_abi_strings_checked_by_parser!(u128_, |i|{ i }, \"C\");\n+\n+    #[cfg(not(stage0))]\n+    pub use self::imp::*;\n+}"}, {"sha": "cd2e8f101814199224c64f1a663c145a96e77bbf", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -153,12 +153,16 @@ clone_impl! { i8 }\n clone_impl! { i16 }\n clone_impl! { i32 }\n clone_impl! { i64 }\n+#[cfg(not(stage0))]\n+clone_impl! { i128 }\n \n clone_impl! { usize }\n clone_impl! { u8 }\n clone_impl! { u16 }\n clone_impl! { u32 }\n clone_impl! { u64 }\n+#[cfg(not(stage0))]\n+clone_impl! { u128 }\n \n clone_impl! { f32 }\n clone_impl! { f64 }"}, {"sha": "a78d27ea3afc1ea251a73e202ee669ed5ffc0158", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -681,6 +681,8 @@ mod impls {\n     partial_eq_impl! {\n         bool char usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64\n     }\n+    #[cfg(not(stage0))]\n+    partial_eq_impl! { u128 i128 }\n \n     macro_rules! eq_impl {\n         ($($t:ty)*) => ($(\n@@ -690,6 +692,8 @@ mod impls {\n     }\n \n     eq_impl! { () bool char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+    #[cfg(not(stage0))]\n+    eq_impl! { u128 i128 }\n \n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n@@ -779,6 +783,8 @@ mod impls {\n     }\n \n     ord_impl! { char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+    #[cfg(not(stage0))]\n+    ord_impl! { u128 i128 }\n \n     #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n     impl PartialEq for ! {"}, {"sha": "ccd4343336f5ecde65dab99ea48a7eca99d361b3", "filename": "src/libcore/default.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -144,12 +144,16 @@ default_impl! { u8, 0 }\n default_impl! { u16, 0 }\n default_impl! { u32, 0 }\n default_impl! { u64, 0 }\n+#[cfg(not(stage0))]\n+default_impl! { u128, 0 }\n \n default_impl! { isize, 0 }\n default_impl! { i8, 0 }\n default_impl! { i16, 0 }\n default_impl! { i32, 0 }\n default_impl! { i64, 0 }\n+#[cfg(not(stage0))]\n+default_impl! { i128, 0 }\n \n default_impl! { f32, 0.0f32 }\n default_impl! { f64, 0.0f64 }"}, {"sha": "cd725392b665ffcd9ed583a90f6c9aff1cb89901", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -30,6 +30,8 @@ trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n     fn to_u16(&self) -> u16;\n     fn to_u32(&self) -> u32;\n     fn to_u64(&self) -> u64;\n+    #[cfg(not(stage0))]\n+    fn to_u128(&self) -> u128;\n }\n \n macro_rules! doit {\n@@ -39,9 +41,13 @@ macro_rules! doit {\n         fn to_u16(&self) -> u16 { *self as u16 }\n         fn to_u32(&self) -> u32 { *self as u32 }\n         fn to_u64(&self) -> u64 { *self as u64 }\n+        #[cfg(not(stage0))]\n+        fn to_u128(&self) -> u128 { *self as u128 }\n     })*)\n }\n doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+#[cfg(not(stage0))]\n+doit! { i128 u128 }\n \n /// A type that represents a specific radix\n #[doc(hidden)]\n@@ -59,11 +65,11 @@ trait GenericRadix {\n \n     /// Format an integer using the radix using a formatter.\n     fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n-        // The radix can be as low as 2, so we need a buffer of at least 64\n+        // The radix can be as low as 2, so we need a buffer of at least 128\n         // characters for a base 2 number.\n         let zero = T::zero();\n         let is_nonnegative = x >= zero;\n-        let mut buf = [0; 64];\n+        let mut buf = [0; 128];\n         let mut curr = buf.len();\n         let base = T::from_u8(self.base());\n         if is_nonnegative {\n@@ -182,6 +188,8 @@ integer! { i8, u8 }\n integer! { i16, u16 }\n integer! { i32, u32 }\n integer! { i64, u64 }\n+#[cfg(not(stage0))]\n+integer! { i128, u128 }\n \n const DEC_DIGITS_LUT: &'static[u8] =\n     b\"0001020304050607080910111213141516171819\\\n@@ -203,14 +211,15 @@ macro_rules! impl_Display {\n                 // convert the negative num to positive by summing 1 to it's 2 complement\n                 (!self.$conv_fn()).wrapping_add(1)\n             };\n-            let mut buf: [u8; 20] = unsafe { mem::uninitialized() };\n+            let mut buf: [u8; 39] = unsafe { mem::uninitialized() };\n             let mut curr = buf.len() as isize;\n             let buf_ptr = buf.as_mut_ptr();\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n             unsafe {\n-                // eagerly decode 4 characters at a time\n-                if <$t>::max_value() as u64 >= 10000 {\n+                // need at least 16 bits for the 4-characters-at-a-time to work.\n+                if ::mem::size_of::<$t>() >= 2 {\n+                    // eagerly decode 4 characters at a time\n                     while n >= 10000 {\n                         let rem = (n % 10000) as isize;\n                         n /= 10000;\n@@ -256,6 +265,8 @@ macro_rules! impl_Display {\n \n impl_Display!(i8, u8, i16, u16, i32, u32: to_u32);\n impl_Display!(i64, u64: to_u64);\n+#[cfg(not(stage0))]\n+impl_Display!(i128, u128: to_u128);\n #[cfg(target_pointer_width = \"16\")]\n impl_Display!(isize, usize: to_u16);\n #[cfg(target_pointer_width = \"32\")]"}, {"sha": "92657a6d0b1ca3d3a49bf762d0a629f7a1fc42a8", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -186,6 +186,13 @@ pub trait Hasher {\n     fn write_u64(&mut self, i: u64) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })\n     }\n+    #[cfg(not(stage0))]\n+    /// Writes a single `u128` into this hasher.\n+    #[inline]\n+    #[unstable(feature = \"i128\", issue = \"35118\")]\n+    fn write_u128(&mut self, i: u128) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 16]>(i) })\n+    }\n     /// Writes a single `usize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n@@ -220,6 +227,13 @@ pub trait Hasher {\n     fn write_i64(&mut self, i: i64) {\n         self.write_u64(i as u64)\n     }\n+    #[cfg(not(stage0))]\n+    /// Writes a single `i128` into this hasher.\n+    #[inline]\n+    #[unstable(feature = \"i128\", issue = \"35118\")]\n+    fn write_i128(&mut self, i: i128) {\n+        self.write_u128(i as u128)\n+    }\n     /// Writes a single `isize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n@@ -362,6 +376,11 @@ mod impls {\n         (i64, write_i64),\n         (isize, write_isize),\n     }\n+    #[cfg(not(stage0))]\n+    impl_write! {\n+        (u128, write_u128),\n+        (i128, write_i128),\n+    }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Hash for bool {"}, {"sha": "9d22037882f214248c79e71f20e7d157caeb1ea1", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -242,6 +242,8 @@ step_impl_signed!(i64);\n // assume here that it is less than 64-bits.\n #[cfg(not(target_pointer_width = \"64\"))]\n step_impl_no_between!(u64 i64);\n+#[cfg(not(stage0))]\n+step_impl_no_between!(u128 i128);\n \n /// An adapter for stepping range iterators by a custom amount.\n ///"}, {"sha": "2cb2f81fcffb55da39892a369b2b63cb208e0fd3", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -90,6 +90,7 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(never_type)]\n+#![cfg_attr(not(stage0), feature(i128_type))]\n #![feature(prelude_import)]\n \n #[prelude_import]\n@@ -120,12 +121,20 @@ mod uint_macros;\n #[path = \"num/i32.rs\"]   pub mod i32;\n #[path = \"num/i64.rs\"]   pub mod i64;\n \n+// SNAP\n+#[cfg(not(stage0))]\n+#[path = \"num/i128.rs\"]   pub mod i128;\n+\n #[path = \"num/usize.rs\"] pub mod usize;\n #[path = \"num/u8.rs\"]    pub mod u8;\n #[path = \"num/u16.rs\"]   pub mod u16;\n #[path = \"num/u32.rs\"]   pub mod u32;\n #[path = \"num/u64.rs\"]   pub mod u64;\n \n+// SNAP\n+#[cfg(not(stage0))]\n+#[path = \"num/u128.rs\"]   pub mod u128;\n+\n #[path = \"num/f32.rs\"]   pub mod f32;\n #[path = \"num/f64.rs\"]   pub mod f64;\n "}, {"sha": "539ad00bd30e039b2df991c346358452c8dd7f4b", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -30,6 +30,10 @@ unsafe impl Zeroable for i32 {}\n unsafe impl Zeroable for u32 {}\n unsafe impl Zeroable for i64 {}\n unsafe impl Zeroable for u64 {}\n+#[cfg(not(stage0))]\n+unsafe impl Zeroable for i128 {}\n+#[cfg(not(stage0))]\n+unsafe impl Zeroable for u128 {}\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations."}, {"sha": "6268271a1dcc57728d75864e94c06c3e1babf993", "filename": "src/libcore/num/i128.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi128.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The 128-bit signed integer type.\n+//!\n+//! *[See also the `i128` primitive type](../../std/primitive.i128.html).*\n+\n+#![unstable(feature = \"i128\", issue=\"35118\")]\n+\n+int_module! { i128 }"}, {"sha": "0f3a5baa2dd9ea85c9d5590e5b8ac72f82e66994", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-int_module! { i16, 16 }\n+int_module! { i16 }"}, {"sha": "ea8b3a9145c6e94bddf791917d64288d2d04eefc", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-int_module! { i32, 32 }\n+int_module! { i32 }"}, {"sha": "aa21b1190aef568f252342cfed8f3dcd965fc7ad", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-int_module! { i64, 64 }\n+int_module! { i64 }"}, {"sha": "1bed4861594c91bcec80ba9e600bf137c88cc5ac", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-int_module! { i8, 8 }\n+int_module! { i8 }"}, {"sha": "630fac9d92f0f1ec440978a1464ae1207ec98bc8", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -10,7 +10,7 @@\n \n #![doc(hidden)]\n \n-macro_rules! int_module { ($T:ident, $bits:expr) => (\n+macro_rules! int_module { ($T:ident) => (\n \n /// The smallest value that can be represented by this integer type.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "e0917f79c43dc83a976e6f8ee45d6a85a2a95706", "filename": "src/libcore/num/isize.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fisize.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -14,9 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[cfg(target_pointer_width = \"16\")]\n-int_module! { isize, 16 }\n-#[cfg(target_pointer_width = \"32\")]\n-int_module! { isize, 32 }\n-#[cfg(target_pointer_width = \"64\")]\n-int_module! { isize, 64 }\n+int_module! { isize }"}, {"sha": "61c687313dcb66e28277addff7edf755128305d8", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 119, "deletions": 12, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -145,6 +145,8 @@ macro_rules! zero_one_impl {\n     )*)\n }\n zero_one_impl! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+zero_one_impl! { u128 i128 }\n \n macro_rules! zero_one_impl_float {\n     ($($t:ty)*) => ($(\n@@ -191,7 +193,7 @@ macro_rules! int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub const fn min_value() -> Self {\n-            (-1 as Self) << ($BITS - 1)\n+            !0 ^ ((!0 as $UnsignedT) >> 1) as Self\n         }\n \n         /// Returns the largest value that can be represented by this integer type.\n@@ -1298,6 +1300,16 @@ impl i64 {\n         intrinsics::mul_with_overflow }\n }\n \n+// SNAP\n+#[cfg(not(stage0))]\n+#[lang = \"i128\"]\n+impl i128 {\n+    int_impl! { i128, u128, 128,\n+        intrinsics::add_with_overflow,\n+        intrinsics::sub_with_overflow,\n+        intrinsics::mul_with_overflow }\n+}\n+\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n@@ -2330,6 +2342,20 @@ impl u64 {\n         intrinsics::mul_with_overflow }\n }\n \n+// SNAP\n+#[cfg(not(stage0))]\n+#[lang = \"u128\"]\n+impl u128 {\n+    uint_impl! { u128, 128,\n+        intrinsics::ctpop,\n+        intrinsics::ctlz,\n+        intrinsics::cttz,\n+        intrinsics::bswap,\n+        intrinsics::add_with_overflow,\n+        intrinsics::sub_with_overflow,\n+        intrinsics::mul_with_overflow }\n+}\n+\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n@@ -2543,6 +2569,8 @@ macro_rules! from_str_radix_int_impl {\n     )*}\n }\n from_str_radix_int_impl! { isize i8 i16 i32 i64 usize u8 u16 u32 u64 }\n+#[cfg(not(stage0))]\n+from_str_radix_int_impl! { u128 i128 }\n \n /// The error type returned when a checked integral type conversion fails.\n #[unstable(feature = \"try_from\", issue = \"33417\")]\n@@ -2567,7 +2595,7 @@ impl fmt::Display for TryFromIntError {\n     }\n }\n \n-macro_rules! same_sign_from_int_impl {\n+macro_rules! same_sign_try_from_int_impl {\n     ($storage:ty, $target:ty, $($source:ty),*) => {$(\n         #[unstable(feature = \"try_from\", issue = \"33417\")]\n         impl TryFrom<$source> for $target {\n@@ -2586,16 +2614,51 @@ macro_rules! same_sign_from_int_impl {\n     )*}\n }\n \n-same_sign_from_int_impl!(u64, u8, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, i8, i8, i16, i32, i64, isize);\n-same_sign_from_int_impl!(u64, u16, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, i16, i8, i16, i32, i64, isize);\n-same_sign_from_int_impl!(u64, u32, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, i32, i8, i16, i32, i64, isize);\n-same_sign_from_int_impl!(u64, u64, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, i64, i8, i16, i32, i64, isize);\n-same_sign_from_int_impl!(u64, usize, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, isize, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(u64, u8, u8, u16, u32, u64, usize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(i64, i8, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(u64, u16, u8, u16, u32, u64, usize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(i64, i16, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(u64, u32, u8, u16, u32, u64, usize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(i64, i32, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(u64, u64, u8, u16, u32, u64, usize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(i64, i64, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(u64, usize, u8, u16, u32, u64, usize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(i64, isize, i8, i16, i32, i64, isize);\n+\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u8, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i8, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u16, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i16, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u32, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i32, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u64, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i64, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u128, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i128, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, usize, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, isize, i8, i16, i32, i64, i128, isize);\n \n macro_rules! cross_sign_from_int_impl {\n     ($unsigned:ty, $($signed:ty),*) => {$(\n@@ -2629,12 +2692,30 @@ macro_rules! cross_sign_from_int_impl {\n     )*}\n }\n \n+#[cfg(stage0)]\n cross_sign_from_int_impl!(u8, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n cross_sign_from_int_impl!(u16, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n cross_sign_from_int_impl!(u32, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n cross_sign_from_int_impl!(u64, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n cross_sign_from_int_impl!(usize, i8, i16, i32, i64, isize);\n \n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u8, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u16, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u32, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u64, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u128, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(usize, i8, i16, i32, i64, i128, isize);\n+\n #[doc(hidden)]\n trait FromStrRadixHelper: PartialOrd + Copy {\n     fn min_value() -> Self;\n@@ -2662,6 +2743,8 @@ macro_rules! doit {\n     })*)\n }\n doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+#[cfg(not(stage0))]\n+doit! { i128 u128 }\n \n fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {\n     use self::IntErrorKind::*;\n@@ -2795,27 +2878,51 @@ macro_rules! impl_from {\n impl_from! { u8, u16 }\n impl_from! { u8, u32 }\n impl_from! { u8, u64 }\n+#[cfg(not(stage0))]\n+impl_from! { u8, u128 }\n impl_from! { u8, usize }\n impl_from! { u16, u32 }\n impl_from! { u16, u64 }\n+#[cfg(not(stage0))]\n+impl_from! { u16, u128 }\n impl_from! { u32, u64 }\n+#[cfg(not(stage0))]\n+impl_from! { u32, u128 }\n+#[cfg(not(stage0))]\n+impl_from! { u64, u128 }\n \n // Signed -> Signed\n impl_from! { i8, i16 }\n impl_from! { i8, i32 }\n impl_from! { i8, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { i8, i128 }\n impl_from! { i8, isize }\n impl_from! { i16, i32 }\n impl_from! { i16, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { i16, i128 }\n impl_from! { i32, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { i32, i128 }\n+#[cfg(not(stage0))]\n+impl_from! { i64, i128 }\n \n // Unsigned -> Signed\n impl_from! { u8, i16 }\n impl_from! { u8, i32 }\n impl_from! { u8, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { u8, i128 }\n impl_from! { u16, i32 }\n impl_from! { u16, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { u16, i128 }\n impl_from! { u32, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { u32, i128 }\n+#[cfg(not(stage0))]\n+impl_from! { u64, i128 }\n \n // Note: integers can only be represented with full precision in a float if\n // they fit in the significand, which is 24 bits in f32 and 53 bits in f64."}, {"sha": "77291f687255e9fbd2961aa3911a27af4e509394", "filename": "src/libcore/num/u128.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu128.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The 128-bit unsigned integer type.\n+//!\n+//! *[See also the `u128` primitive type](../../std/primitive.u128.html).*\n+\n+#![unstable(feature = \"i128\", issue=\"35118\")]\n+uint_module! { u128 }"}, {"sha": "9c318216f1fbaf1bcdee03934e30faf5eae60eee", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { u16, 16 }\n+uint_module! { u16 }"}, {"sha": "84367c2073833c3c5e55d23214c3e7d751414e2b", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { u32, 32 }\n+uint_module! { u32 }"}, {"sha": "cc48a28b22f69fb79fcb795fd1f6c1392c4063d3", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { u64, 64 }\n+uint_module! { u64 }"}, {"sha": "6c0daa7763ae1ed45ed46ae997e76115710b704d", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { u8, 8 }\n+uint_module! { u8 }"}, {"sha": "a3a2dc73e9c8e2ee70604b1e2c7ccdaae25901a5", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -10,7 +10,7 @@\n \n #![doc(hidden)]\n \n-macro_rules! uint_module { ($T:ident, $bits:expr) => (\n+macro_rules! uint_module { ($T:ident) => (\n \n /// The smallest value that can be represented by this integer type.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "0b6f1c73c5834c32e496b31d0ad096b7cce02fc4", "filename": "src/libcore/num/usize.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fusize.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -14,9 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[cfg(target_pointer_width = \"16\")]\n-uint_module! { usize, 16 }\n-#[cfg(target_pointer_width = \"32\")]\n-uint_module! { usize, 32 }\n-#[cfg(target_pointer_width = \"64\")]\n-uint_module! { usize, 64 }\n+uint_module! { usize }"}, {"sha": "b3c2c25551e0d4b9d0b773b34445f388498872b5", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -298,6 +298,8 @@ macro_rules! wrapping_impl {\n }\n \n wrapping_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+wrapping_impl! { u128 i128 }\n \n mod shift_max {\n     #![allow(non_upper_case_globals)]"}, {"sha": "40d941a8b27e03d84e34cf8fbc06663439718e7d", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -268,6 +268,8 @@ macro_rules! add_impl {\n }\n \n add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+add_impl! { u128 i128 }\n \n /// The `Sub` trait is used to specify the functionality of `-`.\n ///\n@@ -341,6 +343,8 @@ macro_rules! sub_impl {\n }\n \n sub_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+sub_impl! { u128 i128 }\n \n /// The `Mul` trait is used to specify the functionality of `*`.\n ///\n@@ -463,6 +467,8 @@ macro_rules! mul_impl {\n }\n \n mul_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+mul_impl! { u128 i128 }\n \n /// The `Div` trait is used to specify the functionality of `/`.\n ///\n@@ -592,6 +598,8 @@ macro_rules! div_impl_integer {\n }\n \n div_impl_integer! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+div_impl_integer! { u128 i128 }\n \n macro_rules! div_impl_float {\n     ($($t:ty)*) => ($(\n@@ -671,6 +679,9 @@ macro_rules! rem_impl_integer {\n }\n \n rem_impl_integer! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+rem_impl_integer! { u128 i128 }\n+\n \n macro_rules! rem_impl_float {\n     ($($t:ty)*) => ($(\n@@ -766,6 +777,8 @@ macro_rules! neg_impl_unsigned {\n \n // neg_impl_unsigned! { usize u8 u16 u32 u64 }\n neg_impl_numeric! { isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+neg_impl_numeric! { i128 }\n \n /// The `Not` trait is used to specify the functionality of unary `!`.\n ///\n@@ -824,6 +837,8 @@ macro_rules! not_impl {\n }\n \n not_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+not_impl! { u128 i128 }\n \n /// The `BitAnd` trait is used to specify the functionality of `&`.\n ///\n@@ -907,6 +922,8 @@ macro_rules! bitand_impl {\n }\n \n bitand_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitand_impl! { u128 i128 }\n \n /// The `BitOr` trait is used to specify the functionality of `|`.\n ///\n@@ -990,6 +1007,8 @@ macro_rules! bitor_impl {\n }\n \n bitor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitor_impl! { u128 i128 }\n \n /// The `BitXor` trait is used to specify the functionality of `^`.\n ///\n@@ -1076,6 +1095,8 @@ macro_rules! bitxor_impl {\n }\n \n bitxor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitxor_impl! { u128 i128 }\n \n /// The `Shl` trait is used to specify the functionality of `<<`.\n ///\n@@ -1166,17 +1187,23 @@ macro_rules! shl_impl_all {\n         shl_impl! { $t, u16 }\n         shl_impl! { $t, u32 }\n         shl_impl! { $t, u64 }\n+        #[cfg(not(stage0))]\n+        shl_impl! { $t, u128 }\n         shl_impl! { $t, usize }\n \n         shl_impl! { $t, i8 }\n         shl_impl! { $t, i16 }\n         shl_impl! { $t, i32 }\n         shl_impl! { $t, i64 }\n+        #[cfg(not(stage0))]\n+        shl_impl! { $t, i128 }\n         shl_impl! { $t, isize }\n     )*)\n }\n \n shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+shl_impl_all! { u128 i128 }\n \n /// The `Shr` trait is used to specify the functionality of `>>`.\n ///\n@@ -1267,17 +1294,23 @@ macro_rules! shr_impl_all {\n         shr_impl! { $t, u16 }\n         shr_impl! { $t, u32 }\n         shr_impl! { $t, u64 }\n+        #[cfg(not(stage0))]\n+        shr_impl! { $t, u128 }\n         shr_impl! { $t, usize }\n \n         shr_impl! { $t, i8 }\n         shr_impl! { $t, i16 }\n         shr_impl! { $t, i32 }\n         shr_impl! { $t, i64 }\n+        #[cfg(not(stage0))]\n+        shr_impl! { $t, i128 }\n         shr_impl! { $t, isize }\n     )*)\n }\n \n shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+shr_impl_all! { u128 i128 }\n \n /// The `AddAssign` trait is used to specify the functionality of `+=`.\n ///\n@@ -1334,6 +1367,8 @@ macro_rules! add_assign_impl {\n }\n \n add_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+add_assign_impl! { u128 i128 }\n \n /// The `SubAssign` trait is used to specify the functionality of `-=`.\n ///\n@@ -1390,6 +1425,8 @@ macro_rules! sub_assign_impl {\n }\n \n sub_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+sub_assign_impl! { u128 i128 }\n \n /// The `MulAssign` trait is used to specify the functionality of `*=`.\n ///\n@@ -1435,6 +1472,8 @@ macro_rules! mul_assign_impl {\n }\n \n mul_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+mul_assign_impl! { u128 i128 }\n \n /// The `DivAssign` trait is used to specify the functionality of `/=`.\n ///\n@@ -1479,6 +1518,8 @@ macro_rules! div_assign_impl {\n }\n \n div_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+div_assign_impl! { u128 i128 }\n \n /// The `RemAssign` trait is used to specify the functionality of `%=`.\n ///\n@@ -1523,6 +1564,8 @@ macro_rules! rem_assign_impl {\n }\n \n rem_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+rem_assign_impl! { u128 i128 }\n \n /// The `BitAndAssign` trait is used to specify the functionality of `&=`.\n ///\n@@ -1609,6 +1652,8 @@ macro_rules! bitand_assign_impl {\n }\n \n bitand_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitand_assign_impl! { u128 i128 }\n \n /// The `BitOrAssign` trait is used to specify the functionality of `|=`.\n ///\n@@ -1653,6 +1698,8 @@ macro_rules! bitor_assign_impl {\n }\n \n bitor_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitor_assign_impl! { u128 i128 }\n \n /// The `BitXorAssign` trait is used to specify the functionality of `^=`.\n ///\n@@ -1697,6 +1744,8 @@ macro_rules! bitxor_assign_impl {\n }\n \n bitxor_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitxor_assign_impl! { u128 i128 }\n \n /// The `ShlAssign` trait is used to specify the functionality of `<<=`.\n ///\n@@ -1749,17 +1798,23 @@ macro_rules! shl_assign_impl_all {\n         shl_assign_impl! { $t, u16 }\n         shl_assign_impl! { $t, u32 }\n         shl_assign_impl! { $t, u64 }\n+        #[cfg(not(stage0))]\n+        shl_assign_impl! { $t, u128 }\n         shl_assign_impl! { $t, usize }\n \n         shl_assign_impl! { $t, i8 }\n         shl_assign_impl! { $t, i16 }\n         shl_assign_impl! { $t, i32 }\n         shl_assign_impl! { $t, i64 }\n+        #[cfg(not(stage0))]\n+        shl_assign_impl! { $t, i128 }\n         shl_assign_impl! { $t, isize }\n     )*)\n }\n \n shl_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+shl_assign_impl_all! { u128 i128 }\n \n /// The `ShrAssign` trait is used to specify the functionality of `>>=`.\n ///\n@@ -1812,17 +1867,23 @@ macro_rules! shr_assign_impl_all {\n         shr_assign_impl! { $t, u16 }\n         shr_assign_impl! { $t, u32 }\n         shr_assign_impl! { $t, u64 }\n+        #[cfg(not(stage0))]\n+        shr_assign_impl! { $t, u128 }\n         shr_assign_impl! { $t, usize }\n \n         shr_assign_impl! { $t, i8 }\n         shr_assign_impl! { $t, i16 }\n         shr_assign_impl! { $t, i32 }\n         shr_assign_impl! { $t, i64 }\n+        #[cfg(not(stage0))]\n+        shr_assign_impl! { $t, i128 }\n         shr_assign_impl! { $t, isize }\n     )*)\n }\n \n shr_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+shr_assign_impl_all! { u128 i128 }\n \n /// The `Index` trait is used to specify the functionality of indexing operations\n /// like `container[index]` when used in an immutable context."}, {"sha": "51494885e73696addcd84337051035bbbfdbef5f", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -20,6 +20,7 @@ rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "73ec9d8f8c8805ee0f56350277a48ed0515fb5a0", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -62,6 +62,9 @@ extern crate rustc_errors as errors;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n+// SNAP:\n+extern crate rustc_i128;\n+\n #[cfg(test)]\n extern crate test;\n "}, {"sha": "cd7859af8ee7b526a96e1d1776d4ef4a3641f89a", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -260,11 +260,13 @@ language_item_table! {\n     I16ImplItem,                     \"i16\",                     i16_impl;\n     I32ImplItem,                     \"i32\",                     i32_impl;\n     I64ImplItem,                     \"i64\",                     i64_impl;\n+    I128ImplItem,                     \"i128\",                   i128_impl;\n     IsizeImplItem,                   \"isize\",                   isize_impl;\n     U8ImplItem,                      \"u8\",                      u8_impl;\n     U16ImplItem,                     \"u16\",                     u16_impl;\n     U32ImplItem,                     \"u32\",                     u32_impl;\n     U64ImplItem,                     \"u64\",                     u64_impl;\n+    U128ImplItem,                    \"u128\",                    u128_impl;\n     UsizeImplItem,                   \"usize\",                   usize_impl;\n     F32ImplItem,                     \"f32\",                     f32_impl;\n     F64ImplItem,                     \"f64\",                     f64_impl;"}, {"sha": "380c5b0eb6f3b5bca9cd6ee080c1fc07b88c073b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -194,11 +194,13 @@ pub struct CommonTypes<'tcx> {\n     pub i16: Ty<'tcx>,\n     pub i32: Ty<'tcx>,\n     pub i64: Ty<'tcx>,\n+    pub i128: Ty<'tcx>,\n     pub usize: Ty<'tcx>,\n     pub u8: Ty<'tcx>,\n     pub u16: Ty<'tcx>,\n     pub u32: Ty<'tcx>,\n     pub u64: Ty<'tcx>,\n+    pub u128: Ty<'tcx>,\n     pub f32: Ty<'tcx>,\n     pub f64: Ty<'tcx>,\n     pub never: Ty<'tcx>,\n@@ -359,11 +361,13 @@ impl<'tcx> CommonTypes<'tcx> {\n             i16: mk(TyInt(ast::IntTy::I16)),\n             i32: mk(TyInt(ast::IntTy::I32)),\n             i64: mk(TyInt(ast::IntTy::I64)),\n+            i128: mk(TyInt(ast::IntTy::I128)),\n             usize: mk(TyUint(ast::UintTy::Us)),\n             u8: mk(TyUint(ast::UintTy::U8)),\n             u16: mk(TyUint(ast::UintTy::U16)),\n             u32: mk(TyUint(ast::UintTy::U32)),\n             u64: mk(TyUint(ast::UintTy::U64)),\n+            u128: mk(TyUint(ast::UintTy::U128)),\n             f32: mk(TyFloat(ast::FloatTy::F32)),\n             f64: mk(TyFloat(ast::FloatTy::F64)),\n         }\n@@ -1304,6 +1308,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ast::IntTy::I16  => self.types.i16,\n             ast::IntTy::I32  => self.types.i32,\n             ast::IntTy::I64  => self.types.i64,\n+            ast::IntTy::I128  => self.types.i128,\n         }\n     }\n \n@@ -1314,6 +1319,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ast::UintTy::U16  => self.types.u16,\n             ast::UintTy::U32  => self.types.u32,\n             ast::UintTy::U64  => self.types.u64,\n+            ast::UintTy::U128  => self.types.u128,\n         }\n     }\n "}, {"sha": "ff95554dbbfcd6a36fac3b77c6c2f1ce0c590ee9", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 58, "deletions": 23, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -20,6 +20,8 @@ use ty::{self, Ty, TyCtxt, TypeFoldable};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n use syntax_pos::DUMMY_SP;\n+use rustc_i128::u128;\n+use rustc_const_math::ConstInt;\n \n use std::cmp;\n use std::fmt;\n@@ -35,6 +37,7 @@ pub struct TargetDataLayout {\n     pub i16_align: Align,\n     pub i32_align: Align,\n     pub i64_align: Align,\n+    pub i128_align: Align,\n     pub f32_align: Align,\n     pub f64_align: Align,\n     pub pointer_size: Size,\n@@ -55,6 +58,7 @@ impl Default for TargetDataLayout {\n             i16_align: Align::from_bits(16, 16).unwrap(),\n             i32_align: Align::from_bits(32, 32).unwrap(),\n             i64_align: Align::from_bits(32, 64).unwrap(),\n+            i128_align: Align::from_bits(32, 64).unwrap(),\n             f32_align: Align::from_bits(32, 32).unwrap(),\n             f64_align: Align::from_bits(64, 64).unwrap(),\n             pointer_size: Size::from_bits(64),\n@@ -99,6 +103,7 @@ impl TargetDataLayout {\n         };\n \n         let mut dl = TargetDataLayout::default();\n+        let mut i128_align_src = 64;\n         for spec in sess.target.target.data_layout.split(\"-\") {\n             match &spec.split(\":\").collect::<Vec<_>>()[..] {\n                 &[\"e\"] => dl.endian = Endian::Little,\n@@ -111,19 +116,28 @@ impl TargetDataLayout {\n                     dl.pointer_align = align(a, p);\n                 }\n                 &[s, ref a..] if s.starts_with(\"i\") => {\n-                    let ty_align = match s[1..].parse::<u64>() {\n-                        Ok(1) => &mut dl.i8_align,\n-                        Ok(8) => &mut dl.i8_align,\n-                        Ok(16) => &mut dl.i16_align,\n-                        Ok(32) => &mut dl.i32_align,\n-                        Ok(64) => &mut dl.i64_align,\n-                        Ok(_) => continue,\n+                    let bits = match s[1..].parse::<u64>() {\n+                        Ok(bits) => bits,\n                         Err(_) => {\n                             size(&s[1..], \"i\"); // For the user error.\n                             continue;\n                         }\n                     };\n-                    *ty_align = align(a, s);\n+                    let a = align(a, s);\n+                    match bits {\n+                        1 => dl.i1_align = a,\n+                        8 => dl.i8_align = a,\n+                        16 => dl.i16_align = a,\n+                        32 => dl.i32_align = a,\n+                        64 => dl.i64_align = a,\n+                        _ => {}\n+                    }\n+                    if bits >= i128_align_src && bits <= 128 {\n+                        // Default alignment for i128 is decided by taking the alignment of\n+                        // largest-sized i{64...128}.\n+                        i128_align_src = bits;\n+                        dl.i128_align = a;\n+                    }\n                 }\n                 &[s, ref a..] if s.starts_with(\"v\") => {\n                     let v_size = size(&s[1..], \"v\");\n@@ -325,7 +339,8 @@ pub enum Integer {\n     I8,\n     I16,\n     I32,\n-    I64\n+    I64,\n+    I128,\n }\n \n impl Integer {\n@@ -336,6 +351,7 @@ impl Integer {\n             I16 => Size::from_bytes(2),\n             I32 => Size::from_bytes(4),\n             I64  => Size::from_bytes(8),\n+            I128  => Size::from_bytes(16),\n         }\n     }\n \n@@ -346,6 +362,7 @@ impl Integer {\n             I16 => dl.i16_align,\n             I32 => dl.i32_align,\n             I64 => dl.i64_align,\n+            I128 => dl.i128_align,\n         }\n     }\n \n@@ -357,33 +374,37 @@ impl Integer {\n             (I16, false) => tcx.types.u16,\n             (I32, false) => tcx.types.u32,\n             (I64, false) => tcx.types.u64,\n+            (I128, false) => tcx.types.u128,\n             (I1, true) => tcx.types.i8,\n             (I8, true) => tcx.types.i8,\n             (I16, true) => tcx.types.i16,\n             (I32, true) => tcx.types.i32,\n             (I64, true) => tcx.types.i64,\n+            (I128, true) => tcx.types.i128,\n         }\n     }\n \n     /// Find the smallest Integer type which can represent the signed value.\n     pub fn fit_signed(x: i64) -> Integer {\n         match x {\n-            -0x0000_0001...0x0000_0000 => I1,\n-            -0x0000_0080...0x0000_007f => I8,\n-            -0x0000_8000...0x0000_7fff => I16,\n-            -0x8000_0000...0x7fff_ffff => I32,\n-            _ => I64\n+            -0x0000_0000_0000_0001...0x0000_0000_0000_0000 => I1,\n+            -0x0000_0000_0000_0080...0x0000_0000_0000_007f => I8,\n+            -0x0000_0000_0000_8000...0x0000_0000_0000_7fff => I16,\n+            -0x0000_0000_8000_0000...0x0000_0000_7fff_ffff => I32,\n+            -0x8000_0000_0000_0000...0x7fff_ffff_ffff_ffff => I64,\n+            _ => I128\n         }\n     }\n \n     /// Find the smallest Integer type which can represent the unsigned value.\n     pub fn fit_unsigned(x: u64) -> Integer {\n         match x {\n-            0...0x0000_0001 => I1,\n-            0...0x0000_00ff => I8,\n-            0...0x0000_ffff => I16,\n-            0...0xffff_ffff => I32,\n-            _ => I64\n+            0...0x0000_0000_0000_0001 => I1,\n+            0...0x0000_0000_0000_00ff => I8,\n+            0...0x0000_0000_0000_ffff => I16,\n+            0...0x0000_0000_ffff_ffff => I32,\n+            0...0xffff_ffff_ffff_ffff => I64,\n+            _ => I128,\n         }\n     }\n \n@@ -406,6 +427,7 @@ impl Integer {\n             attr::SignedInt(IntTy::I16) | attr::UnsignedInt(UintTy::U16) => I16,\n             attr::SignedInt(IntTy::I32) | attr::UnsignedInt(UintTy::U32) => I32,\n             attr::SignedInt(IntTy::I64) | attr::UnsignedInt(UintTy::U64) => I64,\n+            attr::SignedInt(IntTy::I128) | attr::UnsignedInt(UintTy::U128) => I128,\n             attr::SignedInt(IntTy::Is) | attr::UnsignedInt(UintTy::Us) => {\n                 dl.ptr_sized_integer()\n             }\n@@ -486,6 +508,7 @@ impl Primitive {\n             Int(I16) => Size::from_bits(16),\n             Int(I32) | F32 => Size::from_bits(32),\n             Int(I64) | F64 => Size::from_bits(64),\n+            Int(I128) => Size::from_bits(128),\n             Pointer => dl.pointer_size\n         }\n     }\n@@ -497,6 +520,7 @@ impl Primitive {\n             Int(I16) => dl.i16_align,\n             Int(I32) => dl.i32_align,\n             Int(I64) => dl.i64_align,\n+            Int(I128) => dl.i128_align,\n             F32 => dl.f32_align,\n             F64 => dl.f64_align,\n             Pointer => dl.pointer_align\n@@ -1175,19 +1199,30 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                 if def.is_enum() && def.variants.iter().all(|v| v.fields.is_empty()) {\n                     // All bodies empty -> intlike\n-                    let (mut min, mut max, mut non_zero) = (i64::MAX, i64::MIN, true);\n+                    let (mut min, mut max, mut non_zero) = (i64::max_value(),\n+                                                            i64::min_value(),\n+                                                            true);\n                     for v in &def.variants {\n-                        let x = v.disr_val.to_u64_unchecked() as i64;\n+                        let x = match v.disr_val.erase_type() {\n+                            ConstInt::InferSigned(i) => i as i64,\n+                            ConstInt::Infer(i) => i as u64 as i64,\n+                            _ => bug!()\n+                        };\n                         if x == 0 { non_zero = false; }\n                         if x < min { min = x; }\n                         if x > max { max = x; }\n                     }\n \n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..], min, max);\n+                    // FIXME: should handle i128? signed-value based impl is weird and hard to\n+                    // grok.\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..],\n+                                                              min,\n+                                                              max);\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n                         non_zero: non_zero,\n+                        // FIXME: should be u128?\n                         min: min as u64,\n                         max: max as u64\n                     });\n@@ -1232,7 +1267,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // non-empty body, explicit discriminants should have\n                 // been rejected by a checker before this point.\n                 for (i, v) in def.variants.iter().enumerate() {\n-                    if i as u64 != v.disr_val.to_u64_unchecked() {\n+                    if i as u128 != v.disr_val.to_u128_unchecked() {\n                         bug!(\"non-C-like enum {} with specified discriminants\",\n                             tcx.item_path_str(def.did));\n                     }"}, {"sha": "0b45ff94a93123bffad6a5c2f6ba43626a3bd439", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -51,11 +51,13 @@ impl IntTypeExt for attr::IntType {\n             SignedInt(ast::IntTy::I16)     => tcx.types.i16,\n             SignedInt(ast::IntTy::I32)     => tcx.types.i32,\n             SignedInt(ast::IntTy::I64)     => tcx.types.i64,\n+            SignedInt(ast::IntTy::I128)     => tcx.types.i128,\n             SignedInt(ast::IntTy::Is)   => tcx.types.isize,\n             UnsignedInt(ast::UintTy::U8)    => tcx.types.u8,\n             UnsignedInt(ast::UintTy::U16)   => tcx.types.u16,\n             UnsignedInt(ast::UintTy::U32)   => tcx.types.u32,\n             UnsignedInt(ast::UintTy::U64)   => tcx.types.u64,\n+            UnsignedInt(ast::UintTy::U128)   => tcx.types.u128,\n             UnsignedInt(ast::UintTy::Us) => tcx.types.usize,\n         }\n     }\n@@ -66,6 +68,7 @@ impl IntTypeExt for attr::IntType {\n             SignedInt(ast::IntTy::I16)   => ConstInt::I16(0),\n             SignedInt(ast::IntTy::I32)   => ConstInt::I32(0),\n             SignedInt(ast::IntTy::I64)   => ConstInt::I64(0),\n+            SignedInt(ast::IntTy::I128)   => ConstInt::I128(0),\n             SignedInt(ast::IntTy::Is) => match tcx.sess.target.int_type {\n                 ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16(0)),\n                 ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32(0)),\n@@ -76,6 +79,7 @@ impl IntTypeExt for attr::IntType {\n             UnsignedInt(ast::UintTy::U16) => ConstInt::U16(0),\n             UnsignedInt(ast::UintTy::U32) => ConstInt::U32(0),\n             UnsignedInt(ast::UintTy::U64) => ConstInt::U64(0),\n+            UnsignedInt(ast::UintTy::U128) => ConstInt::U128(0),\n             UnsignedInt(ast::UintTy::Us) => match tcx.sess.target.uint_type {\n                 ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(0)),\n                 ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(0)),\n@@ -91,11 +95,13 @@ impl IntTypeExt for attr::IntType {\n             (SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => {},\n             (SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => {},\n             (SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => {},\n+            (SignedInt(ast::IntTy::I128), ConstInt::I128(_)) => {},\n             (SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) => {},\n             (UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => {},\n             (UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => {},\n             (UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => {},\n             (UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => {},\n+            (UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) => {},\n             (UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => {},\n             _ => bug!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n         }"}, {"sha": "7148e181bbd6d8aa0f8be0f0748b71f7bade0681", "filename": "src/librustc_const_eval/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -19,4 +19,5 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n syntax = { path = \"../libsyntax\" }\n graphviz = { path = \"../libgraphviz\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "c736b4865e73834ac605581ae7f5d4f89f5b39d6", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 52, "deletions": 37, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -43,6 +43,8 @@ use std::cmp::Ordering;\n use rustc_const_math::*;\n use rustc_errors::DiagnosticBuilder;\n \n+use rustc_i128::{i128, u128};\n+\n macro_rules! math {\n     ($e:expr, $op:expr) => {\n         match $op {\n@@ -588,38 +590,43 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if let hir::ExprLit(ref lit) = inner.node {\n             use syntax::ast::*;\n             use syntax::ast::LitIntType::*;\n-            const I8_OVERFLOW: u64 = ::std::i8::MAX as u64 + 1;\n-            const I16_OVERFLOW: u64 = ::std::i16::MAX as u64 + 1;\n-            const I32_OVERFLOW: u64 = ::std::i32::MAX as u64 + 1;\n-            const I64_OVERFLOW: u64 = ::std::i64::MAX as u64 + 1;\n+            const I8_OVERFLOW: u128 = i8::max_value() as u128 + 1;\n+            const I16_OVERFLOW: u128 = i16::max_value() as u128 + 1;\n+            const I32_OVERFLOW: u128 = i32::max_value() as u128 + 1;\n+            const I64_OVERFLOW: u128 = i64::max_value() as u128 + 1;\n+            const I128_OVERFLOW: u128 = i128::max_value() as u128 + 1;\n             match (&lit.node, ety.map(|t| &t.sty)) {\n                 (&LitKind::Int(I8_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I8))) |\n                 (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n-                    return Ok(Integral(I8(::std::i8::MIN)))\n+                    return Ok(Integral(I8(i8::min_value())))\n                 },\n                 (&LitKind::Int(I16_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I16))) |\n                 (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n-                    return Ok(Integral(I16(::std::i16::MIN)))\n+                    return Ok(Integral(I16(i16::min_value())))\n                 },\n                 (&LitKind::Int(I32_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I32))) |\n                 (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n-                    return Ok(Integral(I32(::std::i32::MIN)))\n+                    return Ok(Integral(I32(i32::min_value())))\n                 },\n                 (&LitKind::Int(I64_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I64))) |\n                 (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n-                    return Ok(Integral(I64(::std::i64::MIN)))\n+                    return Ok(Integral(I64(i64::min_value())))\n+                },\n+                (&LitKind::Int(I128_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I128))) |\n+                (&LitKind::Int(I128_OVERFLOW, Signed(IntTy::I128)), _) => {\n+                    return Ok(Integral(I128(i128::min_value())))\n                 },\n                 (&LitKind::Int(n, Unsuffixed), Some(&ty::TyInt(IntTy::Is))) |\n                 (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n                     match tcx.sess.target.int_type {\n                         IntTy::I16 => if n == I16_OVERFLOW {\n-                            return Ok(Integral(Isize(Is16(::std::i16::MIN))));\n+                            return Ok(Integral(Isize(Is16(i16::min_value()))));\n                         },\n                         IntTy::I32 => if n == I32_OVERFLOW {\n-                            return Ok(Integral(Isize(Is32(::std::i32::MIN))));\n+                            return Ok(Integral(Isize(Is32(i32::min_value()))));\n                         },\n                         IntTy::I64 => if n == I64_OVERFLOW {\n-                            return Ok(Integral(Isize(Is64(::std::i64::MIN))));\n+                            return Ok(Integral(Isize(Is64(i64::min_value()))));\n                         },\n                         _ => bug!(),\n                     }\n@@ -973,34 +980,39 @@ fn infer<'a, 'tcx>(i: ConstInt,\n         (&ty::TyInt(IntTy::I16), result @ I16(_)) => Ok(result),\n         (&ty::TyInt(IntTy::I32), result @ I32(_)) => Ok(result),\n         (&ty::TyInt(IntTy::I64), result @ I64(_)) => Ok(result),\n+        (&ty::TyInt(IntTy::I128), result @ I128(_)) => Ok(result),\n         (&ty::TyInt(IntTy::Is), result @ Isize(_)) => Ok(result),\n \n         (&ty::TyUint(UintTy::U8), result @ U8(_)) => Ok(result),\n         (&ty::TyUint(UintTy::U16), result @ U16(_)) => Ok(result),\n         (&ty::TyUint(UintTy::U32), result @ U32(_)) => Ok(result),\n         (&ty::TyUint(UintTy::U64), result @ U64(_)) => Ok(result),\n+        (&ty::TyUint(UintTy::U128), result @ U128(_)) => Ok(result),\n         (&ty::TyUint(UintTy::Us), result @ Usize(_)) => Ok(result),\n \n-        (&ty::TyInt(IntTy::I8), Infer(i)) => Ok(I8(i as i64 as i8)),\n-        (&ty::TyInt(IntTy::I16), Infer(i)) => Ok(I16(i as i64 as i16)),\n-        (&ty::TyInt(IntTy::I32), Infer(i)) => Ok(I32(i as i64 as i32)),\n-        (&ty::TyInt(IntTy::I64), Infer(i)) => Ok(I64(i as i64)),\n+        (&ty::TyInt(IntTy::I8), Infer(i)) => Ok(I8(i as i128 as i8)),\n+        (&ty::TyInt(IntTy::I16), Infer(i)) => Ok(I16(i as i128 as i16)),\n+        (&ty::TyInt(IntTy::I32), Infer(i)) => Ok(I32(i as i128 as i32)),\n+        (&ty::TyInt(IntTy::I64), Infer(i)) => Ok(I64(i as i128 as i64)),\n+        (&ty::TyInt(IntTy::I128), Infer(i)) => Ok(I128(i as i128)),\n         (&ty::TyInt(IntTy::Is), Infer(i)) => {\n-            Ok(Isize(ConstIsize::new_truncating(i as i64, tcx.sess.target.int_type)))\n+            Ok(Isize(ConstIsize::new_truncating(i as i128, tcx.sess.target.int_type)))\n         },\n \n         (&ty::TyInt(IntTy::I8), InferSigned(i)) => Ok(I8(i as i8)),\n         (&ty::TyInt(IntTy::I16), InferSigned(i)) => Ok(I16(i as i16)),\n         (&ty::TyInt(IntTy::I32), InferSigned(i)) => Ok(I32(i as i32)),\n-        (&ty::TyInt(IntTy::I64), InferSigned(i)) => Ok(I64(i)),\n+        (&ty::TyInt(IntTy::I64), InferSigned(i)) => Ok(I64(i as i64)),\n+        (&ty::TyInt(IntTy::I128), InferSigned(i)) => Ok(I128(i)),\n         (&ty::TyInt(IntTy::Is), InferSigned(i)) => {\n             Ok(Isize(ConstIsize::new_truncating(i, tcx.sess.target.int_type)))\n         },\n \n         (&ty::TyUint(UintTy::U8), Infer(i)) => Ok(U8(i as u8)),\n         (&ty::TyUint(UintTy::U16), Infer(i)) => Ok(U16(i as u16)),\n         (&ty::TyUint(UintTy::U32), Infer(i)) => Ok(U32(i as u32)),\n-        (&ty::TyUint(UintTy::U64), Infer(i)) => Ok(U64(i)),\n+        (&ty::TyUint(UintTy::U64), Infer(i)) => Ok(U64(i as u64)),\n+        (&ty::TyUint(UintTy::U128), Infer(i)) => Ok(U128(i)),\n         (&ty::TyUint(UintTy::Us), Infer(i)) => {\n             Ok(Usize(ConstUsize::new_truncating(i, tcx.sess.target.uint_type)))\n         },\n@@ -1071,21 +1083,23 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n }\n \n fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n-    let v = val.to_u64_unchecked();\n+    let v = val.to_u128_unchecked();\n     match ty.sty {\n         ty::TyBool if v == 0 => Ok(Bool(false)),\n         ty::TyBool if v == 1 => Ok(Bool(true)),\n-        ty::TyInt(ast::IntTy::I8) => Ok(Integral(I8(v as i64 as i8))),\n-        ty::TyInt(ast::IntTy::I16) => Ok(Integral(I16(v as i64 as i16))),\n-        ty::TyInt(ast::IntTy::I32) => Ok(Integral(I32(v as i64 as i32))),\n-        ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i64))),\n+        ty::TyInt(ast::IntTy::I8) => Ok(Integral(I8(v as i128 as i8))),\n+        ty::TyInt(ast::IntTy::I16) => Ok(Integral(I16(v as i128 as i16))),\n+        ty::TyInt(ast::IntTy::I32) => Ok(Integral(I32(v as i128 as i32))),\n+        ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i128 as i64))),\n+        ty::TyInt(ast::IntTy::I128) => Ok(Integral(I128(v as i128))),\n         ty::TyInt(ast::IntTy::Is) => {\n-            Ok(Integral(Isize(ConstIsize::new_truncating(v as i64, tcx.sess.target.int_type))))\n+            Ok(Integral(Isize(ConstIsize::new_truncating(v as i128, tcx.sess.target.int_type))))\n         },\n         ty::TyUint(ast::UintTy::U8) => Ok(Integral(U8(v as u8))),\n         ty::TyUint(ast::UintTy::U16) => Ok(Integral(U16(v as u16))),\n         ty::TyUint(ast::UintTy::U32) => Ok(Integral(U32(v as u32))),\n-        ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v))),\n+        ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v as u64))),\n+        ty::TyUint(ast::UintTy::U128) => Ok(Integral(U128(v as u128))),\n         ty::TyUint(ast::UintTy::Us) => {\n             Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.uint_type))))\n         },\n@@ -1115,13 +1129,13 @@ fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match ty.sty {\n         ty::TyInt(_) | ty::TyUint(_) => {\n             let i = match val {\n-                F32(f) if f >= 0.0 => Infer(f as u64),\n+                F32(f) if f >= 0.0 => Infer(f as u128),\n                 FInfer { f64: f, .. } |\n-                F64(f) if f >= 0.0 => Infer(f as u64),\n+                F64(f) if f >= 0.0 => Infer(f as u128),\n \n-                F32(f) => InferSigned(f as i64),\n+                F32(f) => InferSigned(f as i128),\n                 FInfer { f64: f, .. } |\n-                F64(f) => InferSigned(f as i64)\n+                F64(f) => InferSigned(f as i128)\n             };\n \n             if let (InferSigned(_), &ty::TyUint(_)) = (i, &ty.sty) {\n@@ -1145,9 +1159,9 @@ fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n     match val {\n         Integral(i) => cast_const_int(tcx, i, ty),\n-        Bool(b) => cast_const_int(tcx, Infer(b as u64), ty),\n+        Bool(b) => cast_const_int(tcx, Infer(b as u128), ty),\n         Float(f) => cast_const_float(tcx, f, ty),\n-        Char(c) => cast_const_int(tcx, Infer(c as u64), ty),\n+        Char(c) => cast_const_int(tcx, Infer(c as u128), ty),\n         Function(_) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n         ByteStr(b) => match ty.sty {\n             ty::TyRawPtr(_) => {\n@@ -1185,28 +1199,29 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n         LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n         LitKind::Int(n, Signed(ity)) => {\n-            infer(InferSigned(n as i64), tcx, &ty::TyInt(ity)).map(Integral)\n+            infer(InferSigned(n as i128), tcx, &ty::TyInt(ity)).map(Integral)\n         },\n \n+        // FIXME: this should become u128.\n         LitKind::Int(n, Unsuffixed) => {\n             match ty_hint.map(|t| &t.sty) {\n                 Some(&ty::TyInt(ity)) => {\n-                    infer(InferSigned(n as i64), tcx, &ty::TyInt(ity)).map(Integral)\n+                    infer(InferSigned(n as i128), tcx, &ty::TyInt(ity)).map(Integral)\n                 },\n                 Some(&ty::TyUint(uty)) => {\n-                    infer(Infer(n), tcx, &ty::TyUint(uty)).map(Integral)\n+                    infer(Infer(n as u128), tcx, &ty::TyUint(uty)).map(Integral)\n                 },\n-                None => Ok(Integral(Infer(n))),\n+                None => Ok(Integral(Infer(n as u128))),\n                 Some(&ty::TyAdt(adt, _)) => {\n                     let hints = tcx.lookup_repr_hints(adt.did);\n                     let int_ty = tcx.enum_repr_type(hints.iter().next());\n-                    infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty).map(Integral)\n+                    infer(Infer(n as u128), tcx, &int_ty.to_ty(tcx).sty).map(Integral)\n                 },\n                 Some(ty_hint) => bug!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n             }\n         },\n         LitKind::Int(n, Unsigned(ity)) => {\n-            infer(Infer(n), tcx, &ty::TyUint(ity)).map(Integral)\n+            infer(Infer(n as u128), tcx, &ty::TyUint(ity)).map(Integral)\n         },\n \n         LitKind::Float(n, fty) => {"}, {"sha": "67b4efdbd1f4474518860ae445b7cdaa5bd20408", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -28,6 +28,7 @@\n #![feature(slice_patterns)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(const_fn)]\n \n extern crate arena;\n #[macro_use] extern crate syntax;\n@@ -41,6 +42,8 @@ extern crate graphviz;\n extern crate syntax_pos;\n extern crate serialize as rustc_serialize; // used by deriving\n \n+extern crate rustc_i128;\n+\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;"}, {"sha": "3d7a4865e45af62fe436b883dd409b0a8ec3dff0", "filename": "src/librustc_const_math/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_math%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_math%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2FCargo.toml?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -12,3 +12,4 @@ crate-type = [\"dylib\"]\n log = { path = \"../liblog\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "1e9c2badd686096be1a1269c42b8b7c5bf6ce1a3", "filename": "src/librustc_const_math/err.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_math%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_math%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ferr.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -74,11 +74,13 @@ impl ConstMathErr {\n             ULitOutOfRange(ast::UintTy::U16) => \"literal out of range for u16\",\n             ULitOutOfRange(ast::UintTy::U32) => \"literal out of range for u32\",\n             ULitOutOfRange(ast::UintTy::U64) => \"literal out of range for u64\",\n+            ULitOutOfRange(ast::UintTy::U128) => \"literal out of range for u128\",\n             ULitOutOfRange(ast::UintTy::Us) => \"literal out of range for usize\",\n             LitOutOfRange(ast::IntTy::I8) => \"literal out of range for i8\",\n             LitOutOfRange(ast::IntTy::I16) => \"literal out of range for i16\",\n             LitOutOfRange(ast::IntTy::I32) => \"literal out of range for i32\",\n             LitOutOfRange(ast::IntTy::I64) => \"literal out of range for i64\",\n+            LitOutOfRange(ast::IntTy::I128) => \"literal out of range for i128\",\n             LitOutOfRange(ast::IntTy::Is) => \"literal out of range for isize\",\n         }\n     }"}, {"sha": "59eb4b70aa8ff4eba799748a6af0718cae9c57b7", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 213, "deletions": 126, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -11,6 +11,7 @@\n use std::cmp::Ordering;\n use syntax::attr::IntType;\n use syntax::ast::{IntTy, UintTy};\n+use rustc_i128::{i128, u128};\n \n use super::is::*;\n use super::us::*;\n@@ -22,92 +23,153 @@ pub enum ConstInt {\n     I16(i16),\n     I32(i32),\n     I64(i64),\n+    I128(i128),\n     Isize(ConstIsize),\n     U8(u8),\n     U16(u16),\n     U32(u32),\n     U64(u64),\n+    U128(u128),\n     Usize(ConstUsize),\n-    Infer(u64),\n-    InferSigned(i64),\n+    Infer(u128),\n+    InferSigned(i128),\n }\n pub use self::ConstInt::*;\n \n \n macro_rules! bounds {\n-    ($($t:ident $min:ident $max:ident)*) => {\n-        mod as_u64 {\n-            $(\n-                #[allow(dead_code)]\n-                pub const $min: u64 = ::std::$t::MIN as u64;\n-                #[allow(dead_code)]\n-                pub const $max: u64 = ::std::$t::MAX as u64;\n-            )*\n-        }\n-        mod as_i64 {\n-            $(\n-                #[allow(dead_code)]\n-                pub const $min: i64 = ::std::$t::MIN as i64;\n-                #[allow(dead_code)]\n-                pub const $max: i64 = ::std::$t::MAX as i64;\n-            )*\n-        }\n+    ($ct: ty, $($t:ident $min:ident $max:ident)*) => {\n+        $(\n+            pub const $min: $ct = $t::min_value() as $ct;\n+            pub const $max: $ct = $t::max_value() as $ct;\n+        )*\n+    };\n+    ($ct: ty: $min_val: expr, $($t:ident $min:ident $max:ident)*) => {\n+        $(\n+            pub const $min: $ct = $min_val;\n+            pub const $max: $ct = $t::max_value() as $ct;\n+        )*\n+    }\n+}\n+\n+mod ubounds {\n+    #![allow(dead_code)]\n+    use rustc_i128::{u128, i128};\n+    bounds!{u128: 0,\n+        i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX i128 I128MIN I128MAX\n+        u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX u64 U64MIN U64MAX u128 U128MIN U128MAX\n+        // do not add constants for isize/usize, because these are guaranteed to be wrong for\n+        // arbitrary host/target combinations\n     }\n }\n \n-bounds!{\n-    i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX isize IMIN IMAX\n-    u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX u64 U64MIN U64MAX usize UMIN UMAX\n+mod ibounds {\n+    #![allow(dead_code)]\n+    use rustc_i128::i128;\n+    #[cfg(stage0)]\n+    pub const U64MIN: i128 = 0;\n+    #[cfg(stage0)]\n+    pub const U64MAX: i128 = i128::max_value();\n+    #[cfg(not(stage0))]\n+    bounds!(i128, u64 U64MIN U64MAX);\n+\n+    pub const U128MIN: i128 = 0;\n+    pub const U128MAX: i128 = i128::max_value();\n+\n+    bounds!{i128,\n+        i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX i128 I128MIN I128MAX\n+        u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX\n+        // do not add constants for isize/usize, because these are guaranteed to be wrong for\n+        // arbitrary host/target combinations\n+    }\n }\n \n impl ConstInt {\n+    /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n+    /// not happen.\n+    pub fn new_unsigned(val: u128, ty: UintTy, usize_ty: UintTy) -> Option<ConstInt> {\n+        match ty {\n+            UintTy::U8 if val <= ubounds::U8MAX => Some(U8(val as u8)),\n+            UintTy::U16 if val <= ubounds::U16MAX => Some(U16(val as u16)),\n+            UintTy::U32 if val <= ubounds::U32MAX => Some(U32(val as u32)),\n+            UintTy::U64 if val <= ubounds::U64MAX => Some(U64(val as u64)),\n+            UintTy::Us if val <= ubounds::U64MAX => ConstUsize::new(val as u64, usize_ty).ok()\n+                .map(Usize),\n+            UintTy::U128 => Some(U128(val)),\n+            _ => None\n+        }\n+    }\n+\n+    /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n+    /// not happen.\n+    pub fn new_signed(val: i128, ty: IntTy, isize_ty: IntTy) -> Option<ConstInt> {\n+        match ty {\n+            IntTy::I8 if val <= ibounds::I8MAX => Some(I8(val as i8)),\n+            IntTy::I16 if val <= ibounds::I16MAX => Some(I16(val as i16)),\n+            IntTy::I32 if val <= ibounds::I32MAX => Some(I32(val as i32)),\n+            IntTy::I64 if val <= ibounds::I64MAX => Some(I64(val as i64)),\n+            IntTy::Is if val <= ibounds::I64MAX => ConstIsize::new(val as i64, isize_ty).ok()\n+                .map(Isize),\n+            IntTy::I128 => Some(I128(val)),\n+            _ => None\n+        }\n+    }\n+\n     /// If either value is `Infer` or `InferSigned`, try to turn the value into the type of\n     /// the other value. If both values have no type, don't do anything\n     pub fn infer(self, other: Self) -> Result<(Self, Self), ConstMathErr> {\n         let inferred = match (self, other) {\n             (InferSigned(_), InferSigned(_))\n             | (Infer(_), Infer(_)) => self, // no inference possible\n             // kindof wrong, you could have had values > I64MAX during computation of a\n-            (Infer(a @ 0...as_u64::I64MAX), InferSigned(_)) => InferSigned(a as i64),\n+            (Infer(a @ 0...ubounds::I64MAX), InferSigned(_)) => InferSigned(a as i128),\n             (Infer(_), InferSigned(_)) => return Err(ConstMathErr::NotInRange),\n             (_, InferSigned(_))\n             | (_, Infer(_)) => return other.infer(self).map(|(b, a)| (a, b)),\n \n-            (Infer(a @ 0...as_u64::I8MAX), I8(_)) => I8(a as i64 as i8),\n-            (Infer(a @ 0...as_u64::I16MAX), I16(_)) => I16(a as i64 as i16),\n-            (Infer(a @ 0...as_u64::I32MAX), I32(_)) => I32(a as i64 as i32),\n-            (Infer(a @ 0...as_u64::I64MAX), I64(_)) => I64(a as i64),\n-            (Infer(a @ 0...as_u64::I16MAX), Isize(Is16(_))) => Isize(Is16(a as i64 as i16)),\n-            (Infer(a @ 0...as_u64::I32MAX), Isize(Is32(_))) => Isize(Is32(a as i64 as i32)),\n-            (Infer(a @ 0...as_u64::I64MAX), Isize(Is64(_))) => Isize(Is64(a as i64)),\n-            (Infer(a @ 0...as_u64::U8MAX), U8(_)) => U8(a as u8),\n-            (Infer(a @ 0...as_u64::U16MAX), U16(_)) => U16(a as u16),\n-            (Infer(a @ 0...as_u64::U32MAX), U32(_)) => U32(a as u32),\n-            (Infer(a), U64(_)) => U64(a),\n-            (Infer(a @ 0...as_u64::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n-            (Infer(a @ 0...as_u64::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n-            (Infer(a), Usize(Us64(_))) => Usize(Us64(a)),\n+            (Infer(a @ 0...ubounds::I8MAX), I8(_)) => I8(a as i64 as i8),\n+            (Infer(a @ 0...ubounds::I16MAX), I16(_)) => I16(a as i64 as i16),\n+            (Infer(a @ 0...ubounds::I32MAX), I32(_)) => I32(a as i64 as i32),\n+            (Infer(a @ 0...ubounds::I64MAX), I64(_)) => I64(a as i64),\n+            (Infer(a @ 0...ubounds::I128MAX), I128(_)) => I128(a as i128),\n+            (Infer(a @ 0...ubounds::I16MAX), Isize(Is16(_))) => Isize(Is16(a as i64 as i16)),\n+            (Infer(a @ 0...ubounds::I32MAX), Isize(Is32(_))) => Isize(Is32(a as i64 as i32)),\n+            (Infer(a @ 0...ubounds::I64MAX), Isize(Is64(_))) => Isize(Is64(a as i64)),\n+            (Infer(a @ 0...ubounds::U8MAX), U8(_)) => U8(a as u8),\n+            (Infer(a @ 0...ubounds::U16MAX), U16(_)) => U16(a as u16),\n+            (Infer(a @ 0...ubounds::U32MAX), U32(_)) => U32(a as u32),\n+            (Infer(a @ 0...ubounds::U64MAX), U64(_)) => U64(a as u64),\n+            (Infer(a @ 0...ubounds::U128MAX), U128(_)) => U128(a as u128),\n+            (Infer(a @ 0...ubounds::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n+            (Infer(a @ 0...ubounds::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n+            (Infer(a @ 0...ubounds::U64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n \n             (Infer(_), _) => return Err(ConstMathErr::NotInRange),\n \n-            (InferSigned(a @ as_i64::I8MIN...as_i64::I8MAX), I8(_)) => I8(a as i8),\n-            (InferSigned(a @ as_i64::I16MIN...as_i64::I16MAX), I16(_)) => I16(a as i16),\n-            (InferSigned(a @ as_i64::I32MIN...as_i64::I32MAX), I32(_)) => I32(a as i32),\n-            (InferSigned(a), I64(_)) => I64(a),\n-            (InferSigned(a @ as_i64::I16MIN...as_i64::I16MAX), Isize(Is16(_))) => {\n+            (InferSigned(a @ ibounds::I8MIN...ibounds::I8MAX), I8(_)) => I8(a as i8),\n+            (InferSigned(a @ ibounds::I16MIN...ibounds::I16MAX), I16(_)) => I16(a as i16),\n+            (InferSigned(a @ ibounds::I32MIN...ibounds::I32MAX), I32(_)) => I32(a as i32),\n+            (InferSigned(a @ ibounds::I64MIN...ibounds::I64MAX), I64(_)) => I64(a as i64),\n+            (InferSigned(a @ ibounds::I128MIN...ibounds::I128MAX), I128(_)) => I128(a as i128),\n+            (InferSigned(a @ ibounds::I16MIN...ibounds::I16MAX), Isize(Is16(_))) => {\n                 Isize(Is16(a as i16))\n             },\n-            (InferSigned(a @ as_i64::I32MIN...as_i64::I32MAX), Isize(Is32(_))) => {\n+            (InferSigned(a @ ibounds::I32MIN...ibounds::I32MAX), Isize(Is32(_))) => {\n                 Isize(Is32(a as i32))\n             },\n-            (InferSigned(a), Isize(Is64(_))) => Isize(Is64(a)),\n-            (InferSigned(a @ 0...as_i64::U8MAX), U8(_)) => U8(a as u8),\n-            (InferSigned(a @ 0...as_i64::U16MAX), U16(_)) => U16(a as u16),\n-            (InferSigned(a @ 0...as_i64::U32MAX), U32(_)) => U32(a as u32),\n-            (InferSigned(a @ 0...as_i64::I64MAX), U64(_)) => U64(a as u64),\n-            (InferSigned(a @ 0...as_i64::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n-            (InferSigned(a @ 0...as_i64::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n-            (InferSigned(a @ 0...as_i64::I64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n+            (InferSigned(a @ ibounds::I64MIN...ibounds::I64MAX), Isize(Is64(_))) => {\n+                Isize(Is64(a as i64))\n+            },\n+            (InferSigned(a @ 0...ibounds::U8MAX), U8(_)) => U8(a as u8),\n+            (InferSigned(a @ 0...ibounds::U16MAX), U16(_)) => U16(a as u16),\n+            (InferSigned(a @ 0...ibounds::U32MAX), U32(_)) => U32(a as u32),\n+            // SNAP: replace with U64MAX\n+            (InferSigned(a @ 0...ibounds::I64MAX), U64(_)) => U64(a as u64),\n+            (InferSigned(a @ 0...ibounds::I128MAX), U128(_)) => U128(a as u128),\n+            (InferSigned(a @ 0...ibounds::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n+            (InferSigned(a @ 0...ibounds::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n+            // SNAP: replace with U64MAX\n+            (InferSigned(a @ 0...ibounds::I64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n             (InferSigned(_), _) => return Err(ConstMathErr::NotInRange),\n             _ => self, // already known types\n         };\n@@ -119,28 +181,31 @@ impl ConstInt {\n         match self {\n             Infer(i) => Infer(i),\n             InferSigned(i) if i < 0 => InferSigned(i),\n-            I8(i) if i < 0 => InferSigned(i as i64),\n-            I16(i) if i < 0 => InferSigned(i as i64),\n-            I32(i) if i < 0 => InferSigned(i as i64),\n-            I64(i) if i < 0 => InferSigned(i as i64),\n-            Isize(Is16(i)) if i < 0 => InferSigned(i as i64),\n-            Isize(Is32(i)) if i < 0 => InferSigned(i as i64),\n-            Isize(Is64(i)) if i < 0 => InferSigned(i as i64),\n-            InferSigned(i) => Infer(i as u64),\n-            I8(i) => Infer(i as u64),\n-            I16(i) => Infer(i as u64),\n-            I32(i) => Infer(i as u64),\n-            I64(i) => Infer(i as u64),\n-            Isize(Is16(i)) => Infer(i as u64),\n-            Isize(Is32(i)) => Infer(i as u64),\n-            Isize(Is64(i)) => Infer(i as u64),\n-            U8(i) => Infer(i as u64),\n-            U16(i) => Infer(i as u64),\n-            U32(i) => Infer(i as u64),\n-            U64(i) => Infer(i as u64),\n-            Usize(Us16(i)) => Infer(i as u64),\n-            Usize(Us32(i)) => Infer(i as u64),\n-            Usize(Us64(i)) => Infer(i),\n+            I8(i) if i < 0 => InferSigned(i as i128),\n+            I16(i) if i < 0 => InferSigned(i as i128),\n+            I32(i) if i < 0 => InferSigned(i as i128),\n+            I64(i) if i < 0 => InferSigned(i as i128),\n+            I128(i) if i < 0 => InferSigned(i as i128),\n+            Isize(Is16(i)) if i < 0 => InferSigned(i as i128),\n+            Isize(Is32(i)) if i < 0 => InferSigned(i as i128),\n+            Isize(Is64(i)) if i < 0 => InferSigned(i as i128),\n+            InferSigned(i) => Infer(i as u128),\n+            I8(i) => Infer(i as u128),\n+            I16(i) => Infer(i as u128),\n+            I32(i) => Infer(i as u128),\n+            I64(i) => Infer(i as u128),\n+            I128(i) => Infer(i as u128),\n+            Isize(Is16(i)) => Infer(i as u128),\n+            Isize(Is32(i)) => Infer(i as u128),\n+            Isize(Is64(i)) => Infer(i as u128),\n+            U8(i) => Infer(i as u128),\n+            U16(i) => Infer(i as u128),\n+            U32(i) => Infer(i as u128),\n+            U64(i) => Infer(i as u128),\n+            U128(i) => Infer(i as u128),\n+            Usize(Us16(i)) => Infer(i as u128),\n+            Usize(Us32(i)) => Infer(i as u128),\n+            Usize(Us64(i)) => Infer(i as u128),\n         }\n     }\n \n@@ -153,67 +218,66 @@ impl ConstInt {\n             I16(_) => \"i16\",\n             I32(_) => \"i32\",\n             I64(_) => \"i64\",\n+            I128(_) => \"i128\",\n             Isize(_) => \"isize\",\n             U8(_) => \"u8\",\n             U16(_) => \"u16\",\n             U32(_) => \"u32\",\n             U64(_) => \"u64\",\n+            U128(_) => \"u128\",\n             Usize(_) => \"usize\",\n         }\n     }\n \n-    /// Erases the type and returns a u64.\n-    /// This is not the same as `-5i8 as u64` but as `-5i8 as i64 as u64`\n-    pub fn to_u64_unchecked(self) -> u64 {\n+    /// Erases the type and returns a u128.\n+    /// This is not the same as `-5i8 as u128` but as `-5i8 as i128 as u128`\n+    pub fn to_u128_unchecked(self) -> u128 {\n         match self.erase_type() {\n             ConstInt::Infer(i) => i,\n-            ConstInt::InferSigned(i) => i as u64,\n+            ConstInt::InferSigned(i) => i as u128,\n             _ => unreachable!(),\n         }\n     }\n \n     /// Converts the value to a `u32` if it's in the range 0...std::u32::MAX\n     pub fn to_u32(&self) -> Option<u32> {\n-        match *self {\n-            I8(v) if v >= 0 => Some(v as u32),\n-            I16(v) if v >= 0 => Some(v as u32),\n-            I32(v) if v >= 0 => Some(v as u32),\n-            InferSigned(v)\n-            | Isize(Is64(v))\n-            | I64(v) if v >= 0 && v <= ::std::u32::MAX as i64 => Some(v as u32),\n-            Isize(Is32(v)) if v >= 0 => Some(v as u32),\n-            Isize(Is16(v)) if v >= 0 => Some(v as u32),\n-            U8(v) => Some(v as u32),\n-            U16(v) => Some(v as u32),\n-            U32(v) => Some(v),\n-            Infer(v)\n-            | Usize(Us64(v))\n-            | U64(v) if v <= ::std::u32::MAX as u64 => Some(v as u32),\n-            Usize(Us32(v)) => Some(v),\n-            Usize(Us16(v)) => Some(v as u32),\n-            _ => None,\n-        }\n+        self.to_u128().and_then(|v| if v <= u32::max_value() as u128 {\n+            Some(v as u32)\n+        } else {\n+            None\n+        })\n     }\n \n-    /// Converts the value to a `u64` if it's >= 0\n+    /// Converts the value to a `u64` if it's in the range 0...std::u64::MAX\n     pub fn to_u64(&self) -> Option<u64> {\n+        self.to_u128().and_then(|v| if v <= u64::max_value() as u128 {\n+            Some(v as u64)\n+        } else {\n+            None\n+        })\n+    }\n+\n+    /// Converts the value to a `u128` if it's in the range 0...std::u128::MAX\n+    pub fn to_u128(&self) -> Option<u128> {\n         match *self {\n             Infer(v) => Some(v),\n-            InferSigned(v) if v >= 0 => Some(v as u64),\n-            I8(v) if v >= 0 => Some(v as u64),\n-            I16(v) if v >= 0 => Some(v as u64),\n-            I32(v) if v >= 0 => Some(v as u64),\n-            I64(v) if v >= 0 => Some(v as u64),\n-            Isize(Is16(v)) if v >= 0 => Some(v as u64),\n-            Isize(Is32(v)) if v >= 0 => Some(v as u64),\n-            Isize(Is64(v)) if v >= 0 => Some(v as u64),\n-            U8(v) => Some(v as u64),\n-            U16(v) => Some(v as u64),\n-            U32(v) => Some(v as u64),\n-            U64(v) => Some(v),\n-            Usize(Us16(v)) => Some(v as u64),\n-            Usize(Us32(v)) => Some(v as u64),\n-            Usize(Us64(v)) => Some(v),\n+            InferSigned(v) if v >= 0 => Some(v as u128),\n+            I8(v) if v >= 0 => Some(v as u128),\n+            I16(v) if v >= 0 => Some(v as u128),\n+            I32(v) if v >= 0 => Some(v as u128),\n+            I64(v) if v >= 0 => Some(v as u128),\n+            I128(v) if v >= 0 => Some(v as u128),\n+            Isize(Is16(v)) if v >= 0 => Some(v as u128),\n+            Isize(Is32(v)) if v >= 0 => Some(v as u128),\n+            Isize(Is64(v)) if v >= 0 => Some(v as u128),\n+            U8(v) => Some(v as u128),\n+            U16(v) => Some(v as u128),\n+            U32(v) => Some(v as u128),\n+            U64(v) => Some(v as u128),\n+            U128(v) => Some(v as u128),\n+            Usize(Us16(v)) => Some(v as u128),\n+            Usize(Us32(v)) => Some(v as u128),\n+            Usize(Us64(v)) => Some(v as u128),\n             _ => None,\n         }\n     }\n@@ -224,6 +288,7 @@ impl ConstInt {\n             I16(v) => v < 0,\n             I32(v) => v < 0,\n             I64(v) => v < 0,\n+            I128(v) => v < 0,\n             Isize(Is16(v)) => v < 0,\n             Isize(Is32(v)) => v < 0,\n             Isize(Is64(v)) => v < 0,\n@@ -239,13 +304,15 @@ impl ConstInt {\n             (I16(a), I16(b)) => Ok(a.cmp(&b)),\n             (I32(a), I32(b)) => Ok(a.cmp(&b)),\n             (I64(a), I64(b)) => Ok(a.cmp(&b)),\n+            (I128(a), I128(b)) => Ok(a.cmp(&b)),\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(a.cmp(&b)),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(a.cmp(&b)),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(a.cmp(&b)),\n             (U8(a), U8(b)) => Ok(a.cmp(&b)),\n             (U16(a), U16(b)) => Ok(a.cmp(&b)),\n             (U32(a), U32(b)) => Ok(a.cmp(&b)),\n             (U64(a), U64(b)) => Ok(a.cmp(&b)),\n+            (U128(a), U128(b)) => Ok(a.cmp(&b)),\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(a.cmp(&b)),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(a.cmp(&b)),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(a.cmp(&b)),\n@@ -265,13 +332,15 @@ impl ConstInt {\n             ConstInt::I16(i) => ConstInt::I16(add1!(i)),\n             ConstInt::I32(i) => ConstInt::I32(add1!(i)),\n             ConstInt::I64(i) => ConstInt::I64(add1!(i)),\n+            ConstInt::I128(i) => ConstInt::I128(add1!(i)),\n             ConstInt::Isize(ConstIsize::Is16(i)) => ConstInt::Isize(ConstIsize::Is16(add1!(i))),\n             ConstInt::Isize(ConstIsize::Is32(i)) => ConstInt::Isize(ConstIsize::Is32(add1!(i))),\n             ConstInt::Isize(ConstIsize::Is64(i)) => ConstInt::Isize(ConstIsize::Is64(add1!(i))),\n             ConstInt::U8(i) => ConstInt::U8(add1!(i)),\n             ConstInt::U16(i) => ConstInt::U16(add1!(i)),\n             ConstInt::U32(i) => ConstInt::U32(add1!(i)),\n             ConstInt::U64(i) => ConstInt::U64(add1!(i)),\n+            ConstInt::U128(i) => ConstInt::U128(add1!(i)),\n             ConstInt::Usize(ConstUsize::Us16(i)) => ConstInt::Usize(ConstUsize::Us16(add1!(i))),\n             ConstInt::Usize(ConstUsize::Us32(i)) => ConstInt::Usize(ConstUsize::Us32(add1!(i))),\n             ConstInt::Usize(ConstUsize::Us64(i)) => ConstInt::Usize(ConstUsize::Us64(add1!(i))),\n@@ -285,11 +354,13 @@ impl ConstInt {\n             ConstInt::I16(_) => Some(IntType::SignedInt(IntTy::I16)),\n             ConstInt::I32(_) => Some(IntType::SignedInt(IntTy::I32)),\n             ConstInt::I64(_) => Some(IntType::SignedInt(IntTy::I64)),\n+            ConstInt::I128(_) => Some(IntType::SignedInt(IntTy::I128)),\n             ConstInt::Isize(_) => Some(IntType::SignedInt(IntTy::Is)),\n             ConstInt::U8(_) => Some(IntType::UnsignedInt(UintTy::U8)),\n             ConstInt::U16(_) => Some(IntType::UnsignedInt(UintTy::U16)),\n             ConstInt::U32(_) => Some(IntType::UnsignedInt(UintTy::U32)),\n             ConstInt::U64(_) => Some(IntType::UnsignedInt(UintTy::U64)),\n+            ConstInt::U128(_) => Some(IntType::UnsignedInt(UintTy::U128)),\n             ConstInt::Usize(_) => Some(IntType::UnsignedInt(UintTy::Us)),\n             _ => None,\n         }\n@@ -317,13 +388,15 @@ impl ::std::fmt::Display for ConstInt {\n             I16(i) => write!(fmt, \"{}i16\", i),\n             I32(i) => write!(fmt, \"{}i32\", i),\n             I64(i) => write!(fmt, \"{}i64\", i),\n+            I128(i) => write!(fmt, \"{}i128\", i),\n             Isize(ConstIsize::Is64(i)) => write!(fmt, \"{}isize\", i),\n             Isize(ConstIsize::Is32(i)) => write!(fmt, \"{}isize\", i),\n             Isize(ConstIsize::Is16(i)) => write!(fmt, \"{}isize\", i),\n             U8(i) => write!(fmt, \"{}u8\", i),\n             U16(i) => write!(fmt, \"{}u16\", i),\n             U32(i) => write!(fmt, \"{}u32\", i),\n             U64(i) => write!(fmt, \"{}u64\", i),\n+            U128(i) => write!(fmt, \"{}u128\", i),\n             Usize(ConstUsize::Us64(i)) => write!(fmt, \"{}usize\", i),\n             Usize(ConstUsize::Us32(i)) => write!(fmt, \"{}usize\", i),\n             Usize(ConstUsize::Us16(i)) => write!(fmt, \"{}usize\", i),\n@@ -351,13 +424,15 @@ macro_rules! impl_binop {\n                     (I16(a), I16(b)) => a.$checked_func(b).map(I16),\n                     (I32(a), I32(b)) => a.$checked_func(b).map(I32),\n                     (I64(a), I64(b)) => a.$checked_func(b).map(I64),\n+                    (I128(a), I128(b)) => a.$checked_func(b).map(I128),\n                     (Isize(Is16(a)), Isize(Is16(b))) => a.$checked_func(b).map(Is16).map(Isize),\n                     (Isize(Is32(a)), Isize(Is32(b))) => a.$checked_func(b).map(Is32).map(Isize),\n                     (Isize(Is64(a)), Isize(Is64(b))) => a.$checked_func(b).map(Is64).map(Isize),\n                     (U8(a), U8(b)) => a.$checked_func(b).map(U8),\n                     (U16(a), U16(b)) => a.$checked_func(b).map(U16),\n                     (U32(a), U32(b)) => a.$checked_func(b).map(U32),\n                     (U64(a), U64(b)) => a.$checked_func(b).map(U64),\n+                    (U128(a), U128(b)) => a.$checked_func(b).map(U128),\n                     (Usize(Us16(a)), Usize(Us16(b))) => a.$checked_func(b).map(Us16).map(Usize),\n                     (Usize(Us32(a)), Usize(Us32(b))) => a.$checked_func(b).map(Us32).map(Usize),\n                     (Usize(Us64(a)), Usize(Us64(b))) => a.$checked_func(b).map(Us64).map(Usize),\n@@ -380,13 +455,15 @@ macro_rules! derive_binop {\n                     (I16(a), I16(b)) => Ok(I16(a.$func(b))),\n                     (I32(a), I32(b)) => Ok(I32(a.$func(b))),\n                     (I64(a), I64(b)) => Ok(I64(a.$func(b))),\n+                    (I128(a), I128(b)) => Ok(I128(a.$func(b))),\n                     (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a.$func(b)))),\n                     (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a.$func(b)))),\n                     (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a.$func(b)))),\n                     (U8(a), U8(b)) => Ok(U8(a.$func(b))),\n                     (U16(a), U16(b)) => Ok(U16(a.$func(b))),\n                     (U32(a), U32(b)) => Ok(U32(a.$func(b))),\n                     (U64(a), U64(b)) => Ok(U64(a.$func(b))),\n+                    (U128(a), U128(b)) => Ok(U128(a.$func(b))),\n                     (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a.$func(b)))),\n                     (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a.$func(b)))),\n                     (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a.$func(b)))),\n@@ -406,6 +483,11 @@ derive_binop!(BitAnd, bitand);\n derive_binop!(BitOr, bitor);\n derive_binop!(BitXor, bitxor);\n \n+#[cfg(not(stage0))]\n+const I128_MIN: i128 = ::std::i128::MIN;\n+#[cfg(stage0)]\n+const I128_MIN: i128 = ::std::i64::MIN;\n+\n fn check_division(\n     lhs: ConstInt,\n     rhs: ConstInt,\n@@ -417,6 +499,7 @@ fn check_division(\n         (I16(_), I16(0)) => Err(zerr),\n         (I32(_), I32(0)) => Err(zerr),\n         (I64(_), I64(0)) => Err(zerr),\n+        (I128(_), I128(0)) => Err(zerr),\n         (Isize(_), Isize(Is16(0))) => Err(zerr),\n         (Isize(_), Isize(Is32(0))) => Err(zerr),\n         (Isize(_), Isize(Is64(0))) => Err(zerr),\n@@ -426,6 +509,7 @@ fn check_division(\n         (U16(_), U16(0)) => Err(zerr),\n         (U32(_), U32(0)) => Err(zerr),\n         (U64(_), U64(0)) => Err(zerr),\n+        (U128(_), U128(0)) => Err(zerr),\n         (Usize(_), Usize(Us16(0))) => Err(zerr),\n         (Usize(_), Usize(Us32(0))) => Err(zerr),\n         (Usize(_), Usize(Us64(0))) => Err(zerr),\n@@ -435,10 +519,11 @@ fn check_division(\n         (I16(::std::i16::MIN), I16(-1)) => Err(Overflow(op)),\n         (I32(::std::i32::MIN), I32(-1)) => Err(Overflow(op)),\n         (I64(::std::i64::MIN), I64(-1)) => Err(Overflow(op)),\n+        (I128(I128_MIN), I128(-1)) => Err(Overflow(op)),\n         (Isize(Is16(::std::i16::MIN)), Isize(Is16(-1))) => Err(Overflow(op)),\n         (Isize(Is32(::std::i32::MIN)), Isize(Is32(-1))) => Err(Overflow(op)),\n         (Isize(Is64(::std::i64::MIN)), Isize(Is64(-1))) => Err(Overflow(op)),\n-        (InferSigned(::std::i64::MIN), InferSigned(-1)) => Err(Overflow(op)),\n+        (InferSigned(I128_MIN), InferSigned(-1)) => Err(Overflow(op)),\n \n         _ => Ok(()),\n     }\n@@ -454,6 +539,7 @@ impl ::std::ops::Div for ConstInt {\n             (I16(a), I16(b)) => Ok(I16(a/b)),\n             (I32(a), I32(b)) => Ok(I32(a/b)),\n             (I64(a), I64(b)) => Ok(I64(a/b)),\n+            (I128(a), I128(b)) => Ok(I128(a/b)),\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a/b))),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a/b))),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a/b))),\n@@ -463,6 +549,7 @@ impl ::std::ops::Div for ConstInt {\n             (U16(a), U16(b)) => Ok(U16(a/b)),\n             (U32(a), U32(b)) => Ok(U32(a/b)),\n             (U64(a), U64(b)) => Ok(U64(a/b)),\n+            (U128(a), U128(b)) => Ok(U128(a/b)),\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a/b))),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a/b))),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a/b))),\n@@ -484,6 +571,7 @@ impl ::std::ops::Rem for ConstInt {\n             (I16(a), I16(b)) => Ok(I16(a%b)),\n             (I32(a), I32(b)) => Ok(I32(a%b)),\n             (I64(a), I64(b)) => Ok(I64(a%b)),\n+            (I128(a), I128(b)) => Ok(I128(a%b)),\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a%b))),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a%b))),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a%b))),\n@@ -493,6 +581,7 @@ impl ::std::ops::Rem for ConstInt {\n             (U16(a), U16(b)) => Ok(U16(a%b)),\n             (U32(a), U32(b)) => Ok(U32(a%b)),\n             (U64(a), U64(b)) => Ok(U64(a%b)),\n+            (U128(a), U128(b)) => Ok(U128(a%b)),\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a%b))),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a%b))),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a%b))),\n@@ -512,13 +601,15 @@ impl ::std::ops::Shl<ConstInt> for ConstInt {\n             I16(a) => Ok(I16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             I32(a) => Ok(I32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             I64(a) => Ok(I64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            I128(a) => Ok(I128(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             U8(a) => Ok(U8(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             U16(a) => Ok(U16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             U32(a) => Ok(U32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             U64(a) => Ok(U64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            U128(a) => Ok(U128(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n@@ -537,13 +628,15 @@ impl ::std::ops::Shr<ConstInt> for ConstInt {\n             I16(a) => Ok(I16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             I32(a) => Ok(I32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             I64(a) => Ok(I64(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            I128(a) => Ok(I128(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             U8(a) => Ok(U8(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             U16(a) => Ok(U16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             U32(a) => Ok(U32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             U64(a) => Ok(U64(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            U128(a) => Ok(U128(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n@@ -561,22 +654,14 @@ impl ::std::ops::Neg for ConstInt {\n             I16(a) => Ok(I16(overflowing!(a.overflowing_neg(), Op::Neg))),\n             I32(a) => Ok(I32(overflowing!(a.overflowing_neg(), Op::Neg))),\n             I64(a) => Ok(I64(overflowing!(a.overflowing_neg(), Op::Neg))),\n+            I128(a) => Ok(I128(overflowing!(a.overflowing_neg(), Op::Neg))),\n             Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_neg(), Op::Neg)))),\n             Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_neg(), Op::Neg)))),\n             Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_neg(), Op::Neg)))),\n-            U8(0) => Ok(U8(0)),\n-            U16(0) => Ok(U16(0)),\n-            U32(0) => Ok(U32(0)),\n-            U64(0) => Ok(U64(0)),\n-            Usize(Us16(0)) => Ok(Usize(Us16(0))),\n-            Usize(Us32(0)) => Ok(Usize(Us32(0))),\n-            Usize(Us64(0)) => Ok(Usize(Us64(0))),\n-            U8(_) => Err(UnsignedNegation),\n-            U16(_) => Err(UnsignedNegation),\n-            U32(_) => Err(UnsignedNegation),\n-            U64(_) => Err(UnsignedNegation),\n-            Usize(_) => Err(UnsignedNegation),\n-            Infer(a @ 0...as_u64::I64MAX) => Ok(InferSigned(-(a as i64))),\n+            a@U8(0) | a@U16(0) | a@U32(0) | a@U64(0) | a@U128(0) |\n+            a@Usize(Us16(0)) | a@Usize(Us32(0)) | a@Usize(Us64(0)) => Ok(a),\n+            U8(_) | U16(_) | U32(_) | U64(_) | U128(_) | Usize(_) => Err(UnsignedNegation),\n+            Infer(a @ 0...ubounds::I64MAX) => Ok(InferSigned(-(a as i128))),\n             Infer(_) => Err(Overflow(Op::Neg)),\n             InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_neg(), Op::Neg))),\n         }\n@@ -591,13 +676,15 @@ impl ::std::ops::Not for ConstInt {\n             I16(a) => Ok(I16(!a)),\n             I32(a) => Ok(I32(!a)),\n             I64(a) => Ok(I64(!a)),\n+            I128(a) => Ok(I128(!a)),\n             Isize(Is16(a)) => Ok(Isize(Is16(!a))),\n             Isize(Is32(a)) => Ok(Isize(Is32(!a))),\n             Isize(Is64(a)) => Ok(Isize(Is64(!a))),\n             U8(a) => Ok(U8(!a)),\n             U16(a) => Ok(U16(!a)),\n             U32(a) => Ok(U32(!a)),\n             U64(a) => Ok(U64(!a)),\n+            U128(a) => Ok(U128(!a)),\n             Usize(Us16(a)) => Ok(Usize(Us16(!a))),\n             Usize(Us32(a)) => Ok(Usize(Us32(!a))),\n             Usize(Us64(a)) => Ok(Usize(Us64(!a))),"}, {"sha": "19ae0c91fc5f9b2ddd435178c9abaf0afaef5341", "filename": "src/librustc_const_math/is.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_math%2Fis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_math%2Fis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fis.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -10,6 +10,7 @@\n \n use syntax::ast;\n use super::err::*;\n+use rustc_i128::i128;\n \n /// Depending on the target only one variant is ever used in a compilation.\n /// Anything else is an error. This invariant is checked at several locations\n@@ -41,11 +42,11 @@ impl ConstIsize {\n             _ => unreachable!(),\n         }\n     }\n-    pub fn new_truncating(i: i64, target_int_ty: ast::IntTy) -> Self {\n+    pub fn new_truncating(i: i128, target_int_ty: ast::IntTy) -> Self {\n         match target_int_ty {\n             ast::IntTy::I16 => Is16(i as i16),\n             ast::IntTy::I32 => Is32(i as i32),\n-            ast::IntTy::I64 => Is64(i),\n+            ast::IntTy::I64 => Is64(i as i64),\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "597344a2c82d01b9f675bf668fdae0a6ae56ba13", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -25,10 +25,14 @@\n \n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![feature(const_fn)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n \n+// SNAP: remove use of this crate\n+extern crate rustc_i128;\n+\n extern crate serialize as rustc_serialize; // used by deriving\n \n mod float;"}, {"sha": "9ebf5cab6bb06000a18d4125e3fb3942ddc9c365", "filename": "src/librustc_const_math/us.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_math%2Fus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_const_math%2Fus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fus.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -10,6 +10,7 @@\n \n use syntax::ast;\n use super::err::*;\n+use rustc_i128::u128;\n \n /// Depending on the target only one variant is ever used in a compilation.\n /// Anything else is an error. This invariant is checked at several locations\n@@ -41,11 +42,11 @@ impl ConstUsize {\n             _ => unreachable!(),\n         }\n     }\n-    pub fn new_truncating(i: u64, target_uint_ty: ast::UintTy) -> Self {\n+    pub fn new_truncating(i: u128, target_uint_ty: ast::UintTy) -> Self {\n         match target_uint_ty {\n             ast::UintTy::U16 => Us16(i as u16),\n             ast::UintTy::U32 => Us32(i as u32),\n-            ast::UintTy::U64 => Us64(i),\n+            ast::UintTy::U64 => Us64(i as u64),\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "bb6103748102de1a49d1cd376b8d497039805d18", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -11,3 +11,4 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = { path = \"../liblog\" }\n serialize = { path = \"../libserialize\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "d3ec674daed4da97d90fa62cfc6d2b5dd4289741", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -44,6 +44,8 @@ extern crate serialize as rustc_serialize; // used by deriving\n #[cfg(unix)]\n extern crate libc;\n \n+extern crate rustc_i128;\n+\n pub use rustc_serialize::hex::ToHex;\n \n pub mod array_vec;"}, {"sha": "87048eff5b78b9fcc3af0d37be46da11cc29ab65", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -13,13 +13,14 @@ use std::marker::PhantomData;\n use std::mem;\n use blake2b::Blake2bHasher;\n use rustc_serialize::leb128;\n+use rustc_i128::{u128,i128};\n \n fn write_unsigned_leb128_to_buf(buf: &mut [u8; 16], value: u64) -> usize {\n-    leb128::write_unsigned_leb128_to(value, |i, v| buf[i] = v)\n+    leb128::write_unsigned_leb128_to(value as u128, |i, v| buf[i] = v)\n }\n \n fn write_signed_leb128_to_buf(buf: &mut [u8; 16], value: i64) -> usize {\n-    leb128::write_signed_leb128_to(value, |i, v| buf[i] = v)\n+    leb128::write_signed_leb128_to(value as i128, |i, v| buf[i] = v)\n }\n \n /// When hashing something that ends up affecting properties like symbol names. We"}, {"sha": "6fd67637db7e6f27fdbc9c77e64a649ef9cda858", "filename": "src/librustc_i128/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_i128%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_i128%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_i128%2FCargo.toml?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_i128\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_i128\"\n+path = \"lib.rs\""}, {"sha": "80f550c7f50e2089bd2388c1f593fa2a3499466f", "filename": "src/librustc_i128/lib.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_i128%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_i128%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_i128%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(non_camel_case_types)]\n+#![cfg_attr(not(stage0), feature(i128_type))]\n+#![no_std]\n+#![crate_type=\"rlib\"]\n+#![crate_name=\"rustc_i128\"]\n+\n+#[cfg(stage0)]\n+pub type i128 = i64;\n+#[cfg(stage0)]\n+pub type u128 = u64;\n+\n+#[cfg(not(stage0))]\n+pub type i128 = int::_i128;\n+#[cfg(not(stage0))]\n+pub type u128 = int::_u128;\n+#[cfg(not(stage0))]\n+mod int {\n+    pub type _i128 = i128;\n+    pub type _u128 = u128;\n+}"}, {"sha": "8a38f36a5d1335699f64429bc041eca9bfe9c41c", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -16,3 +16,4 @@ serialize = { path = \"../libserialize\" }\n log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "d02e4f9b165d8e4986cbd3ef68b9e3654dc24c25", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -33,6 +33,8 @@ extern crate serialize as rustc_serialize;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n \n+extern crate rustc_i128;\n+\n const ATTR_DIRTY: &'static str = \"rustc_dirty\";\n const ATTR_CLEAN: &'static str = \"rustc_clean\";\n const ATTR_DIRTY_METADATA: &'static str = \"rustc_metadata_dirty\";"}, {"sha": "272f8b4f64dbd65ef1ec6e291b40389a65904770", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -14,5 +14,6 @@ log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "a24edfaaac1c2fa3689aab276ab2f8bb47ecc0d3", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -47,6 +47,8 @@ extern crate rustc_back;\n extern crate rustc_const_eval;\n extern crate syntax_pos;\n \n+extern crate rustc_i128;\n+\n pub use rustc::lint;\n pub use rustc::middle;\n pub use rustc::session;"}, {"sha": "95e955bd6833e85edf233bfd16d339b57c6b0815", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -33,6 +33,8 @@ use syntax::codemap;\n \n use rustc::hir;\n \n+use rustc_i128::{i128, u128};\n+\n register_long_diagnostics! {\n E0519: r##\"\n It is not allowed to negate an unsigned integer.\n@@ -147,7 +149,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                     if let Some(bits) = opt_ty_bits {\n                         let exceeding = if let hir::ExprLit(ref lit) = r.node {\n                             if let ast::LitKind::Int(shift, _) = lit.node {\n-                                shift >= bits\n+                                shift as u64 >= bits\n                             } else {\n                                 false\n                             }\n@@ -182,12 +184,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                     t\n                                 };\n                                 let (_, max) = int_ty_range(int_type);\n+                                let max = max as u128;\n                                 let negative = self.negated_expr_id == e.id;\n \n                                 // Detect literal value out of range [min, max] inclusive\n                                 // avoiding use of -min to prevent overflow/panic\n-                                if (negative && v > max as u64 + 1) ||\n-                                   (!negative && v > max as u64) {\n+                                if (negative && v > max + 1) ||\n+                                   (!negative && v > max) {\n                                     cx.span_lint(OVERFLOWING_LITERALS,\n                                                  e.span,\n                                                  &format!(\"literal out of range for {:?}\", t));\n@@ -204,7 +207,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             t\n                         };\n                         let (min, max) = uint_ty_range(uint_type);\n-                        let lit_val: u64 = match lit.node {\n+                        let lit_val: u128 = match lit.node {\n                             // _v is u8, within range by definition\n                             ast::LitKind::Byte(_v) => return,\n                             ast::LitKind::Int(v, _) => v,\n@@ -264,23 +267,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n         // for isize & usize, be conservative with the warnings, so that the\n         // warnings are consistent between 32- and 64-bit platforms\n-        fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n+        fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n             match int_ty {\n-                ast::IntTy::Is => (i64::MIN, i64::MAX),\n-                ast::IntTy::I8 => (i8::MIN as i64, i8::MAX as i64),\n-                ast::IntTy::I16 => (i16::MIN as i64, i16::MAX as i64),\n-                ast::IntTy::I32 => (i32::MIN as i64, i32::MAX as i64),\n-                ast::IntTy::I64 => (i64::MIN, i64::MAX),\n+                ast::IntTy::Is => (i64::min_value() as i128, i64::max_value() as i128),\n+                ast::IntTy::I8 => (i8::min_value() as i64 as i128, i8::max_value() as i128),\n+                ast::IntTy::I16 => (i16::min_value() as i64 as i128, i16::max_value() as i128),\n+                ast::IntTy::I32 => (i32::min_value() as i64 as i128, i32::max_value() as i128),\n+                ast::IntTy::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n+                ast::IntTy::I128 =>(i128::min_value() as i128, i128::max_value()),\n             }\n         }\n \n-        fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n+        fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n             match uint_ty {\n-                ast::UintTy::Us => (u64::MIN, u64::MAX),\n-                ast::UintTy::U8 => (u8::MIN as u64, u8::MAX as u64),\n-                ast::UintTy::U16 => (u16::MIN as u64, u16::MAX as u64),\n-                ast::UintTy::U32 => (u32::MIN as u64, u32::MAX as u64),\n-                ast::UintTy::U64 => (u64::MIN, u64::MAX),\n+                ast::UintTy::Us => (u64::min_value() as u128, u64::max_value() as u128),\n+                ast::UintTy::U8 => (u8::min_value() as u128, u8::max_value() as u128),\n+                ast::UintTy::U16 => (u16::min_value() as u128, u16::max_value() as u128),\n+                ast::UintTy::U32 => (u32::min_value() as u128, u32::max_value() as u128),\n+                ast::UintTy::U64 => (u64::min_value() as u128, u64::max_value() as u128),\n+                ast::UintTy::U128 => (u128::min_value(), u128::max_value()),\n             }\n         }\n \n@@ -298,6 +303,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 ast::IntTy::I16 => 16 as u64,\n                 ast::IntTy::I32 => 32,\n                 ast::IntTy::I64 => 64,\n+                ast::IntTy::I128 => 128,\n             }\n         }\n \n@@ -308,6 +314,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 ast::UintTy::U16 => 16,\n                 ast::UintTy::U32 => 32,\n                 ast::UintTy::U64 => 64,\n+                ast::UintTy::U128 => 128,\n             }\n         }\n \n@@ -327,28 +334,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             match tcx.tables().node_id_to_type(expr.id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n-                    let lit_val: i64 = match lit.node {\n+                    let lit_val: i128 = match lit.node {\n                         hir::ExprLit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n-                                ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i64,\n-                                _ => return true,\n+                                ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i128,\n+                                _ => return true\n                             }\n-                        }\n-                        _ => bug!(),\n+                        },\n+                        _ => bug!()\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n                 ty::TyUint(uint_ty) => {\n-                    let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n-                    let lit_val: u64 = match lit.node {\n+                    let (min, max) :(u128, u128) = uint_ty_range(uint_ty);\n+                    let lit_val: u128 = match lit.node {\n                         hir::ExprLit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, _) => v,\n-                                _ => return true,\n+                                _ => return true\n                             }\n-                        }\n-                        _ => bug!(),\n+                        },\n+                        _ => bug!()\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }"}, {"sha": "6815da4cc20fdecdcd08c2240a4b9f50e485c2a8", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -33,7 +33,7 @@ pub enum LLVMRustResult {\n // Consts for the LLVM CallConv type, pre-cast to usize.\n \n /// LLVM CallingConv::ID. Should we wrap this?\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(C)]\n pub enum CallConv {\n     CCallConv = 0,\n@@ -578,9 +578,12 @@ extern \"C\" {\n \n     // Operations on scalar constants\n     pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool) -> ValueRef;\n+    pub fn LLVMConstIntOfArbitraryPrecision(IntTy: TypeRef, Wn: c_uint, Ws: *const u64) -> ValueRef;\n     pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n     pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n     pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n+    pub fn LLVMRustConstInt128Get(ConstantVal: ValueRef, SExt: bool,\n+                                  high: *mut u64, low: *mut u64) -> bool;\n \n \n     // Operations on composite constants"}, {"sha": "4bd98c087f5171bcfc6c00a85665113cc575b39e", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -18,6 +18,7 @@ rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }"}, {"sha": "dad956afb5e60ebbe8e505e2f70dde6c2ffc745f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -43,6 +43,7 @@ use syntax::attr;\n use syntax::ast::{self, NodeId};\n use syntax::codemap;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n+use rustc_i128::{u128, i128};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Decoder<'a>,\n@@ -211,12 +212,14 @@ impl<'doc, 'tcx> Decoder for DecodeContext<'doc, 'tcx> {\n     decoder_methods! {\n         read_nil -> ();\n \n+        read_u128 -> u128;\n         read_u64 -> u64;\n         read_u32 -> u32;\n         read_u16 -> u16;\n         read_u8 -> u8;\n         read_usize -> usize;\n \n+        read_i128 -> i128;\n         read_i64 -> i64;\n         read_i32 -> i32;\n         read_i16 -> i16;"}, {"sha": "c3bcdf42d4edecca53c1d750fddea3943bdda989", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -43,6 +43,8 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n+use rustc_i128::{u128, i128};\n+\n use super::index_builder::{FromId, IndexBuilder, Untracked};\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n@@ -75,12 +77,14 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n \n     encoder_methods! {\n         emit_usize(usize);\n+        emit_u128(u128);\n         emit_u64(u64);\n         emit_u32(u32);\n         emit_u16(u16);\n         emit_u8(u8);\n \n         emit_isize(isize);\n+        emit_i128(i128);\n         emit_i64(i64);\n         emit_i32(i32);\n         emit_i16(i16);\n@@ -259,7 +263,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n-            disr: variant.disr_val.to_u64_unchecked(),\n+            disr: variant.disr_val.to_u128_unchecked(),\n             struct_ctor: None,\n         };\n \n@@ -386,7 +390,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n-            disr: variant.disr_val.to_u64_unchecked(),\n+            disr: variant.disr_val.to_u128_unchecked(),\n             struct_ctor: Some(def_id.index),\n         };\n \n@@ -648,7 +652,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 };\n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n-                    disr: variant.disr_val.to_u64_unchecked(),\n+                    disr: variant.disr_val.to_u128_unchecked(),\n                     struct_ctor: struct_ctor,\n                 }))\n             }\n@@ -657,7 +661,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n-                    disr: variant.disr_val.to_u64_unchecked(),\n+                    disr: variant.disr_val.to_u128_unchecked(),\n                     struct_ctor: None,\n                 }))\n             }"}, {"sha": "f4ccc01544aa660a045ab396d0361440ff013da4", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -45,9 +45,12 @@ extern crate rustc_back;\n extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate rustc_llvm;\n+extern crate rustc_i128;\n \n mod diagnostics;\n \n+pub use rustc::middle;\n+\n mod astencode;\n mod index_builder;\n mod index;"}, {"sha": "74825a5c6e3f676325a2419ee782aca90cead7ef", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -27,6 +27,8 @@ use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n \n+use rustc_i128::u128;\n+\n pub fn rustc_version() -> String {\n     format!(\"rustc {}\",\n             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n@@ -264,7 +266,7 @@ pub struct FnData {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct VariantData {\n     pub ctor_kind: CtorKind,\n-    pub disr: u64,\n+    pub disr: u128,\n \n     /// If this is a struct's only variant, this\n     /// is the index of the \"struct ctor\" item."}, {"sha": "7e26aa9a57bf57cfd09ac9a473aa5e2116535f3d", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -17,5 +17,6 @@ rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "8199a08c852de872c8f96e39ff7a3b8c39cc4990", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -15,6 +15,7 @@ use std;\n use rustc_const_math::{ConstMathErr, Op};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_i128::i128;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};\n@@ -347,6 +348,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I16 => ConstInt::I16(-1),\n                     ast::IntTy::I32 => ConstInt::I32(-1),\n                     ast::IntTy::I64 => ConstInt::I64(-1),\n+                    ast::IntTy::I128 => ConstInt::I128(-1),\n                     ast::IntTy::Is => {\n                         let int_ty = self.hir.tcx().sess.target.int_type;\n                         let val = ConstIsize::new(-1, int_ty).unwrap();\n@@ -369,10 +371,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let literal = match ty.sty {\n             ty::TyInt(ity) => {\n                 let val = match ity {\n-                    ast::IntTy::I8  => ConstInt::I8(std::i8::MIN),\n-                    ast::IntTy::I16 => ConstInt::I16(std::i16::MIN),\n-                    ast::IntTy::I32 => ConstInt::I32(std::i32::MIN),\n-                    ast::IntTy::I64 => ConstInt::I64(std::i64::MIN),\n+                    ast::IntTy::I8  => ConstInt::I8(i8::min_value()),\n+                    ast::IntTy::I16 => ConstInt::I16(i16::min_value()),\n+                    ast::IntTy::I32 => ConstInt::I32(i32::min_value()),\n+                    ast::IntTy::I64 => ConstInt::I64(i64::min_value()),\n+                    ast::IntTy::I128 => ConstInt::I128(i128::min_value()),\n                     ast::IntTy::Is => {\n                         let int_ty = self.hir.tcx().sess.target.int_type;\n                         let min = match int_ty {"}, {"sha": "99aa5cb0fa86eb1f5d735cd1b945f4f17d5937a2", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -66,6 +66,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::UintTy::U16 => ConstInt::U16(0),\n                     ast::UintTy::U32 => ConstInt::U32(0),\n                     ast::UintTy::U64 => ConstInt::U64(0),\n+                    ast::UintTy::U128 => ConstInt::U128(0),\n                     ast::UintTy::Us => {\n                         let uint_ty = self.hir.tcx().sess.target.uint_type;\n                         let val = ConstUsize::new(0, uint_ty).unwrap();\n@@ -81,6 +82,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I16 => ConstInt::I16(0),\n                     ast::IntTy::I32 => ConstInt::I32(0),\n                     ast::IntTy::I64 => ConstInt::I64(0),\n+                    ast::IntTy::I128 => ConstInt::I128(0),\n                     ast::IntTy::Is => {\n                         let int_ty = self.hir.tcx().sess.target.int_type;\n                         let val = ConstIsize::new(0, int_ty).unwrap();"}, {"sha": "a608275cefa0610da7d763139c3ec4159e7740fd", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -41,6 +41,8 @@ extern crate syntax_pos;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n \n+extern crate rustc_i128;\n+\n pub mod diagnostics;\n \n pub mod build;"}, {"sha": "b7908f0c0edded5a92e26cd17a00ab01062d7914", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -61,6 +61,7 @@ use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n+use syntax::feature_gate::{emit_feature_err, GateIssue};\n \n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use errors::DiagnosticBuilder;\n@@ -1005,13 +1006,14 @@ impl PrimitiveTypeTable {\n         table.intern(\"i16\", TyInt(IntTy::I16));\n         table.intern(\"i32\", TyInt(IntTy::I32));\n         table.intern(\"i64\", TyInt(IntTy::I64));\n+        table.intern(\"i128\", TyInt(IntTy::I128));\n         table.intern(\"str\", TyStr);\n         table.intern(\"usize\", TyUint(UintTy::Us));\n         table.intern(\"u8\", TyUint(UintTy::U8));\n         table.intern(\"u16\", TyUint(UintTy::U16));\n         table.intern(\"u32\", TyUint(UintTy::U32));\n         table.intern(\"u64\", TyUint(UintTy::U64));\n-\n+        table.intern(\"u128\", TyUint(UintTy::U128));\n         table\n     }\n \n@@ -2308,8 +2310,20 @@ impl<'a> Resolver<'a> {\n             PathResult::Module(..) | PathResult::Failed(..)\n                     if (ns == TypeNS || path.len() > 1) &&\n                        self.primitive_type_table.primitive_types.contains_key(&path[0].name) => {\n+                let prim = self.primitive_type_table.primitive_types[&path[0].name];\n+                match prim {\n+                    TyUint(UintTy::U128) | TyInt(IntTy::I128) => {\n+                        if !self.session.features.borrow().i128_type {\n+                            emit_feature_err(&self.session.parse_sess,\n+                                                \"i128_type\", span, GateIssue::Language,\n+                                                \"128-bit type is unstable\");\n+\n+                        }\n+                    }\n+                    _ => {}\n+                }\n                 PathResolution {\n-                    base_def: Def::PrimTy(self.primitive_type_table.primitive_types[&path[0].name]),\n+                    base_def: Def::PrimTy(prim),\n                     depth: path.len() - 1,\n                 }\n             }"}, {"sha": "93e2e472b75f13d22d4561c06df1165f4658418e", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -23,7 +23,8 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "65e752232f6adb0b607dc5915b7f658378e8bf1f", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -313,7 +313,7 @@ impl ArgType {\n ///\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct FnType {\n     /// The LLVM types of each argument.\n     pub args: Vec<ArgType>,\n@@ -352,6 +352,7 @@ impl FnType {\n             Fastcall => llvm::X86FastcallCallConv,\n             Vectorcall => llvm::X86_VectorCall,\n             C => llvm::CCallConv,\n+            Unadjusted => llvm::CCallConv,\n             Win64 => llvm::X86_64_Win64,\n             SysV64 => llvm::X86_64_SysV,\n             Aapcs => llvm::ArmAapcsCallConv,\n@@ -528,6 +529,8 @@ impl FnType {\n                                     ccx: &CrateContext<'a, 'tcx>,\n                                     abi: Abi,\n                                     sig: &ty::FnSig<'tcx>) {\n+        if abi == Abi::Unadjusted { return }\n+\n         if abi == Abi::Rust || abi == Abi::RustCall ||\n            abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             let fixup = |arg: &mut ArgType| {"}, {"sha": "a849f38247380d1dd7e808a77aaa7d2b2bd2cacc", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -18,16 +18,20 @@ use type_::Type;\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     let fixup = |a: &mut ArgType| {\n-        if a.ty.kind() == Struct {\n-            match llsize_of_alloc(ccx, a.ty) {\n-                1 => a.cast = Some(Type::i8(ccx)),\n-                2 => a.cast = Some(Type::i16(ccx)),\n-                4 => a.cast = Some(Type::i32(ccx)),\n-                8 => a.cast = Some(Type::i64(ccx)),\n-                _ => a.make_indirect(ccx)\n-            }\n-        } else {\n-            a.extend_integer_width_to(32);\n+        match a.ty.kind() {\n+            Struct => match llsize_of_alloc(ccx, a.ty) {\n+                          1 => a.cast = Some(Type::i8(ccx)),\n+                          2 => a.cast = Some(Type::i16(ccx)),\n+                          4 => a.cast = Some(Type::i32(ccx)),\n+                          8 => a.cast = Some(Type::i64(ccx)),\n+                          _ => a.make_indirect(ccx)\n+                      },\n+            Integer => match llsize_of_alloc(ccx, a.ty) {\n+                           1 ... 8 => a.extend_integer_width_to(32),\n+                           16 => a.make_indirect(ccx),\n+                           _ => bug!(),\n+            },\n+            _ => (),\n         }\n     };\n "}, {"sha": "7e7bd15dc6e5ad6730fd5e96a4a6b5a16bd46c81", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -44,6 +44,8 @@ use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::Span;\n \n+use rustc_i128::u128;\n+\n pub use context::{CrateContext, SharedCrateContext};\n \n pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -425,6 +427,17 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n     }\n }\n \n+pub fn C_big_integral(t: Type, u: u128, sign_extend: bool) -> ValueRef {\n+    if ::std::mem::size_of::<u128>() == 16 {\n+        unsafe {\n+            llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, &u as *const u128 as *const u64)\n+        }\n+    } else {\n+        // SNAP: remove after snapshot\n+        C_integral(t, u as u64, sign_extend)\n+    }\n+}\n+\n pub fn C_floating_f64(f: f64, t: Type) -> ValueRef {\n     unsafe {\n         llvm::LLVMConstReal(t.to_ref(), f)\n@@ -580,20 +593,29 @@ fn is_const_integral(v: ValueRef) -> bool {\n     }\n }\n \n-pub fn const_to_opt_int(v: ValueRef) -> Option<i64> {\n-    unsafe {\n-        if is_const_integral(v) {\n-            Some(llvm::LLVMConstIntGetSExtValue(v))\n-        } else {\n-            None\n-        }\n-    }\n+#[inline]\n+#[cfg(stage0)]\n+fn hi_lo_to_u128(lo: u64, _: u64) -> u128 {\n+    lo as u128\n }\n \n-pub fn const_to_opt_uint(v: ValueRef) -> Option<u64> {\n+#[inline]\n+#[cfg(not(stage0))]\n+fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n+    ((hi as u128) << 64) | (lo as u128)\n+}\n+\n+pub fn const_to_opt_u128(v: ValueRef, sign_ext: bool) -> Option<u128> {\n     unsafe {\n         if is_const_integral(v) {\n-            Some(llvm::LLVMConstIntGetZExtValue(v))\n+            let (mut lo, mut hi) = (0u64, 0u64);\n+            let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n+                                                       &mut hi as *mut u64, &mut lo as *mut u64);\n+            if success {\n+                Some(hi_lo_to_u128(lo, hi))\n+            } else {\n+                None\n+            }\n         } else {\n             None\n         }"}, {"sha": "413b643740861a1cf047fe8de836a7bfcf69b9bf", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -1022,6 +1022,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     let t_i16 = Type::i16(ccx);\n     let t_i32 = Type::i32(ccx);\n     let t_i64 = Type::i64(ccx);\n+    let t_i128 = Type::i128(ccx);\n     let t_f32 = Type::f32(ccx);\n     let t_f64 = Type::f64(ccx);\n \n@@ -1088,50 +1089,60 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     ifn!(\"llvm.ctpop.i16\", fn(t_i16) -> t_i16);\n     ifn!(\"llvm.ctpop.i32\", fn(t_i32) -> t_i32);\n     ifn!(\"llvm.ctpop.i64\", fn(t_i64) -> t_i64);\n+    ifn!(\"llvm.ctpop.i128\", fn(t_i128) -> t_i128);\n \n     ifn!(\"llvm.ctlz.i8\", fn(t_i8 , i1) -> t_i8);\n     ifn!(\"llvm.ctlz.i16\", fn(t_i16, i1) -> t_i16);\n     ifn!(\"llvm.ctlz.i32\", fn(t_i32, i1) -> t_i32);\n     ifn!(\"llvm.ctlz.i64\", fn(t_i64, i1) -> t_i64);\n+    ifn!(\"llvm.ctlz.i128\", fn(t_i128, i1) -> t_i128);\n \n     ifn!(\"llvm.cttz.i8\", fn(t_i8 , i1) -> t_i8);\n     ifn!(\"llvm.cttz.i16\", fn(t_i16, i1) -> t_i16);\n     ifn!(\"llvm.cttz.i32\", fn(t_i32, i1) -> t_i32);\n     ifn!(\"llvm.cttz.i64\", fn(t_i64, i1) -> t_i64);\n+    ifn!(\"llvm.cttz.i128\", fn(t_i128, i1) -> t_i128);\n \n     ifn!(\"llvm.bswap.i16\", fn(t_i16) -> t_i16);\n     ifn!(\"llvm.bswap.i32\", fn(t_i32) -> t_i32);\n     ifn!(\"llvm.bswap.i64\", fn(t_i64) -> t_i64);\n+    ifn!(\"llvm.bswap.i128\", fn(t_i128) -> t_i128);\n \n     ifn!(\"llvm.sadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.sadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.sadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.sadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.uadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.uadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.uadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.uadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.ssub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.ssub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.ssub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.ssub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.usub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.usub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.usub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.usub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.usub.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.smul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.smul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.smul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.smul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.smul.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.umul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.umul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.umul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.umul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.umul.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.lifetime.start\", fn(t_i64,i8p) -> void);\n     ifn!(\"llvm.lifetime.end\", fn(t_i64, i8p) -> void);"}, {"sha": "b2d12c7e7d0f2a323130bdcefd4f74bdb2029b48", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -1460,7 +1460,8 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 llvm::LLVMRustDIBuilderCreateEnumerator(\n                     DIB(cx),\n                     name.as_ptr(),\n-                    v.disr_val.to_u64_unchecked())\n+                    // FIXME: what if enumeration has i128 discriminant?\n+                    v.disr_val.to_u128_unchecked() as u64)\n             }\n         })\n         .collect();"}, {"sha": "c5737c6e5f12c38a267e60f2937d6093fbd3e004", "filename": "src/librustc_trans/disr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdisr.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -26,7 +26,8 @@ impl ::std::ops::BitAnd for Disr {\n \n impl From<::rustc::ty::Disr> for Disr {\n     fn from(i: ::rustc::ty::Disr) -> Disr {\n-        Disr(i.to_u64_unchecked())\n+        // FIXME: what if discr has 128 bit discr?\n+        Disr(i.to_u128_unchecked() as u64)\n     }\n }\n "}, {"sha": "62141369caec1cf11a3644e8fef37e6d02ccbc06", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -346,11 +346,12 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n-            let align = match (const_to_opt_uint(sized_align), const_to_opt_uint(unsized_align)) {\n+            let align = match (const_to_opt_u128(sized_align, false),\n+                               const_to_opt_u128(unsized_align, false)) {\n                 (Some(sized_align), Some(unsized_align)) => {\n                     // If both alignments are constant, (the sized_align should always be), then\n                     // pick the correct alignment statically.\n-                    C_uint(ccx, std::cmp::max(sized_align, unsized_align))\n+                    C_uint(ccx, std::cmp::max(sized_align, unsized_align) as u64)\n                 }\n                 _ => bcx.select(bcx.icmp(llvm::IntUGT, sized_align, unsized_align),\n                                 sized_align,"}, {"sha": "c4129b346e409b4dca0d2a4762ae2035a2e5ca25", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -32,6 +32,8 @@ use syntax::symbol::Symbol;\n use rustc::session::Session;\n use syntax_pos::Span;\n \n+use rustc_i128::u128;\n+\n use std::cmp::Ordering;\n use std::iter;\n \n@@ -1019,15 +1021,15 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                  in_elem, in_ty,\n                  ret_ty, ret_ty.simd_type(tcx));\n \n-        let total_len = in_len as u64 * 2;\n+        let total_len = in_len as u128 * 2;\n \n         let vector = llargs[2];\n \n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n                 let val = const_get_elt(vector, &[i as libc::c_uint]);\n-                match const_to_opt_uint(val) {\n+                match const_to_opt_u128(val, true) {\n                     None => {\n                         emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n                         None\n@@ -1167,6 +1169,8 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n // Returns the width of an int TypeVariant, and if it's signed or not\n // Returns None if the type is not an integer\n+// FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n+// stuffs.\n fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n         -> Option<(u64, bool)> {\n     use rustc::ty::{TyInt, TyUint};\n@@ -1184,6 +1188,7 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n             ast::IntTy::I16 => 16,\n             ast::IntTy::I32 => 32,\n             ast::IntTy::I64 => 64,\n+            ast::IntTy::I128 => 128,\n         }, true)),\n         TyUint(t) => Some((match t {\n             ast::UintTy::Us => {\n@@ -1198,6 +1203,7 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n             ast::UintTy::U16 => 16,\n             ast::UintTy::U32 => 32,\n             ast::UintTy::U64 => 64,\n+            ast::UintTy::U128 => 128,\n         }, false)),\n         _ => None,\n     }"}, {"sha": "11bfa0d76c382e3e05da1a5427a0b3602b8d5064", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -57,6 +57,7 @@ extern crate rustc_const_eval;\n #[macro_use]\n #[no_link]\n extern crate rustc_bitflags;\n+extern crate rustc_i128;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "ecedcd68382d167ad44ef8d6d852472ab8cb112b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n                 let cond = self.trans_operand(&bcx, cond).immediate();\n-                let mut const_cond = common::const_to_opt_uint(cond).map(|c| c == 1);\n+                let mut const_cond = common::const_to_opt_u128(cond, false).map(|c| c == 1);\n \n                 // This case can currently arise only from functions marked\n                 // with #[rustc_inherit_overflow_checks] and inlined from\n@@ -322,14 +322,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let len = self.trans_operand(&mut bcx, len).immediate();\n                         let index = self.trans_operand(&mut bcx, index).immediate();\n \n-                        let const_err = common::const_to_opt_uint(len).and_then(|len| {\n-                            common::const_to_opt_uint(index).map(|index| {\n-                                ErrKind::IndexOutOfBounds {\n-                                    len: len,\n-                                    index: index\n-                                }\n-                            })\n-                        });\n+                        let const_err = common::const_to_opt_u128(len, false)\n+                            .and_then(|len| common::const_to_opt_u128(index, false)\n+                                .map(|index| ErrKind::IndexOutOfBounds {\n+                                    len: len as u64,\n+                                    index: index as u64\n+                                }));\n \n                         let file_line = C_struct(bcx.ccx, &[filename, line], false);\n                         let align = llalign_of_min(bcx.ccx, common::val_ty(file_line));"}, {"sha": "700894c255da68de83680cd580a2ce7c92f00502", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 17, "deletions": 49, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -13,7 +13,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc_const_eval::{ErrKind, ConstEvalErr, report_const_eval_err};\n use rustc_const_math::ConstInt::*;\n use rustc_const_math::ConstFloat::*;\n-use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstMathErr};\n+use rustc_const_math::{ConstInt, ConstMathErr};\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir;\n@@ -25,16 +25,15 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr, machine};\n use callee::Callee;\n use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n-use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral};\n+use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integral};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n-use common::{const_to_opt_int, const_to_opt_uint};\n+use common::{const_to_opt_u128};\n use consts;\n use monomorphize::{self, Instance};\n use type_of;\n use type_::Type;\n use value::Value;\n \n-use syntax::ast;\n use syntax_pos::Span;\n \n use std::fmt;\n@@ -43,6 +42,8 @@ use std::ptr;\n use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n \n+use rustc_i128::{u128, i128};\n+\n /// A sized constant rvalue.\n /// The LLVM type might not be the same for a single Rust type,\n /// e.g. each enum variant would have its own LLVM struct type.\n@@ -75,6 +76,7 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Integral(I16(v)) => C_integral(Type::i16(ccx), v as u64, true),\n             ConstVal::Integral(I32(v)) => C_integral(Type::i32(ccx), v as u64, true),\n             ConstVal::Integral(I64(v)) => C_integral(Type::i64(ccx), v as u64, true),\n+            ConstVal::Integral(I128(v)) => C_big_integral(Type::i128(ccx), v as u128, true),\n             ConstVal::Integral(Isize(v)) => {\n                 let i = v.as_i64(ccx.tcx().sess.target.int_type);\n                 C_integral(Type::int(ccx), i as u64, true)\n@@ -83,6 +85,7 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Integral(U16(v)) => C_integral(Type::i16(ccx), v as u64, false),\n             ConstVal::Integral(U32(v)) => C_integral(Type::i32(ccx), v as u64, false),\n             ConstVal::Integral(U64(v)) => C_integral(Type::i64(ccx), v, false),\n+            ConstVal::Integral(U128(v)) => C_big_integral(Type::i128(ccx), v, false),\n             ConstVal::Integral(Usize(v)) => {\n                 let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n                 C_integral(Type::int(ccx), u, false)\n@@ -428,15 +431,15 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::ProjectionElem::Index(ref index) => {\n                         let llindex = self.const_operand(index, span)?.llval;\n \n-                        let iv = if let Some(iv) = common::const_to_opt_uint(llindex) {\n+                        let iv = if let Some(iv) = common::const_to_opt_u128(llindex, false) {\n                             iv\n                         } else {\n                             span_bug!(span, \"index is not an integer-constant expression\")\n                         };\n \n                         // Produce an undef instead of a LLVM assertion on OOB.\n                         let len = common::const_to_uint(tr_base.len(self.ccx));\n-                        let llelem = if iv < len {\n+                        let llelem = if iv < len as u128 {\n                             const_get_elt(base.llval, &[iv as u32])\n                         } else {\n                             C_undef(type_of::type_of(self.ccx, projected_ty))\n@@ -794,49 +797,14 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n     match t.sty {\n-        ty::TyInt(int_type) => const_to_opt_int(value).and_then(|input| match int_type {\n-            ast::IntTy::I8 => {\n-                assert_eq!(input as i8 as i64, input);\n-                Some(ConstInt::I8(input as i8))\n-            },\n-            ast::IntTy::I16 => {\n-                assert_eq!(input as i16 as i64, input);\n-                Some(ConstInt::I16(input as i16))\n-            },\n-            ast::IntTy::I32 => {\n-                assert_eq!(input as i32 as i64, input);\n-                Some(ConstInt::I32(input as i32))\n-            },\n-            ast::IntTy::I64 => {\n-                Some(ConstInt::I64(input))\n-            },\n-            ast::IntTy::Is => {\n-                ConstIsize::new(input, tcx.sess.target.int_type)\n-                    .ok().map(ConstInt::Isize)\n-            },\n-        }),\n-        ty::TyUint(uint_type) => const_to_opt_uint(value).and_then(|input| match uint_type {\n-            ast::UintTy::U8 => {\n-                assert_eq!(input as u8 as u64, input);\n-                Some(ConstInt::U8(input as u8))\n-            },\n-            ast::UintTy::U16 => {\n-                assert_eq!(input as u16 as u64, input);\n-                Some(ConstInt::U16(input as u16))\n-            },\n-            ast::UintTy::U32 => {\n-                assert_eq!(input as u32 as u64, input);\n-                Some(ConstInt::U32(input as u32))\n-            },\n-            ast::UintTy::U64 => {\n-                Some(ConstInt::U64(input))\n-            },\n-            ast::UintTy::Us => {\n-                ConstUsize::new(input, tcx.sess.target.uint_type)\n-                    .ok().map(ConstInt::Usize)\n-            },\n-        }),\n-        _ => None,\n+        ty::TyInt(int_type) => const_to_opt_u128(value, true)\n+            .and_then(|input| ConstInt::new_signed(input as i128, int_type,\n+                                                   tcx.sess.target.int_type)),\n+        ty::TyUint(uint_type) => const_to_opt_u128(value, false)\n+            .and_then(|input| ConstInt::new_unsigned(input, uint_type,\n+                                                     tcx.sess.target.uint_type)),\n+        _ => None\n+\n     }\n }\n "}, {"sha": "a1373cb9482b7b17861a5a008c2e708c700c83b5", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -205,6 +205,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     sig: &ty::FnSig<'tcx>,\n     abi: Abi,\n ) {\n+    debug!(\"fn_ty: {:?}\", fn_ty);\n     let debug_context =\n         debuginfo::create_function_debug_context(fcx.ccx, instance, sig, abi, fcx.llfn, mir);\n     let bcx = fcx.get_entry_block();"}, {"sha": "526155655af2778b45fd62bbed866992ae43a752", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     pub fn immediate(self) -> ValueRef {\n         match self.val {\n             OperandValue::Immediate(s) => s,\n-            _ => bug!()\n+            _ => bug!(\"not immediate: {:?}\", self)\n         }\n     }\n "}, {"sha": "cca48737bb963e7d6dbb703c6e85c5c76fd50bcb", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -711,11 +711,13 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> Val\n             TyInt(I16) => \"llvm.sadd.with.overflow.i16\",\n             TyInt(I32) => \"llvm.sadd.with.overflow.i32\",\n             TyInt(I64) => \"llvm.sadd.with.overflow.i64\",\n+            TyInt(I128) => \"llvm.sadd.with.overflow.i128\",\n \n             TyUint(U8) => \"llvm.uadd.with.overflow.i8\",\n             TyUint(U16) => \"llvm.uadd.with.overflow.i16\",\n             TyUint(U32) => \"llvm.uadd.with.overflow.i32\",\n             TyUint(U64) => \"llvm.uadd.with.overflow.i64\",\n+            TyUint(U128) => \"llvm.uadd.with.overflow.i128\",\n \n             _ => unreachable!(),\n         },\n@@ -724,11 +726,13 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> Val\n             TyInt(I16) => \"llvm.ssub.with.overflow.i16\",\n             TyInt(I32) => \"llvm.ssub.with.overflow.i32\",\n             TyInt(I64) => \"llvm.ssub.with.overflow.i64\",\n+            TyInt(I128) => \"llvm.ssub.with.overflow.i128\",\n \n             TyUint(U8) => \"llvm.usub.with.overflow.i8\",\n             TyUint(U16) => \"llvm.usub.with.overflow.i16\",\n             TyUint(U32) => \"llvm.usub.with.overflow.i32\",\n             TyUint(U64) => \"llvm.usub.with.overflow.i64\",\n+            TyUint(U128) => \"llvm.usub.with.overflow.i128\",\n \n             _ => unreachable!(),\n         },\n@@ -737,11 +741,13 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> Val\n             TyInt(I16) => \"llvm.smul.with.overflow.i16\",\n             TyInt(I32) => \"llvm.smul.with.overflow.i32\",\n             TyInt(I64) => \"llvm.smul.with.overflow.i64\",\n+            TyInt(I128) => \"llvm.smul.with.overflow.i128\",\n \n             TyUint(U8) => \"llvm.umul.with.overflow.i8\",\n             TyUint(U16) => \"llvm.umul.with.overflow.i16\",\n             TyUint(U32) => \"llvm.umul.with.overflow.i32\",\n             TyUint(U64) => \"llvm.umul.with.overflow.i64\",\n+            TyUint(U128) => \"llvm.umul.with.overflow.i128\",\n \n             _ => unreachable!(),\n         },"}, {"sha": "f6f91411225d9b0ecad02567763aa85b9aec5936", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -397,11 +397,13 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n             ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n             ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n+            ty::TyInt(ast::IntTy::I128)   => output.push_str(\"i128\"),\n             ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n             ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n             ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n             ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n             ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n+            ty::TyUint(ast::UintTy::U128)  => output.push_str(\"u128\"),\n             ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n             ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n             ty::TyAdt(adt_def, substs) => {"}, {"sha": "f68acab911317c5935920cc32f7f13cb823b9297", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -94,6 +94,10 @@ impl Type {\n         ty!(llvm::LLVMInt64TypeInContext(ccx.llcx()))\n     }\n \n+    pub fn i128(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMIntTypeInContext(ccx.llcx(), 128))\n+    }\n+\n     // Creates an integer type with the given number of bits, e.g. i24\n     pub fn ix(ccx: &CrateContext, num_bits: u64) -> Type {\n         ty!(llvm::LLVMIntTypeInContext(ccx.llcx(), num_bits as c_uint))\n@@ -134,7 +138,8 @@ impl Type {\n             ast::IntTy::I8 => Type::i8(ccx),\n             ast::IntTy::I16 => Type::i16(ccx),\n             ast::IntTy::I32 => Type::i32(ccx),\n-            ast::IntTy::I64 => Type::i64(ccx)\n+            ast::IntTy::I64 => Type::i64(ccx),\n+            ast::IntTy::I128 => Type::i128(ccx),\n         }\n     }\n \n@@ -144,7 +149,8 @@ impl Type {\n             ast::UintTy::U8 => Type::i8(ccx),\n             ast::UintTy::U16 => Type::i16(ccx),\n             ast::UintTy::U32 => Type::i32(ccx),\n-            ast::UintTy::U64 => Type::i64(ccx)\n+            ast::UintTy::U64 => Type::i64(ccx),\n+            ast::UintTy::U128 => Type::i128(ccx),\n         }\n     }\n \n@@ -307,6 +313,7 @@ impl Type {\n             I16 => Type::i16(cx),\n             I32 => Type::i32(cx),\n             I64 => Type::i64(cx),\n+            I128 => Type::i128(cx),\n         }\n     }\n "}, {"sha": "4f41bbe9924b0f54fd37da4d9833625b27984aca", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -432,7 +432,9 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n             (true,  32, &ty::TyInt(ast::IntTy::I32)) |\n             (false, 32, &ty::TyUint(ast::UintTy::U32)) |\n             (true,  64, &ty::TyInt(ast::IntTy::I64)) |\n-            (false, 64, &ty::TyUint(ast::UintTy::U64)) => {},\n+            (false, 64, &ty::TyUint(ast::UintTy::U64)) |\n+            (true,  128, &ty::TyInt(ast::IntTy::I128)) |\n+            (false, 128, &ty::TyUint(ast::UintTy::U128)) => {},\n             _ => simple_error(&format!(\"`{}`\", t),\n                               &format!(\"`{}{n}`\",\n                                        if signed {\"i\"} else {\"u\"},"}, {"sha": "5c3da4237bef261e6f7c8c91799e103083a374d0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -435,6 +435,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let lang_def_id = self.tcx.lang_items.i64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n+            ty::TyInt(ast::IntTy::I128) => {\n+                let lang_def_id = self.tcx.lang_items.i128_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n             ty::TyInt(ast::IntTy::Is) => {\n                 let lang_def_id = self.tcx.lang_items.isize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n@@ -455,6 +459,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let lang_def_id = self.tcx.lang_items.u64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n+            ty::TyUint(ast::UintTy::U128) => {\n+                let lang_def_id = self.tcx.lang_items.u128_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n             ty::TyUint(ast::UintTy::Us) => {\n                 let lang_def_id = self.tcx.lang_items.usize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);"}, {"sha": "26dd53fecb243e306626a2ecd57ca7a2bf5ebb74", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -1330,6 +1330,13 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n \n     let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(ccx.tcx);\n+    if repr_type_ty == ccx.tcx.types.i128 || repr_type_ty == ccx.tcx.types.u128 {\n+        if !ccx.tcx.sess.features.borrow().i128_type {\n+            emit_feature_err(&ccx.tcx.sess.parse_sess,\n+                             \"i128_type\", sp, GateIssue::Language, \"128-bit type is unstable\");\n+        }\n+    }\n+\n     for v in vs {\n         if let Some(e) = v.node.disr_expr {\n             check_const_with_type(ccx, e, repr_type_ty, e.node_id);"}, {"sha": "2b5a4515cd0d8d63c576253a3f3e9ad57e87d10d", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -160,6 +160,13 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                                   \"i64\",\n                                                   item.span);\n                     }\n+                    ty::TyInt(ast::IntTy::I128) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.i128_impl(),\n+                                                  \"i128\",\n+                                                  \"i128\",\n+                                                  item.span);\n+                    }\n                     ty::TyInt(ast::IntTy::Is) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.isize_impl(),\n@@ -195,6 +202,13 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                                   \"u64\",\n                                                   item.span);\n                     }\n+                    ty::TyUint(ast::UintTy::U128) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.u128_impl(),\n+                                                  \"u128\",\n+                                                  \"u128\",\n+                                                  item.span);\n+                    }\n                     ty::TyUint(ast::UintTy::Us) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.usize_impl(),"}, {"sha": "7ddf10375bf2384be2a361d3177219986e457d86", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -1060,11 +1060,13 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) |\n                     (attr::SignedInt(ast::IntTy::I32), ConstInt::I32(_)) |\n                     (attr::SignedInt(ast::IntTy::I64), ConstInt::I64(_)) |\n+                    (attr::SignedInt(ast::IntTy::I128), ConstInt::I128(_)) |\n                     (attr::SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) |\n                     (attr::UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) |\n                     (attr::UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) |\n                     (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) |\n                     (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) |\n+                    (attr::UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) |\n                     (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => Some(i),\n                     (_, i) => {\n                         print_err(ConstVal::Integral(i));"}, {"sha": "93854193762fbcf2d2ef7a63e9f2c02250d846c2", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -268,11 +268,13 @@ pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n         tcx.lang_items.i16_impl(),\n         tcx.lang_items.i32_impl(),\n         tcx.lang_items.i64_impl(),\n+        tcx.lang_items.i128_impl(),\n         tcx.lang_items.usize_impl(),\n         tcx.lang_items.u8_impl(),\n         tcx.lang_items.u16_impl(),\n         tcx.lang_items.u32_impl(),\n         tcx.lang_items.u64_impl(),\n+        tcx.lang_items.u128_impl(),\n         tcx.lang_items.f32_impl(),\n         tcx.lang_items.f64_impl(),\n         tcx.lang_items.char_impl(),"}, {"sha": "e0a26ca318189e8226374a2f37f4e3761c8428c0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -1513,8 +1513,8 @@ pub enum Type {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Copy, Debug)]\n pub enum PrimitiveType {\n-    Isize, I8, I16, I32, I64,\n-    Usize, U8, U16, U32, U64,\n+    Isize, I8, I16, I32, I64, I128,\n+    Usize, U8, U16, U32, U64, U128,\n     F32, F64,\n     Char,\n     Bool,\n@@ -1595,11 +1595,13 @@ impl PrimitiveType {\n             \"i16\" => Some(PrimitiveType::I16),\n             \"i32\" => Some(PrimitiveType::I32),\n             \"i64\" => Some(PrimitiveType::I64),\n+            \"i128\" => Some(PrimitiveType::I128),\n             \"usize\" => Some(PrimitiveType::Usize),\n             \"u8\" => Some(PrimitiveType::U8),\n             \"u16\" => Some(PrimitiveType::U16),\n             \"u32\" => Some(PrimitiveType::U32),\n             \"u64\" => Some(PrimitiveType::U64),\n+            \"u128\" => Some(PrimitiveType::U128),\n             \"bool\" => Some(PrimitiveType::Bool),\n             \"char\" => Some(PrimitiveType::Char),\n             \"str\" => Some(PrimitiveType::Str),\n@@ -1614,26 +1616,29 @@ impl PrimitiveType {\n     }\n \n     pub fn as_str(&self) -> &'static str {\n+        use self::PrimitiveType::*;\n         match *self {\n-            PrimitiveType::Isize => \"isize\",\n-            PrimitiveType::I8 => \"i8\",\n-            PrimitiveType::I16 => \"i16\",\n-            PrimitiveType::I32 => \"i32\",\n-            PrimitiveType::I64 => \"i64\",\n-            PrimitiveType::Usize => \"usize\",\n-            PrimitiveType::U8 => \"u8\",\n-            PrimitiveType::U16 => \"u16\",\n-            PrimitiveType::U32 => \"u32\",\n-            PrimitiveType::U64 => \"u64\",\n-            PrimitiveType::F32 => \"f32\",\n-            PrimitiveType::F64 => \"f64\",\n-            PrimitiveType::Str => \"str\",\n-            PrimitiveType::Bool => \"bool\",\n-            PrimitiveType::Char => \"char\",\n-            PrimitiveType::Array => \"array\",\n-            PrimitiveType::Slice => \"slice\",\n-            PrimitiveType::Tuple => \"tuple\",\n-            PrimitiveType::RawPointer => \"pointer\",\n+            Isize => \"isize\",\n+            I8 => \"i8\",\n+            I16 => \"i16\",\n+            I32 => \"i32\",\n+            I64 => \"i64\",\n+            I128 => \"i128\",\n+            Usize => \"usize\",\n+            U8 => \"u8\",\n+            U16 => \"u16\",\n+            U32 => \"u32\",\n+            U64 => \"u64\",\n+            U128 => \"u128\",\n+            F32 => \"f32\",\n+            F64 => \"f64\",\n+            Str => \"str\",\n+            Bool => \"bool\",\n+            Char => \"char\",\n+            Array => \"array\",\n+            Slice => \"slice\",\n+            Tuple => \"tuple\",\n+            RawPointer => \"pointer\",\n         }\n     }\n \n@@ -1650,6 +1655,7 @@ impl From<ast::IntTy> for PrimitiveType {\n             ast::IntTy::I16 => PrimitiveType::I16,\n             ast::IntTy::I32 => PrimitiveType::I32,\n             ast::IntTy::I64 => PrimitiveType::I64,\n+            ast::IntTy::I128 => PrimitiveType::I128,\n         }\n     }\n }\n@@ -1662,6 +1668,7 @@ impl From<ast::UintTy> for PrimitiveType {\n             ast::UintTy::U16 => PrimitiveType::U16,\n             ast::UintTy::U32 => PrimitiveType::U32,\n             ast::UintTy::U64 => PrimitiveType::U64,\n+            ast::UintTy::U128 => PrimitiveType::U128,\n         }\n     }\n }\n@@ -2486,6 +2493,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n fn build_deref_target_impls(cx: &DocContext,\n                             items: &[Item],\n                             ret: &mut Vec<Item>) {\n+    use self::PrimitiveType::*;\n     let tcx = cx.tcx;\n \n     for item in items {\n@@ -2505,25 +2513,27 @@ fn build_deref_target_impls(cx: &DocContext,\n             }\n         };\n         let did = match primitive {\n-            PrimitiveType::Isize => tcx.lang_items.isize_impl(),\n-            PrimitiveType::I8 => tcx.lang_items.i8_impl(),\n-            PrimitiveType::I16 => tcx.lang_items.i16_impl(),\n-            PrimitiveType::I32 => tcx.lang_items.i32_impl(),\n-            PrimitiveType::I64 => tcx.lang_items.i64_impl(),\n-            PrimitiveType::Usize => tcx.lang_items.usize_impl(),\n-            PrimitiveType::U8 => tcx.lang_items.u8_impl(),\n-            PrimitiveType::U16 => tcx.lang_items.u16_impl(),\n-            PrimitiveType::U32 => tcx.lang_items.u32_impl(),\n-            PrimitiveType::U64 => tcx.lang_items.u64_impl(),\n-            PrimitiveType::F32 => tcx.lang_items.f32_impl(),\n-            PrimitiveType::F64 => tcx.lang_items.f64_impl(),\n-            PrimitiveType::Char => tcx.lang_items.char_impl(),\n-            PrimitiveType::Bool => None,\n-            PrimitiveType::Str => tcx.lang_items.str_impl(),\n-            PrimitiveType::Slice => tcx.lang_items.slice_impl(),\n-            PrimitiveType::Array => tcx.lang_items.slice_impl(),\n-            PrimitiveType::Tuple => None,\n-            PrimitiveType::RawPointer => tcx.lang_items.const_ptr_impl(),\n+            Isize => tcx.lang_items.isize_impl(),\n+            I8 => tcx.lang_items.i8_impl(),\n+            I16 => tcx.lang_items.i16_impl(),\n+            I32 => tcx.lang_items.i32_impl(),\n+            I64 => tcx.lang_items.i64_impl(),\n+            I128 => tcx.lang_items.i128_impl(),\n+            Usize => tcx.lang_items.usize_impl(),\n+            U8 => tcx.lang_items.u8_impl(),\n+            U16 => tcx.lang_items.u16_impl(),\n+            U32 => tcx.lang_items.u32_impl(),\n+            U64 => tcx.lang_items.u64_impl(),\n+            U128 => tcx.lang_items.u128_impl(),\n+            F32 => tcx.lang_items.f32_impl(),\n+            F64 => tcx.lang_items.f64_impl(),\n+            Char => tcx.lang_items.char_impl(),\n+            Bool => None,\n+            Str => tcx.lang_items.str_impl(),\n+            Slice => tcx.lang_items.slice_impl(),\n+            Array => tcx.lang_items.slice_impl(),\n+            Tuple => None,\n+            RawPointer => tcx.lang_items.const_ptr_impl(),\n         };\n         if let Some(did) = did {\n             if !did.is_local() {"}, {"sha": "3213b4e4208be91e1240ecec4219ad6511d2a75b", "filename": "src/libserialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibserialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibserialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2FCargo.toml?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -10,3 +10,4 @@ crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n log = { path = \"../liblog\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "3e62026f512195d23069b64ff38b12c54e33998c", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -211,6 +211,8 @@ use std::string;\n use std::{char, f64, fmt, str};\n use std;\n \n+use rustc_i128::{i128, u128};\n+\n use Encodable;\n \n /// Represents a json value\n@@ -494,12 +496,14 @@ impl<'a> ::Encoder for Encoder<'a> {\n     }\n \n     fn emit_usize(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u128(&mut self, v: u128) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n     fn emit_isize(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i128(&mut self, v: i128) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n@@ -742,12 +746,14 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     }\n \n     fn emit_usize(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u128(&mut self, v: u128) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n     fn emit_isize(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i128(&mut self, v: i128) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n@@ -2138,11 +2144,13 @@ impl ::Decoder for Decoder {\n     read_primitive! { read_u16, u16 }\n     read_primitive! { read_u32, u32 }\n     read_primitive! { read_u64, u64 }\n+    read_primitive! { read_u128, u128 }\n     read_primitive! { read_isize, isize }\n     read_primitive! { read_i8, i8 }\n     read_primitive! { read_i16, i16 }\n     read_primitive! { read_i32, i32 }\n     read_primitive! { read_i64, i64 }\n+    read_primitive! { read_i128, i128 }\n \n     fn read_f32(&mut self) -> DecodeResult<f32> { self.read_f64().map(|x| x as f32) }\n "}, {"sha": "392f332d508dd64e1979579531023b19066cb0cc", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc_i128::{i128, u128};\n+\n #[inline]\n fn write_to_vec(vec: &mut Vec<u8>, position: usize, byte: u8) {\n     if position == vec.len() {\n@@ -24,11 +26,10 @@ fn write_to_vec(vec: &mut Vec<u8>, position: usize, byte: u8) {\n /// The callback `write` is called once for each position\n /// that is to be written to with the byte to be encoded\n /// at that position.\n-pub fn write_unsigned_leb128_to<W>(mut value: u64, mut write: W) -> usize\n+pub fn write_unsigned_leb128_to<W>(mut value: u128, mut write: W) -> usize\n     where W: FnMut(usize, u8)\n {\n     let mut position = 0;\n-\n     loop {\n         let mut byte = (value & 0x7F) as u8;\n         value >>= 7;\n@@ -47,19 +48,19 @@ pub fn write_unsigned_leb128_to<W>(mut value: u64, mut write: W) -> usize\n     position\n }\n \n-pub fn write_unsigned_leb128(out: &mut Vec<u8>, start_position: usize, value: u64) -> usize {\n+pub fn write_unsigned_leb128(out: &mut Vec<u8>, start_position: usize, value: u128) -> usize {\n     write_unsigned_leb128_to(value, |i, v| write_to_vec(out, start_position+i, v))\n }\n \n #[inline]\n-pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u64, usize) {\n+pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u128, usize) {\n     let mut result = 0;\n     let mut shift = 0;\n     let mut position = start_position;\n     loop {\n         let byte = data[position];\n         position += 1;\n-        result |= ((byte & 0x7F) as u64) << shift;\n+        result |= ((byte & 0x7F) as u128) << shift;\n         if (byte & 0x80) == 0 {\n             break;\n         }\n@@ -76,7 +77,7 @@ pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u64, usize)\n /// The callback `write` is called once for each position\n /// that is to be written to with the byte to be encoded\n /// at that position.\n-pub fn write_signed_leb128_to<W>(mut value: i64, mut write: W) -> usize\n+pub fn write_signed_leb128_to<W>(mut value: i128, mut write: W) -> usize\n     where W: FnMut(usize, u8)\n {\n     let mut position = 0;\n@@ -86,6 +87,7 @@ pub fn write_signed_leb128_to<W>(mut value: i64, mut write: W) -> usize\n         value >>= 7;\n         let more = !((((value == 0) && ((byte & 0x40) == 0)) ||\n                       ((value == -1) && ((byte & 0x40) != 0))));\n+\n         if more {\n             byte |= 0x80; // Mark this byte to show that more bytes will follow.\n         }\n@@ -97,16 +99,15 @@ pub fn write_signed_leb128_to<W>(mut value: i64, mut write: W) -> usize\n             break;\n         }\n     }\n-\n     position\n }\n \n-pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, value: i64) -> usize {\n+pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, value: i128) -> usize {\n     write_signed_leb128_to(value, |i, v| write_to_vec(out, start_position+i, v))\n }\n \n #[inline]\n-pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i64, usize) {\n+pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i128, usize) {\n     let mut result = 0;\n     let mut shift = 0;\n     let mut position = start_position;\n@@ -115,7 +116,7 @@ pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i64, usize) {\n     loop {\n         byte = data[position];\n         position += 1;\n-        result |= ((byte & 0x7F) as i64) << shift;\n+        result |= ((byte & 0x7F) as i128) << shift;\n         shift += 7;\n \n         if (byte & 0x80) == 0 {\n@@ -125,7 +126,7 @@ pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i64, usize) {\n \n     if (shift < 64) && ((byte & 0x40) != 0) {\n         // sign extend\n-        result |= -(1i64 << shift);\n+        result |= -(1 << shift);\n     }\n \n     (result, position - start_position)\n@@ -153,22 +154,13 @@ fn test_unsigned_leb128() {\n \n #[test]\n fn test_signed_leb128() {\n-    let mut values = Vec::new();\n-\n-    let mut i = -500;\n-    while i < 500 {\n-        values.push(i * 123457i64);\n-        i += 1;\n-    }\n-\n+    let values: Vec<_> = (-500..500).map(|i| i * 0x12345789ABCDEF).collect();\n     let mut stream = Vec::new();\n-\n     for &x in &values {\n         let pos = stream.len();\n         let bytes_written = write_signed_leb128(&mut stream, pos, x);\n         assert_eq!(stream.len(), pos + bytes_written);\n     }\n-\n     let mut pos = 0;\n     for &x in &values {\n         let (value, bytes_read) = read_signed_leb128(&mut stream, pos);"}, {"sha": "0979860189ca1d5973406733755f650044e22b8f", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -44,6 +44,8 @@ Core encoding and decoding interfaces.\n extern crate std_unicode;\n extern crate collections;\n \n+extern crate rustc_i128;\n+\n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable};\n \n pub use self::serialize::{SpecializationError, SpecializedEncoder, SpecializedDecoder};"}, {"sha": "8a0648d5851a18b988ee74c08d6fb711a1de9284", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -13,6 +13,8 @@ use std::borrow::Cow;\n use std::io::{self, Write};\n use serialize;\n \n+use rustc_i128::{i128, u128};\n+\n // -----------------------------------------------------------------------------\n // Encoder\n // -----------------------------------------------------------------------------\n@@ -33,7 +35,7 @@ impl<'a> Encoder<'a> {\n macro_rules! write_uleb128 {\n     ($enc:expr, $value:expr) => {{\n         let pos = $enc.cursor.position() as usize;\n-        let bytes_written = write_unsigned_leb128($enc.cursor.get_mut(), pos, $value as u64);\n+        let bytes_written = write_unsigned_leb128($enc.cursor.get_mut(), pos, $value as u128);\n         $enc.cursor.set_position((pos + bytes_written) as u64);\n         Ok(())\n     }}\n@@ -42,7 +44,7 @@ macro_rules! write_uleb128 {\n macro_rules! write_sleb128 {\n     ($enc:expr, $value:expr) => {{\n         let pos = $enc.cursor.position() as usize;\n-        let bytes_written = write_signed_leb128($enc.cursor.get_mut(), pos, $value as i64);\n+        let bytes_written = write_signed_leb128($enc.cursor.get_mut(), pos, $value as i128);\n         $enc.cursor.set_position((pos + bytes_written) as u64);\n         Ok(())\n     }}\n@@ -59,6 +61,10 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         write_uleb128!(self, v)\n     }\n \n+    fn emit_u128(&mut self, v: u128) -> EncodeResult {\n+        write_uleb128!(self, v)\n+    }\n+\n     fn emit_u64(&mut self, v: u64) -> EncodeResult {\n         write_uleb128!(self, v)\n     }\n@@ -80,6 +86,10 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         write_sleb128!(self, v)\n     }\n \n+    fn emit_i128(&mut self, v: i128) -> EncodeResult {\n+        write_sleb128!(self, v)\n+    }\n+\n     fn emit_i64(&mut self, v: i64) -> EncodeResult {\n         write_sleb128!(self, v)\n     }\n@@ -184,6 +194,11 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         Ok(())\n     }\n \n+    #[inline]\n+    fn read_u128(&mut self) -> Result<u128, Self::Error> {\n+        read_uleb128!(self, u128)\n+    }\n+\n     #[inline]\n     fn read_u64(&mut self) -> Result<u64, Self::Error> {\n         read_uleb128!(self, u64)\n@@ -211,6 +226,11 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         read_uleb128!(self, usize)\n     }\n \n+    #[inline]\n+    fn read_i128(&mut self) -> Result<i128, Self::Error> {\n+        read_sleb128!(self, i128)\n+    }\n+\n     #[inline]\n     fn read_i64(&mut self) -> Result<i64, Self::Error> {\n         read_sleb128!(self, i64)"}, {"sha": "395f2ccbe6d28ef166780479f8b9f1c538dc4df1", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -20,18 +20,21 @@ use std::path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n use std::sync::Arc;\n+use rustc_i128::{i128, u128};\n \n pub trait Encoder {\n     type Error;\n \n     // Primitive types:\n     fn emit_nil(&mut self) -> Result<(), Self::Error>;\n     fn emit_usize(&mut self, v: usize) -> Result<(), Self::Error>;\n+    fn emit_u128(&mut self, v: u128) -> Result<(), Self::Error>;\n     fn emit_u64(&mut self, v: u64) -> Result<(), Self::Error>;\n     fn emit_u32(&mut self, v: u32) -> Result<(), Self::Error>;\n     fn emit_u16(&mut self, v: u16) -> Result<(), Self::Error>;\n     fn emit_u8(&mut self, v: u8) -> Result<(), Self::Error>;\n     fn emit_isize(&mut self, v: isize) -> Result<(), Self::Error>;\n+    fn emit_i128(&mut self, v: i128) -> Result<(), Self::Error>;\n     fn emit_i64(&mut self, v: i64) -> Result<(), Self::Error>;\n     fn emit_i32(&mut self, v: i32) -> Result<(), Self::Error>;\n     fn emit_i16(&mut self, v: i16) -> Result<(), Self::Error>;\n@@ -144,11 +147,13 @@ pub trait Decoder {\n     // Primitive types:\n     fn read_nil(&mut self) -> Result<(), Self::Error>;\n     fn read_usize(&mut self) -> Result<usize, Self::Error>;\n+    fn read_u128(&mut self) -> Result<u128, Self::Error>;\n     fn read_u64(&mut self) -> Result<u64, Self::Error>;\n     fn read_u32(&mut self) -> Result<u32, Self::Error>;\n     fn read_u16(&mut self) -> Result<u16, Self::Error>;\n     fn read_u8(&mut self) -> Result<u8, Self::Error>;\n     fn read_isize(&mut self) -> Result<isize, Self::Error>;\n+    fn read_i128(&mut self) -> Result<i128, Self::Error>;\n     fn read_i64(&mut self) -> Result<i64, Self::Error>;\n     fn read_i32(&mut self) -> Result<i32, Self::Error>;\n     fn read_i16(&mut self) -> Result<i16, Self::Error>;\n@@ -328,6 +333,20 @@ impl Decodable for u64 {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Encodable for u128 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_u128(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl Decodable for u128 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<u128, D::Error> {\n+        d.read_u128()\n+    }\n+}\n+\n impl Encodable for isize {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_isize(*self)\n@@ -388,6 +407,20 @@ impl Decodable for i64 {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Encodable for i128 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_i128(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl Decodable for i128 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<i128, D::Error> {\n+        d.read_i128()\n+    }\n+}\n+\n impl Encodable for str {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(self)"}, {"sha": "f1e3996e825bfee7444d6fa777b265091e320540", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -301,6 +301,7 @@\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n #![feature(zero_one)]\n+#![feature(i128)]\n #![cfg_attr(test, feature(update_panic_count))]\n \n // Explicitly import the prelude. The compiler uses this same unstable attribute\n@@ -395,6 +396,9 @@ pub use core::i16;\n pub use core::i32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::i64;\n+#[unstable(feature = \"i128\", issue = \"35118\")]\n+#[cfg(not(stage0))]\n+pub use core::i128;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::usize;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -423,6 +427,9 @@ pub use core_collections::string;\n pub use core_collections::vec;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use std_unicode::char;\n+#[unstable(feature = \"i128\", issue = \"35118\")]\n+#[cfg(not(stage0))]\n+pub use core::u128;\n \n pub mod f32;\n pub mod f64;"}, {"sha": "5981b482a972897546c35bd45b2a5dbfd23a0494", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -597,6 +597,17 @@ mod prim_i32 { }\n ///\n mod prim_i64 { }\n \n+#[doc(primitive = \"i128\")]\n+//\n+/// The 128-bit signed integer type.\n+///\n+/// *[See also the `std::i128` module](i128/index.html).*\n+///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `i8` in there.\n+///\n+mod prim_i128 { }\n+\n #[doc(primitive = \"u8\")]\n //\n /// The 8-bit unsigned integer type.\n@@ -641,6 +652,17 @@ mod prim_u32 { }\n ///\n mod prim_u64 { }\n \n+#[doc(primitive = \"u128\")]\n+//\n+/// The 128-bit unsigned integer type.\n+///\n+/// *[See also the `std::u128` module](u128/index.html).*\n+///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `u8` in there.\n+///\n+mod prim_u128 { }\n+\n #[doc(primitive = \"isize\")]\n //\n /// The pointer-sized signed integer type."}, {"sha": "a200da6c293eae0ccd1d764d043e86ae5e877104", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -15,3 +15,4 @@ rustc_bitflags = { path = \"../librustc_bitflags\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "75554f20effeea2bda313212ce18d4c923b9111f", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -50,6 +50,7 @@ pub enum Abi {\n     RustIntrinsic,\n     RustCall,\n     PlatformIntrinsic,\n+    Unadjusted\n }\n \n #[allow(non_camel_case_types)]\n@@ -92,6 +93,7 @@ const AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: Abi::RustIntrinsic, name: \"rust-intrinsic\", generic: true },\n     AbiData {abi: Abi::RustCall, name: \"rust-call\", generic: true },\n     AbiData {abi: Abi::PlatformIntrinsic, name: \"platform-intrinsic\", generic: true },\n+    AbiData {abi: Abi::Unadjusted, name: \"unadjusted\", generic: true },\n ];\n \n /// Returns the ABI with the given name (if any)."}, {"sha": "da4b787160fb2b921bdc2977ed19d335157abdb5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -33,6 +33,8 @@ use std::u32;\n \n use serialize::{self, Encodable, Decodable, Encoder, Decoder};\n \n+use rustc_i128::{u128, i128};\n+\n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n /// macro expansion per Flatt et al., \"Macros That Work Together\"\n@@ -1062,7 +1064,7 @@ pub enum LitKind {\n     /// A character literal (`'a'`)\n     Char(char),\n     /// An integer literal (`1`)\n-    Int(u64, LitIntType),\n+    Int(u128, LitIntType),\n     /// A float literal (`1f64` or `1E10f64`)\n     Float(Symbol, FloatTy),\n     /// A float literal without a suffix (`1.0 or 1.0E10`)\n@@ -1171,6 +1173,7 @@ pub enum IntTy {\n     I16,\n     I32,\n     I64,\n+    I128,\n }\n \n impl fmt::Debug for IntTy {\n@@ -1192,24 +1195,16 @@ impl IntTy {\n             IntTy::I8 => \"i8\",\n             IntTy::I16 => \"i16\",\n             IntTy::I32 => \"i32\",\n-            IntTy::I64 => \"i64\"\n+            IntTy::I64 => \"i64\",\n+            IntTy::I128 => \"i128\",\n         }\n     }\n \n-    pub fn val_to_string(&self, val: i64) -> String {\n-        // cast to a u64 so we can correctly print INT64_MIN. All integral types\n-        // are parsed as u64, so we wouldn't want to print an extra negative\n+    pub fn val_to_string(&self, val: i128) -> String {\n+        // cast to a u128 so we can correctly print INT128_MIN. All integral types\n+        // are parsed as u128, so we wouldn't want to print an extra negative\n         // sign.\n-        format!(\"{}{}\", val as u64, self.ty_to_string())\n-    }\n-\n-    pub fn ty_max(&self) -> u64 {\n-        match *self {\n-            IntTy::I8 => 0x80,\n-            IntTy::I16 => 0x8000,\n-            IntTy::Is | IntTy::I32 => 0x80000000, // FIXME: actually ni about Is\n-            IntTy::I64 => 0x8000000000000000\n-        }\n+        format!(\"{}{}\", val as u128, self.ty_to_string())\n     }\n \n     pub fn bit_width(&self) -> Option<usize> {\n@@ -1219,6 +1214,7 @@ impl IntTy {\n             IntTy::I16 => 16,\n             IntTy::I32 => 32,\n             IntTy::I64 => 64,\n+            IntTy::I128 => 128,\n         })\n     }\n }\n@@ -1230,6 +1226,7 @@ pub enum UintTy {\n     U16,\n     U32,\n     U64,\n+    U128,\n }\n \n impl UintTy {\n@@ -1239,30 +1236,23 @@ impl UintTy {\n             UintTy::U8 => \"u8\",\n             UintTy::U16 => \"u16\",\n             UintTy::U32 => \"u32\",\n-            UintTy::U64 => \"u64\"\n+            UintTy::U64 => \"u64\",\n+            UintTy::U128 => \"u128\",\n         }\n     }\n \n-    pub fn val_to_string(&self, val: u64) -> String {\n+    pub fn val_to_string(&self, val: u128) -> String {\n         format!(\"{}{}\", val, self.ty_to_string())\n     }\n \n-    pub fn ty_max(&self) -> u64 {\n-        match *self {\n-            UintTy::U8 => 0xff,\n-            UintTy::U16 => 0xffff,\n-            UintTy::Us | UintTy::U32 => 0xffffffff, // FIXME: actually ni about Us\n-            UintTy::U64 => 0xffffffffffffffff\n-        }\n-    }\n-\n     pub fn bit_width(&self) -> Option<usize> {\n         Some(match *self {\n             UintTy::Us => return None,\n             UintTy::U8 => 8,\n             UintTy::U16 => 16,\n             UintTy::U32 => 32,\n             UintTy::U64 => 64,\n+            UintTy::U128 => 128,\n         })\n     }\n }"}, {"sha": "ab8a49b41f25ec876cdeb6a150eceaddf7086ab0", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -899,6 +899,8 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n         \"u32\" => Some(UnsignedInt(ast::UintTy::U32)),\n         \"i64\" => Some(SignedInt(ast::IntTy::I64)),\n         \"u64\" => Some(UnsignedInt(ast::UintTy::U64)),\n+        \"i128\" => Some(SignedInt(ast::IntTy::I128)),\n+        \"u128\" => Some(UnsignedInt(ast::UintTy::U128)),\n         \"isize\" => Some(SignedInt(ast::IntTy::Is)),\n         \"usize\" => Some(UnsignedInt(ast::UintTy::Us)),\n         _ => None\n@@ -945,7 +947,8 @@ impl IntType {\n             SignedInt(ast::IntTy::I8) | UnsignedInt(ast::UintTy::U8) |\n             SignedInt(ast::IntTy::I16) | UnsignedInt(ast::UintTy::U16) |\n             SignedInt(ast::IntTy::I32) | UnsignedInt(ast::UintTy::U32) |\n-            SignedInt(ast::IntTy::I64) | UnsignedInt(ast::UintTy::U64) => true,\n+            SignedInt(ast::IntTy::I64) | UnsignedInt(ast::UintTy::U64) |\n+            SignedInt(ast::IntTy::I128) | UnsignedInt(ast::UintTy::U128) => true,\n             SignedInt(ast::IntTy::Is) | UnsignedInt(ast::UintTy::Us) => false\n         }\n     }"}, {"sha": "28f0c297303e38f590c9775cd9f1990d2e26afdf", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -16,6 +16,7 @@ use codemap::{dummy_spanned, respan, Spanned};\n use ext::base::ExtCtxt;\n use ptr::P;\n use symbol::{Symbol, keywords};\n+use rustc_i128::u128;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -712,23 +713,26 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::Lit(P(respan(sp, lit))))\n     }\n     fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n-        self.expr_lit(span, ast::LitKind::Int(i as u64, ast::LitIntType::Unsigned(ast::UintTy::Us)))\n+        self.expr_lit(span, ast::LitKind::Int(i as u128,\n+                                              ast::LitIntType::Unsigned(ast::UintTy::Us)))\n     }\n     fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr> {\n         if i < 0 {\n-            let i = (-i) as u64;\n+            let i = (-i) as u128;\n             let lit_ty = ast::LitIntType::Signed(ast::IntTy::Is);\n             let lit = self.expr_lit(sp, ast::LitKind::Int(i, lit_ty));\n             self.expr_unary(sp, ast::UnOp::Neg, lit)\n         } else {\n-            self.expr_lit(sp, ast::LitKind::Int(i as u64, ast::LitIntType::Signed(ast::IntTy::Is)))\n+            self.expr_lit(sp, ast::LitKind::Int(i as u128,\n+                                                ast::LitIntType::Signed(ast::IntTy::Is)))\n         }\n     }\n     fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u64, ast::LitIntType::Unsigned(ast::UintTy::U32)))\n+        self.expr_lit(sp, ast::LitKind::Int(u as u128,\n+                                            ast::LitIntType::Unsigned(ast::UintTy::U32)))\n     }\n     fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u64, ast::LitIntType::Unsigned(ast::UintTy::U8)))\n+        self.expr_lit(sp, ast::LitKind::Int(u as u128, ast::LitIntType::Unsigned(ast::UintTy::U8)))\n     }\n     fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Bool(value))"}, {"sha": "d2eb2636e6b31deaff6bab62a6623e278efb3e16", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -19,6 +19,7 @@ use parse::token;\n use ptr::P;\n use tokenstream::{self, TokenTree};\n \n+\n /// Quasiquoting works via token trees.\n ///\n /// This is registered as a set of expression syntax extension called quote!\n@@ -40,6 +41,7 @@ pub mod rt {\n     pub use parse::new_parser_from_tts;\n     pub use syntax_pos::{BytePos, Span, DUMMY_SP};\n     pub use codemap::{dummy_spanned};\n+    use rustc_i128::{u128};\n \n     pub trait ToTokens {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree>;\n@@ -288,7 +290,7 @@ pub mod rt {\n                     } else {\n                         *self\n                     };\n-                    let lit = ast::LitKind::Int(val as u64, ast::LitIntType::Signed($tag));\n+                    let lit = ast::LitKind::Int(val as u128, ast::LitIntType::Signed($tag));\n                     let lit = P(ast::Expr {\n                         id: ast::DUMMY_NODE_ID,\n                         node: ast::ExprKind::Lit(P(dummy_spanned(lit))),\n@@ -310,7 +312,7 @@ pub mod rt {\n         (unsigned, $t:ty, $tag:expr) => (\n             impl ToTokens for $t {\n                 fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-                    let lit = ast::LitKind::Int(*self as u64, ast::LitIntType::Unsigned($tag));\n+                    let lit = ast::LitKind::Int(*self as u128, ast::LitIntType::Unsigned($tag));\n                     dummy_spanned(lit).to_tokens(cx)\n                 }\n             }"}, {"sha": "e7df454cf6a50220783c7c533d8934a8ff5250b3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -321,6 +321,12 @@ declare_features! (\n \n     // `extern \"ptx-*\" fn()`\n     (active, abi_ptx, \"1.15.0\", None),\n+\n+    // The `i128` type\n+    (active, i128_type, \"1.16.0\", Some(35118)),\n+\n+    // The `unadjusted` ABI. Perma unstable.\n+    (active, abi_unadjusted, \"1.16.0\", None),\n );\n \n declare_features! (\n@@ -992,7 +998,11 @@ impl<'a> PostExpansionVisitor<'a> {\n             Abi::PtxKernel => {\n                 gate_feature_post!(&self, abi_ptx, span,\n                                    \"PTX ABIs are experimental and subject to change\");\n-            }\n+            },\n+            Abi::Unadjusted => {\n+                gate_feature_post!(&self, abi_unadjusted, span,\n+                                   \"unadjusted ABI is an implementation detail and perma-unstable\");\n+            },\n             // Stable\n             Abi::Cdecl |\n             Abi::Stdcall |\n@@ -1215,6 +1225,18 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, loop_break_value, e.span,\n                                    \"`break` with a value is experimental\");\n             }\n+            ast::ExprKind::Lit(ref lit) => {\n+                if let ast::LitKind::Int(_, ref ty) = lit.node {\n+                    match *ty {\n+                        ast::LitIntType::Signed(ast::IntTy::I128) |\n+                        ast::LitIntType::Unsigned(ast::UintTy::U128) => {\n+                            gate_feature_post!(&self, i128_type, e.span,\n+                                               \"128-bit integers are not stable\");\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "5d6808284f67edba031f3e3d15812035392fb706", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -46,8 +46,9 @@ pub extern crate rustc_errors as errors;\n extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n-extern crate serialize as rustc_serialize; // used by deriving\n+extern crate rustc_i128;\n \n+extern crate serialize as rustc_serialize; // used by deriving\n \n // A variant of 'try!' that panics on an Err. This is used as a crutch on the\n // way towards a non-panic!-prone parser. It should be used for fatal parsing"}, {"sha": "32b61a88ac17f78c94b46a7390f7ab36e2030a6c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -28,6 +28,8 @@ use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::str;\n \n+use rustc_i128::u128;\n+\n pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n \n #[macro_use]\n@@ -557,18 +559,20 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n             \"i16\" => ast::LitIntType::Signed(ast::IntTy::I16),\n             \"i32\" => ast::LitIntType::Signed(ast::IntTy::I32),\n             \"i64\" => ast::LitIntType::Signed(ast::IntTy::I64),\n+            \"i128\" => ast::LitIntType::Signed(ast::IntTy::I128),\n             \"usize\" => ast::LitIntType::Unsigned(ast::UintTy::Us),\n             \"u8\"  => ast::LitIntType::Unsigned(ast::UintTy::U8),\n             \"u16\" => ast::LitIntType::Unsigned(ast::UintTy::U16),\n             \"u32\" => ast::LitIntType::Unsigned(ast::UintTy::U32),\n             \"u64\" => ast::LitIntType::Unsigned(ast::UintTy::U64),\n+            \"u128\" => ast::LitIntType::Unsigned(ast::UintTy::U128),\n             suf => {\n                 // i<digits> and u<digits> look like widths, so lets\n                 // give an error message along those lines\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n                     sd.struct_span_err(sp, &format!(\"invalid width `{}` for integer literal\",\n                                              &suf[1..]))\n-                      .help(\"valid widths are 8, 16, 32 and 64\")\n+                      .help(\"valid widths are 8, 16, 32, 64 and 128\")\n                       .emit();\n                 } else {\n                     sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for numeric literal\", suf))\n@@ -585,7 +589,7 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n     debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n            string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n \n-    match u64::from_str_radix(s, base) {\n+    match u128::from_str_radix(s, base) {\n         Ok(r) => ast::LitKind::Int(r, ty),\n         Err(_) => {\n             // small bases are lexed as if they were base 10, e.g, the string"}, {"sha": "2bb38433a26efc47e5c5ce0f8070c8bfb8093796", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -64,6 +64,8 @@ use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::slice;\n \n+use rustc_i128::u128;\n+\n bitflags! {\n     flags Restrictions: u8 {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n@@ -2044,7 +2046,7 @@ impl<'a> Parser<'a> {\n     pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinVec<Attribute>) -> P<Expr> {\n         let span = &self.span;\n         let lv_lit = P(codemap::Spanned {\n-            node: LitKind::Int(i as u64, ast::LitIntType::Unsigned(UintTy::U32)),\n+            node: LitKind::Int(i as u128, ast::LitIntType::Unsigned(UintTy::U32)),\n             span: *span\n         });\n "}, {"sha": "60e1882fcf582c4ad36f4f423ce3c2b29405641c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -30,6 +30,8 @@ use std_inject;\n use symbol::{Symbol, keywords};\n use tokenstream::{self, TokenTree};\n \n+use rustc_i128::i128;\n+\n use std::ascii;\n use std::io::{self, Write, Read};\n use std::iter;\n@@ -647,8 +649,7 @@ pub trait PrintState<'a> {\n             ast::LitKind::Int(i, t) => {\n                 match t {\n                     ast::LitIntType::Signed(st) => {\n-                        word(self.writer(),\n-                             &st.val_to_string(i as i64))\n+                        word(self.writer(), &st.val_to_string(i as i128))\n                     }\n                     ast::LitIntType::Unsigned(ut) => {\n                         word(self.writer(), &ut.val_to_string(i))"}, {"sha": "0d2f4eaaffda3097a903bef2745c247feee035db", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -782,12 +782,14 @@ fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &\n                 attr::ReprInt(attr::SignedInt(ast::IntTy::I16)) => \"i16\",\n                 attr::ReprInt(attr::SignedInt(ast::IntTy::I32)) => \"i32\",\n                 attr::ReprInt(attr::SignedInt(ast::IntTy::I64)) => \"i64\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::I128)) => \"i128\",\n \n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::Us)) => \"usize\",\n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::U8)) => \"u8\",\n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::U16)) => \"u16\",\n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::U32)) => \"u32\",\n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::U64)) => \"u64\",\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U128)) => \"u128\",\n             }\n         }\n     }"}, {"sha": "e87d2b53995b9f28ea6fa8d8fa6737a97c80b1d3", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -1246,6 +1246,23 @@ extern \"C\" void LLVMRustSetLinkage(LLVMValueRef V,\n   LLVMSetLinkage(V, from_rust(RustLinkage));\n }\n \n+// Returns true if both high and low were successfully set. Fails in case constant wasn\u2019t any of\n+// the common sizes (1, 8, 16, 32, 64, 128 bits)\n+extern \"C\" bool LLVMRustConstInt128Get(LLVMValueRef CV, bool sext, uint64_t *high, uint64_t *low)\n+{\n+    auto C = unwrap<llvm::ConstantInt>(CV);\n+    if (C->getBitWidth() > 128) { return false; }\n+    APInt AP;\n+    if (sext) {\n+        AP = C->getValue().sextOrSelf(128);\n+    } else {\n+        AP = C->getValue().zextOrSelf(128);\n+    }\n+    *low = AP.getLoBits(64).getZExtValue();\n+    *high = AP.getHiBits(64).getZExtValue();\n+    return true;\n+}\n+\n extern \"C\" LLVMContextRef LLVMRustGetValueContext(LLVMValueRef V) {\n   return wrap(&unwrap(V)->getContext());\n }"}, {"sha": "f3fb92e2b2206f5ddf47770edeed7d91531a3797", "filename": "src/test/compile-fail/const-tup-index-span.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -10,7 +10,7 @@\n \n // Test spans of errors\n \n-const TUP: (usize,) = 5 << 64;\n+const TUP: (usize,) = 5usize << 64;\n //~^ ERROR E0080\n //~| attempt to shift left with overflow\n const ARR: [i32; TUP.0] = [];"}, {"sha": "4a76d39921842b563377c01527e703052d99af26", "filename": "src/test/compile-fail/i128-feature-2.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fcompile-fail%2Fi128-feature-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fcompile-fail%2Fi128-feature-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fi128-feature-2.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+fn test1() -> i128 { //~ ERROR 128-bit type is unstable\n+    0\n+}\n+\n+fn test1_2() -> u128 { //~ ERROR 128-bit type is unstable\n+    0\n+}\n+\n+fn test3() {\n+    let x: i128 = 0; //~ ERROR 128-bit type is unstable\n+}\n+\n+fn test3_2() {\n+    let x: u128 = 0; //~ ERROR 128-bit type is unstable\n+}\n+\n+#[repr(u128)]\n+enum A { //~ ERROR 128-bit type is unstable\n+    A(u64)\n+}"}, {"sha": "87dda469f93900a29076c0b5f2661f80c8f46aa4", "filename": "src/test/compile-fail/i128-feature.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fcompile-fail%2Fi128-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fcompile-fail%2Fi128-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fi128-feature.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+fn test2() {\n+    0i128; //~ ERROR 128-bit integers are not stable\n+}\n+\n+fn test2_2() {\n+    0u128; //~ ERROR 128-bit integers are not stable\n+}\n+"}, {"sha": "501f4451ed8d51b6982f001ec10ddc214210001c", "filename": "src/test/compile-fail/unadjusted-unstable.rs", "status": "renamed", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fcompile-fail%2Funadjusted-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fcompile-fail%2Funadjusted-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funadjusted-unstable.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+extern \"unadjusted\" fn foo() {\n+//~^ ERROR: unadjusted ABI is an implementation detail and perma-unstable\n+}\n+\n fn main() {\n-    println!(\"{}\", 18446744073709551616u64);  //~ error: int literal is too large\n+    foo();\n }", "previous_filename": "src/test/compile-fail/oversized-literal.rs"}, {"sha": "1af8df7d2f64441f3a56e64d700d9dd90c6bb5bd", "filename": "src/test/parse-fail/int-literal-too-large-span.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fparse-fail%2Fint-literal-too-large-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fparse-fail%2Fint-literal-too-large-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fint-literal-too-large-span.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -13,7 +13,7 @@\n // issue #17123\n \n fn main() {\n-    100000000000000000000000000000000 //~ ERROR int literal is too large\n-\n+    9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n+    //~^ ERROR int literal is too large\n         ; // the span shouldn't point to this.\n }"}, {"sha": "cf1500e34d874ad279ac6e81fde6392d8144e916", "filename": "src/test/parse-fail/issue-5544-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fparse-fail%2Fissue-5544-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fparse-fail%2Fissue-5544-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-5544-a.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -11,6 +11,6 @@\n // compile-flags: -Z parse-only\n \n fn main() {\n-    let __isize = 18446744073709551616; // 2^64\n+    let __isize = 340282366920938463463374607431768211456; // 2^128\n     //~^ ERROR int literal is too large\n }"}, {"sha": "8c0b6741cb80428c63546fff07f0ac3a31f8dcea", "filename": "src/test/parse-fail/issue-5544-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fparse-fail%2Fissue-5544-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fparse-fail%2Fissue-5544-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-5544-b.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -11,6 +11,6 @@\n // compile-flags: -Z parse-only\n \n fn main() {\n-    let __isize = 0xff_ffff_ffff_ffff_ffff;\n+    let __isize = 0xffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ff;\n     //~^ ERROR int literal is too large\n }"}, {"sha": "d495a8edd09a4c2d393cc3de7505be9d52accf33", "filename": "src/test/parse-fail/lex-bad-numeric-literals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fparse-fail%2Flex-bad-numeric-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fparse-fail%2Flex-bad-numeric-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Flex-bad-numeric-literals.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -23,8 +23,8 @@ fn main() {\n     0o; //~ ERROR: no valid digits\n     1e+; //~ ERROR: expected at least one digit in exponent\n     0x539.0; //~ ERROR: hexadecimal float literal is not supported\n-    99999999999999999999999999999999; //~ ERROR: int literal is too large\n-    99999999999999999999999999999999; //~ ERROR: int literal is too large\n+    9900000000000000000000000000999999999999999999999999999999; //~ ERROR: int literal is too large\n+    9900000000000000000000000000999999999999999999999999999999; //~ ERROR: int literal is too large\n     0x; //~ ERROR: no valid digits\n     0xu32; //~ ERROR: no valid digits\n     0ou32; //~ ERROR: no valid digits"}, {"sha": "b7aeb21229ccb6f33528473140368d0c8b4afc8e", "filename": "src/test/run-pass/i128.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Frun-pass%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Frun-pass%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi128.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage0\n+// ignore-stage1\n+#![feature(i128_type, test)]\n+\n+extern crate test;\n+use test::black_box as b;\n+\n+fn main() {\n+    let x: i128 = -1;\n+    assert_eq!(0, !x);\n+    let y: i128 = -2;\n+    assert_eq!(!1, y);\n+    let z: i128 = 0xABCD_EF;\n+    assert_eq!(z * z, 0x734C_C2F2_A521);\n+    assert_eq!(z * z * z * z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(-z * -z, 0x734C_C2F2_A521);\n+    assert_eq!(-z * -z * -z * -z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(-z + -z + -z + -z, -0x2AF3_7BC);\n+    let k: i128 = -0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210;\n+    assert_eq!(k + k, -0x2468_ACF1_3579_BDFF_DB97_530E_CA86_420);\n+    assert_eq!(0, k - k);\n+    assert_eq!(-0x1234_5678_9ABC_DEFF_EDCB_A987_5A86_421, k + z);\n+    assert_eq!(-0x1000_0000_0000_0000_0000_0000_0000_000,\n+               k + 0x234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!(-0x6EF5_DE4C_D3BC_2AAA_3BB4_CC5D_D6EE_8, k / 42);\n+    assert_eq!(-k, k / -1);\n+    assert_eq!(-0x91A2_B3C4_D5E6_F8, k >> 65);\n+    assert_eq!(-0xFDB9_7530_ECA8_6420_0000_0000_0000_0000, k << 65);\n+    assert!(k < z);\n+    assert!(y > k);\n+    assert!(y < x);\n+    assert_eq!(x as i64, -1);\n+    assert_eq!(z as i64, 0xABCD_EF);\n+    assert_eq!(k as i64, -0xFEDC_BA98_7654_3210);\n+    assert_eq!(k as u128, 0xFEDC_BA98_7654_3210_0123_4567_89AB_CDF0);\n+    assert_eq!(-k as u128, 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!((-z as f64) as i128, -z);\n+    assert_eq!((-z as f32) as i128, -z);\n+    assert_eq!((-z as f64 * 16.0) as i128, -z * 16);\n+    assert_eq!((-z as f32 * 16.0) as i128, -z * 16);\n+    // Same stuff as above, but blackboxed, to force use of intrinsics\n+    let x: i128 = b(-1);\n+    assert_eq!(0, !x);\n+    let y: i128 = b(-2);\n+    assert_eq!(!1, y);\n+    let z: i128 = b(0xABCD_EF);\n+    assert_eq!(z * z, 0x734C_C2F2_A521);\n+    assert_eq!(z * z * z * z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(-z * -z, 0x734C_C2F2_A521);\n+    assert_eq!(-z * -z * -z * -z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(-z + -z + -z + -z, -0x2AF3_7BC);\n+    let k: i128 = b(-0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!(k + k, -0x2468_ACF1_3579_BDFF_DB97_530E_CA86_420);\n+    assert_eq!(0, k - k);\n+    assert_eq!(-0x1234_5678_9ABC_DEFF_EDCB_A987_5A86_421, k + z);\n+    assert_eq!(-0x1000_0000_0000_0000_0000_0000_0000_000,\n+               k + 0x234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!(-0x6EF5_DE4C_D3BC_2AAA_3BB4_CC5D_D6EE_8, k / 42);\n+    assert_eq!(-k, k / -1);\n+    assert_eq!(-0x91A2_B3C4_D5E6_F8, k >> 65);\n+    assert_eq!(-0xFDB9_7530_ECA8_6420_0000_0000_0000_0000, k << 65);\n+    assert!(k < z);\n+    assert!(y > k);\n+    assert!(y < x);\n+    assert_eq!(x as i64, -1);\n+    assert_eq!(z as i64, 0xABCD_EF);\n+    assert_eq!(k as i64, -0xFEDC_BA98_7654_3210);\n+    assert_eq!(k as u128, 0xFEDC_BA98_7654_3210_0123_4567_89AB_CDF0);\n+    assert_eq!(-k as u128, 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!((-z as f64) as i128, -z);\n+    assert_eq!((-z as f32) as i128, -z);\n+    assert_eq!((-z as f64 * 16.0) as i128, -z * 16);\n+    assert_eq!((-z as f32 * 16.0) as i128, -z * 16);\n+    // formatting\n+    let j: i128 = -(1 << 67);\n+    assert_eq!(\"-147573952589676412928\", format!(\"{}\", j));\n+    assert_eq!(\"fffffffffffffff80000000000000000\", format!(\"{:x}\", j));\n+    assert_eq!(\"3777777777777777777760000000000000000000000\", format!(\"{:o}\", j));\n+    assert_eq!(\"1111111111111111111111111111111111111111111111111111111111111\\\n+                0000000000000000000000000000000000000000000000000000000000000000000\",\n+               format!(\"{:b}\", j));\n+    assert_eq!(\"-147573952589676412928\", format!(\"{:?}\", j));\n+    // common traits\n+    assert_eq!(x, b(x.clone()));\n+    // overflow checks\n+    assert_eq!((-z).checked_mul(-z), Some(0x734C_C2F2_A521));\n+    assert_eq!((z).checked_mul(z), Some(0x734C_C2F2_A521));\n+    assert_eq!((k).checked_mul(k), None);\n+}"}, {"sha": "d138e09318bfe3ce1b1ae681041cc658f0732b24", "filename": "src/test/run-pass/u128.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Frun-pass%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Frun-pass%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu128.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage0\n+// ignore-stage1\n+#![feature(i128_type)]\n+\n+fn main() {\n+    let x: u128 = 0xFFFF_FFFF_FFFF_FFFF__FFFF_FFFF_FFFF_FFFF;\n+    assert_eq!(0, !x);\n+    assert_eq!(0, !x);\n+    let y: u128 = 0xFFFF_FFFF_FFFF_FFFF__FFFF_FFFF_FFFF_FFFE;\n+    assert_eq!(!1, y);\n+    assert_eq!(x, y | 1);\n+    assert_eq!(0xFAFF_0000_FF8F_0000__FFFF_0000_FFFF_FFFE,\n+               y &\n+               0xFAFF_0000_FF8F_0000__FFFF_0000_FFFF_FFFF);\n+    let z: u128 = 0xABCD_EF;\n+    assert_eq!(z * z, 0x734C_C2F2_A521);\n+    assert_eq!(z * z * z * z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(z + z + z + z, 0x2AF3_7BC);\n+    let k: u128 = 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210;\n+    assert_eq!(k + k, 0x2468_ACF1_3579_BDFF_DB97_530E_CA86_420);\n+    assert_eq!(0, k - k);\n+    assert_eq!(0x1234_5678_9ABC_DEFF_EDCB_A987_5A86_421, k - z);\n+    assert_eq!(0x1000_0000_0000_0000_0000_0000_0000_000,\n+               k - 0x234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!(0x6EF5_DE4C_D3BC_2AAA_3BB4_CC5D_D6EE_8, k / 42);\n+    assert_eq!(0, k % 42);\n+    assert_eq!(15, z % 42);\n+    assert_eq!(0x169D_A8020_CEC18, k % 0x3ACB_FE49_FF24_AC);\n+    assert_eq!(0x91A2_B3C4_D5E6_F7, k >> 65);\n+    assert_eq!(0xFDB9_7530_ECA8_6420_0000_0000_0000_0000, k << 65);\n+    assert!(k > z);\n+    assert!(y > k);\n+    assert!(y < x);\n+    assert_eq!(x as u64, !0);\n+    assert_eq!(z as u64, 0xABCD_EF);\n+    assert_eq!(k as u64, 0xFEDC_BA98_7654_3210);\n+    assert_eq!(k as i128, 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!((z as f64) as u128, z);\n+    assert_eq!((z as f32) as u128, z);\n+    assert_eq!((z as f64 * 16.0) as u128, z * 16);\n+    assert_eq!((z as f32 * 16.0) as u128, z * 16);\n+    let l :u128 = 432 << 100;\n+    assert_eq!((l as f32) as u128, l);\n+    assert_eq!((l as f64) as u128, l);\n+    // formatting\n+    let j: u128 = 1 << 67;\n+    assert_eq!(\"147573952589676412928\", format!(\"{}\", j));\n+    assert_eq!(\"80000000000000000\", format!(\"{:x}\", j));\n+    assert_eq!(\"20000000000000000000000\", format!(\"{:o}\", j));\n+    assert_eq!(\"10000000000000000000000000000000000000000000000000000000000000000000\",\n+               format!(\"{:b}\", j));\n+    assert_eq!(\"340282366920938463463374607431768211455\",\n+        format!(\"{}\", u128::max_value()));\n+    assert_eq!(\"147573952589676412928\", format!(\"{:?}\", j));\n+    // common traits\n+    x.clone();\n+}"}, {"sha": "f71ef126b64d9556914558d4ffb6c2b9316b0d6b", "filename": "src/test/ui/codemap_tests/unicode.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -1,4 +1,4 @@\n-error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, ptx-kernel, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n+error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, ptx-kernel, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic, unadjusted], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n   --> $DIR/unicode.rs:11:8\n    |\n 11 | extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}"}, {"sha": "3808c05c6b9398a95f86db47e493db3a26a29206", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bd207626fa46445d58404099b0a2f0bf8e0934/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=38bd207626fa46445d58404099b0a2f0bf8e0934", "patch": "@@ -26,6 +26,7 @@\n //! exceptions:\n //!\n //! - core may not have platform-specific code\n+//! - libcompiler_builtins may have platform-specific code\n //! - liballoc_system may have platform-specific code\n //! - liballoc_jemalloc may have platform-specific code\n //! - libpanic_abort may have platform-specific code\n@@ -53,6 +54,7 @@ const EXCEPTION_PATHS: &'static [&'static str] = &[\n     // std crates\n     \"src/liballoc_jemalloc\",\n     \"src/liballoc_system\",\n+    \"src/libcompiler_builtins\",\n     \"src/liblibc\",\n     \"src/libpanic_abort\",\n     \"src/libpanic_unwind\","}]}