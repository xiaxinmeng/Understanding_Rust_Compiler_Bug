{"sha": "542ed2bf72b232b245ece058fc11aebb1ca507d7", "node_id": "C_kwDOAAsO6NoAKDU0MmVkMmJmNzJiMjMyYjI0NWVjZTA1OGZjMTFhZWJiMWNhNTA3ZDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-11T21:34:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-11T21:34:23Z"}, "message": "Auto merge of #108417 - Zoxc:dep-graph-branch, r=cjgillot\n\nMove dep graph methods to DepGraphData to avoid branches and `unwrap`s\n\nThis moves methods from `DepGraph` to `DepGraphData` which makes the code a bit cleaner since the dep graph is unconditionally available. It also changes `try_execute_query` to only branch on dep graph availability once, removing unnecessary branches and `unwrap`s.\n\nThis is based on https://github.com/rust-lang/rust/pull/108134 and https://github.com/rust-lang/rust/pull/108167.\n\nPerformance impact of just the last commit:\n<table><tr><td rowspan=\"2\">Benchmark</td><td colspan=\"1\"><b>Before</b></th><td colspan=\"2\"><b>After</b></th></tr><tr><td align=\"right\">Time</td><td align=\"right\">Time</td><td align=\"right\">%</th></tr><tr><td>\ud83d\udfe3 <b>clap</b>:check</td><td align=\"right\">1.7354s</td><td align=\"right\">1.7242s</td><td align=\"right\"> -0.64%</td></tr><tr><td>\ud83d\udfe3 <b>clap</b>:check:initial</td><td align=\"right\">2.0813s</td><td align=\"right\">2.0687s</td><td align=\"right\"> -0.61%</td></tr><tr><td>\ud83d\udfe3 <b>clap</b>:check:unchanged</td><td align=\"right\">0.4554s</td><td align=\"right\">0.4550s</td><td align=\"right\"> -0.09%</td></tr><tr><td>\ud83d\udfe3 <b>hyper</b>:check</td><td align=\"right\">0.2528s</td><td align=\"right\">0.2521s</td><td align=\"right\"> -0.27%</td></tr><tr><td>\ud83d\udfe3 <b>hyper</b>:check:initial</td><td align=\"right\">0.3222s</td><td align=\"right\">0.3214s</td><td align=\"right\"> -0.25%</td></tr><tr><td>\ud83d\udfe3 <b>hyper</b>:check:unchanged</td><td align=\"right\">0.1339s</td><td align=\"right\">0.1333s</td><td align=\"right\"> -0.38%</td></tr><tr><td>\ud83d\udfe3 <b>regex</b>:check</td><td align=\"right\">0.9484s</td><td align=\"right\">0.9455s</td><td align=\"right\"> -0.30%</td></tr><tr><td>\ud83d\udfe3 <b>regex</b>:check:initial</td><td align=\"right\">1.1805s</td><td align=\"right\">1.1727s</td><td align=\"right\"> -0.66%</td></tr><tr><td>\ud83d\udfe3 <b>regex</b>:check:unchanged</td><td align=\"right\">0.3305s</td><td align=\"right\">0.3307s</td><td align=\"right\"> 0.08%</td></tr><tr><td>\ud83d\udfe3 <b>syn</b>:check</td><td align=\"right\">1.5453s</td><td align=\"right\">1.5374s</td><td align=\"right\"> -0.51%</td></tr><tr><td>\ud83d\udfe3 <b>syn</b>:check:initial</td><td align=\"right\">1.9230s</td><td align=\"right\">1.9206s</td><td align=\"right\"> -0.12%</td></tr><tr><td>\ud83d\udfe3 <b>syn</b>:check:unchanged</td><td align=\"right\">0.6340s</td><td align=\"right\">0.6333s</td><td align=\"right\"> -0.11%</td></tr><tr><td>\ud83d\udfe3 <b>syntex_syntax</b>:check</td><td align=\"right\">5.8623s</td><td align=\"right\">5.8536s</td><td align=\"right\"> -0.15%</td></tr><tr><td>\ud83d\udfe3 <b>syntex_syntax</b>:check:initial</td><td align=\"right\">7.2873s</td><td align=\"right\">7.2786s</td><td align=\"right\"> -0.12%</td></tr><tr><td>\ud83d\udfe3 <b>syntex_syntax</b>:check:unchanged</td><td align=\"right\">1.8378s</td><td align=\"right\">1.8478s</td><td align=\"right\"> 0.54%</td></tr><tr><td>Total</td><td align=\"right\">26.5300s</td><td align=\"right\">26.4750s</td><td align=\"right\"> -0.21%</td></tr><tr><td>Summary</td><td align=\"right\">1.0000s</td><td align=\"right\">0.9976s</td><td align=\"right\"> -0.24%</td></tr></table>\n\nr? `@cjgillot`", "tree": {"sha": "265c8a68987acbfb2e41ad03ba66fe8d9d084735", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/265c8a68987acbfb2e41ad03ba66fe8d9d084735"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/542ed2bf72b232b245ece058fc11aebb1ca507d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/542ed2bf72b232b245ece058fc11aebb1ca507d7", "html_url": "https://github.com/rust-lang/rust/commit/542ed2bf72b232b245ece058fc11aebb1ca507d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/542ed2bf72b232b245ece058fc11aebb1ca507d7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a73f50d875840b8077b8ec080fa41881d7ce40d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a73f50d875840b8077b8ec080fa41881d7ce40d", "html_url": "https://github.com/rust-lang/rust/commit/8a73f50d875840b8077b8ec080fa41881d7ce40d"}, {"sha": "42a0aaa9343bb8f75d1cfe3db65a07102bad9e4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/42a0aaa9343bb8f75d1cfe3db65a07102bad9e4f", "html_url": "https://github.com/rust-lang/rust/commit/42a0aaa9343bb8f75d1cfe3db65a07102bad9e4f"}], "stats": {"total": 394, "additions": 221, "deletions": 173}, "files": [{"sha": "8a9a12386064f41c6c3bf5858ed31d05dc8254e6", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 161, "deletions": 128, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/542ed2bf72b232b245ece058fc11aebb1ca507d7/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542ed2bf72b232b245ece058fc11aebb1ca507d7/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=542ed2bf72b232b245ece058fc11aebb1ca507d7", "patch": "@@ -70,7 +70,7 @@ impl DepNodeColor {\n     }\n }\n \n-struct DepGraphData<K: DepKind> {\n+pub struct DepGraphData<K: DepKind> {\n     /// The new encoding of the dependency graph, optimized for red/green\n     /// tracking. The `current` field is the dependency graph of only the\n     /// current compilation session: We don't merge the previous dep-graph into\n@@ -168,6 +168,11 @@ impl<K: DepKind> DepGraph<K> {\n         DepGraph { data: None, virtual_dep_node_index: Lrc::new(AtomicU32::new(0)) }\n     }\n \n+    #[inline]\n+    pub fn data(&self) -> Option<&DepGraphData<K>> {\n+        self.data.as_deref()\n+    }\n+\n     /// Returns `true` if we are actually building the full dep-graph, and `false` otherwise.\n     #[inline]\n     pub fn is_fully_enabled(&self) -> bool {\n@@ -252,6 +257,38 @@ impl<K: DepKind> DepGraph<K> {\n         K::with_deps(TaskDepsRef::Forbid, op)\n     }\n \n+    #[inline(always)]\n+    pub fn with_task<Ctxt: HasDepContext<DepKind = K>, A: Debug, R>(\n+        &self,\n+        key: DepNode<K>,\n+        cx: Ctxt,\n+        arg: A,\n+        task: fn(Ctxt, A) -> R,\n+        hash_result: Option<fn(&mut StableHashingContext<'_>, &R) -> Fingerprint>,\n+    ) -> (R, DepNodeIndex) {\n+        match self.data() {\n+            Some(data) => data.with_task(key, cx, arg, task, hash_result),\n+            None => (task(cx, arg), self.next_virtual_depnode_index()),\n+        }\n+    }\n+\n+    pub fn with_anon_task<Tcx: DepContext<DepKind = K>, OP, R>(\n+        &self,\n+        cx: Tcx,\n+        dep_kind: K,\n+        op: OP,\n+    ) -> (R, DepNodeIndex)\n+    where\n+        OP: FnOnce() -> R,\n+    {\n+        match self.data() {\n+            Some(data) => data.with_anon_task(cx, dep_kind, op),\n+            None => (op(), self.next_virtual_depnode_index()),\n+        }\n+    }\n+}\n+\n+impl<K: DepKind> DepGraphData<K> {\n     /// Starts a new dep-graph task. Dep-graph tasks are specified\n     /// using a free function (`task`) and **not** a closure -- this\n     /// is intentional because we want to exercise tight control over\n@@ -288,29 +325,6 @@ impl<K: DepKind> DepGraph<K> {\n         task: fn(Ctxt, A) -> R,\n         hash_result: Option<fn(&mut StableHashingContext<'_>, &R) -> Fingerprint>,\n     ) -> (R, DepNodeIndex) {\n-        if self.is_fully_enabled() {\n-            self.with_task_impl(key, cx, arg, task, hash_result)\n-        } else {\n-            // Incremental compilation is turned off. We just execute the task\n-            // without tracking. We still provide a dep-node index that uniquely\n-            // identifies the task so that we have a cheap way of referring to\n-            // the query for self-profiling.\n-            (task(cx, arg), self.next_virtual_depnode_index())\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn with_task_impl<Ctxt: HasDepContext<DepKind = K>, A: Debug, R>(\n-        &self,\n-        key: DepNode<K>,\n-        cx: Ctxt,\n-        arg: A,\n-        task: fn(Ctxt, A) -> R,\n-        hash_result: Option<fn(&mut StableHashingContext<'_>, &R) -> Fingerprint>,\n-    ) -> (R, DepNodeIndex) {\n-        // This function is only called when the graph is enabled.\n-        let data = self.data.as_ref().unwrap();\n-\n         // If the following assertion triggers, it can have two reasons:\n         // 1. Something is wrong with DepNode creation, either here or\n         //    in `DepGraph::try_mark_green()`.\n@@ -351,9 +365,9 @@ impl<K: DepKind> DepGraph<K> {\n         let print_status = cfg!(debug_assertions) && dcx.sess().opts.unstable_opts.dep_tasks;\n \n         // Intern the new `DepNode`.\n-        let (dep_node_index, prev_and_color) = data.current.intern_node(\n+        let (dep_node_index, prev_and_color) = self.current.intern_node(\n             dcx.profiler(),\n-            &data.previous,\n+            &self.previous,\n             key,\n             edges,\n             current_fingerprint,\n@@ -364,12 +378,12 @@ impl<K: DepKind> DepGraph<K> {\n \n         if let Some((prev_index, color)) = prev_and_color {\n             debug_assert!(\n-                data.colors.get(prev_index).is_none(),\n+                self.colors.get(prev_index).is_none(),\n                 \"DepGraph::with_task() - Duplicate DepNodeColor \\\n                             insertion for {key:?}\"\n             );\n \n-            data.colors.insert(prev_index, color);\n+            self.colors.insert(prev_index, color);\n         }\n \n         (result, dep_node_index)\n@@ -388,57 +402,55 @@ impl<K: DepKind> DepGraph<K> {\n     {\n         debug_assert!(!cx.is_eval_always(dep_kind));\n \n-        if let Some(ref data) = self.data {\n-            let task_deps = Lock::new(TaskDeps::default());\n-            let result = K::with_deps(TaskDepsRef::Allow(&task_deps), op);\n-            let task_deps = task_deps.into_inner();\n-            let task_deps = task_deps.reads;\n-\n-            let dep_node_index = match task_deps.len() {\n-                0 => {\n-                    // Because the dep-node id of anon nodes is computed from the sets of its\n-                    // dependencies we already know what the ID of this dependency-less node is\n-                    // going to be (i.e. equal to the precomputed\n-                    // `SINGLETON_DEPENDENCYLESS_ANON_NODE`). As a consequence we can skip creating\n-                    // a `StableHasher` and sending the node through interning.\n-                    DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE\n-                }\n-                1 => {\n-                    // When there is only one dependency, don't bother creating a node.\n-                    task_deps[0]\n-                }\n-                _ => {\n-                    // The dep node indices are hashed here instead of hashing the dep nodes of the\n-                    // dependencies. These indices may refer to different nodes per session, but this isn't\n-                    // a problem here because we that ensure the final dep node hash is per session only by\n-                    // combining it with the per session random number `anon_id_seed`. This hash only need\n-                    // to map the dependencies to a single value on a per session basis.\n-                    let mut hasher = StableHasher::new();\n-                    task_deps.hash(&mut hasher);\n-\n-                    let target_dep_node = DepNode {\n-                        kind: dep_kind,\n-                        // Fingerprint::combine() is faster than sending Fingerprint\n-                        // through the StableHasher (at least as long as StableHasher\n-                        // is so slow).\n-                        hash: data.current.anon_id_seed.combine(hasher.finish()).into(),\n-                    };\n+        let task_deps = Lock::new(TaskDeps::default());\n+        let result = K::with_deps(TaskDepsRef::Allow(&task_deps), op);\n+        let task_deps = task_deps.into_inner();\n+        let task_deps = task_deps.reads;\n+\n+        let dep_node_index = match task_deps.len() {\n+            0 => {\n+                // Because the dep-node id of anon nodes is computed from the sets of its\n+                // dependencies we already know what the ID of this dependency-less node is\n+                // going to be (i.e. equal to the precomputed\n+                // `SINGLETON_DEPENDENCYLESS_ANON_NODE`). As a consequence we can skip creating\n+                // a `StableHasher` and sending the node through interning.\n+                DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE\n+            }\n+            1 => {\n+                // When there is only one dependency, don't bother creating a node.\n+                task_deps[0]\n+            }\n+            _ => {\n+                // The dep node indices are hashed here instead of hashing the dep nodes of the\n+                // dependencies. These indices may refer to different nodes per session, but this isn't\n+                // a problem here because we that ensure the final dep node hash is per session only by\n+                // combining it with the per session random number `anon_id_seed`. This hash only need\n+                // to map the dependencies to a single value on a per session basis.\n+                let mut hasher = StableHasher::new();\n+                task_deps.hash(&mut hasher);\n+\n+                let target_dep_node = DepNode {\n+                    kind: dep_kind,\n+                    // Fingerprint::combine() is faster than sending Fingerprint\n+                    // through the StableHasher (at least as long as StableHasher\n+                    // is so slow).\n+                    hash: self.current.anon_id_seed.combine(hasher.finish()).into(),\n+                };\n \n-                    data.current.intern_new_node(\n-                        cx.profiler(),\n-                        target_dep_node,\n-                        task_deps,\n-                        Fingerprint::ZERO,\n-                    )\n-                }\n-            };\n+                self.current.intern_new_node(\n+                    cx.profiler(),\n+                    target_dep_node,\n+                    task_deps,\n+                    Fingerprint::ZERO,\n+                )\n+            }\n+        };\n \n-            (result, dep_node_index)\n-        } else {\n-            (op(), self.next_virtual_depnode_index())\n-        }\n+        (result, dep_node_index)\n     }\n+}\n \n+impl<K: DepKind> DepGraph<K> {\n     #[inline]\n     pub fn read_index(&self, dep_node_index: DepNodeIndex) {\n         if let Some(ref data) = self.data {\n@@ -519,9 +531,9 @@ impl<K: DepKind> DepGraph<K> {\n             // value to an existing node.\n             //\n             // For sanity, we still check that the loaded stable hash and the new one match.\n-            if let Some(dep_node_index) = self.dep_node_index_of_opt(&node) {\n+            if let Some(dep_node_index) = data.dep_node_index_of_opt(&node) {\n                 let _current_fingerprint =\n-                    crate::query::incremental_verify_ich(cx, result, &node, hash_result);\n+                    crate::query::incremental_verify_ich(cx, data, result, &node, hash_result);\n \n                 #[cfg(debug_assertions)]\n                 if hash_result.is_some() {\n@@ -577,32 +589,57 @@ impl<K: DepKind> DepGraph<K> {\n             self.next_virtual_depnode_index()\n         }\n     }\n+}\n \n+impl<K: DepKind> DepGraphData<K> {\n     #[inline]\n-    pub fn dep_node_index_of(&self, dep_node: &DepNode<K>) -> DepNodeIndex {\n-        self.dep_node_index_of_opt(dep_node).unwrap()\n+    pub fn dep_node_index_of_opt(&self, dep_node: &DepNode<K>) -> Option<DepNodeIndex> {\n+        if let Some(prev_index) = self.previous.node_to_index_opt(dep_node) {\n+            self.current.prev_index_to_index.lock()[prev_index]\n+        } else {\n+            self.current\n+                .new_node_to_index\n+                .get_shard_by_value(dep_node)\n+                .lock()\n+                .get(dep_node)\n+                .copied()\n+        }\n     }\n \n     #[inline]\n-    pub fn dep_node_index_of_opt(&self, dep_node: &DepNode<K>) -> Option<DepNodeIndex> {\n-        let data = self.data.as_ref().unwrap();\n-        let current = &data.current;\n+    pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n+        self.dep_node_index_of_opt(dep_node).is_some()\n+    }\n \n-        if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n-            current.prev_index_to_index.lock()[prev_index]\n+    fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n+        if let Some(prev_index) = self.previous.node_to_index_opt(dep_node) {\n+            self.colors.get(prev_index)\n         } else {\n-            current.new_node_to_index.get_shard_by_value(dep_node).lock().get(dep_node).copied()\n+            // This is a node that did not exist in the previous compilation session.\n+            None\n         }\n     }\n \n-    #[inline]\n-    pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n-        self.data.is_some() && self.dep_node_index_of_opt(dep_node).is_some()\n+    /// Returns true if the given node has been marked as green during the\n+    /// current compilation session. Used in various assertions\n+    pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n+        self.node_color(dep_node).map_or(false, |c| c.is_green())\n     }\n \n     #[inline]\n     pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n-        self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n+        self.previous.fingerprint_of(dep_node)\n+    }\n+\n+    pub fn mark_debug_loaded_from_disk(&self, dep_node: DepNode<K>) {\n+        self.debug_loaded_from_disk.lock().insert(dep_node);\n+    }\n+}\n+\n+impl<K: DepKind> DepGraph<K> {\n+    #[inline]\n+    pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n+        self.data.as_ref().and_then(|data| data.dep_node_index_of_opt(dep_node)).is_some()\n     }\n \n     /// Checks whether a previous work product exists for `v` and, if\n@@ -617,10 +654,6 @@ impl<K: DepKind> DepGraph<K> {\n         &self.data.as_ref().unwrap().previous_work_products\n     }\n \n-    pub fn mark_debug_loaded_from_disk(&self, dep_node: DepNode<K>) {\n-        self.data.as_ref().unwrap().debug_loaded_from_disk.lock().insert(dep_node);\n-    }\n-\n     pub fn debug_was_loaded_from_disk(&self, dep_node: DepNode<K>) -> bool {\n         self.data.as_ref().unwrap().debug_loaded_from_disk.lock().contains(&dep_node)\n     }\n@@ -645,17 +678,22 @@ impl<K: DepKind> DepGraph<K> {\n \n     fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n         if let Some(ref data) = self.data {\n-            if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n-                return data.colors.get(prev_index);\n-            } else {\n-                // This is a node that did not exist in the previous compilation session.\n-                return None;\n-            }\n+            return data.node_color(dep_node);\n         }\n \n         None\n     }\n \n+    pub fn try_mark_green<Qcx: QueryContext<DepKind = K>>(\n+        &self,\n+        qcx: Qcx,\n+        dep_node: &DepNode<K>,\n+    ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n+        self.data().and_then(|data| data.try_mark_green(qcx, dep_node))\n+    }\n+}\n+\n+impl<K: DepKind> DepGraphData<K> {\n     /// Try to mark a node index for the node dep_node.\n     ///\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n@@ -668,43 +706,39 @@ impl<K: DepKind> DepGraph<K> {\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         debug_assert!(!qcx.dep_context().is_eval_always(dep_node.kind));\n \n-        // Return None if the dep graph is disabled\n-        let data = self.data.as_ref()?;\n-\n         // Return None if the dep node didn't exist in the previous session\n-        let prev_index = data.previous.node_to_index_opt(dep_node)?;\n+        let prev_index = self.previous.node_to_index_opt(dep_node)?;\n \n-        match data.colors.get(prev_index) {\n+        match self.colors.get(prev_index) {\n             Some(DepNodeColor::Green(dep_node_index)) => return Some((prev_index, dep_node_index)),\n             Some(DepNodeColor::Red) => return None,\n             None => {}\n         }\n \n-        let backtrace = backtrace_printer(qcx.dep_context().sess(), data, prev_index);\n+        let backtrace = backtrace_printer(qcx.dep_context().sess(), self, prev_index);\n \n         // This DepNode and the corresponding query invocation existed\n         // in the previous compilation session too, so we can try to\n         // mark it as green by recursively marking all of its\n         // dependencies green.\n         let ret = self\n-            .try_mark_previous_green(qcx, data, prev_index, &dep_node)\n+            .try_mark_previous_green(qcx, prev_index, &dep_node)\n             .map(|dep_node_index| (prev_index, dep_node_index));\n \n         // We succeeded, no backtrace.\n         backtrace.disable();\n         return ret;\n     }\n \n-    #[instrument(skip(self, qcx, data, parent_dep_node_index), level = \"debug\")]\n+    #[instrument(skip(self, qcx, parent_dep_node_index), level = \"debug\")]\n     fn try_mark_parent_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n         qcx: Qcx,\n-        data: &DepGraphData<K>,\n         parent_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n     ) -> Option<()> {\n-        let dep_dep_node_color = data.colors.get(parent_dep_node_index);\n-        let dep_dep_node = &data.previous.index_to_node(parent_dep_node_index);\n+        let dep_dep_node_color = self.colors.get(parent_dep_node_index);\n+        let dep_dep_node = &self.previous.index_to_node(parent_dep_node_index);\n \n         match dep_dep_node_color {\n             Some(DepNodeColor::Green(_)) => {\n@@ -733,8 +767,7 @@ impl<K: DepKind> DepGraph<K> {\n                 dep_dep_node, dep_dep_node.hash,\n             );\n \n-            let node_index =\n-                self.try_mark_previous_green(qcx, data, parent_dep_node_index, dep_dep_node);\n+            let node_index = self.try_mark_previous_green(qcx, parent_dep_node_index, dep_dep_node);\n \n             if node_index.is_some() {\n                 debug!(\"managed to MARK dependency {dep_dep_node:?} as green\",);\n@@ -750,7 +783,7 @@ impl<K: DepKind> DepGraph<K> {\n             return None;\n         }\n \n-        let dep_dep_node_color = data.colors.get(parent_dep_node_index);\n+        let dep_dep_node_color = self.colors.get(parent_dep_node_index);\n \n         match dep_dep_node_color {\n             Some(DepNodeColor::Green(_)) => {\n@@ -783,30 +816,29 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n-    #[instrument(skip(self, qcx, data, prev_dep_node_index), level = \"debug\")]\n+    #[instrument(skip(self, qcx, prev_dep_node_index), level = \"debug\")]\n     fn try_mark_previous_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n         qcx: Qcx,\n-        data: &DepGraphData<K>,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n     ) -> Option<DepNodeIndex> {\n         #[cfg(not(parallel_compiler))]\n         {\n             debug_assert!(!self.dep_node_exists(dep_node));\n-            debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n+            debug_assert!(self.colors.get(prev_dep_node_index).is_none());\n         }\n \n         // We never try to mark eval_always nodes as green\n         debug_assert!(!qcx.dep_context().is_eval_always(dep_node.kind));\n \n-        debug_assert_eq!(data.previous.index_to_node(prev_dep_node_index), *dep_node);\n+        debug_assert_eq!(self.previous.index_to_node(prev_dep_node_index), *dep_node);\n \n-        let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n+        let prev_deps = self.previous.edge_targets_from(prev_dep_node_index);\n \n         for &dep_dep_node_index in prev_deps {\n-            let backtrace = backtrace_printer(qcx.dep_context().sess(), data, dep_dep_node_index);\n-            let success = self.try_mark_parent_green(qcx, data, dep_dep_node_index, dep_node);\n+            let backtrace = backtrace_printer(qcx.dep_context().sess(), self, dep_dep_node_index);\n+            let success = self.try_mark_parent_green(qcx, dep_dep_node_index, dep_node);\n             backtrace.disable();\n             success?;\n         }\n@@ -819,9 +851,9 @@ impl<K: DepKind> DepGraph<K> {\n \n         // We allocating an entry for the node in the current dependency graph and\n         // adding all the appropriate edges imported from the previous graph\n-        let dep_node_index = data.current.promote_node_and_deps_to_current(\n+        let dep_node_index = self.current.promote_node_and_deps_to_current(\n             qcx.dep_context().profiler(),\n-            &data.previous,\n+            &self.previous,\n             prev_dep_node_index,\n         );\n \n@@ -833,20 +865,20 @@ impl<K: DepKind> DepGraph<K> {\n \n         #[cfg(not(parallel_compiler))]\n         debug_assert!(\n-            data.colors.get(prev_dep_node_index).is_none(),\n+            self.colors.get(prev_dep_node_index).is_none(),\n             \"DepGraph::try_mark_previous_green() - Duplicate DepNodeColor \\\n                       insertion for {dep_node:?}\"\n         );\n \n         if !side_effects.is_empty() {\n-            self.with_query_deserialization(|| {\n-                self.emit_side_effects(qcx, data, dep_node_index, side_effects)\n+            qcx.dep_context().dep_graph().with_query_deserialization(|| {\n+                self.emit_side_effects(qcx, dep_node_index, side_effects)\n             });\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map.\n         // Multiple threads can all write the same color here\n-        data.colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n+        self.colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n \n         debug!(\"successfully marked {dep_node:?} as green\");\n         Some(dep_node_index)\n@@ -859,11 +891,10 @@ impl<K: DepKind> DepGraph<K> {\n     fn emit_side_effects<Qcx: QueryContext<DepKind = K>>(\n         &self,\n         qcx: Qcx,\n-        data: &DepGraphData<K>,\n         dep_node_index: DepNodeIndex,\n         side_effects: QuerySideEffects,\n     ) {\n-        let mut processed = data.processed_side_effects.lock();\n+        let mut processed = self.processed_side_effects.lock();\n \n         if processed.insert(dep_node_index) {\n             // We were the first to insert the node in the set so this thread\n@@ -879,7 +910,9 @@ impl<K: DepKind> DepGraph<K> {\n             }\n         }\n     }\n+}\n \n+impl<K: DepKind> DepGraph<K> {\n     /// Returns true if the given node has been marked as red during the\n     /// current compilation session. Used in various assertions\n     pub fn is_red(&self, dep_node: &DepNode<K>) -> bool {"}, {"sha": "5a7b9ae2ab436cb6054219324993252c8f5f6997", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/542ed2bf72b232b245ece058fc11aebb1ca507d7/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542ed2bf72b232b245ece058fc11aebb1ca507d7/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=542ed2bf72b232b245ece058fc11aebb1ca507d7", "patch": "@@ -6,7 +6,8 @@ mod serialized;\n \n pub use dep_node::{DepKindStruct, DepNode, DepNodeParams, WorkProductId};\n pub use graph::{\n-    hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, TaskDepsRef, WorkProduct,\n+    hash_result, DepGraph, DepGraphData, DepNodeColor, DepNodeIndex, TaskDeps, TaskDepsRef,\n+    WorkProduct,\n };\n pub use query::DepGraphQuery;\n pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};"}, {"sha": "7b9e0c3a0a6777a72e19bea87308bd705a92cd3a", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 58, "deletions": 44, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/542ed2bf72b232b245ece058fc11aebb1ca507d7/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/542ed2bf72b232b245ece058fc11aebb1ca507d7/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=542ed2bf72b232b245ece058fc11aebb1ca507d7", "patch": "@@ -2,8 +2,8 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::HasDepContext;\n use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex, DepNodeParams};\n+use crate::dep_graph::{DepGraphData, HasDepContext};\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n@@ -411,32 +411,34 @@ where\n     Qcx: QueryContext,\n {\n     let dep_graph = qcx.dep_context().dep_graph();\n+    let dep_graph_data = match dep_graph.data() {\n+        // Fast path for when incr. comp. is off.\n+        None => {\n+            // Fingerprint the key, just to assert that it doesn't\n+            // have anything we don't consider hashable\n+            if cfg!(debug_assertions) {\n+                let _ = key.to_fingerprint(*qcx.dep_context());\n+            }\n \n-    // Fast path for when incr. comp. is off.\n-    if !dep_graph.is_fully_enabled() {\n-        // Fingerprint the key, just to assert that it doesn't\n-        // have anything we don't consider hashable\n-        if cfg!(debug_assertions) {\n-            let _ = key.to_fingerprint(*qcx.dep_context());\n-        }\n-\n-        let prof_timer = qcx.dep_context().profiler().query_provider();\n-        let result = qcx.start_query(job_id, query.depth_limit(), None, || query.compute(qcx, key));\n-        let dep_node_index = dep_graph.next_virtual_depnode_index();\n-        prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n+            let prof_timer = qcx.dep_context().profiler().query_provider();\n+            let result =\n+                qcx.start_query(job_id, query.depth_limit(), None, || query.compute(qcx, key));\n+            let dep_node_index = dep_graph.next_virtual_depnode_index();\n+            prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n+\n+            // Similarly, fingerprint the result to assert that\n+            // it doesn't have anything not considered hashable.\n+            if cfg!(debug_assertions) && let Some(hash_result) = query.hash_result()\n+            {\n+                qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n+                    hash_result(&mut hcx, &result);\n+                });\n+            }\n \n-        // Similarly, fingerprint the result to assert that\n-        // it doesn't have anything not considered hashable.\n-        if cfg!(debug_assertions)\n-            && let Some(hash_result) = query.hash_result()\n-        {\n-            qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n-                hash_result(&mut hcx, &result);\n-            });\n+            return (result, dep_node_index);\n         }\n-\n-        return (result, dep_node_index);\n-    }\n+        Some(data) => data,\n+    };\n \n     if !query.anon() && !query.eval_always() {\n         // `to_dep_node` is expensive for some `DepKind`s.\n@@ -446,7 +448,7 @@ where\n         // The diagnostics for this query will be promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n         if let Some(ret) = qcx.start_query(job_id, false, None, || {\n-            try_load_from_disk_and_cache_in_memory(query, qcx, &key, &dep_node)\n+            try_load_from_disk_and_cache_in_memory(query, dep_graph_data, qcx, &key, &dep_node)\n         }) {\n             return ret;\n         }\n@@ -458,7 +460,7 @@ where\n     let (result, dep_node_index) =\n         qcx.start_query(job_id, query.depth_limit(), Some(&diagnostics), || {\n             if query.anon() {\n-                return dep_graph.with_anon_task(*qcx.dep_context(), query.dep_kind(), || {\n+                return dep_graph_data.with_anon_task(*qcx.dep_context(), query.dep_kind(), || {\n                     query.compute(qcx, key)\n                 });\n             }\n@@ -467,7 +469,7 @@ where\n             let dep_node =\n                 dep_node_opt.unwrap_or_else(|| query.construct_dep_node(*qcx.dep_context(), &key));\n \n-            dep_graph.with_task(\n+            dep_graph_data.with_task(\n                 dep_node,\n                 (qcx, query),\n                 key,\n@@ -495,6 +497,7 @@ where\n #[inline(always)]\n fn try_load_from_disk_and_cache_in_memory<Q, Qcx>(\n     query: Q,\n+    dep_graph_data: &DepGraphData<Qcx::DepKind>,\n     qcx: Qcx,\n     key: &Q::Key,\n     dep_node: &DepNode<Qcx::DepKind>,\n@@ -506,10 +509,9 @@ where\n     // Note this function can be called concurrently from the same query\n     // We must ensure that this is handled correctly.\n \n-    let dep_graph = qcx.dep_context().dep_graph();\n-    let (prev_dep_node_index, dep_node_index) = dep_graph.try_mark_green(qcx, &dep_node)?;\n+    let (prev_dep_node_index, dep_node_index) = dep_graph_data.try_mark_green(qcx, &dep_node)?;\n \n-    debug_assert!(dep_graph.is_green(dep_node));\n+    debug_assert!(dep_graph_data.is_green(dep_node));\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n@@ -519,23 +521,22 @@ where\n         // The call to `with_query_deserialization` enforces that no new `DepNodes`\n         // are created during deserialization. See the docs of that method for more\n         // details.\n-        let result =\n-            dep_graph.with_query_deserialization(|| try_load_from_disk(qcx, prev_dep_node_index));\n+        let result = qcx\n+            .dep_context()\n+            .dep_graph()\n+            .with_query_deserialization(|| try_load_from_disk(qcx, prev_dep_node_index));\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n         if let Some(result) = result {\n             if std::intrinsics::unlikely(\n                 qcx.dep_context().sess().opts.unstable_opts.query_dep_graph,\n             ) {\n-                dep_graph.mark_debug_loaded_from_disk(*dep_node)\n+                dep_graph_data.mark_debug_loaded_from_disk(*dep_node)\n             }\n \n-            let prev_fingerprint = qcx\n-                .dep_context()\n-                .dep_graph()\n-                .prev_fingerprint_of(dep_node)\n-                .unwrap_or(Fingerprint::ZERO);\n+            let prev_fingerprint =\n+                dep_graph_data.prev_fingerprint_of(dep_node).unwrap_or(Fingerprint::ZERO);\n             // If `-Zincremental-verify-ich` is specified, re-hash results from\n             // the cache and make sure that they have the expected fingerprint.\n             //\n@@ -547,7 +548,13 @@ where\n             if std::intrinsics::unlikely(\n                 try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n             ) {\n-                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result());\n+                incremental_verify_ich(\n+                    *qcx.dep_context(),\n+                    dep_graph_data,\n+                    &result,\n+                    dep_node,\n+                    query.hash_result(),\n+                );\n             }\n \n             return Some((result, dep_node_index));\n@@ -566,7 +573,7 @@ where\n     let prof_timer = qcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| query.compute(qcx, *key));\n+    let result = qcx.dep_context().dep_graph().with_ignore(|| query.compute(qcx, *key));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -579,15 +586,22 @@ where\n     //\n     // See issue #82920 for an example of a miscompilation that would get turned into\n     // an ICE by this check\n-    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result());\n+    incremental_verify_ich(\n+        *qcx.dep_context(),\n+        dep_graph_data,\n+        &result,\n+        dep_node,\n+        query.hash_result(),\n+    );\n \n     Some((result, dep_node_index))\n }\n \n #[inline]\n-#[instrument(skip(tcx, result, hash_result), level = \"debug\")]\n+#[instrument(skip(tcx, dep_graph_data, result, hash_result), level = \"debug\")]\n pub(crate) fn incremental_verify_ich<Tcx, V: Debug>(\n     tcx: Tcx,\n+    dep_graph_data: &DepGraphData<Tcx::DepKind>,\n     result: &V,\n     dep_node: &DepNode<Tcx::DepKind>,\n     hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n@@ -596,15 +610,15 @@ where\n     Tcx: DepContext,\n {\n     assert!(\n-        tcx.dep_graph().is_green(dep_node),\n+        dep_graph_data.is_green(dep_node),\n         \"fingerprint for green query instance not loaded from cache: {dep_node:?}\",\n     );\n \n     let new_hash = hash_result.map_or(Fingerprint::ZERO, |f| {\n         tcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n     });\n \n-    let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n+    let old_hash = dep_graph_data.prev_fingerprint_of(dep_node);\n \n     if Some(new_hash) != old_hash {\n         incremental_verify_ich_failed("}]}