{"sha": "ba2741594ba2d4de2ad8cea69def6408ff5409af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMjc0MTU5NGJhMmQ0ZGUyYWQ4Y2VhNjlkZWY2NDA4ZmY1NDA5YWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-21T23:01:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-21T23:01:27Z"}, "message": "Auto merge of #46922 - kennytm:rollup, r=kennytm\n\nRollup of 14 pull requests\n\n- Successful merges: #46636, #46780, #46784, #46809, #46814, #46820, #46839, #46847, #46858, #46878, #46884, #46890, #46898, #46918\n- Failed merges:", "tree": {"sha": "2c17b5743bf95d61eef4f3c307bc2823520d768f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c17b5743bf95d61eef4f3c307bc2823520d768f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba2741594ba2d4de2ad8cea69def6408ff5409af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba2741594ba2d4de2ad8cea69def6408ff5409af", "html_url": "https://github.com/rust-lang/rust/commit/ba2741594ba2d4de2ad8cea69def6408ff5409af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba2741594ba2d4de2ad8cea69def6408ff5409af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "250b492052e94d76bd318a4b932159395da55981", "url": "https://api.github.com/repos/rust-lang/rust/commits/250b492052e94d76bd318a4b932159395da55981", "html_url": "https://github.com/rust-lang/rust/commit/250b492052e94d76bd318a4b932159395da55981"}, {"sha": "0787ad92614df48096dbb5cbd6f2cf7833c97293", "url": "https://api.github.com/repos/rust-lang/rust/commits/0787ad92614df48096dbb5cbd6f2cf7833c97293", "html_url": "https://github.com/rust-lang/rust/commit/0787ad92614df48096dbb5cbd6f2cf7833c97293"}], "stats": {"total": 782, "additions": 453, "deletions": 329}, "files": [{"sha": "919d8329941a4b01e6337697db1f8da9f48728bd", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -112,14 +112,17 @@ There are large number of options provided in this config file that will alter t\n configuration used in the build process. Some options to note:\n \n #### `[llvm]`:\n+- `assertions = true` = This enables LLVM assertions, which makes LLVM misuse cause an assertion failure instead of weird misbehavior. This also slows down the compiler's runtime by ~20%.\n - `ccache = true` - Use ccache when building llvm\n \n #### `[build]`:\n - `compiler-docs = true` - Build compiler documentation\n \n #### `[rust]`:\n-- `debuginfo = true` - Build a compiler with debuginfo\n-- `optimize = false` - Disable optimizations to speed up compilation of stage1 rust\n+- `debuginfo = true` - Build a compiler with debuginfo. Makes building rustc slower, but then you can use a debugger to debug `rustc`.\n+- `debuginfo-lines = true` - An alternative to `debuginfo = true` that doesn't let you use a debugger, but doesn't make building rustc slower and still gives you line numbers in backtraces.\n+- `debug-assertions = true` - Makes the log output of `debug!` work.\n+- `optimize = false` - Disable optimizations to speed up compilation of stage1 rust, but makes the stage1 compiler x100 slower.\n \n For more options, the `config.toml` file contains commented out defaults, with\n descriptions of what each option will do.\n@@ -273,6 +276,27 @@ build, you'll need to build rustdoc specially, since it's not normally built in\n stage 1. `python x.py build --stage 1 src/libstd src/tools/rustdoc` will build\n rustdoc and libstd, which will allow rustdoc to be run with that toolchain.)\n \n+### Out-of-tree builds\n+[out-of-tree-builds]: #out-of-tree-builds\n+\n+Rust's `x.py` script fully supports out-of-tree builds - it looks for\n+the Rust source code from the directory `x.py` was found in, but it\n+reads the `config.toml` configuration file from the directory it's\n+run in, and places all build artifacts within a subdirectory named `build`.\n+\n+This means that if you want to do an out-of-tree build, you can just do it:\n+```\n+$ cd my/build/dir\n+$ cp ~/my-config.toml config.toml # Or fill in config.toml otherwise\n+$ path/to/rust/x.py build\n+...\n+$ # This will use the Rust source code in `path/to/rust`, but build\n+$ # artifacts will now be in ./build\n+```\n+\n+It's absolutely fine to have multiple build directories with different\n+`config.toml` configurations using the same code.\n+\n ## Pull Requests\n [pull-requests]: #pull-requests\n \n@@ -446,14 +470,14 @@ failed to run: ~/rust/build/x86_64-unknown-linux-gnu/stage0/bin/cargo build --ma\n If you haven't used the `[patch]`\n section of `Cargo.toml` before, there is [some relevant documentation about it\n in the cargo docs](http://doc.crates.io/manifest.html#the-patch-section). In\n-addition to that, you should read the \n+addition to that, you should read the\n [Overriding dependencies](http://doc.crates.io/specifying-dependencies.html#overriding-dependencies)\n section of the documentation as well.\n \n Specifically, the following [section in Overriding dependencies](http://doc.crates.io/specifying-dependencies.html#testing-a-bugfix) reveals what the problem is:\n \n > Next up we need to ensure that our lock file is updated to use this new version of uuid so our project uses the locally checked out copy instead of one from crates.io. The way [patch] works is that it'll load the dependency at ../path/to/uuid and then whenever crates.io is queried for versions of uuid it'll also return the local version.\n-> \n+>\n > This means that the version number of the local checkout is significant and will affect whether the patch is used. Our manifest declared uuid = \"1.0\" which means we'll only resolve to >= 1.0.0, < 2.0.0, and Cargo's greedy resolution algorithm also means that we'll resolve to the maximum version within that range. Typically this doesn't matter as the version of the git repository will already be greater or match the maximum version published on crates.io, but it's important to keep this in mind!\n \n This says that when we updated the submodule, the version number in our"}, {"sha": "93d7e66b7b203b32e088581d1b02c747e93b2f6f", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -224,8 +224,10 @@ use Bound::{Excluded, Included, Unbounded};\n /// types inside a `Vec`, it will not allocate space for them. *Note that in this case\n /// the `Vec` may not report a [`capacity`] of 0*. `Vec` will allocate if and only\n /// if [`mem::size_of::<T>`]`() * capacity() > 0`. In general, `Vec`'s allocation\n-/// details are subtle enough that it is strongly recommended that you only\n-/// free memory allocated by a `Vec` by creating a new `Vec` and dropping it.\n+/// details are very subtle &mdash; if you intend to allocate memory using a `Vec`\n+/// and use it for something else (either to pass to unsafe code, or to build your\n+/// own memory-backed collection), be sure to deallocate this memory by using\n+/// `from_raw_parts` to recover the `Vec` and then dropping it.\n ///\n /// If a `Vec` *has* allocated memory, then the memory it points to is on the heap\n /// (as defined by the allocator Rust is configured to use by default), and its"}, {"sha": "000d06a57a622eb4db4a15d0f76db48571f4d8e4", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -1 +1 @@\n-Subproject commit 18feaccbfd0dfbd5ab5d0a2a6eac9c04be667266\n+Subproject commit 000d06a57a622eb4db4a15d0f76db48571f4d8e4"}, {"sha": "732a02e8c427dd6a0bdc36e3c31f334c052bd295", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -114,7 +114,7 @@ macro_rules! define_bignum {\n         /// copying it recklessly may result in the performance hit.\n         /// Thus this is intentionally not `Copy`.\n         ///\n-        /// All operations available to bignums panic in the case of over/underflows.\n+        /// All operations available to bignums panic in the case of overflows.\n         /// The caller is responsible to use large enough bignum types.\n         pub struct $name {\n             /// One plus the offset to the maximum \"digit\" in use."}, {"sha": "851c0a0dd6f7506d6a43b76e63b98d34d313a2ca", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 60, "deletions": 159, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -98,10 +98,7 @@ pub mod diy_float;\n \n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n-    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr,\n-     $add_with_overflow:path,\n-     $sub_with_overflow:path,\n-     $mul_with_overflow:path) => {\n+    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr) => {\n         /// Returns the smallest value that can be represented by this integer type.\n         ///\n         /// # Examples\n@@ -402,7 +399,7 @@ macro_rules! int_impl {\n         }\n \n         /// Checked integer subtraction. Computes `self - rhs`, returning\n-        /// `None` if underflow occurred.\n+        /// `None` if overflow occurred.\n         ///\n         /// # Examples\n         ///\n@@ -420,7 +417,7 @@ macro_rules! int_impl {\n         }\n \n         /// Checked integer multiplication. Computes `self * rhs`, returning\n-        /// `None` if underflow or overflow occurred.\n+        /// `None` if overflow occurred.\n         ///\n         /// # Examples\n         ///\n@@ -438,7 +435,7 @@ macro_rules! int_impl {\n         }\n \n         /// Checked integer division. Computes `self / rhs`, returning `None`\n-        /// if `rhs == 0` or the operation results in underflow or overflow.\n+        /// if `rhs == 0` or the operation results in overflow.\n         ///\n         /// # Examples\n         ///\n@@ -460,7 +457,7 @@ macro_rules! int_impl {\n         }\n \n         /// Checked integer remainder. Computes `self % rhs`, returning `None`\n-        /// if `rhs == 0` or the operation results in underflow or overflow.\n+        /// if `rhs == 0` or the operation results in overflow.\n         ///\n         /// # Examples\n         ///\n@@ -865,11 +862,11 @@ macro_rules! int_impl {\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n-            unsafe {\n-                let (a, b) = $add_with_overflow(self as $ActualT,\n-                                                rhs as $ActualT);\n-                (a as Self, b)\n-            }\n+            let (a, b) = unsafe {\n+                intrinsics::add_with_overflow(self as $ActualT,\n+                                              rhs as $ActualT)\n+            };\n+            (a as Self, b)\n         }\n \n         /// Calculates `self` - `rhs`\n@@ -891,11 +888,11 @@ macro_rules! int_impl {\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n-            unsafe {\n-                let (a, b) = $sub_with_overflow(self as $ActualT,\n-                                                rhs as $ActualT);\n-                (a as Self, b)\n-            }\n+            let (a, b) = unsafe {\n+                intrinsics::sub_with_overflow(self as $ActualT,\n+                                              rhs as $ActualT)\n+            };\n+            (a as Self, b)\n         }\n \n         /// Calculates the multiplication of `self` and `rhs`.\n@@ -915,11 +912,11 @@ macro_rules! int_impl {\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n-            unsafe {\n-                let (a, b) = $mul_with_overflow(self as $ActualT,\n-                                                rhs as $ActualT);\n-                (a as Self, b)\n-            }\n+            let (a, b) = unsafe {\n+                intrinsics::mul_with_overflow(self as $ActualT,\n+                                              rhs as $ActualT)\n+            };\n+            (a as Self, b)\n         }\n \n         /// Calculates the divisor when `self` is divided by `rhs`.\n@@ -1207,82 +1204,50 @@ macro_rules! int_impl {\n \n #[lang = \"i8\"]\n impl i8 {\n-    int_impl! { i8, i8, u8, 8,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    int_impl! { i8, i8, u8, 8 }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n-    int_impl! { i16, i16, u16, 16,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    int_impl! { i16, i16, u16, 16 }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n-    int_impl! { i32, i32, u32, 32,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    int_impl! { i32, i32, u32, 32 }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n-    int_impl! { i64, i64, u64, 64,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    int_impl! { i64, i64, u64, 64 }\n }\n \n #[lang = \"i128\"]\n impl i128 {\n-    int_impl! { i128, i128, u128, 128,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    int_impl! { i128, i128, u128, 128 }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i16, u16, 16,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    int_impl! { isize, i16, u16, 16 }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i32, u32, 32,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    int_impl! { isize, i32, u32, 32 }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize, i64, u64, 64,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    int_impl! { isize, i64, u64, 64 }\n }\n \n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n-    ($SelfT:ty, $ActualT:ty, $BITS:expr,\n-     $ctpop:path,\n-     $ctlz:path,\n-     $ctlz_nonzero:path,\n-     $cttz:path,\n-     $bswap:path,\n-     $add_with_overflow:path,\n-     $sub_with_overflow:path,\n-     $mul_with_overflow:path) => {\n+    ($SelfT:ty, $ActualT:ty, $BITS:expr) => {\n         /// Returns the smallest value that can be represented by this integer type.\n         ///\n         /// # Examples\n@@ -1346,7 +1311,7 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn count_ones(self) -> u32 {\n-            unsafe { $ctpop(self as $ActualT) as u32 }\n+            unsafe { intrinsics::ctpop(self as $ActualT) as u32 }\n         }\n \n         /// Returns the number of zeros in the binary representation of `self`.\n@@ -1381,7 +1346,7 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn leading_zeros(self) -> u32 {\n-            unsafe { $ctlz(self as $ActualT) as u32 }\n+            unsafe { intrinsics::ctlz(self as $ActualT) as u32 }\n         }\n \n         /// Returns the number of trailing zeros in the binary representation\n@@ -1480,7 +1445,7 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn swap_bytes(self) -> Self {\n-            unsafe { $bswap(self as $ActualT) as Self }\n+            unsafe { intrinsics::bswap(self as $ActualT) as Self }\n         }\n \n         /// Converts an integer from big endian to the target's endianness.\n@@ -1598,7 +1563,7 @@ macro_rules! uint_impl {\n         }\n \n         /// Checked integer subtraction. Computes `self - rhs`, returning\n-        /// `None` if underflow occurred.\n+        /// `None` if overflow occurred.\n         ///\n         /// # Examples\n         ///\n@@ -1616,7 +1581,7 @@ macro_rules! uint_impl {\n         }\n \n         /// Checked integer multiplication. Computes `self * rhs`, returning\n-        /// `None` if underflow or overflow occurred.\n+        /// `None` if overflow occurred.\n         ///\n         /// # Examples\n         ///\n@@ -1634,7 +1599,7 @@ macro_rules! uint_impl {\n         }\n \n         /// Checked integer division. Computes `self / rhs`, returning `None`\n-        /// if `rhs == 0` or the operation results in underflow or overflow.\n+        /// if `rhs == 0` or the operation results in overflow.\n         ///\n         /// # Examples\n         ///\n@@ -1654,7 +1619,7 @@ macro_rules! uint_impl {\n         }\n \n         /// Checked integer remainder. Computes `self % rhs`, returning `None`\n-        /// if `rhs == 0` or the operation results in underflow or overflow.\n+        /// if `rhs == 0` or the operation results in overflow.\n         ///\n         /// # Examples\n         ///\n@@ -1984,11 +1949,11 @@ macro_rules! uint_impl {\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n-            unsafe {\n-                let (a, b) = $add_with_overflow(self as $ActualT,\n-                                                rhs as $ActualT);\n-                (a as Self, b)\n-            }\n+            let (a, b) = unsafe {\n+                intrinsics::add_with_overflow(self as $ActualT,\n+                                              rhs as $ActualT)\n+            };\n+            (a as Self, b)\n         }\n \n         /// Calculates `self` - `rhs`\n@@ -2010,11 +1975,11 @@ macro_rules! uint_impl {\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n-            unsafe {\n-                let (a, b) = $sub_with_overflow(self as $ActualT,\n-                                                rhs as $ActualT);\n-                (a as Self, b)\n-            }\n+            let (a, b) = unsafe {\n+                intrinsics::sub_with_overflow(self as $ActualT,\n+                                              rhs as $ActualT)\n+            };\n+            (a as Self, b)\n         }\n \n         /// Calculates the multiplication of `self` and `rhs`.\n@@ -2034,11 +1999,11 @@ macro_rules! uint_impl {\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n-            unsafe {\n-                let (a, b) = $mul_with_overflow(self as $ActualT,\n-                                                rhs as $ActualT);\n-                (a as Self, b)\n-            }\n+            let (a, b) = unsafe {\n+                intrinsics::mul_with_overflow(self as $ActualT,\n+                                              rhs as $ActualT)\n+            };\n+            (a as Self, b)\n         }\n \n         /// Calculates the divisor when `self` is divided by `rhs`.\n@@ -2223,7 +2188,7 @@ macro_rules! uint_impl {\n             // (such as intel pre-haswell) have more efficient ctlz\n             // intrinsics when the argument is non-zero.\n             let p = self - 1;\n-            let z = unsafe { $ctlz_nonzero(p) };\n+            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n             <$SelfT>::max_value() >> z\n         }\n \n@@ -2270,15 +2235,7 @@ macro_rules! uint_impl {\n \n #[lang = \"u8\"]\n impl u8 {\n-    uint_impl! { u8, u8, 8,\n-        intrinsics::ctpop,\n-        intrinsics::ctlz,\n-        intrinsics::ctlz_nonzero,\n-        intrinsics::cttz,\n-        intrinsics::bswap,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    uint_impl! { u8, u8, 8 }\n \n \n     /// Checks if the value is within the ASCII range.\n@@ -2824,95 +2781,39 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    uint_impl! { u16, u16, 16,\n-        intrinsics::ctpop,\n-        intrinsics::ctlz,\n-        intrinsics::ctlz_nonzero,\n-        intrinsics::cttz,\n-        intrinsics::bswap,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    uint_impl! { u16, u16, 16 }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n-    uint_impl! { u32, u32, 32,\n-        intrinsics::ctpop,\n-        intrinsics::ctlz,\n-        intrinsics::ctlz_nonzero,\n-        intrinsics::cttz,\n-        intrinsics::bswap,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    uint_impl! { u32, u32, 32 }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n-    uint_impl! { u64, u64, 64,\n-        intrinsics::ctpop,\n-        intrinsics::ctlz,\n-        intrinsics::ctlz_nonzero,\n-        intrinsics::cttz,\n-        intrinsics::bswap,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    uint_impl! { u64, u64, 64 }\n }\n \n #[lang = \"u128\"]\n impl u128 {\n-    uint_impl! { u128, u128, 128,\n-        intrinsics::ctpop,\n-        intrinsics::ctlz,\n-        intrinsics::ctlz_nonzero,\n-        intrinsics::cttz,\n-        intrinsics::bswap,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    uint_impl! { u128, u128, 128 }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u16, 16,\n-        intrinsics::ctpop,\n-        intrinsics::ctlz,\n-        intrinsics::ctlz_nonzero,\n-        intrinsics::cttz,\n-        intrinsics::bswap,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    uint_impl! { usize, u16, 16 }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u32, 32,\n-        intrinsics::ctpop,\n-        intrinsics::ctlz,\n-        intrinsics::ctlz_nonzero,\n-        intrinsics::cttz,\n-        intrinsics::bswap,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    uint_impl! { usize, u32, 32 }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u64, 64,\n-        intrinsics::ctpop,\n-        intrinsics::ctlz,\n-        intrinsics::ctlz_nonzero,\n-        intrinsics::cttz,\n-        intrinsics::bswap,\n-        intrinsics::add_with_overflow,\n-        intrinsics::sub_with_overflow,\n-        intrinsics::mul_with_overflow }\n+    uint_impl! { usize, u64, 64 }\n }\n \n /// A classification of floating point numbers."}, {"sha": "85bdeae442bf7991aaf36e3a1331fb16dd4a88af", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -581,8 +581,7 @@ impl<T: ?Sized> *const T {\n     /// * Both the starting and resulting pointer must be either in bounds or one\n     ///   byte past the end of an allocated object.\n     ///\n-    /// * The computed offset, **in bytes**, cannot overflow or underflow an\n-    ///   `isize`.\n+    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n     /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n     ///   space. That is, the infinite-precision sum, **in bytes** must fit in a usize.\n@@ -714,8 +713,7 @@ impl<T: ?Sized> *const T {\n     /// * Both the starting and resulting pointer must be either in bounds or one\n     ///   byte past the end of an allocated object.\n     ///\n-    /// * The computed offset, **in bytes**, cannot overflow or underflow an\n-    ///   `isize`.\n+    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n     /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n     ///   space. That is, the infinite-precision sum must fit in a `usize`.\n@@ -1219,8 +1217,7 @@ impl<T: ?Sized> *mut T {\n     /// * Both the starting and resulting pointer must be either in bounds or one\n     ///   byte past the end of an allocated object.\n     ///\n-    /// * The computed offset, **in bytes**, cannot overflow or underflow an\n-    ///   `isize`.\n+    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n     /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n     ///   space. That is, the infinite-precision sum, **in bytes** must fit in a usize.\n@@ -1419,8 +1416,7 @@ impl<T: ?Sized> *mut T {\n     /// * Both the starting and resulting pointer must be either in bounds or one\n     ///   byte past the end of an allocated object.\n     ///\n-    /// * The computed offset, **in bytes**, cannot overflow or underflow an\n-    ///   `isize`.\n+    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n     ///\n     /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n     ///   space. That is, the infinite-precision sum must fit in a `usize`."}, {"sha": "110493bbec1595519eb1c8bbae8a4449b80b9a5c", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 24, "deletions": 59, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -413,27 +413,14 @@ impl<'a> Id<'a> {\n     /// quotes, ...) will return an empty `Err` value.\n     pub fn new<Name: IntoCow<'a, str>>(name: Name) -> Result<Id<'a>, ()> {\n         let name = name.into_cow();\n-        {\n-            let mut chars = name.chars();\n-            match chars.next() {\n-                Some(c) if is_letter_or_underscore(c) => {}\n-                _ => return Err(()),\n-            }\n-            if !chars.all(is_constituent) {\n-                return Err(());\n-            }\n-        }\n-        return Ok(Id { name: name });\n-\n-        fn is_letter_or_underscore(c: char) -> bool {\n-            in_range('a', c, 'z') || in_range('A', c, 'Z') || c == '_'\n-        }\n-        fn is_constituent(c: char) -> bool {\n-            is_letter_or_underscore(c) || in_range('0', c, '9')\n+        match name.chars().next() {\n+            Some(c) if c.is_ascii_alphabetic() || c == '_' => {}\n+            _ => return Err(()),\n         }\n-        fn in_range(low: char, c: char, high: char) -> bool {\n-            low as usize <= c as usize && c as usize <= high as usize\n+        if !name.chars().all(|c| c.is_ascii_alphanumeric() || c == '_' ) {\n+            return Err(());\n         }\n+        return Ok(Id { name: name });\n     }\n \n     pub fn as_slice(&'a self) -> &'a str {\n@@ -484,8 +471,7 @@ pub trait Labeller<'a> {\n     /// Maps `e` to a label that will be used in the rendered output.\n     /// The label need not be unique, and may be the empty string; the\n     /// default is in fact the empty string.\n-    fn edge_label(&'a self, e: &Self::Edge) -> LabelText<'a> {\n-        let _ignored = e;\n+    fn edge_label(&'a self, _e: &Self::Edge) -> LabelText<'a> {\n         LabelStr(\"\".into_cow())\n     }\n \n@@ -655,79 +641,58 @@ pub fn render_opts<'a, N, E, G, W>(g: &'a G,\n           G: Labeller<'a, Node=N, Edge=E> + GraphWalk<'a, Node=N, Edge=E>,\n           W: Write\n {\n-    fn writeln<W: Write>(w: &mut W, arg: &[&str]) -> io::Result<()> {\n-        for &s in arg {\n-            w.write_all(s.as_bytes())?;\n-        }\n-        write!(w, \"\\n\")\n-    }\n-\n-    fn indent<W: Write>(w: &mut W) -> io::Result<()> {\n-        w.write_all(b\"    \")\n-    }\n-\n-    writeln(w, &[\"digraph \", g.graph_id().as_slice(), \" {\"])?;\n+    writeln!(w, \"digraph {} {{\", g.graph_id().as_slice())?;\n     for n in g.nodes().iter() {\n-        indent(w)?;\n+        write!(w, \"    \")?;\n         let id = g.node_id(n);\n \n         let escaped = &g.node_label(n).to_dot_string();\n-        let shape;\n \n-        let mut text = vec![id.as_slice()];\n+        let mut text = Vec::new();\n+        write!(text, \"{}\", id.as_slice()).unwrap();\n \n         if !options.contains(&RenderOption::NoNodeLabels) {\n-            text.push(\"[label=\");\n-            text.push(escaped);\n-            text.push(\"]\");\n+            write!(text, \"[label={}]\", escaped).unwrap();\n         }\n \n         let style = g.node_style(n);\n         if !options.contains(&RenderOption::NoNodeStyles) && style != Style::None {\n-            text.push(\"[style=\\\"\");\n-            text.push(style.as_slice());\n-            text.push(\"\\\"]\");\n+            write!(text, \"[style=\\\"{}\\\"]\", style.as_slice()).unwrap();\n         }\n \n         if let Some(s) = g.node_shape(n) {\n-            shape = s.to_dot_string();\n-            text.push(\"[shape=\");\n-            text.push(&shape);\n-            text.push(\"]\");\n+            write!(text, \"[shape={}]\", &s.to_dot_string()).unwrap();\n         }\n \n-        text.push(\";\");\n-        writeln(w, &text)?;\n+        writeln!(text, \";\").unwrap();\n+        w.write_all(&text[..])?;\n     }\n \n     for e in g.edges().iter() {\n         let escaped_label = &g.edge_label(e).to_dot_string();\n-        indent(w)?;\n+        write!(w, \"    \")?;\n         let source = g.source(e);\n         let target = g.target(e);\n         let source_id = g.node_id(&source);\n         let target_id = g.node_id(&target);\n \n-        let mut text = vec![source_id.as_slice(), \" -> \", target_id.as_slice()];\n+        let mut text = Vec::new();\n+        write!(text, \"{} -> {}\", source_id.as_slice(), target_id.as_slice()).unwrap();\n \n         if !options.contains(&RenderOption::NoEdgeLabels) {\n-            text.push(\"[label=\");\n-            text.push(escaped_label);\n-            text.push(\"]\");\n+            write!(text, \"[label={}]\", escaped_label).unwrap();\n         }\n \n         let style = g.edge_style(e);\n         if !options.contains(&RenderOption::NoEdgeStyles) && style != Style::None {\n-            text.push(\"[style=\\\"\");\n-            text.push(style.as_slice());\n-            text.push(\"\\\"]\");\n+            write!(text, \"[style=\\\"{}\\\"]\", style.as_slice()).unwrap();\n         }\n \n-        text.push(\";\");\n-        writeln(w, &text)?;\n+        writeln!(text, \";\").unwrap();\n+        w.write_all(&text[..])?;\n     }\n \n-    writeln(w, &[\"}\"])\n+    writeln!(w, \"}}\")\n }\n \n pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {"}, {"sha": "2945b1ab912450c488bbcf85f8578c3a34c28a42", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -341,7 +341,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n         std_hash::Hash::hash(&TAG_VALID_SPAN, hasher);\n         // We truncate the stable_id hash and line and col numbers. The chances\n         // of causing a collision this way should be minimal.\n-        std_hash::Hash::hash(&file_lo.name, hasher);\n+        std_hash::Hash::hash(&(file_lo.name_hash as u64), hasher);\n \n         let col = (col_lo.0 as u64) & 0xFF;\n         let line = ((line_lo as u64) & 0xFF_FF_FF) << 8;"}, {"sha": "57120d61e7c7b820e3f3978a1ee2f085356a96ee", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -387,7 +387,8 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for FileMap {\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let FileMap {\n-            ref name,\n+            name: _, // We hash the smaller name_hash instead of this\n+            name_hash,\n             name_was_remapped,\n             unmapped_path: _,\n             crate_of_origin,\n@@ -402,7 +403,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for FileMap {\n             ref non_narrow_chars,\n         } = *self;\n \n-        name.hash_stable(hcx, hasher);\n+        (name_hash as u64).hash_stable(hcx, hasher);\n         name_was_remapped.hash_stable(hcx, hasher);\n \n         DefId {"}, {"sha": "3bcde93fde502cd1704ceb77a0d586c497d5e934", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -558,24 +558,29 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n             ty::TyError => { }\n             _ => {\n-                let def_id = self.mc.tables.type_dependent_defs()[call.hir_id].def_id();\n-                let call_scope = region::Scope::Node(call.hir_id.local_id);\n-                match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n-                    FnMutOverloadedCall => {\n-                        let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n-                        self.borrow_expr(callee,\n-                                         call_scope_r,\n-                                         ty::MutBorrow,\n-                                         ClosureInvocation);\n-                    }\n-                    FnOverloadedCall => {\n-                        let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n-                        self.borrow_expr(callee,\n-                                         call_scope_r,\n-                                         ty::ImmBorrow,\n-                                         ClosureInvocation);\n+                if let Some(def) = self.mc.tables.type_dependent_defs().get(call.hir_id) {\n+                    let def_id = def.def_id();\n+                    let call_scope = region::Scope::Node(call.hir_id.local_id);\n+                    match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n+                        FnMutOverloadedCall => {\n+                            let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n+                            self.borrow_expr(callee,\n+                                            call_scope_r,\n+                                            ty::MutBorrow,\n+                                            ClosureInvocation);\n+                        }\n+                        FnOverloadedCall => {\n+                            let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n+                            self.borrow_expr(callee,\n+                                            call_scope_r,\n+                                            ty::ImmBorrow,\n+                                            ClosureInvocation);\n+                        }\n+                        FnOnceOverloadedCall => self.consume_expr(callee),\n                     }\n-                    FnOnceOverloadedCall => self.consume_expr(callee),\n+                } else {\n+                    self.tcx().sess.delay_span_bug(call.span,\n+                                                   \"no type-dependent def for overloaded call\");\n                 }\n             }\n         }"}, {"sha": "7e80139b791d1dfb5781e77a2915d9b8464a6d5c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -528,6 +528,25 @@ impl OutputFilenames {\n     pub fn filestem(&self) -> String {\n         format!(\"{}{}\", self.out_filestem, self.extra)\n     }\n+\n+    pub fn contains_path(&self, input_path: &PathBuf) -> bool {\n+        let input_path = input_path.canonicalize().ok();\n+        if input_path.is_none() {\n+            return false\n+        }\n+        match self.single_output_file {\n+            Some(ref output_path) => output_path.canonicalize().ok() == input_path,\n+            None => {\n+                for k in self.outputs.keys() {\n+                    let output_path = self.path(k.to_owned());\n+                    if output_path.canonicalize().ok() == input_path {\n+                        return true;\n+                    }\n+                }\n+                false\n+            }\n+        }\n+    }\n }\n \n pub fn host_triple() -> &'static str {\n@@ -596,6 +615,12 @@ impl Options {\n             ).map(|(src, dst)| (src.clone(), dst.clone())).collect()\n         )\n     }\n+\n+    /// True if there will be an output file generated\n+    pub fn will_create_output_file(&self) -> bool {\n+        !self.debugging_opts.parse_only && // The file is just being parsed\n+            !self.debugging_opts.ls // The file is just being queried\n+    }\n }\n \n // The type of entry function, so"}, {"sha": "978c6c742339c12d629c8ffe236a6f1a4d809170", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -1484,27 +1484,25 @@ impl<'a, 'tcx> LayoutDetails {\n                                     Some(niche) => niche,\n                                     None => continue\n                                 };\n+                            let mut align = dl.aggregate_align;\n                             let st = variants.iter().enumerate().map(|(j, v)| {\n                                 let mut st = univariant_uninterned(v,\n                                     &def.repr, StructKind::AlwaysSized)?;\n                                 st.variants = Variants::Single { index: j };\n+\n+                                align = align.max(st.align);\n+\n                                 Ok(st)\n                             }).collect::<Result<Vec<_>, _>>()?;\n \n                             let offset = st[i].fields.offset(field_index) + offset;\n-                            let LayoutDetails { mut size, mut align, .. } = st[i];\n+                            let size = st[i].size;\n \n-                            let mut niche_align = niche.value.align(dl);\n                             let abi = if offset.bytes() == 0 && niche.value.size(dl) == size {\n                                 Abi::Scalar(niche.clone())\n                             } else {\n-                                if offset.abi_align(niche_align) != offset {\n-                                    niche_align = dl.i8_align;\n-                                }\n                                 Abi::Aggregate { sized: true }\n                             };\n-                            align = align.max(niche_align);\n-                            size = size.abi_align(align);\n \n                             return Ok(tcx.intern_layout(LayoutDetails {\n                                 variants: Variants::NicheFilling {"}, {"sha": "a288ff6316f8316e77bd576ecbc350bf68b84d81", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -71,6 +71,7 @@ use profile;\n \n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n+                     input_path: &Option<PathBuf>,\n                      input: &Input,\n                      outdir: &Option<PathBuf>,\n                      output: &Option<PathBuf>,\n@@ -142,6 +143,20 @@ pub fn compile_input(sess: &Session,\n         };\n \n         let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n+\n+        // Ensure the source file isn't accidentally overwritten during compilation.\n+        match *input_path {\n+            Some(ref input_path) => {\n+                if outputs.contains_path(input_path) && sess.opts.will_create_output_file() {\n+                    sess.err(&format!(\n+                        \"the input file \\\"{}\\\" would be overwritten by the generated executable\",\n+                        input_path.display()));\n+                    return Err(CompileIncomplete::Stopped);\n+                }\n+            },\n+            None => {}\n+        }\n+\n         let crate_name =\n             ::rustc_trans_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n         let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {"}, {"sha": "60857505c7ac5277ed5aa97d29cb67fd14e2958c", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -232,7 +232,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n     let mut sess = session::build_session_with_codemap(\n-        sopts, input_file_path, descriptions, codemap, emitter_dest,\n+        sopts, input_file_path.clone(), descriptions, codemap, emitter_dest,\n     );\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n@@ -252,6 +252,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let control = callbacks.build_controller(&sess, &matches);\n     (driver::compile_input(&sess,\n                            &cstore,\n+                           &input_file_path,\n                            &input,\n                            &odir,\n                            &ofile,"}, {"sha": "501f6bb0c0d825e33cde6b6067c42584e9dd6624", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -349,7 +349,27 @@ impl MissingDoc {\n             }\n         }\n \n-        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.check_name(\"doc\"));\n+        fn has_doc(attr: &ast::Attribute) -> bool {\n+            if !attr.check_name(\"doc\") {\n+                return false;\n+            }\n+\n+            if attr.is_value_str() {\n+                return true;\n+            }\n+\n+            if let Some(list) = attr.meta_item_list() {\n+                for meta in list {\n+                    if meta.check_name(\"include\") {\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            false\n+        }\n+\n+        let has_doc = attrs.iter().any(|a| has_doc(a));\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS,\n                          cx.tcx.sess.codemap().def_span(sp),"}, {"sha": "0e9f4a8f1784b7a392a14d7356261fdc3b198133", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -1129,6 +1129,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                       lines,\n                                       multibyte_chars,\n                                       non_narrow_chars,\n+                                      name_hash,\n                                       .. } = filemap_to_import;\n \n             let source_length = (end_pos - start_pos).to_usize();\n@@ -1155,6 +1156,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                                                    name_was_remapped,\n                                                                    self.cnum.as_u32(),\n                                                                    src_hash,\n+                                                                   name_hash,\n                                                                    source_length,\n                                                                    lines,\n                                                                    multibyte_chars,"}, {"sha": "5ddbb18450e2ea22a3a6e12be2074abf130e5be3", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -28,8 +28,10 @@ use rustc::ty::codec::{self as ty_codec, TyEncoder};\n use rustc::session::config::{self, CrateTypeProcMacro};\n use rustc::util::nodemap::{FxHashMap, NodeSet};\n \n+use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n \n+use std::hash::Hash;\n use std::io::prelude::*;\n use std::io::Cursor;\n use std::path::Path;\n@@ -290,6 +292,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         } else {\n                             let mut adapted = (**filemap).clone();\n                             adapted.name = Path::new(&working_dir).join(name).into();\n+                            adapted.name_hash = {\n+                                let mut hasher: StableHasher<u128> = StableHasher::new();\n+                                adapted.name.hash(&mut hasher);\n+                                hasher.finish()\n+                            };\n                             Rc::new(adapted)\n                         }\n                     },"}, {"sha": "b1fef274cba4b9d323518174cf132c1f0eca113b", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -377,6 +377,17 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n     assert!(target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n+    // Note that at this point in time the `codegen_units` here may not be in a\n+    // deterministic order (but we know they're deterministically the same set).\n+    // We want this merging to produce a deterministic ordering of codegen units\n+    // from the input.\n+    //\n+    // Due to basically how we've implemented the merging below (merge the two\n+    // smallest into each other) we're sure to start off with a deterministic\n+    // order (sorted by name). This'll mean that if two cgus have the same size\n+    // the stable sort below will keep everything nice and deterministic.\n+    codegen_units.sort_by_key(|cgu| cgu.name().clone());\n+\n     // Merge the two smallest codegen units until the target size is reached.\n     // Note that \"size\" is estimated here rather inaccurately as the number of\n     // translation items in a given unit. This could be improved on."}, {"sha": "3be44f3095858f1e5d87454d232a3333dae14dc9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -3720,9 +3720,10 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                     })).and_then(|did| c.impls.get(&did));\n                     if let Some(impls) = inner_impl {\n                         out.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#deref-methods\\\">\");\n-                        out.push_str(&format!(\"Methods from {:#}&lt;Target={:#}&gt;\",\n-                                              impl_.inner_impl().trait_.as_ref().unwrap(),\n-                                              target));\n+                        out.push_str(&format!(\"Methods from {}&lt;Target={}&gt;\",\n+                                              Escape(&format!(\"{:#}\",\n+                                                     impl_.inner_impl().trait_.as_ref().unwrap())),\n+                                              Escape(&format!(\"{:#}\", target))));\n                         out.push_str(\"</a>\");\n                         let ret = impls.iter()\n                                        .filter(|i| i.inner_impl().trait_.is_none())"}, {"sha": "8e861f10dd8d4851c4fc2baf24fe37da897ec0b5", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -263,7 +263,7 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, cfgs: Vec<String>,\n     }\n \n     let res = panic::catch_unwind(AssertUnwindSafe(|| {\n-        driver::compile_input(&sess, &cstore, &input, &out, &None, None, &control)\n+        driver::compile_input(&sess, &cstore, &None, &input, &out, &None, None, &control)\n     }));\n \n     let compile_result = match res {\n@@ -533,7 +533,7 @@ impl Collector {\n                 should_panic: testing::ShouldPanic::No,\n                 allow_fail,\n             },\n-            testfn: testing::DynTestFn(box move |()| {\n+            testfn: testing::DynTestFn(box move || {\n                 let panic = io::set_panic(None);\n                 let print = io::set_print(None);\n                 match {"}, {"sha": "8308ab48d9ceb47ce3e6081b2c85da931d8245b6", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -263,7 +263,7 @@ impl<R: Seek> Seek for BufReader<R> {\n     /// See `std::io::Seek` for more details.\n     ///\n     /// Note: In the edge case where you're seeking with `SeekFrom::Current(n)`\n-    /// where `n` minus the internal buffer length underflows an `i64`, two\n+    /// where `n` minus the internal buffer length overflows an `i64`, two\n     /// seeks will be performed instead of one. If the second seek returns\n     /// `Err`, the underlying reader will be left at the same position it would\n     /// have if you seeked to `SeekFrom::Current(0)`."}, {"sha": "15ddb62bab5c8635c39e8932da0056fd6b9c9f23", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -290,7 +290,7 @@ impl Duration {\n     }\n \n     /// Checked `Duration` subtraction. Computes `self - other`, returning [`None`]\n-    /// if the result would be negative or if underflow occurred.\n+    /// if the result would be negative or if overflow occurred.\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///"}, {"sha": "e49a7117192d37d24dfe932a68d98a82d505e8a1", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -246,6 +246,7 @@ impl CodeMap {\n                                 name_was_remapped: bool,\n                                 crate_of_origin: u32,\n                                 src_hash: u128,\n+                                name_hash: u128,\n                                 source_len: usize,\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>,\n@@ -282,6 +283,7 @@ impl CodeMap {\n             lines: RefCell::new(file_local_lines),\n             multibyte_chars: RefCell::new(file_local_multibyte_chars),\n             non_narrow_chars: RefCell::new(file_local_non_narrow_chars),\n+            name_hash,\n         });\n \n         files.push(filemap.clone());"}, {"sha": "81baa0c3954ca202549502813249c4f23ee6da35", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -1115,15 +1115,19 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                     match File::open(&filename).and_then(|mut f| f.read_to_end(&mut buf)) {\n                         Ok(..) => {}\n                         Err(e) => {\n-                            self.cx.span_warn(at.span,\n-                                              &format!(\"couldn't read {}: {}\",\n-                                                       filename.display(),\n-                                                       e));\n+                            self.cx.span_err(at.span,\n+                                             &format!(\"couldn't read {}: {}\",\n+                                                      filename.display(),\n+                                                      e));\n                         }\n                     }\n \n                     match String::from_utf8(buf) {\n                         Ok(src) => {\n+                            // Add this input file to the code map to make it available as\n+                            // dependency information\n+                            self.cx.codemap().new_filemap_and_lines(&filename, &src);\n+\n                             let include_info = vec![\n                                 dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n                                         attr::mk_name_value_item_str(\"file\".into(),\n@@ -1137,9 +1141,9 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                                         attr::mk_list_item(\"include\".into(), include_info))));\n                         }\n                         Err(_) => {\n-                            self.cx.span_warn(at.span,\n-                                              &format!(\"{} wasn't a utf-8 file\",\n-                                                       filename.display()));\n+                            self.cx.span_err(at.span,\n+                                             &format!(\"{} wasn't a utf-8 file\",\n+                                                      filename.display()));\n                         }\n                     }\n                 } else {"}, {"sha": "85f0925b98210383459cc783e35cc131af6165aa", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -30,7 +30,7 @@ use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::cmp::{self, Ordering};\n use std::fmt;\n-use std::hash::Hasher;\n+use std::hash::{Hasher, Hash};\n use std::ops::{Add, Sub};\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -691,6 +691,8 @@ pub struct FileMap {\n     pub multibyte_chars: RefCell<Vec<MultiByteChar>>,\n     /// Width of characters that are not narrow in the source code\n     pub non_narrow_chars: RefCell<Vec<NonNarrowChar>>,\n+    /// A hash of the filename, used for speeding up the incr. comp. hashing.\n+    pub name_hash: u128,\n }\n \n impl Encodable for FileMap {\n@@ -752,6 +754,9 @@ impl Encodable for FileMap {\n             })?;\n             s.emit_struct_field(\"non_narrow_chars\", 8, |s| {\n                 (*self.non_narrow_chars.borrow()).encode(s)\n+            })?;\n+            s.emit_struct_field(\"name_hash\", 9, |s| {\n+                self.name_hash.encode(s)\n             })\n         })\n     }\n@@ -801,6 +806,8 @@ impl Decodable for FileMap {\n                 d.read_struct_field(\"multibyte_chars\", 7, |d| Decodable::decode(d))?;\n             let non_narrow_chars: Vec<NonNarrowChar> =\n                 d.read_struct_field(\"non_narrow_chars\", 8, |d| Decodable::decode(d))?;\n+            let name_hash: u128 =\n+                d.read_struct_field(\"name_hash\", 9, |d| Decodable::decode(d))?;\n             Ok(FileMap {\n                 name,\n                 name_was_remapped,\n@@ -816,7 +823,8 @@ impl Decodable for FileMap {\n                 external_src: RefCell::new(ExternalSource::AbsentOk),\n                 lines: RefCell::new(lines),\n                 multibyte_chars: RefCell::new(multibyte_chars),\n-                non_narrow_chars: RefCell::new(non_narrow_chars)\n+                non_narrow_chars: RefCell::new(non_narrow_chars),\n+                name_hash,\n             })\n         })\n     }\n@@ -836,9 +844,16 @@ impl FileMap {\n                start_pos: BytePos) -> FileMap {\n         remove_bom(&mut src);\n \n-        let mut hasher: StableHasher<u128> = StableHasher::new();\n-        hasher.write(src.as_bytes());\n-        let src_hash = hasher.finish();\n+        let src_hash = {\n+            let mut hasher: StableHasher<u128> = StableHasher::new();\n+            hasher.write(src.as_bytes());\n+            hasher.finish()\n+        };\n+        let name_hash = {\n+            let mut hasher: StableHasher<u128> = StableHasher::new();\n+            name.hash(&mut hasher);\n+            hasher.finish()\n+        };\n         let end_pos = start_pos.to_usize() + src.len();\n \n         FileMap {\n@@ -854,6 +869,7 @@ impl FileMap {\n             lines: RefCell::new(Vec::new()),\n             multibyte_chars: RefCell::new(Vec::new()),\n             non_narrow_chars: RefCell::new(Vec::new()),\n+            name_hash,\n         }\n     }\n "}, {"sha": "0d837c470a223dd7c3ae2ae20354a62ecd097407", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -35,6 +35,7 @@\n #![deny(warnings)]\n \n #![feature(asm)]\n+#![feature(fnbox)]\n #![cfg_attr(unix, feature(libc))]\n #![feature(set_stdio)]\n #![feature(panic_unwind)]\n@@ -56,6 +57,7 @@ use self::OutputLocation::*;\n \n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::any::Any;\n+use std::boxed::FnBox;\n use std::cmp;\n use std::collections::BTreeMap;\n use std::env;\n@@ -133,24 +135,14 @@ pub trait TDynBenchFn: Send {\n     fn run(&self, harness: &mut Bencher);\n }\n \n-pub trait FnBox<T>: Send + 'static {\n-    fn call_box(self: Box<Self>, t: T);\n-}\n-\n-impl<T, F: FnOnce(T) + Send + 'static> FnBox<T> for F {\n-    fn call_box(self: Box<F>, t: T) {\n-        (*self)(t)\n-    }\n-}\n-\n // A function that runs a test. If the function returns successfully,\n // the test succeeds; if the function panics then the test fails. We\n // may need to come up with a more clever definition of test in order\n // to support isolation of tests into threads.\n pub enum TestFn {\n     StaticTestFn(fn()),\n     StaticBenchFn(fn(&mut Bencher)),\n-    DynTestFn(Box<FnBox<()>>),\n+    DynTestFn(Box<FnBox() + Send>),\n     DynBenchFn(Box<TDynBenchFn + 'static>),\n }\n \n@@ -1337,14 +1329,14 @@ pub fn convert_benchmarks_to_tests(tests: Vec<TestDescAndFn>) -> Vec<TestDescAnd\n     tests.into_iter().map(|x| {\n         let testfn = match x.testfn {\n             DynBenchFn(bench) => {\n-                DynTestFn(Box::new(move |()| {\n+                DynTestFn(Box::new(move || {\n                     bench::run_once(|b| {\n                         __rust_begin_short_backtrace(|| bench.run(b))\n                     })\n                 }))\n             }\n             StaticBenchFn(benchfn) => {\n-                DynTestFn(Box::new(move |()| {\n+                DynTestFn(Box::new(move || {\n                     bench::run_once(|b| {\n                         __rust_begin_short_backtrace(|| benchfn(b))\n                     })\n@@ -1379,7 +1371,7 @@ pub fn run_test(opts: &TestOpts,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: Sender<MonitorMsg>,\n                       nocapture: bool,\n-                      testfn: Box<FnBox<()>>) {\n+                      testfn: Box<FnBox() + Send>) {\n         struct Sink(Arc<Mutex<Vec<u8>>>);\n         impl Write for Sink {\n             fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n@@ -1405,9 +1397,7 @@ pub fn run_test(opts: &TestOpts,\n                 None\n             };\n \n-            let result = catch_unwind(AssertUnwindSafe(|| {\n-                testfn.call_box(())\n-            }));\n+            let result = catch_unwind(AssertUnwindSafe(testfn));\n \n             if let Some((printio, panicio)) = oldio {\n                 io::set_print(printio);\n@@ -1449,14 +1439,14 @@ pub fn run_test(opts: &TestOpts,\n             return;\n         }\n         DynTestFn(f) => {\n-            let cb = move |()| {\n-                __rust_begin_short_backtrace(|| f.call_box(()))\n+            let cb = move || {\n+                __rust_begin_short_backtrace(f)\n             };\n             run_test_inner(desc, monitor_ch, opts.nocapture, Box::new(cb))\n         }\n         StaticTestFn(f) =>\n             run_test_inner(desc, monitor_ch, opts.nocapture,\n-                           Box::new(move |()| __rust_begin_short_backtrace(f))),\n+                           Box::new(move || __rust_begin_short_backtrace(f))),\n     }\n }\n \n@@ -1720,7 +1710,7 @@ mod tests {\n                 should_panic: ShouldPanic::No,\n                 allow_fail: false,\n             },\n-            testfn: DynTestFn(Box::new(move |()| f())),\n+            testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1738,7 +1728,7 @@ mod tests {\n                 should_panic: ShouldPanic::No,\n                 allow_fail: false,\n             },\n-            testfn: DynTestFn(Box::new(move |()| f())),\n+            testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1758,7 +1748,7 @@ mod tests {\n                 should_panic: ShouldPanic::Yes,\n                 allow_fail: false,\n             },\n-            testfn: DynTestFn(Box::new(move |()| f())),\n+            testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1778,7 +1768,7 @@ mod tests {\n                 should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n                 allow_fail: false,\n             },\n-            testfn: DynTestFn(Box::new(move |()| f())),\n+            testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1800,7 +1790,7 @@ mod tests {\n                 should_panic: ShouldPanic::YesWithMessage(expected),\n                 allow_fail: false,\n             },\n-            testfn: DynTestFn(Box::new(move |()| f())),\n+            testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1818,7 +1808,7 @@ mod tests {\n                 should_panic: ShouldPanic::Yes,\n                 allow_fail: false,\n             },\n-            testfn: DynTestFn(Box::new(move |()| f())),\n+            testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1852,7 +1842,7 @@ mod tests {\n                                  should_panic: ShouldPanic::No,\n                                  allow_fail: false,\n                              },\n-                             testfn: DynTestFn(Box::new(move |()| {})),\n+                             testfn: DynTestFn(Box::new(move || {})),\n                          },\n                          TestDescAndFn {\n                              desc: TestDesc {\n@@ -1861,7 +1851,7 @@ mod tests {\n                                  should_panic: ShouldPanic::No,\n                                  allow_fail: false,\n                              },\n-                             testfn: DynTestFn(Box::new(move |()| {})),\n+                             testfn: DynTestFn(Box::new(move || {})),\n                          }];\n         let filtered = filter_tests(&opts, tests);\n \n@@ -1885,7 +1875,7 @@ mod tests {\n                     should_panic: ShouldPanic::No,\n                     allow_fail: false,\n                 },\n-                testfn: DynTestFn(Box::new(move |()| {}))\n+                testfn: DynTestFn(Box::new(move || {}))\n             })\n             .collect()\n         }\n@@ -1967,7 +1957,7 @@ mod tests {\n                         should_panic: ShouldPanic::No,\n                         allow_fail: false,\n                     },\n-                    testfn: DynTestFn(Box::new(move |()| testfn())),\n+                    testfn: DynTestFn(Box::new(testfn)),\n                 };\n                 tests.push(test);\n             }"}, {"sha": "c255294e790b71338162654703597c279f4d15f9", "filename": "src/test/COMPILER_TESTS.md", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2FCOMPILER_TESTS.md", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2FCOMPILER_TESTS.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2FCOMPILER_TESTS.md?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -35,20 +35,24 @@ The error levels that you can have are:\n ## Summary of Header Commands\n \n Header commands specify something about the entire test file as a\n-whole, instead of just a few lines inside the test.\n+whole. They are normally put right after the copyright comment, e.g.:\n+\n+```Rust\n+// Copyright blah blah blah\n+// except according to those terms.\n+\n+// ignore-test This doesn't actually work\n+```\n+\n+### Ignoring tests\n+\n+These are used to ignore the test in some situations, which means the test won't\n+be compiled or run.\n \n * `ignore-X` where `X` is a target detail or stage will ignore the test accordingly (see below)\n * `ignore-pretty` will not compile the pretty-printed test (this is done to test the pretty-printer, but might not always work)\n * `ignore-test` always ignores the test\n-* `ignore-lldb` and `ignore-gdb` will skip the debuginfo tests\n-* `min-{gdb,lldb}-version`\n-* `should-fail` indicates that the test should fail; used for \"meta testing\",\n-  where we test the compiletest program itself to check that it will generate\n-  errors in appropriate scenarios. This header is ignored for pretty-printer tests.\n-* `gate-test-X` where `X` is a feature marks the test as \"gate test\" for feature X.\n-  Such tests are supposed to ensure that the compiler errors when usage of a gated\n-  feature is attempted without the proper `#![feature(X)]` tag.\n-  Each unstable lang feature is required to have a gate test.\n+* `ignore-lldb` and `ignore-gdb` will skip a debuginfo test on that debugger.\n \n Some examples of `X` in `ignore-X`:\n \n@@ -58,6 +62,22 @@ Some examples of `X` in `ignore-X`:\n * Pointer width: `32bit`, `64bit`.\n * Stage: `stage0`, `stage1`, `stage2`.\n \n+### Other Header Commands\n+\n+* `min-{gdb,lldb}-version`\n+* `min-llvm-version`\n+* `must-compile-successfully` for UI tests, indicates that the test is supposed\n+  to compile, as opposed to the default where the test is supposed to error out.\n+* `compile-flags` passes extra command-line args to the compiler,\n+  e.g. `compile-flags -g` which forces debuginfo to be enabled.\n+* `should-fail` indicates that the test should fail; used for \"meta testing\",\n+  where we test the compiletest program itself to check that it will generate\n+  errors in appropriate scenarios. This header is ignored for pretty-printer tests.\n+* `gate-test-X` where `X` is a feature marks the test as \"gate test\" for feature X.\n+  Such tests are supposed to ensure that the compiler errors when usage of a gated\n+  feature is attempted without the proper `#![feature(X)]` tag.\n+  Each unstable lang feature is required to have a gate test.\n+\n ## Revisions\n \n Certain classes of tests support \"revisions\" (as of the time of this\n@@ -109,6 +129,12 @@ fails, we will print out the current output, but it is also saved in\n printed as part of the test failure message), so you can run `diff` and\n so forth.\n \n+Normally, the test-runner checks that UI tests fail compilation. If you want\n+to do a UI test for code that *compiles* (e.g. to test warnings, or if you\n+have a collection of tests, only some of which error out), you can use the\n+`// must-compile-successfully` header command to have the test runner instead\n+check that the test compiles successfully.\n+\n ### Editing and updating the reference files\n \n If you have changed the compiler's output intentionally, or you are"}, {"sha": "1ae0d0bd2760a62953651a6690f9bf991692ddaf", "filename": "src/test/compile-fail/external-doc-error.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Fcompile-fail%2Fexternal-doc-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Fcompile-fail%2Fexternal-doc-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexternal-doc-error.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(external_doc)]\n+\n+#[doc(include = \"not-a-file.md\")] //~ ERROR: couldn't read\n+pub struct SomeStruct;\n+\n+fn main() {}"}, {"sha": "f8bcd8861f3a6c0da29c89bc5b175889f7cf5cfa", "filename": "src/test/compile-fail/issue-46771.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Fcompile-fail%2Fissue-46771.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Fcompile-fail%2Fissue-46771.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-46771.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    struct Foo;\n+    (1 .. 2).find(|_| Foo(0) == 0); //~ ERROR expected function, found `main::Foo`\n+}"}, {"sha": "1293695b7997776e270e51f0f9e4405f8a57a3ab", "filename": "src/test/run-make/include_bytes_deps/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Finclude_bytes_deps%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Finclude_bytes_deps%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Finclude_bytes_deps%2FMakefile?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -8,7 +8,7 @@ ifneq ($(shell uname),FreeBSD)\n ifndef IS_WINDOWS\n all:\n \t$(RUSTC) --emit dep-info main.rs\n-\t$(CGREP) \"input.txt\" \"input.bin\" < $(TMPDIR)/main.d\n+\t$(CGREP) \"input.txt\" \"input.bin\" \"input.md\" < $(TMPDIR)/main.d\n else\n all:\n "}, {"sha": "2a19b7405f795f88e9346104f4a843251e6eef2d", "filename": "src/test/run-make/include_bytes_deps/input.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Finclude_bytes_deps%2Finput.md", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Finclude_bytes_deps%2Finput.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Finclude_bytes_deps%2Finput.md?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -0,0 +1 @@\n+# Hello, world!"}, {"sha": "27ca1a46a500d6613891f0a991917c9dd53e0ae9", "filename": "src/test/run-make/include_bytes_deps/main.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Finclude_bytes_deps%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Finclude_bytes_deps%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Finclude_bytes_deps%2Fmain.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(external_doc)]\n+\n+#[doc(include=\"input.md\")]\n+pub struct SomeStruct;\n+\n pub fn main() {\n     const INPUT_TXT: &'static str = include_str!(\"input.txt\");\n     const INPUT_BIN: &'static [u8] = include_bytes!(\"input.bin\");"}, {"sha": "f0ab1d5dc0fec7eabec80afd1a2bb6c1c907e803", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -71,5 +71,5 @@ fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     let (sess, cstore) = basic_sess(sysroot);\n     let control = CompileController::basic();\n     let input = Input::Str { name: FileName::Anon, input: code };\n-    let _ = compile_input(&sess, &cstore, &input, &None, &Some(output), None, &control);\n+    let _ = compile_input(&sess, &cstore, &None, &input, &None, &Some(output), None, &control);\n }"}, {"sha": "0554627d67753cd7a79b57140cf66cf41550f1d2", "filename": "src/test/run-make/output-filename-overwrites-input/Makefile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Foutput-filename-overwrites-input%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Foutput-filename-overwrites-input%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Foutput-filename-overwrites-input%2FMakefile?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -0,0 +1,10 @@\n+-include ../tools.mk\n+\n+all:\n+\tcp foo.rs $(TMPDIR)/foo\n+\t$(RUSTC) $(TMPDIR)/foo 2>&1 \\\n+\t\t| $(CGREP) -e \"the input file \\\".*foo\\\" would be overwritten by the generated executable\"\n+\t$(RUSTC) foo.rs 2>&1 && $(RUSTC) -Z ls $(TMPDIR)/foo 2>&1\n+\tcp foo.rs $(TMPDIR)/foo.rs\n+\t$(RUSTC) $(TMPDIR)/foo.rs -o $(TMPDIR)/foo.rs 2>&1 \\\n+\t\t| $(CGREP) -e \"the input file \\\".*foo.rs\\\" would be overwritten by the generated executable\""}, {"sha": "046d27a9f0fe55586ed5f82a1533900e04e6b1ec", "filename": "src/test/run-make/output-filename-overwrites-input/foo.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Foutput-filename-overwrites-input%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Foutput-filename-overwrites-input%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Foutput-filename-overwrites-input%2Ffoo.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {}"}, {"sha": "f161fe9f8e8df2f8d4ed7ac6ae31c35149492d29", "filename": "src/test/run-make/weird-output-filenames/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Fweird-output-filenames%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-make%2Fweird-output-filenames%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fweird-output-filenames%2FMakefile?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -7,8 +7,8 @@ all:\n \tcp foo.rs $(TMPDIR)/.foo.bar\n \t$(RUSTC) $(TMPDIR)/.foo.bar 2>&1 \\\n \t\t| $(CGREP) -e \"invalid character.*in crate name:\"\n-\tcp foo.rs $(TMPDIR)/+foo+bar\n-\t$(RUSTC) $(TMPDIR)/+foo+bar 2>&1 \\\n+\tcp foo.rs $(TMPDIR)/+foo+bar.rs\n+\t$(RUSTC) $(TMPDIR)/+foo+bar.rs 2>&1 \\\n \t\t| $(CGREP) -e \"invalid character.*in crate name:\"\n \tcp foo.rs $(TMPDIR)/-foo.rs\n \t$(RUSTC) $(TMPDIR)/-foo.rs 2>&1 \\"}, {"sha": "7968ae2278ae93a06eba631c4885e39408d52972", "filename": "src/test/run-pass/packed-struct-optimized-enum.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-pass%2Fpacked-struct-optimized-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frun-pass%2Fpacked-struct-optimized-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-optimized-enum.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -19,7 +19,9 @@ impl<T: Copy> Clone for Packed<T> {\n fn sanity_check_size<T: Copy>(one: T) {\n     let two = [one, one];\n     let stride = (&two[1] as *const _ as usize) - (&two[0] as *const _ as usize);\n-    assert_eq!(stride, std::mem::size_of_val(&one));\n+    let (size, align) = (std::mem::size_of::<T>(), std::mem::align_of::<T>());\n+    assert_eq!(stride, size);\n+    assert_eq!(size % align, 0);\n }\n \n fn main() {\n@@ -32,5 +34,12 @@ fn main() {\n     // In #46769, `Option<(Packed<&()>, bool)>` was found to have\n     // pointer alignment, without actually being aligned in size.\n     // E.g. on 64-bit platforms, it had alignment `8` but size `9`.\n-    sanity_check_size(Some((Packed(&()), true)));\n+    type PackedRefAndBool<'a> = (Packed<&'a ()>, bool);\n+    sanity_check_size::<Option<PackedRefAndBool>>(Some((Packed(&()), true)));\n+\n+    // Make sure we don't pay for the enum optimization in size,\n+    // e.g. we shouldn't need extra padding after the packed data.\n+    assert_eq!(std::mem::align_of::<Option<PackedRefAndBool>>(), 1);\n+    assert_eq!(std::mem::size_of::<Option<PackedRefAndBool>>(),\n+               std::mem::size_of::<PackedRefAndBool>());\n }"}, {"sha": "767fb05313adc15973de66aae30bf9d3298508a4", "filename": "src/test/rustdoc/auxiliary/external-cross.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frustdoc%2Fauxiliary%2Fexternal-cross.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frustdoc%2Fauxiliary%2Fexternal-cross.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fexternal-cross.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(external_doc)]\n+#![deny(missing_doc)]\n \n #[doc(include=\"external-cross-doc.md\")]\n pub struct NeedMoreDocs;"}, {"sha": "f31b0ddca9adaa084a8dce45f67435454dce352b", "filename": "src/test/rustdoc/escape-deref-methods.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frustdoc%2Fescape-deref-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftest%2Frustdoc%2Fescape-deref-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fescape-deref-methods.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+use std::ops::{Deref, DerefMut};\n+\n+#[derive(Debug, Clone)]\n+pub struct Title {\n+    name: String,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct TitleList {\n+    pub members: Vec<Title>,\n+}\n+\n+impl TitleList {\n+    pub fn new() -> Self {\n+        TitleList { members: Vec::new() }\n+    }\n+}\n+\n+impl Deref for TitleList {\n+    type Target = Vec<Title>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.members\n+    }\n+}\n+\n+// @has foo/struct.TitleList.html\n+// @has - '//*[@class=\"sidebar-title\"]' 'Methods from Deref<Target=Vec<Title>>'\n+impl DerefMut for TitleList {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.members\n+    }\n+}"}, {"sha": "80630b5e2cf4b3087605291b6defd079fb9b64d0", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2741594ba2d4de2ad8cea69def6408ff5409af/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=ba2741594ba2d4de2ad8cea69def6408ff5409af", "patch": "@@ -711,7 +711,7 @@ pub fn make_test_name(config: &Config, testpaths: &TestPaths) -> test::TestName\n pub fn make_test_closure(config: &Config, testpaths: &TestPaths) -> test::TestFn {\n     let config = config.clone();\n     let testpaths = testpaths.clone();\n-    test::DynTestFn(Box::new(move |()| runtest::run(config, &testpaths)))\n+    test::DynTestFn(Box::new(move || runtest::run(config, &testpaths)))\n }\n \n /// Returns (Path to GDB, GDB Version, GDB has Rust Support)"}]}