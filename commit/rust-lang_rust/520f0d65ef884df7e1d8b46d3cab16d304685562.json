{"sha": "520f0d65ef884df7e1d8b46d3cab16d304685562", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMGYwZDY1ZWY4ODRkZjdlMWQ4YjQ2ZDNjYWIxNmQzMDQ2ODU1NjI=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-06T11:02:04Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-06T11:02:04Z"}, "message": "Format multiple patterns in 'if let' and `while let'\n\nCloses #2511.", "tree": {"sha": "e9fff1cc9c66d38007ba880a6d9277cc6daf8dad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9fff1cc9c66d38007ba880a6d9277cc6daf8dad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/520f0d65ef884df7e1d8b46d3cab16d304685562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/520f0d65ef884df7e1d8b46d3cab16d304685562", "html_url": "https://github.com/rust-lang/rust/commit/520f0d65ef884df7e1d8b46d3cab16d304685562", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/520f0d65ef884df7e1d8b46d3cab16d304685562/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7495324bcd0671070ec1f651df27778fea63afe", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7495324bcd0671070ec1f651df27778fea63afe", "html_url": "https://github.com/rust-lang/rust/commit/d7495324bcd0671070ec1f651df27778fea63afe"}], "stats": {"total": 202, "additions": 97, "deletions": 105}, "files": [{"sha": "337080f6c99ed00b1cbe4b3e7c430c6b7219d54e", "filename": "src/expr.rs", "status": "modified", "additions": 97, "deletions": 105, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/520f0d65ef884df7e1d8b46d3cab16d304685562/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520f0d65ef884df7e1d8b46d3cab16d304685562/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=520f0d65ef884df7e1d8b46d3cab16d304685562", "patch": "@@ -730,7 +730,7 @@ struct ControlFlow<'a> {\n     block: &'a ast::Block,\n     else_block: Option<&'a ast::Expr>,\n     label: Option<ast::Label>,\n-    pat: Option<&'a ast::Pat>,\n+    pats: Option<Vec<&'a ast::Pat>>,\n     keyword: &'a str,\n     matcher: &'a str,\n     connector: &'a str,\n@@ -754,7 +754,7 @@ fn to_control_flow(expr: &ast::Expr, expr_type: ExprType) -> Option<ControlFlow>\n         ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n             Some(ControlFlow::new_if(\n                 cond,\n-                Some(pat),\n+                Some(ptr_vec_to_ref_vec(pat)),\n                 if_block,\n                 else_block.as_ref().map(|e| &**e),\n                 expr_type == ExprType::SubExpression,\n@@ -772,7 +772,7 @@ fn to_control_flow(expr: &ast::Expr, expr_type: ExprType) -> Option<ControlFlow>\n             Some(ControlFlow::new_while(None, cond, block, label, expr.span))\n         }\n         ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => Some(\n-            ControlFlow::new_while(Some(pat), cond, block, label, expr.span),\n+            ControlFlow::new_while(Some(ptr_vec_to_ref_vec(pat)), cond, block, label, expr.span),\n         ),\n         _ => None,\n     }\n@@ -781,24 +781,25 @@ fn to_control_flow(expr: &ast::Expr, expr_type: ExprType) -> Option<ControlFlow>\n impl<'a> ControlFlow<'a> {\n     fn new_if(\n         cond: &'a ast::Expr,\n-        pat: Option<&'a ast::Pat>,\n+        pats: Option<Vec<&'a ast::Pat>>,\n         block: &'a ast::Block,\n         else_block: Option<&'a ast::Expr>,\n         allow_single_line: bool,\n         nested_if: bool,\n         span: Span,\n     ) -> ControlFlow<'a> {\n+        let matcher = match pats {\n+            Some(..) => \"let\",\n+            None => \"\",\n+        };\n         ControlFlow {\n             cond: Some(cond),\n             block,\n             else_block,\n             label: None,\n-            pat,\n+            pats,\n             keyword: \"if\",\n-            matcher: match pat {\n-                Some(..) => \"let\",\n-                None => \"\",\n-            },\n+            matcher,\n             connector: \" =\",\n             allow_single_line,\n             nested_if,\n@@ -812,7 +813,7 @@ impl<'a> ControlFlow<'a> {\n             block,\n             else_block: None,\n             label,\n-            pat: None,\n+            pats: None,\n             keyword: \"loop\",\n             matcher: \"\",\n             connector: \"\",\n@@ -823,23 +824,24 @@ impl<'a> ControlFlow<'a> {\n     }\n \n     fn new_while(\n-        pat: Option<&'a ast::Pat>,\n+        pats: Option<Vec<&'a ast::Pat>>,\n         cond: &'a ast::Expr,\n         block: &'a ast::Block,\n         label: Option<ast::Label>,\n         span: Span,\n     ) -> ControlFlow<'a> {\n+        let matcher = match pats {\n+            Some(..) => \"let\",\n+            None => \"\",\n+        };\n         ControlFlow {\n             cond: Some(cond),\n             block,\n             else_block: None,\n             label,\n-            pat,\n+            pats,\n             keyword: \"while\",\n-            matcher: match pat {\n-                Some(..) => \"let\",\n-                None => \"\",\n-            },\n+            matcher,\n             connector: \" =\",\n             allow_single_line: false,\n             nested_if: false,\n@@ -859,7 +861,7 @@ impl<'a> ControlFlow<'a> {\n             block,\n             else_block: None,\n             label,\n-            pat: Some(pat),\n+            pats: Some(vec![pat]),\n             keyword: \"for\",\n             matcher: \"\",\n             connector: \" in\",\n@@ -914,6 +916,46 @@ impl<'a> ControlFlow<'a> {\n }\n \n impl<'a> ControlFlow<'a> {\n+    fn rewrite_pat_expr(\n+        &self,\n+        context: &RewriteContext,\n+        expr: &ast::Expr,\n+        shape: Shape,\n+        offset: usize,\n+    ) -> Option<String> {\n+        debug!(\"rewrite_pat_expr {:?} {:?} {:?}\", shape, self.pats, expr);\n+\n+        let cond_shape = shape.offset_left(offset)?;\n+        if let Some(ref pat) = self.pats {\n+            let matcher = if self.matcher.is_empty() {\n+                self.matcher.to_owned()\n+            } else {\n+                format!(\"{} \", self.matcher)\n+            };\n+            let pat_shape = cond_shape\n+                .offset_left(matcher.len())?\n+                .sub_width(self.connector.len())?;\n+            let pat_string = rewrite_multiple_patterns(context, pat, pat_shape)?;\n+            let result = format!(\"{}{}{}\", matcher, pat_string, self.connector);\n+            return rewrite_assign_rhs(context, result, expr, cond_shape);\n+        }\n+\n+        let expr_rw = expr.rewrite(context, cond_shape);\n+        // The expression may (partially) fit on the current line.\n+        // We do not allow splitting between `if` and condition.\n+        if self.keyword == \"if\" || expr_rw.is_some() {\n+            return expr_rw;\n+        }\n+\n+        // The expression won't fit on the current line, jump to next.\n+        let nested_shape = shape\n+            .block_indent(context.config.tab_spaces())\n+            .with_max_width(context.config);\n+        let nested_indent_str = nested_shape.indent.to_string_with_newline(context.config);\n+        expr.rewrite(context, nested_shape)\n+            .map(|expr_rw| format!(\"{}{}\", nested_indent_str, expr_rw))\n+    }\n+\n     fn rewrite_cond(\n         &self,\n         context: &RewriteContext,\n@@ -922,11 +964,7 @@ impl<'a> ControlFlow<'a> {\n     ) -> Option<(String, usize)> {\n         // Do not take the rhs overhead from the upper expressions into account\n         // when rewriting pattern.\n-        let new_width = context\n-            .config\n-            .max_width()\n-            .checked_sub(shape.used_width())\n-            .unwrap_or(0);\n+        let new_width = context.budget(shape.used_width());\n         let fresh_shape = Shape {\n             width: new_width,\n             ..shape\n@@ -944,16 +982,7 @@ impl<'a> ControlFlow<'a> {\n         let offset = self.keyword.len() + label_string.len() + 1;\n \n         let pat_expr_string = match self.cond {\n-            Some(cond) => rewrite_pat_expr(\n-                context,\n-                self.pat,\n-                cond,\n-                self.matcher,\n-                self.connector,\n-                self.keyword,\n-                constr_shape,\n-                offset,\n-            )?,\n+            Some(cond) => self.rewrite_pat_expr(context, cond, constr_shape, offset)?,\n             None => String::new(),\n         };\n \n@@ -1007,9 +1036,9 @@ impl<'a> ControlFlow<'a> {\n             context\n                 .snippet_provider\n                 .span_after(mk_sp(lo, self.span.hi()), self.keyword.trim()),\n-            self.pat.map_or(cond_span.lo(), |p| {\n+            self.pats.as_ref().map_or(cond_span.lo(), |p| {\n                 if self.matcher.is_empty() {\n-                    p.span.lo()\n+                    p[0].span.lo()\n                 } else {\n                     context\n                         .snippet_provider\n@@ -1102,7 +1131,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                 ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref next_else_block) => {\n                     ControlFlow::new_if(\n                         cond,\n-                        Some(pat),\n+                        Some(ptr_vec_to_ref_vec(pat)),\n                         if_block,\n                         next_else_block.as_ref().map(|e| &**e),\n                         false,\n@@ -1455,7 +1484,7 @@ fn rewrite_match_arm(\n     };\n     let pats_str = rewrite_match_pattern(\n         context,\n-        &arm.pats,\n+        &ptr_vec_to_ref_vec(&arm.pats),\n         &arm.guard,\n         beginning_vert.is_some(),\n         shape,\n@@ -1513,7 +1542,7 @@ fn is_short_pattern_inner(pat: &ast::Pat) -> bool {\n \n fn rewrite_match_pattern(\n     context: &RewriteContext,\n-    pats: &[ptr::P<ast::Pat>],\n+    pats: &[&ast::Pat],\n     guard: &Option<ptr::P<ast::Expr>>,\n     has_beginning_vert: bool,\n     shape: Shape,\n@@ -1524,36 +1553,7 @@ fn rewrite_match_pattern(\n     let pat_shape = shape\n         .sub_width(5)?\n         .offset_left(if has_beginning_vert { 2 } else { 0 })?;\n-\n-    let pat_strs = pats.iter()\n-        .map(|p| p.rewrite(context, pat_shape))\n-        .collect::<Option<Vec<_>>>()?;\n-\n-    let use_mixed_layout = pats.iter()\n-        .zip(pat_strs.iter())\n-        .all(|(pat, pat_str)| is_short_pattern(pat, pat_str));\n-    let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n-    let tactic = if use_mixed_layout {\n-        DefinitiveListTactic::Mixed\n-    } else {\n-        definitive_tactic(\n-            &items,\n-            ListTactic::HorizontalVertical,\n-            Separator::VerticalBar,\n-            pat_shape.width,\n-        )\n-    };\n-    let fmt = ListFormatting {\n-        tactic,\n-        separator: \" |\",\n-        trailing_separator: SeparatorTactic::Never,\n-        separator_place: context.config.binop_separator(),\n-        shape: pat_shape,\n-        ends_with_newline: false,\n-        preserve_newline: false,\n-        config: context.config,\n-    };\n-    let pats_str = write_list(&items, &fmt)?;\n+    let pats_str = rewrite_multiple_patterns(context, pats, pat_shape)?;\n     let beginning_vert = if has_beginning_vert { \"| \" } else { \"\" };\n \n     // Guard\n@@ -1749,48 +1749,40 @@ fn rewrite_guard(\n     }\n }\n \n-fn rewrite_pat_expr(\n+fn rewrite_multiple_patterns(\n     context: &RewriteContext,\n-    pat: Option<&ast::Pat>,\n-    expr: &ast::Expr,\n-    matcher: &str,\n-    // Connecting piece between pattern and expression,\n-    // *without* trailing space.\n-    connector: &str,\n-    keyword: &str,\n+    pats: &[&ast::Pat],\n     shape: Shape,\n-    offset: usize,\n ) -> Option<String> {\n-    debug!(\"rewrite_pat_expr {:?} {:?} {:?}\", shape, pat, expr);\n-    let cond_shape = shape.offset_left(offset)?;\n-    if let Some(pat) = pat {\n-        let matcher = if matcher.is_empty() {\n-            matcher.to_owned()\n-        } else {\n-            format!(\"{} \", matcher)\n-        };\n-        let pat_shape = cond_shape\n-            .offset_left(matcher.len())?\n-            .sub_width(connector.len())?;\n-        let pat_string = pat.rewrite(context, pat_shape)?;\n-        let result = format!(\"{}{}{}\", matcher, pat_string, connector);\n-        return rewrite_assign_rhs(context, result, expr, cond_shape);\n-    }\n-\n-    let expr_rw = expr.rewrite(context, cond_shape);\n-    // The expression may (partially) fit on the current line.\n-    // We do not allow splitting between `if` and condition.\n-    if keyword == \"if\" || expr_rw.is_some() {\n-        return expr_rw;\n-    }\n+    let pat_strs = pats.iter()\n+        .map(|p| p.rewrite(context, shape))\n+        .collect::<Option<Vec<_>>>()?;\n \n-    // The expression won't fit on the current line, jump to next.\n-    let nested_shape = shape\n-        .block_indent(context.config.tab_spaces())\n-        .with_max_width(context.config);\n-    let nested_indent_str = nested_shape.indent.to_string_with_newline(context.config);\n-    expr.rewrite(context, nested_shape)\n-        .map(|expr_rw| format!(\"{}{}\", nested_indent_str, expr_rw))\n+    let use_mixed_layout = pats.iter()\n+        .zip(pat_strs.iter())\n+        .all(|(pat, pat_str)| is_short_pattern(pat, pat_str));\n+    let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n+    let tactic = if use_mixed_layout {\n+        DefinitiveListTactic::Mixed\n+    } else {\n+        definitive_tactic(\n+            &items,\n+            ListTactic::HorizontalVertical,\n+            Separator::VerticalBar,\n+            shape.width,\n+        )\n+    };\n+    let fmt = ListFormatting {\n+        tactic,\n+        separator: \" |\",\n+        trailing_separator: SeparatorTactic::Never,\n+        separator_place: context.config.binop_separator(),\n+        shape: shape,\n+        ends_with_newline: false,\n+        preserve_newline: false,\n+        config: context.config,\n+    };\n+    write_list(&items, &fmt)\n }\n \n fn can_extend_match_arm_body(body: &ast::Expr) -> bool {"}]}