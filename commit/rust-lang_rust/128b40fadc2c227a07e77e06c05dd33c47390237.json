{"sha": "128b40fadc2c227a07e77e06c05dd33c47390237", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyOGI0MGZhZGMyYzIyN2EwN2U3N2UwNmMwNWRkMzNjNDczOTAyMzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-25T22:38:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-25T22:38:47Z"}, "message": "Auto merge of #45367 - alexcrichton:simd-llvm-changes, r=eddyb\n\nrustc: Add support for some more x86 SIMD ops\n\nThis commit adds compiler support for two basic operations needed for binding\nSIMD on x86 platforms:\n\n* First, a `nontemporal_store` intrinsic was added for the `_mm_stream_ps`, seen\n  in rust-lang-nursery/stdsimd#114. This was relatively straightforward and is\n  quite similar to the volatile store intrinsic.\n\n* Next, and much more intrusively, a new type to the backend was added. The\n  `x86_mmx` type is used in LLVM for a 64-bit vector register and is used in\n  various intrinsics like `_mm_abs_pi8` as seen in rust-lang-nursery/stdsimd#74.\n  This new type was added as a new layout option as well as having support added\n  to the trans backend. The type is enabled with the `#[repr(x86_mmx)]`\n  attribute which is intended to just be an implementation detail of SIMD in\n  Rust.\n\nI'm not 100% certain about how the `x86_mmx` type was added, so any extra eyes\nor thoughts on that would be greatly appreciated!", "tree": {"sha": "21c61528dcc42e0c992f24a937d8b2faf13580b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21c61528dcc42e0c992f24a937d8b2faf13580b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/128b40fadc2c227a07e77e06c05dd33c47390237", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/128b40fadc2c227a07e77e06c05dd33c47390237", "html_url": "https://github.com/rust-lang/rust/commit/128b40fadc2c227a07e77e06c05dd33c47390237", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/128b40fadc2c227a07e77e06c05dd33c47390237/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e97ba83287a6f0f85cc9cc7a51ab309487e17038", "url": "https://api.github.com/repos/rust-lang/rust/commits/e97ba83287a6f0f85cc9cc7a51ab309487e17038", "html_url": "https://github.com/rust-lang/rust/commit/e97ba83287a6f0f85cc9cc7a51ab309487e17038"}, {"sha": "fe53a8106dfb54b5fe04d2ce7e8ee6472b0d5b16", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe53a8106dfb54b5fe04d2ce7e8ee6472b0d5b16", "html_url": "https://github.com/rust-lang/rust/commit/fe53a8106dfb54b5fe04d2ce7e8ee6472b0d5b16"}], "stats": {"total": 129, "additions": 125, "deletions": 4}, "files": [{"sha": "f1e51e995c238a9e6d57c4d3e3736880f71b9226", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=128b40fadc2c227a07e77e06c05dd33c47390237", "patch": "@@ -1387,4 +1387,9 @@ extern \"rust-intrinsic\" {\n     /// # } }\n     /// ```\n     pub fn align_offset(ptr: *const (), align: usize) -> usize;\n+\n+    /// Emits a `!nontemporal` store according to LLVM (see their docs).\n+    /// Probably will never become stable.\n+    #[cfg(not(stage0))]\n+    pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n }"}, {"sha": "dd64d76bc0c51eaead173299dc677c18172d9367", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=128b40fadc2c227a07e77e06c05dd33c47390237", "patch": "@@ -587,6 +587,7 @@ extern \"C\" {\n \n     // Operations on other types\n     pub fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMX86MMXTypeInContext(C: ContextRef) -> TypeRef;\n     pub fn LLVMRustMetadataTypeInContext(C: ContextRef) -> TypeRef;\n \n     // Operations on all values"}, {"sha": "e40311af595cdc993c81006c0d720e51856e72aa", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=128b40fadc2c227a07e77e06c05dd33c47390237", "patch": "@@ -612,6 +612,29 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn nontemporal_store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n+        debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n+        assert!(!self.llbuilder.is_null());\n+        self.count_insn(\"store.nontemporal\");\n+        let ptr = self.check_store(val, ptr);\n+        unsafe {\n+            let insn = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n+\n+            // According to LLVM [1] building a nontemporal store must *always*\n+            // point to a metadata value of the integer 1. Who knew?\n+            //\n+            // [1]: http://llvm.org/docs/LangRef.html#store-instruction\n+            let one = C_i32(self.ccx, 1);\n+            let node = llvm::LLVMMDNodeInContext(self.ccx.llcx(),\n+                                                 &one,\n+                                                 1);\n+            llvm::LLVMSetMetadata(insn,\n+                                  llvm::MD_nontemporal as c_uint,\n+                                  node);\n+            insn\n+        }\n+    }\n+\n     pub fn gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n         self.count_insn(\"gep\");\n         unsafe {"}, {"sha": "8f5d836f56f3ffffca87481525ce758d20669e2a", "filename": "src/librustc_trans/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_trans%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_trans%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdiagnostics.rs?ref=128b40fadc2c227a07e77e06c05dd33c47390237", "patch": "@@ -37,13 +37,13 @@ The generic type has to be a SIMD type. Example:\n \n #[repr(simd)]\n #[derive(Copy, Clone)]\n-struct i32x1(i32);\n+struct i32x2(i32, i32);\n \n extern \"platform-intrinsic\" {\n     fn simd_add<T>(a: T, b: T) -> T;\n }\n \n-unsafe { simd_add(i32x1(0), i32x1(1)); } // ok!\n+unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n ```\n \"##,\n "}, {"sha": "997dd5573538a26fbf2f5343b6c751e977c9feee", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=128b40fadc2c227a07e77e06c05dd33c47390237", "patch": "@@ -540,6 +540,22 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             }\n         }\n \n+        \"nontemporal_store\" => {\n+            let tp_ty = substs.type_at(0);\n+            let dst = args[0].deref(bcx.ccx);\n+            let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n+                bcx.load(ptr, align.non_abi())\n+            } else {\n+                from_immediate(bcx, args[1].immediate())\n+            };\n+            let ptr = bcx.pointercast(dst.llval, val_ty(val).ptr_to());\n+            let store = bcx.nontemporal_store(val, ptr);\n+            unsafe {\n+                llvm::LLVMSetAlignment(store, ccx.align_of(tp_ty).abi() as u32);\n+            }\n+            return\n+        }\n+\n         _ => {\n             let intr = match Intrinsic::find(&name) {\n                 Some(intr) => intr,"}, {"sha": "1775e53284963106ce8a05f0ea328bd7eeb7dd8a", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=128b40fadc2c227a07e77e06c05dd33c47390237", "patch": "@@ -286,4 +286,8 @@ impl Type {\n             Type::i8(ccx)\n         }\n     }\n+\n+    pub fn x86_mmx(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMX86MMXTypeInContext(ccx.llcx()))\n+    }\n }"}, {"sha": "42e45b3a36fe4897be65ddc4f4d769a2239d0140", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=128b40fadc2c227a07e77e06c05dd33c47390237", "patch": "@@ -26,8 +26,23 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match layout.abi {\n         layout::Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n         layout::Abi::Vector => {\n-            return Type::vector(&layout.field(ccx, 0).llvm_type(ccx),\n-                                layout.fields.count() as u64);\n+            // LLVM has a separate type for 64-bit SIMD vectors on X86 called\n+            // `x86_mmx` which is needed for some SIMD operations. As a bit of a\n+            // hack (all SIMD definitions are super unstable anyway) we\n+            // recognize any one-element SIMD vector as \"this should be an\n+            // x86_mmx\" type. In general there shouldn't be a need for other\n+            // one-element SIMD vectors, so it's assumed this won't clash with\n+            // much else.\n+            let use_x86_mmx = layout.fields.count() == 1 &&\n+                layout.size.bits() == 64 &&\n+                (ccx.sess().target.target.arch == \"x86\" ||\n+                 ccx.sess().target.target.arch == \"x86_64\");\n+            if use_x86_mmx {\n+                return Type::x86_mmx(ccx)\n+            } else {\n+                return Type::vector(&layout.field(ccx, 0).llvm_type(ccx),\n+                                    layout.fields.count() as u64);\n+            }\n         }\n         layout::Abi::ScalarPair(..) => {\n             return Type::struct_(ccx, &["}, {"sha": "c1adb0e65a4da926ef09f76ce52e8311a3649485", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=128b40fadc2c227a07e77e06c05dd33c47390237", "patch": "@@ -318,6 +318,10 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 (0, vec![ptr_ty, tcx.types.usize], tcx.types.usize)\n             },\n \n+            \"nontemporal_store\" => {\n+                (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_nil())\n+            }\n+\n             ref other => {\n                 struct_span_err!(tcx.sess, it.span, E0093,\n                                 \"unrecognized intrinsic function: `{}`\","}, {"sha": "28ec534b97a68d4c5701ec11b0fbe51ee229a1e9", "filename": "src/test/codegen/nontemporal.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Ftest%2Fcodegen%2Fnontemporal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Ftest%2Fcodegen%2Fnontemporal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnontemporal.rs?ref=128b40fadc2c227a07e77e06c05dd33c47390237", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -O\n+\n+#![feature(core_intrinsics)]\n+#![crate_type = \"lib\"]\n+\n+#[no_mangle]\n+pub fn a(a: &mut u32, b: u32) {\n+    // CHECK-LABEL: define void @a\n+    // CHECK: store i32 %b, i32* %a, align 4, !nontemporal\n+    unsafe {\n+        std::intrinsics::nontemporal_store(a, b);\n+    }\n+}"}, {"sha": "bedda63bbff31deb19072212e59df5fff994465a", "filename": "src/test/codegen/x86_mmx.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Ftest%2Fcodegen%2Fx86_mmx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128b40fadc2c227a07e77e06c05dd33c47390237/src%2Ftest%2Fcodegen%2Fx86_mmx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fx86_mmx.rs?ref=128b40fadc2c227a07e77e06c05dd33c47390237", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-arm\n+// ignore-aarch64\n+// ignore-emscripten\n+// compile-flags: -O\n+\n+#![feature(repr_simd)]\n+#![crate_type=\"lib\"]\n+\n+#[repr(simd)]\n+#[derive(Clone, Copy)]\n+pub struct i8x8(u64);\n+\n+#[no_mangle]\n+pub fn a(a: &mut i8x8, b: i8x8) -> i8x8 {\n+    // CHECK-LABEL: define x86_mmx @a(x86_mmx*{{.*}}, x86_mmx{{.*}})\n+    // CHECK: store x86_mmx %b, x86_mmx* %a\n+    // CHECK: ret x86_mmx %b\n+    *a = b;\n+    return b\n+}"}]}