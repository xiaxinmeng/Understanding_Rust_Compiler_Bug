{"sha": "88538adf9ae1886d9b5c1f45d55b2f76bd6435bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NTM4YWRmOWFlMTg4NmQ5YjVjMWY0NWQ1NWIyZjc2YmQ2NDM1YmQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-09-12T13:15:05Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-09-18T19:23:01Z"}, "message": "Record intra-statement/terminator conflicts\n\nSome MIR statements and terminators have an (undocumented...) invariant\nthat some of their input and outputs must not overlap. This records\nconflicts between locals used in these positions.", "tree": {"sha": "fc7976adb92b82d14840aba7380c6f7ecef7cc38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc7976adb92b82d14840aba7380c6f7ecef7cc38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88538adf9ae1886d9b5c1f45d55b2f76bd6435bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88538adf9ae1886d9b5c1f45d55b2f76bd6435bd", "html_url": "https://github.com/rust-lang/rust/commit/88538adf9ae1886d9b5c1f45d55b2f76bd6435bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88538adf9ae1886d9b5c1f45d55b2f76bd6435bd/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddd6930b549d069ac13de66b8676fed4feb95ec4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddd6930b549d069ac13de66b8676fed4feb95ec4", "html_url": "https://github.com/rust-lang/rust/commit/ddd6930b549d069ac13de66b8676fed4feb95ec4"}], "stats": {"total": 228, "additions": 206, "deletions": 22}, "files": [{"sha": "20f8f820176abbe626fc69f98ef638f75da473a8", "filename": "compiler/rustc_mir/src/transform/dest_prop.rs", "status": "modified", "additions": 206, "deletions": 22, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/88538adf9ae1886d9b5c1f45d55b2f76bd6435bd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88538adf9ae1886d9b5c1f45d55b2f76bd6435bd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs?ref=88538adf9ae1886d9b5c1f45d55b2f76bd6435bd", "patch": "@@ -109,8 +109,8 @@ use rustc_index::{\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n use rustc_middle::mir::{\n-    traversal, Body, Local, LocalKind, Location, Operand, Place, PlaceElem, Rvalue, Statement,\n-    StatementKind, Terminator, TerminatorKind,\n+    traversal, Body, InlineAsmOperand, Local, LocalKind, Location, Operand, Place, PlaceElem,\n+    Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -397,7 +397,9 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'tcx> {\n     }\n }\n \n-struct Conflicts {\n+struct Conflicts<'a> {\n+    relevant_locals: &'a BitSet<Local>,\n+\n     /// The conflict matrix. It is always symmetric and the adjacency matrix of the corresponding\n     /// conflict graph.\n     matrix: BitMatrix<Local, Local>,\n@@ -406,30 +408,21 @@ struct Conflicts {\n     unify_cache: BitSet<Local>,\n }\n \n-impl Conflicts {\n+impl Conflicts<'a> {\n     fn build<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &'_ Body<'tcx>,\n         source: MirSource<'tcx>,\n-        relevant_locals: &BitSet<Local>,\n+        relevant_locals: &'a BitSet<Local>,\n     ) -> Self {\n         // We don't have to look out for locals that have their address taken, since\n         // `find_candidates` already takes care of that.\n \n-        let mut conflicts = BitMatrix::from_row_n(\n+        let conflicts = BitMatrix::from_row_n(\n             &BitSet::new_empty(body.local_decls.len()),\n             body.local_decls.len(),\n         );\n \n-        let mut record_conflicts = |new_conflicts: &mut BitSet<_>| {\n-            // Remove all locals that are not candidates.\n-            new_conflicts.intersect(relevant_locals);\n-\n-            for local in new_conflicts.iter() {\n-                conflicts.union_row_with(&new_conflicts, local);\n-            }\n-        };\n-\n         let def_id = source.def_id();\n         let mut init = MaybeInitializedLocals\n             .into_engine(tcx, body, def_id)\n@@ -494,6 +487,12 @@ impl Conflicts {\n             },\n         );\n \n+        let mut this = Self {\n+            relevant_locals,\n+            matrix: conflicts,\n+            unify_cache: BitSet::new_empty(body.local_decls.len()),\n+        };\n+\n         let mut live_and_init_locals = Vec::new();\n \n         // Visit only reachable basic blocks. The exact order is not important.\n@@ -511,14 +510,22 @@ impl Conflicts {\n                 BitSet::new_empty(body.local_decls.len())\n             });\n \n-            // First, go forwards for `MaybeInitializedLocals`.\n-            for statement_index in 0..=data.statements.len() {\n-                let loc = Location { block, statement_index };\n+            // First, go forwards for `MaybeInitializedLocals` and apply intra-statement/terminator\n+            // conflicts.\n+            for (i, statement) in data.statements.iter().enumerate() {\n+                this.record_statement_conflicts(statement);\n+\n+                let loc = Location { block, statement_index: i };\n                 init.seek_before_primary_effect(loc);\n \n-                live_and_init_locals[statement_index].clone_from(init.get());\n+                live_and_init_locals[i].clone_from(init.get());\n             }\n \n+            this.record_terminator_conflicts(data.terminator());\n+            let term_loc = Location { block, statement_index: data.statements.len() };\n+            init.seek_before_primary_effect(term_loc);\n+            live_and_init_locals[term_loc.statement_index].clone_from(init.get());\n+\n             // Now, go backwards and union with the liveness results.\n             for statement_index in (0..=data.statements.len()).rev() {\n                 let loc = Location { block, statement_index };\n@@ -528,7 +535,7 @@ impl Conflicts {\n \n                 trace!(\"record conflicts at {:?}\", loc);\n \n-                record_conflicts(&mut live_and_init_locals[statement_index]);\n+                this.record_conflicts(&mut live_and_init_locals[statement_index]);\n             }\n \n             init.seek_to_block_end(block);\n@@ -537,10 +544,187 @@ impl Conflicts {\n             conflicts.intersect(live.get());\n             trace!(\"record conflicts at end of {:?}\", block);\n \n-            record_conflicts(&mut conflicts);\n+            this.record_conflicts(&mut conflicts);\n+        }\n+\n+        this\n+    }\n+\n+    fn record_conflicts(&mut self, new_conflicts: &mut BitSet<Local>) {\n+        // Remove all locals that are not candidates.\n+        new_conflicts.intersect(self.relevant_locals);\n+\n+        for local in new_conflicts.iter() {\n+            self.matrix.union_row_with(&new_conflicts, local);\n+        }\n+    }\n+\n+    /// Records locals that must not overlap during the evaluation of `stmt`. These locals conflict\n+    /// and must not be merged.\n+    fn record_statement_conflicts(&mut self, stmt: &Statement<'_>) {\n+        match &stmt.kind {\n+            // While the left and right sides of an assignment must not overlap, we do not mark\n+            // conflicts here as that would make this optimization useless. When we optimize, we\n+            // eliminate the resulting self-assignments automatically.\n+            StatementKind::Assign(_) => {}\n+\n+            StatementKind::LlvmInlineAsm(asm) => {\n+                // Inputs and outputs must not overlap.\n+                for (_, input) in &*asm.inputs {\n+                    if let Some(in_place) = input.place() {\n+                        if !in_place.is_indirect() {\n+                            for out_place in &*asm.outputs {\n+                                if !out_place.is_indirect() && !in_place.is_indirect() {\n+                                    self.matrix.insert(in_place.local, out_place.local);\n+                                    self.matrix.insert(out_place.local, in_place.local);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            StatementKind::SetDiscriminant { .. }\n+            | StatementKind::StorageLive(_)\n+            | StatementKind::StorageDead(_)\n+            | StatementKind::Retag(_, _)\n+            | StatementKind::FakeRead(_, _)\n+            | StatementKind::AscribeUserType(_, _)\n+            | StatementKind::Nop => {}\n         }\n+    }\n \n-        Self { matrix: conflicts, unify_cache: BitSet::new_empty(body.local_decls.len()) }\n+    fn record_terminator_conflicts(&mut self, term: &Terminator<'_>) {\n+        match &term.kind {\n+            TerminatorKind::DropAndReplace { location, value, target: _, unwind: _ } => {\n+                if let Some(place) = value.place() {\n+                    if !place.is_indirect() && !location.is_indirect() {\n+                        self.matrix.insert(place.local, location.local);\n+                        self.matrix.insert(location.local, place.local);\n+                    }\n+                }\n+            }\n+            TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n+                if let Some(place) = value.place() {\n+                    if !place.is_indirect() && !resume_arg.is_indirect() {\n+                        self.matrix.insert(place.local, resume_arg.local);\n+                        self.matrix.insert(resume_arg.local, place.local);\n+                    }\n+                }\n+            }\n+            TerminatorKind::Call {\n+                func,\n+                args,\n+                destination: Some((dest_place, _)),\n+                cleanup: _,\n+                from_hir_call: _,\n+            } => {\n+                // No arguments may overlap with the destination.\n+                for arg in args.iter().chain(Some(func)) {\n+                    if let Some(place) = arg.place() {\n+                        if !place.is_indirect() && !dest_place.is_indirect() {\n+                            self.matrix.insert(dest_place.local, place.local);\n+                            self.matrix.insert(place.local, dest_place.local);\n+                        }\n+                    }\n+                }\n+            }\n+            TerminatorKind::InlineAsm {\n+                template: _,\n+                operands,\n+                options: _,\n+                line_spans: _,\n+                destination: _,\n+            } => {\n+                // The intended semantics here aren't documented, we just assume that nothing that\n+                // could be written to by the assembly may overlap with any other operands.\n+                for op in operands {\n+                    match op {\n+                        InlineAsmOperand::Out { reg: _, late: _, place: Some(dest_place) }\n+                        | InlineAsmOperand::InOut {\n+                            reg: _,\n+                            late: _,\n+                            in_value: _,\n+                            out_place: Some(dest_place),\n+                        } => {\n+                            // For output place `place`, add all places accessed by the inline asm.\n+                            for op in operands {\n+                                match op {\n+                                    InlineAsmOperand::In { reg: _, value } => {\n+                                        if let Some(p) = value.place() {\n+                                            if !p.is_indirect() && !dest_place.is_indirect() {\n+                                                self.matrix.insert(p.local, dest_place.local);\n+                                                self.matrix.insert(dest_place.local, p.local);\n+                                            }\n+                                        }\n+                                    }\n+                                    InlineAsmOperand::Out {\n+                                        reg: _,\n+                                        late: _,\n+                                        place: Some(place),\n+                                    } => {\n+                                        if !place.is_indirect() && !dest_place.is_indirect() {\n+                                            self.matrix.insert(place.local, dest_place.local);\n+                                            self.matrix.insert(dest_place.local, place.local);\n+                                        }\n+                                    }\n+                                    InlineAsmOperand::InOut {\n+                                        reg: _,\n+                                        late: _,\n+                                        in_value,\n+                                        out_place,\n+                                    } => {\n+                                        if let Some(place) = in_value.place() {\n+                                            if !place.is_indirect() && !dest_place.is_indirect() {\n+                                                self.matrix.insert(place.local, dest_place.local);\n+                                                self.matrix.insert(dest_place.local, place.local);\n+                                            }\n+                                        }\n+\n+                                        if let Some(place) = out_place {\n+                                            if !place.is_indirect() && !dest_place.is_indirect() {\n+                                                self.matrix.insert(place.local, dest_place.local);\n+                                                self.matrix.insert(dest_place.local, place.local);\n+                                            }\n+                                        }\n+                                    }\n+                                    InlineAsmOperand::Out { reg: _, late: _, place: None }\n+                                    | InlineAsmOperand::Const { value: _ }\n+                                    | InlineAsmOperand::SymFn { value: _ }\n+                                    | InlineAsmOperand::SymStatic { value: _ } => {}\n+                                }\n+                            }\n+                        }\n+                        InlineAsmOperand::Const { value } => {\n+                            assert!(value.place().is_none());\n+                        }\n+                        InlineAsmOperand::InOut {\n+                            reg: _,\n+                            late: _,\n+                            in_value: _,\n+                            out_place: None,\n+                        }\n+                        | InlineAsmOperand::In { reg: _, value: _ }\n+                        | InlineAsmOperand::Out { reg: _, late: _, place: None }\n+                        | InlineAsmOperand::SymFn { value: _ }\n+                        | InlineAsmOperand::SymStatic { value: _ } => {}\n+                    }\n+                }\n+            }\n+\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::Call { destination: None, .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::FalseUnwind { .. } => {}\n+        }\n     }\n \n     fn contains(&self, a: Local, b: Local) -> bool {"}]}