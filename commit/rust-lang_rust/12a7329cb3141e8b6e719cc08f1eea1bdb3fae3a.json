{"sha": "12a7329cb3141e8b6e719cc08f1eea1bdb3fae3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYTczMjljYjMxNDFlOGI2ZTcxOWNjMDhmMWVlYTFiZGIzZmFlM2E=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-05T13:55:17Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-05T13:55:17Z"}, "message": "Merge #1648\n\n1648: Optimize parsing a little r=lnicola a=lnicola\n\nThis is the change from https://github.com/rust-analyzer/rust-analyzer/issues/1643#issuecomment-517979911. In the long run we should probably take a different approach, but until then this provides a decent speed-up (10.5s vs 11.5s according to `ra_cli analysis-stats`.\r\n\r\nEDIT: Does the profiling part make sense? I'm not sure if all parsing happens before the type inference begins or it's lazy.\n\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>\nCo-authored-by: Lauren\u021biu Nicola <lnicola@users.noreply.github.com>", "tree": {"sha": "4048f6a71b825dd93d7c968bc44471143d69473b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4048f6a71b825dd93d7c968bc44471143d69473b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12a7329cb3141e8b6e719cc08f1eea1bdb3fae3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12a7329cb3141e8b6e719cc08f1eea1bdb3fae3a", "html_url": "https://github.com/rust-lang/rust/commit/12a7329cb3141e8b6e719cc08f1eea1bdb3fae3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12a7329cb3141e8b6e719cc08f1eea1bdb3fae3a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "a490f80a9c49380c5088b704047bb20b76c06e4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a490f80a9c49380c5088b704047bb20b76c06e4d", "html_url": "https://github.com/rust-lang/rust/commit/a490f80a9c49380c5088b704047bb20b76c06e4d"}, {"sha": "f1cfd5ec3de3de39e5423e80a35c719463c4e5c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1cfd5ec3de3de39e5423e80a35c719463c4e5c0", "html_url": "https://github.com/rust-lang/rust/commit/f1cfd5ec3de3de39e5423e80a35c719463c4e5c0"}], "stats": {"total": 60, "additions": 40, "deletions": 20}, "files": [{"sha": "7e7e6c073ceb82491e37e686cbc463eeaab35bbc", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12a7329cb3141e8b6e719cc08f1eea1bdb3fae3a/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12a7329cb3141e8b6e719cc08f1eea1bdb3fae3a/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=12a7329cb3141e8b6e719cc08f1eea1bdb3fae3a", "patch": "@@ -52,6 +52,9 @@ pub fn run(verbose: bool, memory_usage: bool, path: &Path, only: Option<&str>) -\n     println!(\"Total modules found: {}\", visited_modules.len());\n     println!(\"Total declarations: {}\", num_decls);\n     println!(\"Total functions: {}\", funcs.len());\n+    println!(\"Item Collection: {:?}, {}\", analysis_time.elapsed(), ra_prof::memory_usage());\n+\n+    let inference_time = Instant::now();\n     let bar = indicatif::ProgressBar::with_draw_target(\n         funcs.len() as u64,\n         indicatif::ProgressDrawTarget::stderr_nohz(),\n@@ -112,7 +115,8 @@ pub fn run(verbose: bool, memory_usage: bool, path: &Path, only: Option<&str>) -\n         num_exprs_partially_unknown,\n         (num_exprs_partially_unknown * 100 / num_exprs)\n     );\n-    println!(\"Analysis: {:?}, {}\", analysis_time.elapsed(), ra_prof::memory_usage());\n+    println!(\"Inference: {:?}, {}\", inference_time.elapsed(), ra_prof::memory_usage());\n+    println!(\"Total: {:?}, {}\", analysis_time.elapsed(), ra_prof::memory_usage());\n \n     if memory_usage {\n         drop(db);"}, {"sha": "393586561b10328ecc4125e6ebc79eeca861a5c0", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/12a7329cb3141e8b6e719cc08f1eea1bdb3fae3a/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12a7329cb3141e8b6e719cc08f1eea1bdb3fae3a/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=12a7329cb3141e8b6e719cc08f1eea1bdb3fae3a", "patch": "@@ -6,7 +6,7 @@ use crate::{\n     event::Event,\n     ParseError,\n     SyntaxKind::{self, EOF, ERROR, TOMBSTONE},\n-    TokenSet, TokenSource, T,\n+    Token, TokenSet, TokenSource, T,\n };\n \n /// `Parser` struct provides the low-level API for\n@@ -87,8 +87,9 @@ impl<'t> Parser<'t> {\n         let mut i = 0;\n \n         loop {\n-            let mut kind = self.token_source.lookahead_nth(i).kind;\n-            if let Some((composited, step)) = self.is_composite(kind, i) {\n+            let token = self.token_source.lookahead_nth(i);\n+            let mut kind = token.kind;\n+            if let Some((composited, step)) = self.is_composite(token, i) {\n                 kind = composited;\n                 i += step;\n             } else {\n@@ -250,32 +251,47 @@ impl<'t> Parser<'t> {\n     }\n \n     /// helper function for check if it is composite.\n-    fn is_composite(&self, kind: SyntaxKind, n: usize) -> Option<(SyntaxKind, usize)> {\n+    fn is_composite(&self, first: Token, n: usize) -> Option<(SyntaxKind, usize)> {\n         // We assume the dollars will not occuried between\n         // mult-byte tokens\n \n-        let first = self.token_source.lookahead_nth(n);\n+        let jn1 = first.is_jointed_to_next;\n+        if !jn1 && first.kind != T![-] {\n+            return None;\n+        }\n+\n         let second = self.token_source.lookahead_nth(n + 1);\n+        if first.kind == T![-] && second.kind == T![>] {\n+            return Some((T![->], 2));\n+        }\n+        if !jn1 {\n+            return None;\n+        }\n+\n+        match (first.kind, second.kind) {\n+            (T![:], T![:]) => return Some((T![::], 2)),\n+            (T![=], T![=]) => return Some((T![==], 2)),\n+            (T![=], T![>]) => return Some((T![=>], 2)),\n+            (T![!], T![=]) => return Some((T![!=], 2)),\n+            _ => {}\n+        }\n+\n+        if first.kind != T![.] || second.kind != T![.] {\n+            return None;\n+        }\n+\n         let third = self.token_source.lookahead_nth(n + 2);\n \n-        let jn1 = first.is_jointed_to_next;\n-        let la2 = second.kind;\n         let jn2 = second.is_jointed_to_next;\n         let la3 = third.kind;\n \n-        match kind {\n-            T![.] if jn1 && la2 == T![.] && jn2 && la3 == T![.] => Some((T![...], 3)),\n-            T![.] if jn1 && la2 == T![.] && la3 == T![=] => Some((T![..=], 3)),\n-            T![.] if jn1 && la2 == T![.] => Some((T![..], 2)),\n-\n-            T![:] if jn1 && la2 == T![:] => Some((T![::], 2)),\n-            T![=] if jn1 && la2 == T![=] => Some((T![==], 2)),\n-            T![=] if jn1 && la2 == T![>] => Some((T![=>], 2)),\n-\n-            T![!] if jn1 && la2 == T![=] => Some((T![!=], 2)),\n-            T![-] if la2 == T![>] => Some((T![->], 2)),\n-            _ => None,\n+        if jn2 && la3 == T![.] {\n+            return Some((T![...], 3));\n+        }\n+        if la3 == T![=] {\n+            return Some((T![..=], 3));\n         }\n+        return Some((T![..], 2));\n     }\n \n     fn eat_dollars(&mut self) {"}]}