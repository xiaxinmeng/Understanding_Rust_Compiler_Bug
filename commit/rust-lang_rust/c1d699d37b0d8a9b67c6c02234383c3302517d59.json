{"sha": "c1d699d37b0d8a9b67c6c02234383c3302517d59", "node_id": "C_kwDOAAsO6NoAKGMxZDY5OWQzN2IwZDhhOWI2N2M2YzAyMjM0MzgzYzMzMDI1MTdkNTk", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-01-30T18:31:18Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-01-30T18:31:18Z"}, "message": "Remove the remaining simd intrinsic macros", "tree": {"sha": "78a347bad8ed88f9fb864c6dc4c8a303e1d9c976", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78a347bad8ed88f9fb864c6dc4c8a303e1d9c976"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1d699d37b0d8a9b67c6c02234383c3302517d59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d699d37b0d8a9b67c6c02234383c3302517d59", "html_url": "https://github.com/rust-lang/rust/commit/c1d699d37b0d8a9b67c6c02234383c3302517d59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1d699d37b0d8a9b67c6c02234383c3302517d59/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ae27ea6aaf68ddc1e2b7812cbe1f356d13711c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ae27ea6aaf68ddc1e2b7812cbe1f356d13711c7", "html_url": "https://github.com/rust-lang/rust/commit/1ae27ea6aaf68ddc1e2b7812cbe1f356d13711c7"}], "stats": {"total": 150, "additions": 72, "deletions": 78}, "files": [{"sha": "893d809a47e2289dc45af49a54e4fecefdeab611", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 72, "deletions": 78, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/c1d699d37b0d8a9b67c6c02234383c3302517d59/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d699d37b0d8a9b67c6c02234383c3302517d59/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=c1d699d37b0d8a9b67c6c02234383c3302517d59", "patch": "@@ -17,54 +17,6 @@ fn report_simd_type_validation_error(\n     crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n }\n \n-macro simd_int_binop($fx:expr, $intrinsic:ident, $span:ident, $op_u:ident|$op_s:ident($x:ident, $y:ident) -> $ret:ident) {\n-    if !$x.layout().ty.is_simd() {\n-        report_simd_type_validation_error($fx, $intrinsic, $span, $x.layout().ty);\n-        return;\n-    }\n-\n-    // FIXME use vector instructions when possible\n-    simd_pair_for_each_lane($fx, $x, $y, $ret, &|fx, lane_ty, _ret_lane_ty, x_lane, y_lane| {\n-        match lane_ty.kind() {\n-            ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n-            ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n-            _ => unreachable!(\"{:?}\", lane_ty),\n-        }\n-    });\n-}\n-\n-macro simd_int_flt_binop($fx:expr, $intrinsic:ident, $span:ident, $op_u:ident|$op_s:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) {\n-    if !$x.layout().ty.is_simd() {\n-        report_simd_type_validation_error($fx, $intrinsic, $span, $x.layout().ty);\n-        return;\n-    }\n-\n-    // FIXME use vector instructions when possible\n-    simd_pair_for_each_lane($fx, $x, $y, $ret, &|fx, lane_ty, _ret_lane_ty, x_lane, y_lane| {\n-        match lane_ty.kind() {\n-            ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n-            ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n-            ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n-            _ => unreachable!(\"{:?}\", lane_ty),\n-        }\n-    });\n-}\n-\n-macro simd_flt_binop($fx:expr, $intrinsic:ident, $span:ident, $op:ident($x:ident, $y:ident) -> $ret:ident) {\n-    if !$x.layout().ty.is_simd() {\n-        report_simd_type_validation_error($fx, $intrinsic, $span, $x.layout().ty);\n-        return;\n-    }\n-\n-    // FIXME use vector instructions when possible\n-    simd_pair_for_each_lane($fx, $x, $y, $ret, &|fx, lane_ty, _ret_lane_ty, x_lane, y_lane| {\n-        match lane_ty.kind() {\n-            ty::Float(_) => fx.bcx.ins().$op(x_lane, y_lane),\n-            _ => unreachable!(\"{:?}\", lane_ty),\n-        }\n-    });\n-}\n-\n pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     intrinsic: Symbol,\n@@ -142,6 +94,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                     (ty::Float(_), sym::simd_ge) => {\n                         fx.bcx.ins().fcmp(FloatCC::GreaterThanOrEqual, x_lane, y_lane)\n                     }\n+\n                     _ => unreachable!(),\n                 };\n \n@@ -327,17 +280,34 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             });\n         };\n \n-        simd_add, (c x, c y) {\n-            simd_int_flt_binop!(fx, intrinsic, span, iadd|iadd|fadd(x, y) -> ret);\n-        };\n-        simd_sub, (c x, c y) {\n-            simd_int_flt_binop!(fx, intrinsic, span, isub|isub|fsub(x, y) -> ret);\n-        };\n-        simd_mul, (c x, c y) {\n-            simd_int_flt_binop!(fx, intrinsic, span, imul|imul|fmul(x, y) -> ret);\n-        };\n-        simd_div, (c x, c y) {\n-            simd_int_flt_binop!(fx, intrinsic, span, udiv|sdiv|fdiv(x, y) -> ret);\n+        simd_add | simd_sub | simd_mul | simd_div, (c x, c y) {\n+            if !x.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, x.layout().ty);\n+                return;\n+            }\n+\n+            // FIXME use vector instructions when possible\n+            simd_pair_for_each_lane(fx, x, y, ret, &|fx, lane_ty, _ret_lane_ty, x_lane, y_lane| match (\n+                lane_ty.kind(),\n+                intrinsic,\n+            ) {\n+                (ty::Uint(_), sym::simd_add) => fx.bcx.ins().iadd(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_sub) => fx.bcx.ins().isub(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_mul) => fx.bcx.ins().imul(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_div) => fx.bcx.ins().udiv(x_lane, y_lane),\n+\n+                (ty::Int(_), sym::simd_add) => fx.bcx.ins().iadd(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_sub) => fx.bcx.ins().isub(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_mul) => fx.bcx.ins().imul(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_div) => fx.bcx.ins().sdiv(x_lane, y_lane),\n+\n+                (ty::Float(_), sym::simd_add) => fx.bcx.ins().fadd(x_lane, y_lane),\n+                (ty::Float(_), sym::simd_sub) => fx.bcx.ins().fsub(x_lane, y_lane),\n+                (ty::Float(_), sym::simd_mul) => fx.bcx.ins().fmul(x_lane, y_lane),\n+                (ty::Float(_), sym::simd_div) => fx.bcx.ins().fdiv(x_lane, y_lane),\n+\n+                _ => unreachable!(),\n+            });\n         };\n         simd_rem, (c x, c y) {\n             if !x.layout().ty.is_simd() {\n@@ -365,20 +335,31 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 }\n             });\n         };\n-        simd_shl, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, span, ishl|ishl(x, y) -> ret);\n-        };\n-        simd_shr, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, span, ushr|sshr(x, y) -> ret);\n-        };\n-        simd_and, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, span, band|band(x, y) -> ret);\n-        };\n-        simd_or, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, span, bor|bor(x, y) -> ret);\n-        };\n-        simd_xor, (c x, c y) {\n-            simd_int_binop!(fx, intrinsic, span, bxor|bxor(x, y) -> ret);\n+        simd_shl | simd_shr | simd_and | simd_or | simd_xor, (c x, c y) {\n+            if !x.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, x.layout().ty);\n+                return;\n+            }\n+\n+            // FIXME use vector instructions when possible\n+            simd_pair_for_each_lane(fx, x, y, ret, &|fx, lane_ty, _ret_lane_ty, x_lane, y_lane| match (\n+                lane_ty.kind(),\n+                intrinsic,\n+            ) {\n+                (ty::Uint(_), sym::simd_shl) => fx.bcx.ins().ishl(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_shr) => fx.bcx.ins().ushr(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_and) => fx.bcx.ins().band(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_or) => fx.bcx.ins().bor(x_lane, y_lane),\n+                (ty::Uint(_), sym::simd_xor) => fx.bcx.ins().bxor(x_lane, y_lane),\n+\n+                (ty::Int(_), sym::simd_shl) => fx.bcx.ins().ishl(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_shr) => fx.bcx.ins().sshr(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_and) => fx.bcx.ins().band(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_or) => fx.bcx.ins().bor(x_lane, y_lane),\n+                (ty::Int(_), sym::simd_xor) => fx.bcx.ins().bxor(x_lane, y_lane),\n+\n+                _ => unreachable!(),\n+            });\n         };\n \n         simd_fma, (c a, c b, c c) {\n@@ -407,11 +388,24 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             }\n         };\n \n-        simd_fmin, (c x, c y) {\n-            simd_flt_binop!(fx, intrinsic, span, fmin(x, y) -> ret);\n-        };\n-        simd_fmax, (c x, c y) {\n-            simd_flt_binop!(fx, intrinsic, span, fmax(x, y) -> ret);\n+        simd_fmin | simd_fmax, (c x, c y) {\n+            if !x.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, x.layout().ty);\n+                return;\n+            }\n+\n+            // FIXME use vector instructions when possible\n+            simd_pair_for_each_lane(fx, x, y, ret, &|fx, lane_ty, _ret_lane_ty, x_lane, y_lane| {\n+                match lane_ty.kind() {\n+                    ty::Float(_) => {},\n+                    _ => unreachable!(\"{:?}\", lane_ty),\n+                }\n+                match intrinsic {\n+                    sym::simd_fmin => fx.bcx.ins().fmin(x_lane, y_lane),\n+                    sym::simd_fmax => fx.bcx.ins().fmax(x_lane, y_lane),\n+                    _ => unreachable!(),\n+                }\n+            });\n         };\n \n         simd_round, (c a) {"}]}