{"sha": "c2b3aa99390213cc41f4a7a001963fa49e1ee509", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYjNhYTk5MzkwMjEzY2M0MWY0YTdhMDAxOTYzZmE0OWUxZWU1MDk=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-02T16:05:06Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-06T08:24:52Z"}, "message": "rustc/middle: improve some patterns", "tree": {"sha": "ff742baaafce78f545629490e72b2d6739c74f04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff742baaafce78f545629490e72b2d6739c74f04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2b3aa99390213cc41f4a7a001963fa49e1ee509", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2b3aa99390213cc41f4a7a001963fa49e1ee509", "html_url": "https://github.com/rust-lang/rust/commit/c2b3aa99390213cc41f4a7a001963fa49e1ee509", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2b3aa99390213cc41f4a7a001963fa49e1ee509/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac841e74502183cde08e462d98cc55752abd000a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac841e74502183cde08e462d98cc55752abd000a", "html_url": "https://github.com/rust-lang/rust/commit/ac841e74502183cde08e462d98cc55752abd000a"}], "stats": {"total": 151, "additions": 56, "deletions": 95}, "files": [{"sha": "575d32dd401f1e5af17f9784f3add70d69751443", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=c2b3aa99390213cc41f4a7a001963fa49e1ee509", "patch": "@@ -131,12 +131,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn mark_live_symbols(&mut self) {\n         let mut scanned = FxHashSet();\n-        while !self.worklist.is_empty() {\n-            let id = self.worklist.pop().unwrap();\n-            if scanned.contains(&id) {\n+        while let Some(id) = self.worklist.pop() {\n+            if !scanned.insert(id) {\n                 continue\n             }\n-            scanned.insert(id);\n \n             if let Some(ref node) = self.tcx.hir.find(id) {\n                 self.live_symbols.insert(id);"}, {"sha": "12b304298c155eca21397dd0e243c61d95948ef3", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=c2b3aa99390213cc41f4a7a001963fa49e1ee509", "patch": "@@ -253,7 +253,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    return ret;\n+    ret\n }\n \n fn add_library(tcx: TyCtxt<'_, '_, '_>,"}, {"sha": "44572a1977ab4dd40580c44c3c4aa2e781d6daba", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=c2b3aa99390213cc41f4a7a001963fa49e1ee509", "patch": "@@ -35,12 +35,8 @@ impl_stable_hash_for!(enum self::SymbolExportLevel {\n \n impl SymbolExportLevel {\n     pub fn is_below_threshold(self, threshold: SymbolExportLevel) -> bool {\n-        if threshold == SymbolExportLevel::Rust {\n-            // We export everything from Rust dylibs\n-            true\n-        } else {\n-            self == SymbolExportLevel::C\n-        }\n+        threshold == SymbolExportLevel::Rust // export everything from Rust dylibs\n+          || self == SymbolExportLevel::C\n     }\n }\n "}, {"sha": "e18a1d8258567aab44ef932c0272558663de5049", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c2b3aa99390213cc41f4a7a001963fa49e1ee509", "patch": "@@ -801,10 +801,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             self.walk_pat(discr_cmt.clone(), &pat, mode);\n         }\n \n-        if let Some(ref guard) = arm.guard {\n-            match guard {\n-                hir::Guard::If(ref e) => self.consume_expr(e),\n-            }\n+        if let Some(hir::Guard::If(ref e)) = arm.guard {\n+            self.consume_expr(e)\n         }\n \n         self.consume_expr(&arm.body);"}, {"sha": "d53d5fdb97d426cfc083b20744475d938cdeb851", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=c2b3aa99390213cc41f4a7a001963fa49e1ee509", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n                 }\n                 Err(LayoutError::Unknown(bad)) => {\n                     if bad == ty {\n-                        \"this type's size can vary\".to_string()\n+                        \"this type's size can vary\".to_owned()\n                     } else {\n                         format!(\"size can vary because of {}\", bad)\n                     }"}, {"sha": "ccfac3140929fc8f0d6f4dc0d5f399902c296f7c", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c2b3aa99390213cc41f4a7a001963fa49e1ee509", "patch": "@@ -145,8 +145,8 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n \n     fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n         // Check for duplicates.\n-        match self.items.items[item_index] {\n-            Some(original_def_id) if original_def_id != item_def_id => {\n+        if let Some(original_def_id) = self.items.items[item_index] {\n+            if original_def_id != item_def_id {\n                 let name = LangItem::from_u32(item_index as u32).unwrap().name();\n                 let mut err = match self.tcx.hir.span_if_local(item_def_id) {\n                     Some(span) => struct_span_err!(\n@@ -169,9 +169,6 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n                 }\n                 err.emit();\n             }\n-            _ => {\n-                // OK.\n-            }\n         }\n \n         // Matched.\n@@ -194,7 +191,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n         }\n     }\n \n-    return None;\n+    None\n }\n \n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItems {"}, {"sha": "56f67328458d380a9fa93d8db52f80fb395875bd", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=c2b3aa99390213cc41f4a7a001963fa49e1ee509", "patch": "@@ -170,7 +170,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_, '_, '_>) -> Strin\n         VarDefNode(s) => {\n             format!(\"Var def node [{}]\", cm.span_to_string(s))\n         }\n-        ExitNode => \"Exit node\".to_string(),\n+        ExitNode => \"Exit node\".to_owned(),\n     }\n }\n \n@@ -330,7 +330,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             Local(LocalInfo { name, .. }) | Arg(_, name) => {\n                 name.to_string()\n             },\n-            CleanExit => \"<clean-exit>\".to_string()\n+            CleanExit => \"<clean-exit>\".to_owned()\n         }\n     }\n \n@@ -1049,12 +1049,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n               // the construction of a closure itself is not important,\n               // but we have to consider the closed over variables.\n-              let caps = match self.ir.capture_info_map.get(&expr.id) {\n-                  Some(caps) => caps.clone(),\n-                  None => {\n-                      span_bug!(expr.span, \"no registered caps\");\n-                  }\n-              };\n+                let caps = self.ir.capture_info_map.get(&expr.id).cloned().unwrap_or_else(||\n+                    span_bug!(expr.span, \"no registered caps\"));\n+\n               caps.iter().rev().fold(succ, |succ, cap| {\n                   self.init_from_succ(cap.ln, succ);\n                   let var = self.variable(cap.var_hid, expr.span);\n@@ -1114,15 +1111,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n             for arm in arms {\n-                let body_succ =\n-                    self.propagate_through_expr(&arm.body, succ);\n-                let guard_succ =\n-                    self.propagate_through_opt_expr(\n-                        arm.guard.as_ref().map(|g|\n-                            match g {\n-                                hir::Guard::If(e) => &**e,\n-                            }),\n-                        body_succ);\n+                    let body_succ = self.propagate_through_expr(&arm.body, succ);\n+\n+                    let guard_succ = self.propagate_through_opt_expr(\n+                        arm.guard.as_ref().map(|hir::Guard::If(e)| &**e),\n+                        body_succ\n+                    );\n                 // only consider the first pattern; any later patterns must have\n                 // the same bindings, and we also consider the first pattern to be\n                 // the \"authoritative\" set of ids\n@@ -1146,10 +1140,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               let target = match label.target_id {\n                     Ok(node_id) => self.break_ln.get(&node_id),\n                     Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n-              }.map(|x| *x);\n-\n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n+                }.cloned();\n \n               match target {\n                   Some(b) => self.propagate_through_opt_expr(opt_expr.as_ref().map(|e| &**e), b),\n@@ -1159,18 +1152,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprKind::Continue(label) => {\n               // Find which label this expr continues to\n-              let sc = match label.target_id {\n-                    Ok(node_id) => node_id,\n-                    Err(err) => span_bug!(expr.span, \"loop scope error: {}\", err),\n-              };\n+                let sc = label.target_id.unwrap_or_else(|err|\n+                    span_bug!(expr.span, \"loop scope error: {}\", err));\n \n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n-\n-              match self.cont_ln.get(&sc) {\n-                  Some(&b) => b,\n-                  None => span_bug!(expr.span, \"continue to unknown label\")\n-              }\n+                self.cont_ln.get(&sc).cloned().unwrap_or_else(||\n+                    span_bug!(expr.span, \"continue to unknown label\"))\n           }\n \n           hir::ExprKind::Assign(ref l, ref r) => {\n@@ -1450,8 +1438,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.propagate_through_expr(&cond, ln)\n                 }\n             };\n-            assert!(cond_ln == new_cond_ln);\n-            assert!(body_ln == self.propagate_through_block(body, cond_ln));\n+            assert_eq!(cond_ln, new_cond_ln);\n+            assert_eq!(body_ln, self.propagate_through_block(body, cond_ln));\n         }\n \n         cond_ln\n@@ -1576,7 +1564,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn should_warn(&self, var: Variable) -> Option<String> {\n         let name = self.ir.variable_name(var);\n-        if name.is_empty() || name.as_bytes()[0] == ('_' as u8) {\n+        if name.is_empty() || name.as_bytes()[0] == b'_' {\n             None\n         } else {\n             Some(name)"}, {"sha": "3e07902aad30f779a3c027c10bc81e75c74b1d11", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=c2b3aa99390213cc41f4a7a001963fa49e1ee509", "patch": "@@ -515,10 +515,8 @@ impl<'tcx> ScopeTree {\n \n     /// Returns the lifetime of the local variable `var_id`\n     pub fn var_scope(&self, var_id: hir::ItemLocalId) -> Scope {\n-        match self.var_map.get(&var_id) {\n-            Some(&r) => r,\n-            None => { bug!(\"no enclosing scope for id {:?}\", var_id); }\n-        }\n+        self.var_map.get(&var_id).cloned().unwrap_or_else(||\n+            bug!(\"no enclosing scope for id {:?}\", var_id))\n     }\n \n     pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<Scope> {\n@@ -828,10 +826,8 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n \n-    if let Some(ref g) = arm.guard {\n-        match g {\n-            hir::Guard::If(ref expr) => visitor.terminating_scopes.insert(expr.hir_id.local_id),\n-        };\n+    if let Some(hir::Guard::If(ref expr)) = arm.guard {\n+        visitor.terminating_scopes.insert(expr.hir_id.local_id);\n     }\n \n     intravisit::walk_arm(visitor, arm);"}, {"sha": "5bfae5a8c33c5efdd2cd91e5f6bddd924c268b3d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=c2b3aa99390213cc41f4a7a001963fa49e1ee509", "patch": "@@ -1872,18 +1872,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 node: hir::TraitItemKind::Method(_, ref m),\n                 ..\n             }) => {\n-                match self.tcx\n+                if let hir::ItemKind::Trait(.., ref trait_items) = self.tcx\n                     .hir\n                     .expect_item(self.tcx.hir.get_parent(parent))\n                     .node\n                 {\n-                    hir::ItemKind::Trait(.., ref trait_items) => {\n-                        assoc_item_kind = trait_items\n-                            .iter()\n-                            .find(|ti| ti.id.node_id == parent)\n-                            .map(|ti| ti.kind);\n-                    }\n-                    _ => {}\n+                    assoc_item_kind = trait_items\n+                        .iter()\n+                        .find(|ti| ti.id.node_id == parent)\n+                        .map(|ti| ti.kind);\n                 }\n                 match *m {\n                     hir::TraitMethod::Required(_) => None,\n@@ -1895,19 +1892,16 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 node: hir::ImplItemKind::Method(_, body),\n                 ..\n             }) => {\n-                match self.tcx\n+                if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) = self.tcx\n                     .hir\n                     .expect_item(self.tcx.hir.get_parent(parent))\n                     .node\n                 {\n-                    hir::ItemKind::Impl(.., ref self_ty, ref impl_items) => {\n-                        impl_self = Some(self_ty);\n-                        assoc_item_kind = impl_items\n-                            .iter()\n-                            .find(|ii| ii.id.node_id == parent)\n-                            .map(|ii| ii.kind);\n-                    }\n-                    _ => {}\n+                    impl_self = Some(self_ty);\n+                    assoc_item_kind = impl_items\n+                        .iter()\n+                        .find(|ii| ii.id.node_id == parent)\n+                        .map(|ii| ii.kind);\n                 }\n                 Some(body)\n             }\n@@ -2541,15 +2535,12 @@ fn insert_late_bound_lifetimes(\n     appears_in_where_clause.visit_generics(generics);\n \n     for param in &generics.params {\n-        match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => {\n-                if !param.bounds.is_empty() {\n-                    // `'a: 'b` means both `'a` and `'b` are referenced\n-                    appears_in_where_clause\n-                        .regions.insert(hir::LifetimeName::Param(param.name.modern()));\n-                }\n+        if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n+            if !param.bounds.is_empty() {\n+                // `'a: 'b` means both `'a` and `'b` are referenced\n+                appears_in_where_clause\n+                    .regions.insert(hir::LifetimeName::Param(param.name.modern()));\n             }\n-            hir::GenericParamKind::Type { .. } => {}\n         }\n     }\n "}, {"sha": "0e4989937cd3e6ea1decfcb9a9799752fe548c66", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2b3aa99390213cc41f4a7a001963fa49e1ee509/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=c2b3aa99390213cc41f4a7a001963fa49e1ee509", "patch": "@@ -523,15 +523,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             Some(Def::Method(_)) |\n             Some(Def::AssociatedTy(_)) |\n             Some(Def::AssociatedConst(_)) => {\n-                match self.associated_item(def_id).container {\n-                    ty::TraitContainer(trait_def_id) => {\n-                        // Trait methods do not declare visibility (even\n-                        // for visibility info in cstore). Use containing\n-                        // trait instead, so methods of pub traits are\n-                        // themselves considered pub.\n-                        def_id = trait_def_id;\n-                    }\n-                    _ => {}\n+                if let ty::TraitContainer(trait_def_id) = self.associated_item(def_id).container {\n+                    // Trait methods do not declare visibility (even\n+                    // for visibility info in cstore). Use containing\n+                    // trait instead, so methods of pub traits are\n+                    // themselves considered pub.\n+                    def_id = trait_def_id;\n                 }\n             }\n             _ => {}"}]}