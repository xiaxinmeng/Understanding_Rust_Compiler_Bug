{"sha": "4eff8526a789e0dfa8b97f7dec91b7b5c18e8544", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZmY4NTI2YTc4OWUwZGZhOGI5N2Y3ZGVjOTFiN2I1YzE4ZTg1NDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-23T15:54:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-23T15:54:23Z"}, "message": "Auto merge of #60155 - davidtwco:issue-59819, r=oli-obk\n\nSuggest dereferencing when `Deref` is implemented.\n\nFixes #59819.\n\nr? @oli-obk\ncc @estebank", "tree": {"sha": "eb5d9e478b45c8420ac27f059a634f4fff17ef1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb5d9e478b45c8420ac27f059a634f4fff17ef1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544", "html_url": "https://github.com/rust-lang/rust/commit/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe0a415b4ba3310c2263f07e0253e2434310299c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe0a415b4ba3310c2263f07e0253e2434310299c", "html_url": "https://github.com/rust-lang/rust/commit/fe0a415b4ba3310c2263f07e0253e2434310299c"}, {"sha": "7ab1bfd692c2679278c5dc978b04dfb16dfae470", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ab1bfd692c2679278c5dc978b04dfb16dfae470", "html_url": "https://github.com/rust-lang/rust/commit/7ab1bfd692c2679278c5dc978b04dfb16dfae470"}], "stats": {"total": 230, "additions": 175, "deletions": 55}, "files": [{"sha": "6ce03025bf23cd769d556cc4cc77b89ebad8a3ec", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 66, "deletions": 55, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=4eff8526a789e0dfa8b97f7dec91b7b5c18e8544", "patch": "@@ -1,6 +1,6 @@\n use crate::check::FnCtxt;\n use rustc::infer::InferOk;\n-use rustc::traits::{ObligationCause, ObligationCauseCode};\n+use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n \n use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::Span;\n@@ -324,8 +324,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             sp,\n         );\n \n-        match (&expected.sty, &checked_ty.sty) {\n-            (&ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.sty, &check.sty) {\n+        // Check the `expn_info()` to see if this is a macro; if so, it's hard to\n+        // extract the text and make a good suggestion, so don't bother.\n+        let is_macro = sp.ctxt().outer().expn_info().is_some();\n+\n+        match (&expr.node, &expected.sty, &checked_ty.sty) {\n+            (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.sty, &check.sty) {\n                 (&ty::Str, &ty::Array(arr, _)) |\n                 (&ty::Str, &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.node {\n@@ -352,7 +356,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 _ => {}\n             },\n-            (&ty::Ref(_, _, mutability), _) => {\n+            (_, &ty::Ref(_, _, mutability), _) => {\n                 // Check if it can work when put into a ref. For example:\n                 //\n                 // ```\n@@ -407,60 +411,67 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         });\n                     }\n                 }\n-            }\n-            (_, &ty::Ref(_, checked, _)) => {\n+            },\n+            (hir::ExprKind::AddrOf(_, ref expr), _, &ty::Ref(_, checked, _)) if {\n+                self.infcx.can_sub(self.param_env, checked, &expected).is_ok() && !is_macro\n+            } => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n-                // we may want to suggest adding a `*`, or removing\n-                // a `&`.\n-                //\n-                // (But, also check the `expn_info()` to see if this is\n-                // a macro; if so, it's hard to extract the text and make a good\n-                // suggestion, so don't bother.)\n-                if self.infcx.can_sub(self.param_env, checked, &expected).is_ok() &&\n-                   sp.ctxt().outer().expn_info().is_none() {\n-                    match expr.node {\n-                        // Maybe remove `&`?\n-                        hir::ExprKind::AddrOf(_, ref expr) => {\n-                            if !cm.span_to_filename(expr.span).is_real() {\n-                                if let Ok(code) = cm.span_to_snippet(sp) {\n-                                    if code.chars().next() == Some('&') {\n-                                        return Some((\n-                                            sp,\n-                                            \"consider removing the borrow\",\n-                                            code[1..].to_string()),\n-                                        );\n-                                    }\n-                                }\n-                                return None;\n-                            }\n-                            if let Ok(code) = cm.span_to_snippet(expr.span) {\n-                                return Some((sp, \"consider removing the borrow\", code));\n-                            }\n-                        }\n-\n-                        // Maybe add `*`? Only if `T: Copy`.\n-                        _ => {\n-                            if self.infcx.type_is_copy_modulo_regions(self.param_env,\n-                                                                      checked,\n-                                                                      sp) {\n-                                // do not suggest if the span comes from a macro (#52783)\n-                                if let (Ok(code), true) = (\n-                                    cm.span_to_snippet(sp),\n-                                    sp == expr.span,\n-                                ) {\n-                                    return Some((\n-                                        sp,\n-                                        \"consider dereferencing the borrow\",\n-                                        if is_struct_pat_shorthand_field {\n-                                            format!(\"{}: *{}\", code, code)\n-                                        } else {\n-                                            format!(\"*{}\", code)\n-                                        },\n-                                    ));\n-                                }\n-                            }\n+                // we may want to suggest removing a `&`.\n+                if !cm.span_to_filename(expr.span).is_real() {\n+                    if let Ok(code) = cm.span_to_snippet(sp) {\n+                        if code.chars().next() == Some('&') {\n+                            return Some((\n+                                sp,\n+                                \"consider removing the borrow\",\n+                                code[1..].to_string(),\n+                            ));\n                         }\n                     }\n+                    return None;\n+                }\n+                if let Ok(code) = cm.span_to_snippet(expr.span) {\n+                    return Some((sp, \"consider removing the borrow\", code));\n+                }\n+            },\n+            _ if sp == expr.span && !is_macro => {\n+                // Check for `Deref` implementations by constructing a predicate to\n+                // prove: `<T as Deref>::Output == U`\n+                let deref_trait = self.tcx.lang_items().deref_trait().unwrap();\n+                let item_def_id = self.tcx.associated_items(deref_trait).next().unwrap().def_id;\n+                let predicate = ty::Predicate::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n+                    // `<T as Deref>::Output`\n+                    projection_ty: ty::ProjectionTy {\n+                        // `T`\n+                        substs: self.tcx.mk_substs_trait(\n+                            checked_ty,\n+                            self.fresh_substs_for_item(sp, item_def_id),\n+                        ),\n+                        // `Deref::Output`\n+                        item_def_id,\n+                    },\n+                    // `U`\n+                    ty: expected,\n+                }));\n+                let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n+                let impls_deref = self.infcx.predicate_may_hold(&obligation);\n+\n+                // For a suggestion to make sense, the type would need to be `Copy`.\n+                let is_copy = self.infcx.type_is_copy_modulo_regions(self.param_env, expected, sp);\n+\n+                if is_copy && impls_deref {\n+                    if let Ok(code) = cm.span_to_snippet(sp) {\n+                        let message = if checked_ty.is_region_ptr() {\n+                            \"consider dereferencing the borrow\"\n+                        } else {\n+                            \"consider dereferencing the type\"\n+                        };\n+                        let suggestion = if is_struct_pat_shorthand_field {\n+                            format!(\"{}: *{}\", code, code)\n+                        } else {\n+                            format!(\"*{}\", code)\n+                        };\n+                        return Some((sp, message, suggestion));\n+                    }\n                 }\n             }\n             _ => {}"}, {"sha": "644d2a4e41bafb29a284d598102b805d410b9141", "filename": "src/test/ui/suggestions/issue-59819.fixed", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.fixed?ref=4eff8526a789e0dfa8b97f7dec91b7b5c18e8544", "patch": "@@ -0,0 +1,35 @@\n+// run-rustfix\n+\n+#![allow(warnings)]\n+\n+// Test that suggestion to add `*` characters applies to implementations of `Deref` as well as\n+// references.\n+\n+struct Foo(i32);\n+\n+struct Bar(String);\n+\n+impl std::ops::Deref for Foo {\n+    type Target = i32;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl std::ops::Deref for Bar {\n+    type Target = String;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo(42);\n+    let y: i32 = *x; //~ ERROR mismatched types\n+    let a = &42;\n+    let b: i32 = *a; //~ ERROR mismatched types\n+\n+    // Do not make a suggestion when adding a `*` wouldn't actually fix the issue:\n+    let f = Bar(\"bar\".to_string());\n+    let g: String = f.to_string(); //~ ERROR mismatched types\n+}"}, {"sha": "8e8ff8372e808362eba24ba39e4b5ab938936da5", "filename": "src/test/ui/suggestions/issue-59819.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.rs?ref=4eff8526a789e0dfa8b97f7dec91b7b5c18e8544", "patch": "@@ -0,0 +1,35 @@\n+// run-rustfix\n+\n+#![allow(warnings)]\n+\n+// Test that suggestion to add `*` characters applies to implementations of `Deref` as well as\n+// references.\n+\n+struct Foo(i32);\n+\n+struct Bar(String);\n+\n+impl std::ops::Deref for Foo {\n+    type Target = i32;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl std::ops::Deref for Bar {\n+    type Target = String;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo(42);\n+    let y: i32 = x; //~ ERROR mismatched types\n+    let a = &42;\n+    let b: i32 = a; //~ ERROR mismatched types\n+\n+    // Do not make a suggestion when adding a `*` wouldn't actually fix the issue:\n+    let f = Bar(\"bar\".to_string());\n+    let g: String = f; //~ ERROR mismatched types\n+}"}, {"sha": "66898115cbd6de1d308f35693be17dd95471f5c4", "filename": "src/test/ui/suggestions/issue-59819.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-59819.stderr?ref=4eff8526a789e0dfa8b97f7dec91b7b5c18e8544", "patch": "@@ -0,0 +1,39 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-59819.rs:28:18\n+   |\n+LL |     let y: i32 = x;\n+   |                  ^\n+   |                  |\n+   |                  expected i32, found struct `Foo`\n+   |                  help: consider dereferencing the type: `*x`\n+   |\n+   = note: expected type `i32`\n+              found type `Foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-59819.rs:30:18\n+   |\n+LL |     let b: i32 = a;\n+   |                  ^\n+   |                  |\n+   |                  expected i32, found &{integer}\n+   |                  help: consider dereferencing the borrow: `*a`\n+   |\n+   = note: expected type `i32`\n+              found type `&{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-59819.rs:34:21\n+   |\n+LL |     let g: String = f;\n+   |                     ^\n+   |                     |\n+   |                     expected struct `std::string::String`, found struct `Bar`\n+   |                     help: try using a conversion method: `f.to_string()`\n+   |\n+   = note: expected type `std::string::String`\n+              found type `Bar`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}