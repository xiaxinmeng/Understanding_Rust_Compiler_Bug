{"sha": "afc68277f69572944fd81d61b126732ab29b5d17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYzY4Mjc3ZjY5NTcyOTQ0ZmQ4MWQ2MWIxMjY3MzJhYjI5YjVkMTc=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-16T20:48:15Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-03-02T13:25:22Z"}, "message": "pull out suggest_name::* to utils; enchance heuristics", "tree": {"sha": "2ce079a2d48f83cd9520a48c3d6d1082626008fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ce079a2d48f83cd9520a48c3d6d1082626008fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afc68277f69572944fd81d61b126732ab29b5d17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afc68277f69572944fd81d61b126732ab29b5d17", "html_url": "https://github.com/rust-lang/rust/commit/afc68277f69572944fd81d61b126732ab29b5d17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afc68277f69572944fd81d61b126732ab29b5d17/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f915ab79fa1b11982b8e82e2db5b2486a893bed4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f915ab79fa1b11982b8e82e2db5b2486a893bed4", "html_url": "https://github.com/rust-lang/rust/commit/f915ab79fa1b11982b8e82e2db5b2486a893bed4"}], "stats": {"total": 910, "additions": 821, "deletions": 89}, "files": [{"sha": "312ac7ac4268064ebb4b255940b3419f26d3656b", "filename": "crates/ide_assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 4, "deletions": 88, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/afc68277f69572944fd81d61b126732ab29b5d17/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc68277f69572944fd81d61b126732ab29b5d17/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=afc68277f69572944fd81d61b126732ab29b5d17", "patch": "@@ -1,15 +1,14 @@\n-use itertools::Itertools;\n-use stdx::{format_to, to_lower_snake_case};\n+use stdx::format_to;\n use syntax::{\n-    ast::{self, AstNode, NameOwner},\n+    ast::{self, AstNode},\n     SyntaxKind::{\n         BLOCK_EXPR, BREAK_EXPR, CLOSURE_EXPR, COMMENT, LOOP_EXPR, MATCH_ARM, PATH_EXPR, RETURN_EXPR,\n     },\n     SyntaxNode,\n };\n use test_utils::mark;\n \n-use crate::{AssistContext, AssistId, AssistKind, Assists};\n+use crate::{utils::suggest_name, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: extract_variable\n //\n@@ -55,7 +54,7 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext) -> Option\n \n             let var_name = match &field_shorthand {\n                 Some(it) => it.to_string(),\n-                None => suggest_variable_name(ctx, &to_extract),\n+                None => suggest_name::variable(&to_extract, &ctx.sema),\n             };\n             let expr_range = match &field_shorthand {\n                 Some(it) => it.syntax().text_range().cover(to_extract.syntax().text_range()),\n@@ -174,89 +173,6 @@ impl Anchor {\n     }\n }\n \n-fn suggest_variable_name(ctx: &AssistContext, expr: &ast::Expr) -> String {\n-    // FIXME: account for existing names in the scope\n-    suggest_name_from_param(ctx, expr)\n-        .or_else(|| suggest_name_from_func(expr))\n-        .or_else(|| suggest_name_from_method(expr))\n-        .or_else(|| suggest_name_by_type(ctx, expr))\n-        .unwrap_or_else(|| \"var_name\".to_string())\n-}\n-\n-fn normalize_name(name: &str) -> Option<String> {\n-    let name = to_lower_snake_case(name);\n-\n-    let useless_names = [\"new\", \"default\", \"some\", \"none\", \"ok\", \"err\"];\n-    if useless_names.contains(&name.as_str()) {\n-        return None;\n-    }\n-\n-    Some(name)\n-}\n-\n-fn suggest_name_from_func(expr: &ast::Expr) -> Option<String> {\n-    let call = match expr {\n-        ast::Expr::CallExpr(call) => call,\n-        _ => return None,\n-    };\n-    let func = match call.expr()? {\n-        ast::Expr::PathExpr(path) => path,\n-        _ => return None,\n-    };\n-    let ident = func.path()?.segment()?.name_ref()?.ident_token()?;\n-    normalize_name(ident.text())\n-}\n-\n-fn suggest_name_from_method(expr: &ast::Expr) -> Option<String> {\n-    let method = match expr {\n-        ast::Expr::MethodCallExpr(call) => call,\n-        _ => return None,\n-    };\n-    let ident = method.name_ref()?.ident_token()?;\n-    normalize_name(ident.text())\n-}\n-\n-fn suggest_name_from_param(ctx: &AssistContext, expr: &ast::Expr) -> Option<String> {\n-    let arg_list = expr.syntax().parent().and_then(ast::ArgList::cast)?;\n-    let args_parent = arg_list.syntax().parent()?;\n-    let func = if let Some(call) = ast::CallExpr::cast(args_parent.clone()) {\n-        let func = call.expr()?;\n-        let func_ty = ctx.sema.type_of_expr(&func)?;\n-        func_ty.as_callable(ctx.db())?\n-    } else if let Some(method) = ast::MethodCallExpr::cast(args_parent) {\n-        ctx.sema.resolve_method_call_as_callable(&method)?\n-    } else {\n-        return None;\n-    };\n-\n-    let (idx, _) = arg_list.args().find_position(|it| it == expr).unwrap();\n-    let (pat, _) = func.params(ctx.db()).into_iter().nth(idx)?;\n-    let param = match pat? {\n-        either::Either::Right(ast::Pat::IdentPat(param)) => param,\n-        _ => return None,\n-    };\n-    let name = param.name()?;\n-    normalize_name(&name.to_string())\n-}\n-\n-fn suggest_name_by_type(ctx: &AssistContext, expr: &ast::Expr) -> Option<String> {\n-    let ty = ctx.sema.type_of_expr(expr)?;\n-    let ty = ty.remove_ref().unwrap_or(ty);\n-\n-    name_from_type(ty, ctx)\n-}\n-\n-fn name_from_type(ty: hir::Type, ctx: &AssistContext) -> Option<String> {\n-    let name = if let Some(adt) = ty.as_adt() {\n-        adt.name(ctx.db()).to_string()\n-    } else if let Some(trait_) = ty.as_dyn_trait() {\n-        trait_.name(ctx.db()).to_string()\n-    } else {\n-        return None;\n-    };\n-    normalize_name(&name)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use test_utils::mark;"}, {"sha": "66820058b6a54f70aa4ec7756cad39b72229951f", "filename": "crates/ide_assists/src/tests.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/afc68277f69572944fd81d61b126732ab29b5d17/crates%2Fide_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc68277f69572944fd81d61b126732ab29b5d17/crates%2Fide_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests.rs?ref=afc68277f69572944fd81d61b126732ab29b5d17", "patch": "@@ -12,7 +12,7 @@ use ide_db::{\n     RootDatabase,\n };\n use stdx::{format_to, trim_indent};\n-use syntax::TextRange;\n+use syntax::{ast, AstNode, TextRange};\n use test_utils::{assert_eq_text, extract_offset};\n \n use crate::{handlers::Handler, Assist, AssistConfig, AssistContext, AssistKind, Assists};\n@@ -180,6 +180,50 @@ fn labels(assists: &[Assist]) -> String {\n     labels.into_iter().collect::<String>()\n }\n \n+pub(crate) type NameSuggestion = fn(&ast::Expr, &Semantics<'_, RootDatabase>) -> Option<String>;\n+\n+#[track_caller]\n+pub(crate) fn check_name_suggestion(\n+    suggestion: NameSuggestion,\n+    ra_fixture: &str,\n+    suggested_name: &str,\n+) {\n+    check_name(suggestion, ra_fixture, Some(suggested_name));\n+}\n+\n+#[track_caller]\n+pub(crate) fn check_name_suggestion_not_applicable(suggestion: NameSuggestion, ra_fixture: &str) {\n+    check_name(suggestion, ra_fixture, None);\n+}\n+\n+#[track_caller]\n+fn check_name(suggestion: NameSuggestion, ra_fixture: &str, expected: Option<&str>) {\n+    let (db, file_with_carret_id, range_or_offset) = RootDatabase::with_range_or_offset(ra_fixture);\n+    let frange = FileRange { file_id: file_with_carret_id, range: range_or_offset.into() };\n+\n+    let sema = Semantics::new(&db);\n+    let source_file = sema.parse(frange.file_id);\n+    let element = source_file.syntax().covering_element(frange.range);\n+    let expr =\n+        element.ancestors().find_map(ast::Expr::cast).expect(\"selection is not an expression\");\n+    assert_eq!(\n+        expr.syntax().text_range(),\n+        frange.range,\n+        \"selection is not an expression(yet contained in one)\"\n+    );\n+\n+    let name = suggestion(&expr, &sema);\n+\n+    match (name, expected) {\n+        (Some(name), Some(expected_name)) => {\n+            assert_eq_text!(&name, expected_name);\n+        }\n+        (Some(_), None) => panic!(\"name suggestion should not be applicable\"),\n+        (None, Some(_)) => panic!(\"name suggestion is not applicable\"),\n+        (None, None) => (),\n+    }\n+}\n+\n #[test]\n fn assist_order_field_struct() {\n     let before = \"struct Foo { $0bar: u32 }\";"}, {"sha": "62f959082ecf238ff1203643ccf4161931fcbcae", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afc68277f69572944fd81d61b126732ab29b5d17/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc68277f69572944fd81d61b126732ab29b5d17/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=afc68277f69572944fd81d61b126732ab29b5d17", "patch": "@@ -1,5 +1,7 @@\n //! Assorted functions shared by several assists.\n \n+pub(crate) mod suggest_name;\n+\n use std::ops;\n \n use ast::TypeBoundsOwner;"}, {"sha": "345e9af4014d3d1fe1022889d2b45fb4dbe7f079", "filename": "crates/ide_assists/src/utils/suggest_name.rs", "status": "added", "additions": 770, "deletions": 0, "changes": 770, "blob_url": "https://github.com/rust-lang/rust/blob/afc68277f69572944fd81d61b126732ab29b5d17/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc68277f69572944fd81d61b126732ab29b5d17/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=afc68277f69572944fd81d61b126732ab29b5d17", "patch": "@@ -0,0 +1,770 @@\n+//! This module contains functions to suggest names for expressions, functions and other items\n+\n+use hir::Semantics;\n+use ide_db::RootDatabase;\n+use itertools::Itertools;\n+use stdx::to_lower_snake_case;\n+use syntax::{\n+    ast::{self, NameOwner},\n+    match_ast, AstNode,\n+};\n+\n+/// Trait names, that will be ignored when in `impl Trait` and `dyn Trait`\n+const USELESS_TRAITS: &[&str] = &[\"Send\", \"Sync\", \"Copy\", \"Clone\", \"Eq\", \"PartialEq\"];\n+/// Identifier names that won't be suggested, ever\n+///\n+/// **NOTE**: they all must be snake lower case\n+const USELESS_NAMES: &[&str] =\n+    &[\"new\", \"default\", \"option\", \"some\", \"none\", \"ok\", \"err\", \"str\", \"string\"];\n+/// Generic types replaced by their first argument\n+///\n+/// # Examples\n+/// `Option<Name>` -> `Name`\n+/// `Result<User, Error>` -> `User`\n+const WRAPPER_TYPES: &[&str] = &[\"Box\", \"Option\", \"Result\"];\n+/// Prefixes to strip from methods names\n+///\n+/// # Examples\n+/// `vec.as_slice()` -> `slice`\n+/// `args.into_config()` -> `config`\n+/// `bytes.to_vec()` -> `vec`\n+const USELESS_METHOD_PREFIXES: &[&str] = &[\"into_\", \"as_\", \"to_\"];\n+\n+/// Suggest name of variable for given expression\n+///\n+/// **NOTE**: it is caller's responsibility to guarantee uniqueness of the name.\n+/// I.e. it doesn't look for names in scope.\n+///\n+/// # Current implementation\n+///\n+/// In current implementation, the function tries to get the name from\n+/// the following sources:\n+///\n+/// * if expr is an argument to function/method, use paramter name\n+/// * if expr is a function/method call, use function name\n+/// * expression type name if it exists (E.g. `()`, `fn() -> ()` or `!` do not have names)\n+/// * fallback: `var_name`\n+///\n+/// It also applies heuristics to filter out less informative names\n+///\n+/// Currently it sticks to the first name found.\n+pub(crate) fn variable(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> String {\n+    from_param(expr, sema)\n+        .or_else(|| from_call(expr))\n+        .or_else(|| from_type(expr, sema))\n+        .unwrap_or_else(|| \"var_name\".to_string())\n+}\n+\n+fn normalize(name: &str) -> Option<String> {\n+    let name = to_lower_snake_case(name);\n+\n+    if USELESS_NAMES.contains(&name.as_str()) {\n+        return None;\n+    }\n+\n+    if !is_valid_name(&name) {\n+        return None;\n+    }\n+\n+    Some(name)\n+}\n+\n+fn is_valid_name(name: &str) -> bool {\n+    match syntax::lex_single_syntax_kind(name) {\n+        Some((syntax::SyntaxKind::IDENT, _error)) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn from_call(expr: &ast::Expr) -> Option<String> {\n+    from_func_call(expr).or_else(|| from_method_call(expr))\n+}\n+\n+fn from_func_call(expr: &ast::Expr) -> Option<String> {\n+    let call = match expr {\n+        ast::Expr::CallExpr(call) => call,\n+        _ => return None,\n+    };\n+    let func = match call.expr()? {\n+        ast::Expr::PathExpr(path) => path,\n+        _ => return None,\n+    };\n+    let ident = func.path()?.segment()?.name_ref()?.ident_token()?;\n+    normalize(ident.text())\n+}\n+\n+fn from_method_call(expr: &ast::Expr) -> Option<String> {\n+    let method = match expr {\n+        ast::Expr::MethodCallExpr(call) => call,\n+        _ => return None,\n+    };\n+    let ident = method.name_ref()?.ident_token()?;\n+    let name = normalize(ident.text())?;\n+\n+    for prefix in USELESS_METHOD_PREFIXES {\n+        if let Some(suffix) = name.strip_prefix(prefix) {\n+            return Some(suffix.to_string());\n+        }\n+    }\n+\n+    Some(name)\n+}\n+\n+fn from_param(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> Option<String> {\n+    let arg_list = expr.syntax().parent().and_then(ast::ArgList::cast)?;\n+    let args_parent = arg_list.syntax().parent()?;\n+    let func = match_ast! {\n+        match args_parent {\n+            ast::CallExpr(call) => {\n+                let func = call.expr()?;\n+                let func_ty = sema.type_of_expr(&func)?;\n+                func_ty.as_callable(sema.db)?\n+            },\n+            ast::MethodCallExpr(method) => sema.resolve_method_call_as_callable(&method)?,\n+            _ => return None,\n+        }\n+    };\n+\n+    let (idx, _) = arg_list.args().find_position(|it| it == expr).unwrap();\n+    let (pat, _) = func.params(sema.db).into_iter().nth(idx)?;\n+    let pat = match pat? {\n+        either::Either::Right(pat) => pat,\n+        _ => return None,\n+    };\n+    let name = var_name_from_pat(&pat)?;\n+    normalize(&name.to_string())\n+}\n+\n+fn var_name_from_pat(pat: &ast::Pat) -> Option<ast::Name> {\n+    match pat {\n+        ast::Pat::IdentPat(var) => var.name(),\n+        ast::Pat::RefPat(ref_pat) => var_name_from_pat(&ref_pat.pat()?),\n+        ast::Pat::BoxPat(box_pat) => var_name_from_pat(&box_pat.pat()?),\n+        _ => None,\n+    }\n+}\n+\n+fn from_type(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> Option<String> {\n+    let ty = sema.type_of_expr(expr)?;\n+    let ty = ty.remove_ref().unwrap_or(ty);\n+\n+    name_of_type(&ty, sema.db)\n+}\n+\n+fn name_of_type(ty: &hir::Type, db: &RootDatabase) -> Option<String> {\n+    let name = if let Some(adt) = ty.as_adt() {\n+        let name = adt.name(db).to_string();\n+\n+        if WRAPPER_TYPES.contains(&name.as_str()) {\n+            let inner_ty = ty.type_parameters().next()?;\n+            return name_of_type(&inner_ty, db);\n+        }\n+\n+        name\n+    } else if let Some(trait_) = ty.as_dyn_trait() {\n+        trait_name(&trait_, db)?\n+    } else if let Some(traits) = ty.as_impl_traits(db) {\n+        let mut iter = traits.into_iter().filter_map(|t| trait_name(&t, db));\n+        let name = iter.next()?;\n+        if iter.next().is_some() {\n+            return None;\n+        }\n+        name\n+    } else {\n+        return None;\n+    };\n+    normalize(&name)\n+}\n+\n+fn trait_name(trait_: &hir::Trait, db: &RootDatabase) -> Option<String> {\n+    let name = trait_.name(db).to_string();\n+    if USELESS_TRAITS.contains(&name.as_str()) {\n+        return None;\n+    }\n+    Some(name)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::tests::check_name_suggestion;\n+\n+    mod from_func_call {\n+        use super::*;\n+\n+        #[test]\n+        fn no_args() {\n+            check_name_suggestion(\n+                |e, _| from_func_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0bar()$0\n+                }\"#,\n+                \"bar\",\n+            );\n+        }\n+\n+        #[test]\n+        fn single_arg() {\n+            check_name_suggestion(\n+                |e, _| from_func_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0bar(1)$0\n+                }\"#,\n+                \"bar\",\n+            );\n+        }\n+\n+        #[test]\n+        fn many_args() {\n+            check_name_suggestion(\n+                |e, _| from_func_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0bar(1, 2, 3)$0\n+                }\"#,\n+                \"bar\",\n+            );\n+        }\n+\n+        #[test]\n+        fn path() {\n+            check_name_suggestion(\n+                |e, _| from_func_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0i32::bar(1, 2, 3)$0\n+                }\"#,\n+                \"bar\",\n+            );\n+        }\n+\n+        #[test]\n+        fn generic_params() {\n+            check_name_suggestion(\n+                |e, _| from_func_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0bar::<i32>(1, 2, 3)$0\n+                }\"#,\n+                \"bar\",\n+            );\n+        }\n+    }\n+\n+    mod from_method_call {\n+        use super::*;\n+\n+        #[test]\n+        fn no_args() {\n+            check_name_suggestion(\n+                |e, _| from_method_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0bar.frobnicate()$0\n+                }\"#,\n+                \"frobnicate\",\n+            );\n+        }\n+\n+        #[test]\n+        fn generic_params() {\n+            check_name_suggestion(\n+                |e, _| from_method_call(e),\n+                r#\"\n+                fn foo() {\n+                    $0bar.frobnicate::<i32, u32>()$0\n+                }\"#,\n+                \"frobnicate\",\n+            );\n+        }\n+\n+        #[test]\n+        fn to_name() {\n+            check_name_suggestion(\n+                |e, _| from_method_call(e),\n+                r#\"\n+                struct Args;\n+                struct Config;\n+                impl Args {\n+                    fn to_config(&self) -> Config {}\n+                }\n+                fn foo() {\n+                    $0Args.to_config()$0;\n+                }\"#,\n+                \"config\",\n+            );\n+        }\n+    }\n+\n+    mod from_param {\n+        use crate::tests::check_name_suggestion_not_applicable;\n+\n+        use super::*;\n+\n+        #[test]\n+        fn plain_func() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                fn bar(n: i32, m: u32);\n+                fn foo() {\n+                    bar($01$0, 2)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn mut_param() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                fn bar(mut n: i32, m: u32);\n+                fn foo() {\n+                    bar($01$0, 2)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn func_does_not_exist() {\n+            check_name_suggestion_not_applicable(\n+                from_param,\n+                r#\"\n+                fn foo() {\n+                    bar($01$0, 2)\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn unnamed_param() {\n+            check_name_suggestion_not_applicable(\n+                from_param,\n+                r#\"\n+                fn bar(_: i32, m: u32);\n+                fn foo() {\n+                    bar($01$0, 2)\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn tuple_pat() {\n+            check_name_suggestion_not_applicable(\n+                from_param,\n+                r#\"\n+                fn bar((n, k): (i32, i32), m: u32);\n+                fn foo() {\n+                    bar($0(1, 2)$0, 3)\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn ref_pat() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                fn bar(&n: &i32, m: u32);\n+                fn foo() {\n+                    bar($0&1$0, 3)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn box_pat() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                fn bar(box n: &i32, m: u32);\n+                fn foo() {\n+                    bar($01$0, 3)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn param_out_of_index() {\n+            check_name_suggestion_not_applicable(\n+                from_param,\n+                r#\"\n+                fn bar(n: i32, m: u32);\n+                fn foo() {\n+                    bar(1, 2, $03$0)\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn generic_param_resolved() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                fn bar<T>(n: T, m: u32);\n+                fn foo() {\n+                    bar($01$0, 2)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn generic_param_unresolved() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                fn bar<T>(n: T, m: u32);\n+                fn foo<T>(x: T) {\n+                    bar($0x$0, 2)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn method() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                struct S;\n+                impl S {\n+                    fn bar(&self, n: i32, m: u32);\n+                }\n+                fn foo() {\n+                    S.bar($01$0, 2)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn method_ufcs() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                struct S;\n+                impl S {\n+                    fn bar(&self, n: i32, m: u32);\n+                }\n+                fn foo() {\n+                    S::bar(&S, $01$0, 2)\n+                }\"#,\n+                \"n\",\n+            );\n+        }\n+\n+        #[test]\n+        fn method_self() {\n+            check_name_suggestion_not_applicable(\n+                from_param,\n+                r#\"\n+                struct S;\n+                impl S {\n+                    fn bar(&self, n: i32, m: u32);\n+                }\n+                fn foo() {\n+                    S::bar($0&S$0, 1, 2)\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn method_self_named() {\n+            check_name_suggestion(\n+                from_param,\n+                r#\"\n+                struct S;\n+                impl S {\n+                    fn bar(strukt: &Self, n: i32, m: u32);\n+                }\n+                fn foo() {\n+                    S::bar($0&S$0, 1, 2)\n+                }\"#,\n+                \"strukt\",\n+            );\n+        }\n+    }\n+\n+    mod from_type {\n+        use crate::tests::check_name_suggestion_not_applicable;\n+\n+        use super::*;\n+\n+        #[test]\n+        fn i32() {\n+            check_name_suggestion_not_applicable(\n+                from_type,\n+                r#\"\n+                fn foo() {\n+                    let _: i32 = $01$0;\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn u64() {\n+            check_name_suggestion_not_applicable(\n+                from_type,\n+                r#\"\n+                fn foo() {\n+                    let _: u64 = $01$0;\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn bool() {\n+            check_name_suggestion_not_applicable(\n+                from_type,\n+                r#\"\n+                fn foo() {\n+                    let _: bool = $0true$0;\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn struct_unit() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                struct Seed;\n+                fn foo() {\n+                    let _ = $0Seed$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+\n+        #[test]\n+        fn struct_unit_to_snake() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                struct SeedState;\n+                fn foo() {\n+                    let _ = $0SeedState$0;\n+                }\"#,\n+                \"seed_state\",\n+            );\n+        }\n+\n+        #[test]\n+        fn struct_single_arg() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                struct Seed(u32);\n+                fn foo() {\n+                    let _ = $0Seed(0)$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+\n+        #[test]\n+        fn struct_with_fields() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                struct Seed { value: u32 }\n+                fn foo() {\n+                    let _ = $0Seed { value: 0 }$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+\n+        #[test]\n+        fn enum_() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                enum Kind { A, B }\n+                fn foo() {\n+                    let _ = $0Kind::A$0;\n+                }\"#,\n+                \"kind\",\n+            );\n+        }\n+\n+        #[test]\n+        fn enum_generic_resolved() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                enum Kind<T> { A(T), B }\n+                fn foo() {\n+                    let _ = $0Kind::A(1)$0;\n+                }\"#,\n+                \"kind\",\n+            );\n+        }\n+\n+        #[test]\n+        fn enum_generic_unresolved() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                enum Kind<T> { A(T), B }\n+                fn foo<T>(x: T) {\n+                    let _ = $0Kind::A(x)$0;\n+                }\"#,\n+                \"kind\",\n+            );\n+        }\n+\n+        #[test]\n+        fn dyn_trait() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                trait DynHandler {}\n+                fn bar() -> dyn DynHandler {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"dyn_handler\",\n+            );\n+        }\n+\n+        #[test]\n+        fn impl_trait() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                trait StaticHandler {}\n+                fn bar() -> impl StaticHandler {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"static_handler\",\n+            );\n+        }\n+\n+        #[test]\n+        fn impl_trait_plus_clone() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                trait StaticHandler {}\n+                trait Clone {}\n+                fn bar() -> impl StaticHandler + Clone {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"static_handler\",\n+            );\n+        }\n+\n+        #[test]\n+        fn impl_trait_plus_lifetime() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                trait StaticHandler {}\n+                trait Clone {}\n+                fn bar<'a>(&'a i32) -> impl StaticHandler + 'a {}\n+                fn foo() {\n+                    $0bar(&1)$0;\n+                }\"#,\n+                \"static_handler\",\n+            );\n+        }\n+\n+        #[test]\n+        fn impl_trait_plus_trait() {\n+            check_name_suggestion_not_applicable(\n+                from_type,\n+                r#\"\n+                trait Handler {}\n+                trait StaticHandler {}\n+                fn bar() -> impl StaticHandler + Handler {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn ref_value() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                struct Seed;\n+                fn bar() -> &Seed {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+\n+        #[test]\n+        fn box_value() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                struct Box<T>(*const T);\n+                struct Seed;\n+                fn bar() -> Box<Seed> {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+\n+        #[test]\n+        fn box_generic() {\n+            check_name_suggestion_not_applicable(\n+                from_type,\n+                r#\"\n+                struct Box<T>(*const T);\n+                fn bar<T>() -> Box<T> {}\n+                fn foo<T>() {\n+                    $0bar::<T>()$0;\n+                }\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn option_value() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                enum Option<T> { Some(T) }\n+                struct Seed;\n+                fn bar() -> Option<Seed> {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+\n+        #[test]\n+        fn result_value() {\n+            check_name_suggestion(\n+                from_type,\n+                r#\"\n+                enum Result<T, E> { Ok(T), Err(E) }\n+                struct Seed;\n+                struct Error;\n+                fn bar() -> Result<Seed, Error> {}\n+                fn foo() {\n+                    $0bar()$0;\n+                }\"#,\n+                \"seed\",\n+            );\n+        }\n+    }\n+}"}]}