{"sha": "bc486dc233b23f79d5f144cbbbd67cde208c14b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNDg2ZGMyMzNiMjNmNzlkNWYxNDRjYmJiZDY3Y2RlMjA4YzE0YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-10T15:22:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-10T15:22:18Z"}, "message": "auto merge of #19663 : tbu-/rust/pr_fix_vecmap, r=Gankro\n\n- Introduce a named type for the return type of `VecMap::move_iter`\r\n- Rename all type parameters to `V` for \"Value\".\r\n- Remove unnecessary call to an `Option::unwrap`, use pattern matching instead.\r\n- Remove incorrect `Hash` implementation which took the `VecMap`'s capacity\r\n  into account.\r\n\r\nThis is a [breaking-change], however whoever used the `Hash` implementation\r\nrelied on an incorrect implementation.", "tree": {"sha": "3dbd576e079524d08cd6b7f2a3507b0c4f55a2db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dbd576e079524d08cd6b7f2a3507b0c4f55a2db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc486dc233b23f79d5f144cbbbd67cde208c14b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc486dc233b23f79d5f144cbbbd67cde208c14b6", "html_url": "https://github.com/rust-lang/rust/commit/bc486dc233b23f79d5f144cbbbd67cde208c14b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc486dc233b23f79d5f144cbbbd67cde208c14b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daa2bde2ba37aae5ac8b819410513bb61a7b9a43", "url": "https://api.github.com/repos/rust-lang/rust/commits/daa2bde2ba37aae5ac8b819410513bb61a7b9a43", "html_url": "https://github.com/rust-lang/rust/commit/daa2bde2ba37aae5ac8b819410513bb61a7b9a43"}, {"sha": "20eaf168c5b40c003bd7d28fe4c071b24118410e", "url": "https://api.github.com/repos/rust-lang/rust/commits/20eaf168c5b40c003bd7d28fe4c071b24118410e", "html_url": "https://github.com/rust-lang/rust/commit/20eaf168c5b40c003bd7d28fe4c071b24118410e"}], "stats": {"total": 88, "additions": 53, "deletions": 35}, "files": [{"sha": "3b8c690e0474964642cfbfa4f3d96430cb8fbb60", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/bc486dc233b23f79d5f144cbbbd67cde208c14b6/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc486dc233b23f79d5f144cbbbd67cde208c14b6/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=bc486dc233b23f79d5f144cbbbd67cde208c14b6", "patch": "@@ -21,10 +21,9 @@ use core::iter;\n use core::iter::{Enumerate, FilterMap};\n use core::mem::replace;\n \n+use hash::{Hash, Writer};\n use {vec, slice};\n use vec::Vec;\n-use hash;\n-use hash::Hash;\n \n // FIXME(conventions): capacity management???\n \n@@ -62,8 +61,8 @@ use hash::Hash;\n /// assert!(months.is_empty());\n /// ```\n #[deriving(PartialEq, Eq)]\n-pub struct VecMap<T> {\n-    v: Vec<Option<T>>,\n+pub struct VecMap<V> {\n+    v: Vec<Option<V>>,\n }\n \n impl<V> Default for VecMap<V> {\n@@ -83,9 +82,16 @@ impl<V:Clone> Clone for VecMap<V> {\n     }\n }\n \n-impl <S: hash::Writer, T: Hash<S>> Hash<S> for VecMap<T> {\n+impl<S: Writer, V: Hash<S>> Hash<S> for VecMap<V> {\n     fn hash(&self, state: &mut S) {\n-        self.v.hash(state)\n+        // In order to not traverse the `VecMap` twice, count the elements\n+        // during iteration.\n+        let mut count: uint = 0;\n+        for elt in self.iter() {\n+            elt.hash(state);\n+            count += 1;\n+        }\n+        count.hash(state);\n     }\n }\n \n@@ -99,7 +105,7 @@ impl<V> VecMap<V> {\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn new() -> VecMap<V> { VecMap{v: vec!()} }\n+    pub fn new() -> VecMap<V> { VecMap { v: vec![] } }\n \n     /// Creates an empty `VecMap` with space for at least `capacity`\n     /// elements before resizing.\n@@ -223,10 +229,7 @@ impl<V> VecMap<V> {\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn into_iter(&mut self)\n-        -> FilterMap<(uint, Option<V>), (uint, V),\n-                Enumerate<vec::MoveItems<Option<V>>>>\n-    {\n+    pub fn into_iter(&mut self) -> MoveItems<V> {\n         let values = replace(&mut self.v, vec!());\n         values.into_iter().enumerate().filter_map(|(i, v)| {\n             v.map(|v| (i, v))\n@@ -539,16 +542,19 @@ impl<V> IndexMut<uint, V> for VecMap<V> {\n \n macro_rules! iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n+        impl<'a, V> Iterator<$elem> for $name<'a, V> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n                 while self.front < self.back {\n                     match self.iter.next() {\n                         Some(elem) => {\n-                            if elem.is_some() {\n-                                let index = self.front;\n-                                self.front += 1;\n-                                return Some((index, elem $(. $getter ())+));\n+                            match elem$(. $getter ())+ {\n+                                Some(x) => {\n+                                    let index = self.front;\n+                                    self.front += 1;\n+                                    return Some((index, x));\n+                                },\n+                                None => {},\n                             }\n                         }\n                         _ => ()\n@@ -568,15 +574,18 @@ macro_rules! iterator {\n \n macro_rules! double_ended_iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n+        impl<'a, V> DoubleEndedIterator<$elem> for $name<'a, V> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n                 while self.front < self.back {\n                     match self.iter.next_back() {\n                         Some(elem) => {\n-                            if elem.is_some() {\n-                                self.back -= 1;\n-                                return Some((self.back, elem$(. $getter ())+));\n+                            match elem$(. $getter ())+ {\n+                                Some(x) => {\n+                                    self.back -= 1;\n+                                    return Some((self.back, x));\n+                                },\n+                                None => {},\n                             }\n                         }\n                         _ => ()\n@@ -590,39 +599,43 @@ macro_rules! double_ended_iterator {\n }\n \n /// Forward iterator over a map.\n-pub struct Entries<'a, T:'a> {\n+pub struct Entries<'a, V:'a> {\n     front: uint,\n     back: uint,\n-    iter: slice::Items<'a, Option<T>>\n+    iter: slice::Items<'a, Option<V>>\n }\n \n-iterator!(impl Entries -> (uint, &'a T), as_ref, unwrap)\n-double_ended_iterator!(impl Entries -> (uint, &'a T), as_ref, unwrap)\n+iterator!(impl Entries -> (uint, &'a V), as_ref)\n+double_ended_iterator!(impl Entries -> (uint, &'a V), as_ref)\n \n /// Forward iterator over the key-value pairs of a map, with the\n /// values being mutable.\n-pub struct MutEntries<'a, T:'a> {\n+pub struct MutEntries<'a, V:'a> {\n     front: uint,\n     back: uint,\n-    iter: slice::MutItems<'a, Option<T>>\n+    iter: slice::MutItems<'a, Option<V>>\n }\n \n-iterator!(impl MutEntries -> (uint, &'a mut T), as_mut, unwrap)\n-double_ended_iterator!(impl MutEntries -> (uint, &'a mut T), as_mut, unwrap)\n+iterator!(impl MutEntries -> (uint, &'a mut V), as_mut)\n+double_ended_iterator!(impl MutEntries -> (uint, &'a mut V), as_mut)\n \n /// Forward iterator over the keys of a map\n-pub type Keys<'a, T> =\n-    iter::Map<'static, (uint, &'a T), uint, Entries<'a, T>>;\n+pub type Keys<'a, V> =\n+    iter::Map<'static, (uint, &'a V), uint, Entries<'a, V>>;\n \n /// Forward iterator over the values of a map\n-pub type Values<'a, T> =\n-    iter::Map<'static, (uint, &'a T), &'a T, Entries<'a, T>>;\n+pub type Values<'a, V> =\n+    iter::Map<'static, (uint, &'a V), &'a V, Entries<'a, V>>;\n+\n+/// Iterator over the key-value pairs of a map, the iterator consumes the map\n+pub type MoveItems<V> =\n+    FilterMap<'static, (uint, Option<V>), (uint, V), Enumerate<vec::MoveItems<Option<V>>>>;\n \n #[cfg(test)]\n mod test_map {\n     use std::prelude::*;\n     use vec::Vec;\n-    use hash;\n+    use hash::hash;\n \n     use super::VecMap;\n \n@@ -940,7 +953,7 @@ mod test_map {\n         let mut x = VecMap::new();\n         let mut y = VecMap::new();\n \n-        assert!(hash::hash(&x) == hash::hash(&y));\n+        assert!(hash(&x) == hash(&y));\n         x.insert(1, 'a');\n         x.insert(2, 'b');\n         x.insert(3, 'c');\n@@ -949,7 +962,12 @@ mod test_map {\n         y.insert(2, 'b');\n         y.insert(1, 'a');\n \n-        assert!(hash::hash(&x) == hash::hash(&y));\n+        assert!(hash(&x) == hash(&y));\n+\n+        x.insert(1000, 'd');\n+        x.remove(&1000);\n+\n+        assert!(hash(&x) == hash(&y));\n     }\n \n     #[test]"}]}