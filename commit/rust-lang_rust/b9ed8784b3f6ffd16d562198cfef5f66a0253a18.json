{"sha": "b9ed8784b3f6ffd16d562198cfef5f66a0253a18", "node_id": "C_kwDOAAsO6NoAKGI5ZWQ4Nzg0YjNmNmZmZDE2ZDU2MjE5OGNmZWY1ZjY2YTAyNTNhMTg", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-05-02T21:51:45Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-05-25T18:01:43Z"}, "message": "rustdoc: include impl generics / self in search index", "tree": {"sha": "9afecf12809eed2f0297b2d49da3ed4a12f55b11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9afecf12809eed2f0297b2d49da3ed4a12f55b11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9ed8784b3f6ffd16d562198cfef5f66a0253a18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9ed8784b3f6ffd16d562198cfef5f66a0253a18", "html_url": "https://github.com/rust-lang/rust/commit/b9ed8784b3f6ffd16d562198cfef5f66a0253a18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9ed8784b3f6ffd16d562198cfef5f66a0253a18/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fed13030c2a2ebd79bfb1fd8be4f768cbe8c9d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fed13030c2a2ebd79bfb1fd8be4f768cbe8c9d9", "html_url": "https://github.com/rust-lang/rust/commit/9fed13030c2a2ebd79bfb1fd8be4f768cbe8c9d9"}], "stats": {"total": 221, "additions": 204, "deletions": 17}, "files": [{"sha": "23bb020716dd568d23ed0b8fe43b770479ecfa76", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9ed8784b3f6ffd16d562198cfef5f66a0253a18/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9ed8784b3f6ffd16d562198cfef5f66a0253a18/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=b9ed8784b3f6ffd16d562198cfef5f66a0253a18", "patch": "@@ -1410,6 +1410,12 @@ pub(crate) struct Generics {\n     pub(crate) where_predicates: Vec<WherePredicate>,\n }\n \n+impl Generics {\n+    pub(crate) fn is_empty(&self) -> bool {\n+        self.params.is_empty() && self.where_predicates.is_empty()\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub(crate) struct Function {\n     pub(crate) decl: FnDecl,"}, {"sha": "813e6fa24eca52f9f0e01e57dfeecb39eb616576", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b9ed8784b3f6ffd16d562198cfef5f66a0253a18/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9ed8784b3f6ffd16d562198cfef5f66a0253a18/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=b9ed8784b3f6ffd16d562198cfef5f66a0253a18", "patch": "@@ -95,7 +95,9 @@ pub(crate) struct Cache {\n     // Private fields only used when initially crawling a crate to build a cache\n     stack: Vec<Symbol>,\n     parent_stack: Vec<DefId>,\n+    impl_generics_stack: Vec<(clean::Type, clean::Generics)>,\n     parent_is_trait_impl: bool,\n+    parent_is_blanket_or_auto_impl: bool,\n     stripped_mod: bool,\n \n     pub(crate) search_index: Vec<IndexItem>,\n@@ -105,7 +107,8 @@ pub(crate) struct Cache {\n     // then the fully qualified name of the structure isn't presented in `paths`\n     // yet when its implementation methods are being indexed. Caches such methods\n     // and their parent id here and indexes them at the end of crate parsing.\n-    pub(crate) orphan_impl_items: Vec<(DefId, clean::Item)>,\n+    pub(crate) orphan_impl_items:\n+        Vec<(DefId, clean::Item, Option<(clean::Type, clean::Generics)>, bool)>,\n \n     // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n     // even though the trait itself is not exported. This can happen if a trait\n@@ -315,15 +318,26 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             desc,\n                             parent,\n                             parent_idx: None,\n-                            search_type: get_function_type_for_search(&item, self.tcx, self.cache),\n+                            search_type: get_function_type_for_search(\n+                                &item,\n+                                self.tcx,\n+                                self.cache.impl_generics_stack.last(),\n+                                self.cache.parent_is_blanket_or_auto_impl,\n+                                self.cache,\n+                            ),\n                             aliases: item.attrs.get_doc_aliases(),\n                         });\n                     }\n                 }\n                 (Some(parent), None) if is_inherent_impl_item => {\n                     // We have a parent, but we don't know where they're\n                     // defined yet. Wait for later to index this item.\n-                    self.cache.orphan_impl_items.push((parent, item.clone()));\n+                    self.cache.orphan_impl_items.push((\n+                        parent,\n+                        item.clone(),\n+                        self.cache.impl_generics_stack.last().cloned(),\n+                        self.cache.parent_is_blanket_or_auto_impl,\n+                    ));\n                 }\n                 _ => {}\n             }\n@@ -440,9 +454,34 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             _ => false,\n         };\n \n+        // When recursing into an impl item, make the generics context visible\n+        // to the child items.\n+        let item = {\n+            let mut item = item;\n+            let mut old_parent_is_blanket_or_auto_impl = false;\n+            if let clean::Item { kind: box clean::ImplItem(ref mut i), .. } = item {\n+                old_parent_is_blanket_or_auto_impl = mem::replace(\n+                    &mut self.cache.parent_is_blanket_or_auto_impl,\n+                    !matches!(i.kind, clean::ImplKind::Normal),\n+                );\n+                self.cache.impl_generics_stack.push((\n+                    mem::replace(&mut i.for_, clean::Type::Infer),\n+                    mem::replace(\n+                        &mut i.generics,\n+                        clean::Generics { params: Vec::new(), where_predicates: Vec::new() },\n+                    ),\n+                ));\n+            }\n+            let mut item = self.fold_item_recur(item);\n+            if let clean::Item { kind: box clean::ImplItem(ref mut i), .. } = item {\n+                self.cache.parent_is_blanket_or_auto_impl = old_parent_is_blanket_or_auto_impl;\n+                (i.for_, i.generics) = self.cache.impl_generics_stack.pop().expect(\"pushed above\");\n+            }\n+            item\n+        };\n+\n         // Once we've recursively found all the generics, hoard off all the\n         // implementations elsewhere.\n-        let item = self.fold_item_recur(item);\n         let ret = if let clean::Item { kind: box clean::ImplItem(ref i), .. } = item {\n             // Figure out the id of this impl. This may map to a\n             // primitive rather than always to a struct/enum."}, {"sha": "323c0e89f29bb1b50116a1f31f189b5a076b8d86", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 63, "deletions": 13, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b9ed8784b3f6ffd16d562198cfef5f66a0253a18/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9ed8784b3f6ffd16d562198cfef5f66a0253a18/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=b9ed8784b3f6ffd16d562198cfef5f66a0253a18", "patch": "@@ -25,7 +25,7 @@ pub(crate) fn build_index<'tcx>(\n \n     // Attach all orphan items to the type's definition if the type\n     // has since been learned.\n-    for &(did, ref item) in &cache.orphan_impl_items {\n+    for &(did, ref item, ref impl_generics, from_blanket_or_auto_impl) in &cache.orphan_impl_items {\n         if let Some(&(ref fqp, _)) = cache.paths.get(&did) {\n             let desc = item\n                 .doc_value()\n@@ -37,7 +37,13 @@ pub(crate) fn build_index<'tcx>(\n                 desc,\n                 parent: Some(did),\n                 parent_idx: None,\n-                search_type: get_function_type_for_search(item, tcx, cache),\n+                search_type: get_function_type_for_search(\n+                    item,\n+                    tcx,\n+                    impl_generics.as_ref(),\n+                    from_blanket_or_auto_impl,\n+                    cache,\n+                ),\n                 aliases: item.attrs.get_doc_aliases(),\n             });\n         }\n@@ -192,12 +198,18 @@ pub(crate) fn build_index<'tcx>(\n pub(crate) fn get_function_type_for_search<'tcx>(\n     item: &clean::Item,\n     tcx: TyCtxt<'tcx>,\n+    impl_generics: Option<&(clean::Type, clean::Generics)>,\n+    from_blanket_or_auto_impl: bool,\n     cache: &Cache,\n ) -> Option<IndexItemFunctionType> {\n+    if from_blanket_or_auto_impl {\n+        return None;\n+    }\n+\n     let (mut inputs, mut output) = match *item.kind {\n-        clean::FunctionItem(ref f) => get_fn_inputs_and_outputs(f, tcx, cache),\n-        clean::MethodItem(ref m, _) => get_fn_inputs_and_outputs(m, tcx, cache),\n-        clean::TyMethodItem(ref m) => get_fn_inputs_and_outputs(m, tcx, cache),\n+        clean::FunctionItem(ref f) => get_fn_inputs_and_outputs(f, tcx, impl_generics, cache),\n+        clean::MethodItem(ref m, _) => get_fn_inputs_and_outputs(m, tcx, impl_generics, cache),\n+        clean::TyMethodItem(ref m) => get_fn_inputs_and_outputs(m, tcx, impl_generics, cache),\n         _ => return None,\n     };\n \n@@ -247,9 +259,10 @@ fn get_index_type_name(clean_type: &clean::Type) -> Option<Symbol> {\n /// Important note: It goes through generics recursively. So if you have\n /// `T: Option<Result<(), ()>>`, it'll go into `Option` and then into `Result`.\n #[instrument(level = \"trace\", skip(tcx, res, cache))]\n-fn add_generics_and_bounds_as_types<'tcx>(\n+fn add_generics_and_bounds_as_types<'tcx, 'a>(\n+    self_: Option<&'a Type>,\n     generics: &Generics,\n-    arg: &Type,\n+    arg: &'a Type,\n     tcx: TyCtxt<'tcx>,\n     recurse: usize,\n     res: &mut Vec<TypeWithKind>,\n@@ -334,6 +347,17 @@ fn add_generics_and_bounds_as_types<'tcx>(\n         return;\n     }\n \n+    // First, check if it's \"Self\".\n+    let arg = if let Some(self_) = self_ {\n+        match &*arg {\n+            Type::BorrowedRef { type_, .. } if type_.is_self_type() => self_,\n+            type_ if type_.is_self_type() => self_,\n+            arg => arg,\n+        }\n+    } else {\n+        arg\n+    };\n+\n     // If this argument is a type parameter and not a trait bound or a type, we need to look\n     // for its bounds.\n     if let Type::Generic(arg_s) = *arg {\n@@ -350,6 +374,7 @@ fn add_generics_and_bounds_as_types<'tcx>(\n                         match &param_def.kind {\n                             clean::GenericParamDefKind::Type { default: Some(ty), .. } => {\n                                 add_generics_and_bounds_as_types(\n+                                    self_,\n                                     generics,\n                                     ty,\n                                     tcx,\n@@ -372,6 +397,7 @@ fn add_generics_and_bounds_as_types<'tcx>(\n                 if let Some(path) = bound.get_trait_path() {\n                     let ty = Type::Path { path };\n                     add_generics_and_bounds_as_types(\n+                        self_,\n                         generics,\n                         &ty,\n                         tcx,\n@@ -393,6 +419,7 @@ fn add_generics_and_bounds_as_types<'tcx>(\n         if let Some(arg_generics) = arg.generics() {\n             for gen in arg_generics.iter() {\n                 add_generics_and_bounds_as_types(\n+                    self_,\n                     generics,\n                     gen,\n                     tcx,\n@@ -413,18 +440,33 @@ fn add_generics_and_bounds_as_types<'tcx>(\n fn get_fn_inputs_and_outputs<'tcx>(\n     func: &Function,\n     tcx: TyCtxt<'tcx>,\n+    impl_generics: Option<&(clean::Type, clean::Generics)>,\n     cache: &Cache,\n ) -> (Vec<TypeWithKind>, Vec<TypeWithKind>) {\n     let decl = &func.decl;\n-    let generics = &func.generics;\n+\n+    let combined_generics;\n+    let (self_, generics) = if let Some(&(ref impl_self, ref impl_generics)) = impl_generics {\n+        match (impl_generics.is_empty(), func.generics.is_empty()) {\n+            (true, _) => (Some(impl_self), &func.generics),\n+            (_, true) => (Some(impl_self), impl_generics),\n+            (false, false) => {\n+                let mut params = func.generics.params.clone();\n+                params.extend(impl_generics.params.clone());\n+                let mut where_predicates = func.generics.where_predicates.clone();\n+                where_predicates.extend(impl_generics.where_predicates.clone());\n+                combined_generics = clean::Generics { params, where_predicates };\n+                (Some(impl_self), &combined_generics)\n+            }\n+        }\n+    } else {\n+        (None, &func.generics)\n+    };\n \n     let mut all_types = Vec::new();\n     for arg in decl.inputs.values.iter() {\n-        if arg.type_.is_self_type() {\n-            continue;\n-        }\n         let mut args = Vec::new();\n-        add_generics_and_bounds_as_types(generics, &arg.type_, tcx, 0, &mut args, cache);\n+        add_generics_and_bounds_as_types(self_, generics, &arg.type_, tcx, 0, &mut args, cache);\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n@@ -437,7 +479,15 @@ fn get_fn_inputs_and_outputs<'tcx>(\n     let mut ret_types = Vec::new();\n     match decl.output {\n         FnRetTy::Return(ref return_type) => {\n-            add_generics_and_bounds_as_types(generics, return_type, tcx, 0, &mut ret_types, cache);\n+            add_generics_and_bounds_as_types(\n+                self_,\n+                generics,\n+                return_type,\n+                tcx,\n+                0,\n+                &mut ret_types,\n+                cache,\n+            );\n             if ret_types.is_empty() {\n                 if let Some(kind) = return_type.def_id(cache).map(|did| tcx.def_kind(did).into()) {\n                     ret_types.push(TypeWithKind::from((get_index_type(return_type, vec![]), kind)));"}, {"sha": "20bb7be6ba004176f67aefc34bc2a50b3a8d47f4", "filename": "src/test/rustdoc-js/generics-impl.js", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b9ed8784b3f6ffd16d562198cfef5f66a0253a18/src%2Ftest%2Frustdoc-js%2Fgenerics-impl.js", "raw_url": "https://github.com/rust-lang/rust/raw/b9ed8784b3f6ffd16d562198cfef5f66a0253a18/src%2Ftest%2Frustdoc-js%2Fgenerics-impl.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fgenerics-impl.js?ref=b9ed8784b3f6ffd16d562198cfef5f66a0253a18", "patch": "@@ -0,0 +1,57 @@\n+// exact-check\n+\n+const QUERY = [\n+    'Aaaaaaa -> u32',\n+    'Aaaaaaa -> bool',\n+    'Aaaaaaa -> usize',\n+    'Read -> u64',\n+    'bool -> u64',\n+    'Ddddddd -> u64',\n+    '-> Ddddddd'\n+];\n+\n+const EXPECTED = [\n+    {\n+        // Aaaaaaa -> u32\n+        'others': [\n+            { 'path': 'generics_impl::Aaaaaaa', 'name': 'bbbbbbb' },\n+        ],\n+    },\n+    {\n+        // Aaaaaaa -> bool\n+        'others': [\n+            { 'path': 'generics_impl::Aaaaaaa', 'name': 'ccccccc' },\n+        ],\n+    },\n+    {\n+        // Aaaaaaa -> usize\n+        'others': [\n+            { 'path': 'generics_impl::Aaaaaaa', 'name': 'read' },\n+        ],\n+    },\n+    {\n+        // Read -> u64\n+        'others': [\n+            { 'path': 'generics_impl::Ddddddd', 'name': 'eeeeeee' },\n+            { 'path': 'generics_impl::Ddddddd', 'name': 'ggggggg' },\n+        ],\n+    },\n+    {\n+        // bool -> u64\n+        'others': [\n+            { 'path': 'generics_impl::Ddddddd', 'name': 'fffffff' },\n+        ],\n+    },\n+    {\n+        // Ddddddd -> u64\n+        'others': [\n+            { 'path': 'generics_impl::Ddddddd', 'name': 'ggggggg' },\n+        ],\n+    },\n+    {\n+        // -> \"Ddddddd\"\n+        'returned': [\n+            { 'path': 'generics_impl::Ddddddd', 'name': 'hhhhhhh' },\n+        ],\n+    },\n+];"}, {"sha": "696218021d5afa9d26e4fa3a488c3d672a6c1cdc", "filename": "src/test/rustdoc-js/generics-impl.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b9ed8784b3f6ffd16d562198cfef5f66a0253a18/src%2Ftest%2Frustdoc-js%2Fgenerics-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9ed8784b3f6ffd16d562198cfef5f66a0253a18/src%2Ftest%2Frustdoc-js%2Fgenerics-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fgenerics-impl.rs?ref=b9ed8784b3f6ffd16d562198cfef5f66a0253a18", "patch": "@@ -0,0 +1,35 @@\n+use std::io::{Result as IoResult, Read};\n+\n+pub struct Aaaaaaa;\n+\n+impl Aaaaaaa {\n+    pub fn bbbbbbb(self) -> u32 {\n+        1\n+    }\n+    pub fn ccccccc(&self) -> bool {\n+        true\n+    }\n+}\n+\n+impl Read for Aaaaaaa {\n+    fn read(&mut self, out: &mut [u8]) -> IoResult<usize> {\n+        Ok(out.len())\n+    }\n+}\n+\n+pub struct Ddddddd<T>(T);\n+\n+impl<T: Read> Ddddddd<T> {\n+    pub fn eeeeeee(_: T) -> u64 {\n+        1\n+    }\n+    pub fn fffffff(_: bool) -> u64 {\n+        1\n+    }\n+    pub fn ggggggg(self) -> u64 {\n+        1\n+    }\n+    pub fn hhhhhhh() -> Self where T: Default {\n+        Ddddddd(T::default())\n+    }\n+}"}]}