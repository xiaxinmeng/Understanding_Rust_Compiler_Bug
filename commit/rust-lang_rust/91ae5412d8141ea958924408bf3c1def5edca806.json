{"sha": "91ae5412d8141ea958924408bf3c1def5edca806", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYWU1NDEyZDgxNDFlYTk1ODkyNDQwOGJmM2MxZGVmNWVkY2E4MDY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-15T21:56:42Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-15T22:35:36Z"}, "message": "rustc: Merge module and type namespaces. r=brson", "tree": {"sha": "65e295ba7ac7159ea3f7fe172e1a241114ef5e2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65e295ba7ac7159ea3f7fe172e1a241114ef5e2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91ae5412d8141ea958924408bf3c1def5edca806", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91ae5412d8141ea958924408bf3c1def5edca806", "html_url": "https://github.com/rust-lang/rust/commit/91ae5412d8141ea958924408bf3c1def5edca806", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91ae5412d8141ea958924408bf3c1def5edca806/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5b82a65e96cfe77e4983e78a34a7d5aa91329b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5b82a65e96cfe77e4983e78a34a7d5aa91329b4", "html_url": "https://github.com/rust-lang/rust/commit/c5b82a65e96cfe77e4983e78a34a7d5aa91329b4"}], "stats": {"total": 1828, "additions": 877, "deletions": 951}, "files": [{"sha": "018972d4c3e0de742e174b7d84491ffa9ad1d9a3", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -104,7 +104,7 @@ pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n     }\n }\n \n-fn safe_to_steal_ty(t: @ast::ty, tm: test_mode) -> bool {\n+fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n     // Restrictions happen to be the same.\n     safe_to_replace_ty(t.node, tm)\n }\n@@ -119,16 +119,16 @@ fn stash_expr_if(c: fn@(@ast::expr, test_mode)->bool,\n     } else {/* now my indices are wrong :( */ }\n }\n \n-fn stash_ty_if(c: fn@(@ast::ty, test_mode)->bool,\n-               es: @mut ~[ast::ty],\n-               e: @ast::ty,\n+fn stash_ty_if(c: fn@(@ast::Ty, test_mode)->bool,\n+               es: @mut ~[ast::Ty],\n+               e: @ast::Ty,\n                tm: test_mode) {\n     if c(e, tm) {\n         es.push(*e);\n     } else {/* now my indices are wrong :( */ }\n }\n \n-type stolen_stuff = {exprs: ~[ast::expr], tys: ~[ast::ty]};\n+type stolen_stuff = {exprs: ~[ast::expr], tys: ~[ast::Ty]};\n \n fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n     let exprs = @mut ~[];\n@@ -195,7 +195,7 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint,\n \n \n // Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty,\n+fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n                        tm: test_mode) -> ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_ty_rep(j_: @mut uint, i_: uint, newty_: ast::ty_,\n@@ -225,7 +225,7 @@ fn as_str(f: fn@(+x: io::Writer)) -> ~str {\n     io::with_str_writer(f)\n }\n \n-fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n+fn check_variants_of_ast(crate: ast::crate, codemap: codemap::CodeMap,\n                          filename: &Path, cx: context) {\n     let stolen = steal(crate, cx.mode);\n     let extra_exprs = vec::filter(common_exprs(),\n@@ -239,7 +239,7 @@ fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n \n fn check_variants_T<T: Copy>(\n   crate: ast::crate,\n-  codemap: codemap::codemap,\n+  codemap: codemap::CodeMap,\n   filename: &Path,\n   thing_label: ~str,\n   things: ~[T],\n@@ -444,7 +444,7 @@ fn parse_and_print(code: @~str) -> ~str {\n \n fn has_raw_pointers(c: ast::crate) -> bool {\n     let has_rp = @mut false;\n-    fn visit_ty(flag: @mut bool, t: @ast::ty) {\n+    fn visit_ty(flag: @mut bool, t: @ast::Ty) {\n         match t.node {\n           ast::ty_ptr(_) => { *flag = true; }\n           _ => { }"}, {"sha": "46ac90413a6489367f6ad78f46f9f57d4ad84984", "filename": "src/libcore/cmath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibcore%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibcore%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmath.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -12,7 +12,7 @@ use libc::c_double;\n \n #[link_name = \"m\"]\n #[abi = \"cdecl\"]\n-pub extern mod c_double {\n+pub extern mod c_double_utils {\n \n     // Alpabetically sorted by link_name\n \n@@ -87,7 +87,7 @@ pub extern mod c_double {\n \n #[link_name = \"m\"]\n #[abi = \"cdecl\"]\n-pub extern mod c_float {\n+pub extern mod c_float_utils {\n \n     // Alpabetically sorted by link_name\n "}, {"sha": "ed6908d110d6d505de7d992c6f6e76c1be2b8ac9", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -4,7 +4,7 @@\n \n //! Operations and constants for `f32`\n \n-pub use cmath::c_float::*;\n+pub use cmath::c_float_utils::*;\n pub use cmath::c_float_targ_consts::*;\n \n // These are not defined inside consts:: for consistency with"}, {"sha": "2d13dc86e2fa57727d22fd2101d16ba864e94ad9", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -4,7 +4,7 @@\n \n //! Operations and constants for `f64`\n \n-pub use cmath::c_double::*;\n+pub use cmath::c_double_utils::*;\n pub use cmath::c_double_targ_consts::*;\n \n // FIXME (#1433): obtain these in a different way\n@@ -59,7 +59,7 @@ pub pure fn ge(x: f64, y: f64) -> bool { return x >= y; }\n pub pure fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n pub pure fn sqrt(x: f64) -> f64 {\n-    cmath::c_double::sqrt(x as libc::c_double) as f64\n+    cmath::c_double_utils::sqrt(x as libc::c_double) as f64\n }\n \n /// Returns true if `x` is a positive number, including +0.0f640 and +Infinity"}, {"sha": "7ed43f619e13e2cad1bbb3336fcdff892f0a023a", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -87,7 +87,7 @@ pub use funcs::extra::*;\n \n pub use size_t;\n pub use c_float, c_double, c_void, FILE, fpos_t;\n-pub use DIR, dirent;\n+pub use DIR, dirent_t;\n pub use c_char, c_schar, c_uchar;\n pub use c_short, c_ushort, c_int, c_uint, c_long, c_ulong;\n pub use size_t, ptrdiff_t, clock_t, time_t;\n@@ -147,7 +147,7 @@ mod types {\n         }\n         pub mod posix88 {\n             pub enum DIR {}\n-            pub enum dirent {}\n+            pub enum dirent_t {}\n         }\n         pub mod posix01 {}\n         pub mod posix08 {}\n@@ -1019,7 +1019,7 @@ pub mod funcs {\n         pub extern mod dirent {\n             fn opendir(dirname: *c_char) -> *DIR;\n             fn closedir(dirp: *DIR) -> c_int;\n-            fn readdir(dirp: *DIR) -> *dirent;\n+            fn readdir(dirp: *DIR) -> *dirent_t;\n             fn rewinddir(dirp: *DIR);\n             fn seekdir(dirp: *DIR, loc: c_long);\n             fn telldir(dirp: *DIR) -> c_long;"}, {"sha": "e3da15d181b7617ce1968f130e92fc800df05de8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -129,7 +129,7 @@ type path = {span: span,\n              global: bool,\n              idents: ~[ident],\n              rp: Option<@region>,\n-             types: ~[@ty]};\n+             types: ~[@Ty]};\n \n type crate_num = int;\n \n@@ -156,7 +156,7 @@ enum ty_param_bound {\n     bound_send,\n     bound_const,\n     bound_owned,\n-    bound_trait(@ty),\n+    bound_trait(@Ty),\n }\n \n #[auto_serialize]\n@@ -702,7 +702,7 @@ type initializer = {op: init_op, expr: @expr};\n // a refinement on pat.\n #[auto_serialize]\n #[auto_deserialize]\n-type local_ =  {is_mutbl: bool, ty: @ty, pat: @pat,\n+type local_ =  {is_mutbl: bool, ty: @Ty, pat: @pat,\n                 init: Option<initializer>, id: node_id};\n \n type local = spanned<local_>;\n@@ -764,7 +764,7 @@ enum expr_ {\n     expr_binary(binop, @expr, @expr),\n     expr_unary(unop, @expr),\n     expr_lit(@lit),\n-    expr_cast(@expr, @ty),\n+    expr_cast(@expr, @Ty),\n     expr_if(@expr, blk, Option<@expr>),\n     expr_while(@expr, blk),\n     /* Conditionless loop (can be exited with break, cont, ret, or fail)\n@@ -788,7 +788,7 @@ enum expr_ {\n     expr_assign(@expr, @expr),\n     expr_swap(@expr, @expr),\n     expr_assign_op(binop, @expr, @expr),\n-    expr_field(@expr, ident, ~[@ty]),\n+    expr_field(@expr, ident, ~[@Ty]),\n     expr_index(@expr, @expr),\n     expr_path(@path),\n     expr_addr_of(mutability, @expr),\n@@ -843,10 +843,10 @@ type capture_clause = @~[capture_item];\n #[auto_deserialize]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n enum token_tree {\n-    tt_tok(span, token::token),\n+    tt_tok(span, token::Token),\n     tt_delim(~[token_tree]),\n     // These only make sense for right-hand-sides of MBE macros\n-    tt_seq(span, ~[token_tree], Option<token::token>, bool),\n+    tt_seq(span, ~[token_tree], Option<token::Token>, bool),\n     tt_nonterminal(span, ident)\n }\n \n@@ -908,10 +908,10 @@ type matcher = spanned<matcher_>;\n #[auto_deserialize]\n enum matcher_ {\n     // match one token\n-    match_tok(token::token),\n+    match_tok(token::Token),\n     // match repetitions of a sequence: body, separator, zero ok?,\n     // lo, hi position-in-match-array used:\n-    match_seq(~[matcher], Option<token::token>, bool, uint, uint),\n+    match_seq(~[matcher], Option<token::Token>, bool, uint, uint),\n     // parse a Rust NT: name to bind, name of NT, position in match array:\n     match_nonterminal(ident, ident, uint)\n }\n@@ -984,7 +984,7 @@ impl ast::lit_: cmp::Eq {\n // type structure in middle/ty.rs as well.\n #[auto_serialize]\n #[auto_deserialize]\n-type mt = {ty: @ty, mutbl: mutability};\n+type mt = {ty: @Ty, mutbl: mutability};\n \n #[auto_serialize]\n #[auto_deserialize]\n@@ -1087,7 +1087,7 @@ impl float_ty : cmp::Eq {\n \n #[auto_serialize]\n #[auto_deserialize]\n-type ty = {id: node_id, node: ty_, span: span};\n+type Ty = {id: node_id, node: ty_, span: span};\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n #[auto_serialize]\n@@ -1163,9 +1163,9 @@ enum ty_ {\n     ty_rptr(@region, mt),\n     ty_rec(~[ty_field]),\n     ty_fn(proto, purity, @~[ty_param_bound], fn_decl),\n-    ty_tup(~[@ty]),\n+    ty_tup(~[@Ty]),\n     ty_path(@path, node_id),\n-    ty_fixed_length(@ty, Option<uint>),\n+    ty_fixed_length(@Ty, Option<uint>),\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n@@ -1175,16 +1175,16 @@ enum ty_ {\n \n // Equality and byte-iter (hashing) can be quite approximate for AST types.\n // since we only care about this for normalizing them to \"real\" types.\n-impl ty : cmp::Eq {\n-    pure fn eq(other: &ty) -> bool {\n+impl Ty : cmp::Eq {\n+    pure fn eq(other: &Ty) -> bool {\n         ptr::addr_of(&self) == ptr::addr_of(&(*other))\n     }\n-    pure fn ne(other: &ty) -> bool {\n+    pure fn ne(other: &Ty) -> bool {\n         ptr::addr_of(&self) != ptr::addr_of(&(*other))\n     }\n }\n \n-impl ty : to_bytes::IterBytes {\n+impl Ty : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n     }\n@@ -1193,13 +1193,13 @@ impl ty : to_bytes::IterBytes {\n \n #[auto_serialize]\n #[auto_deserialize]\n-type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n+type arg = {mode: mode, ty: @Ty, ident: ident, id: node_id};\n \n #[auto_serialize]\n #[auto_deserialize]\n type fn_decl =\n     {inputs: ~[arg],\n-     output: @ty,\n+     output: @Ty,\n      cf: ret_style};\n \n #[auto_serialize]\n@@ -1362,7 +1362,7 @@ type foreign_mod =\n \n #[auto_serialize]\n #[auto_deserialize]\n-type variant_arg = {ty: @ty, id: node_id};\n+type variant_arg = {ty: @Ty, id: node_id};\n \n #[auto_serialize]\n #[auto_deserialize]\n@@ -1495,7 +1495,7 @@ impl visibility : cmp::Eq {\n type struct_field_ = {\n     kind: struct_field_kind,\n     id: node_id,\n-    ty: @ty\n+    ty: @Ty\n };\n \n type struct_field = spanned<struct_field_>;\n@@ -1531,17 +1531,17 @@ type item = {ident: ident, attrs: ~[attribute],\n #[auto_serialize]\n #[auto_deserialize]\n enum item_ {\n-    item_const(@ty, @expr),\n+    item_const(@Ty, @expr),\n     item_fn(fn_decl, purity, ~[ty_param], blk),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n-    item_ty(@ty, ~[ty_param]),\n+    item_ty(@Ty, ~[ty_param]),\n     item_enum(enum_def, ~[ty_param]),\n     item_class(@struct_def, ~[ty_param]),\n     item_trait(~[ty_param], ~[@trait_ref], ~[trait_method]),\n     item_impl(~[ty_param],\n               Option<@trait_ref>, /* (optional) trait this impl implements */\n-              @ty, /* self */\n+              @Ty, /* self */\n               ~[@method]),\n     item_mac(mac),\n }\n@@ -1601,7 +1601,7 @@ type foreign_item =\n #[auto_deserialize]\n enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, ~[ty_param]),\n-    foreign_item_const(@ty)\n+    foreign_item_const(@Ty)\n }\n \n // The data we save and restore about an inlined item or method.  This is not"}, {"sha": "6fd84c3317f72abf55b0a234aa9be80ca0c5d255", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -471,7 +471,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_expr_post: fn@(_e: @expr) {\n         },\n \n-        visit_ty: fn@(t: @ty) {\n+        visit_ty: fn@(t: @Ty) {\n             match t.node {\n               ty_path(_, id) => vfn(id),\n               _ => { /* fall through */ }"}, {"sha": "0cb8b425c942e0305bc449f1849e9adc8e6b14ac", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -7,7 +7,7 @@ export file_substr;\n export fss_none;\n export fss_internal;\n export fss_external;\n-export codemap;\n+export CodeMap;\n export expn_info;\n export expn_info_;\n export expanded_from;\n@@ -55,11 +55,11 @@ type filemap =\n     @{name: filename, substr: file_substr, src: @~str,\n       start_pos: file_pos, mut lines: ~[file_pos]};\n \n-type codemap = @{files: DVec<filemap>};\n+type CodeMap = @{files: DVec<filemap>};\n \n type loc = {file: filemap, line: uint, col: uint};\n \n-fn new_codemap() -> codemap { @{files: DVec()} }\n+fn new_codemap() -> CodeMap { @{files: DVec()} }\n \n fn new_filemap_w_substr(+filename: filename, +substr: file_substr,\n                         src: @~str,\n@@ -77,7 +77,7 @@ fn new_filemap(+filename: filename, src: @~str,\n                              start_pos_ch, start_pos_byte);\n }\n \n-fn mk_substr_filename(cm: codemap, sp: span) -> ~str\n+fn mk_substr_filename(cm: CodeMap, sp: span) -> ~str\n {\n     let pos = lookup_char_pos(cm, sp.lo);\n     return fmt!(\"<%s:%u:%u>\", pos.file.name, pos.line, pos.col);\n@@ -89,7 +89,7 @@ fn next_line(file: filemap, chpos: uint, byte_pos: uint) {\n \n type lookup_fn = pure fn(file_pos) -> uint;\n \n-fn lookup_line(map: codemap, pos: uint, lookup: lookup_fn)\n+fn lookup_line(map: CodeMap, pos: uint, lookup: lookup_fn)\n     -> {fm: filemap, line: uint}\n {\n     let len = map.files.len();\n@@ -112,22 +112,22 @@ fn lookup_line(map: codemap, pos: uint, lookup: lookup_fn)\n     return {fm: f, line: a};\n }\n \n-fn lookup_pos(map: codemap, pos: uint, lookup: lookup_fn) -> loc {\n+fn lookup_pos(map: CodeMap, pos: uint, lookup: lookup_fn) -> loc {\n     let {fm: f, line: a} = lookup_line(map, pos, lookup);\n     return {file: f, line: a + 1u, col: pos - lookup(f.lines[a])};\n }\n \n-fn lookup_char_pos(map: codemap, pos: uint) -> loc {\n+fn lookup_char_pos(map: CodeMap, pos: uint) -> loc {\n     pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n     return lookup_pos(map, pos, lookup);\n }\n \n-fn lookup_byte_pos(map: codemap, pos: uint) -> loc {\n+fn lookup_byte_pos(map: CodeMap, pos: uint) -> loc {\n     pure fn lookup(pos: file_pos) -> uint { return pos.byte; }\n     return lookup_pos(map, pos, lookup);\n }\n \n-fn lookup_char_pos_adj(map: codemap, pos: uint)\n+fn lookup_char_pos_adj(map: CodeMap, pos: uint)\n     -> {filename: ~str, line: uint, col: uint, file: Option<filemap>}\n {\n     let loc = lookup_char_pos(map, pos);\n@@ -150,7 +150,7 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n     }\n }\n \n-fn adjust_span(map: codemap, sp: span) -> span {\n+fn adjust_span(map: CodeMap, sp: span) -> span {\n     pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n     let line = lookup_line(map, sp.lo, lookup);\n     match (line.fm.substr) {\n@@ -178,14 +178,14 @@ impl span : cmp::Eq {\n     pure fn ne(other: &span) -> bool { !self.eq(other) }\n }\n \n-fn span_to_str_no_adj(sp: span, cm: codemap) -> ~str {\n+fn span_to_str_no_adj(sp: span, cm: CodeMap) -> ~str {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n     return fmt!(\"%s:%u:%u: %u:%u\", lo.file.name,\n              lo.line, lo.col, hi.line, hi.col)\n }\n \n-fn span_to_str(sp: span, cm: codemap) -> ~str {\n+fn span_to_str(sp: span, cm: CodeMap) -> ~str {\n     let lo = lookup_char_pos_adj(cm, sp.lo);\n     let hi = lookup_char_pos_adj(cm, sp.hi);\n     return fmt!(\"%s:%u:%u: %u:%u\", lo.filename,\n@@ -194,12 +194,12 @@ fn span_to_str(sp: span, cm: codemap) -> ~str {\n \n type file_lines = {file: filemap, lines: ~[uint]};\n \n-fn span_to_filename(sp: span, cm: codemap::codemap) -> filename {\n+fn span_to_filename(sp: span, cm: codemap::CodeMap) -> filename {\n     let lo = lookup_char_pos(cm, sp.lo);\n     return /* FIXME (#2543) */ copy lo.file.name;\n }\n \n-fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n+fn span_to_lines(sp: span, cm: codemap::CodeMap) -> @file_lines {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n     let mut lines = ~[];\n@@ -218,7 +218,7 @@ fn get_line(fm: filemap, line: int) -> ~str unsafe {\n     str::slice(*fm.src, begin, end)\n }\n \n-fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)\n+fn lookup_byte_offset(cm: codemap::CodeMap, chpos: uint)\n     -> {fm: filemap, pos: uint} {\n     pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n     let {fm, line} = lookup_line(cm, chpos, lookup);\n@@ -228,20 +228,20 @@ fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)\n     {fm: fm, pos: line_offset + col_offset}\n }\n \n-fn span_to_snippet(sp: span, cm: codemap::codemap) -> ~str {\n+fn span_to_snippet(sp: span, cm: codemap::CodeMap) -> ~str {\n     let begin = lookup_byte_offset(cm, sp.lo);\n     let end = lookup_byte_offset(cm, sp.hi);\n     assert begin.fm.start_pos == end.fm.start_pos;\n     return str::slice(*begin.fm.src, begin.pos, end.pos);\n }\n \n-fn get_snippet(cm: codemap::codemap, fidx: uint, lo: uint, hi: uint) -> ~str\n+fn get_snippet(cm: codemap::CodeMap, fidx: uint, lo: uint, hi: uint) -> ~str\n {\n     let fm = cm.files[fidx];\n     return str::slice(*fm.src, lo, hi)\n }\n \n-fn get_filemap(cm: codemap, filename: ~str) -> filemap {\n+fn get_filemap(cm: CodeMap, filename: ~str) -> filemap {\n     for cm.files.each |fm| { if fm.name == filename { return *fm; } }\n     //XXjdm the following triggers a mismatched type bug\n     //      (or expected function, found _|_)"}, {"sha": "855b0ca3ef56879a3c17e6c266dfbf91e9b9f0ad", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -9,7 +9,7 @@ export codemap_span_handler, codemap_handler;\n export ice_msg;\n export expect;\n \n-type emitter = fn@(cmsp: Option<(codemap::codemap, span)>,\n+type emitter = fn@(cmsp: Option<(codemap::CodeMap, span)>,\n                    msg: &str, lvl: level);\n \n \n@@ -33,7 +33,7 @@ trait handler {\n     fn note(msg: &str);\n     fn bug(msg: &str) -> !;\n     fn unimpl(msg: &str) -> !;\n-    fn emit(cmsp: Option<(codemap::codemap, span)>, msg: &str, lvl: level);\n+    fn emit(cmsp: Option<(codemap::CodeMap, span)>, msg: &str, lvl: level);\n }\n \n type handler_t = @{\n@@ -43,7 +43,7 @@ type handler_t = @{\n \n type codemap_t = @{\n     handler: handler,\n-    cm: codemap::codemap\n+    cm: codemap::CodeMap\n };\n \n impl codemap_t: span_handler {\n@@ -107,7 +107,7 @@ impl handler_t: handler {\n         self.fatal(ice_msg(msg));\n     }\n     fn unimpl(msg: &str) -> ! { self.bug(~\"unimplemented \" + msg); }\n-    fn emit(cmsp: Option<(codemap::codemap, span)>, msg: &str, lvl: level) {\n+    fn emit(cmsp: Option<(codemap::CodeMap, span)>, msg: &str, lvl: level) {\n         self.emit(cmsp, msg, lvl);\n     }\n }\n@@ -116,7 +116,7 @@ fn ice_msg(msg: &str) -> ~str {\n     fmt!(\"internal compiler error: %s\", msg)\n }\n \n-fn mk_span_handler(handler: handler, cm: codemap::codemap) -> span_handler {\n+fn mk_span_handler(handler: handler, cm: codemap::CodeMap) -> span_handler {\n     @{ handler: handler, cm: cm } as span_handler\n }\n \n@@ -125,7 +125,7 @@ fn mk_handler(emitter: Option<emitter>) -> handler {\n     let emit = match emitter {\n       Some(e) => e,\n       None => {\n-        let f = fn@(cmsp: Option<(codemap::codemap, span)>,\n+        let f = fn@(cmsp: Option<(codemap::CodeMap, span)>,\n             msg: &str, t: level) {\n             emit(cmsp, msg, t);\n         };\n@@ -189,8 +189,7 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: &str) {\n     io::stderr().write_str(fmt!(\" %s\\n\", msg));\n }\n \n-fn emit(cmsp: Option<(codemap::codemap, span)>,\n-        msg: &str, lvl: level) {\n+fn emit(cmsp: Option<(codemap::CodeMap, span)>, msg: &str, lvl: level) {\n     match cmsp {\n       Some((cm, sp)) => {\n         let sp = codemap::adjust_span(cm,sp);\n@@ -206,7 +205,7 @@ fn emit(cmsp: Option<(codemap::codemap, span)>,\n     }\n }\n \n-fn highlight_lines(cm: codemap::codemap, sp: span,\n+fn highlight_lines(cm: codemap::CodeMap, sp: span,\n                    lines: @codemap::file_lines) {\n \n     let fm = lines.file;\n@@ -261,7 +260,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     }\n }\n \n-fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n+fn print_macro_backtrace(cm: codemap::CodeMap, sp: span) {\n     do option::iter(&sp.expn_info) |ei| {\n         let ss = option::map_default(&ei.callie.span, @~\"\",\n                                      |span| @codemap::span_to_str(*span, cm));"}, {"sha": "7e5e68ffff90efe82c9cd5dac69369c6db9ff8c6", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -250,12 +250,12 @@ priv impl ext_ctxt {\n     }\n \n     fn path_tps(span: span, strs: ~[ast::ident],\n-                tps: ~[@ast::ty]) -> @ast::path {\n+                tps: ~[@ast::Ty]) -> @ast::path {\n         @{span: span, global: false, idents: strs, rp: None, types: tps}\n     }\n \n     fn ty_path(span: span, strs: ~[ast::ident],\n-               tps: ~[@ast::ty]) -> @ast::ty {\n+               tps: ~[@ast::Ty]) -> @ast::Ty {\n         @{id: self.next_id(),\n           node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n           span: span}\n@@ -360,7 +360,7 @@ fn mk_impl(\n     ty_param: ast::ty_param,\n     path: @ast::path,\n     tps: ~[ast::ty_param],\n-    f: fn(@ast::ty) -> @ast::method\n+    f: fn(@ast::Ty) -> @ast::method\n ) -> @ast::item {\n     // All the type parameters need to bound to the trait.\n     let mut trait_tps = vec::append(\n@@ -549,7 +549,7 @@ fn mk_ser_method(\n fn mk_deser_method(\n     cx: ext_ctxt,\n     span: span,\n-    ty: @ast::ty,\n+    ty: @ast::Ty,\n     deser_body: ast::blk\n ) -> @ast::method {\n     let ty_d = @{"}, {"sha": "5b4cc23ce09fd8095352ec0ba45e6d7d2acfecb0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,7 +1,7 @@\n use std::map::HashMap;\n use parse::parser;\n use diagnostic::span_handler;\n-use codemap::{codemap, span, expn_info, expanded_from};\n+use codemap::{CodeMap, span, expn_info, expanded_from};\n \n // obsolete old-style #macro code:\n //\n@@ -124,7 +124,7 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n trait ext_ctxt {\n-    fn codemap() -> codemap;\n+    fn codemap() -> CodeMap;\n     fn parse_sess() -> parse::parse_sess;\n     fn cfg() -> ast::crate_cfg;\n     fn print_backtrace();\n@@ -156,7 +156,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n                       mut mod_path: ~[ast::ident],\n                       mut trace_mac: bool};\n     impl ctxt_repr: ext_ctxt {\n-        fn codemap() -> codemap { self.parse_sess.cm }\n+        fn codemap() -> CodeMap { self.parse_sess.cm }\n         fn parse_sess() -> parse::parse_sess { self.parse_sess }\n         fn cfg() -> ast::crate_cfg { self.cfg }\n         fn print_backtrace() { }"}, {"sha": "4d04552bfa15ae12c014695ec3074e936dfc99c1", "filename": "src/libsyntax/ext/pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -37,7 +37,7 @@ use codemap::span;\n use ext::base::ext_ctxt;\n use ast::tt_delim;\n use parse::lexer::{new_tt_reader, reader};\n-use parse::parser::{parser, SOURCE_FILE};\n+use parse::parser::{Parser, SOURCE_FILE};\n use parse::common::parser_common;\n \n use pipes::parse_proto::proto_parser;\n@@ -52,7 +52,7 @@ fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n     let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                cx.parse_sess().interner, None, tt);\n     let rdr = tt_rdr as reader;\n-    let rust_parser = parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n+    let rust_parser = Parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n \n     let proto = rust_parser.parse_proto(cx.str_of(id));\n "}, {"sha": "f10cbc2a5898a349685559e6b1cbf9fedc330611", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -28,17 +28,17 @@ fn empty_span() -> span {\n }\n \n trait append_types {\n-    fn add_ty(ty: @ast::ty) -> @ast::path;\n-    fn add_tys(+tys: ~[@ast::ty]) -> @ast::path;\n+    fn add_ty(ty: @ast::Ty) -> @ast::path;\n+    fn add_tys(+tys: ~[@ast::Ty]) -> @ast::path;\n }\n \n impl @ast::path: append_types {\n-    fn add_ty(ty: @ast::ty) -> @ast::path {\n+    fn add_ty(ty: @ast::Ty) -> @ast::path {\n         @{types: vec::append_one(self.types, ty),\n           .. *self}\n     }\n \n-    fn add_tys(+tys: ~[@ast::ty]) -> @ast::path {\n+    fn add_tys(+tys: ~[@ast::Ty]) -> @ast::path {\n         @{types: vec::append(self.types, tys),\n           .. *self}\n     }\n@@ -47,48 +47,48 @@ impl @ast::path: append_types {\n trait ext_ctxt_ast_builder {\n     fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n         -> ast::ty_param;\n-    fn arg(name: ident, ty: @ast::ty) -> ast::arg;\n+    fn arg(name: ident, ty: @ast::Ty) -> ast::arg;\n     fn expr_block(e: @ast::expr) -> ast::blk;\n-    fn fn_decl(+inputs: ~[ast::arg], output: @ast::ty) -> ast::fn_decl;\n+    fn fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n     fn item(name: ident, span: span, +node: ast::item_) -> @ast::item;\n     fn item_fn_poly(name: ident,\n                     +inputs: ~[ast::arg],\n-                    output: @ast::ty,\n+                    output: @ast::Ty,\n                     +ty_params: ~[ast::ty_param],\n                     +body: ast::blk) -> @ast::item;\n     fn item_fn(name: ident,\n                +inputs: ~[ast::arg],\n-               output: @ast::ty,\n+               output: @ast::Ty,\n                +body: ast::blk) -> @ast::item;\n     fn item_enum_poly(name: ident,\n                       span: span,\n                       +enum_definition: ast::enum_def,\n                       +ty_params: ~[ast::ty_param]) -> @ast::item;\n     fn item_enum(name: ident, span: span,\n                  +enum_definition: ast::enum_def) -> @ast::item;\n-    fn variant(name: ident, span: span, +tys: ~[@ast::ty]) -> ast::variant;\n+    fn variant(name: ident, span: span, +tys: ~[@ast::Ty]) -> ast::variant;\n     fn item_mod(name: ident, span: span, +items: ~[@ast::item]) -> @ast::item;\n-    fn ty_path_ast_builder(path: @ast::path) -> @ast::ty;\n+    fn ty_path_ast_builder(path: @ast::path) -> @ast::Ty;\n     fn item_ty_poly(name: ident,\n                     span: span,\n-                    ty: @ast::ty,\n+                    ty: @ast::Ty,\n                     +params: ~[ast::ty_param]) -> @ast::item;\n-    fn item_ty(name: ident, span: span, ty: @ast::ty) -> @ast::item;\n-    fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::ty];\n-    fn ty_field_imm(name: ident, ty: @ast::ty) -> ast::ty_field;\n-    fn ty_rec(+v: ~[ast::ty_field]) -> @ast::ty;\n+    fn item_ty(name: ident, span: span, ty: @ast::Ty) -> @ast::item;\n+    fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::Ty];\n+    fn ty_field_imm(name: ident, ty: @ast::Ty) -> ast::ty_field;\n+    fn ty_rec(+v: ~[ast::ty_field]) -> @ast::Ty;\n     fn field_imm(name: ident, e: @ast::expr) -> ast::field;\n     fn rec(+v: ~[ast::field]) -> @ast::expr;\n     fn block(+stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk;\n     fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt;\n     fn stmt_expr(e: @ast::expr) -> @ast::stmt;\n     fn block_expr(b: ast::blk) -> @ast::expr;\n     fn empty_span() -> span;\n-    fn ty_option(ty: @ast::ty) -> @ast::ty;\n+    fn ty_option(ty: @ast::Ty) -> @ast::Ty;\n }\n \n impl ext_ctxt: ext_ctxt_ast_builder {\n-    fn ty_option(ty: @ast::ty) -> @ast::ty {\n+    fn ty_option(ty: @ast::Ty) -> @ast::Ty {\n         self.ty_path_ast_builder(path(~[self.ident_of(~\"Option\")],\n                                       self.empty_span())\n                                  .add_ty(ty))\n@@ -146,18 +146,18 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n           span: self.empty_span()}\n     }\n \n-    fn ty_field_imm(name: ident, ty: @ast::ty) -> ast::ty_field {\n+    fn ty_field_imm(name: ident, ty: @ast::Ty) -> ast::ty_field {\n         {node: {ident: name, mt: { ty: ty, mutbl: ast::m_imm } },\n           span: self.empty_span()}\n     }\n \n-    fn ty_rec(+fields: ~[ast::ty_field]) -> @ast::ty {\n+    fn ty_rec(+fields: ~[ast::ty_field]) -> @ast::Ty {\n         @{id: self.next_id(),\n           node: ast::ty_rec(fields),\n           span: self.empty_span()}\n     }\n \n-    fn ty_infer() -> @ast::ty {\n+    fn ty_infer() -> @ast::Ty {\n         @{id: self.next_id(),\n           node: ast::ty_infer,\n           span: self.empty_span()}\n@@ -169,7 +169,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n         {ident: id, id: self.next_id(), bounds: @bounds}\n     }\n \n-    fn arg(name: ident, ty: @ast::ty) -> ast::arg {\n+    fn arg(name: ident, ty: @ast::Ty) -> ast::arg {\n         {mode: ast::infer(self.next_id()),\n          ty: ty,\n          ident: name,\n@@ -192,7 +192,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn fn_decl(+inputs: ~[ast::arg],\n-               output: @ast::ty) -> ast::fn_decl {\n+               output: @ast::Ty) -> ast::fn_decl {\n         {inputs: inputs,\n          output: output,\n          cf: ast::return_val}\n@@ -224,7 +224,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n \n     fn item_fn_poly(name: ident,\n                     +inputs: ~[ast::arg],\n-                    output: @ast::ty,\n+                    output: @ast::Ty,\n                     +ty_params: ~[ast::ty_param],\n                     +body: ast::blk) -> @ast::item {\n         self.item(name,\n@@ -237,7 +237,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n \n     fn item_fn(name: ident,\n                +inputs: ~[ast::arg],\n-               output: @ast::ty,\n+               output: @ast::Ty,\n                +body: ast::blk) -> @ast::item {\n         self.item_fn_poly(name, inputs, output, ~[], body)\n     }\n@@ -256,7 +256,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n \n     fn variant(name: ident,\n                span: span,\n-               +tys: ~[@ast::ty]) -> ast::variant {\n+               +tys: ~[@ast::Ty]) -> ast::variant {\n         let args = tys.map(|ty| {ty: *ty, id: self.next_id()});\n \n         {node: {name: name,\n@@ -278,30 +278,30 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n                       items: items}))\n     }\n \n-    fn ty_path_ast_builder(path: @ast::path) -> @ast::ty {\n+    fn ty_path_ast_builder(path: @ast::path) -> @ast::Ty {\n         @{id: self.next_id(),\n           node: ast::ty_path(path, self.next_id()),\n           span: path.span}\n     }\n \n-    fn ty_nil_ast_builder() -> @ast::ty {\n+    fn ty_nil_ast_builder() -> @ast::Ty {\n         @{id: self.next_id(),\n           node: ast::ty_nil,\n           span: self.empty_span()}\n     }\n \n     fn item_ty_poly(name: ident,\n                     span: span,\n-                    ty: @ast::ty,\n+                    ty: @ast::Ty,\n                     +params: ~[ast::ty_param]) -> @ast::item {\n         self.item(name, span, ast::item_ty(ty, params))\n     }\n \n-    fn item_ty(name: ident, span: span, ty: @ast::ty) -> @ast::item {\n+    fn item_ty(name: ident, span: span, ty: @ast::Ty) -> @ast::item {\n         self.item_ty_poly(name, span, ty, ~[])\n     }\n \n-    fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::ty] {\n+    fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::Ty] {\n         ty_params.map(|p| self.ty_path_ast_builder(\n             path(~[p.ident], self.empty_span())))\n     }"}, {"sha": "fcc0c84a4ff391ae87a7069a72f2daf87bde4746", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -38,7 +38,7 @@ impl ext_ctxt: proto::visitor<(), (), ()>  {\n         }\n     }\n \n-    fn visit_message(name: ~str, _span: span, _tys: &[@ast::ty],\n+    fn visit_message(name: ~str, _span: span, _tys: &[@ast::Ty],\n                      this: state, next: next_state) {\n         match next {\n           Some({state: next, tys: next_tys}) => {\n@@ -68,4 +68,4 @@ impl ext_ctxt: proto::visitor<(), (), ()>  {\n           None => ()\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "8f2b92a720c0725d077c9dccd0caadd4571228e8", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -10,7 +10,7 @@ trait proto_parser {\n     fn parse_state(proto: protocol);\n }\n \n-impl parser: proto_parser {\n+impl parser::Parser: proto_parser {\n     fn parse_proto(id: ~str) -> protocol {\n         let proto = protocol(id, self.span);\n "}, {"sha": "7e1cbe9ad0dbfc4ed9b3e56108bd0675f2fecea3", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -181,7 +181,7 @@ impl message: gen_send {\n           }\n         }\n \n-    fn to_ty(cx: ext_ctxt) -> @ast::ty {\n+    fn to_ty(cx: ext_ctxt) -> @ast::Ty {\n         cx.ty_path_ast_builder(path(~[cx.ident_of(self.name())], self.span())\n           .add_tys(cx.ty_vars(self.get_params())))\n     }\n@@ -360,7 +360,7 @@ impl protocol: gen_init {\n         }}\n     }\n \n-    fn buffer_ty_path(cx: ext_ctxt) -> @ast::ty {\n+    fn buffer_ty_path(cx: ext_ctxt) -> @ast::Ty {\n         let mut params: ~[ast::ty_param] = ~[];\n         for (copy self.states).each |s| {\n             for s.ty_params.each |tp| {\n@@ -444,13 +444,13 @@ impl ~[@ast::item]: to_source {\n     }\n }\n \n-impl @ast::ty: to_source {\n+impl @ast::Ty: to_source {\n     fn to_source(cx: ext_ctxt) -> ~str {\n         ty_to_str(self, cx.parse_sess().interner)\n     }\n }\n \n-impl ~[@ast::ty]: to_source {\n+impl ~[@ast::Ty]: to_source {\n     fn to_source(cx: ext_ctxt) -> ~str {\n         str::connect(self.map(|i| i.to_source(cx)), ~\", \")\n     }"}, {"sha": "229e55fdfcc6a0462de6bf2bac59ff5b6b46ba16", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -35,11 +35,11 @@ impl direction {\n     }\n }\n \n-type next_state = Option<{state: ~str, tys: ~[@ast::ty]}>;\n+type next_state = Option<{state: ~str, tys: ~[@ast::Ty]}>;\n \n enum message {\n     // name, span, data, current state, next state\n-    message(~str, span, ~[@ast::ty], state, next_state)\n+    message(~str, span, ~[@ast::Ty], state, next_state)\n }\n \n impl message {\n@@ -78,7 +78,7 @@ enum state {\n \n impl state {\n     fn add_message(name: ~str, span: span,\n-                   +data: ~[@ast::ty], next: next_state) {\n+                   +data: ~[@ast::Ty], next: next_state) {\n         self.messages.push(message(name, span, data, self,\n                                    next));\n     }\n@@ -92,7 +92,7 @@ impl state {\n     }\n \n     /// Returns the type that is used for the messages.\n-    fn to_ty(cx: ext_ctxt) -> @ast::ty {\n+    fn to_ty(cx: ext_ctxt) -> @ast::Ty {\n         cx.ty_path_ast_builder\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n                 cx.ty_vars(self.ty_params)))\n@@ -200,7 +200,7 @@ impl protocol {\n trait visitor<Tproto, Tstate, Tmessage> {\n     fn visit_proto(proto: protocol, st: &[Tstate]) -> Tproto;\n     fn visit_state(state: state, m: &[Tmessage]) -> Tstate;\n-    fn visit_message(name: ~str, spane: span, tys: &[@ast::ty],\n+    fn visit_message(name: ~str, spane: span, tys: &[@ast::Ty],\n                      this: state, next: next_state) -> Tmessage;\n }\n "}, {"sha": "a83789642ccc88e36b0584158ce8e6bf47b3cc66", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,7 +1,7 @@\n use ast::{crate, expr_, mac_invoc,\n                      mac_aq, mac_var};\n use parse::parser;\n-use parse::parser::parse_from_source_str;\n+use parse::parser::{Parser, parse_from_source_str};\n use dvec::DVec;\n use parse::token::ident_interner;\n \n@@ -24,7 +24,7 @@ struct gather_item {\n type aq_ctxt = @{lo: uint, gather: DVec<gather_item>};\n enum fragment {\n     from_expr(@ast::expr),\n-    from_ty(@ast::ty)\n+    from_ty(@ast::Ty)\n }\n \n fn ids_ext(cx: ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n@@ -68,7 +68,7 @@ impl @ast::expr: qq_helper {\n     }\n     fn get_fold_fn() -> ~str {~\"fold_expr\"}\n }\n-impl @ast::ty: qq_helper {\n+impl @ast::Ty: qq_helper {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_ty(self, cx, v);}\n     fn extract_mac() -> Option<ast::mac_> {\n@@ -186,21 +186,21 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n     };\n }\n \n-fn parse_crate(p: parser) -> @ast::crate { p.parse_crate_mod(~[]) }\n-fn parse_ty(p: parser) -> @ast::ty { p.parse_ty(false) }\n-fn parse_stmt(p: parser) -> @ast::stmt { p.parse_stmt(~[]) }\n-fn parse_expr(p: parser) -> @ast::expr { p.parse_expr() }\n-fn parse_pat(p: parser) -> @ast::pat { p.parse_pat(true) }\n+fn parse_crate(p: Parser) -> @ast::crate { p.parse_crate_mod(~[]) }\n+fn parse_ty(p: Parser) -> @ast::Ty { p.parse_ty(false) }\n+fn parse_stmt(p: Parser) -> @ast::stmt { p.parse_stmt(~[]) }\n+fn parse_expr(p: Parser) -> @ast::expr { p.parse_expr() }\n+fn parse_pat(p: Parser) -> @ast::pat { p.parse_pat(true) }\n \n-fn parse_item(p: parser) -> @ast::item {\n+fn parse_item(p: Parser) -> @ast::item {\n     match p.parse_item(~[]) {\n       Some(item) => item,\n       None       => fail ~\"parse_item: parsing an item failed\"\n     }\n }\n \n fn finish<T: qq_helper>\n-    (ecx: ext_ctxt, body: ast::mac_body_, f: fn (p: parser) -> T)\n+    (ecx: ext_ctxt, body: ast::mac_body_, f: fn (p: Parser) -> T)\n     -> @ast::expr\n {\n     let cm = ecx.codemap();\n@@ -309,7 +309,7 @@ fn fold_crate(f: ast_fold, &&n: @ast::crate) -> @ast::crate {\n     @f.fold_crate(*n)\n }\n fn fold_expr(f: ast_fold, &&n: @ast::expr) -> @ast::expr {f.fold_expr(n)}\n-fn fold_ty(f: ast_fold, &&n: @ast::ty) -> @ast::ty {f.fold_ty(n)}\n+fn fold_ty(f: ast_fold, &&n: @ast::Ty) -> @ast::Ty {f.fold_ty(n)}\n fn fold_item(f: ast_fold, &&n: @ast::item) -> @ast::item {\n     f.fold_item(n).get() //HACK: we know we don't drop items\n }"}, {"sha": "bec29c9a8354013d5138f050f42dc70f39ce149a", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -6,7 +6,7 @@ use base::*;\n \n use fold::*;\n use ast_util::respan;\n-use ast::{ident, path, ty, blk_, expr, expr_path,\n+use ast::{ident, path, Ty, blk_, expr, expr_path,\n              expr_vec, expr_mac, mac_invoc, node_id, expr_index};\n \n export add_new_extension;\n@@ -29,7 +29,7 @@ enum matchable {\n     match_expr(@expr),\n     match_path(@path),\n     match_ident(ast::spanned<ident>),\n-    match_ty(@ty),\n+    match_ty(@Ty),\n     match_block(ast::blk),\n     match_exact, /* don't bind anything, just verify the AST traversal */\n }"}, {"sha": "0c7d408db7cc3e802e5c8ea8c78083dff21602c1", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -2,7 +2,7 @@ use codemap::span;\n use ext::base::ext_ctxt;\n use ast::tt_delim;\n use parse::lexer::{new_tt_reader, reader};\n-use parse::parser::{parser, SOURCE_FILE};\n+use parse::parser::{Parser, SOURCE_FILE};\n use parse::common::parser_common;\n \n fn expand_trace_macros(cx: ext_ctxt, sp: span,\n@@ -13,15 +13,15 @@ fn expand_trace_macros(cx: ext_ctxt, sp: span,\n     let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                cx.parse_sess().interner, None, tt);\n     let rdr = tt_rdr as reader;\n-    let rust_parser = parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n+    let rust_parser = Parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n \n     let arg = cx.str_of(rust_parser.parse_ident());\n     match arg {\n       ~\"true\"  => cx.set_trace_macros(true),\n       ~\"false\" => cx.set_trace_macros(false),\n       _ => cx.span_fatal(sp, ~\"trace_macros! only accepts `true` or `false`\")\n     }\n-    let rust_parser = parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n+    let rust_parser = Parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n     let result = rust_parser.parse_expr();\n     base::mr_expr(result)\n }"}, {"sha": "17122b85fb3608c282c5211e383a4a5e73334c2e", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,9 +1,9 @@\n // Earley-like parser for macros.\n use parse::token;\n-use parse::token::{token, EOF, to_str, nonterminal};\n+use parse::token::{Token, EOF, to_str, nonterminal};\n use parse::lexer::*; //resolve bug?\n //import parse::lexer::{reader, tt_reader, tt_reader_as_reader};\n-use parse::parser::{parser,SOURCE_FILE};\n+use parse::parser::{Parser, SOURCE_FILE};\n //import parse::common::parser_common;\n use parse::common::*; //resolve bug?\n use parse::parse_sess;\n@@ -97,7 +97,7 @@ fn is_some(&&mpu: matcher_pos_up) -> bool {\n \n type matcher_pos = ~{\n     elts: ~[ast::matcher], // maybe should be /&? Need to understand regions.\n-    sep: Option<token>,\n+    sep: Option<Token>,\n     mut idx: uint,\n     mut up: matcher_pos_up, // mutable for swapping only\n     matches: ~[DVec<@named_match>],\n@@ -122,7 +122,7 @@ fn count_names(ms: &[matcher]) -> uint {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn initial_matcher_pos(ms: ~[matcher], sep: Option<token>, lo: uint)\n+fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: uint)\n     -> matcher_pos {\n     let mut match_idx_hi = 0u;\n     for ms.each() |elt| {\n@@ -354,7 +354,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n-                let rust_parser = parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n+                let rust_parser = Parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n \n                 let ei = bb_eis.pop();\n                 match ei.elts[ei.idx].node {\n@@ -381,7 +381,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n     }\n }\n \n-fn parse_nt(p: parser, name: ~str) -> nonterminal {\n+fn parse_nt(p: Parser, name: ~str) -> nonterminal {\n     match name {\n       ~\"item\" => match p.parse_item(~[]) {\n         Some(i) => token::nt_item(i),"}, {"sha": "31bc375a76d56cc373f53e5f4a67a56fc2125aac", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -4,7 +4,7 @@ use ast::{ident, matcher_, matcher, match_tok,\n              match_nonterminal, match_seq, tt_delim};\n use parse::lexer::{new_tt_reader, reader};\n use parse::token::{FAT_ARROW, SEMI, LBRACE, RBRACE, nt_matchers, nt_tt};\n-use parse::parser::{parser, SOURCE_FILE};\n+use parse::parser::{Parser, SOURCE_FILE};\n use macro_parser::{parse, parse_or_else, success, failure, named_match,\n                       matched_seq, matched_nonterminal, error};\n use std::map::HashMap;\n@@ -86,7 +86,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                     // rhs has holes ( `$id` and `$(...)` that need filled)\n                     let trncbr = new_tt_reader(s_d, itr, Some(named_matches),\n                                                ~[rhs]);\n-                    let p = parser(cx.parse_sess(), cx.cfg(),\n+                    let p = Parser(cx.parse_sess(), cx.cfg(),\n                                    trncbr as reader, SOURCE_FILE);\n                     let e = p.parse_expr();\n                     return mr_expr(e);\n@@ -111,4 +111,4 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n         name: *cx.parse_sess().interner.get(name),\n         ext: expr_tt({expander: exp, span: Some(sp)})\n     });\n-}\n\\ No newline at end of file\n+}"}, {"sha": "238f9db6ac5371ce9f83c216ed32858d863b0482", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -2,8 +2,7 @@ use diagnostic::span_handler;\n use ast::{token_tree, tt_delim, tt_tok, tt_seq, tt_nonterminal,ident};\n use macro_parser::{named_match, matched_seq, matched_nonterminal};\n use codemap::span;\n-use parse::token::{EOF, INTERPOLATED, IDENT, token, nt_ident,\n-                      ident_interner};\n+use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident, ident_interner};\n use std::map::HashMap;\n \n export tt_reader,  new_tt_reader, dup_tt_reader, tt_next_token;\n@@ -19,7 +18,7 @@ type tt_frame = @{\n     readme: ~[ast::token_tree],\n     mut idx: uint,\n     dotdotdoted: bool,\n-    sep: Option<token>,\n+    sep: Option<Token>,\n     up: tt_frame_up,\n };\n \n@@ -32,7 +31,7 @@ type tt_reader = @{\n     mut repeat_idx: ~[uint],\n     mut repeat_len: ~[uint],\n     /* cached: */\n-    mut cur_tok: token,\n+    mut cur_tok: Token,\n     mut cur_span: span\n };\n \n@@ -134,7 +133,7 @@ fn lockstep_iter_size(t: token_tree, r: tt_reader) -> lis {\n }\n \n \n-fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n+fn tt_next_token(&&r: tt_reader) -> {tok: Token, sp: span} {\n     let ret_val = { tok: r.cur_tok, sp: r.cur_span };\n     while r.cur.idx >= r.cur.readme.len() {\n         /* done with this set; pop or repeat? */"}, {"sha": "564debefa25397ef2dcf49af590906db5c92d4b7", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -33,7 +33,7 @@ trait ast_fold {\n     fn fold_pat(&&v: @pat) -> @pat;\n     fn fold_decl(&&v: @decl) -> @decl;\n     fn fold_expr(&&v: @expr) -> @expr;\n-    fn fold_ty(&&v: @ty) -> @ty;\n+    fn fold_ty(&&v: @Ty) -> @Ty;\n     fn fold_mod(_mod) -> _mod;\n     fn fold_foreign_mod(foreign_mod) -> foreign_mod;\n     fn fold_variant(variant) -> variant;\n@@ -728,7 +728,7 @@ impl ast_fold_precursor: ast_fold {\n               node: n,\n               span: self.new_span(s)};\n     }\n-    fn fold_ty(&&x: @ty) -> @ty {\n+    fn fold_ty(&&x: @Ty) -> @Ty {\n         let (n, s) = self.fold_ty(x.node, x.span, self as ast_fold);\n         return @{id: self.new_id(x.id), node: n, span: self.new_span(s)};\n     }"}, {"sha": "e38ee7ff0376335fb4b73cbb9e4167b9610e0e09", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -12,7 +12,7 @@ export parse_expr_from_source_str, parse_item_from_source_str;\n export parse_stmt_from_source_str;\n export parse_from_source_str;\n \n-use parser::parser;\n+use parser::Parser;\n use attr::parser_attr;\n use common::parser_common;\n use ast::node_id;\n@@ -22,7 +22,7 @@ use lexer::{reader, string_reader};\n use parse::token::{ident_interner, mk_ident_interner};\n \n type parse_sess = @{\n-    cm: codemap::codemap,\n+    cm: codemap::CodeMap,\n     mut next_id: node_id,\n     span_diagnostic: span_handler,\n     interner: @ident_interner,\n@@ -40,7 +40,7 @@ fn new_parse_sess(demitter: Option<emitter>) -> parse_sess {\n              mut chpos: 0u, mut byte_pos: 0u};\n }\n \n-fn new_parse_sess_special_handler(sh: span_handler, cm: codemap::codemap)\n+fn new_parse_sess_special_handler(sh: span_handler, cm: codemap::CodeMap)\n     -> parse_sess {\n     return @{cm: cm,\n              mut next_id: 1,\n@@ -142,7 +142,7 @@ fn parse_stmt_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n     return r;\n }\n \n-fn parse_from_source_str<T>(f: fn (p: parser) -> T,\n+fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n                             name: ~str, ss: codemap::file_substr,\n                             source: @~str, cfg: ast::crate_cfg,\n                             sess: parse_sess)\n@@ -170,27 +170,27 @@ fn next_node_id(sess: parse_sess) -> node_id {\n \n fn new_parser_etc_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n                                   +name: ~str, +ss: codemap::file_substr,\n-                                  source: @~str) -> (parser, string_reader) {\n+                                  source: @~str) -> (Parser, string_reader) {\n     let ftype = parser::SOURCE_FILE;\n     let filemap = codemap::new_filemap_w_substr\n         (name, ss, source, sess.chpos, sess.byte_pos);\n     sess.cm.files.push(filemap);\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n                                         sess.interner);\n-    return (parser(sess, cfg, srdr as reader, ftype), srdr);\n+    return (Parser(sess, cfg, srdr as reader, ftype), srdr);\n }\n \n fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n                               +name: ~str, +ss: codemap::file_substr,\n-                              source: @~str) -> parser {\n+                              source: @~str) -> Parser {\n     let (p, _) = new_parser_etc_from_source_str(sess, cfg, name, ss, source);\n     move p\n }\n \n \n fn new_parser_etc_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n                             path: &Path, ftype: parser::file_type) ->\n-   (parser, string_reader) {\n+   (Parser, string_reader) {\n     let res = io::read_whole_file_str(path);\n     match res {\n       result::Ok(_) => { /* Continue. */ }\n@@ -202,18 +202,18 @@ fn new_parser_etc_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n     sess.cm.files.push(filemap);\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n                                         sess.interner);\n-    return (parser(sess, cfg, srdr as reader, ftype), srdr);\n+    return (Parser(sess, cfg, srdr as reader, ftype), srdr);\n }\n \n fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: &Path,\n-                        ftype: parser::file_type) -> parser {\n+                        ftype: parser::file_type) -> Parser {\n     let (p, _) = new_parser_etc_from_file(sess, cfg, path, ftype);\n     move p\n }\n \n fn new_parser_from_tt(sess: parse_sess, cfg: ast::crate_cfg,\n-                      tt: ~[ast::token_tree]) -> parser {\n+                      tt: ~[ast::token_tree]) -> Parser {\n     let trdr = lexer::new_tt_reader(sess.span_diagnostic, sess.interner,\n                                     None, tt);\n-    return parser(sess, cfg, trdr as reader, parser::SOURCE_FILE)\n+    return Parser(sess, cfg, trdr as reader, parser::SOURCE_FILE)\n }"}, {"sha": "42101a431d6c63d1b966a6287db10a36ebcddf51", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -23,7 +23,7 @@ trait parser_attr {\n     fn parse_optional_meta() -> ~[@ast::meta_item];\n }\n \n-impl parser: parser_attr {\n+impl Parser: parser_attr {\n \n     fn parse_outer_attrs_or_ext(first_item_attrs: ~[ast::attribute])\n         -> attr_or_ext"}, {"sha": "50c22c08f4f88a034ddd276a5fc414156bf8a269", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,63 +1,63 @@\n use std::map::{HashMap};\n use ast_util::spanned;\n-use parser::parser;\n+use parser::Parser;\n use lexer::reader;\n \n type seq_sep = {\n-    sep: Option<token::token>,\n+    sep: Option<token::Token>,\n     trailing_sep_allowed: bool\n };\n \n-fn seq_sep_trailing_disallowed(t: token::token) -> seq_sep {\n+fn seq_sep_trailing_disallowed(t: token::Token) -> seq_sep {\n     return {sep: option::Some(t), trailing_sep_allowed: false};\n }\n-fn seq_sep_trailing_allowed(t: token::token) -> seq_sep {\n+fn seq_sep_trailing_allowed(t: token::Token) -> seq_sep {\n     return {sep: option::Some(t), trailing_sep_allowed: true};\n }\n fn seq_sep_none() -> seq_sep {\n     return {sep: option::None, trailing_sep_allowed: false};\n }\n \n-fn token_to_str(reader: reader, ++token: token::token) -> ~str {\n+fn token_to_str(reader: reader, ++token: token::Token) -> ~str {\n     token::to_str(reader.interner(), token)\n }\n \n trait parser_common {\n-    fn unexpected_last(t: token::token) -> !;\n+    fn unexpected_last(t: token::Token) -> !;\n     fn unexpected() -> !;\n-    fn expect(t: token::token);\n+    fn expect(t: token::Token);\n     fn parse_ident() -> ast::ident;\n     fn parse_path_list_ident() -> ast::path_list_ident;\n     fn parse_value_ident() -> ast::ident;\n-    fn eat(tok: token::token) -> bool;\n+    fn eat(tok: token::Token) -> bool;\n     // A sanity check that the word we are asking for is a known keyword\n     fn require_keyword(word: ~str);\n-    fn token_is_keyword(word: ~str, ++tok: token::token) -> bool;\n+    fn token_is_keyword(word: ~str, ++tok: token::Token) -> bool;\n     fn is_keyword(word: ~str) -> bool;\n-    fn is_any_keyword(tok: token::token) -> bool;\n+    fn is_any_keyword(tok: token::Token) -> bool;\n     fn eat_keyword(word: ~str) -> bool;\n     fn expect_keyword(word: ~str);\n     fn expect_gt();\n-    fn parse_seq_to_before_gt<T: Copy>(sep: Option<token::token>,\n-                                       f: fn(parser) -> T) -> ~[T];\n-    fn parse_seq_to_gt<T: Copy>(sep: Option<token::token>,\n-                                f: fn(parser) -> T) -> ~[T];\n-    fn parse_seq_lt_gt<T: Copy>(sep: Option<token::token>,\n-                                f: fn(parser) -> T) -> spanned<~[T]>;\n-    fn parse_seq_to_end<T: Copy>(ket: token::token, sep: seq_sep,\n-                                 f: fn(parser) -> T) -> ~[T];\n-    fn parse_seq_to_before_end<T: Copy>(ket: token::token, sep: seq_sep,\n-                                        f: fn(parser) -> T) -> ~[T];\n-    fn parse_unspanned_seq<T: Copy>(bra: token::token,\n-                                    ket: token::token,\n+    fn parse_seq_to_before_gt<T: Copy>(sep: Option<token::Token>,\n+                                       f: fn(Parser) -> T) -> ~[T];\n+    fn parse_seq_to_gt<T: Copy>(sep: Option<token::Token>,\n+                                f: fn(Parser) -> T) -> ~[T];\n+    fn parse_seq_lt_gt<T: Copy>(sep: Option<token::Token>,\n+                                f: fn(Parser) -> T) -> spanned<~[T]>;\n+    fn parse_seq_to_end<T: Copy>(ket: token::Token, sep: seq_sep,\n+                                 f: fn(Parser) -> T) -> ~[T];\n+    fn parse_seq_to_before_end<T: Copy>(ket: token::Token, sep: seq_sep,\n+                                        f: fn(Parser) -> T) -> ~[T];\n+    fn parse_unspanned_seq<T: Copy>(bra: token::Token,\n+                                    ket: token::Token,\n                                     sep: seq_sep,\n-                                    f: fn(parser) -> T) -> ~[T];\n-    fn parse_seq<T: Copy>(bra: token::token, ket: token::token, sep: seq_sep,\n-                          f: fn(parser) -> T) -> spanned<~[T]>;\n+                                    f: fn(Parser) -> T) -> ~[T];\n+    fn parse_seq<T: Copy>(bra: token::Token, ket: token::Token, sep: seq_sep,\n+                          f: fn(Parser) -> T) -> spanned<~[T]>;\n }\n \n-impl parser: parser_common {\n-    fn unexpected_last(t: token::token) -> ! {\n+impl Parser: parser_common {\n+    fn unexpected_last(t: token::Token) -> ! {\n         self.span_fatal(\n             copy self.last_span,\n             ~\"unexpected token: `\" + token_to_str(self.reader, t) + ~\"`\");\n@@ -68,7 +68,7 @@ impl parser: parser_common {\n                    + token_to_str(self.reader, self.token) + ~\"`\");\n     }\n \n-    fn expect(t: token::token) {\n+    fn expect(t: token::Token) {\n         if self.token == t {\n             self.bump();\n         } else {\n@@ -104,7 +104,7 @@ impl parser: parser_common {\n         return self.parse_ident();\n     }\n \n-    fn eat(tok: token::token) -> bool {\n+    fn eat(tok: token::Token) -> bool {\n         return if self.token == tok { self.bump(); true } else { false };\n     }\n \n@@ -117,14 +117,14 @@ impl parser: parser_common {\n         }\n     }\n \n-    fn token_is_word(word: ~str, ++tok: token::token) -> bool {\n+    fn token_is_word(word: ~str, ++tok: token::Token) -> bool {\n         match tok {\n           token::IDENT(sid, false) => { *self.id_to_str(sid) == word }\n           _ => { false }\n         }\n     }\n \n-    fn token_is_keyword(word: ~str, ++tok: token::token) -> bool {\n+    fn token_is_keyword(word: ~str, ++tok: token::Token) -> bool {\n         self.require_keyword(word);\n         self.token_is_word(word, tok)\n     }\n@@ -133,7 +133,7 @@ impl parser: parser_common {\n         self.token_is_keyword(word, self.token)\n     }\n \n-    fn is_any_keyword(tok: token::token) -> bool {\n+    fn is_any_keyword(tok: token::Token) -> bool {\n         match tok {\n           token::IDENT(sid, false) => {\n             self.keywords.contains_key_ref(self.id_to_str(sid))\n@@ -216,8 +216,8 @@ impl parser: parser_common {\n         }\n     }\n \n-    fn parse_seq_to_before_gt<T: Copy>(sep: Option<token::token>,\n-                                       f: fn(parser) -> T) -> ~[T] {\n+    fn parse_seq_to_before_gt<T: Copy>(sep: Option<token::Token>,\n+                                       f: fn(Parser) -> T) -> ~[T] {\n         let mut first = true;\n         let mut v = ~[];\n         while self.token != token::GT\n@@ -235,16 +235,16 @@ impl parser: parser_common {\n         return v;\n     }\n \n-    fn parse_seq_to_gt<T: Copy>(sep: Option<token::token>,\n-                                f: fn(parser) -> T) -> ~[T] {\n+    fn parse_seq_to_gt<T: Copy>(sep: Option<token::Token>,\n+                                f: fn(Parser) -> T) -> ~[T] {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n \n         return v;\n     }\n \n-    fn parse_seq_lt_gt<T: Copy>(sep: Option<token::token>,\n-                                f: fn(parser) -> T) -> spanned<~[T]> {\n+    fn parse_seq_lt_gt<T: Copy>(sep: Option<token::Token>,\n+                                f: fn(Parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(token::LT);\n         let result = self.parse_seq_to_before_gt::<T>(sep, f);\n@@ -253,16 +253,16 @@ impl parser: parser_common {\n         return spanned(lo, hi, result);\n     }\n \n-    fn parse_seq_to_end<T: Copy>(ket: token::token, sep: seq_sep,\n-                                 f: fn(parser) -> T) -> ~[T] {\n+    fn parse_seq_to_end<T: Copy>(ket: token::Token, sep: seq_sep,\n+                                 f: fn(Parser) -> T) -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         return val;\n     }\n \n \n-    fn parse_seq_to_before_end<T: Copy>(ket: token::token, sep: seq_sep,\n-                                        f: fn(parser) -> T) -> ~[T] {\n+    fn parse_seq_to_before_end<T: Copy>(ket: token::Token, sep: seq_sep,\n+                                        f: fn(Parser) -> T) -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n         while self.token != ket {\n@@ -279,10 +279,10 @@ impl parser: parser_common {\n         return v;\n     }\n \n-    fn parse_unspanned_seq<T: Copy>(bra: token::token,\n-                                    ket: token::token,\n+    fn parse_unspanned_seq<T: Copy>(bra: token::Token,\n+                                    ket: token::Token,\n                                     sep: seq_sep,\n-                                    f: fn(parser) -> T) -> ~[T] {\n+                                    f: fn(Parser) -> T) -> ~[T] {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n         self.bump();\n@@ -291,8 +291,8 @@ impl parser: parser_common {\n \n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n-    fn parse_seq<T: Copy>(bra: token::token, ket: token::token, sep: seq_sep,\n-                          f: fn(parser) -> T) -> spanned<~[T]> {\n+    fn parse_seq<T: Copy>(bra: token::Token, ket: token::Token, sep: seq_sep,\n+                          f: fn(Parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end::<T>(ket, sep, f);"}, {"sha": "56c9d4de9f3cda71bfd4810ef31f57cbd3c64172", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,4 +1,4 @@\n-use parser::{parser, SOURCE_FILE};\n+use parser::{Parser, SOURCE_FILE};\n use attr::parser_attr;\n \n export eval_crate_directives_to_mod;"}, {"sha": "8f57d733eb51f9421e6d86a7309268caf0e2d0dc", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -10,11 +10,11 @@ export string_reader_as_reader, tt_reader_as_reader;\n \n trait reader {\n     fn is_eof() -> bool;\n-    fn next_token() -> {tok: token::token, sp: span};\n+    fn next_token() -> {tok: token::Token, sp: span};\n     fn fatal(~str) -> !;\n     fn span_diag() -> span_handler;\n     pure fn interner() -> @token::ident_interner;\n-    fn peek() -> {tok: token::token, sp: span};\n+    fn peek() -> {tok: token::Token, sp: span};\n     fn dup() -> reader;\n }\n \n@@ -28,7 +28,7 @@ type string_reader = @{\n     filemap: codemap::filemap,\n     interner: @token::ident_interner,\n     /* cached: */\n-    mut peek_tok: token::token,\n+    mut peek_tok: token::Token,\n     mut peek_span: span\n };\n \n@@ -69,7 +69,7 @@ fn dup_string_reader(&&r: string_reader) -> string_reader {\n \n impl string_reader: reader {\n     fn is_eof() -> bool { is_eof(self) }\n-    fn next_token() -> {tok: token::token, sp: span} {\n+    fn next_token() -> {tok: token::Token, sp: span} {\n         let ret_val = {tok: self.peek_tok, sp: self.peek_span};\n         string_advance_token(self);\n         return ret_val;\n@@ -79,15 +79,15 @@ impl string_reader: reader {\n     }\n     fn span_diag() -> span_handler { self.span_diagnostic }\n     pure fn interner() -> @token::ident_interner { self.interner }\n-    fn peek() -> {tok: token::token, sp: span} {\n+    fn peek() -> {tok: token::Token, sp: span} {\n         {tok: self.peek_tok, sp: self.peek_span}\n     }\n     fn dup() -> reader { dup_string_reader(self) as reader }\n }\n \n impl tt_reader: reader {\n     fn is_eof() -> bool { self.cur_tok == token::EOF }\n-    fn next_token() -> {tok: token::token, sp: span} {\n+    fn next_token() -> {tok: token::Token, sp: span} {\n         /* weird resolve bug: if the following `if`, or any of its\n         statements are removed, we get resolution errors */\n         if false {\n@@ -101,7 +101,7 @@ impl tt_reader: reader {\n     }\n     fn span_diag() -> span_handler { self.sp_diag }\n     pure fn interner() -> @token::ident_interner { self.interner }\n-    fn peek() -> {tok: token::token, sp: span} {\n+    fn peek() -> {tok: token::Token, sp: span} {\n         { tok: self.cur_tok, sp: self.cur_span }\n     }\n     fn dup() -> reader { dup_tt_reader(self) as reader }\n@@ -196,14 +196,14 @@ fn is_bin_digit(c: char) -> bool { return c == '0' || c == '1'; }\n \n // might return a sugared-doc-attr\n fn consume_whitespace_and_comments(rdr: string_reader)\n-                                -> Option<{tok: token::token, sp: span}> {\n+                                -> Option<{tok: token::Token, sp: span}> {\n     while is_whitespace(rdr.curr) { bump(rdr); }\n     return consume_any_line_comment(rdr);\n }\n \n // might return a sugared-doc-attr\n fn consume_any_line_comment(rdr: string_reader)\n-                                -> Option<{tok: token::token, sp: span}> {\n+                                -> Option<{tok: token::Token, sp: span}> {\n     if rdr.curr == '/' {\n         match nextch(rdr) {\n           '/' => {\n@@ -246,7 +246,7 @@ fn consume_any_line_comment(rdr: string_reader)\n \n // might return a sugared-doc-attr\n fn consume_block_comment(rdr: string_reader)\n-                                -> Option<{tok: token::token, sp: span}> {\n+                                -> Option<{tok: token::Token, sp: span}> {\n \n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n     if rdr.curr == '*' || rdr.curr == '!' {\n@@ -317,7 +317,7 @@ fn scan_digits(rdr: string_reader, radix: uint) -> ~str {\n     };\n }\n \n-fn scan_number(c: char, rdr: string_reader) -> token::token {\n+fn scan_number(c: char, rdr: string_reader) -> token::Token {\n     let mut num_str, base = 10u, c = c, n = nextch(rdr);\n     if c == '0' && n == 'x' {\n         bump(rdr);\n@@ -435,7 +435,7 @@ fn scan_numeric_escape(rdr: string_reader, n_hex_digits: uint) -> char {\n     return accum_int as char;\n }\n \n-fn next_token_inner(rdr: string_reader) -> token::token {\n+fn next_token_inner(rdr: string_reader) -> token::Token {\n     let mut accum_str = ~\"\";\n     let mut c = rdr.curr;\n     if (c >= 'a' && c <= 'z')\n@@ -460,7 +460,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n     if is_dec_digit(c) {\n         return scan_number(c, rdr);\n     }\n-    fn binop(rdr: string_reader, op: token::binop) -> token::token {\n+    fn binop(rdr: string_reader, op: token::binop) -> token::Token {\n         bump(rdr);\n         if rdr.curr == '=' {\n             bump(rdr);"}, {"sha": "c0e01fb194430d96016e11443e6b04502f244ebe", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -10,7 +10,7 @@ removed.\n use codemap::span;\n use ast::{expr, expr_lit, lit_nil};\n use ast_util::{respan};\n-use token::token;\n+use token::Token;\n \n /// The specific types of unsupported syntax\n pub enum ObsoleteSyntax {\n@@ -47,7 +47,7 @@ pub trait ObsoleteReporter {\n     fn obsolete_expr(sp: span, kind: ObsoleteSyntax) -> @expr;\n }\n \n-impl parser : ObsoleteReporter {\n+impl Parser : ObsoleteReporter {\n     /// Reports an obsolete syntax non-fatal error.\n     fn obsolete(sp: span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {\n@@ -121,7 +121,7 @@ impl parser : ObsoleteReporter {\n         }\n     }\n \n-    fn token_is_obsolete_ident(ident: &str, token: token) -> bool {\n+    fn token_is_obsolete_ident(ident: &str, token: Token) -> bool {\n         match token {\n             token::IDENT(copy sid, _) => {\n                 str::eq_slice(*self.id_to_str(sid), ident)"}, {"sha": "e29620a7e79dd8d3305aa1a9e778b059b9797e88", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -6,7 +6,7 @@ use std::map::HashMap;\n use token::{can_begin_expr, is_ident, is_ident_or_path, is_plain_ident,\n             INTERPOLATED, special_idents};\n use codemap::{span,fss_none};\n-use util::interner::interner;\n+use util::interner::Interner;\n use ast_util::{spanned, respan, mk_sp, ident_to_path, operator_prec};\n use lexer::reader;\n use prec::{as_prec, token_to_binop};\n@@ -58,7 +58,7 @@ use ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              stmt_semi, struct_def, struct_field, struct_variant_kind,\n              subtract, sty_box, sty_by_ref, sty_region, sty_static, sty_uniq,\n              sty_value, token_tree, trait_method, trait_ref, tt_delim, tt_seq,\n-             tt_tok, tt_nonterminal, tuple_variant_kind, ty, ty_, ty_bot,\n+             tt_tok, tt_nonterminal, tuple_variant_kind, Ty, ty_, ty_bot,\n              ty_box, ty_field, ty_fn, ty_infer, ty_mac, ty_method, ty_nil,\n              ty_param, ty_param_bound, ty_path, ty_ptr, ty_rec, ty_rptr,\n              ty_tup, ty_u32, ty_uniq, ty_vec, ty_fixed_length, type_value_ns,\n@@ -71,7 +71,7 @@ use ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              expr_vstore_uniq};\n \n export file_type;\n-export parser;\n+export Parser;\n export CRATE_FILE;\n export SOURCE_FILE;\n \n@@ -190,14 +190,14 @@ pure fn maybe_append(+lhs: ~[attribute], rhs: Option<~[attribute]>)\n \n /* ident is handled by common.rs */\n \n-fn parser(sess: parse_sess, cfg: ast::crate_cfg,\n-          +rdr: reader, ftype: file_type) -> parser {\n+fn Parser(sess: parse_sess, cfg: ast::crate_cfg,\n+          +rdr: reader, ftype: file_type) -> Parser {\n \n     let tok0 = rdr.next_token();\n     let span0 = tok0.sp;\n     let interner = rdr.interner();\n \n-    parser {\n+    Parser {\n         reader: move rdr,\n         interner: move interner,\n         sess: sess,\n@@ -223,14 +223,14 @@ fn parser(sess: parse_sess, cfg: ast::crate_cfg,\n     }\n }\n \n-struct parser {\n+struct Parser {\n     sess: parse_sess,\n     cfg: crate_cfg,\n     file_type: file_type,\n-    mut token: token::token,\n+    mut token: token::Token,\n     mut span: span,\n     mut last_span: span,\n-    mut buffer: [mut {tok: token::token, sp: span}]/4,\n+    mut buffer: [mut {tok: token::Token, sp: span}]/4,\n     mut buffer_start: int,\n     mut buffer_end: int,\n     mut restriction: restriction,\n@@ -247,7 +247,7 @@ struct parser {\n     drop {} /* do not copy the parser; its state is tied to outside state */\n }\n \n-impl parser {\n+impl Parser {\n     fn bump() {\n         self.last_span = self.span;\n         let next = if self.buffer_start == self.buffer_end {\n@@ -260,7 +260,7 @@ impl parser {\n         self.token = next.tok;\n         self.span = next.sp;\n     }\n-    fn swap(next: token::token, lo: uint, hi: uint) {\n+    fn swap(next: token::Token, lo: uint, hi: uint) {\n         self.token = next;\n         self.span = mk_sp(lo, hi);\n     }\n@@ -270,7 +270,7 @@ impl parser {\n         }\n         return (4 - self.buffer_start) + self.buffer_end;\n     }\n-    fn look_ahead(distance: uint) -> token::token {\n+    fn look_ahead(distance: uint) -> token::Token {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n             self.buffer[self.buffer_end] = self.reader.next_token();\n@@ -411,7 +411,7 @@ impl parser {\n         });\n     }\n \n-    fn parse_ret_ty() -> (ret_style, @ty) {\n+    fn parse_ret_ty() -> (ret_style, @Ty) {\n         return if self.eat(token::RARROW) {\n             let lo = self.span.lo;\n             if self.eat(token::NOT) {\n@@ -472,7 +472,7 @@ impl parser {\n         self.region_from_name(name)\n     }\n \n-    fn parse_ty(colons_before_params: bool) -> @ty {\n+    fn parse_ty(colons_before_params: bool) -> @Ty {\n         maybe_whole!(self, nt_ty);\n \n         let lo = self.span.lo;\n@@ -609,10 +609,10 @@ impl parser {\n         }\n     }\n \n-    fn parse_capture_item_or(parse_arg_fn: fn(parser) -> arg_or_capture_item)\n+    fn parse_capture_item_or(parse_arg_fn: fn(Parser) -> arg_or_capture_item)\n         -> arg_or_capture_item {\n \n-        fn parse_capture_item(p:parser, is_move: bool) -> capture_item {\n+        fn parse_capture_item(p:Parser, is_move: bool) -> capture_item {\n             let sp = mk_sp(p.span.lo, p.span.hi);\n             let ident = p.parse_ident();\n             @{id: p.get_id(), is_move: is_move, name: ident, span: sp}\n@@ -728,7 +728,7 @@ impl parser {\n         }\n     }\n \n-    fn lit_from_token(tok: token::token) -> lit_ {\n+    fn lit_from_token(tok: token::Token) -> lit_ {\n         match tok {\n           token::LIT_INT(i, it) => lit_int(i, it),\n           token::LIT_UINT(u, ut) => lit_uint(u, ut),\n@@ -760,8 +760,8 @@ impl parser {\n     }\n \n     fn parse_path_without_tps_(\n-        parse_ident: fn(parser) -> ident,\n-        parse_last_ident: fn(parser) -> ident) -> @path {\n+        parse_ident: fn(Parser) -> ident,\n+        parse_last_ident: fn(Parser) -> ident) -> @path {\n \n         maybe_whole!(self, nt_path);\n         let lo = self.span.lo;\n@@ -842,7 +842,7 @@ impl parser {\n         }\n     }\n \n-    fn parse_field(sep: token::token) -> field {\n+    fn parse_field(sep: token::Token) -> field {\n         let lo = self.span.lo;\n         let m = self.parse_mutability();\n         let i = self.parse_ident();\n@@ -1220,7 +1220,7 @@ impl parser {\n         return e;\n     }\n \n-    fn parse_sep_and_zerok() -> (Option<token::token>, bool) {\n+    fn parse_sep_and_zerok() -> (Option<token::Token>, bool) {\n         if self.token == token::BINOP(token::STAR)\n             || self.token == token::BINOP(token::PLUS) {\n             let zerok = self.token == token::BINOP(token::STAR);\n@@ -1243,7 +1243,7 @@ impl parser {\n     fn parse_token_tree() -> token_tree {\n         maybe_whole!(deref self, nt_tt);\n \n-        fn parse_tt_tok(p: parser, delim_ok: bool) -> token_tree {\n+        fn parse_tt_tok(p: Parser, delim_ok: bool) -> token_tree {\n             match p.token {\n               token::RPAREN | token::RBRACE | token::RBRACKET\n               if !delim_ok => {\n@@ -1310,8 +1310,8 @@ impl parser {\n     // This goofy function is necessary to correctly match parens in matchers.\n     // Otherwise, `$( ( )` would be a valid matcher, and `$( () )` would be\n     // invalid. It's similar to common::parse_seq.\n-    fn parse_matcher_subseq(name_idx: @mut uint, bra: token::token,\n-                            ket: token::token) -> ~[matcher] {\n+    fn parse_matcher_subseq(name_idx: @mut uint, bra: token::Token,\n+                            ket: token::Token) -> ~[matcher] {\n         let mut ret_val = ~[];\n         let mut lparens = 0u;\n \n@@ -2158,7 +2158,7 @@ impl parser {\n     fn parse_stmt(+first_item_attrs: ~[attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n-        fn check_expected_item(p: parser, current_attrs: ~[attribute]) {\n+        fn check_expected_item(p: Parser, current_attrs: ~[attribute]) {\n             // If we have attributes then we should have an item\n             if vec::is_not_empty(current_attrs) {\n                 p.fatal(~\"expected item\");\n@@ -2221,7 +2221,7 @@ impl parser {\n \n         maybe_whole!(pair_empty self, nt_block);\n \n-        fn maybe_parse_inner_attrs_and_next(p: parser, parse_attrs: bool) ->\n+        fn maybe_parse_inner_attrs_and_next(p: Parser, parse_attrs: bool) ->\n             {inner: ~[attribute], next: ~[attribute]} {\n             if parse_attrs {\n                 p.parse_inner_attrs_and_next()\n@@ -2386,7 +2386,7 @@ impl parser {\n         } else { ~[] }\n     }\n \n-    fn parse_fn_decl(parse_arg_fn: fn(parser) -> arg_or_capture_item)\n+    fn parse_fn_decl(parse_arg_fn: fn(Parser) -> arg_or_capture_item)\n         -> (fn_decl, capture_clause) {\n \n         let args_or_capture_items: ~[arg_or_capture_item] =\n@@ -2420,11 +2420,11 @@ impl parser {\n     }\n \n     fn parse_fn_decl_with_self(parse_arg_fn:\n-                                    fn(parser) -> arg_or_capture_item)\n+                                    fn(Parser) -> arg_or_capture_item)\n                             -> (self_ty, fn_decl, capture_clause) {\n \n         fn maybe_parse_self_ty(cnstr: fn(+v: mutability) -> ast::self_ty_,\n-                               p: parser) -> ast::self_ty_ {\n+                               p: Parser) -> ast::self_ty_ {\n             // We need to make sure it isn't a mode or a type\n             if p.token_is_keyword(~\"self\", p.look_ahead(1)) ||\n                 ((p.token_is_keyword(~\"const\", p.look_ahead(1)) ||\n@@ -2604,7 +2604,7 @@ impl parser {\n     // Parses four variants (with the region/type params always optional):\n     //    impl<T> ~[T] : to_str { ... }\n     fn parse_item_impl() -> item_info {\n-        fn wrap_path(p: parser, pt: @path) -> @ty {\n+        fn wrap_path(p: Parser, pt: @path) -> @Ty {\n             @{id: p.get_id(), node: ty_path(pt, p.get_id()), span: pt.span}\n         }\n \n@@ -2664,7 +2664,7 @@ impl parser {\n           ref_id: self.get_id(), impl_id: self.get_id()}\n     }\n \n-    fn parse_trait_ref_list(ket: token::token) -> ~[@trait_ref] {\n+    fn parse_trait_ref_list(ket: token::Token) -> ~[@trait_ref] {\n         self.parse_seq_to_before_end(\n             ket, seq_sep_trailing_disallowed(token::COMMA),\n             |p| p.parse_trait_ref())\n@@ -2756,7 +2756,7 @@ impl parser {\n          None)\n     }\n \n-    fn token_is_pound_or_doc_comment(++tok: token::token) -> bool {\n+    fn token_is_pound_or_doc_comment(++tok: token::Token) -> bool {\n         match tok {\n             token::POUND | token::DOC_COMMENT(_) => true,\n             _ => false\n@@ -2841,7 +2841,7 @@ impl parser {\n         self.eat_keyword(~\"static\")\n     }\n \n-    fn parse_mod_items(term: token::token,\n+    fn parse_mod_items(term: token::Token,\n                        +first_item_attrs: ~[attribute]) -> _mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n         let {attrs_remaining, view_items, items: starting_items} =\n@@ -3222,7 +3222,7 @@ impl parser {\n         }\n     }\n \n-    fn fn_expr_lookahead(tok: token::token) -> bool {\n+    fn fn_expr_lookahead(tok: token::Token) -> bool {\n         match tok {\n           token::LPAREN | token::AT | token::TILDE | token::BINOP(_) => true,\n           _ => false\n@@ -3608,7 +3608,7 @@ impl parser {\n         return self.fatal(~\"expected crate directive\");\n     }\n \n-    fn parse_crate_directives(term: token::token,\n+    fn parse_crate_directives(term: token::Token,\n                               first_outer_attr: ~[attribute]) ->\n         ~[@crate_directive] {\n "}, {"sha": "3fd905cb8ecec44f614c30f18ff202a98d386299", "filename": "src/libsyntax/parse/prec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Fprec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Fprec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fprec.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -3,7 +3,7 @@ export unop_prec;\n export token_to_binop;\n \n use token::*;\n-use token::token;\n+use token::Token;\n use ast::*;\n \n /// Unary operators have higher precedence than binary\n@@ -19,7 +19,7 @@ const as_prec: uint = 11u;\n  * Maps a token to a record specifying the corresponding binary\n  * operator and its precedence\n  */\n-fn token_to_binop(tok: token) -> Option<ast::binop> {\n+fn token_to_binop(tok: Token) -> Option<ast::binop> {\n   match tok {\n       BINOP(STAR)    => Some(mul),\n       BINOP(SLASH)   => Some(div),"}, {"sha": "5151fd1bac8377e3bcab95eef7b723ed3e854d74", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,5 +1,5 @@\n use util::interner;\n-use util::interner::interner;\n+use util::interner::Interner;\n use std::map::HashMap;\n \n #[auto_serialize]\n@@ -19,7 +19,7 @@ enum binop {\n \n #[auto_serialize]\n #[auto_deserialize]\n-enum token {\n+enum Token {\n     /* Expression-operator symbols. */\n     EQ,\n     LT,\n@@ -84,7 +84,7 @@ enum nonterminal {\n     nt_stmt(@ast::stmt),\n     nt_pat( @ast::pat),\n     nt_expr(@ast::expr),\n-    nt_ty(  @ast::ty),\n+    nt_ty(  @ast::Ty),\n     nt_ident(ast::ident, bool),\n     nt_path(@ast::path),\n     nt_tt(  @ast::token_tree), //needs @ed to break a circularity\n@@ -106,7 +106,7 @@ fn binop_to_str(o: binop) -> ~str {\n     }\n }\n \n-fn to_str(in: @ident_interner, t: token) -> ~str {\n+fn to_str(in: @ident_interner, t: Token) -> ~str {\n     match t {\n       EQ => ~\"=\",\n       LT => ~\"<\",\n@@ -192,7 +192,7 @@ fn to_str(in: @ident_interner, t: token) -> ~str {\n     }\n }\n \n-pure fn can_begin_expr(t: token) -> bool {\n+pure fn can_begin_expr(t: Token) -> bool {\n     match t {\n       LPAREN => true,\n       LBRACE => true,\n@@ -223,7 +223,7 @@ pure fn can_begin_expr(t: token) -> bool {\n }\n \n /// what's the opposite delimiter?\n-fn flip_delimiter(t: token::token) -> token::token {\n+fn flip_delimiter(t: token::Token) -> token::Token {\n     match t {\n       token::LPAREN => token::RPAREN,\n       token::LBRACE => token::RBRACE,\n@@ -237,7 +237,7 @@ fn flip_delimiter(t: token::token) -> token::token {\n \n \n \n-fn is_lit(t: token) -> bool {\n+fn is_lit(t: Token) -> bool {\n     match t {\n       LIT_INT(_, _) => true,\n       LIT_UINT(_, _) => true,\n@@ -248,22 +248,22 @@ fn is_lit(t: token) -> bool {\n     }\n }\n \n-pure fn is_ident(t: token) -> bool {\n+pure fn is_ident(t: Token) -> bool {\n     match t { IDENT(_, _) => true, _ => false }\n }\n \n-pure fn is_ident_or_path(t: token) -> bool {\n+pure fn is_ident_or_path(t: Token) -> bool {\n     match t {\n       IDENT(_, _) | INTERPOLATED(nt_path(*)) => true,\n       _ => false\n     }\n }\n \n-pure fn is_plain_ident(t: token) -> bool {\n+pure fn is_plain_ident(t: Token) -> bool {\n     match t { IDENT(_, false) => true, _ => false }\n }\n \n-pure fn is_bar(t: token) -> bool {\n+pure fn is_bar(t: Token) -> bool {\n     match t { BINOP(OR) | OROR => true, _ => false }\n }\n \n@@ -314,7 +314,7 @@ mod special_idents {\n }\n \n struct ident_interner {\n-    priv interner: util::interner::interner<@~str>,\n+    priv interner: util::interner::Interner<@~str>,\n }\n \n impl ident_interner {\n@@ -457,8 +457,8 @@ impl binop : cmp::Eq {\n     pure fn ne(other: &binop) -> bool { !self.eq(other) }\n }\n \n-impl token : cmp::Eq {\n-    pure fn eq(other: &token) -> bool {\n+impl Token : cmp::Eq {\n+    pure fn eq(other: &Token) -> bool {\n         match self {\n             EQ => {\n                 match (*other) {\n@@ -720,7 +720,7 @@ impl token : cmp::Eq {\n             }\n         }\n     }\n-    pure fn ne(other: &token) -> bool { !self.eq(other) }\n+    pure fn ne(other: &Token) -> bool { !self.eq(other) }\n }\n \n // Local Variables:"}, {"sha": "5e37f7e18ece9f2932be5076203ef86e41a6d1e4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,5 +1,5 @@\n use parse::{comments, lexer, token};\n-use codemap::codemap;\n+use codemap::CodeMap;\n use pp::{break_offset, word, printer, space, zerobreak, hardbreak, breaks};\n use pp::{consistent, inconsistent, eof};\n use ast::{required, provided};\n@@ -24,7 +24,7 @@ fn no_ann() -> pp_ann {\n \n type ps =\n     @{s: pp::printer,\n-      cm: Option<codemap>,\n+      cm: Option<CodeMap>,\n       intr: @token::ident_interner,\n       comments: Option<~[comments::cmnt]>,\n       literals: Option<~[comments::lit]>,\n@@ -45,7 +45,7 @@ fn end(s: ps) {\n \n fn rust_printer(writer: io::Writer, intr: @ident_interner) -> ps {\n     return @{s: pp::mk_printer(writer, default_columns),\n-             cm: None::<codemap>,\n+             cm: None::<CodeMap>,\n              intr: intr,\n              comments: None::<~[comments::cmnt]>,\n              literals: None::<~[comments::lit]>,\n@@ -63,7 +63,7 @@ const default_columns: uint = 78u;\n // Requires you to pass an input filename and reader so that\n // it can scan the input text for comments and literals to\n // copy forward.\n-fn print_crate(cm: codemap, intr: @ident_interner,\n+fn print_crate(cm: CodeMap, intr: @ident_interner,\n                span_diagnostic: diagnostic::span_handler,\n                crate: @ast::crate, filename: ~str, in: io::Reader,\n                out: io::Writer, ann: pp_ann, is_expanded: bool) {\n@@ -91,7 +91,7 @@ fn print_crate_(s: ps, &&crate: @ast::crate) {\n     eof(s.s);\n }\n \n-fn ty_to_str(ty: @ast::ty, intr: @ident_interner) -> ~str {\n+fn ty_to_str(ty: @ast::Ty, intr: @ident_interner) -> ~str {\n     to_str(ty, print_type, intr)\n }\n \n@@ -348,11 +348,11 @@ fn print_region(s: ps, region: @ast::region, sep: ~str) {\n     word(s.s, sep);\n }\n \n-fn print_type(s: ps, &&ty: @ast::ty) {\n+fn print_type(s: ps, &&ty: @ast::Ty) {\n     print_type_ex(s, ty, false);\n }\n \n-fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n+fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     match ty.node {"}, {"sha": "f564589cbe0c0d800a22be6c3b8e68b082ca5216", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -12,29 +12,29 @@ type hash_interner<T: Const> =\n     {map: HashMap<T, uint>,\n      vect: DVec<T>};\n \n-fn mk<T:Eq IterBytes Hash Const Copy>() -> interner<T> {\n+fn mk<T:Eq IterBytes Hash Const Copy>() -> Interner<T> {\n     let m = map::HashMap::<T, uint>();\n     let hi: hash_interner<T> =\n         {map: m, vect: DVec()};\n-    move ((move hi) as interner::<T>)\n+    move ((move hi) as Interner::<T>)\n }\n \n-fn mk_prefill<T:Eq IterBytes Hash Const Copy>(init: ~[T]) -> interner<T> {\n+fn mk_prefill<T:Eq IterBytes Hash Const Copy>(init: ~[T]) -> Interner<T> {\n     let rv = mk();\n     for init.each() |v| { rv.intern(*v); }\n     return rv;\n }\n \n \n /* when traits can extend traits, we should extend index<uint,T> to get [] */\n-trait interner<T:Eq IterBytes Hash Const Copy> {\n+trait Interner<T:Eq IterBytes Hash Const Copy> {\n     fn intern(T) -> uint;\n     fn gensym(T) -> uint;\n     pure fn get(uint) -> T;\n     fn len() -> uint;\n }\n \n-impl <T:Eq IterBytes Hash Const Copy> hash_interner<T>: interner<T> {\n+impl <T:Eq IterBytes Hash Const Copy> hash_interner<T>: Interner<T> {\n     fn intern(val: T) -> uint {\n         match self.map.find(val) {\n           Some(idx) => return idx,"}, {"sha": "32fcbdfc7589c5c71bca84787e45c9d8ea91386b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -55,7 +55,7 @@ type visitor<E> =\n       visit_decl: fn@(@decl, E, vt<E>),\n       visit_expr: fn@(@expr, E, vt<E>),\n       visit_expr_post: fn@(@expr, E, vt<E>),\n-      visit_ty: fn@(@ty, E, vt<E>),\n+      visit_ty: fn@(@Ty, E, vt<E>),\n       visit_ty_params: fn@(~[ty_param], E, vt<E>),\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n       visit_ty_method: fn@(ty_method, E, vt<E>),\n@@ -187,9 +187,9 @@ fn visit_enum_def<E>(enum_definition: ast::enum_def, tps: ~[ast::ty_param],\n     }\n }\n \n-fn skip_ty<E>(_t: @ty, _e: E, _v: vt<E>) {}\n+fn skip_ty<E>(_t: @Ty, _e: E, _v: vt<E>) {}\n \n-fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n+fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n     match t.node {\n       ty_box(mt) | ty_uniq(mt) |\n       ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n@@ -490,7 +490,7 @@ type simple_visitor =\n       visit_decl: fn@(@decl),\n       visit_expr: fn@(@expr),\n       visit_expr_post: fn@(@expr),\n-      visit_ty: fn@(@ty),\n+      visit_ty: fn@(@Ty),\n       visit_ty_params: fn@(~[ty_param]),\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id),\n       visit_ty_method: fn@(ty_method),\n@@ -499,7 +499,7 @@ type simple_visitor =\n       visit_struct_field: fn@(@struct_field),\n       visit_struct_method: fn@(@method)};\n \n-fn simple_ignore_ty(_t: @ty) {}\n+fn simple_ignore_ty(_t: @Ty) {}\n \n fn default_simple_visitor() -> simple_visitor {\n     return @{visit_mod: fn@(_m: _mod, _sp: span, _id: node_id) { },\n@@ -577,7 +577,7 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     fn v_expr_post(f: fn@(@expr), ex: @expr, &&_e: (), _v: vt<()>) {\n         f(ex);\n     }\n-    fn v_ty(f: fn@(@ty), ty: @ty, &&e: (), v: vt<()>) {\n+    fn v_ty(f: fn@(@Ty), ty: @Ty, &&e: (), v: vt<()>) {\n         f(ty);\n         visit_ty(ty, e, v);\n     }"}, {"sha": "61fd68c193a6a418de2c406dd7b6cc9e5a303a02", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,6 +1,6 @@\n use libc::{c_int, c_uint, c_char};\n use driver::session;\n-use session::session;\n+use session::Session;\n use lib::llvm::llvm;\n use syntax::attr;\n use middle::ty;\n@@ -33,14 +33,14 @@ impl output_type : cmp::Eq {\n     pure fn ne(other: &output_type) -> bool { !self.eq(other) }\n }\n \n-fn llvm_err(sess: session, msg: ~str) -> ! unsafe {\n+fn llvm_err(sess: Session, msg: ~str) -> ! unsafe {\n     let cstr = llvm::LLVMRustGetLastError();\n     if cstr == ptr::null() {\n         sess.fatal(msg);\n     } else { sess.fatal(msg + ~\": \" + str::raw::from_c_str(cstr)); }\n }\n \n-fn WriteOutputFile(sess:session,\n+fn WriteOutputFile(sess: Session,\n         PM: lib::llvm::PassManagerRef, M: ModuleRef,\n         Triple: *c_char,\n         // FIXME: When #2334 is fixed, change\n@@ -69,7 +69,7 @@ mod jit {\n         env: *(),\n     }\n \n-    fn exec(sess: session,\n+    fn exec(sess: Session,\n             pm: PassManagerRef,\n             m: ModuleRef,\n             opt: c_int,\n@@ -131,7 +131,7 @@ mod write {\n         return false;\n     }\n \n-    fn run_passes(sess: session, llmod: ModuleRef, output: &Path) {\n+    fn run_passes(sess: Session, llmod: ModuleRef, output: &Path) {\n         let opts = sess.opts;\n         if sess.time_llvm_passes() { llvm::LLVMRustEnableTimePasses(); }\n         let mut pm = mk_pass_manager();\n@@ -384,15 +384,15 @@ mod write {\n  *\n  */\n \n-fn build_link_meta(sess: session, c: ast::crate, output: &Path,\n+fn build_link_meta(sess: Session, c: ast::crate, output: &Path,\n                    symbol_hasher: &hash::State) -> link_meta {\n \n     type provided_metas =\n         {name: Option<~str>,\n          vers: Option<~str>,\n          cmh_items: ~[@ast::meta_item]};\n \n-    fn provided_link_metas(sess: session, c: ast::crate) ->\n+    fn provided_link_metas(sess: Session, c: ast::crate) ->\n        provided_metas {\n         let mut name: Option<~str> = None;\n         let mut vers: Option<~str> = None;\n@@ -454,13 +454,13 @@ fn build_link_meta(sess: session, c: ast::crate, output: &Path,\n         return truncated_hash_result(symbol_hasher);\n     }\n \n-    fn warn_missing(sess: session, name: ~str, default: ~str) {\n+    fn warn_missing(sess: Session, name: ~str, default: ~str) {\n         if !sess.building_library { return; }\n         sess.warn(fmt!(\"missing crate link meta `%s`, using `%s` as default\",\n                        name, default));\n     }\n \n-    fn crate_meta_name(sess: session, _crate: ast::crate,\n+    fn crate_meta_name(sess: Session, _crate: ast::crate,\n                        output: &Path, metas: provided_metas) -> ~str {\n         return match metas.name {\n               Some(v) => v,\n@@ -477,7 +477,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: &Path,\n             };\n     }\n \n-    fn crate_meta_vers(sess: session, _crate: ast::crate,\n+    fn crate_meta_vers(sess: Session, _crate: ast::crate,\n                        metas: provided_metas) -> ~str {\n         return match metas.vers {\n               Some(v) => v,\n@@ -569,7 +569,7 @@ fn sanitize(s: ~str) -> ~str {\n     return result;\n }\n \n-fn mangle(sess: session, ss: path) -> ~str {\n+fn mangle(sess: Session, ss: path) -> ~str {\n     // Follow C++ namespace-mangling style\n \n     let mut n = ~\"_ZN\"; // Begin name-sequence.\n@@ -584,7 +584,7 @@ fn mangle(sess: session, ss: path) -> ~str {\n     n\n }\n \n-fn exported_name(sess: session, path: path, hash: ~str, vers: ~str) -> ~str {\n+fn exported_name(sess: Session, path: path, hash: ~str, vers: ~str) -> ~str {\n     return mangle(sess,\n                   vec::append_one(\n                       vec::append_one(path, path_name(sess.ident_of(hash))),\n@@ -623,7 +623,7 @@ fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: ~str) -> ~str {\n \n // If the user wants an exe generated we need to invoke\n // cc to link the object file with some libs\n-fn link_binary(sess: session,\n+fn link_binary(sess: Session,\n                obj_filename: &Path,\n                out_filename: &Path,\n                lm: link_meta) {"}, {"sha": "8038d7bb6ddf98c2c5ec2f9b589b4ea53fce30f3", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -13,7 +13,7 @@ pure fn not_win32(os: session::os) -> bool {\n   }\n }\n \n-fn get_rpath_flags(sess: session::session, out_filename: &Path) -> ~[~str] {\n+fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> ~[~str] {\n     let os = sess.targ_cfg.os;\n \n     // No rpath on windows\n@@ -35,7 +35,7 @@ fn get_rpath_flags(sess: session::session, out_filename: &Path) -> ~[~str] {\n     rpaths_to_flags(rpaths)\n }\n \n-fn get_sysroot_absolute_rt_lib(sess: session::session) -> Path {\n+fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n     let r = filesearch::relative_target_lib_path(sess.opts.target_triple);\n     sess.filesearch.sysroot().push_rel(&r).push(os::dll_filename(\"rustrt\"))\n }"}, {"sha": "5da8f5475ed136ba7557194697af7350a15686b0", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,6 +1,6 @@\n // -*- rust -*-\n use metadata::{creader, cstore, filesearch};\n-use session::{session, session_, OptLevel, No, Less, Default, Aggressive};\n+use session::{Session, Session_, OptLevel, No, Less, Default, Aggressive};\n use syntax::parse;\n use syntax::{ast, codemap};\n use syntax::attr;\n@@ -32,7 +32,7 @@ fn source_name(input: input) -> ~str {\n     }\n }\n \n-fn default_configuration(sess: session, argv0: ~str, input: input) ->\n+fn default_configuration(sess: Session, argv0: ~str, input: input) ->\n    ast::crate_cfg {\n     let libc = match sess.targ_cfg.os {\n       session::os_win32 => ~\"msvcrt.dll\",\n@@ -70,7 +70,7 @@ fn append_configuration(cfg: ast::crate_cfg, name: ~str) -> ast::crate_cfg {\n     }\n }\n \n-fn build_configuration(sess: session, argv0: ~str, input: input) ->\n+fn build_configuration(sess: Session, argv0: ~str, input: input) ->\n    ast::crate_cfg {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n@@ -106,7 +106,7 @@ enum input {\n     str_input(~str)\n }\n \n-fn parse_input(sess: session, cfg: ast::crate_cfg, input: input)\n+fn parse_input(sess: Session, cfg: ast::crate_cfg, input: input)\n     -> @ast::crate {\n     match input {\n       file_input(file) => {\n@@ -145,7 +145,7 @@ impl compile_upto : cmp::Eq {\n     pure fn ne(other: &compile_upto) -> bool { !self.eq(other) }\n }\n \n-fn compile_upto(sess: session, cfg: ast::crate_cfg,\n+fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n                 input: input, upto: compile_upto,\n                 outputs: Option<output_filenames>)\n     -> {crate: @ast::crate, tcx: Option<ty::ctxt>} {\n@@ -277,7 +277,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     return {crate: crate, tcx: Some(ty_cx)};\n }\n \n-fn compile_input(sess: session, cfg: ast::crate_cfg, input: input,\n+fn compile_input(sess: Session, cfg: ast::crate_cfg, input: input,\n                  outdir: &Option<Path>, output: &Option<Path>) {\n \n     let upto = if sess.opts.parse_only { cu_parse }\n@@ -287,7 +287,7 @@ fn compile_input(sess: session, cfg: ast::crate_cfg, input: input,\n     compile_upto(sess, cfg, input, upto, Some(outputs));\n }\n \n-fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n+fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: input,\n                       ppm: pp_mode) {\n     fn ann_paren_for_expr(node: pprust::ann_node) {\n         match node {\n@@ -571,7 +571,7 @@ fn build_session_options(binary: ~str,\n }\n \n fn build_session(sopts: @session::options,\n-                 demitter: diagnostic::emitter) -> session {\n+                 demitter: diagnostic::emitter) -> Session {\n     let codemap = codemap::new_codemap();\n     let diagnostic_handler =\n         diagnostic::mk_handler(Some(demitter));\n@@ -581,11 +581,10 @@ fn build_session(sopts: @session::options,\n }\n \n fn build_session_(sopts: @session::options,\n-                  cm: codemap::codemap,\n+                  cm: codemap::CodeMap,\n                   demitter: diagnostic::emitter,\n                   span_diagnostic_handler: diagnostic::span_handler)\n-               -> session {\n-\n+               -> Session {\n     let target_cfg = build_target_config(sopts, demitter);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n                                                     cm);\n@@ -595,7 +594,7 @@ fn build_session_(sopts: @session::options,\n         sopts.target_triple,\n         sopts.addl_lib_search_paths);\n     let lint_settings = lint::mk_lint_settings();\n-    session_(@{targ_cfg: target_cfg,\n+    Session_(@{targ_cfg: target_cfg,\n                opts: sopts,\n                cstore: cstore,\n                parse_sess: p_s,\n@@ -609,7 +608,7 @@ fn build_session_(sopts: @session::options,\n                lint_settings: lint_settings})\n }\n \n-fn parse_pretty(sess: session, &&name: ~str) -> pp_mode {\n+fn parse_pretty(sess: Session, &&name: ~str) -> pp_mode {\n     match name {\n       ~\"normal\" => ppm_normal,\n       ~\"expanded\" => ppm_expanded,\n@@ -652,7 +651,7 @@ type output_filenames = @{out_filename:Path, obj_filename:Path};\n fn build_output_filenames(input: input,\n                           odir: &Option<Path>,\n                           ofile: &Option<Path>,\n-                          sess: session)\n+                          sess: Session)\n         -> output_filenames {\n     let obj_path;\n     let out_path;\n@@ -728,7 +727,7 @@ fn early_error(emitter: diagnostic::emitter, msg: ~str) -> ! {\n     fail;\n }\n \n-fn list_metadata(sess: session, path: &Path, out: io::Writer) {\n+fn list_metadata(sess: Session, path: &Path, out: io::Writer) {\n     metadata::loader::list_file_metadata(\n         sess.parse_sess.interner,\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);"}, {"sha": "59d4e0dfdb84b2b527159add6781a7c4507a5095", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -235,7 +235,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n \n         // The 'diagnostics emitter'. Every error, warning, etc. should\n         // go through this function.\n-        let demitter = fn@(cmsp: Option<(codemap::codemap, codemap::span)>,\n+        let demitter = fn@(cmsp: Option<(codemap::CodeMap, codemap::span)>,\n                            msg: &str, lvl: diagnostic::level) {\n             if lvl == diagnostic::fatal {\n                 comm::send(ch, fatal);"}, {"sha": "ed73bcb6d725977434d64ae63c26afc463764a55", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -127,24 +127,24 @@ type options =\n \n type crate_metadata = {name: ~str, data: ~[u8]};\n \n-type session_ = {targ_cfg: @config,\n+type Session_ = {targ_cfg: @config,\n                  opts: @options,\n-                 cstore: metadata::cstore::cstore,\n+                 cstore: metadata::cstore::CStore,\n                  parse_sess: parse_sess,\n-                 codemap: codemap::codemap,\n+                 codemap: codemap::CodeMap,\n                  // For a library crate, this is always none\n                  mut main_fn: Option<(node_id, codemap::span)>,\n                  span_diagnostic: diagnostic::span_handler,\n-                 filesearch: filesearch::filesearch,\n+                 filesearch: filesearch::FileSearch,\n                  mut building_library: bool,\n                  working_dir: Path,\n                  lint_settings: lint::lint_settings};\n \n-enum session {\n-    session_(@session_)\n+enum Session {\n+    Session_(@Session_)\n }\n \n-impl session {\n+impl Session {\n     fn span_fatal(sp: span, msg: ~str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)\n     }\n@@ -270,7 +270,7 @@ fn basic_options() -> @options {\n }\n \n // Seems out of place, but it uses session, so I'm putting it here\n-fn expect<T: Copy>(sess: session, opt: Option<T>, msg: fn() -> ~str) -> T {\n+fn expect<T: Copy>(sess: Session, opt: Option<T>, msg: fn() -> ~str) -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n "}, {"sha": "e9be56e7d48031ddd318899e8ca465274dbefbf1", "filename": "src/rustc/front/core_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fcore_inject.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,12 +1,12 @@\n-use driver::session::session;\n+use driver::session::Session;\n use syntax::codemap;\n use syntax::ast;\n use syntax::ast_util::*;\n use syntax::attr;\n \n export maybe_inject_libcore_ref;\n \n-fn maybe_inject_libcore_ref(sess: session,\n+fn maybe_inject_libcore_ref(sess: Session,\n                             crate: @ast::crate) -> @ast::crate {\n     if use_core(crate) {\n         inject_libcore_ref(sess, crate)\n@@ -19,7 +19,7 @@ fn use_core(crate: @ast::crate) -> bool {\n     !attr::attrs_contains_name(crate.node.attrs, ~\"no_core\")\n }\n \n-fn inject_libcore_ref(sess: session,\n+fn inject_libcore_ref(sess: Session,\n                       crate: @ast::crate) -> @ast::crate {\n \n     fn spanned<T: Copy>(x: T) -> @ast::spanned<T> {"}, {"sha": "ac74bac3f2f169086a5afac3c8671d30a588ad1c", "filename": "src/rustc/front/intrinsic_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic_inject.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,10 +1,10 @@\n-use driver::session::session;\n+use driver::session::Session;\n use syntax::parse;\n use syntax::ast;\n \n export inject_intrinsic;\n \n-fn inject_intrinsic(sess: session,\n+fn inject_intrinsic(sess: Session,\n                     crate: @ast::crate) -> @ast::crate {\n \n     let intrinsic_module = @include_str!(\"intrinsic.rs\");"}, {"sha": "f0c9de4f2a245a585352797ef953c2cb4e8d381f", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -7,7 +7,7 @@ use syntax::fold;\n use syntax::print::pprust;\n use syntax::codemap::span;\n use driver::session;\n-use session::session;\n+use session::Session;\n use syntax::attr;\n use dvec::DVec;\n \n@@ -19,14 +19,14 @@ type test = {span: span, path: ~[ast::ident],\n              ignore: bool, should_fail: bool};\n \n type test_ctxt =\n-    @{sess: session::session,\n+    @{sess: session::Session,\n       crate: @ast::crate,\n       mut path: ~[ast::ident],\n       testfns: DVec<test>};\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n-fn modify_for_testing(sess: session::session,\n+fn modify_for_testing(sess: session::Session,\n                       crate: @ast::crate) -> @ast::crate {\n \n     if sess.opts.test {\n@@ -36,7 +36,7 @@ fn modify_for_testing(sess: session::session,\n     }\n }\n \n-fn generate_test_harness(sess: session::session,\n+fn generate_test_harness(sess: session::Session,\n                          crate: @ast::crate) -> @ast::crate {\n     let cx: test_ctxt =\n         @{sess: sess,\n@@ -261,13 +261,13 @@ fn mk_path(cx: test_ctxt, path: ~[ast::ident]) -> ~[ast::ident] {\n     else { vec::append(~[cx.sess.ident_of(~\"std\")], path) }\n }\n \n-// The ast::ty of ~[std::test::test_desc]\n-fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n+// The ast::Ty of ~[std::test::test_desc]\n+fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::Ty {\n     let test_desc_ty_path =\n         path_node(mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n                                 cx.sess.ident_of(~\"TestDesc\")]));\n \n-    let test_desc_ty: ast::ty =\n+    let test_desc_ty: ast::Ty =\n         {id: cx.sess.next_node_id(),\n          node: ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()),\n          span: dummy_sp()};"}, {"sha": "3080426e5319c0aa3dbd727af0755d140c88fb94", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -7,7 +7,7 @@ use syntax::visit;\n use syntax::codemap::span;\n use std::map::HashMap;\n use syntax::print::pprust;\n-use filesearch::filesearch;\n+use filesearch::FileSearch;\n use common::*;\n use dvec::DVec;\n use syntax::parse::token::ident_interner;\n@@ -17,7 +17,7 @@ export read_crates;\n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n fn read_crates(diag: span_handler, crate: ast::crate,\n-               cstore: cstore::cstore, filesearch: filesearch,\n+               cstore: cstore::CStore, filesearch: FileSearch,\n                os: loader::os, static: bool, intr: @ident_interner) {\n     let e = @{diag: diag,\n               filesearch: filesearch,\n@@ -88,8 +88,8 @@ fn warn_if_multiple_versions(e: env, diag: span_handler,\n }\n \n type env = @{diag: span_handler,\n-             filesearch: filesearch,\n-             cstore: cstore::cstore,\n+             filesearch: FileSearch,\n+             cstore: cstore::CStore,\n              os: loader::os,\n              static: bool,\n              crate_cache: DVec<cache_entry>,"}, {"sha": "d9fccb16de02e377975d8e8f2c0bd87bdc7e7522", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -39,18 +39,18 @@ struct ProvidedTraitMethodInfo {\n     def_id: ast::def_id\n }\n \n-fn get_symbol(cstore: cstore::cstore, def: ast::def_id) -> ~str {\n+fn get_symbol(cstore: cstore::CStore, def: ast::def_id) -> ~str {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     return decoder::get_symbol(cdata, def.node);\n }\n \n-fn get_type_param_count(cstore: cstore::cstore, def: ast::def_id) -> uint {\n+fn get_type_param_count(cstore: cstore::CStore, def: ast::def_id) -> uint {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     return decoder::get_type_param_count(cdata, def.node);\n }\n \n /// Iterates over all the paths in the given crate.\n-fn each_path(cstore: cstore::cstore, cnum: ast::crate_num,\n+fn each_path(cstore: cstore::CStore, cnum: ast::crate_num,\n              f: fn(decoder::path_entry) -> bool) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     decoder::each_path(cstore.intr, crate_data, f);\n@@ -91,7 +91,7 @@ fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n-fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n+fn get_impls_for_mod(cstore: cstore::CStore, def: ast::def_id,\n                      name: Option<ast::ident>)\n     -> @~[@decoder::_impl] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n@@ -113,14 +113,14 @@ fn get_provided_trait_methods(tcx: ty::ctxt, def: ast::def_id) ->\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n-fn get_method_names_if_trait(cstore: cstore::cstore, def: ast::def_id)\n+fn get_method_names_if_trait(cstore: cstore::CStore, def: ast::def_id)\n     -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n \n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_method_names_if_trait(cstore.intr, cdata, def.node);\n }\n \n-fn get_item_attrs(cstore: cstore::cstore,\n+fn get_item_attrs(cstore: cstore::CStore,\n                   def_id: ast::def_id,\n                   f: fn(~[@ast::meta_item])) {\n \n@@ -140,7 +140,7 @@ fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n-fn get_region_param(cstore: metadata::cstore::cstore,\n+fn get_region_param(cstore: metadata::cstore::CStore,\n                     def: ast::def_id) -> Option<ty::region_variance> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_region_param(cdata, def.node);\n@@ -177,7 +177,7 @@ fn get_impl_traits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n     decoder::get_impl_traits(cdata, def.node, tcx)\n }\n \n-fn get_impl_method(cstore: cstore::cstore,\n+fn get_impl_method(cstore: cstore::CStore,\n                    def: ast::def_id, mname: ast::ident)\n     -> ast::def_id {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n@@ -188,15 +188,15 @@ fn get_impl_method(cstore: cstore::cstore,\n    for their methods (so that get_trait_methods can be reused to get\n    class methods), classes require a slightly different version of\n    get_impl_method. Sigh. */\n-fn get_class_method(cstore: cstore::cstore,\n+fn get_class_method(cstore: cstore::CStore,\n                     def: ast::def_id, mname: ast::ident)\n     -> ast::def_id {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_class_method(cstore.intr, cdata, def.node, mname)\n }\n \n /* If def names a class with a dtor, return it. Otherwise, return none. */\n-fn class_dtor(cstore: cstore::cstore, def: ast::def_id)\n+fn class_dtor(cstore: cstore::CStore, def: ast::def_id)\n     -> Option<ast::def_id> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::class_dtor(cdata, def.node)"}, {"sha": "4bbca3a06050cef8daf7d74cab5c763d82a56d66", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -6,7 +6,7 @@ use std::map::HashMap;\n use syntax::{ast, attr};\n use syntax::parse::token::ident_interner;\n \n-export cstore;\n+export CStore;\n export cnum_map;\n export crate_metadata;\n export mk_cstore;\n@@ -49,7 +49,7 @@ type crate_metadata = @{name: ~str,\n // other modules to access the cstore's private data. This could also be\n // achieved with an obj, but at the expense of a vtable. Not sure if this is a\n // good pattern or not.\n-enum cstore { private(cstore_private), }\n+enum CStore { private(cstore_private), }\n \n type cstore_private =\n     @{metas: map::HashMap<ast::crate_num, crate_metadata>,\n@@ -64,11 +64,11 @@ type cstore_private =\n type use_crate_map = map::HashMap<ast::node_id, ast::crate_num>;\n \n // Internal method to retrieve the data from the cstore\n-pure fn p(cstore: cstore) -> cstore_private {\n+pure fn p(cstore: CStore) -> cstore_private {\n     match cstore { private(p) => p }\n }\n \n-fn mk_cstore(intr: @ident_interner) -> cstore {\n+fn mk_cstore(intr: @ident_interner) -> CStore {\n     let meta_cache = map::HashMap();\n     let crate_map = map::HashMap();\n     let mod_path_map = HashMap();\n@@ -81,21 +81,21 @@ fn mk_cstore(intr: @ident_interner) -> cstore {\n                      intr: intr});\n }\n \n-fn get_crate_data(cstore: cstore, cnum: ast::crate_num) -> crate_metadata {\n+fn get_crate_data(cstore: CStore, cnum: ast::crate_num) -> crate_metadata {\n     return p(cstore).metas.get(cnum);\n }\n \n-fn get_crate_hash(cstore: cstore, cnum: ast::crate_num) -> ~str {\n+fn get_crate_hash(cstore: CStore, cnum: ast::crate_num) -> ~str {\n     let cdata = get_crate_data(cstore, cnum);\n     return decoder::get_crate_hash(cdata.data);\n }\n \n-fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> ~str {\n+fn get_crate_vers(cstore: CStore, cnum: ast::crate_num) -> ~str {\n     let cdata = get_crate_data(cstore, cnum);\n     return decoder::get_crate_vers(cdata.data);\n }\n \n-fn set_crate_data(cstore: cstore, cnum: ast::crate_num,\n+fn set_crate_data(cstore: CStore, cnum: ast::crate_num,\n                   data: crate_metadata) {\n     p(cstore).metas.insert(cnum, data);\n     for vec::each(decoder::get_crate_module_paths(cstore.intr, data)) |dp| {\n@@ -105,57 +105,57 @@ fn set_crate_data(cstore: cstore, cnum: ast::crate_num,\n     }\n }\n \n-fn have_crate_data(cstore: cstore, cnum: ast::crate_num) -> bool {\n+fn have_crate_data(cstore: CStore, cnum: ast::crate_num) -> bool {\n     return p(cstore).metas.contains_key(cnum);\n }\n \n-fn iter_crate_data(cstore: cstore, i: fn(ast::crate_num, crate_metadata)) {\n+fn iter_crate_data(cstore: CStore, i: fn(ast::crate_num, crate_metadata)) {\n     for p(cstore).metas.each |k,v| { i(k, v);};\n }\n \n-fn add_used_crate_file(cstore: cstore, lib: &Path) {\n+fn add_used_crate_file(cstore: CStore, lib: &Path) {\n     if !vec::contains(p(cstore).used_crate_files, lib) {\n         p(cstore).used_crate_files.push(copy *lib);\n     }\n }\n \n-fn get_used_crate_files(cstore: cstore) -> ~[Path] {\n+fn get_used_crate_files(cstore: CStore) -> ~[Path] {\n     return p(cstore).used_crate_files;\n }\n \n-fn add_used_library(cstore: cstore, lib: ~str) -> bool {\n+fn add_used_library(cstore: CStore, lib: ~str) -> bool {\n     assert lib != ~\"\";\n \n     if vec::contains(p(cstore).used_libraries, &lib) { return false; }\n     p(cstore).used_libraries.push(lib);\n     return true;\n }\n \n-fn get_used_libraries(cstore: cstore) -> ~[~str] {\n+fn get_used_libraries(cstore: CStore) -> ~[~str] {\n     return p(cstore).used_libraries;\n }\n \n-fn add_used_link_args(cstore: cstore, args: ~str) {\n+fn add_used_link_args(cstore: CStore, args: ~str) {\n     p(cstore).used_link_args.push_all(str::split_char(args, ' '));\n }\n \n-fn get_used_link_args(cstore: cstore) -> ~[~str] {\n+fn get_used_link_args(cstore: CStore) -> ~[~str] {\n     return p(cstore).used_link_args;\n }\n \n-fn add_use_stmt_cnum(cstore: cstore, use_id: ast::node_id,\n+fn add_use_stmt_cnum(cstore: CStore, use_id: ast::node_id,\n                      cnum: ast::crate_num) {\n     p(cstore).use_crate_map.insert(use_id, cnum);\n }\n \n-fn find_use_stmt_cnum(cstore: cstore,\n+fn find_use_stmt_cnum(cstore: CStore,\n                       use_id: ast::node_id) -> Option<ast::crate_num> {\n     p(cstore).use_crate_map.find(use_id)\n }\n \n // returns hashes of crates directly used by this crate. Hashes are\n // sorted by crate name.\n-fn get_dep_hashes(cstore: cstore) -> ~[~str] {\n+fn get_dep_hashes(cstore: CStore) -> ~[~str] {\n     type crate_hash = {name: ~str, hash: ~str};\n     let mut result = ~[];\n \n@@ -175,7 +175,7 @@ fn get_dep_hashes(cstore: cstore) -> ~[~str] {\n     return vec::map(sorted, mapper);\n }\n \n-fn get_path(cstore: cstore, d: ast::def_id) -> ~[~str] {\n+fn get_path(cstore: CStore, d: ast::def_id) -> ~[~str] {\n     option::map_default(&p(cstore).mod_path_map.find(d), ~[],\n                         |ds| str::split_str(**ds, ~\"::\"))\n }"}, {"sha": "0b25f0670b427ba490db826686c022a71033a54f", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -52,7 +52,7 @@ type encode_parms = {\n     item_symbols: HashMap<ast::node_id, ~str>,\n     discrim_symbols: HashMap<ast::node_id, ~str>,\n     link_meta: link_meta,\n-    cstore: cstore::cstore,\n+    cstore: cstore::CStore,\n     encode_inlined_item: encode_inlined_item\n };\n \n@@ -77,7 +77,7 @@ enum encode_ctxt = {\n     item_symbols: HashMap<ast::node_id, ~str>,\n     discrim_symbols: HashMap<ast::node_id, ~str>,\n     link_meta: link_meta,\n-    cstore: cstore::cstore,\n+    cstore: cstore::CStore,\n     encode_inlined_item: encode_inlined_item,\n     type_abbrevs: abbrev_map\n };\n@@ -1035,9 +1035,9 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n }\n \n fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n-                     cstore: cstore::cstore) {\n+                     cstore: cstore::CStore) {\n \n-    fn get_ordered_deps(ecx: @encode_ctxt, cstore: cstore::cstore)\n+    fn get_ordered_deps(ecx: @encode_ctxt, cstore: cstore::CStore)\n         -> ~[decoder::crate_dep] {\n \n         type hashkv = @{key: crate_num, val: cstore::crate_metadata};"}, {"sha": "b2d20ce56e83883665d92d58dc14aed24767ab3d", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -3,7 +3,7 @@\n // probably just be folded into cstore.\n \n use result::Result;\n-export filesearch;\n+export FileSearch;\n export mk_filesearch;\n export pick;\n export pick_file;\n@@ -21,7 +21,7 @@ fn pick_file(file: Path, path: &Path) -> Option<Path> {\n     else { option::None }\n }\n \n-trait filesearch {\n+trait FileSearch {\n     fn sysroot() -> Path;\n     fn lib_search_paths() -> ~[Path];\n     fn get_target_lib_path() -> Path;\n@@ -30,11 +30,11 @@ trait filesearch {\n \n fn mk_filesearch(maybe_sysroot: Option<Path>,\n                  target_triple: &str,\n-                 addl_lib_search_paths: ~[Path]) -> filesearch {\n+                 addl_lib_search_paths: ~[Path]) -> FileSearch {\n     type filesearch_impl = {sysroot: Path,\n                             addl_lib_search_paths: ~[Path],\n                             target_triple: ~str};\n-    impl filesearch_impl: filesearch {\n+    impl filesearch_impl: FileSearch {\n         fn sysroot() -> Path { self.sysroot }\n         fn lib_search_paths() -> ~[Path] {\n             let mut paths = self.addl_lib_search_paths;\n@@ -64,10 +64,10 @@ fn mk_filesearch(maybe_sysroot: Option<Path>,\n     debug!(\"using sysroot = %s\", sysroot.to_str());\n     {sysroot: sysroot,\n      addl_lib_search_paths: addl_lib_search_paths,\n-     target_triple: str::from_slice(target_triple)} as filesearch\n+     target_triple: str::from_slice(target_triple)} as FileSearch\n }\n \n-fn search<T: Copy>(filesearch: filesearch, pick: pick<T>) -> Option<T> {\n+fn search<T: Copy>(filesearch: FileSearch, pick: pick<T>) -> Option<T> {\n     let mut rslt = None;\n     for filesearch.lib_search_paths().each |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());"}, {"sha": "61b8bcf9067b580ed8e8ccf2299509b3820fb520", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -5,7 +5,7 @@ use syntax::{ast, attr};\n use syntax::print::pprust;\n use syntax::codemap::span;\n use lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n-use filesearch::filesearch;\n+use filesearch::FileSearch;\n use io::WriterUtil;\n use syntax::parse::token::ident_interner;\n \n@@ -28,7 +28,7 @@ enum os {\n \n type ctxt = {\n     diag: span_handler,\n-    filesearch: filesearch,\n+    filesearch: FileSearch,\n     span: span,\n     ident: ast::ident,\n     metas: ~[@ast::meta_item],\n@@ -66,7 +66,7 @@ fn libname(cx: ctxt) -> {prefix: ~str, suffix: ~str} {\n \n fn find_library_crate_aux(cx: ctxt,\n                           nn: {prefix: ~str, suffix: ~str},\n-                          filesearch: filesearch::filesearch) ->\n+                          filesearch: filesearch::FileSearch) ->\n    Option<{ident: ~str, data: @~[u8]}> {\n     let crate_name = crate_name_from_metas(cx.metas);\n     let prefix: ~str = nn.prefix + crate_name + ~\"-\";"}, {"sha": "14aef6db1adbd9a5451dbb5ba59d80dde3e5910d", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -162,7 +162,7 @@ fn parse_bound_region(st: @pstate) -> ty::bound_region {\n     }\n }\n \n-fn parse_region(st: @pstate) -> ty::region {\n+fn parse_region(st: @pstate) -> ty::Region {\n     match next(st) {\n       'b' => {\n         ty::re_bound(parse_bound_region(st))"}, {"sha": "941dd35bdf0b4dcbb6eb47da15e5d1533aea8c5c", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -125,7 +125,7 @@ fn enc_substs(w: io::Writer, cx: @ctxt, substs: ty::substs) {\n     w.write_char(']');\n }\n \n-fn enc_region(w: io::Writer, cx: @ctxt, r: ty::region) {\n+fn enc_region(w: io::Writer, cx: @ctxt, r: ty::Region) {\n     match r {\n       ty::re_bound(br) => {\n         w.write_char('b');"}, {"sha": "b47e6d3b151c33fd6fe69ab5cfe7b3768ddc154d", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -19,7 +19,7 @@ use middle::{ty, typeck};\n use middle::typeck::{method_origin, method_map_entry,\n                      vtable_res,\n                      vtable_origin};\n-use driver::session::session;\n+use driver::session::Session;\n use middle::freevars::freevar_entry;\n use c = metadata::common;\n use e = metadata::encoder;\n@@ -136,7 +136,7 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n-fn reserve_id_range(sess: session,\n+fn reserve_id_range(sess: Session,\n                     from_id_range: ast_util::id_range) -> ast_util::id_range {\n     // Handle the case of an empty range:\n     if ast_util::empty(from_id_range) { return from_id_range; }\n@@ -379,8 +379,8 @@ impl ty::AutoRef: tr {\n     }\n }\n \n-impl ty::region: tr {\n-    fn tr(xcx: extended_decode_ctxt) -> ty::region {\n+impl ty::Region: tr {\n+    fn tr(xcx: extended_decode_ctxt) -> ty::Region {\n         match self {\n             ty::re_bound(br) => ty::re_bound(br.tr(xcx)),\n             ty::re_free(id, br) => ty::re_free(xcx.tr_id(id), br.tr(xcx)),"}, {"sha": "db0e092ed83e06758202eb961dd63c78a66552d0", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -229,7 +229,6 @@ use result::{Result, Ok, Err};\n use syntax::print::pprust;\n use util::common::indenter;\n use ty::to_str;\n-use driver::session::session;\n use dvec::DVec;\n use mem_categorization::*;\n \n@@ -319,8 +318,8 @@ enum bckerr_code {\n     err_mut_variant,\n     err_root_not_permitted,\n     err_mutbl(ast::mutability),\n-    err_out_of_root_scope(ty::region, ty::region), // superscope, subscope\n-    err_out_of_scope(ty::region, ty::region) // superscope, subscope\n+    err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n+    err_out_of_scope(ty::Region, ty::Region) // superscope, subscope\n }\n \n impl bckerr_code : cmp::Eq {\n@@ -436,7 +435,7 @@ fn root_map() -> root_map {\n // Misc\n \n impl borrowck_ctxt {\n-    fn is_subregion_of(r_sub: ty::region, r_sup: ty::region) -> bool {\n+    fn is_subregion_of(r_sub: ty::Region, r_sup: ty::Region) -> bool {\n         region::is_subregion_of(self.tcx.region_map, r_sub, r_sup)\n     }\n "}, {"sha": "e0eb5519d4da34a4818008ffac231c1b39ea8ea4", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -260,7 +260,7 @@ impl gather_loan_ctxt {\n     fn guarantee_valid(&self,\n                        cmt: cmt,\n                        req_mutbl: ast::mutability,\n-                       scope_r: ty::region) {\n+                       scope_r: ty::Region) {\n \n         self.bccx.guaranteed_paths += 1;\n \n@@ -390,7 +390,7 @@ impl gather_loan_ctxt {\n     fn add_loans(&self,\n                  cmt: cmt,\n                  req_mutbl: ast::mutability,\n-                 scope_r: ty::region,\n+                 scope_r: ty::Region,\n                  +loans: ~[Loan]) {\n         if loans.len() == 0 {\n             return;"}, {"sha": "7f4f857dae83fef92e915ec376fdffadf01be359", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -7,7 +7,7 @@ use result::{Result, Ok, Err};\n \n impl borrowck_ctxt {\n     fn loan(cmt: cmt,\n-            scope_region: ty::region,\n+            scope_region: ty::Region,\n             mutbl: ast::mutability) -> bckres<~[Loan]> {\n         let lc = LoanContext {\n             bccx: self,\n@@ -28,7 +28,7 @@ struct LoanContext {\n     bccx: borrowck_ctxt,\n \n     // the region scope for which we must preserve the memory\n-    scope_region: ty::region,\n+    scope_region: ty::Region,\n \n     // accumulated list of loans that will be required\n     mut loans: ~[Loan]\n@@ -39,7 +39,7 @@ impl LoanContext {\n \n     fn issue_loan(&self,\n                   cmt: cmt,\n-                  scope_ub: ty::region,\n+                  scope_ub: ty::Region,\n                   req_mutbl: ast::mutability) -> bckres<()> {\n         if self.bccx.is_subregion_of(self.scope_region, scope_ub) {\n             match req_mutbl {"}, {"sha": "556ea7867cfcac3ecc44205dda088d806c10c6d8", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -23,7 +23,7 @@ impl preserve_condition {\n \n impl borrowck_ctxt {\n     fn preserve(cmt: cmt,\n-                scope_region: ty::region,\n+                scope_region: ty::Region,\n                 item_ub: ast::node_id,\n                 root_ub: ast::node_id)\n         -> bckres<preserve_condition> {\n@@ -41,7 +41,7 @@ enum preserve_ctxt = {\n     bccx: borrowck_ctxt,\n \n     // the region scope for which we must preserve the memory\n-    scope_region: ty::region,\n+    scope_region: ty::Region,\n \n     // the scope for the body of the enclosing fn/method item\n     item_ub: ast::node_id,\n@@ -277,7 +277,7 @@ priv impl &preserve_ctxt {\n     /// Checks that the scope for which the value must be preserved\n     /// is a subscope of `scope_ub`; if so, success.\n     fn compare_scope(cmt: cmt,\n-                     scope_ub: ty::region) -> bckres<preserve_condition> {\n+                     scope_ub: ty::Region) -> bckres<preserve_condition> {\n         if self.bccx.is_subregion_of(self.scope_region, scope_ub) {\n             Ok(pc_ok)\n         } else {"}, {"sha": "563ea8f84be76960fe09f672d5181cabe4717a8a", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,5 +1,4 @@\n use syntax::{ast, ast_util};\n-use driver::session::session;\n use syntax::codemap::span;\n use std::map;\n use std::map::HashMap;"}, {"sha": "fc040ecc4cd3af80acefef0d6ca6216bddb50f10", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -7,7 +7,6 @@ use syntax::print::pprust::pat_to_str;\n use util::ppaux::ty_to_str;\n use pat_util::*;\n use syntax::visit;\n-use driver::session::session;\n use middle::ty;\n use middle::ty::*;\n use std::map::HashMap;"}, {"sha": "bdc042fb764e91fc6e86ec234ab089e676a939cc", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,10 +1,10 @@\n use syntax::ast::*;\n use syntax::{visit, ast_util, ast_map};\n-use driver::session::session;\n+use driver::session::Session;\n use std::map::HashMap;\n use dvec::DVec;\n \n-fn check_crate(sess: session, crate: @crate, ast_map: ast_map::map,\n+fn check_crate(sess: Session, crate: @crate, ast_map: ast_map::map,\n                def_map: resolve::DefMap,\n                 method_map: typeck::method_map, tcx: ty::ctxt) {\n     visit::visit_crate(*crate, false, visit::mk_vt(@{\n@@ -17,7 +17,7 @@ fn check_crate(sess: session, crate: @crate, ast_map: ast_map::map,\n     sess.abort_if_errors();\n }\n \n-fn check_item(sess: session, ast_map: ast_map::map,\n+fn check_item(sess: Session, ast_map: ast_map::map,\n               def_map: resolve::DefMap,\n               it: @item, &&_is_const: bool, v: visit::vt<bool>) {\n     match it.node {\n@@ -55,7 +55,7 @@ fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n     }\n }\n \n-fn check_expr(sess: session, def_map: resolve::DefMap,\n+fn check_expr(sess: Session, def_map: resolve::DefMap,\n               method_map: typeck::method_map, tcx: ty::ctxt,\n               e: @expr, &&is_const: bool, v: visit::vt<bool>) {\n     if is_const {\n@@ -142,12 +142,12 @@ fn check_expr(sess: session, def_map: resolve::DefMap,\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n-fn check_item_recursion(sess: session, ast_map: ast_map::map,\n+fn check_item_recursion(sess: Session, ast_map: ast_map::map,\n                         def_map: resolve::DefMap, it: @item) {\n \n     type env = {\n         root_it: @item,\n-        sess: session,\n+        sess: Session,\n         ast_map: ast_map::map,\n         def_map: resolve::DefMap,\n         idstack: @DVec<node_id>,"}, {"sha": "3fa7f34fb33e27ef46205d7827207c5a7e86ddec", "filename": "src/rustc/middle/check_loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_loop.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,6 +1,5 @@\n use syntax::ast::*;\n use syntax::visit;\n-use driver::session::session;\n \n type ctx = {in_loop: bool, can_ret: bool};\n "}, {"sha": "e4dc9e8330e88d8cf3e6920c5754a914347f0755", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,8 +1,7 @@\n use syntax::{visit, ast_util};\n use syntax::ast::*;\n use syntax::codemap::span;\n-use ty::{kind, kind_copyable, kind_noncopyable, kind_const};\n-use driver::session::session;\n+use middle::ty::{Kind, kind_copyable, kind_noncopyable, kind_const};\n use std::map::HashMap;\n use util::ppaux::{ty_to_str, tys_to_str};\n use syntax::print::pprust::expr_to_str;\n@@ -40,7 +39,7 @@ use lint::{non_implicitly_copyable_typarams,implicit_copies};\n \n const try_adding: &str = \"Try adding a move\";\n \n-fn kind_to_str(k: kind) -> ~str {\n+fn kind_to_str(k: Kind) -> ~str {\n     let mut kinds = ~[];\n \n     if ty::kind_lteq(kind_const(), k) {\n@@ -387,7 +386,7 @@ fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n     visit::visit_stmt(stmt, cx, v);\n }\n \n-fn check_ty(aty: @ty, cx: ctx, v: visit::vt<ctx>) {\n+fn check_ty(aty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n     match aty.node {\n       ty_path(_, id) => {\n         do option::iter(&cx.tcx.node_type_substs.find(id)) |ts| {"}, {"sha": "383fe2db3231c001a88f03df7db3370b16fde391", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -9,7 +9,7 @@\n //\n // * Functions called by the compiler itself.\n \n-use driver::session::session;\n+use driver::session::Session;\n use metadata::csearch::{each_path, get_item_attrs};\n use metadata::cstore::{iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n@@ -50,7 +50,7 @@ struct LanguageItems {\n     mut log_type_fn: Option<def_id>\n }\n \n-mod LanguageItems {\n+mod language_items {\n     #[legacy_exports];\n     fn make() -> LanguageItems {\n         LanguageItems {\n@@ -83,7 +83,7 @@ mod LanguageItems {\n     }\n }\n \n-fn LanguageItemCollector(crate: @crate, session: session,\n+fn LanguageItemCollector(crate: @crate, session: Session,\n                          items: &r/LanguageItems)\n     -> LanguageItemCollector/&r {\n \n@@ -127,7 +127,7 @@ struct LanguageItemCollector {\n     items: &LanguageItems,\n \n     crate: @crate,\n-    session: session,\n+    session: Session,\n \n     item_refs: HashMap<~str,&mut Option<def_id>>,\n }\n@@ -239,8 +239,8 @@ impl LanguageItemCollector {\n     }\n }\n \n-fn collect_language_items(crate: @crate, session: session) -> LanguageItems {\n-    let items = LanguageItems::make();\n+fn collect_language_items(crate: @crate, session: Session) -> LanguageItems {\n+    let items = language_items::make();\n     let collector = LanguageItemCollector(crate, session, &items);\n     collector.collect();\n     copy items"}, {"sha": "0768a09252247f96e955fddaeec4e05c0916d9b9", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,5 +1,5 @@\n use driver::session;\n-use driver::session::session;\n+use driver::session::Session;\n use middle::ty;\n use syntax::{ast, ast_util, visit};\n use syntax::attr;\n@@ -244,7 +244,7 @@ fn clone_lint_modes(modes: lint_modes) -> lint_modes {\n type ctxt_ = {dict: lint_dict,\n               curr: lint_modes,\n               is_default: bool,\n-              sess: session};\n+              sess: Session};\n \n enum ctxt {\n     ctxt_(ctxt_)\n@@ -355,7 +355,7 @@ fn build_settings_item(i: @ast::item, &&cx: ctxt, v: visit::vt<ctxt>) {\n     }\n }\n \n-fn build_settings_crate(sess: session::session, crate: @ast::crate) {\n+fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n \n     let cx = ctxt_({dict: get_lint_dict(),\n                     curr: std::smallintmap::mk(),"}, {"sha": "89d5c842a9f62aa4435d3de83b8725a04d6f3f8d", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -99,7 +99,6 @@ use syntax::print::pprust::{expr_to_str};\n use visit::vt;\n use syntax::codemap::span;\n use syntax::ast::*;\n-use driver::session::session;\n use io::WriterUtil;\n use capture::{cap_move, cap_drop, cap_copy, cap_ref};\n "}, {"sha": "a61cb28c16b1a925de2526f7bd2cda7f1edb1803", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -122,7 +122,7 @@ impl categorization : cmp::Eq {\n enum ptr_kind {\n     uniq_ptr,\n     gc_ptr,\n-    region_ptr(ty::region),\n+    region_ptr(ty::Region),\n     unsafe_ptr\n }\n \n@@ -993,7 +993,7 @@ impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn region_to_str(r: ty::region) -> ~str {\n+    fn region_to_str(r: ty::Region) -> ~str {\n         region_to_str(self.tcx, r)\n     }\n }"}, {"sha": "5c70cd3e2795e76934de4413a4904c64ecd2f474", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -7,7 +7,7 @@ region parameterized.\n \n */\n \n-use driver::session::session;\n+use driver::session::Session;\n use middle::ty;\n use syntax::{ast, visit};\n use syntax::codemap::span;\n@@ -41,7 +41,7 @@ Encodes the bounding lifetime for a given AST node:\n type region_map = HashMap<ast::node_id, ast::node_id>;\n \n struct ctxt {\n-    sess: session,\n+    sess: Session,\n     def_map: resolve::DefMap,\n \n     // Generated maps:\n@@ -108,8 +108,8 @@ fn scope_contains(region_map: region_map, superscope: ast::node_id,\n /// intended to run *after inference* and sadly the logic is somewhat\n /// duplicated with the code in infer.rs.\n fn is_subregion_of(region_map: region_map,\n-                   sub_region: ty::region,\n-                   super_region: ty::region) -> bool {\n+                   sub_region: ty::Region,\n+                   super_region: ty::Region) -> bool {\n     sub_region == super_region ||\n         match (sub_region, super_region) {\n           (_, ty::re_static) => {\n@@ -328,7 +328,7 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n     visit::visit_fn(fk, decl, body, sp, id, fn_cx, visitor);\n }\n \n-fn resolve_crate(sess: session, def_map: resolve::DefMap,\n+fn resolve_crate(sess: Session, def_map: resolve::DefMap,\n                  crate: @ast::crate) -> region_map {\n     let cx: ctxt = ctxt {sess: sess,\n                          def_map: def_map,\n@@ -382,7 +382,7 @@ impl region_dep : cmp::Eq {\n }\n \n type determine_rp_ctxt_ = {\n-    sess: session,\n+    sess: Session,\n     ast_map: ast_map::map,\n     def_map: resolve::DefMap,\n     region_paramd_items: region_paramd_items,\n@@ -599,7 +599,7 @@ fn determine_rp_in_ty_method(ty_m: ast::ty_method,\n     }\n }\n \n-fn determine_rp_in_ty(ty: @ast::ty,\n+fn determine_rp_in_ty(ty: @ast::Ty,\n                       &&cx: determine_rp_ctxt,\n                       visitor: visit::vt<determine_rp_ctxt>) {\n \n@@ -755,7 +755,7 @@ fn determine_rp_in_struct_field(cm: @ast::struct_field,\n     }\n }\n \n-fn determine_rp_in_crate(sess: session,\n+fn determine_rp_in_crate(sess: Session,\n                          ast_map: ast_map::map,\n                          def_map: resolve::DefMap,\n                          crate: @ast::crate) -> region_paramd_items {"}, {"sha": "81ea6daf19581e916c5b534b16f63b0b99102884", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 201, "deletions": 257, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,4 +1,4 @@\n-use driver::session::session;\n+use driver::session::Session;\n use metadata::csearch::{each_path, get_method_names_if_trait};\n use metadata::cstore::find_use_stmt_cnum;\n use metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n@@ -35,7 +35,7 @@ use syntax::ast::{pat_box, pat_lit, pat_range, pat_rec, pat_struct};\n use syntax::ast::{pat_tup, pat_uniq, pat_wild, private, provided, public};\n use syntax::ast::{required, rem, self_ty_, shl, shr, stmt_decl};\n use syntax::ast::{struct_field, struct_variant_kind, sty_static, subtract};\n-use syntax::ast::{trait_ref, tuple_variant_kind, ty, ty_bool, ty_char};\n+use syntax::ast::{trait_ref, tuple_variant_kind, Ty, ty_bool, ty_char};\n use syntax::ast::{ty_f, ty_f32, ty_f64, ty_float, ty_i, ty_i16, ty_i32};\n use syntax::ast::{ty_i64, ty_i8, ty_int, ty_param, ty_path, ty_str, ty_u};\n use syntax::ast::{ty_u16, ty_u32, ty_u64, ty_u8, ty_uint, type_value_ns};\n@@ -115,7 +115,6 @@ impl PatternBindingMode : cmp::Eq {\n \n \n enum Namespace {\n-    ModuleNS,\n     TypeNS,\n     ValueNS\n }\n@@ -166,19 +165,8 @@ enum CaptureClause {\n \n type ResolveVisitor = vt<()>;\n \n-enum ModuleDef {\n-    NoModuleDef,                     // Does not define a module.\n-    ModuleDef(Privacy, @Module),     // Defines a module.\n-}\n-\n-impl ModuleDef {\n-    pure fn is_none() -> bool {\n-        match self { NoModuleDef => true, _ => false }\n-    }\n-}\n-\n enum ImportDirectiveNS {\n-    ModuleNSOnly,\n+    TypeNSOnly,\n     AnyNS\n }\n \n@@ -363,7 +351,6 @@ struct ImportResolution {\n \n     mut outstanding_references: uint,\n \n-    mut module_target: Option<Target>,\n     mut value_target: Option<Target>,\n     mut type_target: Option<Target>,\n \n@@ -375,7 +362,6 @@ fn ImportResolution(privacy: Privacy, span: span) -> ImportResolution {\n         privacy: privacy,\n         span: span,\n         outstanding_references: 0u,\n-        module_target: None,\n         value_target: None,\n         type_target: None,\n         used: false\n@@ -385,7 +371,6 @@ fn ImportResolution(privacy: Privacy, span: span) -> ImportResolution {\n impl ImportResolution {\n     fn target_for_namespace(namespace: Namespace) -> Option<Target> {\n         match namespace {\n-            ModuleNS    => return copy self.module_target,\n             TypeNS      => return copy self.type_target,\n             ValueNS     => return copy self.value_target\n         }\n@@ -482,7 +467,7 @@ pure fn is_none<T>(x: Option<T>) -> bool {\n     }\n }\n \n-fn unused_import_lint_level(session: session) -> level {\n+fn unused_import_lint_level(session: Session) -> level {\n     for session.opts.lint_opts.each |lint_option_pair| {\n         let (lint_type, lint_level) = *lint_option_pair;\n         if lint_type == unused_imports {\n@@ -504,22 +489,26 @@ impl Privacy : cmp::Eq {\n     pure fn ne(other: &Privacy) -> bool { !self.eq(other) }\n }\n \n-// Records a possibly-private definition.\n-struct Definition {\n+// Records a possibly-private type definition.\n+enum TypeNsDef {\n+    ModuleDef(Privacy, @Module),\n+    TypeDef(Privacy, def)\n+}\n+\n+// Records a possibly-private value definition.\n+struct ValueNsDef {\n     privacy: Privacy,\n     def: def,\n }\n \n // Records the definitions (at most one for each namespace) that a name is\n // bound to.\n struct NameBindings {\n-    mut module_def: ModuleDef,         //< Meaning in module namespace.\n-    mut type_def: Option<Definition>,  //< Meaning in type namespace.\n-    mut value_def: Option<Definition>, //< Meaning in value namespace.\n+    mut type_def: Option<TypeNsDef>,    //< Meaning in type namespace.\n+    mut value_def: Option<ValueNsDef>,  //< Meaning in value namespace.\n \n     // For error reporting\n-    // XXX: Merge me into Definition.\n-    mut module_span: Option<span>,\n+    // XXX: Merge me into TypeDef and ValueDef.\n     mut type_span: Option<span>,\n     mut value_span: Option<span>,\n }\n@@ -532,30 +521,30 @@ impl NameBindings {\n                      def_id: Option<def_id>,\n                      legacy_exports: bool,\n                      sp: span) {\n-        if self.module_def.is_none() {\n+        if self.type_def.is_none() {\n             let module_ = @Module(parent_link, def_id, legacy_exports);\n-            self.module_def = ModuleDef(privacy, module_);\n-            self.module_span = Some(sp);\n+            self.type_def = Some(ModuleDef(privacy, module_));\n+            self.type_span = Some(sp);\n         }\n     }\n \n     /// Records a type definition.\n     fn define_type(privacy: Privacy, def: def, sp: span) {\n-        self.type_def = Some(Definition { privacy: privacy, def: def });\n+        self.type_def = Some(TypeDef(privacy, def));\n         self.type_span = Some(sp);\n     }\n \n     /// Records a value definition.\n     fn define_value(privacy: Privacy, def: def, sp: span) {\n-        self.value_def = Some(Definition { privacy: privacy, def: def });\n+        self.value_def = Some(ValueNsDef { privacy: privacy, def: def });\n         self.value_span = Some(sp);\n     }\n \n     /// Returns the module node if applicable.\n     fn get_module_if_available() -> Option<@Module> {\n-        match self.module_def {\n-            NoModuleDef         => return None,\n-            ModuleDef(_privacy, module_)  => return Some(module_)\n+        match self.type_def {\n+            Some(ModuleDef(_, module_)) => return Some(module_),\n+            None | Some(TypeDef(_, _))  => return None,\n         }\n     }\n \n@@ -564,70 +553,76 @@ impl NameBindings {\n      * definition.\n      */\n     fn get_module() -> @Module {\n-        match self.module_def {\n-            NoModuleDef => {\n-                fail\n-                    ~\"get_module called on a node with no module definition!\";\n-            }\n-            ModuleDef(_, module_) => {\n-                return module_;\n+        match self.type_def {\n+            None | Some(TypeDef(*)) => {\n+                fail ~\"get_module called on a node with no module \\\n+                       definition!\"\n             }\n+            Some(ModuleDef(_, module_)) => module_\n         }\n     }\n \n     fn defined_in_namespace(namespace: Namespace) -> bool {\n         match namespace {\n-            ModuleNS => {\n-                match self.module_def {\n-                    NoModuleDef => false,\n-                    _ => true\n-                }\n-            }\n             TypeNS   => return self.type_def.is_some(),\n             ValueNS  => return self.value_def.is_some()\n         }\n     }\n \n-    fn def_for_namespace(namespace: Namespace) -> Option<Definition> {\n+    fn def_for_namespace(namespace: Namespace) -> Option<def> {\n         match namespace {\n-          TypeNS => return self.type_def,\n-          ValueNS => return self.value_def,\n-          ModuleNS => match self.module_def {\n-            NoModuleDef => return None,\n-            ModuleDef(privacy, module_) =>\n-                match module_.def_id {\n-                    None => return None,\n-                    Some(def_id) => {\n-                        return Some(Definition {\n-                            privacy: privacy,\n-                            def: def_mod(def_id)\n-                        });\n+            TypeNS => {\n+                match self.type_def {\n+                    None => None,\n+                    Some(ModuleDef(_, module_)) => {\n+                        module_.def_id.map(|def_id| def_mod(*def_id))\n                     }\n+                    Some(TypeDef(_, def)) => Some(def)\n                 }\n-          }\n+            }\n+            ValueNS => {\n+                match self.value_def {\n+                    None => None,\n+                    Some(value_def) => Some(value_def.def)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn privacy_for_namespace(namespace: Namespace) -> Option<Privacy> {\n+        match namespace {\n+            TypeNS => {\n+                match self.type_def {\n+                    None => None,\n+                    Some(ModuleDef(privacy, _)) | Some(TypeDef(privacy, _)) =>\n+                        Some(privacy)\n+                }\n+            }\n+            ValueNS => {\n+                match self.value_def {\n+                    None => None,\n+                    Some(value_def) => Some(value_def.privacy)\n+                }\n+            }\n         }\n     }\n \n     fn span_for_namespace(namespace: Namespace) -> Option<span> {\n-        match self.def_for_namespace(namespace) {\n-          Some(_) => {\n+        if self.defined_in_namespace(namespace) {\n             match namespace {\n-              TypeNS   => self.type_span,\n-              ValueNS  => self.value_span,\n-              ModuleNS => self.module_span\n+                TypeNS  => self.type_span,\n+                ValueNS => self.value_span,\n             }\n-          }\n-          None => None\n+        } else {\n+            None\n         }\n     }\n }\n \n fn NameBindings() -> NameBindings {\n     NameBindings {\n-        module_def: NoModuleDef,\n         type_def: None,\n         value_def: None,\n-        module_span: None,\n         type_span: None,\n         value_span: None\n     }\n@@ -675,9 +670,8 @@ fn PrimitiveTypeTable(intr: @ident_interner) -> PrimitiveTypeTable {\n \n fn namespace_to_str(ns: Namespace) -> ~str {\n     match ns {\n-      TypeNS   => ~\"type\",\n-      ValueNS  => ~\"value\",\n-      ModuleNS => ~\"module\"\n+        TypeNS  => ~\"type\",\n+        ValueNS => ~\"value\",\n     }\n }\n \n@@ -693,9 +687,8 @@ fn has_legacy_export_attr(attrs: &[syntax::ast::attribute]) -> bool {\n     return false;\n }\n \n-fn Resolver(session: session, lang_items: LanguageItems,\n+fn Resolver(session: Session, lang_items: LanguageItems,\n             crate: @crate) -> Resolver {\n-\n     let graph_root = @NameBindings();\n \n     (*graph_root).define_module(Public,\n@@ -735,7 +728,7 @@ fn Resolver(session: session, lang_items: LanguageItems,\n         primitive_type_table: @PrimitiveTypeTable(session.\n                                                   parse_sess.interner),\n \n-        namespaces: ~[ ModuleNS, TypeNS, ValueNS ],\n+        namespaces: ~[ TypeNS, ValueNS ],\n \n         def_map: HashMap(),\n         export_map2: HashMap(),\n@@ -749,7 +742,7 @@ fn Resolver(session: session, lang_items: LanguageItems,\n \n /// The main resolver class.\n struct Resolver {\n-    session: session,\n+    session: Session,\n     lang_items: LanguageItems,\n     crate: @crate,\n \n@@ -992,40 +985,45 @@ impl Resolver {\n \n         match item.node {\n             item_mod(module_) => {\n-              let legacy = has_legacy_export_attr(item.attrs);\n-              let (name_bindings, new_parent) = self.add_child(ident, parent,\n-                                                       ~[ModuleNS], sp);\n+                let legacy = has_legacy_export_attr(item.attrs);\n+                let (name_bindings, new_parent) =\n+                    self.add_child(ident, parent, ~[TypeNS], sp);\n \n                 let parent_link = self.get_parent_link(new_parent, ident);\n                 let def_id = { crate: 0, node: item.id };\n-              (*name_bindings).define_module(privacy, parent_link,\n-                                             Some(def_id), legacy, sp);\n+                (*name_bindings).define_module(privacy, parent_link,\n+                                               Some(def_id), legacy, sp);\n \n                 let new_parent =\n                     ModuleReducedGraphParent((*name_bindings).get_module());\n \n                 visit_mod(module_, sp, item.id, new_parent, visitor);\n             }\n             item_foreign_mod(fm) => {\n-              let legacy = has_legacy_export_attr(item.attrs);\n-              let new_parent = match fm.sort {\n-                named => {\n-                  let (name_bindings, new_parent) = self.add_child(ident,\n-                     parent, ~[ModuleNS], sp);\n+                let legacy = has_legacy_export_attr(item.attrs);\n+                let new_parent = match fm.sort {\n+                    named => {\n+                        let (name_bindings, new_parent) =\n+                            self.add_child(ident, parent, ~[TypeNS], sp);\n \n-                  let parent_link = self.get_parent_link(new_parent, ident);\n-                  let def_id = { crate: 0, node: item.id };\n-                  (*name_bindings).define_module(privacy, parent_link,\n-                                                 Some(def_id), legacy, sp);\n+                        let parent_link = self.get_parent_link(new_parent,\n+                                                               ident);\n+                        let def_id = { crate: 0, node: item.id };\n+                        (*name_bindings).define_module(privacy,\n+                                                       parent_link,\n+                                                       Some(def_id),\n+                                                       legacy,\n+                                                       sp);\n+\n+                        ModuleReducedGraphParent(name_bindings.get_module())\n+                    }\n \n-                  ModuleReducedGraphParent((*name_bindings).get_module())\n-                }\n-                // For anon foreign mods, the contents just go in the\n-                // current scope\n-                anonymous => parent\n-              };\n+                    // For anon foreign mods, the contents just go in the\n+                    // current scope\n+                    anonymous => parent\n+                };\n \n-              visit_item(item, new_parent, visitor);\n+                visit_item(item, new_parent, visitor);\n             }\n \n             // These items live in the value namespace.\n@@ -1226,7 +1224,7 @@ impl Resolver {\n                     match view_path.node {\n                         view_path_simple(binding, full_path, ns, _) => {\n                             let ns = match ns {\n-                                module_ns => ModuleNSOnly,\n+                                module_ns => TypeNSOnly,\n                                 type_value_ns => AnyNS\n                             };\n \n@@ -1326,8 +1324,7 @@ impl Resolver {\n                 match find_use_stmt_cnum(self.session.cstore, node_id) {\n                     Some(crate_id) => {\n                         let (child_name_bindings, new_parent) =\n-                            // should this be in ModuleNS? --tjc\n-                            self.add_child(name, parent, ~[ModuleNS],\n+                            self.add_child(name, parent, ~[TypeNS],\n                                            view_item.span);\n \n                         let def_id = { crate: crate_id, node: 0 };\n@@ -1410,8 +1407,8 @@ impl Resolver {\n                            ident: ident, new_parent: ReducedGraphParent) {\n         match def {\n           def_mod(def_id) | def_foreign_mod(def_id) => {\n-            match copy child_name_bindings.module_def {\n-              NoModuleDef => {\n+            match copy child_name_bindings.type_def {\n+              None => {\n                 debug!(\"(building reduced graph for \\\n                         external crate) building module \\\n                         %s\", final_ident);\n@@ -1441,10 +1438,8 @@ impl Resolver {\n                         fail ~\"can't happen\";\n                       }\n                       ModuleParentLink(parent_module, ident) => {\n-\n                         let name_bindings = parent_module.children.get(ident);\n-\n-                        resolution.module_target =\n+                        resolution.type_target =\n                             Some(Target(parent_module, name_bindings));\n                       }\n                     }\n@@ -1456,13 +1451,16 @@ impl Resolver {\n                   }\n                 }\n               }\n-              ModuleDef(_priv, module_) => {\n+              Some(ModuleDef(_, module_)) => {\n                 debug!(\"(building reduced graph for \\\n                         external crate) already created \\\n                         module\");\n                 module_.def_id = Some(def_id);\n                 modules.insert(def_id, module_);\n               }\n+              Some(TypeDef(*)) => {\n+                self.session.bug(~\"external module def overwriting type def\");\n+              }\n             }\n           }\n           def_fn(*) | def_static_method(*) | def_const(*) |\n@@ -1553,8 +1551,8 @@ impl Resolver {\n                                    ~[], dummy_sp());\n \n                 // Define or reuse the module node.\n-                match child_name_bindings.module_def {\n-                    NoModuleDef => {\n+                match child_name_bindings.type_def {\n+                    None => {\n                         debug!(\"(building reduced graph for external crate) \\\n                                 autovivifying %s\", *ident_str);\n                         let parent_link = self.get_parent_link(new_parent,\n@@ -1564,7 +1562,7 @@ impl Resolver {\n                                                              None, false,\n                                                              dummy_sp());\n                     }\n-                    ModuleDef(*) => { /* Fall through. */ }\n+                    Some(_) => { /* Fall through. */ }\n                 }\n \n                 current_module = (*child_name_bindings).get_module();\n@@ -1807,7 +1805,7 @@ impl Resolver {\n                                                            target,\n                                                            source);\n                         }\n-                        SingleImport(target, source, ModuleNSOnly) => {\n+                        SingleImport(target, source, TypeNSOnly) => {\n                             resolution_result =\n                                 self.resolve_single_module_import\n                                     (module_, containing_module, target,\n@@ -1876,12 +1874,11 @@ impl Resolver {\n             return Failed;\n         }\n \n-        // We need to resolve all four namespaces for this to succeed.\n+        // We need to resolve both namespaces for this to succeed.\n         //\n         // XXX: See if there's some way of handling namespaces in a more\n-        // generic way. We have four of them; it seems worth doing...\n+        // generic way. We have two of them; it seems worth doing...\n \n-        let mut module_result = UnknownResult;\n         let mut value_result = UnknownResult;\n         let mut type_result = UnknownResult;\n \n@@ -1891,10 +1888,6 @@ impl Resolver {\n                 // Continue.\n             }\n             Some(child_name_bindings) => {\n-                if (*child_name_bindings).defined_in_namespace(ModuleNS) {\n-                    module_result = BoundResult(containing_module,\n-                                                child_name_bindings);\n-                }\n                 if (*child_name_bindings).defined_in_namespace(ValueNS) {\n                     value_result = BoundResult(containing_module,\n                                                child_name_bindings);\n@@ -1906,11 +1899,10 @@ impl Resolver {\n             }\n         }\n \n-        // Unless we managed to find a result in all four namespaces\n-        // (exceedingly unlikely), search imports as well.\n-\n-        match (module_result, value_result, type_result) {\n-            (BoundResult(*), BoundResult(*), BoundResult(*)) => {\n+        // Unless we managed to find a result in both namespaces (unlikely),\n+        // search imports as well.\n+        match (value_result, type_result) {\n+            (BoundResult(*), BoundResult(*)) => {\n                 // Continue.\n             }\n             _ => {\n@@ -1934,9 +1926,6 @@ impl Resolver {\n                         // therefore accurately report that the names are\n                         // unbound.\n \n-                        if module_result.is_unknown() {\n-                            module_result = UnboundResult;\n-                        }\n                         if value_result.is_unknown() {\n                             value_result = UnboundResult;\n                         }\n@@ -1973,11 +1962,6 @@ impl Resolver {\n \n                         // The name is an import which has been fully\n                         // resolved. We can, therefore, just follow it.\n-\n-                        if module_result.is_unknown() {\n-                            module_result = get_binding(import_resolution,\n-                                                        ModuleNS);\n-                        }\n                         if value_result.is_unknown() {\n                             value_result = get_binding(import_resolution,\n                                                        ValueNS);\n@@ -2001,20 +1985,6 @@ impl Resolver {\n         assert module_.import_resolutions.contains_key(target);\n         let import_resolution = module_.import_resolutions.get(target);\n \n-        match module_result {\n-            BoundResult(target_module, name_bindings) => {\n-                debug!(\"(resolving single import) found module binding\");\n-                import_resolution.module_target =\n-                    Some(Target(target_module, name_bindings));\n-            }\n-            UnboundResult => {\n-                debug!(\"(resolving single import) didn't find module \\\n-                        binding\");\n-            }\n-            UnknownResult => {\n-                fail ~\"module result should be known at this point\";\n-            }\n-        }\n         match value_result {\n             BoundResult(target_module, name_bindings) => {\n                 import_resolution.value_target =\n@@ -2037,12 +2007,10 @@ impl Resolver {\n         }\n \n         let i = import_resolution;\n-        match (i.module_target, i.value_target, i.type_target) {\n-          /*\n-            If this name wasn't found in any of the four namespaces, it's\n-            definitely unresolved\n-           */\n-          (None, None, None) => { return Failed; }\n+        match (i.value_target, i.type_target) {\n+          // If this name wasn't found in either namespace, it's definitely\n+          // unresolved.\n+          (None, None) => { return Failed; }\n           _ => {}\n         }\n \n@@ -2081,7 +2049,7 @@ impl Resolver {\n                 // Continue.\n             }\n             Some(child_name_bindings) => {\n-                if (*child_name_bindings).defined_in_namespace(ModuleNS) {\n+                if (*child_name_bindings).defined_in_namespace(TypeNS) {\n                     module_result = BoundResult(containing_module,\n                                                 child_name_bindings);\n                 }\n@@ -2125,8 +2093,8 @@ impl Resolver {\n                         // resolved. We can, therefore, just follow it.\n \n                         if module_result.is_unknown() {\n-                            match (*import_resolution).\n-                                    target_for_namespace(ModuleNS) {\n+                            match (*import_resolution).target_for_namespace(\n+                                    TypeNS) {\n                                 None => {\n                                     module_result = UnboundResult;\n                                 }\n@@ -2156,7 +2124,7 @@ impl Resolver {\n         match module_result {\n             BoundResult(target_module, name_bindings) => {\n                 debug!(\"(resolving single import) found module binding\");\n-                import_resolution.module_target =\n+                import_resolution.type_target =\n                     Some(Target(target_module, name_bindings));\n             }\n             UnboundResult => {\n@@ -2169,8 +2137,8 @@ impl Resolver {\n         }\n \n         let i = import_resolution;\n-        if i.module_target.is_none() {\n-          // If this name wasn't found in the module namespace, it's\n+        if i.type_target.is_none() {\n+          // If this name wasn't found in the type namespace, it's\n           // definitely unresolved.\n           return Failed;\n         }\n@@ -2222,7 +2190,7 @@ impl Resolver {\n \n             debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n-                   is_none(target_import_resolution.module_target),\n+                   is_none(target_import_resolution.type_target),\n                    self.module_to_str(module_));\n \n             // Here we merge two import resolutions.\n@@ -2232,8 +2200,6 @@ impl Resolver {\n                     let new_import_resolution =\n                         @ImportResolution(privacy,\n                                           target_import_resolution.span);\n-                    new_import_resolution.module_target =\n-                        copy target_import_resolution.module_target;\n                     new_import_resolution.value_target =\n                         copy target_import_resolution.value_target;\n                     new_import_resolution.type_target =\n@@ -2246,15 +2212,6 @@ impl Resolver {\n                     // Merge the two import resolutions at a finer-grained\n                     // level.\n \n-                    match copy target_import_resolution.module_target {\n-                        None => {\n-                            // Continue.\n-                        }\n-                        Some(module_target) => {\n-                            dest_import_resolution.module_target =\n-                                Some(copy module_target);\n-                        }\n-                    }\n                     match copy target_import_resolution.value_target {\n                         None => {\n                             // Continue.\n@@ -2307,11 +2264,6 @@ impl Resolver {\n                    self.module_to_str(module_));\n \n             // Merge the child item into the import resolution.\n-            if (*name_bindings).defined_in_namespace(ModuleNS) {\n-                debug!(\"(resolving glob import) ... for module target\");\n-                dest_import_resolution.module_target =\n-                    Some(Target(containing_module, name_bindings));\n-            }\n             if (*name_bindings).defined_in_namespace(ValueNS) {\n                 debug!(\"(resolving glob import) ... for value target\");\n                 dest_import_resolution.value_target =\n@@ -2345,9 +2297,8 @@ impl Resolver {\n \n         while index < module_path_len {\n             let name = (*module_path).get_elt(index);\n-            match self.resolve_name_in_module(search_module, name, ModuleNS,\n-                                            xray) {\n-\n+            match self.resolve_name_in_module(search_module, name, TypeNS,\n+                                              xray) {\n                 Failed => {\n                     self.session.span_err(span, ~\"unresolved name\");\n                     return Failed;\n@@ -2359,16 +2310,16 @@ impl Resolver {\n                     return Indeterminate;\n                 }\n                 Success(target) => {\n-                    match target.bindings.module_def {\n-                        NoModuleDef => {\n+                    match target.bindings.type_def {\n+                        None | Some(TypeDef(*)) => {\n                             // Not a module.\n                             self.session.span_err(span,\n                                                   fmt!(\"not a module: %s\",\n                                                        self.session.\n                                                            str_of(name)));\n                             return Failed;\n                         }\n-                        ModuleDef(_, copy module_) => {\n+                        Some(ModuleDef(_, copy module_)) => {\n                             search_module = module_;\n                         }\n                     }\n@@ -2443,7 +2394,6 @@ impl Resolver {\n         match module_.children.find(name) {\n             Some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) => {\n-\n                 return Success(Target(module_, name_bindings));\n             }\n             Some(_) | None => { /* Not found; continue. */ }\n@@ -2516,15 +2466,15 @@ impl Resolver {\n     fn resolve_module_in_lexical_scope(module_: @Module, name: ident)\n                                     -> ResolveResult<@Module> {\n \n-        match self.resolve_item_in_lexical_scope(module_, name, ModuleNS) {\n+        match self.resolve_item_in_lexical_scope(module_, name, TypeNS) {\n             Success(target) => {\n-                match target.bindings.module_def {\n-                    NoModuleDef => {\n+                match target.bindings.type_def {\n+                    None | Some(TypeDef(*)) => {\n                         error!(\"!!! (resolving module in lexical scope) module\n                                 wasn't actually a module!\");\n                         return Failed;\n                     }\n-                    ModuleDef(_, module_) => {\n+                    Some(ModuleDef(_, module_)) => {\n                         return Success(module_);\n                     }\n                 }\n@@ -2661,8 +2611,7 @@ impl Resolver {\n         debug!(\"(resolving one-level naming result) searching for module\");\n         match self.resolve_item_in_lexical_scope(module_,\n                                                  source_name,\n-                                                 ModuleNS) {\n-\n+                                                 TypeNS) {\n             Failed => {\n                 debug!(\"(resolving one-level renaming import) didn't find \\\n                         module result\");\n@@ -2682,7 +2631,7 @@ impl Resolver {\n \n         let mut value_result;\n         let mut type_result;\n-        if allowable_namespaces == ModuleNSOnly {\n+        if allowable_namespaces == TypeNSOnly {\n             value_result = None;\n             type_result = None;\n         } else {\n@@ -2772,7 +2721,6 @@ impl Resolver {\n                        self.session.str_of(target_name),\n                        self.module_to_str(module_));\n \n-                import_resolution.module_target = module_result;\n                 import_resolution.value_target = value_result;\n                 import_resolution.type_target = type_result;\n \n@@ -2885,18 +2833,19 @@ impl Resolver {\n                                    ident: ident,\n                                    namebindings: @NameBindings,\n                                    reexport: bool) {\n-        for [ModuleNS, TypeNS, ValueNS].each |ns| {\n-            match namebindings.def_for_namespace(*ns) {\n-                Some(d) if d.privacy == Public => {\n+        for [ TypeNS, ValueNS ].each |ns| {\n+            match (namebindings.def_for_namespace(*ns),\n+                   namebindings.privacy_for_namespace(*ns)) {\n+                (Some(d), Some(Public)) => {\n                     debug!(\"(computing exports) YES: %s '%s' \\\n                             => %?\",\n                            if reexport { ~\"reexport\" } else { ~\"export\"},\n                            self.session.str_of(ident),\n-                           def_id_of_def(d.def));\n+                           def_id_of_def(d));\n                     exports2.push(Export2 {\n                         reexport: reexport,\n                         name: self.session.str_of(ident),\n-                        def_id: def_id_of_def(d.def)\n+                        def_id: def_id_of_def(d)\n                     });\n                 }\n                 _ => ()\n@@ -2914,12 +2863,13 @@ impl Resolver {\n         }\n \n         for module_.import_resolutions.each_ref |ident, importresolution| {\n-            for [ModuleNS, TypeNS, ValueNS].each |ns| {\n+            for [ TypeNS, ValueNS ].each |ns| {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe reexport '%s'\",\n                                self.session.str_of(*ident));\n-                        self.add_exports_of_namebindings(exports2, *ident,\n+                        self.add_exports_of_namebindings(exports2,\n+                                                         *ident,\n                                                          target.bindings,\n                                                          true)\n                     }\n@@ -3666,7 +3616,7 @@ impl Resolver {\n                               span: span,\n                               type_parameters: ~[ty_param],\n                               opt_trait_reference: Option<@trait_ref>,\n-                              self_type: @ty,\n+                              self_type: @Ty,\n                               methods: ~[@method],\n                               visitor: ResolveVisitor) {\n \n@@ -3864,50 +3814,52 @@ impl Resolver {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    fn resolve_type(ty: @ty, visitor: ResolveVisitor) {\n+    fn resolve_type(ty: @Ty, visitor: ResolveVisitor) {\n         match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n \n             ty_path(path, path_id) => {\n                 // This is a path in the type namespace. Walk through scopes\n                 // scopes looking for it.\n+                let mut result_def = None;\n \n-                let mut result_def;\n-                match self.resolve_path(path, TypeNS, true, visitor) {\n-                    Some(def) => {\n-                        debug!(\"(resolving type) resolved `%s` to type\",\n-                               self.session.str_of(path.idents.last()));\n-                        result_def = Some(def);\n-                    }\n-                    None => {\n-                        result_def = None;\n+                // First, check to see whether the name is a primitive type.\n+                if path.idents.len() == 1u {\n+                    let name = path.idents.last();\n+\n+                    match self.primitive_type_table\n+                            .primitive_types\n+                            .find(name) {\n+\n+                        Some(primitive_type) => {\n+                            result_def =\n+                                Some(def_prim_ty(primitive_type));\n+                        }\n+                        None => {\n+                            // Continue.\n+                        }\n                     }\n                 }\n \n                 match result_def {\n-                    Some(_) => {\n-                        // Continue.\n-                    }\n                     None => {\n-                        // Check to see whether the name is a primitive type.\n-                        if path.idents.len() == 1u {\n-                            let name = path.idents.last();\n-\n-                            match self.primitive_type_table\n-                                    .primitive_types\n-                                    .find(name) {\n-\n-                                Some(primitive_type) => {\n-                                    result_def =\n-                                        Some(def_prim_ty(primitive_type));\n-                                }\n-                                None => {\n-                                    // Continue.\n-                                }\n+                        match self.resolve_path(path, TypeNS, true, visitor) {\n+                            Some(def) => {\n+                                debug!(\"(resolving type) resolved `%s` to \\\n+                                        type\",\n+                                       self.session.str_of(\n+                                            path.idents.last()));\n+                                result_def = Some(def);\n+                            }\n+                            None => {\n+                                result_def = None;\n                             }\n                         }\n                     }\n+                    Some(_) => {\n+                        // Continue.\n+                    }\n                 }\n \n                 match copy result_def {\n@@ -4223,12 +4175,17 @@ impl Resolver {\n         // First, search children.\n         match containing_module.children.find(name) {\n             Some(child_name_bindings) => {\n-                match (*child_name_bindings).def_for_namespace(namespace) {\n-                    Some(def) if def.privacy == Public || xray == Xray => {\n+                match (child_name_bindings.def_for_namespace(namespace),\n+                       child_name_bindings.privacy_for_namespace(namespace)) {\n+                    (Some(def), Some(Public)) => {\n                         // Found it. Stop the search here.\n-                        return ChildNameDefinition(def.def);\n+                        return ChildNameDefinition(def);\n                     }\n-                    Some(_) | None => {\n+                    (Some(def), _) if xray == Xray => {\n+                        // Found it. Stop the search here.\n+                        return ChildNameDefinition(def);\n+                    }\n+                    (Some(_), _) | (None, _) => {\n                         // Continue.\n                     }\n                 }\n@@ -4244,14 +4201,15 @@ impl Resolver {\n                                        xray == Xray => {\n                 match (*import_resolution).target_for_namespace(namespace) {\n                     Some(target) => {\n-                        match (*target.bindings)\n-                            .def_for_namespace(namespace) {\n-                            Some(def) if def.privacy == Public => {\n+                        match (target.bindings.def_for_namespace(namespace),\n+                               target.bindings.privacy_for_namespace(\n+                                    namespace)) {\n+                            (Some(def), Some(Public)) => {\n                                 // Found it.\n                                 import_resolution.used = true;\n-                                return ImportNameDefinition(def.def);\n+                                return ImportNameDefinition(def);\n                             }\n-                            Some(_) | None => {\n+                            (Some(_), _) | (None, _) => {\n                                 // This can happen with external impls, due to\n                                 // the imperfect way we read the metadata.\n \n@@ -4391,9 +4349,6 @@ impl Resolver {\n                 search_result = self.search_ribs(self.type_ribs, ident, span,\n                                                  AllowCapturingSelf);\n             }\n-            ModuleNS => {\n-                fail ~\"module namespaces do not have local ribs\";\n-            }\n         }\n \n         match copy search_result {\n@@ -4413,23 +4368,22 @@ impl Resolver {\n     fn resolve_item_by_identifier_in_lexical_scope(ident: ident,\n                                                    namespace: Namespace)\n                                                 -> Option<def> {\n-\n         // Check the items.\n         match self.resolve_item_in_lexical_scope(self.current_module,\n                                                ident,\n                                                namespace) {\n-\n             Success(target) => {\n                 match (*target.bindings).def_for_namespace(namespace) {\n                     None => {\n-                        fail ~\"resolved name in a namespace to a set of name \\\n-                              bindings with no def for that namespace?!\";\n+                        // This can happen if we were looking for a type and\n+                        // found a module instead. Modules don't have defs.\n+                        return None;\n                     }\n                     Some(def) => {\n                         debug!(\"(resolving item path in lexical scope) \\\n                                 resolved `%s` to item\",\n                                self.session.str_of(ident));\n-                        return Some(def.def);\n+                        return Some(def);\n                     }\n                 }\n             }\n@@ -4703,7 +4657,7 @@ impl Resolver {\n             for search_module.children.each |_name, child_name_bindings| {\n                 match child_name_bindings.def_for_namespace(TypeNS) {\n                     Some(def) => {\n-                        match def.def {\n+                        match def {\n                             def_ty(trait_def_id) => {\n                                 self.add_trait_info_if_containing_method(\n                                     found_traits, trait_def_id, name);\n@@ -4730,7 +4684,7 @@ impl Resolver {\n                     Some(target) => {\n                         match target.bindings.def_for_namespace(TypeNS) {\n                             Some(def) => {\n-                                match def.def {\n+                                match def {\n                                     def_ty(trait_def_id) => {\n                                         self.\n                                         add_trait_info_if_containing_method(\n@@ -4937,15 +4891,6 @@ impl Resolver {\n \n         debug!(\"Import resolutions:\");\n         for module_.import_resolutions.each |name, import_resolution| {\n-            let mut module_repr;\n-            match (*import_resolution).target_for_namespace(ModuleNS) {\n-                None => { module_repr = ~\"\"; }\n-                Some(_) => {\n-                    module_repr = ~\" module:?\";\n-                    // XXX\n-                }\n-            }\n-\n             let mut value_repr;\n             match (*import_resolution).target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }\n@@ -4964,15 +4909,14 @@ impl Resolver {\n                 }\n             }\n \n-            debug!(\"* %s:%s%s%s\",\n-                   self.session.str_of(name),\n-                   module_repr, value_repr, type_repr);\n+            debug!(\"* %s:%s%s\", self.session.str_of(name),\n+                   value_repr, type_repr);\n         }\n     }\n }\n \n /// Entry point to crate resolution.\n-fn resolve_crate(session: session, lang_items: LanguageItems, crate: @crate)\n+fn resolve_crate(session: Session, lang_items: LanguageItems, crate: @crate)\n               -> { def_map: DefMap,\n                    exp_map2: ExportMap2,\n                    trait_map: TraitMap } {"}, {"sha": "d760bc349073d210e841a9ca9dc5e79f4e8c129a", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -99,7 +99,6 @@\n  *\n  */\n \n-use driver::session::session;\n use lib::llvm::llvm;\n use lib::llvm::{ValueRef, BasicBlockRef};\n use pat_util::*;"}, {"sha": "4c9a006007e7547b89a4a187fb4c95cacc809a0d", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -17,7 +17,7 @@ use libc::{c_uint, c_ulonglong};\n use std::{map, time, list};\n use std::map::HashMap;\n use driver::session;\n-use session::session;\n+use session::Session;\n use syntax::attr;\n use back::{link, abi, upcall};\n use syntax::{ast, ast_util, codemap, ast_map};\n@@ -2377,7 +2377,7 @@ fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n }\n \n \n-fn decl_crate_map(sess: session::session, mapmeta: link_meta,\n+fn decl_crate_map(sess: session::Session, mapmeta: link_meta,\n                   llmod: ModuleRef) -> ValueRef {\n     let targ_cfg = sess.targ_cfg;\n     let int_type = T_int(targ_cfg);\n@@ -2482,7 +2482,7 @@ fn write_abi_version(ccx: @crate_ctxt) {\n                      false);\n }\n \n-fn trans_crate(sess: session::session,\n+fn trans_crate(sess: session::Session,\n                crate: @ast::crate,\n                tcx: ty::ctxt,\n                output: &Path,"}, {"sha": "dfcc66adc3ac67572603b38d12066eddddadc2e5", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -6,7 +6,6 @@ use codemap::span;\n use lib::llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, ModuleRef};\n use lib::llvm::{Opcode, IntPredicate, RealPredicate, True, False,\n         CallConv, TypeKind, AtomicBinOp, AtomicOrdering};\n-use driver::session::session;\n use common::*;\n \n fn B(cx: block) -> BuilderRef {"}, {"sha": "931e82d5be98561fcf4bac81b3e25ecebd21d1b9", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -8,7 +8,7 @@ use vec::raw::to_ptr;\n use std::map::{HashMap,Set};\n use syntax::{ast, ast_map};\n use driver::session;\n-use session::session;\n+use session::Session;\n use middle::ty;\n use back::{link, abi, upcall};\n use syntax::codemap::span;\n@@ -110,7 +110,7 @@ fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n \n // Crate context.  Every crate we compile has one of these.\n type crate_ctxt = {\n-     sess: session::session,\n+     sess: session::Session,\n      llmod: ModuleRef,\n      td: target_data,\n      tn: type_names,\n@@ -605,7 +605,7 @@ fn block_parent(cx: block) -> block {\n impl block {\n     pure fn ccx() -> @crate_ctxt { self.fcx.ccx }\n     pure fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n-    pure fn sess() -> session { self.fcx.ccx.sess }\n+    pure fn sess() -> Session { self.fcx.ccx.sess }\n \n     fn node_id_to_str(id: ast::node_id) -> ~str {\n         ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n@@ -1191,7 +1191,7 @@ fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n     return build::And(cx, bumped, build::Not(cx, mask));\n }\n \n-fn path_str(sess: session::session, p: path) -> ~str {\n+fn path_str(sess: session::Session, p: path) -> ~str {\n     let mut r = ~\"\", first = true;\n     for vec::each(p) |e| {\n         match *e {"}, {"sha": "2db0dd59cf918b8a03c2fb9f9b224ee7bbbc9d19", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -9,7 +9,7 @@ use middle::ty;\n use syntax::{ast, codemap, ast_util, ast_map};\n use syntax::parse::token::ident_interner;\n use codemap::span;\n-use ast::ty;\n+use ast::Ty;\n use pat_util::*;\n use util::ppaux::ty_to_str;\n use driver::session::session;\n@@ -229,7 +229,7 @@ fn create_file(cx: @crate_ctxt, full_path: ~str) -> @metadata<file_md> {\n     return mdval;\n }\n \n-fn line_from_span(cm: codemap::codemap, sp: span) -> uint {\n+fn line_from_span(cm: codemap::CodeMap, sp: span) -> uint {\n     codemap::lookup_char_pos(cm, sp.lo).line\n }\n \n@@ -469,7 +469,7 @@ fn create_composite_type(type_tag: int, name: ~str, file: ValueRef, line: int,\n }\n \n fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n-              vec_ty_span: codemap::span, elem_ty: @ast::ty)\n+              vec_ty_span: codemap::span, elem_ty: @ast::Ty)\n     -> @metadata<tydesc_md> {\n     let fname = filename_from_span(cx, vec_ty_span);\n     let file_node = create_file(cx, fname);\n@@ -492,7 +492,7 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     return @{node: llnode, data: {hash: ty::type_id(vec_t)}};\n }\n \n-fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n+fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::Ty)\n     -> @metadata<tydesc_md> {\n     /*let cache = get_cache(cx);\n     match cached_metadata::<@metadata<tydesc_md>>("}, {"sha": "8a03884f415caf804832fc3fb3233a85837cc57c", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,7 +1,7 @@\n // The classification code for the x86_64 ABI is taken from the clay language\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n-use driver::session::{session, arch_x86_64};\n+use driver::session::arch_x86_64;\n use syntax::codemap::span;\n use libc::c_uint;\n use syntax::{attr, ast_map};"}, {"sha": "a99ef96b2544a80e2732dc919402f914615bf601", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -128,7 +128,7 @@ fn mk_ty_visitor() -> visit::vt<ctx> {\n     visit::mk_vt(@{visit_ty: traverse_ty, ..*visit::default_visitor()})\n }\n \n-fn traverse_ty(ty: @ty, cx: ctx, v: visit::vt<ctx>) {\n+fn traverse_ty(ty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n     if cx.rmap.contains_key(ty.id) { return; }\n     cx.rmap.insert(ty.id, ());\n "}, {"sha": "18a25888bb46ee43d5f5b2461ab509ff55e8e304", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,5 +1,4 @@\n use std::map::HashMap;\n-use driver::session::session;\n use lib::llvm::{TypeRef, ValueRef};\n use syntax::ast;\n use back::abi;"}, {"sha": "149c6ea532d492e9970233f0700caf609daca92f", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,5 +1,4 @@\n use syntax::ast;\n-use driver::session::session;\n use lib::llvm::{ValueRef, TypeRef};\n use back::abi;\n use syntax::codemap::span;"}, {"sha": "8b2efacd4d16a6da4cebd4e86c727c9c0e0c6c3e", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -20,7 +20,6 @@\n use std::map::HashMap;\n use std::list;\n use std::list::{List, Cons, Nil};\n-use driver::session::session;\n use metadata::csearch;\n use syntax::ast::*, syntax::ast_util, syntax::visit;\n use syntax::ast_map;"}, {"sha": "84510c7161e399afb55280ac223b6d58de7fa1c3", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -5,7 +5,7 @@ use std::{map, smallintmap};\n use result::Result;\n use std::map::HashMap;\n use driver::session;\n-use session::session;\n+use session::Session;\n use syntax::{ast, ast_map};\n use syntax::ast_util;\n use syntax::ast_util::{is_local, local_def};\n@@ -103,7 +103,7 @@ export ty_infer, mk_infer, type_is_ty_var, mk_var, mk_int_var;\n export InferTy, TyVar, IntVar;\n export ty_self, mk_self, type_has_self;\n export ty_class;\n-export region, bound_region, encl_region;\n+export Region, bound_region, encl_region;\n export re_bound, re_free, re_scope, re_static, re_var;\n export br_self, br_anon, br_named, br_cap_avoid;\n export get, type_has_params, type_needs_infer, type_has_regions;\n@@ -114,7 +114,7 @@ export ty_var_id;\n export ty_to_def_id;\n export ty_fn_args;\n export ty_region;\n-export kind, kind_implicitly_copyable, kind_send_copy, kind_copyable;\n+export Kind, kind_implicitly_copyable, kind_send_copy, kind_copyable;\n export kind_noncopyable, kind_const;\n export kind_can_be_copied, kind_can_be_sent, kind_can_be_implicitly_copied;\n export kind_is_safe_for_default_mode;\n@@ -219,7 +219,7 @@ enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n     vstore_box,\n-    vstore_slice(region)\n+    vstore_slice(Region)\n }\n \n type field_ty = {\n@@ -302,7 +302,7 @@ type AutoAdjustment = {\n #[auto_deserialize]\n type AutoRef = {\n     kind: AutoRefKind,\n-    region: region,\n+    region: Region,\n     mutbl: ast::mutability\n };\n \n@@ -327,8 +327,8 @@ type ctxt =\n       mut next_id: uint,\n       vecs_implicitly_copyable: bool,\n       legacy_modes: bool,\n-      cstore: metadata::cstore::cstore,\n-      sess: session::session,\n+      cstore: metadata::cstore::CStore,\n+      sess: session::Session,\n       def_map: resolve::DefMap,\n \n       region_map: middle::region::region_map,\n@@ -354,8 +354,8 @@ type ctxt =\n       short_names_cache: HashMap<t, @~str>,\n       needs_drop_cache: HashMap<t, bool>,\n       needs_unwind_cleanup_cache: HashMap<t, bool>,\n-      kind_cache: HashMap<t, kind>,\n-      ast_ty_to_ty_cache: HashMap<@ast::ty, ast_ty_to_ty_cache_entry>,\n+      kind_cache: HashMap<t, Kind>,\n+      ast_ty_to_ty_cache: HashMap<@ast::Ty, ast_ty_to_ty_cache_entry>,\n       enum_var_cache: HashMap<def_id, @~[variant_info]>,\n       trait_method_cache: HashMap<def_id, @~[method]>,\n       ty_param_bounds: HashMap<ast::node_id, param_bounds>,\n@@ -519,7 +519,7 @@ impl param_ty : to_bytes::IterBytes {\n /// Representation of regions:\n #[auto_serialize]\n #[auto_deserialize]\n-enum region {\n+enum Region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n     /// (analogous to type parameters, except that due to the monomorphic\n@@ -570,7 +570,7 @@ enum bound_region {\n     br_cap_avoid(ast::node_id, @bound_region),\n }\n \n-type opt_region = Option<region>;\n+type opt_region = Option<Region>;\n \n /**\n  * The type substs represents the kinds of things that can be substituted to\n@@ -610,7 +610,7 @@ enum sty {\n     ty_uniq(mt),\n     ty_evec(mt, vstore),\n     ty_ptr(mt),\n-    ty_rptr(region, mt),\n+    ty_rptr(Region, mt),\n     ty_rec(~[field]),\n     ty_fn(FnTy),\n     ty_trait(def_id, substs, vstore),\n@@ -656,9 +656,9 @@ enum type_err {\n     terr_record_fields(expected_found<ident>),\n     terr_arg_count,\n     terr_mode_mismatch(expected_found<mode>),\n-    terr_regions_does_not_outlive(region, region),\n-    terr_regions_not_same(region, region),\n-    terr_regions_no_overlap(region, region),\n+    terr_regions_does_not_outlive(Region, Region),\n+    terr_regions_not_same(Region, Region),\n+    terr_regions_no_overlap(Region, Region),\n     terr_vstores_differ(terr_vstore_kind, expected_found<vstore>),\n     terr_in_field(@type_err, ast::ident),\n     terr_sorts(expected_found<t>),\n@@ -783,7 +783,7 @@ impl FnVid : to_bytes::IterBytes {\n     }\n }\n \n-fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n+fn param_bounds_to_kind(bounds: param_bounds) -> Kind {\n     let mut kind = kind_noncopyable();\n     for vec::each(*bounds) |bound| {\n         match *bound {\n@@ -834,7 +834,7 @@ fn new_ty_hash<V: Copy>() -> map::HashMap<t, V> {\n     map::HashMap()\n }\n \n-fn mk_ctxt(s: session::session,\n+fn mk_ctxt(s: session::Session,\n            dm: resolve::DefMap,\n            amap: ast_map::map,\n            freevars: freevars::freevar_map,\n@@ -904,7 +904,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       _ => ()\n     }\n     let mut flags = 0u;\n-    fn rflags(r: region) -> uint {\n+    fn rflags(r: Region) -> uint {\n         (has_regions as uint) | {\n             match r {\n               ty::re_var(_) => needs_infer as uint,\n@@ -1018,12 +1018,12 @@ fn mk_imm_uniq(cx: ctxt, ty: t) -> t { mk_uniq(cx, {ty: ty,\n \n fn mk_ptr(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n \n-fn mk_rptr(cx: ctxt, r: region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n+fn mk_rptr(cx: ctxt, r: Region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n \n-fn mk_mut_rptr(cx: ctxt, r: region, ty: t) -> t {\n+fn mk_mut_rptr(cx: ctxt, r: Region, ty: t) -> t {\n     mk_rptr(cx, r, {ty: ty, mutbl: ast::m_mutbl})\n }\n-fn mk_imm_rptr(cx: ctxt, r: region, ty: t) -> t {\n+fn mk_imm_rptr(cx: ctxt, r: Region, ty: t) -> t {\n     mk_rptr(cx, r, {ty: ty, mutbl: ast::m_imm})\n }\n \n@@ -1148,7 +1148,7 @@ fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n \n // Returns the narrowest lifetime enclosing the evaluation of the expression\n // with id `id`.\n-fn encl_region(cx: ctxt, id: ast::node_id) -> ty::region {\n+fn encl_region(cx: ctxt, id: ast::node_id) -> ty::Region {\n     match cx.region_map.find(id) {\n       Some(encl_scope) => ty::re_scope(encl_scope),\n       None => ty::re_static\n@@ -1265,7 +1265,7 @@ fn fold_ty(cx: ctxt, t0: t, fldop: fn(t) -> t) -> t {\n fn walk_regions_and_ty(\n     cx: ctxt,\n     ty: t,\n-    walkr: fn(r: region),\n+    walkr: fn(r: Region),\n     walkt: fn(t: t) -> bool) {\n \n     if (walkt(ty)) {\n@@ -1280,13 +1280,13 @@ fn walk_regions_and_ty(\n fn fold_regions_and_ty(\n     cx: ctxt,\n     ty: t,\n-    fldr: fn(r: region) -> region,\n+    fldr: fn(r: Region) -> Region,\n     fldfnt: fn(t: t) -> t,\n     fldt: fn(t: t) -> t) -> t {\n \n     fn fold_substs(\n         substs: &substs,\n-        fldr: fn(r: region) -> region,\n+        fldr: fn(r: Region) -> Region,\n         fldt: fn(t: t) -> t) -> substs {\n \n         {self_r: substs.self_r.map(|r| fldr(*r)),\n@@ -1351,10 +1351,10 @@ fn fold_regions_and_ty(\n fn fold_regions(\n     cx: ctxt,\n     ty: t,\n-    fldr: fn(r: region, in_fn: bool) -> region) -> t {\n+    fldr: fn(r: Region, in_fn: bool) -> Region) -> t {\n \n     fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n-               fldr: fn(region, bool) -> region) -> t {\n+               fldr: fn(Region, bool) -> Region) -> t {\n         if !type_has_regions(ty) { return ty; }\n         fold_regions_and_ty(\n             cx, ty,\n@@ -1365,9 +1365,9 @@ fn fold_regions(\n     do_fold(cx, ty, false, fldr)\n }\n \n-fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n+fn fold_region(cx: ctxt, t0: t, fldop: fn(Region, bool) -> Region) -> t {\n     fn do_fold(cx: ctxt, t0: t, under_r: bool,\n-               fldop: fn(region, bool) -> region) -> t {\n+               fldop: fn(Region, bool) -> Region) -> t {\n         let tb = get(t0);\n         if !tbox_has_flag(tb, has_regions) { return t0; }\n         match tb.sty {\n@@ -1777,7 +1777,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n     return needs_unwind_cleanup;\n }\n \n-enum kind { kind_(u32) }\n+enum Kind { kind_(u32) }\n \n /// can be copied (implicitly or explicitly)\n const KIND_MASK_COPY         : u32 = 0b000000000000000000000000001_u32;\n@@ -1797,92 +1797,92 @@ const KIND_MASK_IMPLICIT     : u32 = 0b000000000000000000000010000_u32;\n /// safe for default mode (subset of KIND_MASK_IMPLICIT)\n const KIND_MASK_DEFAULT_MODE : u32 = 0b000000000000000000000100000_u32;\n \n-fn kind_noncopyable() -> kind {\n+fn kind_noncopyable() -> Kind {\n     kind_(0u32)\n }\n \n-fn kind_copyable() -> kind {\n+fn kind_copyable() -> Kind {\n     kind_(KIND_MASK_COPY)\n }\n \n-fn kind_implicitly_copyable() -> kind {\n+fn kind_implicitly_copyable() -> Kind {\n     kind_(KIND_MASK_IMPLICIT | KIND_MASK_COPY)\n }\n \n-fn kind_safe_for_default_mode() -> kind {\n+fn kind_safe_for_default_mode() -> Kind {\n     // similar to implicit copy, but always includes vectors and strings\n     kind_(KIND_MASK_DEFAULT_MODE | KIND_MASK_IMPLICIT | KIND_MASK_COPY)\n }\n \n-fn kind_implicitly_sendable() -> kind {\n+fn kind_implicitly_sendable() -> Kind {\n     kind_(KIND_MASK_IMPLICIT | KIND_MASK_COPY | KIND_MASK_SEND)\n }\n \n-fn kind_safe_for_default_mode_send() -> kind {\n+fn kind_safe_for_default_mode_send() -> Kind {\n     // similar to implicit copy, but always includes vectors and strings\n     kind_(KIND_MASK_DEFAULT_MODE | KIND_MASK_IMPLICIT |\n           KIND_MASK_COPY | KIND_MASK_SEND)\n }\n \n \n-fn kind_send_copy() -> kind {\n+fn kind_send_copy() -> Kind {\n     kind_(KIND_MASK_COPY | KIND_MASK_SEND)\n }\n \n-fn kind_send_only() -> kind {\n+fn kind_send_only() -> Kind {\n     kind_(KIND_MASK_SEND)\n }\n \n-fn kind_const() -> kind {\n+fn kind_const() -> Kind {\n     kind_(KIND_MASK_CONST)\n }\n \n-fn kind_owned() -> kind {\n+fn kind_owned() -> Kind {\n     kind_(KIND_MASK_OWNED)\n }\n \n-fn kind_top() -> kind {\n+fn kind_top() -> Kind {\n     kind_(0xffffffffu32)\n }\n \n-fn remove_const(k: kind) -> kind {\n+fn remove_const(k: Kind) -> Kind {\n     k - kind_const()\n }\n \n-fn remove_implicit(k: kind) -> kind {\n+fn remove_implicit(k: Kind) -> Kind {\n     k - kind_(KIND_MASK_IMPLICIT | KIND_MASK_DEFAULT_MODE)\n }\n \n-fn remove_send(k: kind) -> kind {\n+fn remove_send(k: Kind) -> Kind {\n     k - kind_(KIND_MASK_SEND)\n }\n \n-fn remove_owned_send(k: kind) -> kind {\n+fn remove_owned_send(k: Kind) -> Kind {\n     k - kind_(KIND_MASK_OWNED) - kind_(KIND_MASK_SEND)\n }\n \n-fn remove_copyable(k: kind) -> kind {\n+fn remove_copyable(k: Kind) -> Kind {\n     k - kind_(KIND_MASK_COPY | KIND_MASK_DEFAULT_MODE)\n }\n \n-impl kind : ops::BitAnd<kind,kind> {\n-    pure fn bitand(other: &kind) -> kind {\n+impl Kind : ops::BitAnd<Kind,Kind> {\n+    pure fn bitand(other: &Kind) -> Kind {\n         unsafe {\n             lower_kind(self, (*other))\n         }\n     }\n }\n \n-impl kind : ops::BitOr<kind,kind> {\n-    pure fn bitor(other: &kind) -> kind {\n+impl Kind : ops::BitOr<Kind,Kind> {\n+    pure fn bitor(other: &Kind) -> Kind {\n         unsafe {\n             raise_kind(self, (*other))\n         }\n     }\n }\n \n-impl kind : ops::Sub<kind,kind> {\n-    pure fn sub(other: &kind) -> kind {\n+impl Kind : ops::Sub<Kind,Kind> {\n+    pure fn sub(other: &Kind) -> Kind {\n         unsafe {\n             kind_(*self & !*(*other))\n         }\n@@ -1892,27 +1892,27 @@ impl kind : ops::Sub<kind,kind> {\n // Using these query functions is preferable to direct comparison or matching\n // against the kind constants, as we may modify the kind hierarchy in the\n // future.\n-pure fn kind_can_be_implicitly_copied(k: kind) -> bool {\n+pure fn kind_can_be_implicitly_copied(k: Kind) -> bool {\n     *k & KIND_MASK_IMPLICIT == KIND_MASK_IMPLICIT\n }\n \n-pure fn kind_is_safe_for_default_mode(k: kind) -> bool {\n+pure fn kind_is_safe_for_default_mode(k: Kind) -> bool {\n     *k & KIND_MASK_DEFAULT_MODE == KIND_MASK_DEFAULT_MODE\n }\n \n-pure fn kind_can_be_copied(k: kind) -> bool {\n+pure fn kind_can_be_copied(k: Kind) -> bool {\n     *k & KIND_MASK_COPY == KIND_MASK_COPY\n }\n \n-pure fn kind_can_be_sent(k: kind) -> bool {\n+pure fn kind_can_be_sent(k: Kind) -> bool {\n     *k & KIND_MASK_SEND == KIND_MASK_SEND\n }\n \n-pure fn kind_is_owned(k: kind) -> bool {\n+pure fn kind_is_owned(k: Kind) -> bool {\n     *k & KIND_MASK_OWNED == KIND_MASK_OWNED\n }\n \n-fn meta_kind(p: FnMeta) -> kind {\n+fn meta_kind(p: FnMeta) -> Kind {\n     match p.proto { // XXX consider the kind bounds!\n       proto_vstore(vstore_slice(_)) =>\n         kind_noncopyable() | kind_(KIND_MASK_DEFAULT_MODE),\n@@ -1927,15 +1927,15 @@ fn meta_kind(p: FnMeta) -> kind {\n     }\n }\n \n-fn kind_lteq(a: kind, b: kind) -> bool {\n+fn kind_lteq(a: Kind, b: Kind) -> bool {\n     *a & *b == *a\n }\n \n-fn lower_kind(a: kind, b: kind) -> kind {\n+fn lower_kind(a: Kind, b: Kind) -> Kind {\n     kind_(*a & *b)\n }\n \n-fn raise_kind(a: kind, b: kind) -> kind {\n+fn raise_kind(a: Kind, b: Kind) -> Kind {\n     kind_(*a | *b)\n }\n \n@@ -1960,19 +1960,19 @@ fn test_kinds() {\n // with the given mutability can have.\n // This is used to prevent objects containing mutable state from being\n // implicitly copied and to compute whether things have const kind.\n-fn mutability_kind(m: mutability) -> kind {\n+fn mutability_kind(m: mutability) -> Kind {\n     match (m) {\n       m_mutbl => remove_const(remove_implicit(kind_top())),\n       m_const => remove_implicit(kind_top()),\n       m_imm => kind_top()\n     }\n }\n \n-fn mutable_type_kind(cx: ctxt, ty: mt) -> kind {\n+fn mutable_type_kind(cx: ctxt, ty: mt) -> Kind {\n     lower_kind(mutability_kind(ty.mutbl), type_kind(cx, ty.ty))\n }\n \n-fn type_kind(cx: ctxt, ty: t) -> kind {\n+fn type_kind(cx: ctxt, ty: t) -> Kind {\n     match cx.kind_cache.find(ty) {\n       Some(result) => return result,\n       None => {/* fall through */ }\n@@ -2550,7 +2550,7 @@ impl bound_region : to_bytes::IterBytes {\n     }\n }\n \n-impl region : to_bytes::IterBytes {\n+impl Region : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           re_bound(ref br) =>\n@@ -2763,7 +2763,7 @@ fn is_fn_ty(fty: t) -> bool {\n     }\n }\n \n-fn ty_region(ty: t) -> region {\n+fn ty_region(ty: t) -> Region {\n     match get(ty).sty {\n       ty_rptr(r, _) => r,\n       s => fail fmt!(\"ty_region() invoked on non-rptr: %?\", s)\n@@ -4084,8 +4084,8 @@ impl RegionVid : cmp::Eq {\n     pure fn ne(other: &RegionVid) -> bool { *self != *(*other) }\n }\n \n-impl region : cmp::Eq {\n-    pure fn eq(other: &region) -> bool {\n+impl Region : cmp::Eq {\n+    pure fn eq(other: &Region) -> bool {\n         match self {\n             re_bound(e0a) => {\n                 match (*other) {\n@@ -4119,7 +4119,7 @@ impl region : cmp::Eq {\n             }\n         }\n     }\n-    pure fn ne(other: &region) -> bool { !self.eq(other) }\n+    pure fn ne(other: &Region) -> bool { !self.eq(other) }\n }\n \n impl bound_region : cmp::Eq {\n@@ -4367,9 +4367,9 @@ impl param_bound : cmp::Eq {\n     pure fn ne(other: &param_bound) -> bool { !self.eq(other) }\n }\n \n-impl kind : cmp::Eq {\n-    pure fn eq(other: &kind) -> bool { *self == *(*other) }\n-    pure fn ne(other: &kind) -> bool { *self != *(*other) }\n+impl Kind : cmp::Eq {\n+    pure fn eq(other: &Kind) -> bool { *self == *(*other) }\n+    pure fn ne(other: &Kind) -> bool { *self != *(*other) }\n }\n \n "}, {"sha": "8d10343d78ee021ea10fc38de098433d5d6932f9", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -46,7 +46,6 @@ use syntax::ast_map::node_id_to_str;\n use syntax::ast_util::{local_def, respan, split_trait_methods};\n use syntax::visit;\n use metadata::csearch;\n-use driver::session::session;\n use util::common::may_break;\n use syntax::codemap::span;\n use pat_util::{pat_is_variant, pat_id_map, PatIdMap};"}, {"sha": "b8ff637f7dd373b433678fe4fb2d23712f107d6e", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -58,7 +58,7 @@ trait ast_conv {\n \n fn get_region_reporting_err(tcx: ty::ctxt,\n                             span: span,\n-                            res: Result<ty::region, ~str>) -> ty::region {\n+                            res: Result<ty::Region, ~str>) -> ty::Region {\n \n     match res {\n       result::Ok(r) => r,\n@@ -70,7 +70,7 @@ fn get_region_reporting_err(tcx: ty::ctxt,\n }\n \n fn ast_region_to_region<AC: ast_conv, RS: region_scope Copy Owned>(\n-    self: AC, rscope: RS, span: span, a_r: @ast::region) -> ty::region {\n+    self: AC, rscope: RS, span: span, a_r: @ast::region) -> ty::Region {\n \n     let res = match a_r.node {\n         ast::re_static => Ok(ty::re_static),\n@@ -155,7 +155,7 @@ const NO_TPS: uint = 2u;\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n-    self: AC, rscope: RS, &&ast_ty: @ast::ty) -> ty::t {\n+    self: AC, rscope: RS, &&ast_ty: @ast::Ty) -> ty::t {\n \n     fn ast_mt_to_mt<AC: ast_conv, RS: region_scope Copy Owned>(\n         self: AC, rscope: RS, mt: ast::mt) -> ty::mt {"}, {"sha": "6de249ebc68f27a408cec5887963a17066e3ec26", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -166,20 +166,20 @@ fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n }\n \n // a list of mapping from in-scope-region-names (\"isr\") to the\n-// corresponding ty::region\n-type isr_alist = @List<(ty::bound_region, ty::region)>;\n+// corresponding ty::Region\n+type isr_alist = @List<(ty::bound_region, ty::Region)>;\n \n trait get_and_find_region {\n-    fn get(br: ty::bound_region) -> ty::region;\n-    fn find(br: ty::bound_region) -> Option<ty::region>;\n+    fn get(br: ty::bound_region) -> ty::Region;\n+    fn find(br: ty::bound_region) -> Option<ty::Region>;\n }\n \n impl isr_alist: get_and_find_region {\n-    fn get(br: ty::bound_region) -> ty::region {\n+    fn get(br: ty::bound_region) -> ty::Region {\n         self.find(br).get()\n     }\n \n-    fn find(br: ty::bound_region) -> Option<ty::region> {\n+    fn find(br: ty::bound_region) -> Option<ty::Region> {\n         for list::each(self) |isr| {\n             let (isr_br, isr_r) = *isr;\n             if isr_br == br { return Some(isr_r); }\n@@ -563,7 +563,7 @@ impl @fn_ctxt: ast_conv {\n \n impl @fn_ctxt {\n     fn search_in_scope_regions(br: ty::bound_region)\n-        -> Result<ty::region, ~str>\n+        -> Result<ty::Region, ~str>\n     {\n         match self.in_scope_regions.find(br) {\n             Some(r) => result::Ok(r),\n@@ -581,13 +581,13 @@ impl @fn_ctxt {\n }\n \n impl @fn_ctxt: region_scope {\n-    fn anon_region(span: span) -> Result<ty::region, ~str> {\n+    fn anon_region(span: span) -> Result<ty::Region, ~str> {\n         result::Ok(self.infcx().next_region_var_nb(span))\n     }\n-    fn self_region(_span: span) -> Result<ty::region, ~str> {\n+    fn self_region(_span: span) -> Result<ty::Region, ~str> {\n         self.search_in_scope_regions(ty::br_self)\n     }\n-    fn named_region(_span: span, id: ast::ident) -> Result<ty::region, ~str> {\n+    fn named_region(_span: span, id: ast::ident) -> Result<ty::Region, ~str> {\n         self.search_in_scope_regions(ty::br_named(id))\n     }\n }\n@@ -600,7 +600,7 @@ impl @fn_ctxt {\n              pprust::expr_to_str(expr, self.tcx().sess.intr()))\n     }\n \n-    fn block_region() -> ty::region {\n+    fn block_region() -> ty::Region {\n         ty::re_scope(self.region_lb)\n     }\n \n@@ -645,7 +645,7 @@ impl @fn_ctxt {\n         self.write_ty(node_id, ty::mk_bot(self.tcx()));\n     }\n \n-    fn to_ty(ast_t: @ast::ty) -> ty::t {\n+    fn to_ty(ast_t: @ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, self, ast_t)\n     }\n \n@@ -736,7 +736,7 @@ impl @fn_ctxt {\n     }\n \n     fn mk_subr(a_is_expected: bool, span: span,\n-               sub: ty::region, sup: ty::region) -> Result<(), ty::type_err> {\n+               sub: ty::Region, sup: ty::Region) -> Result<(), ty::type_err> {\n         infer::mk_subr(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n@@ -760,8 +760,8 @@ impl @fn_ctxt {\n \n     fn region_var_if_parameterized(rp: Option<ty::region_variance>,\n                                    span: span,\n-                                   lower_bound: ty::region)\n-        -> Option<ty::region>\n+                                   lower_bound: ty::Region)\n+        -> Option<ty::Region>\n     {\n         rp.map(\n             |_rp| self.infcx().next_region_var_with_lb(span, lower_bound))\n@@ -1359,7 +1359,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n     // Check field access expressions\n     fn check_field(fcx: @fn_ctxt, expr: @ast::expr, is_callee: bool,\n-                   base: @ast::expr, field: ast::ident, tys: ~[@ast::ty])\n+                   base: @ast::expr, field: ast::ident, tys: ~[@ast::Ty])\n         -> bool\n     {\n         let tcx = fcx.ccx.tcx;\n@@ -2443,7 +2443,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n                     tpt: ty_param_bounds_and_ty,\n                     span: span,\n                     node_id: ast::node_id,\n-                    region_lb: ty::region) {\n+                    region_lb: ty::Region) {\n     let ty_param_count = vec::len(*tpt.bounds);\n     let ty_substs_len = vec::len(pth.types);\n "}, {"sha": "caace6051982e69d65f38a006ddb0fb997f12b2c", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -112,8 +112,8 @@ fn check_legality_of_move_bindings(fcx: @fn_ctxt,\n type pat_ctxt = {\n     fcx: @fn_ctxt,\n     map: PatIdMap,\n-    alt_region: ty::region,   // Region for the alt as a whole\n-    block_region: ty::region, // Region for the block of the arm\n+    alt_region: ty::Region,   // Region for the alt as a whole\n+    block_region: ty::Region, // Region for the block of the arm\n };\n \n fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,"}, {"sha": "eaf1a45afa9c08934b7ca52bec47beb30f2de4b0", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -654,7 +654,7 @@ impl LookupContext {\n         kind: AutoRefKind,\n         autoderefs: uint,\n         mutbls: &[ast::mutability],\n-        mk_autoref_ty: &fn(ast::mutability, ty::region) -> ty::t)\n+        mk_autoref_ty: &fn(ast::mutability, ty::Region) -> ty::t)\n         -> Option<method_map_entry>\n     {\n         // This is hokey. We should have mutability inference as a\n@@ -930,7 +930,7 @@ impl LookupContext {\n }\n \n fn transform_self_type_for_method(tcx: ty::ctxt,\n-                                  self_region: Option<ty::region>,\n+                                  self_region: Option<ty::Region>,\n                                   impl_ty: ty::t,\n                                   self_type: ast::self_ty_)\n     -> ty::t"}, {"sha": "932cdd994da7d0b46b03126e126283a381099592", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -32,7 +32,7 @@ use middle::ty::{vstore_uniq};\n enum rcx { rcx_({fcx: @fn_ctxt, mut errors_reported: uint}) }\n type rvt = visit::vt<@rcx>;\n \n-fn encl_region_of_def(fcx: @fn_ctxt, def: ast::def) -> ty::region {\n+fn encl_region_of_def(fcx: @fn_ctxt, def: ast::def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n         def_local(node_id, _) | def_arg(node_id, _) | def_self(node_id) |\n@@ -335,7 +335,7 @@ fn constrain_auto_ref(\n \n fn constrain_free_variables(\n     rcx: @rcx,\n-    region: ty::region,\n+    region: ty::Region,\n     expr: @ast::expr)\n {\n     /*!\n@@ -373,7 +373,7 @@ fn constrain_free_variables(\n fn constrain_regions_in_type_of_node(\n     rcx: @rcx,\n     id: ast::node_id,\n-    encl_region: ty::region,\n+    encl_region: ty::Region,\n     span: span) -> bool\n {\n     let tcx = rcx.fcx.tcx();\n@@ -395,7 +395,7 @@ fn constrain_regions_in_type_of_node(\n \n fn constrain_regions_in_type(\n     rcx: @rcx,\n-    encl_region: ty::region,\n+    encl_region: ty::Region,\n     span: span,\n     ty: ty::t) -> bool\n {\n@@ -417,9 +417,9 @@ fn constrain_regions_in_type(\n     return (e == rcx.errors_reported);\n \n     fn constrain_region(rcx: @rcx,\n-                        encl_region: ty::region,\n+                        encl_region: ty::Region,\n                         span: span,\n-                        region: ty::region) {\n+                        region: ty::Region) {\n         let tcx = rcx.fcx.ccx.tcx;\n \n         debug!(\"constrain_region(encl_region=%?, region=%?)\","}, {"sha": "806b234540cdca1e60991706fc7b99931c73a59e", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -10,7 +10,7 @@ fn replace_bound_regions_in_fn_ty(\n     isr: isr_alist,\n     self_info: Option<self_info>,\n     fn_ty: &ty::FnTy,\n-    mapf: fn(ty::bound_region) -> ty::region) ->\n+    mapf: fn(ty::bound_region) -> ty::Region) ->\n     {isr: isr_alist, self_info: Option<self_info>, fn_ty: ty::FnTy} {\n \n     // Take self_info apart; the self_ty part is the only one we want\n@@ -83,7 +83,7 @@ fn replace_bound_regions_in_fn_ty(\n         tcx: ty::ctxt,\n         isr: isr_alist,\n         tys: ~[ty::t],\n-        to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n+        to_r: fn(ty::bound_region) -> ty::Region) -> isr_alist {\n \n         // Takes `isr` (described above), `to_r` (described above),\n         // and `r`, a region.  If `r` is anything other than a bound\n@@ -93,8 +93,8 @@ fn replace_bound_regions_in_fn_ty(\n         // updated isr_alist that now contains a mapping from `r` to\n         // the result of calling `to_r` on it.\n         fn append_isr(isr: isr_alist,\n-                      to_r: fn(ty::bound_region) -> ty::region,\n-                      r: ty::region) -> isr_alist {\n+                      to_r: fn(ty::bound_region) -> ty::Region,\n+                      r: ty::Region) -> isr_alist {\n             match r {\n               ty::re_free(_, _) | ty::re_static | ty::re_scope(_) |\n               ty::re_var(_) => {"}, {"sha": "189e7377d9c3097e4e65c044851e0ac67f73c272", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -6,7 +6,7 @@\n \n use metadata::csearch::{ProvidedTraitMethodInfo, each_path, get_impl_traits};\n use metadata::csearch::{get_impls_for_mod};\n-use metadata::cstore::{cstore, iter_crate_data};\n+use metadata::cstore::{CStore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n use middle::ty::{ProvidedMethodSource, get, lookup_item_type, subst, t};\n@@ -595,7 +595,7 @@ impl CoherenceChecker {\n     fn create_impl_from_item(item: @item) -> @Impl {\n         fn add_provided_methods(all_methods: &mut ~[@MethodInfo],\n                                 all_provided_methods: ~[@ProvidedMethodInfo],\n-                                sess: driver::session::session) {\n+                                sess: driver::session::Session) {\n             for all_provided_methods.each |provided_method| {\n                 debug!(\n                     \"(creating impl) adding provided method `%s` to impl\",\n@@ -694,7 +694,7 @@ impl CoherenceChecker {\n     // External crate handling\n \n     fn add_impls_for_module(impls_seen: HashMap<def_id,()>,\n-                            crate_store: cstore,\n+                            crate_store: CStore,\n                             module_def_id: def_id) {\n \n         let implementations = get_impls_for_mod(crate_store,"}, {"sha": "a5390d8f293afd4f073417c2c4119ba181b840f3", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -76,7 +76,7 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n \n impl @crate_ctxt {\n     fn to_ty<RS: region_scope Copy Owned>(\n-        rs: RS, ast_ty: @ast::ty) -> ty::t {\n+        rs: RS, ast_ty: @ast::Ty) -> ty::t {\n \n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n@@ -345,7 +345,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n \n     // Replaces bound references to the self region with `with_r`.\n     fn replace_bound_self(tcx: ty::ctxt, ty: ty::t,\n-                          with_r: ty::region) -> ty::t {\n+                          with_r: ty::Region) -> ty::t {\n         do ty::fold_regions(tcx, ty) |r, _in_fn| {\n             if r == ty::re_bound(ty::br_self) {with_r} else {r}\n         }"}, {"sha": "e0465b22c931fe98d99d5e062694397f401cc0b8", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -258,7 +258,6 @@ use util::ppaux::{ty_to_str, mt_to_str};\n use result::{Result, Ok, Err, map_vec, map_vec2, iter_vec2};\n use ty::{mk_fn, type_is_bot};\n use check::regionmanip::{replace_bound_regions_in_fn_ty};\n-use driver::session::session;\n use util::common::{indent, indenter};\n use ast::{unsafe_fn, impure_fn, pure_fn, extern_fn};\n use ast::{m_const, m_imm, m_mutbl};\n@@ -275,7 +274,7 @@ use unify::{vals_and_bindings, root};\n use integral::{int_ty_set, int_ty_set_all};\n use combine::{combine_fields, eq_tys};\n use assignment::Assign;\n-use to_str::to_str;\n+use to_str::ToStr;\n \n use sub::Sub;\n use lub::Lub;\n@@ -385,7 +384,7 @@ fn can_mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n }\n \n fn mk_subr(cx: infer_ctxt, a_is_expected: bool, span: span,\n-           a: ty::region, b: ty::region) -> ures {\n+           a: ty::Region, b: ty::Region) -> ures {\n     debug!(\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n     do indent {\n         do cx.commit {\n@@ -431,8 +430,8 @@ fn resolve_type(cx: infer_ctxt, a: ty::t, modes: uint)\n     resolver(cx, modes).resolve_type_chk(a)\n }\n \n-fn resolve_region(cx: infer_ctxt, r: ty::region, modes: uint)\n-    -> fres<ty::region> {\n+fn resolve_region(cx: infer_ctxt, r: ty::Region, modes: uint)\n+    -> fres<ty::Region> {\n     resolver(cx, modes).resolve_region_chk(r)\n }\n \n@@ -628,12 +627,12 @@ impl infer_ctxt {\n         ty::mk_int_var(self.tcx, self.next_int_var_id())\n     }\n \n-    fn next_region_var_nb(span: span) -> ty::region {\n+    fn next_region_var_nb(span: span) -> ty::Region {\n         ty::re_var(self.region_vars.new_region_var(span))\n     }\n \n     fn next_region_var_with_lb(span: span,\n-                               lb_region: ty::region) -> ty::region {\n+                               lb_region: ty::Region) -> ty::Region {\n         let region_var = self.next_region_var_nb(span);\n \n         // add lb_region as a lower bound on the newly built variable\n@@ -644,7 +643,7 @@ impl infer_ctxt {\n         return region_var;\n     }\n \n-    fn next_region_var(span: span, scope_id: ast::node_id) -> ty::region {\n+    fn next_region_var(span: span, scope_id: ast::node_id) -> ty::Region {\n         self.next_region_var_with_lb(span, ty::re_scope(scope_id))\n     }\n "}, {"sha": "a5af58904dd77e5542bcfcc56385a259e98888de", "filename": "src/rustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -48,7 +48,7 @@\n // A.  But this upper-bound might be stricter than what is truly\n // needed.\n \n-use to_str::to_str;\n+use to_str::ToStr;\n use combine::combine_fields;\n \n fn to_ares(+c: cres<ty::t>) -> ares {\n@@ -190,7 +190,7 @@ priv impl Assign {\n                   a: ty::t,\n                   nr_b: ty::t,\n                   m: ast::mutability,\n-                  r_b: ty::region) -> ares {\n+                  r_b: ty::Region) -> ares {\n \n         debug!(\"try_assign(a=%s, nr_b=%s, m=%?, r_b=%s)\",\n                a.to_str(self.infcx),"}, {"sha": "342a2ce2b76cdd87b9edc26b6871e7b00d2cc54e", "filename": "src/rustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -44,7 +44,7 @@\n // terms of error reporting, although we do not do that properly right\n // now.\n \n-use to_str::to_str;\n+use to_str::ToStr;\n use ty::{FnTyBase, FnMeta, FnSig};\n \n trait combine {\n@@ -72,8 +72,8 @@ trait combine {\n     fn protos(p1: ty::fn_proto, p2: ty::fn_proto) -> cres<ty::fn_proto>;\n     fn ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style>;\n     fn purities(a: purity, b: purity) -> cres<purity>;\n-    fn contraregions(a: ty::region, b: ty::region) -> cres<ty::region>;\n-    fn regions(a: ty::region, b: ty::region) -> cres<ty::region>;\n+    fn contraregions(a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n+    fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n     fn vstores(vk: ty::terr_vstore_kind,\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore>;\n }\n@@ -103,7 +103,7 @@ fn eq_tys<C: combine>(self: &C, a: ty::t, b: ty::t) -> ures {\n     }\n }\n \n-fn eq_regions<C: combine>(self: &C, a: ty::region, b: ty::region) -> ures {\n+fn eq_regions<C: combine>(self: &C, a: ty::Region, b: ty::Region) -> ures {\n     debug!(\"eq_regions(%s, %s)\",\n            a.to_str(self.infcx()),\n            b.to_str(self.infcx()));\n@@ -127,8 +127,8 @@ fn eq_regions<C: combine>(self: &C, a: ty::region, b: ty::region) -> ures {\n \n fn eq_opt_regions<C:combine>(\n     self: &C,\n-    a: Option<ty::region>,\n-    b: Option<ty::region>) -> cres<Option<ty::region>> {\n+    a: Option<ty::Region>,\n+    b: Option<ty::Region>) -> cres<Option<ty::Region>> {\n \n     match (a, b) {\n       (None, None) => {\n@@ -160,9 +160,9 @@ fn super_substs<C:combine>(\n     fn relate_region_param<C:combine>(\n         self: &C,\n         did: ast::def_id,\n-        a: Option<ty::region>,\n-        b: Option<ty::region>)\n-        -> cres<Option<ty::region>>\n+        a: Option<ty::Region>,\n+        b: Option<ty::Region>)\n+        -> cres<Option<ty::Region>>\n     {\n         let polyty = ty::lookup_item_type(self.infcx().tcx, did);\n         match (polyty.region_param, a, b) {"}, {"sha": "77e753fa2204f638c28d12210b7d81ba92f4bce4", "filename": "src/rustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,6 +1,6 @@\n use combine::*;\n use lattice::*;\n-use to_str::to_str;\n+use to_str::ToStr;\n \n enum Glb = combine_fields;  // \"greatest lower bound\" (common subtype)\n \n@@ -109,7 +109,7 @@ impl Glb: combine {\n         }\n     }\n \n-    fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+    fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"%s.regions(%?, %?)\",\n                self.tag(),\n                a.to_str(self.infcx),\n@@ -120,7 +120,7 @@ impl Glb: combine {\n         }\n     }\n \n-    fn contraregions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+    fn contraregions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         Lub(*self).regions(a, b)\n     }\n "}, {"sha": "1b23cb52b20c8c101e768399929385e1595c52b9", "filename": "src/rustc/middle/typeck/infer/integral.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -4,7 +4,7 @@ Code related to integral type inference.\n \n */\n \n-use to_str::to_str;\n+use to_str::ToStr;\n \n // Bitvector to represent sets of integral types\n enum int_ty_set = uint;"}, {"sha": "699613e8ae6557ed1b7bc03d8fd60c007ed1b457", "filename": "src/rustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,6 +1,6 @@\n use combine::*;\n use unify::*;\n-use to_str::to_str;\n+use to_str::ToStr;\n \n // ______________________________________________________________________\n // Lattice operations on variables"}, {"sha": "dcff863a126f0aa080cc01bf8c24d1202da0b14b", "filename": "src/rustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,6 +1,6 @@\n use combine::*;\n use lattice::*;\n-use to_str::to_str;\n+use to_str::ToStr;\n \n enum Lub = combine_fields;  // \"subtype\", \"subregion\" etc\n \n@@ -88,11 +88,11 @@ impl Lub: combine {\n         }\n     }\n \n-    fn contraregions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+    fn contraregions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         return Glb(*self).regions(a, b);\n     }\n \n-    fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+    fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"%s.regions(%?, %?)\",\n                self.tag(),\n                a.to_str(self.infcx),"}, {"sha": "86a872341f5618ea892ebcc2202d662323c9ccfb", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -312,10 +312,10 @@ use std::map::HashMap;\n use std::cell::{Cell, empty_cell};\n use std::list::{List, Nil, Cons};\n \n-use ty::{region, RegionVid};\n use region::is_subregion_of;\n+use ty::{Region, RegionVid};\n use syntax::codemap;\n-use to_str::to_str;\n+use to_str::ToStr;\n use util::ppaux::note_and_explain_region;\n \n export RegionVarBindings;\n@@ -325,8 +325,8 @@ export glb_regions;\n \n enum Constraint {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n-    ConstrainRegSubVar(region, RegionVid),\n-    ConstrainVarSubReg(RegionVid, region)\n+    ConstrainRegSubVar(Region, RegionVid),\n+    ConstrainVarSubReg(RegionVid, Region)\n }\n \n impl Constraint : cmp::Eq {\n@@ -365,8 +365,8 @@ impl Constraint : to_bytes::IterBytes {\n }\n \n struct TwoRegions {\n-    a: region,\n-    b: region,\n+    a: Region,\n+    b: Region,\n }\n \n impl TwoRegions : cmp::Eq {\n@@ -394,7 +394,7 @@ type CombineMap = HashMap<TwoRegions, RegionVid>;\n struct RegionVarBindings {\n     tcx: ty::ctxt,\n     var_spans: DVec<span>,\n-    values: Cell<~[ty::region]>,\n+    values: Cell<~[ty::Region]>,\n     constraints: HashMap<Constraint, span>,\n     lubs: CombineMap,\n     glbs: CombineMap,\n@@ -501,7 +501,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn make_subregion(span: span, sub: region, sup: region) -> cres<()> {\n+    fn make_subregion(span: span, sub: Region, sup: Region) -> cres<()> {\n         // cannot add constraints once regions are resolved\n         assert self.values.is_empty();\n \n@@ -529,7 +529,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn lub_regions(span: span, a: region, b: region) -> cres<region> {\n+    fn lub_regions(span: span, a: Region, b: Region) -> cres<Region> {\n         // cannot add constraints once regions are resolved\n         assert self.values.is_empty();\n \n@@ -551,7 +551,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn glb_regions(span: span, a: region, b: region) -> cres<region> {\n+    fn glb_regions(span: span, a: Region, b: Region) -> cres<Region> {\n         // cannot add constraints once regions are resolved\n         assert self.values.is_empty();\n \n@@ -574,7 +574,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn resolve_var(rid: RegionVid) -> ty::region {\n+    fn resolve_var(rid: RegionVid) -> ty::Region {\n         debug!(\"RegionVarBindings: resolve_var(%?=%u)\", rid, *rid);\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n@@ -586,9 +586,9 @@ impl RegionVarBindings {\n         self.values.with_ref(|values| values[*rid])\n     }\n \n-    fn combine_vars(combines: CombineMap, a: region, b: region, span: span,\n-                    relate: fn(old_r: region, new_r: region) -> cres<()>)\n-        -> cres<region> {\n+    fn combine_vars(combines: CombineMap, a: Region, b: Region, span: span,\n+                    relate: fn(old_r: Region, new_r: Region) -> cres<()>)\n+        -> cres<Region> {\n \n         let vars = TwoRegions { a: a, b: b };\n         match combines.find(vars) {\n@@ -623,11 +623,11 @@ impl RegionVarBindings {\n }\n \n priv impl RegionVarBindings {\n-    fn is_subregion_of(sub: region, sup: region) -> bool {\n+    fn is_subregion_of(sub: Region, sup: Region) -> bool {\n         is_subregion_of(self.tcx.region_map, sub, sup)\n     }\n \n-    fn lub_concrete_regions(+a: region, +b: region) -> region {\n+    fn lub_concrete_regions(+a: Region, +b: Region) -> Region {\n         match (a, b) {\n           (ty::re_static, _) | (_, ty::re_static) => {\n             ty::re_static // nothing lives longer than static\n@@ -682,7 +682,7 @@ priv impl RegionVarBindings {\n         }\n     }\n \n-    fn glb_concrete_regions(+a: region, +b: region) -> cres<region> {\n+    fn glb_concrete_regions(+a: Region, +b: Region) -> cres<Region> {\n         match (a, b) {\n           (ty::re_static, r) | (r, ty::re_static) => {\n             // static lives longer than everything else\n@@ -771,7 +771,7 @@ impl Classification : cmp::Eq {\n     pure fn ne(other: &Classification) -> bool { !self.eq(other) }\n }\n \n-enum GraphNodeValue { NoValue, Value(region), ErrorValue }\n+enum GraphNodeValue { NoValue, Value(Region), ErrorValue }\n \n struct GraphNode {\n     span: span,\n@@ -792,7 +792,7 @@ struct Graph {\n }\n \n struct SpannedRegion {\n-    region: region,\n+    region: Region,\n     span: span,\n }\n \n@@ -803,7 +803,7 @@ fn TwoRegionsMap() -> TwoRegionsMap {\n }\n \n impl RegionVarBindings {\n-    fn infer_variable_values() -> ~[region] {\n+    fn infer_variable_values() -> ~[Region] {\n         let graph = self.construct_graph();\n         self.expansion(&graph);\n         self.contraction(&graph);\n@@ -895,7 +895,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn expand_node(a_region: region,\n+    fn expand_node(a_region: Region,\n                    b_vid: RegionVid,\n                    b_node: &GraphNode) -> bool {\n         debug!(\"expand_node(%?, %? == %?)\",\n@@ -955,7 +955,7 @@ impl RegionVarBindings {\n \n     fn contract_node(a_vid: RegionVid,\n                      a_node: &GraphNode,\n-                     b_region: region) -> bool {\n+                     b_region: Region) -> bool {\n         debug!(\"contract_node(%? == %?/%?, %?)\",\n                a_vid, a_node.value, a_node.classification, b_region);\n \n@@ -985,8 +985,8 @@ impl RegionVarBindings {\n         fn check_node(self: &RegionVarBindings,\n                       a_vid: RegionVid,\n                       a_node: &GraphNode,\n-                      a_region: region,\n-                      b_region: region) -> bool {\n+                      a_region: Region,\n+                      b_region: Region) -> bool {\n             if !self.is_subregion_of(a_region, b_region) {\n                 debug!(\"Setting %? to ErrorValue: %? not subregion of %?\",\n                        a_vid, a_region, b_region);\n@@ -998,8 +998,8 @@ impl RegionVarBindings {\n         fn adjust_node(self: &RegionVarBindings,\n                        a_vid: RegionVid,\n                        a_node: &GraphNode,\n-                       a_region: region,\n-                       b_region: region) -> bool {\n+                       a_region: Region,\n+                       b_region: Region) -> bool {\n             match self.glb_concrete_regions(a_region, b_region) {\n               Ok(glb) => {\n                 if glb == a_region {\n@@ -1040,7 +1040,7 @@ impl RegionVarBindings {\n         debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n     }\n \n-    fn extract_regions_and_report_errors(graph: &Graph) -> ~[region] {\n+    fn extract_regions_and_report_errors(graph: &Graph) -> ~[Region] {\n         let dup_map = TwoRegionsMap();\n         graph.nodes.mapi(|idx, node| {\n             match node.value {\n@@ -1073,8 +1073,8 @@ impl RegionVarBindings {\n \n     // Used to suppress reporting the same basic error over and over\n     fn is_reported(dup_map: TwoRegionsMap,\n-                   r_a: region,\n-                   r_b: region) -> bool {\n+                   r_a: Region,\n+                   r_b: Region) -> bool {\n         let key = TwoRegions { a: r_a, b: r_b };\n         !dup_map.insert(key, ())\n     }"}, {"sha": "5a55fbf9a5dfc7165e34b879165c3e2c4f26c795", "filename": "src/rustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -35,7 +35,7 @@\n // probably better off writing `resolve_all - resolve_ivar`.\n \n use integral::*;\n-use to_str::to_str;\n+use to_str::ToStr;\n \n const resolve_nested_tvar: uint = 0b00000001;\n const resolve_rvar: uint        = 0b00000010;\n@@ -98,7 +98,7 @@ impl resolve_state {\n         }\n     }\n \n-    fn resolve_region_chk(orig: ty::region) -> fres<ty::region> {\n+    fn resolve_region_chk(orig: ty::Region) -> fres<ty::Region> {\n         self.err = None;\n         let resolved = indent(|| self.resolve_region(orig) );\n         match self.err {\n@@ -145,22 +145,22 @@ impl resolve_state {\n         }\n     }\n \n-    fn resolve_region(orig: ty::region) -> ty::region {\n+    fn resolve_region(orig: ty::Region) -> ty::Region {\n         debug!(\"Resolve_region(%s)\", orig.to_str(self.infcx));\n         match orig {\n           ty::re_var(rid) => self.resolve_region_var(rid),\n           _ => orig\n         }\n     }\n \n-    fn resolve_region_var(rid: RegionVid) -> ty::region {\n+    fn resolve_region_var(rid: RegionVid) -> ty::Region {\n         if !self.should(resolve_rvar) {\n             return ty::re_var(rid)\n         }\n         self.infcx.region_vars.resolve_var(rid)\n     }\n \n-    fn assert_not_rvar(rid: RegionVid, r: ty::region) {\n+    fn assert_not_rvar(rid: RegionVid, r: ty::Region) {\n         match r {\n           ty::re_var(rid2) => {\n             self.err = Some(region_var_bound_by_region_var(rid, rid2));"}, {"sha": "0aba993512bb4917a8ebfa3d8e211b69b9a25f42", "filename": "src/rustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,6 +1,6 @@\n use combine::*;\n use unify::*;\n-use to_str::to_str;\n+use to_str::ToStr;\n \n enum Sub = combine_fields;  // \"subtype\", \"subregion\" etc\n \n@@ -20,14 +20,14 @@ impl Sub: combine {\n         Sub(opp).tys(b, a)\n     }\n \n-    fn contraregions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+    fn contraregions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         let opp = combine_fields {\n             a_is_expected: !self.a_is_expected,.. *self\n         };\n         Sub(opp).regions(b, a)\n     }\n \n-    fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+    fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"%s.regions(%s, %s)\",\n                self.tag(),\n                a.to_str(self.infcx),"}, {"sha": "c98a217a7464ef84d3b2004802753ba421c0c07a", "filename": "src/rustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,29 +1,29 @@\n use integral::{int_ty_set};\n use unify::{var_value, redirect, root};\n \n-trait to_str {\n+trait ToStr {\n     fn to_str(cx: infer_ctxt) -> ~str;\n }\n \n-impl ty::t: to_str {\n+impl ty::t: ToStr {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         ty_to_str(cx.tcx, self)\n     }\n }\n \n-impl ty::mt: to_str {\n+impl ty::mt: ToStr {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         mt_to_str(cx.tcx, self)\n     }\n }\n \n-impl ty::region: to_str {\n+impl ty::Region: ToStr {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         util::ppaux::region_to_str(cx.tcx, self)\n     }\n }\n \n-impl<V:Copy to_str> bound<V>: to_str {\n+impl<V:Copy ToStr> bound<V>: ToStr {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         match self {\n           Some(v) => v.to_str(cx),\n@@ -32,23 +32,23 @@ impl<V:Copy to_str> bound<V>: to_str {\n     }\n }\n \n-impl<T:Copy to_str> bounds<T>: to_str {\n+impl<T:Copy ToStr> bounds<T>: ToStr {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         fmt!(\"{%s <: %s}\",\n              self.lb.to_str(cx),\n              self.ub.to_str(cx))\n     }\n }\n \n-impl int_ty_set: to_str {\n+impl int_ty_set: ToStr {\n     fn to_str(_cx: infer_ctxt) -> ~str {\n         match self {\n           int_ty_set(v) => uint::to_str(v, 10u)\n         }\n     }\n }\n \n-impl<V:Copy vid, T:Copy to_str> var_value<V, T>: to_str {\n+impl<V:Copy vid, T:Copy ToStr> var_value<V, T>: ToStr {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         match self {\n           redirect(vid) => fmt!(\"redirect(%s)\", vid.to_str()),"}, {"sha": "f865705563c60e3fac6d46ba4caf703f8e82ae7b", "filename": "src/rustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,6 +1,6 @@\n use combine::combine;\n use integral::*;\n-use to_str::to_str;\n+use to_str::ToStr;\n use std::smallintmap::SmallIntMap;\n \n enum var_value<V:Copy, T:Copy> {\n@@ -46,7 +46,7 @@ impl infer_ctxt {\n         }\n     }\n \n-    fn set<V:Copy vid, T:Copy to_str>(\n+    fn set<V:Copy vid, T:Copy ToStr>(\n         vb: &vals_and_bindings<V, T>, vid: V,\n         +new_v: var_value<V, T>) {\n "}, {"sha": "d379607d6a81f1d8ce3c689fb081336e0861663e", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -2,66 +2,66 @@ use result::Result;\n use syntax::parse::token::special_idents;\n \n trait region_scope {\n-    fn anon_region(span: span) -> Result<ty::region, ~str>;\n-    fn self_region(span: span) -> Result<ty::region, ~str>;\n-    fn named_region(span: span, id: ast::ident) -> Result<ty::region, ~str>;\n+    fn anon_region(span: span) -> Result<ty::Region, ~str>;\n+    fn self_region(span: span) -> Result<ty::Region, ~str>;\n+    fn named_region(span: span, id: ast::ident) -> Result<ty::Region, ~str>;\n }\n \n enum empty_rscope { empty_rscope }\n impl empty_rscope: region_scope {\n-    fn anon_region(_span: span) -> Result<ty::region, ~str> {\n+    fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n         result::Ok(ty::re_static)\n     }\n-    fn self_region(_span: span) -> Result<ty::region, ~str> {\n+    fn self_region(_span: span) -> Result<ty::Region, ~str> {\n         result::Err(~\"only the static region is allowed here\")\n     }\n     fn named_region(_span: span, _id: ast::ident)\n-        -> Result<ty::region, ~str>\n+        -> Result<ty::Region, ~str>\n     {\n         result::Err(~\"only the static region is allowed here\")\n     }\n }\n \n enum type_rscope = Option<ty::region_variance>;\n impl type_rscope: region_scope {\n-    fn anon_region(_span: span) -> Result<ty::region, ~str> {\n+    fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n         match *self {\n           Some(_) => result::Ok(ty::re_bound(ty::br_self)),\n           None => result::Err(~\"to use region types here, the containing \\\n                                 type must be declared with a region bound\")\n         }\n     }\n-    fn self_region(span: span) -> Result<ty::region, ~str> {\n+    fn self_region(span: span) -> Result<ty::Region, ~str> {\n         self.anon_region(span)\n     }\n-    fn named_region(span: span, id: ast::ident) -> Result<ty::region, ~str> {\n+    fn named_region(span: span, id: ast::ident) -> Result<ty::Region, ~str> {\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n             result::Err(~\"named regions other than `self` are not \\\n                           allowed as part of a type declaration\")\n         }\n     }\n }\n \n-fn bound_self_region(rp: Option<ty::region_variance>) -> Option<ty::region> {\n+fn bound_self_region(rp: Option<ty::region_variance>) -> Option<ty::Region> {\n     match rp {\n       Some(_) => Some(ty::re_bound(ty::br_self)),\n       None => None\n     }\n }\n \n-enum anon_rscope = {anon: ty::region, base: region_scope};\n-fn in_anon_rscope<RS: region_scope Copy Owned>(self: RS, r: ty::region)\n+enum anon_rscope = {anon: ty::Region, base: region_scope};\n+fn in_anon_rscope<RS: region_scope Copy Owned>(self: RS, r: ty::Region)\n     -> @anon_rscope {\n     @anon_rscope({anon: r, base: self as region_scope})\n }\n impl @anon_rscope: region_scope {\n-    fn anon_region(_span: span) -> Result<ty::region, ~str> {\n+    fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n         result::Ok(self.anon)\n     }\n-    fn self_region(span: span) -> Result<ty::region, ~str> {\n+    fn self_region(span: span) -> Result<ty::Region, ~str> {\n         self.base.self_region(span)\n     }\n-    fn named_region(span: span, id: ast::ident) -> Result<ty::region, ~str> {\n+    fn named_region(span: span, id: ast::ident) -> Result<ty::Region, ~str> {\n         self.base.named_region(span, id)\n     }\n }\n@@ -76,15 +76,15 @@ fn in_binding_rscope<RS: region_scope Copy Owned>(self: RS)\n     @binding_rscope { base: base, anon_bindings: 0 }\n }\n impl @binding_rscope: region_scope {\n-    fn anon_region(_span: span) -> Result<ty::region, ~str> {\n+    fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n         let idx = self.anon_bindings;\n         self.anon_bindings += 1;\n         result::Ok(ty::re_bound(ty::br_anon(idx)))\n     }\n-    fn self_region(span: span) -> Result<ty::region, ~str> {\n+    fn self_region(span: span) -> Result<ty::Region, ~str> {\n         self.base.self_region(span)\n     }\n-    fn named_region(span: span, id: ast::ident) -> Result<ty::region, ~str> {\n+    fn named_region(span: span, id: ast::ident) -> Result<ty::Region, ~str> {\n         do self.base.named_region(span, id).chain_err |_e| {\n             result::Ok(ty::re_bound(ty::br_named(id)))\n         }"}, {"sha": "0c6ec267da81281a43ad96bb4f988b34f4368561", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,6 +1,5 @@\n use std::map::HashMap;\n use syntax::ast;\n-use ast::{ty, pat};\n use syntax::codemap::{span};\n use syntax::visit;\n use syntax::print;"}, {"sha": "27ace283fa0ce7a75810d372b7be9ec2904c2ab1", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -6,7 +6,7 @@ use middle::ty::{bound_copy, bound_const, bound_owned, bound_send,\n use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n use middle::ty::{ck_block, ck_box, ck_uniq, ctxt, field, method};\n use middle::ty::{mt, t, param_bound};\n-use middle::ty::{re_bound, re_free, re_scope, re_var, re_static, region};\n+use middle::ty::{re_bound, re_free, re_scope, re_var, re_static, Region};\n use middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_enum};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_trait, ty_int};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n@@ -21,11 +21,10 @@ use syntax::print::pprust::{path_to_str, proto_to_str,\n                             mode_to_str, purity_to_str};\n use syntax::{ast, ast_util};\n use syntax::ast_map;\n-use driver::session::session;\n \n fn note_and_explain_region(cx: ctxt,\n                            prefix: ~str,\n-                           region: ty::region,\n+                           region: ty::Region,\n                            suffix: ~str) {\n     match explain_region_and_span(cx, region) {\n       (str, Some(span)) => {\n@@ -42,13 +41,13 @@ fn note_and_explain_region(cx: ctxt,\n \n /// Returns a string like \"the block at 27:31\" that attempts to explain a\n /// lifetime in a way it might plausibly be understood.\n-fn explain_region(cx: ctxt, region: ty::region) -> ~str {\n+fn explain_region(cx: ctxt, region: ty::Region) -> ~str {\n   let (res, _) = explain_region_and_span(cx, region);\n   return res;\n }\n \n \n-fn explain_region_and_span(cx: ctxt, region: ty::region)\n+fn explain_region_and_span(cx: ctxt, region: ty::Region)\n     -> (~str, Option<span>)\n {\n     return match region {\n@@ -172,7 +171,7 @@ fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n // In general, if you are giving a region error message,\n // you should use `explain_region()` or, better yet,\n // `note_and_explain_region()`\n-fn region_to_str(cx: ctxt, region: region) -> ~str {\n+fn region_to_str(cx: ctxt, region: Region) -> ~str {\n     if cx.sess.verbose() {\n         return fmt!(\"&%?\", region);\n     }\n@@ -381,7 +380,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n \n fn parameterized(cx: ctxt,\n                  base: ~str,\n-                 self_r: Option<ty::region>,\n+                 self_r: Option<ty::Region>,\n                  tps: ~[ty::t]) -> ~str {\n \n     let r_str = match self_r {"}, {"sha": "7b2c6fe5f0cbc562e050ab3cedf17747df871bfa", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -10,7 +10,7 @@ non-sendableness.\n use std::map::HashMap;\n use rustc::driver::session;\n use session::{basic_options, options};\n-use session::session;\n+use session::Session;\n use rustc::driver::driver;\n use syntax::diagnostic;\n use syntax::diagnostic::handler;\n@@ -35,7 +35,7 @@ type Ctxt = {\n \n type SrvOwner<T> = fn(srv: Srv) -> T;\n type CtxtHandler<T> = fn~(ctxt: Ctxt) -> T;\n-type Parser = fn~(session, ~str) -> @ast::crate;\n+type Parser = fn~(Session, ~str) -> @ast::crate;\n \n enum Msg {\n     HandleRequest(fn~(Ctxt)),\n@@ -101,7 +101,7 @@ fn exec<T:Send>(\n     comm::recv(po)\n }\n \n-fn build_ctxt(sess: session,\n+fn build_ctxt(sess: Session,\n               ast: @ast::crate) -> Ctxt {\n \n     use rustc::front::config;\n@@ -118,7 +118,7 @@ fn build_ctxt(sess: session,\n     }\n }\n \n-fn build_session() -> session {\n+fn build_session() -> Session {\n     let sopts: @options = basic_options();\n     let codemap = codemap::new_codemap();\n     let error_handlers = build_error_handlers(codemap);\n@@ -137,7 +137,7 @@ type ErrorHandlers = {\n // Build a custom error handler that will allow us to ignore non-fatal\n // errors\n fn build_error_handlers(\n-    codemap: codemap::codemap\n+    codemap: codemap::CodeMap\n ) -> ErrorHandlers {\n \n     type DiagnosticHandler = {\n@@ -156,13 +156,13 @@ fn build_error_handlers(\n         fn note(msg: &str) { self.inner.note(msg) }\n         fn bug(msg: &str) -> ! { self.inner.bug(msg) }\n         fn unimpl(msg: &str) -> ! { self.inner.unimpl(msg) }\n-        fn emit(cmsp: Option<(codemap::codemap, codemap::span)>,\n+        fn emit(cmsp: Option<(codemap::CodeMap, codemap::span)>,\n                 msg: &str, lvl: diagnostic::level) {\n             self.inner.emit(cmsp, msg, lvl)\n         }\n     }\n \n-    let emitter = fn@(cmsp: Option<(codemap::codemap, codemap::span)>,\n+    let emitter = fn@(cmsp: Option<(codemap::CodeMap, codemap::span)>,\n                        msg: &str, lvl: diagnostic::level) {\n         diagnostic::emit(cmsp, msg, lvl);\n     };"}, {"sha": "7fc17dfe83861f798d3322f740a46ce9a8efbdc3", "filename": "src/rustdoc/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Frustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fparse.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -20,16 +20,16 @@ fn from_str(source: ~str) -> @ast::crate {\n         ~\"-\", @source, ~[], parse::new_parse_sess(None))\n }\n \n-fn from_file_sess(sess: session::session, file: &Path) -> @ast::crate {\n+fn from_file_sess(sess: session::Session, file: &Path) -> @ast::crate {\n     parse::parse_crate_from_file(\n         file, cfg(sess, file_input(*file)), sess.parse_sess)\n }\n \n-fn from_str_sess(sess: session::session, source: ~str) -> @ast::crate {\n+fn from_str_sess(sess: session::Session, source: ~str) -> @ast::crate {\n     parse::parse_crate_from_source_str(\n         ~\"-\", @source, cfg(sess, str_input(source)), sess.parse_sess)\n }\n \n-fn cfg(sess: session::session, input: driver::input) -> ast::crate_cfg {\n+fn cfg(sess: session::Session, input: driver::input) -> ast::crate_cfg {\n     driver::default_configuration(sess, ~\"rustdoc\", input)\n }"}, {"sha": "bccaeeaf18ddcf6c7761859d32c05d48a4605ca5", "filename": "src/test/run-pass/issue-2930.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Ftest%2Frun-pass%2Fissue-2930.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Ftest%2Frun-pass%2Fissue-2930.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2930.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -1,6 +1,6 @@\n proto! stream (\n-    stream:send<T:Send> {\n-        send(T) -> stream<T>\n+    Stream:send<T:Send> {\n+        send(T) -> Stream<T>\n     }\n )\n "}, {"sha": "23588de2ecafcda07936696f9cba295cec696255", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91ae5412d8141ea958924408bf3c1def5edca806/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ae5412d8141ea958924408bf3c1def5edca806/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=91ae5412d8141ea958924408bf3c1def5edca806", "patch": "@@ -14,8 +14,8 @@ proto! oneshot (\n )\n \n proto! stream (\n-    stream:send<T:Send> {\n-        send(T) -> stream<T>\n+    Stream:send<T:Send> {\n+        send(T) -> Stream<T>\n     }\n )\n "}]}