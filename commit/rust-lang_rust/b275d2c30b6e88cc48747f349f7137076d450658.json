{"sha": "b275d2c30b6e88cc48747f349f7137076d450658", "node_id": "C_kwDOAAsO6NoAKGIyNzVkMmMzMGI2ZTg4Y2M0ODc0N2YzNDlmNzEzNzA3NmQ0NTA2NTg", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-08T13:53:19Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-20T17:48:32Z"}, "message": "Remove WithOptconstParam.", "tree": {"sha": "b834a60fd639a6badc5f2838974455658522542b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b834a60fd639a6badc5f2838974455658522542b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b275d2c30b6e88cc48747f349f7137076d450658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b275d2c30b6e88cc48747f349f7137076d450658", "html_url": "https://github.com/rust-lang/rust/commit/b275d2c30b6e88cc48747f349f7137076d450658", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b275d2c30b6e88cc48747f349f7137076d450658/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e017fc94a5b35250fd1b0732e004e0112d09728", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e017fc94a5b35250fd1b0732e004e0112d09728", "html_url": "https://github.com/rust-lang/rust/commit/0e017fc94a5b35250fd1b0732e004e0112d09728"}], "stats": {"total": 1289, "additions": 332, "deletions": 957}, "files": [{"sha": "cd200aaa2778fdae8f997deefb85d0fd31eec9a5", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_index::vec::IndexSlice;\n use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n use rustc_middle::mir::Body;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n \n pub use super::{\n     facts::{AllFacts as PoloniusInput, RustcFacts},\n@@ -28,12 +28,9 @@ pub use super::{\n ///     that shows how to do this at `tests/run-make/obtain-borrowck/`.\n ///\n /// *   Polonius is highly unstable, so expect regular changes in its signature or other details.\n-pub fn get_body_with_borrowck_facts(\n-    tcx: TyCtxt<'_>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n-) -> BodyWithBorrowckFacts<'_> {\n+pub fn get_body_with_borrowck_facts(tcx: TyCtxt<'_>, def: LocalDefId) -> BodyWithBorrowckFacts<'_> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n-    let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def.did)).build();\n+    let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def)).build();\n     let input_body: &Body<'_> = &input_body.borrow();\n     let promoted: &IndexSlice<_, _> = &promoted.borrow();\n     *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()"}, {"sha": "2320901a0534d3eb103a0d106eb20a44cd7fe9bc", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::mir::{\n     FakeReadCause, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty, TypeckResults};\n+use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty};\n use rustc_middle::util::CallKind;\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::def_id::LocalDefId;\n@@ -1350,8 +1350,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         finder.visit_expr(body_expr);\n         let Some((closure_expr, closure)) = finder.res else { return };\n \n-        let typeck_results: &TypeckResults<'_> =\n-            tcx.typeck_opt_const_arg(self.body.source.with_opt_param().as_local().unwrap());\n+        let typeck_results = tcx.typeck(self.mir_def_id());\n \n         // Check that the parent of the closure is a method call,\n         // with receiver matching with local's type (modulo refs)"}, {"sha": "6a5a7e08d383628adcb52483594378567466a5a1", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -119,24 +119,12 @@ impl<'tcx> TyCtxtConsts<'tcx> {\n }\n \n pub fn provide(providers: &mut Providers) {\n-    *providers = Providers {\n-        mir_borrowck: |tcx, did| {\n-            if let Some(def) = ty::WithOptConstParam::try_lookup(did, tcx) {\n-                tcx.mir_borrowck_const_arg(def)\n-            } else {\n-                mir_borrowck(tcx, ty::WithOptConstParam::unknown(did))\n-            }\n-        },\n-        mir_borrowck_const_arg: |tcx, (did, param_did)| {\n-            mir_borrowck(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })\n-        },\n-        ..*providers\n-    };\n+    *providers = Providers { mir_borrowck, ..*providers };\n }\n \n-fn mir_borrowck(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &BorrowCheckResult<'_> {\n+fn mir_borrowck(tcx: TyCtxt<'_>, def: LocalDefId) -> &BorrowCheckResult<'_> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n-    debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n+    debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.to_def_id()));\n \n     if input_body.borrow().should_skip() {\n         debug!(\"Skipping borrowck because of injected body\");\n@@ -150,7 +138,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Bor\n         return tcx.arena.alloc(result);\n     }\n \n-    let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n+    let hir_owner = tcx.hir().local_def_id_to_hir_id(def).owner;\n \n     let infcx =\n         tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)).build();\n@@ -167,19 +155,19 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Bor\n /// If `return_body_with_facts` is true, then return the body with non-erased\n /// region ids on which the borrow checking was performed together with Polonius\n /// facts.\n-#[instrument(skip(infcx, input_body, input_promoted), fields(id=?input_body.source.with_opt_param().as_local().unwrap()), level = \"debug\")]\n+#[instrument(skip(infcx, input_body, input_promoted), fields(id=?input_body.source.def_id()), level = \"debug\")]\n fn do_mir_borrowck<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     input_body: &Body<'tcx>,\n     input_promoted: &IndexSlice<Promoted, Body<'tcx>>,\n     return_body_with_facts: bool,\n ) -> (BorrowCheckResult<'tcx>, Option<Box<BodyWithBorrowckFacts<'tcx>>>) {\n-    let def = input_body.source.with_opt_param().as_local().unwrap();\n+    let def = input_body.source.def_id().expect_local();\n     debug!(?def);\n \n     let tcx = infcx.tcx;\n     let infcx = BorrowckInferCtxt::new(infcx);\n-    let param_env = tcx.param_env(def.did);\n+    let param_env = tcx.param_env(def);\n \n     let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);\n     for var_debug_info in &input_body.var_debug_info {\n@@ -207,7 +195,7 @@ fn do_mir_borrowck<'tcx>(\n         errors.set_tainted_by_errors(e);\n     }\n     let upvars: Vec<_> = tcx\n-        .closure_captures(def.did)\n+        .closure_captures(def)\n         .iter()\n         .map(|&captured_place| {\n             let capture = captured_place.info.capture_kind;\n@@ -249,7 +237,7 @@ fn do_mir_borrowck<'tcx>(\n         .iterate_to_fixpoint()\n         .into_results_cursor(&body);\n \n-    let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(def.did).is_fn_or_closure();\n+    let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(def).is_fn_or_closure();\n     let borrow_set =\n         Rc::new(BorrowSet::build(tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n "}, {"sha": "78bdf00a69c45d26a9f27403d16d6162f067e55a", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -61,7 +61,7 @@ pub(crate) fn replace_regions_in_mir<'tcx>(\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexSlice<Promoted, Body<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n-    let def = body.source.with_opt_param().as_local().unwrap();\n+    let def = body.source.def_id().expect_local();\n \n     debug!(?def);\n "}, {"sha": "06b80bd3f29adf096717df19021db559fed6c852", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -394,7 +394,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     self.cx.ascribe_user_type(\n                         constant.literal.ty(),\n                         UserType::TypeOf(\n-                            uv.def.did,\n+                            uv.def,\n                             UserSubsts { substs: uv.substs, user_self_ty: None },\n                         ),\n                         locations.span(&self.cx.body),\n@@ -1766,7 +1766,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             if let Some(uv) = maybe_uneval {\n                 if uv.promoted.is_none() {\n                     let tcx = self.tcx();\n-                    let def_id = uv.def.def_id_for_type_of();\n+                    let def_id = uv.def;\n                     if tcx.def_kind(def_id) == DefKind::InlineConst {\n                         let def_id = def_id.expect_local();\n                         let predicates ="}, {"sha": "ef37c01cef8c96b312b2519a81f3e713a5e6bf75", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -226,7 +226,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// known between those regions.\n     pub fn new(\n         infcx: &BorrowckInferCtxt<'_, 'tcx>,\n-        mir_def: ty::WithOptConstParam<LocalDefId>,\n+        mir_def: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         UniversalRegionsBuilder { infcx, mir_def, param_env }.build()\n@@ -388,7 +388,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n struct UniversalRegionsBuilder<'cx, 'tcx> {\n     infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n-    mir_def: ty::WithOptConstParam<LocalDefId>,\n+    mir_def: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n@@ -417,12 +417,12 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let mut indices = self.compute_indices(fr_static, defining_ty);\n         debug!(\"build: indices={:?}\", indices);\n \n-        let typeck_root_def_id = self.infcx.tcx.typeck_root_def_id(self.mir_def.did.to_def_id());\n+        let typeck_root_def_id = self.infcx.tcx.typeck_root_def_id(self.mir_def.to_def_id());\n \n         // If this is a 'root' body (not a closure/generator/inline const), then\n         // there are no extern regions, so the local regions start at the same\n         // position as the (empty) sub-list of extern regions\n-        let first_local_index = if self.mir_def.did.to_def_id() == typeck_root_def_id {\n+        let first_local_index = if self.mir_def.to_def_id() == typeck_root_def_id {\n             first_extern_index\n         } else {\n             // If this is a closure, generator, or inline-const, then the late-bound regions from the enclosing\n@@ -433,7 +433,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             // }\n             for_each_late_bound_region_in_recursive_scope(\n                 self.infcx.tcx,\n-                self.infcx.tcx.local_parent(self.mir_def.did),\n+                self.infcx.tcx.local_parent(self.mir_def),\n                 |r| {\n                     debug!(?r);\n                     if !indices.indices.contains_key(&r) {\n@@ -462,13 +462,13 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let inputs_and_output = self.infcx.replace_bound_regions_with_nll_infer_vars(\n             FR,\n-            self.mir_def.did,\n+            self.mir_def,\n             bound_inputs_and_output,\n             &mut indices,\n         );\n         // Converse of above, if this is a function/closure then the late-bound regions declared on its\n         // signature are local.\n-        for_each_late_bound_region_in_item(self.infcx.tcx, self.mir_def.did, |r| {\n+        for_each_late_bound_region_in_item(self.infcx.tcx, self.mir_def, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = {\n@@ -492,7 +492,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             if self.infcx.tcx.fn_sig(def_id).skip_binder().c_variadic() {\n                 let va_list_did = self.infcx.tcx.require_lang_item(\n                     LangItem::VaList,\n-                    Some(self.infcx.tcx.def_span(self.mir_def.did)),\n+                    Some(self.infcx.tcx.def_span(self.mir_def)),\n                 );\n \n                 let reg_vid = self\n@@ -544,11 +544,11 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n     /// see `DefiningTy` for details.\n     fn defining_ty(&self) -> DefiningTy<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let typeck_root_def_id = tcx.typeck_root_def_id(self.mir_def.did.to_def_id());\n+        let typeck_root_def_id = tcx.typeck_root_def_id(self.mir_def.to_def_id());\n \n-        match tcx.hir().body_owner_kind(self.mir_def.did) {\n+        match tcx.hir().body_owner_kind(self.mir_def) {\n             BodyOwnerKind::Closure | BodyOwnerKind::Fn => {\n-                let defining_ty = tcx.type_of(self.mir_def.def_id_for_type_of()).subst_identity();\n+                let defining_ty = tcx.type_of(self.mir_def).subst_identity();\n \n                 debug!(\"defining_ty (pre-replacement): {:?}\", defining_ty);\n \n@@ -562,20 +562,20 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     }\n                     ty::FnDef(def_id, substs) => DefiningTy::FnDef(def_id, substs),\n                     _ => span_bug!(\n-                        tcx.def_span(self.mir_def.did),\n+                        tcx.def_span(self.mir_def),\n                         \"expected defining type for `{:?}`: `{:?}`\",\n-                        self.mir_def.did,\n+                        self.mir_def,\n                         defining_ty\n                     ),\n                 }\n             }\n \n             BodyOwnerKind::Const | BodyOwnerKind::Static(..) => {\n                 let identity_substs = InternalSubsts::identity_for_item(tcx, typeck_root_def_id);\n-                if self.mir_def.did.to_def_id() == typeck_root_def_id {\n+                if self.mir_def.to_def_id() == typeck_root_def_id {\n                     let substs =\n                         self.infcx.replace_free_regions_with_nll_infer_vars(FR, identity_substs);\n-                    DefiningTy::Const(self.mir_def.did.to_def_id(), substs)\n+                    DefiningTy::Const(self.mir_def.to_def_id(), substs)\n                 } else {\n                     // FIXME this line creates a dependency between borrowck and typeck.\n                     //\n@@ -587,15 +587,15 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     // below), so that `type_of(inline_const_def_id).substs(substs)` uses the\n                     // proper type with NLL infer vars.\n                     let ty = tcx\n-                        .typeck(self.mir_def.did)\n-                        .node_type(tcx.local_def_id_to_hir_id(self.mir_def.did));\n+                        .typeck(self.mir_def)\n+                        .node_type(tcx.local_def_id_to_hir_id(self.mir_def));\n                     let substs = InlineConstSubsts::new(\n                         tcx,\n                         InlineConstSubstsParts { parent_substs: identity_substs, ty },\n                     )\n                     .substs;\n                     let substs = self.infcx.replace_free_regions_with_nll_infer_vars(FR, substs);\n-                    DefiningTy::InlineConst(self.mir_def.did.to_def_id(), substs)\n+                    DefiningTy::InlineConst(self.mir_def.to_def_id(), substs)\n                 }\n             }\n         }\n@@ -611,7 +611,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         defining_ty: DefiningTy<'tcx>,\n     ) -> UniversalRegionIndices<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let typeck_root_def_id = tcx.typeck_root_def_id(self.mir_def.did.to_def_id());\n+        let typeck_root_def_id = tcx.typeck_root_def_id(self.mir_def.to_def_id());\n         let identity_substs = InternalSubsts::identity_for_item(tcx, typeck_root_def_id);\n         let fr_substs = match defining_ty {\n             DefiningTy::Closure(_, substs)\n@@ -647,7 +647,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n-                assert_eq!(self.mir_def.did.to_def_id(), def_id);\n+                assert_eq!(self.mir_def.to_def_id(), def_id);\n                 let closure_sig = substs.as_closure().sig();\n                 let inputs_and_output = closure_sig.inputs_and_output();\n                 let bound_vars = tcx.mk_bound_variable_kinds_from_iter(\n@@ -682,7 +682,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             }\n \n             DefiningTy::Generator(def_id, substs, movability) => {\n-                assert_eq!(self.mir_def.did.to_def_id(), def_id);\n+                assert_eq!(self.mir_def.to_def_id(), def_id);\n                 let resume_ty = substs.as_generator().resume_ty();\n                 let output = substs.as_generator().return_ty();\n                 let generator_ty = tcx.mk_generator(def_id, substs, movability);\n@@ -700,14 +700,14 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             DefiningTy::Const(def_id, _) => {\n                 // For a constant body, there are no inputs, and one\n                 // \"output\" (the type of the constant).\n-                assert_eq!(self.mir_def.did.to_def_id(), def_id);\n-                let ty = tcx.type_of(self.mir_def.def_id_for_type_of()).subst_identity();\n+                assert_eq!(self.mir_def.to_def_id(), def_id);\n+                let ty = tcx.type_of(self.mir_def).subst_identity();\n                 let ty = indices.fold_to_region_vids(tcx, ty);\n                 ty::Binder::dummy(tcx.mk_type_list(&[ty]))\n             }\n \n             DefiningTy::InlineConst(def_id, substs) => {\n-                assert_eq!(self.mir_def.did.to_def_id(), def_id);\n+                assert_eq!(self.mir_def.to_def_id(), def_id);\n                 let ty = substs.as_inline_const().ty();\n                 ty::Binder::dummy(tcx.mk_type_list(&[ty]))\n             }"}, {"sha": "aacf37bb5b7372f1628b54b9998f19d624f2fa49", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -91,7 +91,7 @@ pub(crate) fn eval_mir_constant<'tcx>(\n             ),\n         },\n         ConstantKind::Unevaluated(mir::UnevaluatedConst { def, .. }, _)\n-            if fx.tcx.is_static(def.did) =>\n+            if fx.tcx.is_static(def) =>\n         {\n             span_bug!(constant.span, \"MIR constant refers to static\");\n         }"}, {"sha": "8f2f829c17c1cd76110180d80c3b2b9331d0eeee", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -333,7 +333,7 @@ fn exported_symbols_provider_local(\n             match *mono_item {\n                 MonoItem::Fn(Instance { def: InstanceDef::Item(def), substs }) => {\n                     if substs.non_erasable_generics().next().is_some() {\n-                        let symbol = ExportedSymbol::Generic(def.did, substs);\n+                        let symbol = ExportedSymbol::Generic(def, substs);\n                         symbols.push((\n                             symbol,\n                             SymbolExportInfo {"}, {"sha": "99f180f475d6bf4da1efca94722bebd9636fd3aa", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -296,12 +296,12 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n     }\n \n     let cid = key.value;\n-    let def = cid.instance.def.with_opt_param();\n-    let is_static = tcx.is_static(def.did);\n+    let def = cid.instance.def.def_id();\n+    let is_static = tcx.is_static(def);\n \n     let mut ecx = InterpCx::new(\n         tcx,\n-        tcx.def_span(def.did),\n+        tcx.def_span(def),\n         key.param_env,\n         // Statics (and promoteds inside statics) may access other statics, because unlike consts\n         // they do not have to behave \"as if\" they were evaluated at runtime."}, {"sha": "814b67b46ec7a239e726a45add6304d62f662d03", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -375,9 +375,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     ) -> InterpResult<'tcx, &'tcx mir::Body<'tcx>> {\n         match instance {\n             ty::InstanceDef::Item(def) => {\n-                if ecx.tcx.is_ctfe_mir_available(def.did) {\n-                    Ok(ecx.tcx.mir_for_ctfe_opt_const_arg(def))\n-                } else if ecx.tcx.def_kind(def.did) == DefKind::AssocConst {\n+                if ecx.tcx.is_ctfe_mir_available(def) {\n+                    Ok(ecx.tcx.mir_for_ctfe(def))\n+                } else if ecx.tcx.def_kind(def) == DefKind::AssocConst {\n                     let guar = ecx.tcx.sess.delay_span_bug(\n                         rustc_span::DUMMY_SP,\n                         \"This is likely a const item that is missing from its impl\",\n@@ -386,7 +386,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 } else {\n                     // `find_mir_or_eval_fn` checks that this is a const fn before even calling us,\n                     // so this should be unreachable.\n-                    let path = ecx.tcx.def_path_str(def.did);\n+                    let path = ecx.tcx.def_path_str(def);\n                     bug!(\"trying to call extern function `{path}` at compile-time\");\n                 }\n             }\n@@ -410,9 +410,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             // Execution might have wandered off into other crates, so we cannot do a stability-\n             // sensitive check here. But we can at least rule out functions that are not const\n             // at all.\n-            if !ecx.tcx.is_const_fn_raw(def.did) {\n+            if !ecx.tcx.is_const_fn_raw(def) {\n                 // allow calling functions inside a trait marked with #[const_trait].\n-                if !ecx.tcx.is_const_default_method(def.did) {\n+                if !ecx.tcx.is_const_default_method(def) {\n                     // We certainly do *not* want to actually call the fn\n                     // though, so be sure we return here.\n                     throw_unsup_format!(\"calling non-const function `{}`\", instance)"}, {"sha": "6030498e946a774d89eddf783335b74a7fa9f781", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -461,10 +461,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         instance: ty::InstanceDef<'tcx>,\n         promoted: Option<mir::Promoted>,\n     ) -> InterpResult<'tcx, &'tcx mir::Body<'tcx>> {\n-        let def = instance.with_opt_param();\n         trace!(\"load mir(instance={:?}, promoted={:?})\", instance, promoted);\n         let body = if let Some(promoted) = promoted {\n-            &self.tcx.promoted_mir_opt_const_arg(def)[promoted]\n+            let def = instance.def_id();\n+            &self.tcx.promoted_mir(def)[promoted]\n         } else {\n             M::load_mir(self, instance)?\n         };\n@@ -502,13 +502,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// The `substs` are assumed to already be in our interpreter \"universe\" (param_env).\n     pub(super) fn resolve(\n         &self,\n-        def: ty::WithOptConstParam<DefId>,\n+        def: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n         trace!(\"resolve: {:?}, {:#?}\", def, substs);\n         trace!(\"param_env: {:#?}\", self.param_env);\n         trace!(\"substs: {:#?}\", substs);\n-        match ty::Instance::resolve_opt_const_arg(*self.tcx, self.param_env, def, substs) {\n+        match ty::Instance::resolve(*self.tcx, self.param_env, def, substs) {\n             Ok(Some(instance)) => Ok(instance),\n             Ok(None) => throw_inval!(TooGeneric),\n "}, {"sha": "df3879200101b444bc6737b0db131b042024577d", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -83,8 +83,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         (fn_val, self.fn_abi_of_fn_ptr(fn_sig_binder, extra_args)?, false)\n                     }\n                     ty::FnDef(def_id, substs) => {\n-                        let instance =\n-                            self.resolve(ty::WithOptConstParam::unknown(def_id), substs)?;\n+                        let instance = self.resolve(def_id, substs)?;\n                         (\n                             FnVal::Instance(instance),\n                             self.fn_abi_of_instance(instance, extra_args)?,"}, {"sha": "7cb19744987c20e7409627c860c723fb1f48d93b", "filename": "compiler/rustc_const_eval/src/interpret/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -36,7 +36,7 @@ where\n                 ty::Closure(def_id, substs)\n                 | ty::Generator(def_id, substs, ..)\n                 | ty::FnDef(def_id, substs) => {\n-                    let instance = ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id));\n+                    let instance = ty::InstanceDef::Item(def_id);\n                     let unused_params = self.tcx.unused_generic_params(instance);\n                     for (index, subst) in substs.into_iter().enumerate() {\n                         let index = index"}, {"sha": "76522ed6e490a50b27fa56a0c40ce82a4a3fbcbc", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -874,7 +874,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     debug!(\"Resolving ({:?}) -> {:?}\", callee, instance);\n                     if let Ok(Some(func)) = instance {\n                         if let InstanceDef::Item(def) = func.def {\n-                            callee = def.did;\n+                            callee = def;\n                         }\n                     }\n                 }"}, {"sha": "bf688f2b34e9d16fd9bbfd83bab1c0f1cb89d43b", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -364,9 +364,8 @@ where\n         assert!(promoted.is_none() || Q::ALLOW_PROMOTED);\n \n         // Don't peek inside trait associated constants.\n-        if promoted.is_none() && cx.tcx.trait_of_item(def.did).is_none() {\n-            assert_eq!(def.const_param_did, None, \"expected associated const: {def:?}\");\n-            let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def.did);\n+        if promoted.is_none() && cx.tcx.trait_of_item(def).is_none() {\n+            let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def);\n \n             if !Q::in_qualifs(&qualifs) {\n                 return false;"}, {"sha": "1e3d61a78befbce01c98ed5fd38b348099100b8b", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -828,15 +828,15 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn promote_candidate(mut self, candidate: Candidate, next_promoted_id: usize) -> Body<'tcx> {\n-        let def = self.source.source.with_opt_param();\n+        let def = self.source.source.def_id();\n         let mut rvalue = {\n             let promoted = &mut self.promoted;\n             let promoted_id = Promoted::new(next_promoted_id);\n             let tcx = self.tcx;\n             let mut promoted_operand = |ty, span| {\n                 promoted.span = span;\n                 promoted.local_decls[RETURN_PLACE] = LocalDecl::new(ty, span);\n-                let substs = tcx.erase_regions(InternalSubsts::identity_for_item(tcx, def.did));\n+                let substs = tcx.erase_regions(InternalSubsts::identity_for_item(tcx, def));\n                 let uneval = mir::UnevaluatedConst { def, substs, promoted: Some(promoted_id) };\n \n                 Operand::Constant(Box::new(Constant {"}, {"sha": "ee64b18d3f60cb443d8fe00ce36fbf2da828d85a", "filename": "compiler/rustc_driver_impl/src/pretty.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_driver_impl%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_driver_impl%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Fpretty.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -488,12 +488,7 @@ fn print_with_analysis(tcx: TyCtxt<'_>, ppm: PpMode) -> Result<(), ErrorGuarante\n             abort_on_err(rustc_hir_analysis::check_crate(tcx), tcx.sess);\n             debug!(\"pretty printing THIR tree\");\n             for did in tcx.hir().body_owners() {\n-                let _ = writeln!(\n-                    out,\n-                    \"{:?}:\\n{}\\n\",\n-                    did,\n-                    tcx.thir_tree(ty::WithOptConstParam::unknown(did))\n-                );\n+                let _ = writeln!(out, \"{:?}:\\n{}\\n\", did, tcx.thir_tree(did));\n             }\n             out\n         }\n@@ -503,12 +498,7 @@ fn print_with_analysis(tcx: TyCtxt<'_>, ppm: PpMode) -> Result<(), ErrorGuarante\n             abort_on_err(rustc_hir_analysis::check_crate(tcx), tcx.sess);\n             debug!(\"pretty printing THIR flat\");\n             for did in tcx.hir().body_owners() {\n-                let _ = writeln!(\n-                    out,\n-                    \"{:?}:\\n{}\\n\",\n-                    did,\n-                    tcx.thir_flat(ty::WithOptConstParam::unknown(did))\n-                );\n+                let _ = writeln!(out, \"{:?}:\\n{}\\n\", did, tcx.thir_flat(did));\n             }\n             out\n         }"}, {"sha": "9b388394ff4964b9f711e6e74a351ab2abe50618", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -420,7 +420,6 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n             // for generic arguments.\n             tcx.type_of(param).subst_identity()\n         }\n-\n         Node::AnonConst(_) => {\n             let parent_node = tcx.hir().get_parent(hir_id);\n             match parent_node {"}, {"sha": "08d3593f91ff803454b82bfba74d73efd27cc37b", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -156,14 +156,6 @@ fn typeck_item_bodies(tcx: TyCtxt<'_>, (): ()) {\n     tcx.hir().par_body_owners(|body_owner_def_id| tcx.ensure().typeck(body_owner_def_id));\n }\n \n-fn typeck_const_arg<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    (did, param_did): (LocalDefId, DefId),\n-) -> &ty::TypeckResults<'tcx> {\n-    let fallback = move || tcx.type_of(param_did).subst_identity();\n-    typeck_with_fallback(tcx, did, fallback)\n-}\n-\n fn typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n     let fallback = move || tcx.type_of(def_id.to_def_id()).subst_identity();\n     typeck_with_fallback(tcx, def_id, fallback)\n@@ -488,7 +480,6 @@ pub fn provide(providers: &mut Providers) {\n     method::provide(providers);\n     *providers = Providers {\n         typeck_item_bodies,\n-        typeck_const_arg,\n         typeck,\n         diagnostic_only_typeck,\n         has_typeck_results,"}, {"sha": "3e80bb906e44930ac81814a2fe80983971893e9e", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -1500,7 +1500,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             Ok(Some(val)) => Ok(self.tcx.mk_const(val, ty)),\n             Ok(None) => {\n                 let tcx = self.tcx;\n-                let def_id = unevaluated.def.did;\n+                let def_id = unevaluated.def;\n                 span_bug!(\n                     tcx.def_span(def_id),\n                     \"unable to construct a constant value for the unevaluated constant {:?}\",\n@@ -1547,8 +1547,8 @@ impl<'tcx> InferCtxt<'tcx> {\n                     substs = replace_param_and_infer_substs_with_placeholder(tcx, substs);\n                 }\n             } else {\n-                substs = InternalSubsts::identity_for_item(tcx, unevaluated.def.did);\n-                param_env = tcx.param_env(unevaluated.def.did);\n+                substs = InternalSubsts::identity_for_item(tcx, unevaluated.def);\n+                param_env = tcx.param_env(unevaluated.def);\n             }\n         }\n "}, {"sha": "5fe9d3446540b51681c1e074be3d22c9af686617", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -795,8 +795,7 @@ fn analysis(tcx: TyCtxt<'_>, (): ()) -> Result<()> {\n             tcx.ensure().has_ffi_unwind_calls(def_id);\n \n             if tcx.hir().body_const_context(def_id).is_some() {\n-                tcx.ensure()\n-                    .mir_drops_elaborated_and_const_checked(ty::WithOptConstParam::unknown(def_id));\n+                tcx.ensure().mir_drops_elaborated_and_const_checked(def_id);\n             }\n         }\n     });"}, {"sha": "731ba4e4631eb28ce3b10c89b4223d8a51f5cb6d", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -1539,8 +1539,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             record!(self.tables.promoted_mir[def_id.to_def_id()] <- tcx.promoted_mir(def_id));\n \n-            let instance =\n-                ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id.to_def_id()));\n+            let instance = ty::InstanceDef::Item(def_id.to_def_id());\n             let unused = tcx.unused_generic_params(instance);\n             self.tables.unused_generic_params.set(def_id.local_def_index, unused);\n         }"}, {"sha": "2de73db3a3cfb62bee8d0e8e7368227c36b45089", "filename": "compiler/rustc_middle/src/mir/graphviz.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraphviz.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -16,19 +16,16 @@ where\n {\n     let def_ids = dump_mir_def_ids(tcx, single);\n \n-    let mirs =\n-        def_ids\n-            .iter()\n-            .flat_map(|def_id| {\n-                if tcx.is_const_fn_raw(*def_id) {\n-                    vec![tcx.optimized_mir(*def_id), tcx.mir_for_ctfe(*def_id)]\n-                } else {\n-                    vec![tcx.instance_mir(ty::InstanceDef::Item(ty::WithOptConstParam::unknown(\n-                        *def_id,\n-                    )))]\n-                }\n-            })\n-            .collect::<Vec<_>>();\n+    let mirs = def_ids\n+        .iter()\n+        .flat_map(|def_id| {\n+            if tcx.is_const_fn_raw(*def_id) {\n+                vec![tcx.optimized_mir(*def_id), tcx.mir_for_ctfe(*def_id)]\n+            } else {\n+                vec![tcx.instance_mir(ty::InstanceDef::Item(*def_id))]\n+            }\n+        })\n+        .collect::<Vec<_>>();\n \n     let use_subgraphs = mirs.len() > 1;\n     if use_subgraphs {"}, {"sha": "ed4ee93e97d50579bceba45e99885082d90af048", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         span: Option<Span>,\n     ) -> EvalToConstValueResult<'tcx> {\n         // Cannot resolve `Unevaluated` constants that contain inference\n-        // variables. We reject those here since `resolve_opt_const_arg`\n+        // variables. We reject those here since `resolve`\n         // would fail otherwise.\n         //\n         // When trying to evaluate constants containing inference variables,\n@@ -51,7 +51,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             bug!(\"did not expect inference variables here\");\n         }\n \n-        match ty::Instance::resolve_opt_const_arg(\n+        match ty::Instance::resolve(\n             self, param_env,\n             // FIXME: maybe have a separate version for resolving mir::UnevaluatedConst?\n             ct.def, ct.substs,\n@@ -73,7 +73,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         span: Option<Span>,\n     ) -> EvalToValTreeResult<'tcx> {\n         // Cannot resolve `Unevaluated` constants that contain inference\n-        // variables. We reject those here since `resolve_opt_const_arg`\n+        // variables. We reject those here since `resolve`\n         // would fail otherwise.\n         //\n         // When trying to evaluate constants containing inference variables,\n@@ -82,7 +82,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             bug!(\"did not expect inference variables here\");\n         }\n \n-        match ty::Instance::resolve_opt_const_arg(self, param_env, ct.def, ct.substs) {\n+        match ty::Instance::resolve(self, param_env, ct.def, ct.substs) {\n             Ok(Some(instance)) => {\n                 let cid = GlobalId { instance, promoted: None };\n                 self.const_eval_global_id_for_typeck(param_env, cid, span).inspect(|_| {\n@@ -94,14 +94,14 @@ impl<'tcx> TyCtxt<'tcx> {\n                     // used generic parameters is a bug of evaluation, so checking for it\n                     // here does feel somewhat sensible.\n                     if !self.features().generic_const_exprs && ct.substs.has_non_region_param() {\n-                        assert!(matches!(self.def_kind(ct.def.did), DefKind::AnonConst));\n-                        let mir_body = self.mir_for_ctfe_opt_const_arg(ct.def);\n+                        assert!(matches!(self.def_kind(ct.def), DefKind::AnonConst));\n+                        let mir_body = self.mir_for_ctfe(ct.def);\n                         if mir_body.is_polymorphic {\n-                            let Some(local_def_id) = ct.def.did.as_local() else { return };\n+                            let Some(local_def_id) = ct.def.as_local() else { return };\n                             self.struct_span_lint_hir(\n                                 lint::builtin::CONST_EVALUATABLE_UNCHECKED,\n                                 self.hir().local_def_id_to_hir_id(local_def_id),\n-                                self.def_span(ct.def.did),\n+                                self.def_span(ct.def),\n                                 \"cannot use constants which depend on generic parameters in types\",\n                                 |err| err,\n                             )"}, {"sha": "9becc04e5d1cfc2f872a394e53e053892f1b5ef7", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 19, "deletions": 43, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -191,20 +191,13 @@ pub struct MirSource<'tcx> {\n \n impl<'tcx> MirSource<'tcx> {\n     pub fn item(def_id: DefId) -> Self {\n-        MirSource {\n-            instance: InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n-            promoted: None,\n-        }\n+        MirSource { instance: InstanceDef::Item(def_id), promoted: None }\n     }\n \n     pub fn from_instance(instance: InstanceDef<'tcx>) -> Self {\n         MirSource { instance, promoted: None }\n     }\n \n-    pub fn with_opt_param(self) -> ty::WithOptConstParam<DefId> {\n-        self.instance.with_opt_param()\n-    }\n-\n     #[inline]\n     pub fn def_id(&self) -> DefId {\n         self.instance.def_id()\n@@ -2436,16 +2429,6 @@ impl<'tcx> ConstantKind<'tcx> {\n         Self::Val(val, ty)\n     }\n \n-    /// Literals are converted to `ConstantKindVal`, const generic parameters are eagerly\n-    /// converted to a constant, everything else becomes `Unevaluated`.\n-    pub fn from_anon_const(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: LocalDefId,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> Self {\n-        Self::from_opt_const_arg_anon_const(tcx, ty::WithOptConstParam::unknown(def_id), param_env)\n-    }\n-\n     #[instrument(skip(tcx), level = \"debug\", ret)]\n     pub fn from_inline_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n@@ -2485,28 +2468,25 @@ impl<'tcx> ConstantKind<'tcx> {\n             ty::InlineConstSubsts::new(tcx, ty::InlineConstSubstsParts { parent_substs, ty })\n                 .substs;\n \n-        let uneval = UnevaluatedConst {\n-            def: ty::WithOptConstParam::unknown(def_id).to_global(),\n-            substs,\n-            promoted: None,\n-        };\n+        let uneval = UnevaluatedConst { def: def_id.to_def_id(), substs, promoted: None };\n         debug_assert!(!uneval.has_free_regions());\n \n         Self::Unevaluated(uneval, ty)\n     }\n \n+    /// Literals are converted to `ConstantKindVal`, const generic parameters are eagerly\n+    /// converted to a constant, everything else becomes `Unevaluated`.\n     #[instrument(skip(tcx), level = \"debug\", ret)]\n-    fn from_opt_const_arg_anon_const(\n+    pub fn from_anon_const(\n         tcx: TyCtxt<'tcx>,\n-        def: ty::WithOptConstParam<LocalDefId>,\n+        def: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n-        let body_id = match tcx.hir().get_by_def_id(def.did) {\n+        let body_id = match tcx.hir().get_by_def_id(def) {\n             hir::Node::AnonConst(ac) => ac.body,\n-            _ => span_bug!(\n-                tcx.def_span(def.did.to_def_id()),\n-                \"from_anon_const can only process anonymous constants\"\n-            ),\n+            _ => {\n+                span_bug!(tcx.def_span(def), \"from_anon_const can only process anonymous constants\")\n+            }\n         };\n \n         let expr = &tcx.hir().body(body_id).value;\n@@ -2522,7 +2502,7 @@ impl<'tcx> ConstantKind<'tcx> {\n         };\n         debug!(\"expr.kind: {:?}\", expr.kind);\n \n-        let ty = tcx.type_of(def.def_id_for_type_of()).subst_identity();\n+        let ty = tcx.type_of(def).subst_identity();\n         debug!(?ty);\n \n         // FIXME(const_generics): We currently have to special case parameters because `min_const_generics`\n@@ -2549,7 +2529,7 @@ impl<'tcx> ConstantKind<'tcx> {\n             _ => {}\n         }\n \n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def);\n         let parent_substs = if let Some(parent_hir_id) = tcx.hir().opt_parent_id(hir_id)\n             && let Some(parent_did) = parent_hir_id.as_owner()\n         {\n@@ -2559,15 +2539,14 @@ impl<'tcx> ConstantKind<'tcx> {\n         };\n         debug!(?parent_substs);\n \n-        let did = def.did.to_def_id();\n+        let did = def.to_def_id();\n         let child_substs = InternalSubsts::identity_for_item(tcx, did);\n         let substs =\n             tcx.mk_substs_from_iter(parent_substs.into_iter().chain(child_substs.into_iter()));\n         debug!(?substs);\n \n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n-        let span = tcx.hir().span(hir_id);\n-        let uneval = UnevaluatedConst::new(def.to_global(), substs);\n+        let span = tcx.def_span(def);\n+        let uneval = UnevaluatedConst::new(did, substs);\n         debug!(?span, ?param_env);\n \n         match tcx.const_eval_resolve(param_env, uneval, Some(span)) {\n@@ -2581,8 +2560,8 @@ impl<'tcx> ConstantKind<'tcx> {\n                 // new unevaluated const and error hard later in codegen\n                 Self::Unevaluated(\n                     UnevaluatedConst {\n-                        def: def.to_global(),\n-                        substs: InternalSubsts::identity_for_item(tcx, def.did),\n+                        def: did,\n+                        substs: InternalSubsts::identity_for_item(tcx, did),\n                         promoted: None,\n                     },\n                     ty,\n@@ -2607,7 +2586,7 @@ impl<'tcx> ConstantKind<'tcx> {\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Lift)]\n #[derive(Hash, HashStable, TypeFoldable, TypeVisitable)]\n pub struct UnevaluatedConst<'tcx> {\n-    pub def: ty::WithOptConstParam<DefId>,\n+    pub def: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub promoted: Option<Promoted>,\n }\n@@ -2623,10 +2602,7 @@ impl<'tcx> UnevaluatedConst<'tcx> {\n \n impl<'tcx> UnevaluatedConst<'tcx> {\n     #[inline]\n-    pub fn new(\n-        def: ty::WithOptConstParam<DefId>,\n-        substs: SubstsRef<'tcx>,\n-    ) -> UnevaluatedConst<'tcx> {\n+    pub fn new(def: DefId, substs: SubstsRef<'tcx>) -> UnevaluatedConst<'tcx> {\n         UnevaluatedConst { def, substs, promoted: Default::default() }\n     }\n }"}, {"sha": "67235f0f524508f8c22d30366de79b6ca060265f", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -373,7 +373,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             // instances into account. The others don't matter for\n                             // the codegen tests and can even make item order\n                             // unstable.\n-                            InstanceDef::Item(def) => def.did.as_local().map(Idx::index),\n+                            InstanceDef::Item(def) => def.as_local().map(Idx::index),\n                             InstanceDef::VTableShim(..)\n                             | InstanceDef::ReifyShim(..)\n                             | InstanceDef::Intrinsic(..)"}, {"sha": "89510bbb3aa15e6e94218f474a71ff828ebb0b54", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -298,8 +298,7 @@ pub fn write_mir_pretty<'tcx>(\n             // are shared between mir_for_ctfe and optimized_mir\n             write_mir_fn(tcx, tcx.mir_for_ctfe(def_id), &mut |_, _| Ok(()), w)?;\n         } else {\n-            let instance_mir =\n-                tcx.instance_mir(ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)));\n+            let instance_mir = tcx.instance_mir(ty::InstanceDef::Item(def_id));\n             render_body(w, instance_mir)?;\n         }\n     }\n@@ -464,11 +463,7 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n                 ConstantKind::Ty(ct) => match ct.kind() {\n                     ty::ConstKind::Param(p) => format!(\"Param({})\", p),\n                     ty::ConstKind::Unevaluated(uv) => {\n-                        format!(\n-                            \"Unevaluated({}, {:?})\",\n-                            self.tcx.def_path_str(uv.def.did),\n-                            uv.substs,\n-                        )\n+                        format!(\"Unevaluated({}, {:?})\", self.tcx.def_path_str(uv.def), uv.substs,)\n                     }\n                     ty::ConstKind::Value(val) => format!(\"Value({})\", fmt_valtree(&val)),\n                     ty::ConstKind::Error(_) => \"Error\".to_string(),\n@@ -481,7 +476,7 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n                 ConstantKind::Unevaluated(uv, _) => {\n                     format!(\n                         \"Unevaluated({}, {:?}, {:?})\",\n-                        self.tcx.def_path_str(uv.def.did),\n+                        self.tcx.def_path_str(uv.def),\n                         uv.substs,\n                         uv.promoted,\n                     )"}, {"sha": "17eaf3e08d81c3e19456c6e97d9ddbcd72ed39fb", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -1,12 +1,12 @@\n //! Values computed by queries that use MIR.\n \n-use crate::mir::{Body, ConstantKind, Promoted};\n+use crate::mir::ConstantKind;\n use crate::ty::{self, OpaqueHiddenType, Ty, TyCtxt};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::unord::UnordSet;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::Span;\n@@ -454,42 +454,3 @@ pub struct CoverageInfo {\n     /// The total number of coverage region counter expressions added to the MIR `Body`.\n     pub num_expressions: u32,\n }\n-\n-/// Shims which make dealing with `WithOptConstParam` easier.\n-///\n-/// For more information on why this is needed, consider looking\n-/// at the docs for `WithOptConstParam` itself.\n-impl<'tcx> TyCtxt<'tcx> {\n-    #[inline]\n-    pub fn mir_const_qualif_opt_const_arg(\n-        self,\n-        def: ty::WithOptConstParam<LocalDefId>,\n-    ) -> ConstQualifs {\n-        if let Some(param_did) = def.const_param_did {\n-            self.mir_const_qualif_const_arg((def.did, param_did))\n-        } else {\n-            self.mir_const_qualif(def.did)\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn promoted_mir_opt_const_arg(\n-        self,\n-        def: ty::WithOptConstParam<DefId>,\n-    ) -> &'tcx IndexVec<Promoted, Body<'tcx>> {\n-        if let Some((did, param_did)) = def.as_const_arg() {\n-            self.promoted_mir_of_const_arg((did, param_did))\n-        } else {\n-            self.promoted_mir(def.did)\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn mir_for_ctfe_opt_const_arg(self, def: ty::WithOptConstParam<DefId>) -> &'tcx Body<'tcx> {\n-        if let Some((did, param_did)) = def.as_const_arg() {\n-            self.mir_for_ctfe_of_const_arg((did, param_did))\n-        } else {\n-            self.mir_for_ctfe(def.did)\n-        }\n-    }\n-}"}, {"sha": "fa62b7f32b1a8bac2621daa38ad11f5c62efc8ca", "filename": "compiler/rustc_middle/src/query/keys.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -174,14 +174,6 @@ impl AsLocalKey for DefId {\n     }\n }\n \n-impl Key for ty::WithOptConstParam<LocalDefId> {\n-    type CacheSelector = DefaultCacheSelector<Self>;\n-\n-    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n-        self.did.default_span(tcx)\n-    }\n-}\n-\n impl Key for SimplifiedType {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n@@ -313,7 +305,7 @@ impl<'tcx> Key for (ty::UnevaluatedConst<'tcx>, ty::UnevaluatedConst<'tcx>) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n-        (self.0).def.did.default_span(tcx)\n+        (self.0).def.default_span(tcx)\n     }\n }\n "}, {"sha": "e98731b89cb5bd85074566c36a33143518ef9130", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 17, "deletions": 98, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -369,26 +369,24 @@ rustc_queries! {\n     }\n \n     /// Fetch the THIR for a given body. If typeck for that body failed, returns an empty `Thir`.\n-    query thir_body(key: ty::WithOptConstParam<LocalDefId>)\n-        -> Result<(&'tcx Steal<thir::Thir<'tcx>>, thir::ExprId), ErrorGuaranteed>\n-    {\n+    query thir_body(key: LocalDefId) -> Result<(&'tcx Steal<thir::Thir<'tcx>>, thir::ExprId), ErrorGuaranteed> {\n         // Perf tests revealed that hashing THIR is inefficient (see #85729).\n         no_hash\n-        desc { |tcx| \"building THIR for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n+        desc { |tcx| \"building THIR for `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Create a THIR tree for debugging.\n-    query thir_tree(key: ty::WithOptConstParam<LocalDefId>) -> &'tcx String {\n+    query thir_tree(key: LocalDefId) -> &'tcx String {\n         no_hash\n         arena_cache\n-        desc { |tcx| \"constructing THIR tree for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n+        desc { |tcx| \"constructing THIR tree for `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Create a list-like THIR representation for debugging.\n-    query thir_flat(key: ty::WithOptConstParam<LocalDefId>) -> &'tcx String {\n+    query thir_flat(key: LocalDefId) -> &'tcx String {\n         no_hash\n         arena_cache\n-        desc { |tcx| \"constructing flat THIR representation for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n+        desc { |tcx| \"constructing flat THIR representation for `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Set of all the `DefId`s in this crate that have MIR associated with\n@@ -407,31 +405,19 @@ rustc_queries! {\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n-    query mir_const_qualif_const_arg(\n-        key: (LocalDefId, DefId)\n-    ) -> mir::ConstQualifs {\n-        desc {\n-            |tcx| \"const checking the const argument `{}`\",\n-            tcx.def_path_str(key.0.to_def_id())\n-        }\n-    }\n \n     /// Fetch the MIR for a given `DefId` right after it's built - this includes\n     /// unreachable code.\n-    query mir_built(key: ty::WithOptConstParam<LocalDefId>) -> &'tcx Steal<mir::Body<'tcx>> {\n-        desc { |tcx| \"building MIR for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n+    query mir_built(key: LocalDefId) -> &'tcx Steal<mir::Body<'tcx>> {\n+        desc { |tcx| \"building MIR for `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Fetch the MIR for a given `DefId` up till the point where it is\n     /// ready for const qualification.\n     ///\n     /// See the README for the `mir` module for details.\n-    query mir_const(key: ty::WithOptConstParam<LocalDefId>) -> &'tcx Steal<mir::Body<'tcx>> {\n-        desc {\n-            |tcx| \"preparing {}`{}` for borrow checking\",\n-            if key.const_param_did.is_some() { \"the const argument \" } else { \"\" },\n-            tcx.def_path_str(key.did.to_def_id()),\n-        }\n+    query mir_const(key: LocalDefId) -> &'tcx Steal<mir::Body<'tcx>> {\n+        desc { |tcx| \"preparing `{}` for borrow checking\", tcx.def_path_str(key.to_def_id()) }\n         no_hash\n     }\n \n@@ -444,22 +430,10 @@ rustc_queries! {\n         }\n         separate_provide_extern\n     }\n-    /// Try to build an abstract representation of the given constant.\n-    query thir_abstract_const_of_const_arg(\n-        key: (LocalDefId, DefId)\n-    ) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n-        desc {\n-            |tcx|\n-            \"building an abstract representation for the const argument `{}`\",\n-            tcx.def_path_str(key.0.to_def_id()),\n-        }\n-    }\n \n-    query mir_drops_elaborated_and_const_checked(\n-        key: ty::WithOptConstParam<LocalDefId>\n-    ) -> &'tcx Steal<mir::Body<'tcx>> {\n+    query mir_drops_elaborated_and_const_checked(key: LocalDefId) -> &'tcx Steal<mir::Body<'tcx>> {\n         no_hash\n-        desc { |tcx| \"elaborating drops for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n+        desc { |tcx| \"elaborating drops for `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     query mir_for_ctfe(\n@@ -470,24 +444,12 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query mir_for_ctfe_of_const_arg(key: (LocalDefId, DefId)) -> &'tcx mir::Body<'tcx> {\n-        desc {\n-            |tcx| \"caching MIR for CTFE of the const argument `{}`\",\n-            tcx.def_path_str(key.0.to_def_id())\n-        }\n-    }\n-\n-    query mir_promoted(key: ty::WithOptConstParam<LocalDefId>) ->\n-        (\n-            &'tcx Steal<mir::Body<'tcx>>,\n-            &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n-        ) {\n+    query mir_promoted(key: LocalDefId) -> (\n+        &'tcx Steal<mir::Body<'tcx>>,\n+        &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n+    ) {\n         no_hash\n-        desc {\n-            |tcx| \"processing MIR for {}`{}`\",\n-            if key.const_param_did.is_some() { \"the const argument \" } else { \"\" },\n-            tcx.def_path_str(key.did.to_def_id()),\n-        }\n+        desc { |tcx| \"processing MIR for `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     query closure_typeinfo(key: LocalDefId) -> ty::ClosureTypeInfo<'tcx> {\n@@ -544,14 +506,6 @@ rustc_queries! {\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n-    query promoted_mir_of_const_arg(\n-        key: (LocalDefId, DefId)\n-    ) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> {\n-        desc {\n-            |tcx| \"optimizing promoted MIR for the const argument `{}`\",\n-            tcx.def_path_str(key.0.to_def_id()),\n-        }\n-    }\n \n     /// Erases regions from `ty` to yield a new type.\n     /// Normally you would just use `tcx.erase_regions(value)`,\n@@ -840,25 +794,13 @@ rustc_queries! {\n         desc { |tcx| \"unsafety-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }\n-    query unsafety_check_result_for_const_arg(key: (LocalDefId, DefId)) -> &'tcx mir::UnsafetyCheckResult {\n-        desc {\n-            |tcx| \"unsafety-checking the const argument `{}`\",\n-            tcx.def_path_str(key.0.to_def_id())\n-        }\n-    }\n \n     /// Unsafety-check this `LocalDefId` with THIR unsafeck. This should be\n     /// used with `-Zthir-unsafeck`.\n     query thir_check_unsafety(key: LocalDefId) {\n         desc { |tcx| \"unsafety-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }\n-    query thir_check_unsafety_for_const_arg(key: (LocalDefId, DefId)) {\n-        desc {\n-            |tcx| \"unsafety-checking the const argument `{}`\",\n-            tcx.def_path_str(key.0.to_def_id())\n-        }\n-    }\n \n     /// Returns the types assumed to be well formed while \"inside\" of the given item.\n     ///\n@@ -960,14 +902,6 @@ rustc_queries! {\n         desc { |tcx| \"type-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }\n-    query typeck_const_arg(\n-        key: (LocalDefId, DefId)\n-    ) -> &'tcx ty::TypeckResults<'tcx> {\n-        desc {\n-            |tcx| \"type-checking the const argument `{}`\",\n-            tcx.def_path_str(key.0.to_def_id()),\n-        }\n-    }\n     query diagnostic_only_typeck(key: LocalDefId) -> &'tcx ty::TypeckResults<'tcx> {\n         desc { |tcx| \"type-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n@@ -992,12 +926,6 @@ rustc_queries! {\n         desc { |tcx| \"borrow-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if(tcx) { tcx.is_typeck_child(key.to_def_id()) }\n     }\n-    query mir_borrowck_const_arg(key: (LocalDefId, DefId)) -> &'tcx mir::BorrowCheckResult<'tcx> {\n-        desc {\n-            |tcx| \"borrow-checking the const argument`{}`\",\n-            tcx.def_path_str(key.0.to_def_id())\n-        }\n-    }\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n@@ -2117,15 +2045,6 @@ rustc_queries! {\n         desc { \"resolving instance `{}`\", ty::Instance::new(key.value.0, key.value.1) }\n     }\n \n-    query resolve_instance_of_const_arg(\n-        key: ty::ParamEnvAnd<'tcx, (LocalDefId, DefId, SubstsRef<'tcx>)>\n-    ) -> Result<Option<ty::Instance<'tcx>>, ErrorGuaranteed> {\n-        desc {\n-            \"resolving instance of the const argument `{}`\",\n-            ty::Instance::new(key.value.0.to_def_id(), key.value.2),\n-        }\n-    }\n-\n     query reveal_opaque_types_in_bounds(key: &'tcx ty::List<ty::Predicate<'tcx>>) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n         desc { \"revealing opaque types in `{:?}`\", key }\n     }"}, {"sha": "b49125f4e5f3df55dd5bb7f46912c1a1eb7be592", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -929,8 +929,8 @@ mod size_asserts {\n     static_assert_size!(Block, 56);\n     static_assert_size!(Expr<'_>, 64);\n     static_assert_size!(ExprKind<'_>, 40);\n-    static_assert_size!(Pat<'_>, 72);\n-    static_assert_size!(PatKind<'_>, 56);\n+    static_assert_size!(Pat<'_>, 64);\n+    static_assert_size!(PatKind<'_>, 48);\n     static_assert_size!(Stmt<'_>, 56);\n     static_assert_size!(StmtKind<'_>, 48);\n     // tidy-alphabetical-end"}, {"sha": "029cf793ad8cc4b52030fa59f86e0c1304762a5e", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -36,15 +36,8 @@ pub type BoundAbstractConst<'tcx> = Result<Option<EarlyBinder<ty::Const<'tcx>>>,\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns a const without substs applied\n-    pub fn bound_abstract_const(\n-        self,\n-        uv: ty::WithOptConstParam<DefId>,\n-    ) -> BoundAbstractConst<'tcx> {\n-        let ac = if let Some((did, param_did)) = uv.as_const_arg() {\n-            self.thir_abstract_const_of_const_arg((did, param_did))\n-        } else {\n-            self.thir_abstract_const(uv.did)\n-        };\n+    pub fn bound_abstract_const(self, uv: DefId) -> BoundAbstractConst<'tcx> {\n+        let ac = self.thir_abstract_const(uv);\n         Ok(ac?.map(|ac| EarlyBinder(ac)))\n     }\n "}, {"sha": "0a191ff7626b7aa5406a3dbf1b94c7ceeab924b6", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -53,37 +53,27 @@ impl<'tcx> Const<'tcx> {\n \n     /// Literals and const generic parameters are eagerly converted to a constant, everything else\n     /// becomes `Unevaluated`.\n-    pub fn from_anon_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n-        Self::from_opt_const_arg_anon_const(tcx, ty::WithOptConstParam::unknown(def_id))\n-    }\n-\n     #[instrument(skip(tcx), level = \"debug\")]\n-    pub fn from_opt_const_arg_anon_const(\n-        tcx: TyCtxt<'tcx>,\n-        def: ty::WithOptConstParam<LocalDefId>,\n-    ) -> Self {\n-        let body_id = match tcx.hir().get_by_def_id(def.did) {\n+    pub fn from_anon_const(tcx: TyCtxt<'tcx>, def: LocalDefId) -> Self {\n+        let body_id = match tcx.hir().get_by_def_id(def) {\n             hir::Node::AnonConst(ac) => ac.body,\n             _ => span_bug!(\n-                tcx.def_span(def.did.to_def_id()),\n+                tcx.def_span(def.to_def_id()),\n                 \"from_anon_const can only process anonymous constants\"\n             ),\n         };\n \n         let expr = &tcx.hir().body(body_id).value;\n         debug!(?expr);\n \n-        let ty = tcx\n-            .type_of(def.def_id_for_type_of())\n-            .no_bound_vars()\n-            .expect(\"const parameter types cannot be generic\");\n+        let ty = tcx.type_of(def).no_bound_vars().expect(\"const parameter types cannot be generic\");\n \n         match Self::try_eval_lit_or_param(tcx, ty, expr) {\n             Some(v) => v,\n             None => tcx.mk_const(\n                 ty::UnevaluatedConst {\n-                    def: def.to_global(),\n-                    substs: InternalSubsts::identity_for_item(tcx, def.did),\n+                    def: def.to_def_id(),\n+                    substs: InternalSubsts::identity_for_item(tcx, def.to_def_id()),\n                 },\n                 ty,\n             ),"}, {"sha": "1ac2cd13982b9adba92f52d36c1442319380623a", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -17,7 +17,7 @@ use super::ScalarInt;\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Lift)]\n #[derive(Hash, HashStable, TypeFoldable, TypeVisitable)]\n pub struct UnevaluatedConst<'tcx> {\n-    pub def: ty::WithOptConstParam<DefId>,\n+    pub def: DefId,\n     pub substs: SubstsRef<'tcx>,\n }\n \n@@ -36,10 +36,7 @@ impl<'tcx> UnevaluatedConst<'tcx> {\n \n impl<'tcx> UnevaluatedConst<'tcx> {\n     #[inline]\n-    pub fn new(\n-        def: ty::WithOptConstParam<DefId>,\n-        substs: SubstsRef<'tcx>,\n-    ) -> UnevaluatedConst<'tcx> {\n+    pub fn new(def: DefId, substs: SubstsRef<'tcx>) -> UnevaluatedConst<'tcx> {\n         UnevaluatedConst { def, substs }\n     }\n }\n@@ -224,9 +221,9 @@ impl<'tcx> ConstKind<'tcx> {\n             // FIXME(eddyb, skinny121) pass `InferCtxt` into here when it's available, so that\n             // we can call `infcx.const_eval_resolve` which handles inference variables.\n             let param_env_and = if (param_env, unevaluated).has_non_region_infer() {\n-                tcx.param_env(unevaluated.def.did).and(ty::UnevaluatedConst {\n+                tcx.param_env(unevaluated.def).and(ty::UnevaluatedConst {\n                     def: unevaluated.def,\n-                    substs: InternalSubsts::identity_for_item(tcx, unevaluated.def.did),\n+                    substs: InternalSubsts::identity_for_item(tcx, unevaluated.def),\n                 })\n             } else {\n                 tcx.erase_regions(param_env)"}, {"sha": "af3a54148e114811f973c0cd1d95f1a3ff838b30", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -13,7 +13,7 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_bound_vars;\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstAllocation};\n-use crate::mir::{Body, BorrowCheckResult, Local, Place, PlaceElem, ProjectionKind, Promoted};\n+use crate::mir::{Body, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::query::LocalCrate;\n use crate::thir::Thir;\n use crate::traits;\n@@ -24,7 +24,7 @@ use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstData, FloatTy, FloatVar, FloatVid,\n     GenericParamDefKind, ImplPolarity, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n     PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, Region, RegionKind, ReprOptions,\n-    TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, TypeckResults, UintTy, Visibility,\n+    TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, UintTy, Visibility,\n };\n use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n use rustc_ast::{self as ast, attr};\n@@ -591,28 +591,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn typeck_opt_const_arg(\n-        self,\n-        def: ty::WithOptConstParam<LocalDefId>,\n-    ) -> &'tcx TypeckResults<'tcx> {\n-        if let Some(param_did) = def.const_param_did {\n-            self.typeck_const_arg((def.did, param_did))\n-        } else {\n-            self.typeck(def.did)\n-        }\n-    }\n-\n-    pub fn mir_borrowck_opt_const_arg(\n-        self,\n-        def: ty::WithOptConstParam<LocalDefId>,\n-    ) -> &'tcx BorrowCheckResult<'tcx> {\n-        if let Some(param_did) = def.const_param_did {\n-            self.mir_borrowck_const_arg((def.did, param_did))\n-        } else {\n-            self.mir_borrowck(def.did)\n-        }\n-    }\n-\n     pub fn alloc_steal_thir(self, thir: Thir<'tcx>) -> &'tcx Steal<Thir<'tcx>> {\n         self.arena.alloc(Steal::new(thir))\n     }"}, {"sha": "cc86cba6fda72bc0f3c56d75d0571c6caea07262", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 28, "deletions": 74, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -34,7 +34,7 @@ pub enum InstanceDef<'tcx> {\n     /// - `fn` items\n     /// - closures\n     /// - generators\n-    Item(ty::WithOptConstParam<DefId>),\n+    Item(DefId),\n \n     /// An intrinsic `fn` item (with `\"rust-intrinsic\"` or `\"platform-intrinsic\"` ABI).\n     ///\n@@ -143,7 +143,7 @@ impl<'tcx> Instance<'tcx> {\n \n         match self.def {\n             InstanceDef::Item(def) => tcx\n-                .upstream_monomorphizations_for(def.did)\n+                .upstream_monomorphizations_for(def)\n                 .and_then(|monos| monos.get(&self.substs).cloned()),\n             InstanceDef::DropGlue(_, Some(_)) => tcx.upstream_drop_glue_for(self.substs),\n             _ => None,\n@@ -155,8 +155,8 @@ impl<'tcx> InstanceDef<'tcx> {\n     #[inline]\n     pub fn def_id(self) -> DefId {\n         match self {\n-            InstanceDef::Item(def) => def.did,\n-            InstanceDef::VTableShim(def_id)\n+            InstanceDef::Item(def_id)\n+            | InstanceDef::VTableShim(def_id)\n             | InstanceDef::ReifyShim(def_id)\n             | InstanceDef::FnPtrShim(def_id, _)\n             | InstanceDef::Virtual(def_id, _)\n@@ -172,7 +172,7 @@ impl<'tcx> InstanceDef<'tcx> {\n     /// Returns the `DefId` of instances which might not require codegen locally.\n     pub fn def_id_if_not_guaranteed_local_codegen(self) -> Option<DefId> {\n         match self {\n-            ty::InstanceDef::Item(def) => Some(def.did),\n+            ty::InstanceDef::Item(def) => Some(def),\n             ty::InstanceDef::DropGlue(def_id, Some(_)) | InstanceDef::ThreadLocalShim(def_id) => {\n                 Some(def_id)\n             }\n@@ -188,23 +188,6 @@ impl<'tcx> InstanceDef<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    pub fn with_opt_param(self) -> ty::WithOptConstParam<DefId> {\n-        match self {\n-            InstanceDef::Item(def) => def,\n-            InstanceDef::VTableShim(def_id)\n-            | InstanceDef::ReifyShim(def_id)\n-            | InstanceDef::FnPtrShim(def_id, _)\n-            | InstanceDef::Virtual(def_id, _)\n-            | InstanceDef::Intrinsic(def_id)\n-            | InstanceDef::ClosureOnceShim { call_once: def_id, track_caller: _ }\n-            | InstanceDef::DropGlue(def_id, _)\n-            | InstanceDef::CloneShim(def_id, _)\n-            | InstanceDef::ThreadLocalShim(def_id)\n-            | InstanceDef::FnPtrAddrShim(def_id, _) => ty::WithOptConstParam::unknown(def_id),\n-        }\n-    }\n-\n     #[inline]\n     pub fn get_attrs(\n         &self,\n@@ -222,7 +205,7 @@ impl<'tcx> InstanceDef<'tcx> {\n     pub fn requires_inline(&self, tcx: TyCtxt<'tcx>) -> bool {\n         use rustc_hir::definitions::DefPathData;\n         let def_id = match *self {\n-            ty::InstanceDef::Item(def) => def.did,\n+            ty::InstanceDef::Item(def) => def,\n             ty::InstanceDef::DropGlue(_, Some(_)) => return false,\n             ty::InstanceDef::ThreadLocalShim(_) => return false,\n             _ => return true,\n@@ -273,8 +256,7 @@ impl<'tcx> InstanceDef<'tcx> {\n \n     pub fn requires_caller_location(&self, tcx: TyCtxt<'_>) -> bool {\n         match *self {\n-            InstanceDef::Item(ty::WithOptConstParam { did: def_id, .. })\n-            | InstanceDef::Virtual(def_id, _) => {\n+            InstanceDef::Item(def_id) | InstanceDef::Virtual(def_id, _) => {\n                 tcx.body_codegen_attrs(def_id).flags.contains(CodegenFnAttrFlags::TRACK_CALLER)\n             }\n             InstanceDef::ClosureOnceShim { call_once: _, track_caller } => track_caller,\n@@ -358,7 +340,7 @@ impl<'tcx> Instance<'tcx> {\n             def_id,\n             substs\n         );\n-        Instance { def: InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)), substs }\n+        Instance { def: InstanceDef::Item(def_id), substs }\n     }\n \n     pub fn mono(tcx: TyCtxt<'tcx>, def_id: DefId) -> Instance<'tcx> {\n@@ -403,18 +385,21 @@ impl<'tcx> Instance<'tcx> {\n     /// couldn't complete due to errors elsewhere - this is distinct\n     /// from `Ok(None)` to avoid misleading diagnostics when an error\n     /// has already been/will be emitted, for the original cause\n+    #[instrument(level = \"debug\", skip(tcx))]\n     pub fn resolve(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> Result<Option<Instance<'tcx>>, ErrorGuaranteed> {\n-        Instance::resolve_opt_const_arg(\n-            tcx,\n-            param_env,\n-            ty::WithOptConstParam::unknown(def_id),\n-            substs,\n-        )\n+        // All regions in the result of this query are erased, so it's\n+        // fine to erase all of the input regions.\n+\n+        // HACK(eddyb) erase regions in `substs` first, so that `param_env.and(...)`\n+        // below is more likely to ignore the bounds in scope (e.g. if the only\n+        // generic parameters mentioned by `substs` were lifetime ones).\n+        let substs = tcx.erase_regions(substs);\n+        tcx.resolve_instance(tcx.erase_regions(param_env.and((def_id, substs))))\n     }\n \n     pub fn expect_resolve(\n@@ -432,31 +417,6 @@ impl<'tcx> Instance<'tcx> {\n         }\n     }\n \n-    // This should be kept up to date with `resolve`.\n-    pub fn resolve_opt_const_arg(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        def: ty::WithOptConstParam<DefId>,\n-        substs: SubstsRef<'tcx>,\n-    ) -> Result<Option<Instance<'tcx>>, ErrorGuaranteed> {\n-        // All regions in the result of this query are erased, so it's\n-        // fine to erase all of the input regions.\n-\n-        // HACK(eddyb) erase regions in `substs` first, so that `param_env.and(...)`\n-        // below is more likely to ignore the bounds in scope (e.g. if the only\n-        // generic parameters mentioned by `substs` were lifetime ones).\n-        let substs = tcx.erase_regions(substs);\n-\n-        // FIXME(eddyb) should this always use `param_env.with_reveal_all()`?\n-        if let Some((did, param_did)) = def.as_const_arg() {\n-            tcx.resolve_instance_of_const_arg(\n-                tcx.erase_regions(param_env.and((did, param_did, substs))),\n-            )\n-        } else {\n-            tcx.resolve_instance(tcx.erase_regions(param_env.and((def.did, substs))))\n-        }\n-    }\n-\n     pub fn resolve_for_fn_ptr(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -470,7 +430,7 @@ impl<'tcx> Instance<'tcx> {\n             match resolved.def {\n                 InstanceDef::Item(def) if resolved.def.requires_caller_location(tcx) => {\n                     debug!(\" => fn pointer created for function with #[track_caller]\");\n-                    resolved.def = InstanceDef::ReifyShim(def.did);\n+                    resolved.def = InstanceDef::ReifyShim(def);\n                 }\n                 InstanceDef::Virtual(def_id, _) => {\n                     debug!(\" => fn pointer created for virtual call\");\n@@ -513,33 +473,33 @@ impl<'tcx> Instance<'tcx> {\n                         if resolved.def.requires_caller_location(tcx)\n                             // 2) The caller location parameter comes from having `#[track_caller]`\n                             // on the implementation, and *not* on the trait method.\n-                            && !tcx.should_inherit_track_caller(def.did)\n+                            && !tcx.should_inherit_track_caller(def)\n                             // If the method implementation comes from the trait definition itself\n                             // (e.g. `trait Foo { #[track_caller] my_fn() { /* impl */ } }`),\n                             // then we don't need to generate a shim. This check is needed because\n                             // `should_inherit_track_caller` returns `false` if our method\n                             // implementation comes from the trait block, and not an impl block\n                             && !matches!(\n-                                tcx.opt_associated_item(def.did),\n+                                tcx.opt_associated_item(def),\n                                 Some(ty::AssocItem {\n                                     container: ty::AssocItemContainer::TraitContainer,\n                                     ..\n                                 })\n                             )\n                         {\n-                            if tcx.is_closure(def.did) {\n+                            if tcx.is_closure(def) {\n                                 debug!(\" => vtable fn pointer created for closure with #[track_caller]: {:?} for method {:?} {:?}\",\n-                                       def.did, def_id, substs);\n+                                       def, def_id, substs);\n \n                                 // Create a shim for the `FnOnce/FnMut/Fn` method we are calling\n                                 // - unlike functions, invoking a closure always goes through a\n                                 // trait.\n                                 resolved = Instance { def: InstanceDef::ReifyShim(def_id), substs };\n                             } else {\n                                 debug!(\n-                                    \" => vtable fn pointer created for function with #[track_caller]: {:?}\", def.did\n+                                    \" => vtable fn pointer created for function with #[track_caller]: {:?}\", def\n                                 );\n-                                resolved.def = InstanceDef::ReifyShim(def.did);\n+                                resolved.def = InstanceDef::ReifyShim(def);\n                             }\n                         }\n                     }\n@@ -714,23 +674,17 @@ fn polymorphize<'tcx>(\n             debug!(\"fold_ty: ty={:?}\", ty);\n             match *ty.kind() {\n                 ty::Closure(def_id, substs) => {\n-                    let polymorphized_substs = polymorphize(\n-                        self.tcx,\n-                        ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n-                        substs,\n-                    );\n+                    let polymorphized_substs =\n+                        polymorphize(self.tcx, ty::InstanceDef::Item(def_id), substs);\n                     if substs == polymorphized_substs {\n                         ty\n                     } else {\n                         self.tcx.mk_closure(def_id, polymorphized_substs)\n                     }\n                 }\n                 ty::Generator(def_id, substs, movability) => {\n-                    let polymorphized_substs = polymorphize(\n-                        self.tcx,\n-                        ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)),\n-                        substs,\n-                    );\n+                    let polymorphized_substs =\n+                        polymorphize(self.tcx, ty::InstanceDef::Item(def_id), substs);\n                     if substs == polymorphized_substs {\n                         ty\n                     } else {"}, {"sha": "42b98540ac7db429273c483b87a6890a4788b934", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 130, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -1007,7 +1007,7 @@ impl<'tcx> Term<'tcx> {\n                 _ => None,\n             },\n             TermKind::Const(ct) => match ct.kind() {\n-                ConstKind::Unevaluated(uv) => Some(tcx.mk_alias_ty(uv.def.did, uv.substs)),\n+                ConstKind::Unevaluated(uv) => Some(tcx.mk_alias_ty(uv.def, uv.substs)),\n                 _ => None,\n             },\n         }\n@@ -1471,129 +1471,6 @@ pub struct BoundConst<'tcx> {\n \n pub type PlaceholderConst<'tcx> = Placeholder<BoundVar>;\n \n-/// A `DefId` which, in case it is a const argument, is potentially bundled with\n-/// the `DefId` of the generic parameter it instantiates.\n-///\n-/// This is used to avoid calls to `type_of` for const arguments during typeck\n-/// which cause cycle errors.\n-///\n-/// ```rust\n-/// struct A;\n-/// impl A {\n-///     fn foo<const N: usize>(&self) -> [u8; N] { [0; N] }\n-///     //           ^ const parameter\n-/// }\n-/// struct B;\n-/// impl B {\n-///     fn foo<const M: u8>(&self) -> usize { 42 }\n-///     //           ^ const parameter\n-/// }\n-///\n-/// fn main() {\n-///     let a = A;\n-///     let _b = a.foo::<{ 3 + 7 }>();\n-///     //               ^^^^^^^^^ const argument\n-/// }\n-/// ```\n-///\n-/// Let's look at the call `a.foo::<{ 3 + 7 }>()` here. We do not know\n-/// which `foo` is used until we know the type of `a`.\n-///\n-/// We only know the type of `a` once we are inside of `typeck(main)`.\n-/// We also end up normalizing the type of `_b` during `typeck(main)` which\n-/// requires us to evaluate the const argument.\n-///\n-/// To evaluate that const argument we need to know its type,\n-/// which we would get using `type_of(const_arg)`. This requires us to\n-/// resolve `foo` as it can be either `usize` or `u8` in this example.\n-/// However, resolving `foo` once again requires `typeck(main)` to get the type of `a`,\n-/// which results in a cycle.\n-///\n-/// In short we must not call `type_of(const_arg)` during `typeck(main)`.\n-///\n-/// When first creating the `ty::Const` of the const argument inside of `typeck` we have\n-/// already resolved `foo` so we know which const parameter this argument instantiates.\n-/// This means that we also know the expected result of `type_of(const_arg)` even if we\n-/// aren't allowed to call that query: it is equal to `type_of(const_param)` which is\n-/// trivial to compute.\n-///\n-/// If we now want to use that constant in a place which potentially needs its type\n-/// we also pass the type of its `const_param`. This is the point of `WithOptConstParam`,\n-/// except that instead of a `Ty` we bundle the `DefId` of the const parameter.\n-/// Meaning that we need to use `type_of(const_param_did)` if `const_param_did` is `Some`\n-/// to get the type of `did`.\n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift, TyEncodable, TyDecodable)]\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-#[derive(Hash, HashStable)]\n-pub struct WithOptConstParam<T> {\n-    pub did: T,\n-    /// The `DefId` of the corresponding generic parameter in case `did` is\n-    /// a const argument.\n-    ///\n-    /// Note that even if `did` is a const argument, this may still be `None`.\n-    /// All queries taking `WithOptConstParam` start by calling `tcx.opt_const_param_of(def.did)`\n-    /// to potentially update `param_did` in the case it is `None`.\n-    pub const_param_did: Option<DefId>,\n-}\n-\n-impl<T> WithOptConstParam<T> {\n-    /// Creates a new `WithOptConstParam` setting `const_param_did` to `None`.\n-    #[inline(always)]\n-    pub fn unknown(did: T) -> WithOptConstParam<T> {\n-        WithOptConstParam { did, const_param_did: None }\n-    }\n-}\n-\n-impl WithOptConstParam<LocalDefId> {\n-    /// Returns `Some((did, param_did))` if `def_id` is a const argument,\n-    /// `None` otherwise.\n-    #[inline(always)]\n-    pub fn try_lookup(_: LocalDefId, _: TyCtxt<'_>) -> Option<(LocalDefId, DefId)> {\n-        None\n-    }\n-\n-    /// In case `self` is unknown but `self.did` is a const argument, this returns\n-    /// a `WithOptConstParam` with the correct `const_param_did`.\n-    #[inline(always)]\n-    pub fn try_upgrade(self, _: TyCtxt<'_>) -> Option<WithOptConstParam<LocalDefId>> {\n-        None\n-    }\n-\n-    pub fn to_global(self) -> WithOptConstParam<DefId> {\n-        WithOptConstParam { did: self.did.to_def_id(), const_param_did: self.const_param_did }\n-    }\n-\n-    pub fn def_id_for_type_of(self) -> DefId {\n-        self.did.to_def_id()\n-    }\n-}\n-\n-impl WithOptConstParam<DefId> {\n-    pub fn as_local(self) -> Option<WithOptConstParam<LocalDefId>> {\n-        self.did\n-            .as_local()\n-            .map(|did| WithOptConstParam { did, const_param_did: self.const_param_did })\n-    }\n-\n-    pub fn as_const_arg(self) -> Option<(LocalDefId, DefId)> {\n-        if let Some(param_did) = self.const_param_did {\n-            if let Some(did) = self.did.as_local() {\n-                return Some((did, param_did));\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    pub fn is_local(self) -> bool {\n-        self.did.is_local()\n-    }\n-\n-    pub fn def_id_for_type_of(self) -> DefId {\n-        self.const_param_did.unwrap_or(self.did)\n-    }\n-}\n-\n /// When type checking, we use the `ParamEnv` to track\n /// details about the set of where-clauses that are in scope at this\n /// particular point.\n@@ -2361,21 +2238,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         match instance {\n             ty::InstanceDef::Item(def) => {\n                 debug!(\"calling def_kind on def: {:?}\", def);\n-                let def_kind = self.def_kind(def.did);\n+                let def_kind = self.def_kind(def);\n                 debug!(\"returned from def_kind: {:?}\", def_kind);\n                 match def_kind {\n                     DefKind::Const\n                     | DefKind::Static(..)\n                     | DefKind::AssocConst\n                     | DefKind::Ctor(..)\n                     | DefKind::AnonConst\n-                    | DefKind::InlineConst => self.mir_for_ctfe_opt_const_arg(def),\n+                    | DefKind::InlineConst => self.mir_for_ctfe(def),\n                     // If the caller wants `mir_for_ctfe` of a function they should not be using\n                     // `instance_mir`, so we'll assume const fn also wants the optimized version.\n-                    _ => {\n-                        assert_eq!(def.const_param_did, None);\n-                        self.optimized_mir(def.did)\n-                    }\n+                    _ => self.optimized_mir(def),\n                 }\n             }\n             ty::InstanceDef::VTableShim(..)"}, {"sha": "5315aa155a831e65773d06b00f7a76b713e2a1a6", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -1328,13 +1328,13 @@ pub trait PrettyPrinter<'tcx>:\n \n         match ct.kind() {\n             ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }) => {\n-                match self.tcx().def_kind(def.did) {\n+                match self.tcx().def_kind(def) {\n                     DefKind::Const | DefKind::AssocConst => {\n-                        p!(print_value_path(def.did, substs))\n+                        p!(print_value_path(def, substs))\n                     }\n                     DefKind::AnonConst => {\n                         if def.is_local()\n-                            && let span = self.tcx().def_span(def.did)\n+                            && let span = self.tcx().def_span(def)\n                             && let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span)\n                         {\n                             p!(write(\"{}\", snip))\n@@ -1344,7 +1344,7 @@ pub trait PrettyPrinter<'tcx>:\n                             // cause printing to enter an infinite recursion if the anon const is in the self type i.e.\n                             // `impl<T: Default> Default for [T; 32 - 1 - 1 - 1] {`\n                             // where we would try to print `<[T; /* print `constant#0` again */] as Default>::{constant#0}`\n-                            p!(write(\"{}::{}\", self.tcx().crate_name(def.did.krate), self.tcx().def_path(def.did).to_string_no_crate_verbose()))\n+                            p!(write(\"{}::{}\", self.tcx().crate_name(def.krate), self.tcx().def_path(def).to_string_no_crate_verbose()))\n                         }\n                     }\n                     defkind => bug!(\"`{:?}` has unexpected defkind {:?}\", ct, defkind),"}, {"sha": "fbcfd4337243317679400aea1070f2cb04699e14", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -78,7 +78,7 @@ pub fn as_constant_inner<'tcx>(\n         ExprKind::NamedConst { def_id, substs, ref user_ty } => {\n             let user_ty = user_ty.as_ref().and_then(push_cuta);\n \n-            let uneval = mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+            let uneval = mir::UnevaluatedConst::new(def_id, substs);\n             let literal = ConstantKind::Unevaluated(uneval, ty);\n \n             Constant { user_ty, span, literal }\n@@ -90,7 +90,7 @@ pub fn as_constant_inner<'tcx>(\n             Constant { user_ty: None, span, literal }\n         }\n         ExprKind::ConstBlock { did: def_id, substs } => {\n-            let uneval = mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+            let uneval = mir::UnevaluatedConst::new(def_id, substs);\n             let literal = ConstantKind::Unevaluated(uneval, ty);\n \n             Constant { user_ty: None, span, literal }"}, {"sha": "b05c3056cbaeec22c86992082dc2964df42eb08f", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 27, "deletions": 47, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -32,38 +32,20 @@ use super::lints;\n \n pub(crate) fn mir_built(\n     tcx: TyCtxt<'_>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n+    def: LocalDefId,\n ) -> &rustc_data_structures::steal::Steal<Body<'_>> {\n-    if let Some(def) = def.try_upgrade(tcx) {\n-        return tcx.mir_built(def);\n-    }\n-\n-    let mut body = mir_build(tcx, def);\n-    if def.const_param_did.is_some() {\n-        assert!(matches!(body.source.instance, ty::InstanceDef::Item(_)));\n-        body.source = MirSource::from_instance(ty::InstanceDef::Item(def.to_global()));\n-    }\n-\n-    tcx.alloc_steal_mir(body)\n+    tcx.alloc_steal_mir(mir_build(tcx, def))\n }\n \n /// Construct the MIR for a given `DefId`.\n-fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_> {\n+fn mir_build(tcx: TyCtxt<'_>, def: LocalDefId) -> Body<'_> {\n     // Ensure unsafeck and abstract const building is ran before we steal the THIR.\n-    match def {\n-        ty::WithOptConstParam { did, const_param_did: Some(const_param_did) } => {\n-            tcx.ensure_with_value().thir_check_unsafety_for_const_arg((did, const_param_did));\n-            tcx.ensure_with_value().thir_abstract_const_of_const_arg((did, const_param_did));\n-        }\n-        ty::WithOptConstParam { did, const_param_did: None } => {\n-            tcx.ensure_with_value().thir_check_unsafety(did);\n-            tcx.ensure_with_value().thir_abstract_const(did);\n-            tcx.ensure_with_value().check_match(did);\n-        }\n-    }\n+    tcx.ensure_with_value().thir_check_unsafety(def);\n+    tcx.ensure_with_value().thir_abstract_const(def);\n+    tcx.ensure_with_value().check_match(def);\n \n     let body = match tcx.thir_body(def) {\n-        Err(error_reported) => construct_error(tcx, def.did, error_reported),\n+        Err(error_reported) => construct_error(tcx, def, error_reported),\n         Ok((thir, expr)) => {\n             // We ran all queries that depended on THIR at the beginning\n             // of `mir_build`, so now we can steal it\n@@ -161,8 +143,7 @@ struct Builder<'a, 'tcx> {\n     thir: &'a Thir<'tcx>,\n     cfg: CFG<'tcx>,\n \n-    def: ty::WithOptConstParam<LocalDefId>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     hir_id: hir::HirId,\n     parent_module: DefId,\n     check_overflow: bool,\n@@ -428,26 +409,26 @@ macro_rules! unpack {\n \n fn construct_fn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    fn_def: ty::WithOptConstParam<LocalDefId>,\n+    fn_def: LocalDefId,\n     thir: &Thir<'tcx>,\n     expr: ExprId,\n     fn_sig: ty::FnSig<'tcx>,\n ) -> Body<'tcx> {\n-    let span = tcx.def_span(fn_def.did);\n-    let fn_id = tcx.hir().local_def_id_to_hir_id(fn_def.did);\n-    let generator_kind = tcx.generator_kind(fn_def.did);\n+    let span = tcx.def_span(fn_def);\n+    let fn_id = tcx.hir().local_def_id_to_hir_id(fn_def);\n+    let generator_kind = tcx.generator_kind(fn_def);\n \n     // The representation of thir for `-Zunpretty=thir-tree` relies on\n     // the entry expression being the last element of `thir.exprs`.\n     assert_eq!(expr.as_usize(), thir.exprs.len() - 1);\n \n     // Figure out what primary body this item has.\n-    let body_id = tcx.hir().body_owned_by(fn_def.did);\n+    let body_id = tcx.hir().body_owned_by(fn_def);\n     let span_with_body = tcx.hir().span_with_body(fn_id);\n     let return_ty_span = tcx\n         .hir()\n         .fn_decl_by_hir_id(fn_id)\n-        .unwrap_or_else(|| span_bug!(span, \"can't build MIR for {:?}\", fn_def.did))\n+        .unwrap_or_else(|| span_bug!(span, \"can't build MIR for {:?}\", fn_def))\n         .output\n         .span();\n \n@@ -457,7 +438,7 @@ fn construct_fn<'tcx>(\n     };\n \n     let mut abi = fn_sig.abi;\n-    if let DefKind::Closure = tcx.def_kind(fn_def.did) {\n+    if let DefKind::Closure = tcx.def_kind(fn_def) {\n         // HACK(eddyb) Avoid having RustCall on closures,\n         // as it adds unnecessary (and wrong) auto-tupling.\n         abi = Abi::Rust;\n@@ -483,7 +464,7 @@ fn construct_fn<'tcx>(\n     {\n         return custom::build_custom_mir(\n             tcx,\n-            fn_def.did.to_def_id(),\n+            fn_def.to_def_id(),\n             fn_id,\n             thir,\n             expr,\n@@ -547,12 +528,12 @@ fn construct_fn<'tcx>(\n \n fn construct_const<'a, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n+    def: LocalDefId,\n     thir: &'a Thir<'tcx>,\n     expr: ExprId,\n     const_ty: Ty<'tcx>,\n ) -> Body<'tcx> {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def);\n \n     // Figure out what primary body this item has.\n     let (span, const_ty_span) = match tcx.hir().get(hir_id) {\n@@ -568,10 +549,10 @@ fn construct_const<'a, 'tcx>(\n             ..\n         }) => (*span, ty.span),\n         Node::AnonConst(_) => {\n-            let span = tcx.def_span(def.did);\n+            let span = tcx.def_span(def);\n             (span, span)\n         }\n-        _ => span_bug!(tcx.def_span(def.did), \"can't build MIR for {:?}\", def.did),\n+        _ => span_bug!(tcx.def_span(def), \"can't build MIR for {:?}\", def),\n     };\n \n     let infcx = tcx.infer_ctxt().build();\n@@ -669,7 +650,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn new(\n         thir: &'a Thir<'tcx>,\n         infcx: InferCtxt<'tcx>,\n-        def: ty::WithOptConstParam<LocalDefId>,\n+        def: LocalDefId,\n         hir_id: hir::HirId,\n         span: Span,\n         arg_count: usize,\n@@ -688,20 +669,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         check_overflow |= tcx.sess.overflow_checks();\n         // Constants always need overflow checks.\n         check_overflow |= matches!(\n-            tcx.hir().body_owner_kind(def.did),\n+            tcx.hir().body_owner_kind(def),\n             hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_)\n         );\n \n         let lint_level = LintLevel::Explicit(hir_id);\n-        let param_env = tcx.param_env(def.did);\n+        let param_env = tcx.param_env(def);\n         let mut builder = Builder {\n             thir,\n             tcx,\n             infcx,\n-            region_scope_tree: tcx.region_scope_tree(def.did),\n+            region_scope_tree: tcx.region_scope_tree(def),\n             param_env,\n-            def,\n-            def_id: def.did.to_def_id(),\n+            def_id: def,\n             hir_id,\n             parent_module: tcx.parent_module(hir_id).to_def_id(),\n             check_overflow,\n@@ -741,7 +721,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         Body::new(\n-            MirSource::item(self.def_id),\n+            MirSource::item(self.def_id.to_def_id()),\n             self.cfg.basic_blocks,\n             self.source_scopes,\n             self.local_decls,\n@@ -779,7 +759,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let tcx = self.tcx;\n         self.upvars = tcx\n-            .closure_captures(self.def.did)\n+            .closure_captures(self.def_id)\n             .iter()\n             .zip(capture_tys)\n             .enumerate()"}, {"sha": "bc1a0fac1297eabf624baadadae6829dc5ba0720", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 9, "deletions": 31, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -117,10 +117,10 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n     }\n \n     /// Handle closures/generators/inline-consts, which is unsafecked with their parent body.\n-    fn visit_inner_body(&mut self, def: ty::WithOptConstParam<LocalDefId>) {\n+    fn visit_inner_body(&mut self, def: LocalDefId) {\n         if let Ok((inner_thir, expr)) = self.tcx.thir_body(def) {\n             let inner_thir = &inner_thir.borrow();\n-            let hir_context = self.tcx.hir().local_def_id_to_hir_id(def.did);\n+            let hir_context = self.tcx.hir().local_def_id_to_hir_id(def);\n             let mut inner_visitor = UnsafetyVisitor { thir: inner_thir, hir_context, ..*self };\n             inner_visitor.visit_expr(&inner_thir[expr]);\n             // Unsafe blocks can be used in the inner body, make sure to take it into account\n@@ -396,18 +396,11 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                 movability: _,\n                 fake_reads: _,\n             }) => {\n-                let closure_def = if let Some((did, const_param_id)) =\n-                    ty::WithOptConstParam::try_lookup(closure_id, self.tcx)\n-                {\n-                    ty::WithOptConstParam { did, const_param_did: Some(const_param_id) }\n-                } else {\n-                    ty::WithOptConstParam::unknown(closure_id)\n-                };\n-                self.visit_inner_body(closure_def);\n+                self.visit_inner_body(closure_id);\n             }\n             ExprKind::ConstBlock { did, substs: _ } => {\n                 let def_id = did.expect_local();\n-                self.visit_inner_body(ty::WithOptConstParam::unknown(def_id));\n+                self.visit_inner_body(def_id);\n             }\n             ExprKind::Field { lhs, .. } => {\n                 let lhs = &self.thir[lhs];\n@@ -706,14 +699,14 @@ impl UnsafeOpKind {\n     }\n }\n \n-pub fn check_unsafety(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) {\n+pub fn thir_check_unsafety(tcx: TyCtxt<'_>, def: LocalDefId) {\n     // THIR unsafeck is gated under `-Z thir-unsafeck`\n     if !tcx.sess.opts.unstable_opts.thir_unsafeck {\n         return;\n     }\n \n     // Closures and inline consts are handled by their owner, if it has a body\n-    if tcx.is_typeck_child(def.did.to_def_id()) {\n+    if tcx.is_typeck_child(def.to_def_id()) {\n         return;\n     }\n \n@@ -726,15 +719,15 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) {\n         return;\n     }\n \n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def);\n     let body_unsafety = tcx.hir().fn_sig_by_hir_id(hir_id).map_or(BodyUnsafety::Safe, |fn_sig| {\n         if fn_sig.header.unsafety == hir::Unsafety::Unsafe {\n             BodyUnsafety::Unsafe(fn_sig.span)\n         } else {\n             BodyUnsafety::Safe\n         }\n     });\n-    let body_target_features = &tcx.body_codegen_attrs(def.did.to_def_id()).target_features;\n+    let body_target_features = &tcx.body_codegen_attrs(def.to_def_id()).target_features;\n     let safety_context =\n         if body_unsafety.is_unsafe() { SafetyContext::UnsafeFn } else { SafetyContext::Safe };\n     let mut visitor = UnsafetyVisitor {\n@@ -746,23 +739,8 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) {\n         body_target_features,\n         assignment_info: None,\n         in_union_destructure: false,\n-        param_env: tcx.param_env(def.did),\n+        param_env: tcx.param_env(def),\n         inside_adt: false,\n     };\n     visitor.visit_expr(&thir[expr]);\n }\n-\n-pub(crate) fn thir_check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n-        tcx.thir_check_unsafety_for_const_arg(def)\n-    } else {\n-        check_unsafety(tcx, ty::WithOptConstParam::unknown(def_id))\n-    }\n-}\n-\n-pub(crate) fn thir_check_unsafety_for_const_arg(\n-    tcx: TyCtxt<'_>,\n-    (did, param_did): (LocalDefId, DefId),\n-) {\n-    check_unsafety(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })\n-}"}, {"sha": "2765a107cf075b827827934424b4de2258e92321", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -35,7 +35,6 @@ pub fn provide(providers: &mut Providers) {\n     providers.lit_to_mir_constant = build::lit_to_mir_constant;\n     providers.mir_built = build::mir_built;\n     providers.thir_check_unsafety = check_unsafety::thir_check_unsafety;\n-    providers.thir_check_unsafety_for_const_arg = check_unsafety::thir_check_unsafety_for_const_arg;\n     providers.thir_body = thir::cx::thir_body;\n     providers.thir_tree = thir::print::thir_tree;\n     providers.thir_flat = thir::print::thir_flat;"}, {"sha": "463f639defe9a6614671e1e5a346592eca2841c8", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -20,25 +20,25 @@ use rustc_span::Span;\n \n pub(crate) fn thir_body(\n     tcx: TyCtxt<'_>,\n-    owner_def: ty::WithOptConstParam<LocalDefId>,\n+    owner_def: LocalDefId,\n ) -> Result<(&Steal<Thir<'_>>, ExprId), ErrorGuaranteed> {\n     let hir = tcx.hir();\n-    let body = hir.body(hir.body_owned_by(owner_def.did));\n+    let body = hir.body(hir.body_owned_by(owner_def));\n     let mut cx = Cx::new(tcx, owner_def);\n     if let Some(reported) = cx.typeck_results.tainted_by_errors {\n         return Err(reported);\n     }\n     let expr = cx.mirror_expr(&body.value);\n \n-    let owner_id = hir.local_def_id_to_hir_id(owner_def.did);\n+    let owner_id = hir.local_def_id_to_hir_id(owner_def);\n     if let Some(ref fn_decl) = hir.fn_decl_by_hir_id(owner_id) {\n-        let closure_env_param = cx.closure_env_param(owner_def.did, owner_id);\n+        let closure_env_param = cx.closure_env_param(owner_def, owner_id);\n         let explicit_params = cx.explicit_params(owner_id, fn_decl, body);\n         cx.thir.params = closure_env_param.into_iter().chain(explicit_params).collect();\n \n         // The resume argument may be missing, in that case we need to provide it here.\n         // It will always be `()` in this case.\n-        if tcx.def_kind(owner_def.did) == DefKind::Generator && body.params.is_empty() {\n+        if tcx.def_kind(owner_def) == DefKind::Generator && body.params.is_empty() {\n             cx.thir.params.push(Param {\n                 ty: tcx.mk_unit(),\n                 pat: None,\n@@ -78,13 +78,12 @@ struct Cx<'tcx> {\n }\n \n impl<'tcx> Cx<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalDefId>) -> Cx<'tcx> {\n-        let typeck_results = tcx.typeck_opt_const_arg(def);\n-        let did = def.did;\n+    fn new(tcx: TyCtxt<'tcx>, def: LocalDefId) -> Cx<'tcx> {\n+        let typeck_results = tcx.typeck(def);\n         let hir = tcx.hir();\n-        let hir_id = hir.local_def_id_to_hir_id(did);\n+        let hir_id = hir.local_def_id_to_hir_id(def);\n \n-        let body_type = if hir.body_owner_kind(did).is_fn_or_closure() {\n+        let body_type = if hir.body_owner_kind(def).is_fn_or_closure() {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n             BodyTy::Fn(typeck_results.liberated_fn_sigs()[hir_id])\n@@ -106,11 +105,11 @@ impl<'tcx> Cx<'tcx> {\n         Cx {\n             tcx,\n             thir: Thir::new(body_type),\n-            param_env: tcx.param_env(def.did),\n-            region_scope_tree: tcx.region_scope_tree(def.did),\n+            param_env: tcx.param_env(def),\n+            region_scope_tree: tcx.region_scope_tree(def),\n             typeck_results,\n             rvalue_scopes: &typeck_results.rvalue_scopes,\n-            body_owner: did.to_def_id(),\n+            body_owner: def.to_def_id(),\n             adjustment_span: None,\n             apply_adjustments: hir\n                 .attrs(hir_id)"}, {"sha": "2b52d70af2a44bb2ef676e12a705bf2a473c1772", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -27,7 +27,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::Span;\n \n pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let Ok((thir, expr)) = tcx.thir_body(ty::WithOptConstParam::unknown(def_id)) else { return };\n+    let Ok((thir, expr)) = tcx.thir_body(def_id) else { return };\n     let thir = thir.borrow();\n     let pattern_arena = TypedArena::default();\n     let mut visitor = MatchVisitor {"}, {"sha": "0e4eca6844f2fa9ab709e0f3da372e3ba2c0c3d8", "filename": "compiler/rustc_mir_build/src/thir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fprint.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -3,7 +3,7 @@ use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::def_id::LocalDefId;\n use std::fmt::{self, Write};\n \n-pub(crate) fn thir_tree(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalDefId>) -> String {\n+pub(crate) fn thir_tree(tcx: TyCtxt<'_>, owner_def: LocalDefId) -> String {\n     match super::cx::thir_body(tcx, owner_def) {\n         Ok((thir, _)) => {\n             let thir = thir.steal();\n@@ -15,7 +15,7 @@ pub(crate) fn thir_tree(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalD\n     }\n }\n \n-pub(crate) fn thir_flat(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalDefId>) -> String {\n+pub(crate) fn thir_flat(tcx: TyCtxt<'_>, owner_def: LocalDefId) -> String {\n     match super::cx::thir_body(tcx, owner_def) {\n         Ok((thir, _)) => format!(\"{:#?}\", thir.steal()),\n         Err(_) => \"error\".into(),"}, {"sha": "ce6d865a7dcefb97165ac809cb23ffe83c0b0a19", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -148,7 +148,7 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n \n             if let Some(uv) = maybe_uneval {\n                 if uv.promoted.is_none() {\n-                    let def_id = uv.def.def_id_for_type_of();\n+                    let def_id = uv.def;\n                     if self.tcx.def_kind(def_id) == DefKind::InlineConst {\n                         let local_def_id = def_id.expect_local();\n                         let UnsafetyCheckResult { violations, used_unsafe_blocks, .. } =\n@@ -375,22 +375,7 @@ impl<'tcx> UnsafetyChecker<'_, 'tcx> {\n }\n \n pub(crate) fn provide(providers: &mut Providers) {\n-    *providers = Providers {\n-        unsafety_check_result: |tcx, def_id| {\n-            if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n-                tcx.unsafety_check_result_for_const_arg(def)\n-            } else {\n-                unsafety_check_result(tcx, ty::WithOptConstParam::unknown(def_id))\n-            }\n-        },\n-        unsafety_check_result_for_const_arg: |tcx, (did, param_did)| {\n-            unsafety_check_result(\n-                tcx,\n-                ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n-            )\n-        },\n-        ..*providers\n-    };\n+    *providers = Providers { unsafety_check_result, ..*providers };\n }\n \n /// Context information for [`UnusedUnsafeVisitor`] traversal,\n@@ -492,10 +477,7 @@ fn check_unused_unsafe(\n     unused_unsafes\n }\n \n-fn unsafety_check_result(\n-    tcx: TyCtxt<'_>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n-) -> &UnsafetyCheckResult {\n+fn unsafety_check_result(tcx: TyCtxt<'_>, def: LocalDefId) -> &UnsafetyCheckResult {\n     debug!(\"unsafety_violations({:?})\", def);\n \n     // N.B., this borrow is valid because all the consumers of\n@@ -510,13 +492,13 @@ fn unsafety_check_result(\n         });\n     }\n \n-    let param_env = tcx.param_env(def.did);\n+    let param_env = tcx.param_env(def);\n \n-    let mut checker = UnsafetyChecker::new(body, def.did, tcx, param_env);\n+    let mut checker = UnsafetyChecker::new(body, def, tcx, param_env);\n     checker.visit_body(&body);\n \n-    let unused_unsafes = (!tcx.is_typeck_child(def.did.to_def_id()))\n-        .then(|| check_unused_unsafe(tcx, def.did, &checker.used_unsafe_blocks));\n+    let unused_unsafes = (!tcx.is_typeck_child(def.to_def_id()))\n+        .then(|| check_unused_unsafe(tcx, def, &checker.used_unsafe_blocks));\n \n     tcx.arena.alloc(UnsafetyCheckResult {\n         violations: checker.violations,"}, {"sha": "bf01b45eb4077eacdd532e5eeaf553b4e2f5ce8a", "filename": "compiler/rustc_mir_transform/src/coverage/query.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -164,7 +164,6 @@ fn is_inlined(body: &Body<'_>, statement: &Statement<'_>) -> bool {\n /// whether that means const mir or runtime mir. For `const fn` this opts for runtime\n /// mir.\n fn mir_body(tcx: TyCtxt<'_>, def_id: DefId) -> &mir::Body<'_> {\n-    let id = ty::WithOptConstParam::unknown(def_id);\n-    let def = ty::InstanceDef::Item(id);\n+    let def = ty::InstanceDef::Item(def_id);\n     tcx.instance_mir(def)\n }"}, {"sha": "db68adc8bc97931e8d954b8c6f8a1e22b55d1619", "filename": "compiler/rustc_mir_transform/src/ffi_unwind_calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -48,7 +48,7 @@ fn has_ffi_unwind_calls(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> bool {\n         return false;\n     }\n \n-    let body = &*tcx.mir_built(ty::WithOptConstParam::unknown(local_def_id)).borrow();\n+    let body = &*tcx.mir_built(local_def_id).borrow();\n \n     let body_ty = tcx.type_of(def_id).skip_binder();\n     let body_abi = match body_ty.kind() {"}, {"sha": "5b3a66bc3d258aaec0a3db0e263f5c1ee9072782", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -1399,7 +1399,7 @@ pub(crate) fn mir_generator_witnesses<'tcx>(\n ) -> GeneratorLayout<'tcx> {\n     assert!(tcx.sess.opts.unstable_opts.drop_tracking_mir);\n \n-    let (body, _) = tcx.mir_promoted(ty::WithOptConstParam::unknown(def_id));\n+    let (body, _) = tcx.mir_promoted(def_id);\n     let body = body.borrow();\n     let body = &*body;\n "}, {"sha": "8b811d7e8708660dd72c3d32dba5819a0adc843e", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -148,8 +148,7 @@ pub(crate) fn mir_inliner_callees<'tcx>(\n     let guard;\n     let body = match (instance, instance.def_id().as_local()) {\n         (InstanceDef::Item(_), Some(def_id)) => {\n-            let def = ty::WithOptConstParam::unknown(def_id);\n-            steal = tcx.mir_promoted(def).0;\n+            steal = tcx.mir_promoted(def_id).0;\n             guard = steal.borrow();\n             &*guard\n         }"}, {"sha": "7a2420a6d940d2991a322f600737eac3818af51b", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 26, "deletions": 88, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -23,7 +23,7 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_data_structures::steal::Steal;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::Visitor as _;\n@@ -111,36 +111,17 @@ pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         mir_keys,\n         mir_const,\n-        mir_const_qualif: |tcx, def_id| {\n-            if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n-                tcx.mir_const_qualif_const_arg(def)\n-            } else {\n-                mir_const_qualif(tcx, ty::WithOptConstParam::unknown(def_id))\n-            }\n-        },\n-        mir_const_qualif_const_arg: |tcx, (did, param_did)| {\n-            mir_const_qualif(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })\n-        },\n+        mir_const_qualif,\n         mir_promoted,\n         mir_drops_elaborated_and_const_checked,\n         mir_for_ctfe,\n-        mir_for_ctfe_of_const_arg,\n         mir_generator_witnesses: generator::mir_generator_witnesses,\n         optimized_mir,\n         is_mir_available,\n         is_ctfe_mir_available: |tcx, did| is_mir_available(tcx, did),\n         mir_callgraph_reachable: inline::cycle::mir_callgraph_reachable,\n         mir_inliner_callees: inline::cycle::mir_inliner_callees,\n-        promoted_mir: |tcx, def_id| {\n-            if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n-                tcx.promoted_mir_of_const_arg(def)\n-            } else {\n-                promoted_mir(tcx, ty::WithOptConstParam::unknown(def_id))\n-            }\n-        },\n-        promoted_mir_of_const_arg: |tcx, (did, param_did)| {\n-            promoted_mir(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })\n-        },\n+        promoted_mir,\n         deduced_param_attrs: deduce_param_attrs::deduced_param_attrs,\n         ..*providers\n     };\n@@ -234,8 +215,8 @@ fn mir_keys(tcx: TyCtxt<'_>, (): ()) -> FxIndexSet<LocalDefId> {\n     set\n }\n \n-fn mir_const_qualif(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> ConstQualifs {\n-    let const_kind = tcx.hir().body_const_context(def.did);\n+fn mir_const_qualif(tcx: TyCtxt<'_>, def: LocalDefId) -> ConstQualifs {\n+    let const_kind = tcx.hir().body_const_context(def);\n \n     // No need to const-check a non-const `fn`.\n     if const_kind.is_none() {\n@@ -253,7 +234,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) ->\n         return Default::default();\n     }\n \n-    let ccx = check_consts::ConstCx { body, tcx, const_kind, param_env: tcx.param_env(def.did) };\n+    let ccx = check_consts::ConstCx { body, tcx, const_kind, param_env: tcx.param_env(def) };\n \n     let mut validator = check_consts::check::Checker::new(&ccx);\n     validator.check_body();\n@@ -266,22 +247,14 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) ->\n /// Make MIR ready for const evaluation. This is run on all MIR, not just on consts!\n /// FIXME(oli-obk): it's unclear whether we still need this phase (and its corresponding query).\n /// We used to have this for pre-miri MIR based const eval.\n-fn mir_const(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Steal<Body<'_>> {\n-    if let Some(def) = def.try_upgrade(tcx) {\n-        return tcx.mir_const(def);\n-    }\n-\n+fn mir_const(tcx: TyCtxt<'_>, def: LocalDefId) -> &Steal<Body<'_>> {\n     // Unsafety check uses the raw mir, so make sure it is run.\n     if !tcx.sess.opts.unstable_opts.thir_unsafeck {\n-        if let Some(param_did) = def.const_param_did {\n-            tcx.ensure_with_value().unsafety_check_result_for_const_arg((def.did, param_did));\n-        } else {\n-            tcx.ensure_with_value().unsafety_check_result(def.did);\n-        }\n+        tcx.ensure_with_value().unsafety_check_result(def);\n     }\n \n     // has_ffi_unwind_calls query uses the raw mir, so make sure it is run.\n-    tcx.ensure_with_value().has_ffi_unwind_calls(def.did);\n+    tcx.ensure_with_value().has_ffi_unwind_calls(def);\n \n     let mut body = tcx.mir_built(def).steal();\n \n@@ -307,16 +280,12 @@ fn mir_const(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Steal<\n /// Compute the main MIR body and the list of MIR bodies of the promoteds.\n fn mir_promoted(\n     tcx: TyCtxt<'_>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n+    def: LocalDefId,\n ) -> (&Steal<Body<'_>>, &Steal<IndexVec<Promoted, Body<'_>>>) {\n-    if let Some(def) = def.try_upgrade(tcx) {\n-        return tcx.mir_promoted(def);\n-    }\n-\n     // Ensure that we compute the `mir_const_qualif` for constants at\n     // this point, before we steal the mir-const result.\n     // Also this means promotion can rely on all const checks having been done.\n-    let const_qualifs = tcx.mir_const_qualif_opt_const_arg(def);\n+    let const_qualifs = tcx.mir_const_qualif(def);\n     let mut body = tcx.mir_const(def).steal();\n     if let Some(error_reported) = const_qualifs.tainted_by_errors {\n         body.tainted_by_errors = Some(error_reported);\n@@ -344,38 +313,22 @@ fn mir_promoted(\n \n /// Compute the MIR that is used during CTFE (and thus has no optimizations run on it)\n fn mir_for_ctfe(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &Body<'_> {\n-    if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n-        tcx.mir_for_ctfe_of_const_arg(def)\n-    } else {\n-        tcx.arena.alloc(inner_mir_for_ctfe(tcx, ty::WithOptConstParam::unknown(def_id)))\n-    }\n+    tcx.arena.alloc(inner_mir_for_ctfe(tcx, def_id))\n }\n \n-/// Same as `mir_for_ctfe`, but used to get the MIR of a const generic parameter.\n-/// The docs on `WithOptConstParam` explain this a bit more, but the TLDR is that\n-/// we'd get cycle errors with `mir_for_ctfe`, because typeck would need to typeck\n-/// the const parameter while type checking the main body, which in turn would try\n-/// to type check the main body again.\n-fn mir_for_ctfe_of_const_arg(tcx: TyCtxt<'_>, (did, param_did): (LocalDefId, DefId)) -> &Body<'_> {\n-    tcx.arena.alloc(inner_mir_for_ctfe(\n-        tcx,\n-        ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n-    ))\n-}\n-\n-fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_> {\n+fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: LocalDefId) -> Body<'_> {\n     // FIXME: don't duplicate this between the optimized_mir/mir_for_ctfe queries\n-    if tcx.is_constructor(def.did.to_def_id()) {\n+    if tcx.is_constructor(def.to_def_id()) {\n         // There's no reason to run all of the MIR passes on constructors when\n         // we can just output the MIR we want directly. This also saves const\n         // qualification and borrow checking the trouble of special casing\n         // constructors.\n-        return shim::build_adt_ctor(tcx, def.did.to_def_id());\n+        return shim::build_adt_ctor(tcx, def.to_def_id());\n     }\n \n     let context = tcx\n         .hir()\n-        .body_const_context(def.did)\n+        .body_const_context(def)\n         .expect(\"mir_for_ctfe should not be used for runtime functions\");\n \n     let body = tcx.mir_drops_elaborated_and_const_checked(def).borrow().clone();\n@@ -413,29 +366,19 @@ fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -\n /// Obtain just the main MIR (no promoteds) and run some cleanups on it. This also runs\n /// mir borrowck *before* doing so in order to ensure that borrowck can be run and doesn't\n /// end up missing the source MIR due to stealing happening.\n-fn mir_drops_elaborated_and_const_checked(\n-    tcx: TyCtxt<'_>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n-) -> &Steal<Body<'_>> {\n-    if let Some(def) = def.try_upgrade(tcx) {\n-        return tcx.mir_drops_elaborated_and_const_checked(def);\n-    }\n-\n+fn mir_drops_elaborated_and_const_checked(tcx: TyCtxt<'_>, def: LocalDefId) -> &Steal<Body<'_>> {\n     if tcx.sess.opts.unstable_opts.drop_tracking_mir\n-        && let DefKind::Generator = tcx.def_kind(def.did)\n+        && let DefKind::Generator = tcx.def_kind(def)\n     {\n-        tcx.ensure_with_value().mir_generator_witnesses(def.did);\n+        tcx.ensure_with_value().mir_generator_witnesses(def);\n     }\n-    let mir_borrowck = tcx.mir_borrowck_opt_const_arg(def);\n+    let mir_borrowck = tcx.mir_borrowck(def);\n \n-    let is_fn_like = tcx.def_kind(def.did).is_fn_like();\n+    let is_fn_like = tcx.def_kind(def).is_fn_like();\n     if is_fn_like {\n-        let did = def.did.to_def_id();\n-        let def = ty::WithOptConstParam::unknown(did);\n-\n         // Do not compute the mir call graph without said call graph actually being used.\n         if inline::Inline.is_enabled(&tcx.sess) {\n-            tcx.ensure_with_value().mir_inliner_callees(ty::InstanceDef::Item(def));\n+            tcx.ensure_with_value().mir_inliner_callees(ty::InstanceDef::Item(def.to_def_id()));\n         }\n     }\n \n@@ -588,7 +531,6 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n \n /// Optimize the MIR and prepare it for codegen.\n fn optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> &Body<'_> {\n-    assert_eq!(ty::WithOptConstParam::try_lookup(did, tcx), None);\n     tcx.arena.alloc(inner_optimized_mir(tcx, did))\n }\n \n@@ -610,8 +552,7 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> Body<'_> {\n         Some(other) => panic!(\"do not use `optimized_mir` for constants: {:?}\", other),\n     }\n     debug!(\"about to call mir_drops_elaborated...\");\n-    let body =\n-        tcx.mir_drops_elaborated_and_const_checked(ty::WithOptConstParam::unknown(did)).steal();\n+    let body = tcx.mir_drops_elaborated_and_const_checked(did).steal();\n     let mut body = remap_mir_for_const_eval_select(tcx, body, hir::Constness::NotConst);\n     debug!(\"body: {:#?}\", body);\n     run_optimization_passes(tcx, &mut body);\n@@ -621,15 +562,12 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> Body<'_> {\n \n /// Fetch all the promoteds of an item and prepare their MIR bodies to be ready for\n /// constant evaluation once all substitutions become known.\n-fn promoted_mir(\n-    tcx: TyCtxt<'_>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n-) -> &IndexVec<Promoted, Body<'_>> {\n-    if tcx.is_constructor(def.did.to_def_id()) {\n+fn promoted_mir(tcx: TyCtxt<'_>, def: LocalDefId) -> &IndexVec<Promoted, Body<'_>> {\n+    if tcx.is_constructor(def.to_def_id()) {\n         return tcx.arena.alloc(IndexVec::new());\n     }\n \n-    let tainted_by_errors = tcx.mir_borrowck_opt_const_arg(def).tainted_by_errors;\n+    let tainted_by_errors = tcx.mir_borrowck(def).tainted_by_errors;\n     let mut promoted = tcx.mir_promoted(def).1.steal();\n \n     for body in &mut promoted {"}, {"sha": "43a485c977db7101165690313fc7c08a195c3784", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -267,7 +267,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n     match mono_item {\n         MonoItem::Fn(instance) => {\n             let def_id = match instance.def {\n-                ty::InstanceDef::Item(def) => def.did,\n+                ty::InstanceDef::Item(def) => def,\n                 ty::InstanceDef::VTableShim(..)\n                 | ty::InstanceDef::ReifyShim(..)\n                 | ty::InstanceDef::FnPtrShim(..)\n@@ -421,8 +421,7 @@ fn mono_item_visibility<'tcx>(\n     };\n \n     let def_id = match instance.def {\n-        InstanceDef::Item(def) => def.did,\n-        InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n+        InstanceDef::Item(def_id) | InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n \n         // We match the visibility of statics here\n         InstanceDef::ThreadLocalShim(def_id) => {"}, {"sha": "ddc62d9c3903e4570cacbc7a15307d736df90412", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -232,7 +232,7 @@ impl<'a, 'tcx> MarkUsedGenericParams<'a, 'tcx> {\n     /// a closure, generator or constant).\n     #[instrument(level = \"debug\", skip(self, def_id, substs))]\n     fn visit_child_body(&mut self, def_id: DefId, substs: SubstsRef<'tcx>) {\n-        let instance = ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id));\n+        let instance = ty::InstanceDef::Item(def_id);\n         let unused = self.tcx.unused_generic_params(instance);\n         debug!(?self.unused_parameters, ?unused);\n         for (i, arg) in substs.iter().enumerate() {\n@@ -272,10 +272,10 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n                 // Avoid considering `T` unused when constants are of the form:\n                 //   `<Self as Foo<T>>::foo::promoted[p]`\n                 if let Some(p) = promoted {\n-                    if self.def_id == def.did && !self.tcx.generics_of(def.did).has_self {\n+                    if self.def_id == def && !self.tcx.generics_of(def).has_self {\n                         // If there is a promoted, don't look at the substs - since it will always contain\n                         // the generic parameters, instead, traverse the promoted MIR.\n-                        let promoted = self.tcx.promoted_mir(def.did);\n+                        let promoted = self.tcx.promoted_mir(def);\n                         self.visit_body(&promoted[p]);\n                     }\n                 }\n@@ -305,9 +305,9 @@ impl<'a, 'tcx> TypeVisitor<TyCtxt<'tcx>> for MarkUsedGenericParams<'a, 'tcx> {\n                 ControlFlow::Continue(())\n             }\n             ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs })\n-                if matches!(self.tcx.def_kind(def.did), DefKind::AnonConst) =>\n+                if matches!(self.tcx.def_kind(def), DefKind::AnonConst) =>\n             {\n-                self.visit_child_body(def.did, substs);\n+                self.visit_child_body(def, substs);\n                 ControlFlow::Continue(())\n             }\n             _ => c.super_visit_with(self),"}, {"sha": "08b588a8c94a4796e73c113ac8dc9ae6aa970dd2", "filename": "compiler/rustc_query_impl/src/profiling_support.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -4,7 +4,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfiler;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n-use rustc_middle::ty::{TyCtxt, WithOptConstParam};\n+use rustc_middle::ty::TyCtxt;\n use rustc_query_system::query::QueryCache;\n use std::fmt::Debug;\n use std::io::Write;\n@@ -151,37 +151,6 @@ impl SpecIntoSelfProfilingString for LocalDefId {\n     }\n }\n \n-impl<T: SpecIntoSelfProfilingString> SpecIntoSelfProfilingString for WithOptConstParam<T> {\n-    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n-        // We print `WithOptConstParam` values as tuples to make them shorter\n-        // and more readable, without losing information:\n-        //\n-        // \"WithOptConstParam { did: foo::bar, const_param_did: Some(foo::baz) }\"\n-        // becomes \"(foo::bar, foo::baz)\" and\n-        // \"WithOptConstParam { did: foo::bar, const_param_did: None }\"\n-        // becomes \"(foo::bar, _)\".\n-\n-        let did = StringComponent::Ref(self.did.to_self_profile_string(builder));\n-\n-        let const_param_did = if let Some(const_param_did) = self.const_param_did {\n-            let const_param_did = builder.def_id_to_string_id(const_param_did);\n-            StringComponent::Ref(const_param_did)\n-        } else {\n-            StringComponent::Value(\"_\")\n-        };\n-\n-        let components = [\n-            StringComponent::Value(\"(\"),\n-            did,\n-            StringComponent::Value(\", \"),\n-            const_param_did,\n-            StringComponent::Value(\")\"),\n-        ];\n-\n-        builder.profiler.alloc_string(&components[..])\n-    }\n-}\n-\n impl<T0, T1> SpecIntoSelfProfilingString for (T0, T1)\n where\n     T0: SpecIntoSelfProfilingString,"}, {"sha": "3a2acbeb32e15b09f11684d8deae09635ff6c8e1", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -198,7 +198,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n                 let identity_substs =\n                     ty::InternalSubsts::identity_for_item(tcx, assoc_def.item.def_id);\n-                let did = ty::WithOptConstParam::unknown(assoc_def.item.def_id);\n+                let did = assoc_def.item.def_id;\n                 let kind =\n                     ty::ConstKind::Unevaluated(ty::UnevaluatedConst::new(did, identity_substs));\n                 ty.map_bound(|ty| tcx.mk_const(kind, ty).into())"}, {"sha": "222af4c2ace989743e142688f669de1fc18a17f0", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -796,10 +796,9 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                                 Ok(Some(valtree)) => Ok(selcx.tcx().mk_const(valtree, c.ty())),\n                                 Ok(None) => {\n                                     let tcx = self.tcx;\n-                                    let def_id = unevaluated.def.did;\n                                     let reported =\n                                         tcx.sess.emit_err(UnableToConstructConstantValue {\n-                                            span: tcx.def_span(def_id),\n+                                            span: tcx.def_span(unevaluated.def),\n                                             unevaluated: unevaluated,\n                                         });\n                                     Err(ErrorHandled::Reported(reported))"}, {"sha": "9d99d30d45c4ffa4ed1674884bf71fea9b556940", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -44,7 +44,7 @@ pub fn is_const_evaluatable<'tcx>(\n         let ct = tcx.expand_abstract_consts(unexpanded_ct);\n \n         let is_anon_ct = if let ty::ConstKind::Unevaluated(uv) = ct.kind() {\n-            tcx.def_kind(uv.def.did) == DefKind::AnonConst\n+            tcx.def_kind(uv.def) == DefKind::AnonConst\n         } else {\n             false\n         };\n@@ -119,7 +119,7 @@ pub fn is_const_evaluatable<'tcx>(\n                 tcx.sess\n                     .struct_span_fatal(\n                         // Slightly better span than just using `span` alone\n-                        if span == rustc_span::DUMMY_SP { tcx.def_span(uv.def.did) } else { span },\n+                        if span == rustc_span::DUMMY_SP { tcx.def_span(uv.def) } else { span },\n                         \"failed to evaluate generic const expression\",\n                     )\n                     .note(\"the crate this constant originates from uses `#![feature(generic_const_exprs)]`\")"}, {"sha": "ae21dcd2a360cca403a85e3a066f94d21a927e85", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -1476,7 +1476,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         };\n                         let mut err =\n                             self.tcx.sess.struct_span_err(span, \"unconstrained generic constant\");\n-                        let const_span = self.tcx.def_span(uv.def.did);\n+                        let const_span = self.tcx.def_span(uv.def);\n                         match self.tcx.sess.source_map().span_to_snippet(const_span) {\n                             Ok(snippet) => err.help(&format!(\n                                 \"try adding a `where` bound using this expression: `where [(); {}]:`\",\n@@ -1771,7 +1771,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         .tcx\n                         .mk_const(\n                             ty::UnevaluatedConst {\n-                                def: ty::WithOptConstParam::unknown(data.projection_ty.def_id),\n+                                def: data.projection_ty.def_id,\n                                 substs: data.projection_ty.substs,\n                             },\n                             ct.ty(),"}, {"sha": "43196d1e6297dd819b972e2419043a832edfe5fa", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -540,8 +540,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                         use ty::ConstKind::Unevaluated;\n                         match (c1.kind(), c2.kind()) {\n                             (Unevaluated(a), Unevaluated(b))\n-                                if a.def.did == b.def.did\n-                                    && tcx.def_kind(a.def.did) == DefKind::AssocConst =>\n+                                if a.def == b.def && tcx.def_kind(a.def) == DefKind::AssocConst =>\n                             {\n                                 if let Ok(new_obligations) = infcx\n                                     .at(&obligation.cause, obligation.param_env)"}, {"sha": "6ba0538717348e9587f0bef80d4dde9a48193c04", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -2131,9 +2131,8 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let ty = tcx.type_of(assoc_ty.item.def_id);\n     let is_const = matches!(tcx.def_kind(assoc_ty.item.def_id), DefKind::AssocConst);\n     let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n-        let identity_substs =\n-            crate::traits::InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n-        let did = ty::WithOptConstParam::unknown(assoc_ty.item.def_id);\n+        let did = assoc_ty.item.def_id;\n+        let identity_substs = crate::traits::InternalSubsts::identity_for_item(tcx, did);\n         let kind = ty::ConstKind::Unevaluated(ty::UnevaluatedConst::new(did, identity_substs));\n         ty.map_bound(|ty| tcx.mk_const(kind, ty).into())\n     } else {"}, {"sha": "081e4d7cfa47db455e59d0bc9de0904d63d8364b", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -896,8 +896,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         use ty::ConstKind::Unevaluated;\n                         match (c1.kind(), c2.kind()) {\n                             (Unevaluated(a), Unevaluated(b))\n-                                if a.def.did == b.def.did\n-                                    && tcx.def_kind(a.def.did) == DefKind::AssocConst =>\n+                                if a.def == b.def && tcx.def_kind(a.def) == DefKind::AssocConst =>\n                             {\n                                 if let Ok(InferOk { obligations, value: () }) = self\n                                     .infcx"}, {"sha": "40e19abc0d06aff772af5f14844c74a631e184c0", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -478,7 +478,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                     match ct.kind() {\n                         ty::ConstKind::Unevaluated(uv) => {\n                             if !ct.has_escaping_bound_vars() {\n-                                let obligations = self.nominal_obligations(uv.def.did, uv.substs);\n+                                let obligations = self.nominal_obligations(uv.def, uv.substs);\n                                 self.out.extend(obligations);\n \n                                 let predicate ="}, {"sha": "e650792f4d5d40e135b7c1f343285572c0beb685", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 25, "deletions": 41, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -132,7 +132,7 @@ fn recurse_build<'tcx>(\n             tcx.mk_const(val, node.ty)\n         }\n         &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n-            let uneval = ty::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+            let uneval = ty::UnevaluatedConst::new(def_id, substs);\n             tcx.mk_const(uneval, node.ty)\n         }\n         ExprKind::ConstParam { param, .. } => tcx.mk_const(*param, node.ty),\n@@ -391,52 +391,36 @@ impl<'a, 'tcx> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n /// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n pub fn thir_abstract_const(\n     tcx: TyCtxt<'_>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n+    def: LocalDefId,\n ) -> Result<Option<ty::Const<'_>>, ErrorGuaranteed> {\n-    if tcx.features().generic_const_exprs {\n-        match tcx.def_kind(def.did) {\n-            // FIXME(generic_const_exprs): We currently only do this for anonymous constants,\n-            // meaning that we do not look into associated constants. I(@lcnr) am not yet sure whether\n-            // we want to look into them or treat them as opaque projections.\n-            //\n-            // Right now we do neither of that and simply always fail to unify them.\n-            DefKind::AnonConst | DefKind::InlineConst => (),\n-            _ => return Ok(None),\n-        }\n-\n-        let body = tcx.thir_body(def)?;\n-        let (body, body_id) = (&*body.0.borrow(), body.1);\n+    if !tcx.features().generic_const_exprs {\n+        return Ok(None);\n+    }\n \n-        let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body };\n-        visit::walk_expr(&mut is_poly_vis, &body[body_id]);\n-        if !is_poly_vis.is_poly {\n-            return Ok(None);\n-        }\n+    match tcx.def_kind(def) {\n+        // FIXME(generic_const_exprs): We currently only do this for anonymous constants,\n+        // meaning that we do not look into associated constants. I(@lcnr) am not yet sure whether\n+        // we want to look into them or treat them as opaque projections.\n+        //\n+        // Right now we do neither of that and simply always fail to unify them.\n+        DefKind::AnonConst | DefKind::InlineConst => (),\n+        _ => return Ok(None),\n+    }\n \n-        let root_span = body.exprs[body_id].span;\n+    let body = tcx.thir_body(def)?;\n+    let (body, body_id) = (&*body.0.borrow(), body.1);\n \n-        Some(recurse_build(tcx, body, body_id, root_span)).transpose()\n-    } else {\n-        Ok(None)\n+    let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body };\n+    visit::walk_expr(&mut is_poly_vis, &body[body_id]);\n+    if !is_poly_vis.is_poly {\n+        return Ok(None);\n     }\n+\n+    let root_span = body.exprs[body_id].span;\n+\n+    Some(recurse_build(tcx, body, body_id, root_span)).transpose()\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {\n-    *providers = ty::query::Providers {\n-        destructure_const,\n-        thir_abstract_const: |tcx, def_id| {\n-            if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n-                tcx.thir_abstract_const_of_const_arg(def)\n-            } else {\n-                thir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n-            }\n-        },\n-        thir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n-            thir_abstract_const(\n-                tcx,\n-                ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n-            )\n-        },\n-        ..*providers\n-    };\n+    *providers = ty::query::Providers { destructure_const, thir_abstract_const, ..*providers };\n }"}, {"sha": "21cc3c9517e9dc7e67a47967d66517522e2b325b", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 8, "deletions": 35, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -1,5 +1,5 @@\n use rustc_errors::ErrorGuaranteed;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::DefId;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::traits::CodegenObligationError;\n use rustc_middle::ty::subst::SubstsRef;\n@@ -13,49 +13,27 @@ use crate::errors::UnexpectedFnPtrAssociatedItem;\n fn resolve_instance<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, (DefId, SubstsRef<'tcx>)>,\n-) -> Result<Option<Instance<'tcx>>, ErrorGuaranteed> {\n-    let (param_env, (did, substs)) = key.into_parts();\n-    inner_resolve_instance(tcx, param_env.and((ty::WithOptConstParam::unknown(did), substs)))\n-}\n-\n-fn resolve_instance_of_const_arg<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, (LocalDefId, DefId, SubstsRef<'tcx>)>,\n-) -> Result<Option<Instance<'tcx>>, ErrorGuaranteed> {\n-    let (param_env, (did, const_param_did, substs)) = key.into_parts();\n-    inner_resolve_instance(\n-        tcx,\n-        param_env.and((\n-            ty::WithOptConstParam { did: did.to_def_id(), const_param_did: Some(const_param_did) },\n-            substs,\n-        )),\n-    )\n-}\n-\n-fn inner_resolve_instance<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>)>,\n ) -> Result<Option<Instance<'tcx>>, ErrorGuaranteed> {\n     let (param_env, (def, substs)) = key.into_parts();\n \n-    let result = if let Some(trait_def_id) = tcx.trait_of_item(def.did) {\n+    let result = if let Some(trait_def_id) = tcx.trait_of_item(def) {\n         debug!(\" => associated item, attempting to find impl in param_env {:#?}\", param_env);\n         resolve_associated_item(\n             tcx,\n-            def.did,\n+            def,\n             param_env,\n             trait_def_id,\n             tcx.normalize_erasing_regions(param_env, substs),\n         )\n     } else {\n-        let ty = tcx.type_of(def.def_id_for_type_of());\n+        let ty = tcx.type_of(def);\n         let item_type =\n             tcx.subst_and_normalize_erasing_regions(substs, param_env, ty.skip_binder());\n \n         let def = match *item_type.kind() {\n             ty::FnDef(def_id, ..) if tcx.is_intrinsic(def_id) => {\n                 debug!(\" => intrinsic\");\n-                ty::InstanceDef::Intrinsic(def.did)\n+                ty::InstanceDef::Intrinsic(def)\n             }\n             ty::FnDef(def_id, substs) if Some(def_id) == tcx.lang_items().drop_in_place_fn() => {\n                 let ty = substs.type_at(0);\n@@ -200,15 +178,11 @@ fn resolve_associated_item<'tcx>(\n             Some(ty::Instance::new(leaf_def.item.def_id, substs))\n         }\n         traits::ImplSource::Generator(generator_data) => Some(Instance {\n-            def: ty::InstanceDef::Item(ty::WithOptConstParam::unknown(\n-                generator_data.generator_def_id,\n-            )),\n+            def: ty::InstanceDef::Item(generator_data.generator_def_id),\n             substs: generator_data.substs,\n         }),\n         traits::ImplSource::Future(future_data) => Some(Instance {\n-            def: ty::InstanceDef::Item(ty::WithOptConstParam::unknown(\n-                future_data.generator_def_id,\n-            )),\n+            def: ty::InstanceDef::Item(future_data.generator_def_id),\n             substs: future_data.substs,\n         }),\n         traits::ImplSource::Closure(closure_data) => {\n@@ -292,6 +266,5 @@ fn resolve_associated_item<'tcx>(\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {\n-    *providers =\n-        ty::query::Providers { resolve_instance, resolve_instance_of_const_arg, ..*providers };\n+    *providers = ty::query::Providers { resolve_instance, ..*providers };\n }"}, {"sha": "b802fd065fe542cc8b9da60e787c8568b744f763", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -243,9 +243,9 @@ pub(crate) fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n     match n.kind() {\n         ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs: _ }) => {\n             let s = if let Some(def) = def.as_local() {\n-                print_const_expr(cx.tcx, cx.tcx.hir().body_owned_by(def.did))\n+                print_const_expr(cx.tcx, cx.tcx.hir().body_owned_by(def))\n             } else {\n-                inline::print_inlined_const(cx.tcx, def.did)\n+                inline::print_inlined_const(cx.tcx, def)\n             };\n \n             s"}, {"sha": "eed0f1f19918bf903d5276d7130ea12cf2c649f9", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -196,11 +196,9 @@ fn is_value_unfrozen_poly<'tcx>(cx: &LateContext<'tcx>, body_id: BodyId, ty: Ty<\n fn is_value_unfrozen_expr<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId, def_id: DefId, ty: Ty<'tcx>) -> bool {\n     let substs = cx.typeck_results().node_substs(hir_id);\n \n-    let result = cx.tcx.const_eval_resolve(\n-        cx.param_env,\n-        mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs),\n-        None,\n-    );\n+    let result = cx\n+        .tcx\n+        .const_eval_resolve(cx.param_env, mir::UnevaluatedConst::new(def_id, substs), None);\n     is_value_unfrozen_raw(cx, result, ty)\n }\n "}, {"sha": "99bfc4b5717c89c21af69a97bc456148cf2a74bd", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -450,11 +450,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 let result = self\n                     .lcx\n                     .tcx\n-                    .const_eval_resolve(\n-                        self.param_env,\n-                        mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs),\n-                        None,\n-                    )\n+                    .const_eval_resolve(self.param_env, mir::UnevaluatedConst::new(def_id, substs), None)\n                     .ok()\n                     .map(|val| rustc_middle::mir::ConstantKind::from_value(val, ty))?;\n                 let result = miri_to_const(self.lcx.tcx, result);"}, {"sha": "4b349e758be7e4e978796894273743d0c58dac74", "filename": "tests/ui/mir/validate/storage-live.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b275d2c30b6e88cc48747f349f7137076d450658/tests%2Fui%2Fmir%2Fvalidate%2Fstorage-live.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b275d2c30b6e88cc48747f349f7137076d450658/tests%2Fui%2Fmir%2Fvalidate%2Fstorage-live.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Fvalidate%2Fstorage-live.stderr?ref=b275d2c30b6e88cc48747f349f7137076d450658", "patch": "@@ -1,4 +1,4 @@\n-error: internal compiler error: broken MIR in Item(WithOptConstParam { did: DefId(0:8 ~ storage_live[HASH]::multiple_storage), const_param_did: None }) (before pass CheckPackedRef) at bb0[1]:\n+error: internal compiler error: broken MIR in Item(DefId(0:8 ~ storage_live[HASH]::multiple_storage)) (before pass CheckPackedRef) at bb0[1]:\n                                 StorageLive(_1) which already has storage here\n   --> $DIR/storage-live.rs:22:13\n    |"}]}