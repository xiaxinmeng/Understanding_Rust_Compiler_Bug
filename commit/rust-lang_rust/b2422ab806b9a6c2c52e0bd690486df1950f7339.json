{"sha": "b2422ab806b9a6c2c52e0bd690486df1950f7339", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNDIyYWI4MDZiOWE2YzJjNTJlMGJkNjkwNDg2ZGYxOTUwZjczMzk=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-07-08T19:51:29Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-07-22T11:32:56Z"}, "message": "remove never-called type-error reporting functions", "tree": {"sha": "5d97b15c0f146f84766afb50f76fb56ac934b1dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d97b15c0f146f84766afb50f76fb56ac934b1dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2422ab806b9a6c2c52e0bd690486df1950f7339", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2422ab806b9a6c2c52e0bd690486df1950f7339", "html_url": "https://github.com/rust-lang/rust/commit/b2422ab806b9a6c2c52e0bd690486df1950f7339", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2422ab806b9a6c2c52e0bd690486df1950f7339/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d7597588d5aa7993dcd26cb0d773ebd27384d91", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d7597588d5aa7993dcd26cb0d773ebd27384d91", "html_url": "https://github.com/rust-lang/rust/commit/0d7597588d5aa7993dcd26cb0d773ebd27384d91"}], "stats": {"total": 88, "additions": 19, "deletions": 69}, "files": [{"sha": "fc5625036ae40ca7ac7231e85d0fec903172e08d", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 19, "deletions": 69, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b2422ab806b9a6c2c52e0bd690486df1950f7339/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2422ab806b9a6c2c52e0bd690486df1950f7339/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b2422ab806b9a6c2c52e0bd690486df1950f7339", "patch": "@@ -1468,75 +1468,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // error type, meaning that an error occurred when typechecking this expression),\n     // this is a derived error. The error cascaded from another error (that was already\n     // reported), so it's not useful to display it to the user.\n-    // The following four methods -- type_error_message_str, type_error_message_str_with_expected,\n-    // type_error_message, and report_mismatched_types -- implement this logic.\n+    // The following methods implement this logic.\n     // They check if either the actual or expected type is TyError, and don't print the error\n     // in this case. The typechecker should only ever report type errors involving mismatched\n-    // types using one of these four methods, and should not call span_err directly for such\n+    // types using one of these methods, and should not call span_err directly for such\n     // errors.\n-    pub fn type_error_message_str<M>(&self,\n-                                     sp: Span,\n-                                     mk_msg: M,\n-                                     actual_ty: String,\n-                                     err: Option<&TypeError<'tcx>>)\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n-    }\n-\n-    pub fn type_error_struct_str<M>(&self,\n-                                    sp: Span,\n-                                    mk_msg: M,\n-                                    actual_ty: String,\n-                                    err: Option<&TypeError<'tcx>>)\n-                                    -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        self.type_error_struct_str_with_expected(sp, mk_msg, None, actual_ty, err)\n-    }\n-\n-    pub fn type_error_message_str_with_expected<M>(&self,\n-                                                   sp: Span,\n-                                                   mk_msg: M,\n-                                                   expected_ty: Option<Ty<'tcx>>,\n-                                                   actual_ty: String,\n-                                                   err: Option<&TypeError<'tcx>>)\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        self.type_error_struct_str_with_expected(sp, mk_msg, expected_ty, actual_ty, err)\n-            .emit();\n-    }\n-\n-    pub fn type_error_struct_str_with_expected<M>(&self,\n-                                                  sp: Span,\n-                                                  mk_msg: M,\n-                                                  expected_ty: Option<Ty<'tcx>>,\n-                                                  actual_ty: String,\n-                                                  err: Option<&TypeError<'tcx>>)\n-                                                  -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n-\n-        let resolved_expected = expected_ty.map(|e_ty| self.resolve_type_vars_if_possible(&e_ty));\n-\n-        if !resolved_expected.references_error() {\n-            let error_str = err.map_or(\"\".to_string(), |t_err| {\n-                format!(\" ({})\", t_err)\n-            });\n-\n-            let mut db = self.tcx.sess.struct_span_err(sp, &format!(\"{}{}\",\n-                mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                error_str));\n-\n-            if let Some(err) = err {\n-                self.tcx.note_and_explain_type_err(&mut db, err, sp);\n-            }\n-            db\n-        } else {\n-            self.tcx.sess.diagnostic().struct_dummy()\n-        }\n-    }\n \n     pub fn type_error_message<M>(&self,\n                                  sp: Span,\n@@ -1556,16 +1492,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 -> DiagnosticBuilder<'tcx>\n         where M: FnOnce(String) -> String,\n     {\n+        debug!(\"type_error_struct({:?}, {:?}, {:?})\", sp, actual_ty, err);\n+\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n \n         // Don't report an error if actual type is TyError.\n         if actual_ty.references_error() {\n             return self.tcx.sess.diagnostic().struct_dummy();\n         }\n \n-        self.type_error_struct_str(sp,\n-            move |_e, a| { mk_msg(a) },\n-            self.ty_to_string(actual_ty), err)\n+        let error_str = err.map_or(\"\".to_string(), |t_err| {\n+            format!(\" ({})\", t_err)\n+        });\n+\n+        let msg = mk_msg(self.ty_to_string(actual_ty));\n+\n+        // FIXME: use an error code.\n+        let mut db = self.tcx.sess.struct_span_err(\n+            sp, &format!(\"{} {}\", msg, error_str));\n+\n+        if let Some(err) = err {\n+            self.tcx.note_and_explain_type_err(&mut db, err, sp);\n+        }\n+\n+        db\n     }\n \n     pub fn report_mismatched_types(&self,"}]}