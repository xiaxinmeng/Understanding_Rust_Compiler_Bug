{"sha": "7036449c774860a5b348dbbe01c20704c557382e", "node_id": "C_kwDOAAsO6NoAKDcwMzY0NDljNzc0ODYwYTViMzQ4ZGJiZTAxYzIwNzA0YzU1NzM4MmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-24T10:35:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-24T10:35:00Z"}, "message": "Auto merge of #98447 - JohnTitor:rollup-pponoo3, r=JohnTitor\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #91264 (Add macro support in jump to definition feature)\n - #96955 (Remove (transitive) reliance on sorting by DefId in pretty-printer)\n - #97633 (Session object: Set OS/ABI)\n - #98039 (Fix `panic` message for `BTreeSet`'s `range` API and document `panic` cases)\n - #98214 (rustc_target: Remove some redundant target properties)\n - #98280 (Improve suggestion for calling fn-like expr on type mismatch)\n - #98394 (Fixup missing renames from `#[main]` to `#[rustc_main]`)\n - #98411 (Update tendril)\n - #98419 (Remove excess rib while resolving closures)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "bf75b20f84c59c275530dddb106f817998fa85c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf75b20f84c59c275530dddb106f817998fa85c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7036449c774860a5b348dbbe01c20704c557382e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7036449c774860a5b348dbbe01c20704c557382e", "html_url": "https://github.com/rust-lang/rust/commit/7036449c774860a5b348dbbe01c20704c557382e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7036449c774860a5b348dbbe01c20704c557382e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d017d59ed013a4bc2431d023077eb7209fe9c60d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d017d59ed013a4bc2431d023077eb7209fe9c60d", "html_url": "https://github.com/rust-lang/rust/commit/d017d59ed013a4bc2431d023077eb7209fe9c60d"}, {"sha": "5e98e55668f25cd046073bd67dbcfd6b58ec467e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e98e55668f25cd046073bd67dbcfd6b58ec467e", "html_url": "https://github.com/rust-lang/rust/commit/5e98e55668f25cd046073bd67dbcfd6b58ec467e"}], "stats": {"total": 862, "additions": 603, "deletions": 259}, "files": [{"sha": "1108c1f4d4c2036daada156e006b1863f6aaebbe", "filename": "Cargo.lock", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -1428,9 +1428,9 @@ checksum = \"d79238883cf0307100b90aba4a755d8051a3182305dfe7f649a1e9dc0517006f\"\n \n [[package]]\n name = \"futf\"\n-version = \"0.1.4\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7c9c1ce3fa9336301af935ab852c437817d14cd33690446569392e65170aac3b\"\n+checksum = \"df420e2e84819663797d1ec6544b13c5be84629e7bb00dc960d6917db2987843\"\n dependencies = [\n  \"mac\",\n  \"new_debug_unreachable\",\n@@ -1713,6 +1713,7 @@ version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8c21d40587b92fa6a6c6e3c1bdbf87d75511db5672f9c93175574b3a00df1758\"\n dependencies = [\n+ \"ahash\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n@@ -2571,6 +2572,18 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"object\"\n+version = \"0.29.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n+dependencies = [\n+ \"crc32fast\",\n+ \"hashbrown 0.12.0\",\n+ \"indexmap\",\n+ \"memchr\",\n+]\n+\n [[package]]\n name = \"odht\"\n version = \"0.3.1\"\n@@ -3720,7 +3733,7 @@ dependencies = [\n  \"itertools\",\n  \"jobserver\",\n  \"libc\",\n- \"object 0.28.4\",\n+ \"object 0.29.0\",\n  \"pathdiff\",\n  \"regex\",\n  \"rustc_apfloat\",\n@@ -5191,9 +5204,9 @@ dependencies = [\n \n [[package]]\n name = \"tendril\"\n-version = \"0.4.1\"\n+version = \"0.4.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"707feda9f2582d5d680d733e38755547a3e8fb471e7ba11452ecfd9ce93a5d3b\"\n+checksum = \"d24a120c5fc464a3458240ee02c299ebcb9d67b5249c8848b09d639dca8d7bb0\"\n dependencies = [\n  \"futf\",\n  \"mac\","}, {"sha": "3370146193a522839ec368071b341b9596981840", "filename": "compiler/rustc_ast/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_ast%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_ast%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fentry.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -2,7 +2,7 @@\n pub enum EntryPointType {\n     None,\n     MainNamed,\n-    MainAttr,\n+    RustcMainAttr,\n     Start,\n     OtherMain, // Not an entry point, but some other function named main\n }"}, {"sha": "a08495f7671b05c02584d6d22b36fcd33ea9d3b7", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -147,7 +147,7 @@ fn entry_point_type(sess: &Session, item: &ast::Item, depth: usize) -> EntryPoin\n             if sess.contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n             } else if sess.contains_name(&item.attrs, sym::rustc_main) {\n-                EntryPointType::MainAttr\n+                EntryPointType::RustcMainAttr\n             } else if item.ident.name == sym::main {\n                 if depth == 0 {\n                     // This is a top-level function so can be 'main'\n@@ -177,12 +177,12 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n         let item = noop_flat_map_item(i, self).expect_one(\"noop did something\");\n         self.depth -= 1;\n \n-        // Remove any #[main] or #[start] from the AST so it doesn't\n+        // Remove any #[rustc_main] or #[start] from the AST so it doesn't\n         // clash with the one we're going to add, but mark it as\n         // #[allow(dead_code)] to avoid printing warnings.\n         let item = match entry_point_type(self.sess, &item, self.depth) {\n-            EntryPointType::MainNamed | EntryPointType::MainAttr | EntryPointType::Start => item\n-                .map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n+            EntryPointType::MainNamed | EntryPointType::RustcMainAttr | EntryPointType::Start => {\n+                item.map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n                     let allow_ident = Ident::new(sym::allow, self.def_site);\n                     let dc_nested =\n                         attr::mk_nested_word_item(Ident::new(sym::dead_code, self.def_site));\n@@ -197,7 +197,8 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n                         .collect();\n \n                     ast::Item { id, ident, attrs, kind, vis, span, tokens }\n-                }),\n+                })\n+            }\n             EntryPointType::None | EntryPointType::OtherMain => item,\n         };\n "}, {"sha": "c007728095f79852708a56c28313c3c8cbcbcd96", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -906,7 +906,7 @@ impl<'ll> CodegenCx<'ll, '_> {\n             return eh_catch_typeinfo;\n         }\n         let tcx = self.tcx;\n-        assert!(self.sess().target.is_like_emscripten);\n+        assert!(self.sess().target.os == \"emscripten\");\n         let eh_catch_typeinfo = match tcx.lang_items().eh_catch_typeinfo() {\n             Some(def_id) => self.get_static(def_id),\n             _ => {"}, {"sha": "9f3647492877ccd3eda40354ac6c15e0da5b883a", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -441,7 +441,7 @@ fn try_intrinsic<'ll>(\n         bx.store(bx.const_i32(0), dest, ret_align);\n     } else if wants_msvc_seh(bx.sess()) {\n         codegen_msvc_try(bx, try_func, data, catch_func, dest);\n-    } else if bx.sess().target.is_like_emscripten {\n+    } else if bx.sess().target.os == \"emscripten\" {\n         codegen_emcc_try(bx, try_func, data, catch_func, dest);\n     } else {\n         codegen_gnu_try(bx, try_func, data, catch_func, dest);"}, {"sha": "1bdc473c29b6ee522bbbaa3736602f066ade81ea", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -42,6 +42,6 @@ rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n \n [dependencies.object]\n-version = \"0.28.4\"\n+version = \"0.29.0\"\n default-features = false\n features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\", \"write\"]"}, {"sha": "72aa790c363572e9e3b2903fa85e8b7cfcc2b518", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -2031,7 +2031,7 @@ fn add_order_independent_options(\n \n     add_link_script(cmd, sess, tmpdir, crate_type);\n \n-    if sess.target.is_like_fuchsia && crate_type == CrateType::Executable {\n+    if sess.target.os == \"fuchsia\" && crate_type == CrateType::Executable {\n         let prefix = if sess.opts.debugging_opts.sanitizer.contains(SanitizerSet::ADDRESS) {\n             \"asan/\"\n         } else {\n@@ -2051,7 +2051,7 @@ fn add_order_independent_options(\n         cmd.no_crt_objects();\n     }\n \n-    if sess.target.is_like_emscripten {\n+    if sess.target.os == \"emscripten\" {\n         cmd.arg(\"-s\");\n         cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n             \"DISABLE_EXCEPTION_CATCHING=1\""}, {"sha": "3dd607adee501107a4d434d0003aeb5d11680339", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -130,7 +130,7 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n     };\n \n     let mut file = write::Object::new(binary_format, architecture, endianness);\n-    match architecture {\n+    let e_flags = match architecture {\n         Architecture::Mips => {\n             let arch = match sess.target.options.cpu.as_ref() {\n                 \"mips1\" => elf::EF_MIPS_ARCH_1,\n@@ -149,7 +149,7 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n             if sess.target.options.cpu.contains(\"r6\") {\n                 e_flags |= elf::EF_MIPS_NAN2008;\n             }\n-            file.flags = FileFlags::Elf { e_flags };\n+            e_flags\n         }\n         Architecture::Mips64 => {\n             // copied from `mips64el-linux-gnuabi64-gcc foo.c -c`\n@@ -160,17 +160,26 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n                 } else {\n                     elf::EF_MIPS_ARCH_64R2\n                 };\n-            file.flags = FileFlags::Elf { e_flags };\n+            e_flags\n         }\n         Architecture::Riscv64 if sess.target.options.features.contains(\"+d\") => {\n             // copied from `riscv64-linux-gnu-gcc foo.c -c`, note though\n             // that the `+d` target feature represents whether the double\n             // float abi is enabled.\n             let e_flags = elf::EF_RISCV_RVC | elf::EF_RISCV_FLOAT_ABI_DOUBLE;\n-            file.flags = FileFlags::Elf { e_flags };\n+            e_flags\n         }\n-        _ => {}\n+        _ => 0,\n+    };\n+    // adapted from LLVM's `MCELFObjectTargetWriter::getOSABI`\n+    let os_abi = match sess.target.options.os.as_ref() {\n+        \"hermit\" => elf::ELFOSABI_STANDALONE,\n+        \"freebsd\" => elf::ELFOSABI_FREEBSD,\n+        \"solaris\" => elf::ELFOSABI_SOLARIS,\n+        _ => elf::ELFOSABI_NONE,\n     };\n+    let abi_version = 0;\n+    file.flags = FileFlags::Elf { os_abi, abi_version, e_flags };\n     Some(file)\n }\n "}, {"sha": "555db5846edd09978a5ecfab7a7ac1eb6dc62798", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -133,6 +133,10 @@ impl CStore {\n         CrateNum::new(self.metas.len() - 1)\n     }\n \n+    pub fn has_crate_data(&self, cnum: CrateNum) -> bool {\n+        self.metas[cnum].is_some()\n+    }\n+\n     pub(crate) fn get_crate_data(&self, cnum: CrateNum) -> CrateMetadataRef<'_> {\n         let cdata = self.metas[cnum]\n             .as_ref()"}, {"sha": "200253d575599fd30cb64c86a7dc8889afb1884b", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -5,7 +5,7 @@ use crate::ty::{\n     TypeSuperFoldable,\n };\n use rustc_apfloat::ieee::{Double, Single};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, DefKind, Namespace};\n@@ -779,8 +779,8 @@ pub trait PrettyPrinter<'tcx>:\n         // by looking up the projections associated with the def_id.\n         let bounds = self.tcx().bound_explicit_item_bounds(def_id);\n \n-        let mut traits = BTreeMap::new();\n-        let mut fn_traits = BTreeMap::new();\n+        let mut traits = FxIndexMap::default();\n+        let mut fn_traits = FxIndexMap::default();\n         let mut is_sized = false;\n \n         for predicate in bounds.transpose_iter().map(|e| e.map_bound(|(p, _)| *p)) {\n@@ -856,7 +856,7 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(\")\");\n                     if let Term::Ty(ty) = return_ty.skip_binder() {\n                         if !ty.is_unit() {\n-                            p!(\"-> \", print(return_ty));\n+                            p!(\" -> \", print(return_ty));\n                         }\n                     }\n                     p!(write(\"{}\", if paren_needed { \")\" } else { \"\" }));\n@@ -970,11 +970,11 @@ pub trait PrettyPrinter<'tcx>:\n         &mut self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         proj_ty: Option<(DefId, ty::Binder<'tcx, Term<'tcx>>)>,\n-        traits: &mut BTreeMap<\n+        traits: &mut FxIndexMap<\n             ty::PolyTraitRef<'tcx>,\n-            BTreeMap<DefId, ty::Binder<'tcx, Term<'tcx>>>,\n+            FxIndexMap<DefId, ty::Binder<'tcx, Term<'tcx>>>,\n         >,\n-        fn_traits: &mut BTreeMap<ty::PolyTraitRef<'tcx>, OpaqueFnEntry<'tcx>>,\n+        fn_traits: &mut FxIndexMap<ty::PolyTraitRef<'tcx>, OpaqueFnEntry<'tcx>>,\n     ) {\n         let trait_def_id = trait_ref.def_id();\n \n@@ -1110,19 +1110,18 @@ pub trait PrettyPrinter<'tcx>:\n         // Builtin bounds.\n         // FIXME(eddyb) avoid printing twice (needed to ensure\n         // that the auto traits are sorted *and* printed via cx).\n-        let mut auto_traits: Vec<_> =\n-            predicates.auto_traits().map(|did| (self.tcx().def_path_str(did), did)).collect();\n+        let mut auto_traits: Vec<_> = predicates.auto_traits().collect();\n \n         // The auto traits come ordered by `DefPathHash`. While\n         // `DefPathHash` is *stable* in the sense that it depends on\n         // neither the host nor the phase of the moon, it depends\n         // \"pseudorandomly\" on the compiler version and the target.\n         //\n-        // To avoid that causing instabilities in compiletest\n+        // To avoid causing instabilities in compiletest\n         // output, sort the auto-traits alphabetically.\n-        auto_traits.sort();\n+        auto_traits.sort_by_cached_key(|did| self.tcx().def_path_str(*did));\n \n-        for (_, def_id) in auto_traits {\n+        for def_id in auto_traits {\n             if !first {\n                 p!(\" + \");\n             }"}, {"sha": "f9e67310452a70f399d75deadfdcb89c27be54ac", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -56,7 +56,7 @@ fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> Entry\n     if ctxt.tcx.sess.contains_name(attrs, sym::start) {\n         EntryPointType::Start\n     } else if ctxt.tcx.sess.contains_name(attrs, sym::rustc_main) {\n-        EntryPointType::MainAttr\n+        EntryPointType::RustcMainAttr\n     } else {\n         if let Some(name) = ctxt.tcx.opt_item_name(id.def_id.to_def_id())\n             && name == sym::main {\n@@ -95,21 +95,21 @@ fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n         EntryPointType::OtherMain => {\n             ctxt.non_main_fns.push(ctxt.tcx.def_span(id.def_id));\n         }\n-        EntryPointType::MainAttr => {\n+        EntryPointType::RustcMainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n                 ctxt.attr_main_fn = Some((id.def_id, ctxt.tcx.def_span(id.def_id.to_def_id())));\n             } else {\n                 struct_span_err!(\n                     ctxt.tcx.sess,\n                     ctxt.tcx.def_span(id.def_id.to_def_id()),\n                     E0137,\n-                    \"multiple functions with a `#[main]` attribute\"\n+                    \"multiple functions with a `#[rustc_main]` attribute\"\n                 )\n                 .span_label(\n                     ctxt.tcx.def_span(id.def_id.to_def_id()),\n-                    \"additional `#[main]` function\",\n+                    \"additional `#[rustc_main]` function\",\n                 )\n-                .span_label(ctxt.attr_main_fn.unwrap().1, \"first `#[main]` function\")\n+                .span_label(ctxt.attr_main_fn.unwrap().1, \"first `#[rustc_main]` function\")\n                 .emit();\n             }\n         }"}, {"sha": "3291be05807f6b099d26c7805f1e287e06e0a196", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -17,7 +17,7 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n     if items.eh_personality().is_none() {\n         items.missing.push(LangItem::EhPersonality);\n     }\n-    if tcx.sess.target.is_like_emscripten && items.eh_catch_typeinfo().is_none() {\n+    if tcx.sess.target.os == \"emscripten\" && items.eh_catch_typeinfo().is_none() {\n         items.missing.push(LangItem::EhCatchTypeinfo);\n     }\n "}, {"sha": "640d13ea435478dc8a141b2e1fbf1435e8350431", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -3514,7 +3514,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     })\n                 });\n             }\n-            ExprKind::Async(..) | ExprKind::Closure(..) => {\n+            // For closures, ClosureOrAsyncRibKind is added in visit_fn\n+            ExprKind::Closure(..) => visit::walk_expr(self, expr),\n+            ExprKind::Async(..) => {\n                 self.with_label_rib(ClosureOrAsyncRibKind, |this| visit::walk_expr(this, expr));\n             }\n             ExprKind::Repeat(ref elem, ref ct) => {"}, {"sha": "25842049413bd6a6a9f746afd5e715710bff092c", "filename": "compiler/rustc_target/src/asm/aarch64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -74,7 +74,7 @@ impl AArch64InlineAsmRegClass {\n }\n \n pub fn target_reserves_x18(target: &Target) -> bool {\n-    target.os == \"android\" || target.is_like_fuchsia || target.is_like_osx || target.is_like_windows\n+    target.os == \"android\" || target.os == \"fuchsia\" || target.is_like_osx || target.is_like_windows\n }\n \n fn reserved_x18("}, {"sha": "b64875e32bdd70f9bda3b60909d3cefcab5f7a08", "filename": "compiler/rustc_target/src/spec/fuchsia_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_target%2Fsrc%2Fspec%2Ffuchsia_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_target%2Fsrc%2Fspec%2Ffuchsia_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Ffuchsia_base.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -28,7 +28,6 @@ pub fn opts() -> TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n         families: cvs![\"unix\"],\n-        is_like_fuchsia: true,\n         pre_link_args,\n         pre_link_objects: crt_objects::new(&[\n             (LinkOutputKind::DynamicNoPicExe, &[\"Scrt1.o\"]),"}, {"sha": "da0589cdd20936c7558f6d36bd5c56b8275bed39", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -1273,12 +1273,6 @@ pub struct TargetOptions {\n     ///   - uses SEH-based unwinding,\n     ///   - supports control flow guard mechanism.\n     pub is_like_msvc: bool,\n-    /// Whether the target toolchain is like Emscripten's. Only useful for compiling with\n-    /// Emscripten toolchain.\n-    /// Defaults to false.\n-    pub is_like_emscripten: bool,\n-    /// Whether the target toolchain is like Fuchsia's.\n-    pub is_like_fuchsia: bool,\n     /// Whether a target toolchain is like WASM.\n     pub is_like_wasm: bool,\n     /// Version of DWARF to use if not using the default.\n@@ -1505,9 +1499,7 @@ impl Default for TargetOptions {\n             is_like_osx: false,\n             is_like_solaris: false,\n             is_like_windows: false,\n-            is_like_emscripten: false,\n             is_like_msvc: false,\n-            is_like_fuchsia: false,\n             is_like_wasm: false,\n             dwarf_version: None,\n             linker_is_gnu: true,\n@@ -2112,8 +2104,6 @@ impl Target {\n         key!(is_like_solaris, bool);\n         key!(is_like_windows, bool);\n         key!(is_like_msvc, bool);\n-        key!(is_like_emscripten, bool);\n-        key!(is_like_fuchsia, bool);\n         key!(is_like_wasm, bool);\n         key!(dwarf_version, Option<u32>);\n         key!(linker_is_gnu, bool);\n@@ -2358,8 +2348,6 @@ impl ToJson for Target {\n         target_option_val!(is_like_solaris);\n         target_option_val!(is_like_windows);\n         target_option_val!(is_like_msvc);\n-        target_option_val!(is_like_emscripten);\n-        target_option_val!(is_like_fuchsia);\n         target_option_val!(is_like_wasm);\n         target_option_val!(dwarf_version);\n         target_option_val!(linker_is_gnu);"}, {"sha": "0865ca7ea7df064fc9828d85ee35db9f2c143cce", "filename": "compiler/rustc_target/src/spec/tests/tests_impl.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_target%2Fsrc%2Fspec%2Ftests%2Ftests_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_target%2Fsrc%2Fspec%2Ftests%2Ftests_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Ftests%2Ftests_impl.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -8,7 +8,12 @@ pub(super) fn test_target(target: Target) {\n \n impl Target {\n     fn check_consistency(&self) {\n+        assert_eq!(self.is_like_osx, self.vendor == \"apple\");\n+        assert_eq!(self.is_like_solaris, self.os == \"solaris\" || self.os == \"illumos\");\n+        assert_eq!(self.is_like_windows, self.os == \"windows\" || self.os == \"uefi\");\n+        assert_eq!(self.is_like_wasm, self.arch == \"wasm32\" || self.arch == \"wasm64\");\n         assert!(self.is_like_windows || !self.is_like_msvc);\n+\n         // Check that LLD with the given flavor is treated identically to the linker it emulates.\n         // If your target really needs to deviate from the rules below, except it and document the\n         // reasons."}, {"sha": "f1087db09d132744a6daf667b76ebefcacca9839", "filename": "compiler/rustc_target/src/spec/wasm32_unknown_emscripten.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_emscripten.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -26,7 +26,6 @@ pub fn target() -> Target {\n         // functionality, and a .wasm file.\n         exe_suffix: \".js\".into(),\n         linker: None,\n-        is_like_emscripten: true,\n         panic_strategy: PanicStrategy::Unwind,\n         no_default_libraries: false,\n         post_link_args,"}, {"sha": "7195da863db481718f9105e41c3524320c3fc25b", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 76, "deletions": 113, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -8,15 +8,14 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n-    Expr, ExprKind, GenericBound, ItemKind, Node, Path, QPath, Stmt, StmtKind, TyKind,\n-    WherePredicate,\n+    Expr, ExprKind, GenericBound, Node, Path, QPath, Stmt, StmtKind, TyKind, WherePredicate,\n };\n use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Binder, IsSuggestable, ToPredicate, Ty};\n-use rustc_span::symbol::{kw, sym};\n+use rustc_middle::ty::{self, Binder, IsSuggestable, Subst, ToPredicate, Ty};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n \n@@ -78,124 +77,88 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) -> bool {\n-        let hir = self.tcx.hir();\n-        let (def_id, sig) = match *found.kind() {\n-            ty::FnDef(def_id, _) => (def_id, found.fn_sig(self.tcx)),\n-            ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig()),\n+        let (def_id, output, inputs) = match *found.kind() {\n+            ty::FnDef(def_id, _) => {\n+                let fn_sig = found.fn_sig(self.tcx);\n+                (def_id, fn_sig.output(), fn_sig.inputs().skip_binder().len())\n+            }\n+            ty::Closure(def_id, substs) => {\n+                let fn_sig = substs.as_closure().sig();\n+                (def_id, fn_sig.output(), fn_sig.inputs().skip_binder().len() - 1)\n+            }\n+            ty::Opaque(def_id, substs) => {\n+                let sig = self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n+                    if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                    && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                    // args tuple will always be substs[1]\n+                    && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                    {\n+                        Some((\n+                            pred.kind().rebind(proj.term.ty().unwrap()),\n+                            args.len(),\n+                        ))\n+                    } else {\n+                        None\n+                    }\n+                });\n+                if let Some((output, inputs)) = sig {\n+                    (def_id, output, inputs)\n+                } else {\n+                    return false;\n+                }\n+            }\n             _ => return false,\n         };\n \n-        let sig = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, sig);\n-        let sig = self.normalize_associated_types_in(expr.span, sig);\n-        if self.can_coerce(sig.output(), expected) {\n-            let (mut sugg_call, applicability) = if sig.inputs().is_empty() {\n-                (String::new(), Applicability::MachineApplicable)\n-            } else {\n-                (\"...\".to_string(), Applicability::HasPlaceholders)\n+        let output = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, output);\n+        let output = self.normalize_associated_types_in(expr.span, output);\n+        if !output.is_ty_var() && self.can_coerce(output, expected) {\n+            let (sugg_call, mut applicability) = match inputs {\n+                0 => (\"\".to_string(), Applicability::MachineApplicable),\n+                1..=4 => (\n+                    (0..inputs).map(|_| \"_\").collect::<Vec<_>>().join(\", \"),\n+                    Applicability::MachineApplicable,\n+                ),\n+                _ => (\"...\".to_string(), Applicability::HasPlaceholders),\n             };\n-            let mut msg = \"call this function\";\n-            match hir.get_if_local(def_id) {\n-                Some(\n-                    Node::Item(hir::Item { kind: ItemKind::Fn(.., body_id), .. })\n-                    | Node::ImplItem(hir::ImplItem {\n-                        kind: hir::ImplItemKind::Fn(_, body_id), ..\n-                    })\n-                    | Node::TraitItem(hir::TraitItem {\n-                        kind: hir::TraitItemKind::Fn(.., hir::TraitFn::Provided(body_id)),\n-                        ..\n-                    }),\n-                ) => {\n-                    let body = hir.body(*body_id);\n-                    sugg_call = body\n-                        .params\n-                        .iter()\n-                        .map(|param| match &param.pat.kind {\n-                            hir::PatKind::Binding(_, _, ident, None)\n-                                if ident.name != kw::SelfLower =>\n-                            {\n-                                ident.to_string()\n-                            }\n-                            _ => \"_\".to_string(),\n-                        })\n-                        .collect::<Vec<_>>()\n-                        .join(\", \");\n-                }\n-                Some(Node::Expr(hir::Expr {\n-                    kind: ExprKind::Closure { body: body_id, .. },\n-                    span: full_closure_span,\n-                    ..\n-                })) => {\n-                    if *full_closure_span == expr.span {\n-                        return false;\n-                    }\n-                    msg = \"call this closure\";\n-                    let body = hir.body(*body_id);\n-                    sugg_call = body\n-                        .params\n-                        .iter()\n-                        .map(|param| match &param.pat.kind {\n-                            hir::PatKind::Binding(_, _, ident, None)\n-                                if ident.name != kw::SelfLower =>\n-                            {\n-                                ident.to_string()\n-                            }\n-                            _ => \"_\".to_string(),\n-                        })\n-                        .collect::<Vec<_>>()\n-                        .join(\", \");\n-                }\n-                Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n-                    sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n-                    match def_id.as_local().map(|def_id| self.tcx.def_kind(def_id)) {\n-                        Some(DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n-                            msg = \"instantiate this tuple variant\";\n-                        }\n-                        Some(DefKind::Ctor(CtorOf::Struct, _)) => {\n-                            msg = \"instantiate this tuple struct\";\n-                        }\n-                        _ => {}\n-                    }\n+\n+            let msg = match self.tcx.def_kind(def_id) {\n+                DefKind::Fn => \"call this function\",\n+                DefKind::Closure | DefKind::OpaqueTy => \"call this closure\",\n+                DefKind::Ctor(CtorOf::Struct, _) => \"instantiate this tuple struct\",\n+                DefKind::Ctor(CtorOf::Variant, _) => \"instantiate this tuple variant\",\n+                _ => \"call this function\",\n+            };\n+\n+            let sugg = match expr.kind {\n+                hir::ExprKind::Call(..)\n+                | hir::ExprKind::Path(..)\n+                | hir::ExprKind::Index(..)\n+                | hir::ExprKind::Lit(..) => {\n+                    vec![(expr.span.shrink_to_hi(), format!(\"({sugg_call})\"))]\n                 }\n-                Some(Node::ForeignItem(hir::ForeignItem {\n-                    kind: hir::ForeignItemKind::Fn(_, idents, _),\n-                    ..\n-                })) => {\n-                    sugg_call = idents\n-                        .iter()\n-                        .map(|ident| {\n-                            if ident.name != kw::SelfLower {\n-                                ident.to_string()\n-                            } else {\n-                                \"_\".to_string()\n-                            }\n-                        })\n-                        .collect::<Vec<_>>()\n-                        .join(\", \")\n+                hir::ExprKind::Closure { .. } => {\n+                    // Might be `{ expr } || { bool }`\n+                    applicability = Applicability::MaybeIncorrect;\n+                    vec![\n+                        (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                        (expr.span.shrink_to_hi(), format!(\")({sugg_call})\")),\n+                    ]\n                 }\n-                Some(Node::TraitItem(hir::TraitItem {\n-                    kind: hir::TraitItemKind::Fn(.., hir::TraitFn::Required(idents)),\n-                    ..\n-                })) => {\n-                    sugg_call = idents\n-                        .iter()\n-                        .map(|ident| {\n-                            if ident.name != kw::SelfLower {\n-                                ident.to_string()\n-                            } else {\n-                                \"_\".to_string()\n-                            }\n-                        })\n-                        .collect::<Vec<_>>()\n-                        .join(\", \")\n+                _ => {\n+                    vec![\n+                        (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                        (expr.span.shrink_to_hi(), format!(\")({sugg_call})\")),\n+                    ]\n                 }\n-                _ => {}\n-            }\n-            err.span_suggestion_verbose(\n-                expr.span.shrink_to_hi(),\n-                &format!(\"use parentheses to {}\", msg),\n-                format!(\"({})\", sugg_call),\n+            };\n+\n+            err.multipart_suggestion_verbose(\n+                format!(\"use parentheses to {msg}\"),\n+                sugg,\n                 applicability,\n             );\n+\n             return true;\n         }\n         false"}, {"sha": "0bddd7a9906994e2f1316281b6df92137782a36e", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -16,6 +16,7 @@ use super::dedup_sorted_iter::DedupSortedIter;\n use super::navigate::{LazyLeafRange, LeafRange};\n use super::node::{self, marker, ForceResult::*, Handle, NodeRef, Root};\n use super::search::SearchResult::*;\n+use super::set_val::SetValZST;\n \n mod entry;\n \n@@ -271,7 +272,7 @@ impl<K: Clone, V: Clone, A: Allocator + Clone> Clone for BTreeMap<K, V, A> {\n     }\n }\n \n-impl<K, Q: ?Sized, A: Allocator + Clone> super::Recover<Q> for BTreeMap<K, (), A>\n+impl<K, Q: ?Sized, A: Allocator + Clone> super::Recover<Q> for BTreeMap<K, SetValZST, A>\n where\n     K: Borrow<Q> + Ord,\n     Q: Ord,\n@@ -318,7 +319,7 @@ where\n                     alloc: (*map.alloc).clone(),\n                     _marker: PhantomData,\n                 }\n-                .insert(());\n+                .insert(SetValZST::default());\n                 None\n             }\n         }"}, {"sha": "4c372b1d60ac4f8fa7b693b6097bef19ef706985", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -897,6 +897,39 @@ fn test_range_mut() {\n     map.check();\n }\n \n+#[should_panic(expected = \"range start is greater than range end in BTreeMap\")]\n+#[test]\n+fn test_range_panic_1() {\n+    let mut map = BTreeMap::new();\n+    map.insert(3, \"a\");\n+    map.insert(5, \"b\");\n+    map.insert(8, \"c\");\n+\n+    let _invalid_range = map.range((Included(&8), Included(&3)));\n+}\n+\n+#[should_panic(expected = \"range start and end are equal and excluded in BTreeMap\")]\n+#[test]\n+fn test_range_panic_2() {\n+    let mut map = BTreeMap::new();\n+    map.insert(3, \"a\");\n+    map.insert(5, \"b\");\n+    map.insert(8, \"c\");\n+\n+    let _invalid_range = map.range((Excluded(&5), Excluded(&5)));\n+}\n+\n+#[should_panic(expected = \"range start and end are equal and excluded in BTreeMap\")]\n+#[test]\n+fn test_range_panic_3() {\n+    let mut map: BTreeMap<i32, ()> = BTreeMap::new();\n+    map.insert(3, ());\n+    map.insert(5, ());\n+    map.insert(8, ());\n+\n+    let _invalid_range = map.range((Excluded(&5), Excluded(&5)));\n+}\n+\n #[test]\n fn test_retain() {\n     let mut map = BTreeMap::from_iter((0..100).map(|x| (x, x * 10)));"}, {"sha": "9d43ac5c5be5992599fa815d4c9cf6d98c78f9c0", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -10,6 +10,7 @@ mod node;\n mod remove;\n mod search;\n pub mod set;\n+mod set_val;\n mod split;\n \n #[doc(hidden)]"}, {"sha": "ad3522b4e0418bf69e3dfaf24af7fe6d49d99dcb", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -97,17 +97,28 @@ impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Lea\n         K: Borrow<Q>,\n         R: RangeBounds<Q>,\n     {\n+        // Determine if map or set is being searched\n+        let is_set = <V as super::set_val::IsSetVal>::is_set_val();\n+\n         // Inlining these variables should be avoided. We assume the bounds reported by `range`\n         // remain the same, but an adversarial implementation could change between calls (#81138).\n         let (start, end) = (range.start_bound(), range.end_bound());\n         match (start, end) {\n             (Bound::Excluded(s), Bound::Excluded(e)) if s == e => {\n-                panic!(\"range start and end are equal and excluded in BTreeMap\")\n+                if is_set {\n+                    panic!(\"range start and end are equal and excluded in BTreeSet\")\n+                } else {\n+                    panic!(\"range start and end are equal and excluded in BTreeMap\")\n+                }\n             }\n             (Bound::Included(s) | Bound::Excluded(s), Bound::Included(e) | Bound::Excluded(e))\n                 if s > e =>\n             {\n-                panic!(\"range start is greater than range end in BTreeMap\")\n+                if is_set {\n+                    panic!(\"range start is greater than range end in BTreeSet\")\n+                } else {\n+                    panic!(\"range start is greater than range end in BTreeMap\")\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "2cfc0807409211e4ad56371bf30568a22085e256", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -13,6 +13,7 @@ use core::ops::{BitAnd, BitOr, BitXor, RangeBounds, Sub};\n \n use super::map::{BTreeMap, Keys};\n use super::merge_iter::MergeIterInner;\n+use super::set_val::SetValZST;\n use super::Recover;\n \n use crate::alloc::{Allocator, Global};\n@@ -81,7 +82,7 @@ pub struct BTreeSet<\n     T,\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > {\n-    map: BTreeMap<T, (), A>,\n+    map: BTreeMap<T, SetValZST, A>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -135,7 +136,7 @@ impl<T: Clone, A: Allocator + Clone> Clone for BTreeSet<T, A> {\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    iter: Keys<'a, T, ()>,\n+    iter: Keys<'a, T, SetValZST>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -158,7 +159,7 @@ pub struct IntoIter<\n     T,\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n > {\n-    iter: super::map::IntoIter<T, (), A>,\n+    iter: super::map::IntoIter<T, SetValZST, A>,\n }\n \n /// An iterator over a sub-range of items in a `BTreeSet`.\n@@ -171,7 +172,7 @@ pub struct IntoIter<\n #[derive(Debug)]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, T: 'a> {\n-    iter: super::map::Range<'a, T, ()>,\n+    iter: super::map::Range<'a, T, SetValZST>,\n }\n \n /// A lazy iterator producing elements in the difference of `BTreeSet`s.\n@@ -375,6 +376,11 @@ impl<T, A: Allocator + Clone> BTreeSet<T, A> {\n     /// `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive\n     /// range from 4 to 10.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if range `start > end`.\n+    /// Panics if range `start == end` and both bounds are `Excluded`.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -905,7 +911,7 @@ impl<T, A: Allocator + Clone> BTreeSet<T, A> {\n     where\n         T: Ord,\n     {\n-        self.map.insert(value, ()).is_none()\n+        self.map.insert(value, SetValZST::default()).is_none()\n     }\n \n     /// Adds a value to the set, replacing the existing element, if any, that is\n@@ -1210,7 +1216,7 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n \n impl<T: Ord, A: Allocator + Clone> BTreeSet<T, A> {\n     fn from_sorted_iter<I: Iterator<Item = T>>(iter: I, alloc: A) -> BTreeSet<T, A> {\n-        let iter = iter.map(|k| (k, ()));\n+        let iter = iter.map(|k| (k, SetValZST::default()));\n         let map = BTreeMap::bulk_build_from_sorted_iter(iter, alloc);\n         BTreeSet { map }\n     }\n@@ -1234,7 +1240,7 @@ impl<T: Ord, const N: usize> From<[T; N]> for BTreeSet<T> {\n \n         // use stable sort to preserve the insertion order.\n         arr.sort();\n-        let iter = IntoIterator::into_iter(arr).map(|k| (k, ()));\n+        let iter = IntoIterator::into_iter(arr).map(|k| (k, SetValZST::default()));\n         let map = BTreeMap::bulk_build_from_sorted_iter(iter, Global);\n         BTreeSet { map }\n     }\n@@ -1284,7 +1290,7 @@ pub struct DrainFilter<\n     F: 'a + FnMut(&T) -> bool,\n {\n     pred: F,\n-    inner: super::map::DrainFilterInner<'a, T, ()>,\n+    inner: super::map::DrainFilterInner<'a, T, SetValZST>,\n     /// The BTreeMap will outlive this IntoIter so we don't care about drop order for `alloc`.\n     alloc: A,\n }\n@@ -1319,7 +1325,7 @@ where\n \n     fn next(&mut self) -> Option<T> {\n         let pred = &mut self.pred;\n-        let mut mapped_pred = |k: &T, _v: &mut ()| pred(k);\n+        let mut mapped_pred = |k: &T, _v: &mut SetValZST| pred(k);\n         self.inner.next(&mut mapped_pred, self.alloc.clone()).map(|(k, _)| k)\n     }\n "}, {"sha": "502d3e1d1266754a093d26b9c0852a5c5927c20d", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -5,6 +5,7 @@ use crate::vec::Vec;\n use std::cmp::Ordering;\n use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n+use std::ops::Bound::{Excluded, Included};\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n #[test]\n@@ -831,3 +832,25 @@ fn from_array() {\n     let unordered_duplicates = BTreeSet::from([4, 1, 4, 3, 2]);\n     assert_eq!(set, unordered_duplicates);\n }\n+\n+#[should_panic(expected = \"range start is greater than range end in BTreeSet\")]\n+#[test]\n+fn test_range_panic_1() {\n+    let mut set = BTreeSet::new();\n+    set.insert(3);\n+    set.insert(5);\n+    set.insert(8);\n+\n+    let _invalid_range = set.range((Included(&8), Included(&3)));\n+}\n+\n+#[should_panic(expected = \"range start and end are equal and excluded in BTreeSet\")]\n+#[test]\n+fn test_range_panic_2() {\n+    let mut set = BTreeSet::new();\n+    set.insert(3);\n+    set.insert(5);\n+    set.insert(8);\n+\n+    let _invalid_range = set.range((Excluded(&5), Excluded(&5)));\n+}"}, {"sha": "80c459bcf81db41471ebf7a6c93279fbffc4c237", "filename": "library/alloc/src/collections/btree/set_val.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset_val.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -0,0 +1,29 @@\n+/// Zero-Sized Type (ZST) for internal `BTreeSet` values.\n+/// Used instead of `()` to differentiate between:\n+/// * `BTreeMap<T, ()>` (possible user-defined map)\n+/// * `BTreeMap<T, SetValZST>` (internal set representation)\n+#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Default)]\n+pub struct SetValZST;\n+\n+/// A trait to differentiate between `BTreeMap` and `BTreeSet` values.\n+/// Returns `true` only for type `SetValZST`, `false` for all other types (blanket implementation).\n+/// `TypeId` requires a `'static` lifetime, use of this trait avoids that restriction.\n+///\n+/// [`TypeId`]: std::any::TypeId\n+pub trait IsSetVal {\n+    fn is_set_val() -> bool;\n+}\n+\n+// Blanket implementation\n+impl<V> IsSetVal for V {\n+    default fn is_set_val() -> bool {\n+        false\n+    }\n+}\n+\n+// Specialization\n+impl IsSetVal for SetValZST {\n+    fn is_set_val() -> bool {\n+        true\n+    }\n+}"}, {"sha": "056eda089c1de6b8c7003e39113c0ae71cda304a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -8,14 +8,16 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::fmt;\n-use std::iter;\n+use std::iter::{self, once};\n \n+use rustc_ast as ast;\n use rustc_attr::{ConstStability, StabilityLevel};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n+use rustc_metadata::creader::{CStore, LoadedMacro};\n use rustc_middle::ty;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::ty::TyCtxt;\n@@ -519,6 +521,7 @@ impl clean::GenericArgs {\n }\n \n // Possible errors when computing href link source for a `DefId`\n+#[derive(PartialEq, Eq)]\n pub(crate) enum HrefError {\n     /// This item is known to rustdoc, but from a crate that does not have documentation generated.\n     ///\n@@ -556,6 +559,79 @@ pub(crate) fn join_with_double_colon(syms: &[Symbol]) -> String {\n     s\n }\n \n+/// This function is to get the external macro path because they are not in the cache used in\n+/// `href_with_root_path`.\n+fn generate_macro_def_id_path(\n+    def_id: DefId,\n+    cx: &Context<'_>,\n+    root_path: Option<&str>,\n+) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n+    let tcx = cx.shared.tcx;\n+    let crate_name = tcx.crate_name(def_id.krate).to_string();\n+    let cache = cx.cache();\n+\n+    let fqp: Vec<Symbol> = tcx\n+        .def_path(def_id)\n+        .data\n+        .into_iter()\n+        .filter_map(|elem| {\n+            // extern blocks (and a few others things) have an empty name.\n+            match elem.data.get_opt_name() {\n+                Some(s) if !s.is_empty() => Some(s),\n+                _ => None,\n+            }\n+        })\n+        .collect();\n+    let relative = fqp.iter().map(|elem| elem.to_string());\n+    let cstore = CStore::from_tcx(tcx);\n+    // We need this to prevent a `panic` when this function is used from intra doc links...\n+    if !cstore.has_crate_data(def_id.krate) {\n+        debug!(\"No data for crate {}\", crate_name);\n+        return Err(HrefError::NotInExternalCache);\n+    }\n+    // Check to see if it is a macro 2.0 or built-in macro.\n+    // More information in <https://rust-lang.github.io/rfcs/1584-macros.html>.\n+    let is_macro_2 = match cstore.load_macro_untracked(def_id, tcx.sess) {\n+        LoadedMacro::MacroDef(def, _) => {\n+            // If `ast_def.macro_rules` is `true`, then it's not a macro 2.0.\n+            matches!(&def.kind, ast::ItemKind::MacroDef(ast_def) if !ast_def.macro_rules)\n+        }\n+        _ => false,\n+    };\n+\n+    let mut path = if is_macro_2 {\n+        once(crate_name.clone()).chain(relative).collect()\n+    } else {\n+        vec![crate_name.clone(), relative.last().unwrap()]\n+    };\n+    if path.len() < 2 {\n+        // The minimum we can have is the crate name followed by the macro name. If shorter, then\n+        // it means that that `relative` was empty, which is an error.\n+        debug!(\"macro path cannot be empty!\");\n+        return Err(HrefError::NotInExternalCache);\n+    }\n+\n+    if let Some(last) = path.last_mut() {\n+        *last = format!(\"macro.{}.html\", last);\n+    }\n+\n+    let url = match cache.extern_locations[&def_id.krate] {\n+        ExternalLocation::Remote(ref s) => {\n+            // `ExternalLocation::Remote` always end with a `/`.\n+            format!(\"{}{}\", s, path.join(\"/\"))\n+        }\n+        ExternalLocation::Local => {\n+            // `root_path` always end with a `/`.\n+            format!(\"{}{}/{}\", root_path.unwrap_or(\"\"), crate_name, path.join(\"/\"))\n+        }\n+        ExternalLocation::Unknown => {\n+            debug!(\"crate {} not in cache when linkifying macros\", crate_name);\n+            return Err(HrefError::NotInExternalCache);\n+        }\n+    };\n+    Ok((url, ItemType::Macro, fqp))\n+}\n+\n pub(crate) fn href_with_root_path(\n     did: DefId,\n     cx: &Context<'_>,\n@@ -611,6 +687,8 @@ pub(crate) fn href_with_root_path(\n                         ExternalLocation::Unknown => return Err(HrefError::DocumentationNotBuilt),\n                     },\n                 )\n+            } else if matches!(def_kind, DefKind::Macro(_)) {\n+                return generate_macro_def_id_path(did, cx, root_path);\n             } else {\n                 return Err(HrefError::NotInExternalCache);\n             }"}, {"sha": "d2ef89078bf6d131751c33f49267359336fa8619", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 83, "deletions": 32, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -22,7 +22,7 @@ use super::format::{self, Buffer};\n use super::render::LinkFromSrc;\n \n /// This type is needed in case we want to render links on items to allow to go to their definition.\n-pub(crate) struct ContextInfo<'a, 'b, 'c> {\n+pub(crate) struct HrefContext<'a, 'b, 'c> {\n     pub(crate) context: &'a Context<'b>,\n     /// This span contains the current file we're going through.\n     pub(crate) file_span: Span,\n@@ -44,7 +44,7 @@ pub(crate) fn render_with_highlighting(\n     tooltip: Option<(Option<Edition>, &str)>,\n     edition: Edition,\n     extra_content: Option<Buffer>,\n-    context_info: Option<ContextInfo<'_, '_, '_>>,\n+    href_context: Option<HrefContext<'_, '_, '_>>,\n     decoration_info: Option<DecorationInfo>,\n ) {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n@@ -62,7 +62,7 @@ pub(crate) fn render_with_highlighting(\n     }\n \n     write_header(out, class, extra_content);\n-    write_code(out, src, edition, context_info, decoration_info);\n+    write_code(out, src, edition, href_context, decoration_info);\n     write_footer(out, playground_button);\n }\n \n@@ -85,31 +85,36 @@ fn write_header(out: &mut Buffer, class: Option<&str>, extra_content: Option<Buf\n ///\n /// Some explanations on the last arguments:\n ///\n-/// In case we are rendering a code block and not a source code file, `context_info` will be `None`.\n-/// To put it more simply: if `context_info` is `None`, the code won't try to generate links to an\n+/// In case we are rendering a code block and not a source code file, `href_context` will be `None`.\n+/// To put it more simply: if `href_context` is `None`, the code won't try to generate links to an\n /// item definition.\n ///\n /// More explanations about spans and how we use them here are provided in the\n fn write_code(\n     out: &mut Buffer,\n     src: &str,\n     edition: Edition,\n-    context_info: Option<ContextInfo<'_, '_, '_>>,\n+    href_context: Option<HrefContext<'_, '_, '_>>,\n     decoration_info: Option<DecorationInfo>,\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n+    let mut closing_tags: Vec<&'static str> = Vec::new();\n     Classifier::new(\n         &src,\n         edition,\n-        context_info.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),\n+        href_context.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),\n         decoration_info,\n     )\n     .highlight(&mut |highlight| {\n         match highlight {\n-            Highlight::Token { text, class } => string(out, Escape(text), class, &context_info),\n-            Highlight::EnterSpan { class } => enter_span(out, class),\n-            Highlight::ExitSpan => exit_span(out),\n+            Highlight::Token { text, class } => string(out, Escape(text), class, &href_context),\n+            Highlight::EnterSpan { class } => {\n+                closing_tags.push(enter_span(out, class, &href_context))\n+            }\n+            Highlight::ExitSpan => {\n+                exit_span(out, closing_tags.pop().expect(\"ExitSpan without EnterSpan\"))\n+            }\n         };\n     });\n }\n@@ -129,7 +134,7 @@ enum Class {\n     RefKeyWord,\n     Self_(Span),\n     Op,\n-    Macro,\n+    Macro(Span),\n     MacroNonTerminal,\n     String,\n     Number,\n@@ -153,7 +158,7 @@ impl Class {\n             Class::RefKeyWord => \"kw-2\",\n             Class::Self_(_) => \"self\",\n             Class::Op => \"op\",\n-            Class::Macro => \"macro\",\n+            Class::Macro(_) => \"macro\",\n             Class::MacroNonTerminal => \"macro-nonterminal\",\n             Class::String => \"string\",\n             Class::Number => \"number\",\n@@ -171,8 +176,22 @@ impl Class {\n     /// a \"span\" (a tuple representing `(lo, hi)` equivalent of `Span`).\n     fn get_span(self) -> Option<Span> {\n         match self {\n-            Self::Ident(sp) | Self::Self_(sp) => Some(sp),\n-            _ => None,\n+            Self::Ident(sp) | Self::Self_(sp) | Self::Macro(sp) => Some(sp),\n+            Self::Comment\n+            | Self::DocComment\n+            | Self::Attribute\n+            | Self::KeyWord\n+            | Self::RefKeyWord\n+            | Self::Op\n+            | Self::MacroNonTerminal\n+            | Self::String\n+            | Self::Number\n+            | Self::Bool\n+            | Self::Lifetime\n+            | Self::PreludeTy\n+            | Self::PreludeVal\n+            | Self::QuestionMark\n+            | Self::Decoration(_) => None,\n         }\n     }\n }\n@@ -611,7 +630,7 @@ impl<'a> Classifier<'a> {\n             },\n             TokenKind::Ident | TokenKind::RawIdent if lookahead == Some(TokenKind::Bang) => {\n                 self.in_macro = true;\n-                sink(Highlight::EnterSpan { class: Class::Macro });\n+                sink(Highlight::EnterSpan { class: Class::Macro(self.new_span(before, text)) });\n                 sink(Highlight::Token { text, class: None });\n                 return;\n             }\n@@ -658,13 +677,20 @@ impl<'a> Classifier<'a> {\n \n /// Called when we start processing a span of text that should be highlighted.\n /// The `Class` argument specifies how it should be highlighted.\n-fn enter_span(out: &mut Buffer, klass: Class) {\n-    write!(out, \"<span class=\\\"{}\\\">\", klass.as_html());\n+fn enter_span(\n+    out: &mut Buffer,\n+    klass: Class,\n+    href_context: &Option<HrefContext<'_, '_, '_>>,\n+) -> &'static str {\n+    string_without_closing_tag(out, \"\", Some(klass), href_context).expect(\n+        \"internal error: enter_span was called with Some(klass) but did not return a \\\n+            closing HTML tag\",\n+    )\n }\n \n /// Called at the end of a span of highlighted text.\n-fn exit_span(out: &mut Buffer) {\n-    out.write_str(\"</span>\");\n+fn exit_span(out: &mut Buffer, closing_tag: &str) {\n+    out.write_str(closing_tag);\n }\n \n /// Called for a span of text. If the text should be highlighted differently\n@@ -687,15 +713,39 @@ fn string<T: Display>(\n     out: &mut Buffer,\n     text: T,\n     klass: Option<Class>,\n-    context_info: &Option<ContextInfo<'_, '_, '_>>,\n+    href_context: &Option<HrefContext<'_, '_, '_>>,\n ) {\n+    if let Some(closing_tag) = string_without_closing_tag(out, text, klass, href_context) {\n+        out.write_str(closing_tag);\n+    }\n+}\n+\n+/// This function writes `text` into `out` with some modifications depending on `klass`:\n+///\n+/// * If `klass` is `None`, `text` is written into `out` with no modification.\n+/// * If `klass` is `Some` but `klass.get_span()` is `None`, it writes the text wrapped in a\n+///   `<span>` with the provided `klass`.\n+/// * If `klass` is `Some` and has a [`rustc_span::Span`], it then tries to generate a link (`<a>`\n+///   element) by retrieving the link information from the `span_correspondance_map` that was filled\n+///   in `span_map.rs::collect_spans_and_sources`. If it cannot retrieve the information, then it's\n+///   the same as the second point (`klass` is `Some` but doesn't have a [`rustc_span::Span`]).\n+fn string_without_closing_tag<T: Display>(\n+    out: &mut Buffer,\n+    text: T,\n+    klass: Option<Class>,\n+    href_context: &Option<HrefContext<'_, '_, '_>>,\n+) -> Option<&'static str> {\n     let Some(klass) = klass\n-    else { return write!(out, \"{}\", text) };\n+    else {\n+        write!(out, \"{}\", text);\n+        return None;\n+    };\n     let Some(def_span) = klass.get_span()\n     else {\n-        write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text);\n-        return;\n+        write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text);\n+        return Some(\"</span>\");\n     };\n+\n     let mut text_s = text.to_string();\n     if text_s.contains(\"::\") {\n         text_s = text_s.split(\"::\").intersperse(\"::\").fold(String::new(), |mut path, t| {\n@@ -715,10 +765,10 @@ fn string<T: Display>(\n             path\n         });\n     }\n-    if let Some(context_info) = context_info {\n+    if let Some(href_context) = href_context {\n         if let Some(href) =\n-            context_info.context.shared.span_correspondance_map.get(&def_span).and_then(|href| {\n-                let context = context_info.context;\n+            href_context.context.shared.span_correspondance_map.get(&def_span).and_then(|href| {\n+                let context = href_context.context;\n                 // FIXME: later on, it'd be nice to provide two links (if possible) for all items:\n                 // one to the documentation page and one to the source definition.\n                 // FIXME: currently, external items only generate a link to their documentation,\n@@ -727,27 +777,28 @@ fn string<T: Display>(\n                 match href {\n                     LinkFromSrc::Local(span) => context\n                         .href_from_span(*span, true)\n-                        .map(|s| format!(\"{}{}\", context_info.root_path, s)),\n+                        .map(|s| format!(\"{}{}\", href_context.root_path, s)),\n                     LinkFromSrc::External(def_id) => {\n-                        format::href_with_root_path(*def_id, context, Some(context_info.root_path))\n+                        format::href_with_root_path(*def_id, context, Some(href_context.root_path))\n                             .ok()\n                             .map(|(url, _, _)| url)\n                     }\n                     LinkFromSrc::Primitive(prim) => format::href_with_root_path(\n                         PrimitiveType::primitive_locations(context.tcx())[prim],\n                         context,\n-                        Some(context_info.root_path),\n+                        Some(href_context.root_path),\n                     )\n                     .ok()\n                     .map(|(url, _, _)| url),\n                 }\n             })\n         {\n-            write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}</a>\", klass.as_html(), href, text_s);\n-            return;\n+            write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}\", klass.as_html(), href, text_s);\n+            return Some(\"</a>\");\n         }\n     }\n-    write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text_s);\n+    write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text_s);\n+    Some(\"</span>\")\n }\n \n #[cfg(test)]"}, {"sha": "34d590fb2448c553a7f3f271c1e1f81dd8538ea8", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 66, "deletions": 17, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -8,7 +8,8 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{ExprKind, HirId, Mod, Node};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::Span;\n+use rustc_span::hygiene::MacroKind;\n+use rustc_span::{BytePos, ExpnKind, Span};\n \n use std::path::{Path, PathBuf};\n \n@@ -63,33 +64,72 @@ struct SpanMapVisitor<'tcx> {\n \n impl<'tcx> SpanMapVisitor<'tcx> {\n     /// This function is where we handle `hir::Path` elements and add them into the \"span map\".\n-    fn handle_path(&mut self, path: &rustc_hir::Path<'_>, path_span: Option<Span>) {\n+    fn handle_path(&mut self, path: &rustc_hir::Path<'_>) {\n         let info = match path.res {\n-            // FIXME: For now, we only handle `DefKind` if it's not `DefKind::TyParam` or\n-            // `DefKind::Macro`. Would be nice to support them too alongside the other `DefKind`\n+            // FIXME: For now, we handle `DefKind` if it's not a `DefKind::TyParam`.\n+            // Would be nice to support them too alongside the other `DefKind`\n             // (such as primitive types!).\n-            Res::Def(kind, def_id) if kind != DefKind::TyParam => {\n-                if matches!(kind, DefKind::Macro(_)) {\n-                    return;\n-                }\n-                Some(def_id)\n-            }\n+            Res::Def(kind, def_id) if kind != DefKind::TyParam => Some(def_id),\n             Res::Local(_) => None,\n             Res::PrimTy(p) => {\n                 // FIXME: Doesn't handle \"path-like\" primitives like arrays or tuples.\n-                let span = path_span.unwrap_or(path.span);\n-                self.matches.insert(span, LinkFromSrc::Primitive(PrimitiveType::from(p)));\n+                self.matches.insert(path.span, LinkFromSrc::Primitive(PrimitiveType::from(p)));\n                 return;\n             }\n             Res::Err => return,\n             _ => return,\n         };\n         if let Some(span) = self.tcx.hir().res_span(path.res) {\n-            self.matches\n-                .insert(path_span.unwrap_or(path.span), LinkFromSrc::Local(clean::Span::new(span)));\n+            self.matches.insert(path.span, LinkFromSrc::Local(clean::Span::new(span)));\n         } else if let Some(def_id) = info {\n-            self.matches.insert(path_span.unwrap_or(path.span), LinkFromSrc::External(def_id));\n+            self.matches.insert(path.span, LinkFromSrc::External(def_id));\n+        }\n+    }\n+\n+    /// Adds the macro call into the span map. Returns `true` if the `span` was inside a macro\n+    /// expansion, whether or not it was added to the span map.\n+    ///\n+    /// The idea for the macro support is to check if the current `Span` comes from expansion. If\n+    /// so, we loop until we find the macro definition by using `outer_expn_data` in a loop.\n+    /// Finally, we get the information about the macro itself (`span` if \"local\", `DefId`\n+    /// otherwise) and store it inside the span map.\n+    fn handle_macro(&mut self, span: Span) -> bool {\n+        if !span.from_expansion() {\n+            return false;\n+        }\n+        // So if the `span` comes from a macro expansion, we need to get the original\n+        // macro's `DefId`.\n+        let mut data = span.ctxt().outer_expn_data();\n+        let mut call_site = data.call_site;\n+        // Macros can expand to code containing macros, which will in turn be expanded, etc.\n+        // So the idea here is to \"go up\" until we're back to code that was generated from\n+        // macro expansion so that we can get the `DefId` of the original macro that was at the\n+        // origin of this expansion.\n+        while call_site.from_expansion() {\n+            data = call_site.ctxt().outer_expn_data();\n+            call_site = data.call_site;\n         }\n+\n+        let macro_name = match data.kind {\n+            ExpnKind::Macro(MacroKind::Bang, macro_name) => macro_name,\n+            // Even though we don't handle this kind of macro, this `data` still comes from\n+            // expansion so we return `true` so we don't go any deeper in this code.\n+            _ => return true,\n+        };\n+        let link_from_src = match data.macro_def_id {\n+            Some(macro_def_id) if macro_def_id.is_local() => {\n+                LinkFromSrc::Local(clean::Span::new(data.def_site))\n+            }\n+            Some(macro_def_id) => LinkFromSrc::External(macro_def_id),\n+            None => return true,\n+        };\n+        let new_span = data.call_site;\n+        let macro_name = macro_name.as_str();\n+        // The \"call_site\" includes the whole macro with its \"arguments\". We only want\n+        // the macro name.\n+        let new_span = new_span.with_hi(new_span.lo() + BytePos(macro_name.len() as u32));\n+        self.matches.insert(new_span, link_from_src);\n+        true\n     }\n }\n \n@@ -101,7 +141,10 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &'tcx rustc_hir::Path<'tcx>, _id: HirId) {\n-        self.handle_path(path, None);\n+        if self.handle_macro(path.span) {\n+            return;\n+        }\n+        self.handle_path(path);\n         intravisit::walk_path(self, path);\n     }\n \n@@ -143,12 +186,18 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n                     );\n                 }\n             }\n+        } else if self.handle_macro(expr.span) {\n+            // We don't want to go deeper into the macro.\n+            return;\n         }\n         intravisit::walk_expr(self, expr);\n     }\n \n     fn visit_use(&mut self, path: &'tcx rustc_hir::Path<'tcx>, id: HirId) {\n-        self.handle_path(path, None);\n+        if self.handle_macro(path.span) {\n+            return;\n+        }\n+        self.handle_path(path);\n         intravisit::walk_use(self, path, id);\n     }\n }"}, {"sha": "d0fd637ba884322c6eea9ef8c630cffb672b7124", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -297,7 +297,7 @@ pub(crate) fn print_src(\n         None,\n         edition,\n         Some(line_numbers),\n-        Some(highlight::ContextInfo { context, file_span, root_path }),\n+        Some(highlight::HrefContext { context, file_span, root_path }),\n         decoration_info,\n     );\n }"}, {"sha": "3396b234a77b19de0d311d8c34ea05cdda056c89", "filename": "src/test/rustdoc/check-source-code-urls-to-def-std.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-source-code-urls-to-def-std.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -15,3 +15,28 @@ pub fn foo(a: u32, b: &str, c: String) {\n     let y: bool = true;\n     babar();\n }\n+\n+macro_rules! yolo { () => {}}\n+\n+fn bar(a: i32) {}\n+\n+macro_rules! bar {\n+    ($a:ident) => { bar($a) }\n+}\n+\n+macro_rules! data {\n+    ($x:expr) => { $x * 2 }\n+}\n+\n+pub fn another_foo() {\n+    // This is known limitation: if the macro doesn't generate anything, the visitor\n+    // can't find any item or anything that could tell us that it comes from expansion.\n+    // @!has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def-std.rs.html#19\"]' 'yolo!'\n+    yolo!();\n+    // @has - '//a[@href=\"{{channel}}/std/macro.eprintln.html\"]' 'eprintln!'\n+    eprintln!();\n+    // @has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def-std.rs.html#27-29\"]' 'data!'\n+    let x = data!(4);\n+    // @has - '//a[@href=\"../../src/foo/check-source-code-urls-to-def-std.rs.html#23-25\"]' 'bar!'\n+    bar!(x);\n+}"}, {"sha": "384561f8ccd7e0496ef3c867ff4e015f8955a958", "filename": "src/test/ui/associated-types/issue-87261.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -83,17 +83,17 @@ fn main() {\n     //~^ ERROR type mismatch resolving `<impl DerivedTrait as Trait>::Associated == ()`\n \n     accepts_trait(returns_opaque_foo());\n-    //~^ ERROR type mismatch resolving `<impl Foo + Trait as Trait>::Associated == ()`\n+    //~^ ERROR type mismatch resolving `<impl Trait + Foo as Trait>::Associated == ()`\n \n     accepts_trait(returns_opaque_derived_foo());\n-    //~^ ERROR type mismatch resolving `<impl Foo + DerivedTrait as Trait>::Associated == ()`\n+    //~^ ERROR type mismatch resolving `<impl DerivedTrait + Foo as Trait>::Associated == ()`\n \n     accepts_generic_trait(returns_opaque_generic());\n     //~^ ERROR type mismatch resolving `<impl GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n \n     accepts_generic_trait(returns_opaque_generic_foo());\n-    //~^ ERROR type mismatch resolving `<impl Foo + GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n+    //~^ ERROR type mismatch resolving `<impl GenericTrait<()> + Foo as GenericTrait<()>>::Associated == ()`\n \n     accepts_generic_trait(returns_opaque_generic_duplicate());\n-    //~^ ERROR type mismatch resolving `<impl GenericTrait<u8> + GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n+    //~^ ERROR type mismatch resolving `<impl GenericTrait<()> + GenericTrait<u8> as GenericTrait<()>>::Associated == ()`\n }"}, {"sha": "8db4a49da3c96e4f7790d038e62ac3ad0062a3d4", "filename": "src/test/ui/associated-types/issue-87261.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -160,7 +160,7 @@ help: consider constraining the associated type `<impl DerivedTrait as Trait>::A\n LL | fn returns_opaque_derived() -> impl DerivedTrait<Associated = ()> + 'static {\n    |                                                 +++++++++++++++++\n \n-error[E0271]: type mismatch resolving `<impl Foo + Trait as Trait>::Associated == ()`\n+error[E0271]: type mismatch resolving `<impl Trait + Foo as Trait>::Associated == ()`\n   --> $DIR/issue-87261.rs:85:5\n    |\n LL | fn returns_opaque_foo() -> impl Trait + Foo {\n@@ -170,18 +170,18 @@ LL |     accepts_trait(returns_opaque_foo());\n    |     ^^^^^^^^^^^^^ expected `()`, found associated type\n    |\n    = note:    expected unit type `()`\n-           found associated type `<impl Foo + Trait as Trait>::Associated`\n+           found associated type `<impl Trait + Foo as Trait>::Associated`\n note: required by a bound in `accepts_trait`\n   --> $DIR/issue-87261.rs:43:27\n    |\n LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n    |                           ^^^^^^^^^^^^^^^ required by this bound in `accepts_trait`\n-help: consider constraining the associated type `<impl Foo + Trait as Trait>::Associated` to `()`\n+help: consider constraining the associated type `<impl Trait + Foo as Trait>::Associated` to `()`\n    |\n LL | fn returns_opaque_foo() -> impl Trait<Associated = ()> + Foo {\n    |                                      +++++++++++++++++\n \n-error[E0271]: type mismatch resolving `<impl Foo + DerivedTrait as Trait>::Associated == ()`\n+error[E0271]: type mismatch resolving `<impl DerivedTrait + Foo as Trait>::Associated == ()`\n   --> $DIR/issue-87261.rs:88:5\n    |\n LL | fn returns_opaque_derived_foo() -> impl DerivedTrait + Foo {\n@@ -191,8 +191,8 @@ LL |     accepts_trait(returns_opaque_derived_foo());\n    |     ^^^^^^^^^^^^^ expected `()`, found associated type\n    |\n    = note:    expected unit type `()`\n-           found associated type `<impl Foo + DerivedTrait as Trait>::Associated`\n-   = help: consider constraining the associated type `<impl Foo + DerivedTrait as Trait>::Associated` to `()`\n+           found associated type `<impl DerivedTrait + Foo as Trait>::Associated`\n+   = help: consider constraining the associated type `<impl DerivedTrait + Foo as Trait>::Associated` to `()`\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n note: required by a bound in `accepts_trait`\n   --> $DIR/issue-87261.rs:43:27\n@@ -221,7 +221,7 @@ help: consider constraining the associated type `<impl GenericTrait<()> as Gener\n LL | fn returns_opaque_generic() -> impl GenericTrait<(), Associated = ()> + 'static {\n    |                                                    +++++++++++++++++\n \n-error[E0271]: type mismatch resolving `<impl Foo + GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n+error[E0271]: type mismatch resolving `<impl GenericTrait<()> + Foo as GenericTrait<()>>::Associated == ()`\n   --> $DIR/issue-87261.rs:94:5\n    |\n LL | fn returns_opaque_generic_foo() -> impl GenericTrait<()> + Foo {\n@@ -231,18 +231,18 @@ LL |     accepts_generic_trait(returns_opaque_generic_foo());\n    |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n    |\n    = note:    expected unit type `()`\n-           found associated type `<impl Foo + GenericTrait<()> as GenericTrait<()>>::Associated`\n+           found associated type `<impl GenericTrait<()> + Foo as GenericTrait<()>>::Associated`\n note: required by a bound in `accepts_generic_trait`\n   --> $DIR/issue-87261.rs:44:46\n    |\n LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n    |                                              ^^^^^^^^^^^^^^^ required by this bound in `accepts_generic_trait`\n-help: consider constraining the associated type `<impl Foo + GenericTrait<()> as GenericTrait<()>>::Associated` to `()`\n+help: consider constraining the associated type `<impl GenericTrait<()> + Foo as GenericTrait<()>>::Associated` to `()`\n    |\n LL | fn returns_opaque_generic_foo() -> impl GenericTrait<(), Associated = ()> + Foo {\n    |                                                        +++++++++++++++++\n \n-error[E0271]: type mismatch resolving `<impl GenericTrait<u8> + GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n+error[E0271]: type mismatch resolving `<impl GenericTrait<()> + GenericTrait<u8> as GenericTrait<()>>::Associated == ()`\n   --> $DIR/issue-87261.rs:97:5\n    |\n LL | fn returns_opaque_generic_duplicate() -> impl GenericTrait<()> + GenericTrait<u8> {\n@@ -252,8 +252,8 @@ LL |     accepts_generic_trait(returns_opaque_generic_duplicate());\n    |     ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n    |\n    = note:    expected unit type `()`\n-           found associated type `<impl GenericTrait<u8> + GenericTrait<()> as GenericTrait<()>>::Associated`\n-   = help: consider constraining the associated type `<impl GenericTrait<u8> + GenericTrait<()> as GenericTrait<()>>::Associated` to `()`\n+           found associated type `<impl GenericTrait<()> + GenericTrait<u8> as GenericTrait<()>>::Associated`\n+   = help: consider constraining the associated type `<impl GenericTrait<()> + GenericTrait<u8> as GenericTrait<()>>::Associated` to `()`\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n note: required by a bound in `accepts_generic_trait`\n   --> $DIR/issue-87261.rs:44:46"}, {"sha": "640156291a38cfc8e93be806616be0a8df1df501", "filename": "src/test/ui/impl-trait/suggest-calling-rpit-closure.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fimpl-trait%2Fsuggest-calling-rpit-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fimpl-trait%2Fsuggest-calling-rpit-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fsuggest-calling-rpit-closure.rs?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -0,0 +1,12 @@\n+fn whatever() -> i32 {\n+    opaque()\n+//~^ ERROR mismatched types\n+}\n+\n+fn opaque() -> impl Fn() -> i32 {\n+    || 0\n+}\n+\n+fn main() {\n+    let _ = whatever();\n+}"}, {"sha": "2a328a0e6f54d821803307daab761b96385aa7a8", "filename": "src/test/ui/impl-trait/suggest-calling-rpit-closure.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fimpl-trait%2Fsuggest-calling-rpit-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fimpl-trait%2Fsuggest-calling-rpit-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fsuggest-calling-rpit-closure.stderr?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-calling-rpit-closure.rs:2:5\n+   |\n+LL | fn whatever() -> i32 {\n+   |                  --- expected `i32` because of return type\n+LL |     opaque()\n+   |     ^^^^^^^^ expected `i32`, found opaque type\n+...\n+LL | fn opaque() -> impl Fn() -> i32 {\n+   |                ---------------- the found opaque type\n+   |\n+   = note:     expected type `i32`\n+           found opaque type `impl Fn() -> i32`\n+help: use parentheses to call this closure\n+   |\n+LL |     opaque()()\n+   |             ++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "d4f64a7de5bcff2096eada7938f4e57ae4ec2846", "filename": "src/test/ui/parser/expr-as-stmt.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -201,6 +201,10 @@ LL |     { true } || { true }\n    |\n    = note: expected type `bool`\n            found closure `[closure@$DIR/expr-as-stmt.rs:51:14: 51:25]`\n+help: use parentheses to call this closure\n+   |\n+LL |     { true } (|| { true })()\n+   |              +           +++\n help: parentheses are required to parse this as an expression\n    |\n LL |     ({ true }) || { true }"}, {"sha": "e71f15ebfd2e7219870a555ce9cd0f2913a25020", "filename": "src/test/ui/parser/struct-literal-restrictions-in-lamda.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.stderr?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -25,6 +25,12 @@ LL | |     }.hi() {\n    |\n    = note: expected type `bool`\n            found closure `[closure@$DIR/struct-literal-restrictions-in-lamda.rs:12:11: 14:11]`\n+help: use parentheses to call this closure\n+   |\n+LL ~     while (|| Foo {\n+LL |         x: 3\n+LL ~     }.hi())() {\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "360557fb5201daca66ff89e027f140d566efcbe3", "filename": "src/test/ui/reify-intrinsic.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Freify-intrinsic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Freify-intrinsic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freify-intrinsic.stderr?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -8,10 +8,6 @@ LL |     let _: unsafe extern \"rust-intrinsic\" fn(isize) -> usize = std::mem::tr\n    |\n    = note: expected fn pointer `unsafe extern \"rust-intrinsic\" fn(isize) -> usize`\n                  found fn item `unsafe extern \"rust-intrinsic\" fn(_) -> _ {transmute::<_, _>}`\n-help: use parentheses to call this function\n-   |\n-LL |     let _: unsafe extern \"rust-intrinsic\" fn(isize) -> usize = std::mem::transmute(...);\n-   |                                                                                   +++++\n \n error[E0606]: casting `unsafe extern \"rust-intrinsic\" fn(_) -> _ {transmute::<_, _>}` as `unsafe extern \"rust-intrinsic\" fn(isize) -> usize` is invalid\n   --> $DIR/reify-intrinsic.rs:11:13"}, {"sha": "f7f39bd0b9a07d635e505014ff5c1a8d80210226", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -1118,6 +1118,10 @@ LL |     if let Range { start: F, end } = F..|| true {}\n    |\n    = note: expected type `bool`\n            found closure `[closure@$DIR/disallowed-positions.rs:136:41: 136:48]`\n+help: use parentheses to call this closure\n+   |\n+LL |     if let Range { start: F, end } = F..(|| true)() {}\n+   |                                         +       +++\n \n error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:136:8\n@@ -1314,6 +1318,10 @@ LL |     while let Range { start: F, end } = F..|| true {}\n    |\n    = note: expected type `bool`\n            found closure `[closure@$DIR/disallowed-positions.rs:200:44: 200:51]`\n+help: use parentheses to call this closure\n+   |\n+LL |     while let Range { start: F, end } = F..(|| true)() {}\n+   |                                            +       +++\n \n error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:200:11"}, {"sha": "3e7041f02b388aaeca7ce0ee1b4fa85c151a8a4c", "filename": "src/test/ui/span/move-closure.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fspan%2Fmove-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fspan%2Fmove-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmove-closure.stderr?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -8,6 +8,10 @@ LL |     let x: () = move || ();\n    |\n    = note: expected unit type `()`\n                 found closure `[closure@$DIR/move-closure.rs:5:17: 5:27]`\n+help: use parentheses to call this closure\n+   |\n+LL |     let x: () = (move || ())();\n+   |                 +          +++\n \n error: aborting due to previous error\n "}, {"sha": "25ce458f6d8133a81672a6837c27be2a61211655", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-without-args.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -33,7 +33,7 @@ LL |     let _: usize = foo;\n            found fn item `fn(usize, usize) -> usize {foo}`\n help: use parentheses to call this function\n    |\n-LL |     let _: usize = foo(a, b);\n+LL |     let _: usize = foo(_, _);\n    |                       ++++++\n \n error[E0308]: mismatched types\n@@ -105,7 +105,7 @@ LL |     let _: usize = T::baz;\n            found fn item `fn(usize, usize) -> usize {<_ as T>::baz}`\n help: use parentheses to call this function\n    |\n-LL |     let _: usize = T::baz(x, y);\n+LL |     let _: usize = T::baz(_, _);\n    |                          ++++++\n \n error[E0308]: mismatched types\n@@ -123,7 +123,7 @@ LL |     let _: usize = T::bat;\n            found fn item `fn(usize) -> usize {<_ as T>::bat}`\n help: use parentheses to call this function\n    |\n-LL |     let _: usize = T::bat(x);\n+LL |     let _: usize = T::bat(_);\n    |                          +++\n \n error[E0308]: mismatched types\n@@ -159,7 +159,7 @@ LL |     let _: usize = X::baz;\n            found fn item `fn(usize, usize) -> usize {<X as T>::baz}`\n help: use parentheses to call this function\n    |\n-LL |     let _: usize = X::baz(x, y);\n+LL |     let _: usize = X::baz(_, _);\n    |                          ++++++\n \n error[E0308]: mismatched types\n@@ -177,7 +177,7 @@ LL |     let _: usize = X::bat;\n            found fn item `fn(usize) -> usize {<X as T>::bat}`\n help: use parentheses to call this function\n    |\n-LL |     let _: usize = X::bat(x);\n+LL |     let _: usize = X::bat(_);\n    |                          +++\n \n error[E0308]: mismatched types\n@@ -195,7 +195,7 @@ LL |     let _: usize = X::bax;\n            found fn item `fn(usize) -> usize {<X as T>::bax}`\n help: use parentheses to call this function\n    |\n-LL |     let _: usize = X::bax(x);\n+LL |     let _: usize = X::bax(_);\n    |                          +++\n \n error[E0308]: mismatched types\n@@ -213,7 +213,7 @@ LL |     let _: usize = X::bach;\n            found fn item `fn(usize) -> usize {<X as T>::bach}`\n help: use parentheses to call this function\n    |\n-LL |     let _: usize = X::bach(x);\n+LL |     let _: usize = X::bach(_);\n    |                           +++\n \n error[E0308]: mismatched types"}, {"sha": "ab39ee74be4421cd4766cc0f6f593951360edb23", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7036449c774860a5b348dbbe01c20704c557382e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr?ref=7036449c774860a5b348dbbe01c20704c557382e", "patch": "@@ -15,6 +15,10 @@ LL |     || -> Closure { || () }\n    |\n    = note: expected unit type `()`\n                 found closure `[closure@$DIR/issue-63279.rs:8:21: 8:26]`\n+help: use parentheses to call this closure\n+   |\n+LL |     || -> Closure { (|| ())() }\n+   |                     +     +++\n \n error[E0308]: mismatched types\n   --> $DIR/issue-63279.rs:8:5"}]}