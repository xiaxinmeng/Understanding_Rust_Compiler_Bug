{"sha": "acb73dbe8b311eb2ffa640ac3e01795d84159df4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjYjczZGJlOGIzMTFlYjJmZmE2NDBhYzNlMDE3OTVkODQxNTlkZjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-24T03:55:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-24T03:55:23Z"}, "message": "Auto merge of #44772 - michaelwoerister:new-graph, r=nikomatsakis\n\nincr.comp.: Add new DepGraph implementation.\n\nThis commits does a few things:\n1. It adds the new dep-graph implementation -- *in addition* to the old one. This way we can start testing the new implementation without switching all tests at once.\n2. It persists the new dep-graph (which includes query result fingerprints) to the incr. comp. caching directory and also loads this data.\n3. It removes support for loading fingerprints of metadata imported from other crates (except for when running autotests). This is not needed anymore with red/green. It could provide a performance advantage but that's yet to be determined. For now, as red/green is not fully implemented yet, the cross-crate incremental tests are disabled.\n\nNote, this PR is based on top of soon-to-be-merged #44696 and only the last 4 commits are new:\n```\n- incr.comp.: Initial implemenation of append-only dep-graph. (c90147c)\n- incr.comp.: Do some various cleanup. (8ce20c5)\n- incr.comp.: Serialize and deserialize new DepGraph. (0e13c1a)\n- incr.comp.: Remove support for loading metadata fingerprints. (270a134)\nEDIT 2:\n- incr.comp.: Make #[rustc_dirty/clean] test for fingerprint equality ... (d8f7ff9)\n```\n(EDIT: GH displays the commits in the wrong order for some reason)\n\nAlso note that this PR is expected to certainly result in performance regressions in the incr. comp. test cases, since we are adding quite a few things (a whole additional dep-graph, for example) without removing anything. End-to-end performance measurements will only make sense again after red/green is enabled and all the legacy tracking has been turned off.\n\nEDIT 2: Pushed another commit that makes the `#[rustc_dirty]`/`#[rustc_clean]` based autotests compared query result fingerprints instead of testing `DepNode` existence.", "tree": {"sha": "f64130db8a8c834675fa514bd978d314e4c9f494", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f64130db8a8c834675fa514bd978d314e4c9f494"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acb73dbe8b311eb2ffa640ac3e01795d84159df4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acb73dbe8b311eb2ffa640ac3e01795d84159df4", "html_url": "https://github.com/rust-lang/rust/commit/acb73dbe8b311eb2ffa640ac3e01795d84159df4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acb73dbe8b311eb2ffa640ac3e01795d84159df4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24831c7221c7b4e32a02f8e8cffe7dfacb88b520", "url": "https://api.github.com/repos/rust-lang/rust/commits/24831c7221c7b4e32a02f8e8cffe7dfacb88b520", "html_url": "https://github.com/rust-lang/rust/commit/24831c7221c7b4e32a02f8e8cffe7dfacb88b520"}, {"sha": "89aec1eb0bbae38123ffb3e41dc9c2af62527e14", "url": "https://api.github.com/repos/rust-lang/rust/commits/89aec1eb0bbae38123ffb3e41dc9c2af62527e14", "html_url": "https://github.com/rust-lang/rust/commit/89aec1eb0bbae38123ffb3e41dc9c2af62527e14"}], "stats": {"total": 1197, "additions": 662, "deletions": 535}, "files": [{"sha": "b492caf10bb0df97217dd0e33de39aedee33df00", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -60,7 +60,7 @@\n //! user of the `DepNode` API of having to know how to compute the expected\n //! fingerprint for a given set of node parameters.\n \n-use hir::def_id::{CrateNum, DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use hir::map::DefPathHash;\n use hir::{HirId, ItemLocalId};\n \n@@ -420,7 +420,7 @@ define_dep_nodes!( <'tcx>\n     [input] Hir(DefId),\n \n     // Represents metadata from an extern crate.\n-    [input] MetaData(DefId),\n+    [input] CrateMetadata(CrateNum),\n \n     // Represents some artifact that we save to disk. Note that these\n     // do not have a def-id as part of their identifier.\n@@ -678,6 +678,22 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefIndex,\n     }\n }\n \n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (CrateNum,) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+\n+    fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n+        let def_id = DefId {\n+            krate: self.0,\n+            index: CRATE_DEF_INDEX,\n+        };\n+        tcx.def_path_hash(def_id).0\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        tcx.crate_name(self.0).as_str().to_string()\n+    }\n+}\n+\n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, DefId) {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n "}, {"sha": "b12db11cb6af692f83ba54042ffd179cfa9bc9d0", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -17,7 +17,7 @@ use std::mem;\n use super::{DepGraphQuery, DepKind, DepNode};\n use super::debug::EdgeFilter;\n \n-pub struct DepGraphEdges {\n+pub(super) struct DepGraphEdges {\n     nodes: Vec<DepNode>,\n     indices: FxHashMap<DepNode, DepNodeIndex>,\n     edges: FxHashSet<(DepNodeIndex, DepNodeIndex)>,\n@@ -31,8 +31,8 @@ pub struct DepGraphEdges {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct DepNodeIndex {\n-    index: u32\n+pub(super) struct DepNodeIndex {\n+    index: u32,\n }\n \n impl DepNodeIndex {"}, {"sha": "71a7ee84cd1449632c3c6762f4270d42a98cd930", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 299, "deletions": 28, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHashingContextProvider};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n+use std::hash::Hash;\n use std::rc::Rc;\n use util::common::{ProfileQueriesMsg, profq_msg};\n \n@@ -22,7 +24,9 @@ use super::dep_node::{DepNode, DepKind, WorkProductId};\n use super::query::DepGraphQuery;\n use super::raii;\n use super::safe::DepGraphSafe;\n-use super::edges::{DepGraphEdges, DepNodeIndex};\n+use super::edges::{self, DepGraphEdges};\n+use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+use super::prev::PreviousDepGraph;\n \n #[derive(Clone)]\n pub struct DepGraph {\n@@ -38,10 +42,38 @@ pub struct DepGraph {\n     fingerprints: Rc<RefCell<FxHashMap<DepNode, Fingerprint>>>\n }\n \n+/// As a temporary measure, while transitioning to the new DepGraph\n+/// implementation, we maintain the old and the new dep-graph encoding in\n+/// parallel, so a DepNodeIndex actually contains two indices, one for each\n+/// version.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DepNodeIndex {\n+    legacy: edges::DepNodeIndex,\n+    new: DepNodeIndexNew,\n+}\n+\n+impl DepNodeIndex {\n+    pub const INVALID: DepNodeIndex = DepNodeIndex {\n+        legacy: edges::DepNodeIndex::INVALID,\n+        new: DepNodeIndexNew::INVALID,\n+    };\n+}\n+\n struct DepGraphData {\n-    /// The actual graph data.\n+    /// The old, initial encoding of the dependency graph. This will soon go\n+    /// away.\n     edges: RefCell<DepGraphEdges>,\n \n+    /// The new encoding of the dependency graph, optimized for red/green\n+    /// tracking. The `current` field is the dependency graph of only the\n+    /// current compilation session: We don't merge the previous dep-graph into\n+    /// current one anymore.\n+    current: RefCell<CurrentDepGraph>,\n+\n+    /// The dep-graph from the previous compilation session. It contains all\n+    /// nodes and edges as well as all fingerprints of nodes that have them.\n+    previous: PreviousDepGraph,\n+\n     /// When we load, there may be `.o` files, cached mir, or other such\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n@@ -55,18 +87,24 @@ struct DepGraphData {\n }\n \n impl DepGraph {\n-    pub fn new(enabled: bool) -> DepGraph {\n+\n+    pub fn new(prev_graph: PreviousDepGraph) -> DepGraph {\n         DepGraph {\n-            data: if enabled {\n-                Some(Rc::new(DepGraphData {\n-                    previous_work_products: RefCell::new(FxHashMap()),\n-                    work_products: RefCell::new(FxHashMap()),\n-                    edges: RefCell::new(DepGraphEdges::new()),\n-                    dep_node_debug: RefCell::new(FxHashMap()),\n-                }))\n-            } else {\n-                None\n-            },\n+            data: Some(Rc::new(DepGraphData {\n+                previous_work_products: RefCell::new(FxHashMap()),\n+                work_products: RefCell::new(FxHashMap()),\n+                edges: RefCell::new(DepGraphEdges::new()),\n+                dep_node_debug: RefCell::new(FxHashMap()),\n+                current: RefCell::new(CurrentDepGraph::new()),\n+                previous: prev_graph,\n+            })),\n+            fingerprints: Rc::new(RefCell::new(FxHashMap())),\n+        }\n+    }\n+\n+    pub fn new_disabled() -> DepGraph {\n+        DepGraph {\n+            data: None,\n             fingerprints: Rc::new(RefCell::new(FxHashMap())),\n         }\n     }\n@@ -82,7 +120,8 @@ impl DepGraph {\n     }\n \n     pub fn in_ignore<'graph>(&'graph self) -> Option<raii::IgnoreTask<'graph>> {\n-        self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.edges))\n+        self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.edges,\n+                                                            &data.current))\n     }\n \n     pub fn with_ignore<OP,R>(&self, op: OP) -> R\n@@ -130,6 +169,7 @@ impl DepGraph {\n     {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().push_task(key);\n+            data.current.borrow_mut().push_task(key);\n             if cfg!(debug_assertions) {\n                 profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n             };\n@@ -145,7 +185,9 @@ impl DepGraph {\n             if cfg!(debug_assertions) {\n                 profq_msg(ProfileQueriesMsg::TaskEnd)\n             };\n-            let dep_node_index = data.edges.borrow_mut().pop_task(key);\n+\n+            let dep_node_index_legacy = data.edges.borrow_mut().pop_task(key);\n+            let dep_node_index_new = data.current.borrow_mut().pop_task(key);\n \n             let mut stable_hasher = StableHasher::new();\n             result.hash_stable(&mut hcx, &mut stable_hasher);\n@@ -155,7 +197,10 @@ impl DepGraph {\n                         .insert(key, stable_hasher.finish())\n                         .is_none());\n \n-            (result, dep_node_index)\n+            (result, DepNodeIndex {\n+                legacy: dep_node_index_legacy,\n+                new: dep_node_index_new,\n+            })\n         } else {\n             if key.kind.fingerprint_needed_for_crate_hash() {\n                 let mut hcx = cx.create_stable_hashing_context();\n@@ -180,9 +225,14 @@ impl DepGraph {\n     {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().push_anon_task();\n+            data.current.borrow_mut().push_anon_task();\n             let result = op();\n-            let dep_node = data.edges.borrow_mut().pop_anon_task(dep_kind);\n-            (result, dep_node)\n+            let dep_node_index_legacy = data.edges.borrow_mut().pop_anon_task(dep_kind);\n+            let dep_node_index_new = data.current.borrow_mut().pop_anon_task(dep_kind);\n+            (result, DepNodeIndex {\n+                legacy: dep_node_index_legacy,\n+                new: dep_node_index_new,\n+            })\n         } else {\n             (op(), DepNodeIndex::INVALID)\n         }\n@@ -192,13 +242,21 @@ impl DepGraph {\n     pub fn read(&self, v: DepNode) {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().read(v);\n+\n+            let mut current = data.current.borrow_mut();\n+            if let Some(&dep_node_index_new) = current.node_to_node_index.get(&v) {\n+                current.read_index(dep_node_index_new);\n+            } else {\n+                bug!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n+            }\n         }\n     }\n \n     #[inline]\n     pub fn read_index(&self, v: DepNodeIndex) {\n         if let Some(ref data) = self.data {\n-            data.edges.borrow_mut().read_index(v);\n+            data.edges.borrow_mut().read_index(v.legacy);\n+            data.current.borrow_mut().read_index(v.new);\n         }\n     }\n \n@@ -213,16 +271,12 @@ impl DepGraph {\n         self.data.as_ref().unwrap().edges.borrow_mut().add_node(node);\n     }\n \n-    pub fn alloc_input_node(&self, node: DepNode) -> DepNodeIndex {\n-        if let Some(ref data) = self.data {\n-            data.edges.borrow_mut().add_node(node)\n-        } else {\n-            DepNodeIndex::INVALID\n-        }\n+    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Fingerprint {\n+        self.fingerprints.borrow()[dep_node]\n     }\n \n-    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n-        self.fingerprints.borrow().get(dep_node).cloned()\n+    pub fn prev_fingerprint_of(&self, dep_node: &DepNode) -> Fingerprint {\n+        self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n \n     /// Indicates that a previous work product exists for `v`. This is\n@@ -291,6 +345,44 @@ impl DepGraph {\n     pub(super) fn dep_node_debug_str(&self, dep_node: DepNode) -> Option<String> {\n         self.data.as_ref().and_then(|t| t.dep_node_debug.borrow().get(&dep_node).cloned())\n     }\n+\n+    pub fn serialize(&self) -> SerializedDepGraph {\n+        let fingerprints = self.fingerprints.borrow();\n+        let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n+\n+        let nodes: IndexVec<_, _> = current_dep_graph.nodes.iter().map(|dep_node| {\n+            let fingerprint = fingerprints.get(dep_node)\n+                                          .cloned()\n+                                          .unwrap_or(Fingerprint::zero());\n+            (*dep_node, fingerprint)\n+        }).collect();\n+\n+        let total_edge_count: usize = current_dep_graph.edges.iter()\n+                                                             .map(|v| v.len())\n+                                                             .sum();\n+\n+        let mut edge_list_indices = IndexVec::with_capacity(nodes.len());\n+        let mut edge_list_data = Vec::with_capacity(total_edge_count);\n+\n+        for (current_dep_node_index, edges) in current_dep_graph.edges.iter_enumerated() {\n+            let start = edge_list_data.len() as u32;\n+            // This should really just be a memcpy :/\n+            edge_list_data.extend(edges.iter().map(|i| SerializedDepNodeIndex(i.index)));\n+            let end = edge_list_data.len() as u32;\n+\n+            debug_assert_eq!(current_dep_node_index.index(), edge_list_indices.len());\n+            edge_list_indices.push((start, end));\n+        }\n+\n+        debug_assert!(edge_list_data.len() <= ::std::u32::MAX as usize);\n+        debug_assert_eq!(edge_list_data.len(), total_edge_count);\n+\n+        SerializedDepGraph {\n+            nodes,\n+            edge_list_indices,\n+            edge_list_data,\n+        }\n+    }\n }\n \n /// A \"work product\" is an intermediate result that we save into the\n@@ -335,3 +427,182 @@ pub struct WorkProduct {\n     /// Saved files associated with this CGU\n     pub saved_files: Vec<(OutputType, String)>,\n }\n+\n+pub(super) struct CurrentDepGraph {\n+    nodes: IndexVec<DepNodeIndexNew, DepNode>,\n+    edges: IndexVec<DepNodeIndexNew, Vec<DepNodeIndexNew>>,\n+    node_to_node_index: FxHashMap<DepNode, DepNodeIndexNew>,\n+\n+    task_stack: Vec<OpenTask>,\n+}\n+\n+impl CurrentDepGraph {\n+    fn new() -> CurrentDepGraph {\n+        CurrentDepGraph {\n+            nodes: IndexVec::new(),\n+            edges: IndexVec::new(),\n+            node_to_node_index: FxHashMap(),\n+            task_stack: Vec::new(),\n+        }\n+    }\n+\n+    pub(super) fn push_ignore(&mut self) {\n+        self.task_stack.push(OpenTask::Ignore);\n+    }\n+\n+    pub(super) fn pop_ignore(&mut self) {\n+        let popped_node = self.task_stack.pop().unwrap();\n+        debug_assert_eq!(popped_node, OpenTask::Ignore);\n+    }\n+\n+    pub(super) fn push_task(&mut self, key: DepNode) {\n+        self.task_stack.push(OpenTask::Regular {\n+            node: key,\n+            reads: Vec::new(),\n+            read_set: FxHashSet(),\n+        });\n+    }\n+\n+    pub(super) fn pop_task(&mut self, key: DepNode) -> DepNodeIndexNew {\n+        let popped_node = self.task_stack.pop().unwrap();\n+\n+        if let OpenTask::Regular {\n+            node,\n+            read_set: _,\n+            reads\n+        } = popped_node {\n+            debug_assert_eq!(node, key);\n+            self.alloc_node(node, reads)\n+        } else {\n+            bug!(\"pop_task() - Expected regular task to be popped\")\n+        }\n+    }\n+\n+    fn push_anon_task(&mut self) {\n+        self.task_stack.push(OpenTask::Anon {\n+            reads: Vec::new(),\n+            read_set: FxHashSet(),\n+        });\n+    }\n+\n+    fn pop_anon_task(&mut self, kind: DepKind) -> DepNodeIndexNew {\n+        let popped_node = self.task_stack.pop().unwrap();\n+\n+        if let OpenTask::Anon {\n+            read_set: _,\n+            reads\n+        } = popped_node {\n+            let mut fingerprint = Fingerprint::zero();\n+            let mut hasher = StableHasher::new();\n+\n+            for &read in reads.iter() {\n+                let read_dep_node = self.nodes[read];\n+\n+                ::std::mem::discriminant(&read_dep_node.kind).hash(&mut hasher);\n+\n+                // Fingerprint::combine() is faster than sending Fingerprint\n+                // through the StableHasher (at least as long as StableHasher\n+                // is so slow).\n+                fingerprint = fingerprint.combine(read_dep_node.hash);\n+            }\n+\n+            fingerprint = fingerprint.combine(hasher.finish());\n+\n+            let target_dep_node = DepNode {\n+                kind,\n+                hash: fingerprint,\n+            };\n+\n+            if let Some(&index) = self.node_to_node_index.get(&target_dep_node) {\n+                return index;\n+            }\n+\n+            self.alloc_node(target_dep_node, reads)\n+        } else {\n+            bug!(\"pop_anon_task() - Expected anonymous task to be popped\")\n+        }\n+    }\n+\n+    fn read_index(&mut self, source: DepNodeIndexNew) {\n+        match self.task_stack.last_mut() {\n+            Some(&mut OpenTask::Regular {\n+                ref mut reads,\n+                ref mut read_set,\n+                node: _,\n+            }) => {\n+                if read_set.insert(source) {\n+                    reads.push(source);\n+                }\n+            }\n+            Some(&mut OpenTask::Anon {\n+                ref mut reads,\n+                ref mut read_set,\n+            }) => {\n+                if read_set.insert(source) {\n+                    reads.push(source);\n+                }\n+            }\n+            Some(&mut OpenTask::Ignore) | None => {\n+                // ignore\n+            }\n+        }\n+    }\n+\n+    fn alloc_node(&mut self,\n+                  dep_node: DepNode,\n+                  edges: Vec<DepNodeIndexNew>)\n+                  -> DepNodeIndexNew {\n+        debug_assert_eq!(self.edges.len(), self.nodes.len());\n+        debug_assert_eq!(self.node_to_node_index.len(), self.nodes.len());\n+        debug_assert!(!self.node_to_node_index.contains_key(&dep_node));\n+        let dep_node_index = DepNodeIndexNew::new(self.nodes.len());\n+        self.nodes.push(dep_node);\n+        self.node_to_node_index.insert(dep_node, dep_node_index);\n+        self.edges.push(edges);\n+        dep_node_index\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub(super) struct DepNodeIndexNew {\n+    index: u32,\n+}\n+\n+impl Idx for DepNodeIndexNew {\n+    fn new(idx: usize) -> Self {\n+        DepNodeIndexNew::new(idx)\n+    }\n+    fn index(self) -> usize {\n+        self.index()\n+    }\n+}\n+\n+impl DepNodeIndexNew {\n+\n+    const INVALID: DepNodeIndexNew = DepNodeIndexNew {\n+        index: ::std::u32::MAX,\n+    };\n+\n+    fn new(v: usize) -> DepNodeIndexNew {\n+        assert!((v & 0xFFFF_FFFF) == v);\n+        DepNodeIndexNew { index: v as u32 }\n+    }\n+\n+    fn index(self) -> usize {\n+        self.index as usize\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+enum OpenTask {\n+    Regular {\n+        node: DepNode,\n+        reads: Vec<DepNodeIndexNew>,\n+        read_set: FxHashSet<DepNodeIndexNew>,\n+    },\n+    Anon {\n+        reads: Vec<DepNodeIndexNew>,\n+        read_set: FxHashSet<DepNodeIndexNew>,\n+    },\n+    Ignore,\n+}"}, {"sha": "cd77e06bdd6b03c6ace7f0e802ad2d279a0ca4a7", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -13,19 +13,17 @@ mod dep_node;\n mod dep_tracking_map;\n mod edges;\n mod graph;\n+mod prev;\n mod query;\n mod raii;\n mod safe;\n+mod serialized;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n-pub use self::dep_node::DepNode;\n-pub use self::dep_node::WorkProductId;\n-pub use self::graph::DepGraph;\n-pub use self::graph::WorkProduct;\n-pub use self::edges::DepNodeIndex;\n+pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId};\n+pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex};\n+pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;\n-pub use self::raii::DepTask;\n-\n-pub use self::dep_node::{DepKind, DepConstructor};\n+pub use self::serialized::SerializedDepGraph;"}, {"sha": "882ca0414ccc9cdaec44161f6a960d81bbcba45b", "filename": "src/librustc/dep_graph/prev.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ich::Fingerprint;\n+use rustc_data_structures::fx::FxHashMap;\n+use super::dep_node::DepNode;\n+use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct PreviousDepGraph {\n+    data: SerializedDepGraph,\n+    index: FxHashMap<DepNode, SerializedDepNodeIndex>,\n+}\n+\n+impl PreviousDepGraph {\n+    pub fn new(data: SerializedDepGraph) -> PreviousDepGraph {\n+        let index: FxHashMap<_, _> = data.nodes\n+            .iter_enumerated()\n+            .map(|(idx, &(dep_node, _))| (dep_node, idx))\n+            .collect();\n+        PreviousDepGraph { data, index }\n+    }\n+\n+    pub fn with_edges_from<F>(&self, dep_node: &DepNode, mut f: F)\n+    where\n+        F: FnMut(&(DepNode, Fingerprint)),\n+    {\n+        let node_index = self.index[dep_node];\n+        self.data\n+            .edge_targets_from(node_index)\n+            .into_iter()\n+            .for_each(|&index| f(&self.data.nodes[index]));\n+    }\n+\n+    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Fingerprint {\n+        let node_index = self.index[dep_node];\n+        self.data.nodes[node_index].1\n+    }\n+}"}, {"sha": "6e9e4f4a18b15ca8e9b6185e0ae5d8cc60357eee", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -8,50 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::DepNode;\n use super::edges::DepGraphEdges;\n+use super::graph::CurrentDepGraph;\n \n use std::cell::RefCell;\n \n-pub struct DepTask<'graph> {\n-    graph: &'graph RefCell<DepGraphEdges>,\n-    key: DepNode,\n-}\n-\n-impl<'graph> DepTask<'graph> {\n-    pub fn new(graph: &'graph RefCell<DepGraphEdges>,\n-               key: DepNode)\n-               -> DepTask<'graph> {\n-        graph.borrow_mut().push_task(key);\n-        DepTask {\n-            graph,\n-            key,\n-        }\n-    }\n-}\n-\n-impl<'graph> Drop for DepTask<'graph> {\n-    fn drop(&mut self) {\n-        self.graph.borrow_mut().pop_task(self.key);\n-    }\n-}\n-\n pub struct IgnoreTask<'graph> {\n-    graph: &'graph RefCell<DepGraphEdges>,\n+    legacy_graph: &'graph RefCell<DepGraphEdges>,\n+    new_graph: &'graph RefCell<CurrentDepGraph>,\n }\n \n impl<'graph> IgnoreTask<'graph> {\n-    pub fn new(graph: &'graph RefCell<DepGraphEdges>) -> IgnoreTask<'graph> {\n-        graph.borrow_mut().push_ignore();\n+    pub(super) fn new(legacy_graph: &'graph RefCell<DepGraphEdges>,\n+                      new_graph: &'graph RefCell<CurrentDepGraph>)\n+                      -> IgnoreTask<'graph> {\n+        legacy_graph.borrow_mut().push_ignore();\n+        new_graph.borrow_mut().push_ignore();\n         IgnoreTask {\n-            graph\n+            legacy_graph,\n+            new_graph,\n         }\n     }\n }\n \n impl<'graph> Drop for IgnoreTask<'graph> {\n     fn drop(&mut self) {\n-        self.graph.borrow_mut().pop_ignore();\n+        self.legacy_graph.borrow_mut().pop_ignore();\n+        self.new_graph.borrow_mut().pop_ignore();\n     }\n }\n "}, {"sha": "21beac9214eef9e3a9504a08f331c9f3a64d23b5", "filename": "src/librustc/dep_graph/serialized.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fserialized.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The data that we will serialize and deserialize.\n+\n+use dep_graph::DepNode;\n+use ich::Fingerprint;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+\n+/// The index of a DepNode in the SerializedDepGraph::nodes array.\n+#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd, Debug,\n+         RustcEncodable, RustcDecodable)]\n+pub struct SerializedDepNodeIndex(pub u32);\n+\n+impl SerializedDepNodeIndex {\n+    #[inline]\n+    pub fn new(idx: usize) -> SerializedDepNodeIndex {\n+        assert!(idx <= ::std::u32::MAX as usize);\n+        SerializedDepNodeIndex(idx as u32)\n+    }\n+}\n+\n+impl Idx for SerializedDepNodeIndex {\n+    #[inline]\n+    fn new(idx: usize) -> Self {\n+        assert!(idx <= ::std::u32::MAX as usize);\n+        SerializedDepNodeIndex(idx as u32)\n+    }\n+\n+    #[inline]\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+/// Data for use when recompiling the **current crate**.\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedDepGraph {\n+    /// The set of all DepNodes in the graph\n+    pub nodes: IndexVec<SerializedDepNodeIndex, (DepNode, Fingerprint)>,\n+    /// For each DepNode, stores the list of edges originating from that\n+    /// DepNode. Encoded as a [start, end) pair indexing into edge_list_data,\n+    /// which holds the actual DepNodeIndices of the target nodes.\n+    pub edge_list_indices: IndexVec<SerializedDepNodeIndex, (u32, u32)>,\n+    /// A flattened list of all edge targets in the graph. Edge sources are\n+    /// implicit in edge_list_indices.\n+    pub edge_list_data: Vec<SerializedDepNodeIndex>,\n+}\n+\n+impl SerializedDepGraph {\n+\n+    pub fn new() -> SerializedDepGraph {\n+        SerializedDepGraph {\n+            nodes: IndexVec::new(),\n+            edge_list_indices: IndexVec::new(),\n+            edge_list_data: Vec::new(),\n+        }\n+    }\n+\n+    pub fn edge_targets_from(&self, source: SerializedDepNodeIndex) -> &[SerializedDepNodeIndex] {\n+        let targets = self.edge_list_indices[source];\n+        &self.edge_list_data[targets.0 as usize..targets.1 as usize]\n+    }\n+}"}, {"sha": "8e48352007b374d9942028a19e40fce1965c5635", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -97,6 +97,17 @@ impl serialize::UseSpecializedDecodable for CrateNum {\n            RustcDecodable, Hash, Copy)]\n pub struct DefIndex(u32);\n \n+impl Idx for DefIndex {\n+    fn new(value: usize) -> Self {\n+        assert!(value < (u32::MAX) as usize);\n+        DefIndex(value as u32)\n+    }\n+\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n impl fmt::Debug for DefIndex {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f,"}, {"sha": "80fadcda2775d426501f90b5ceb66811834d00a9", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -88,6 +88,15 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             ).1;\n         }\n \n+        {\n+            dep_graph.with_task(\n+                DepNode::new_no_params(DepKind::AllLocalTraitImpls),\n+                &hcx,\n+                &krate.trait_impls,\n+                identity_fn\n+            );\n+        }\n+\n         let hir_body_nodes = vec![root_mod_def_path_hash];\n \n         let mut collector = NodeCollector {"}, {"sha": "8ce2feab06cef06ee6ba75b3b55922e3f7c763cd", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -876,17 +876,7 @@ impl<'hir> Map<'hir> {\n \n             Some(RootCrate(_)) => self.forest.krate.span,\n             Some(NotPresent) | None => {\n-                // Some nodes, notably macro definitions, are not\n-                // present in the map for whatever reason, but\n-                // they *do* have def-ids. So if we encounter an\n-                // empty hole, check for that case.\n-                if let Some(def_index) = self.definitions.opt_def_index(id) {\n-                    let def_path_hash = self.definitions.def_path_hash(def_index);\n-                    self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n-                    DUMMY_SP\n-                } else {\n-                    bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n-                }\n+                bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n             }\n         }\n     }"}, {"sha": "a97bfa0536987398acae30741c2738ccb3ccbb3d", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -267,6 +267,8 @@ pub trait CrateStore {\n     fn export_macros_untracked(&self, cnum: CrateNum);\n     fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind;\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;\n+    fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> Symbol;\n+    fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh;\n     fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children_untracked(&self, did: DefId, sess: &Session) -> Vec<def::Export>;\n     fn load_macro_untracked(&self, did: DefId, sess: &Session) -> LoadedMacro;\n@@ -336,6 +338,10 @@ impl CrateStore for DummyCrateStore {\n     fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n     fn export_macros_untracked(&self, cnum: CrateNum) { bug!(\"export_macros\") }\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n+    fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> Symbol {\n+        bug!(\"crate_disambiguator\")\n+    }\n+    fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey { bug!(\"def_key\") }"}, {"sha": "d3256357941f35912a729e08329c919556bbab8b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -1021,7 +1021,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"attempt to recover from parse errors (experimental)\"),\n     incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"enable incremental compilation (experimental)\"),\n-    incremental_cc: bool = (true, parse_bool, [UNTRACKED],\n+    incremental_cc: bool = (false, parse_bool, [UNTRACKED],\n           \"enable cross-crate incremental compilation (even more experimental)\"),\n     incremental_info: bool = (false, parse_bool, [UNTRACKED],\n         \"print high-level information about incremental reuse (or the lack thereof)\"),"}, {"sha": "054c5e122df7a6c00f5629a0f7b1bc4aac6b6894", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -11,6 +11,7 @@\n //! type context book-keeping\n \n use dep_graph::DepGraph;\n+use dep_graph::{DepNode, DepConstructor};\n use errors::DiagnosticBuilder;\n use session::Session;\n use session::config::OutputFilenames;\n@@ -1237,6 +1238,25 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   self.cstore)\n     }\n \n+    // This method makes sure that we have a DepNode and a Fingerprint for\n+    // every upstream crate. It needs to be called once right after the tcx is\n+    // created.\n+    // With full-fledged red/green, the method will probably become unnecessary\n+    // as this will be done on-demand.\n+    pub fn allocate_metadata_dep_nodes(self) {\n+        // We cannot use the query versions of crates() and crate_hash(), since\n+        // those would need the DepNodes that we are allocating here.\n+        for cnum in self.cstore.crates_untracked() {\n+            let dep_node = DepNode::new(self, DepConstructor::CrateMetadata(cnum));\n+            let crate_hash = self.cstore.crate_hash_untracked(cnum);\n+            self.dep_graph.with_task(dep_node,\n+                                     self,\n+                                     crate_hash,\n+                                     |_, x| x // No transformation needed\n+            );\n+        }\n+    }\n+\n     // This method exercises the `in_scope_traits_map` query for all possible\n     // values so that we have their fingerprints available in the DepGraph.\n     // This is only required as long as we still use the old dependency tracking"}, {"sha": "bcfbc1980cf6a986f288ca888042355041721ee4", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -643,7 +643,16 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         &crate_name,\n         &disambiguator.as_str(),\n     );\n-    let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n+\n+    let dep_graph = if sess.opts.build_dep_graph() {\n+        let prev_dep_graph = time(time_passes, \"load prev dep-graph (new)\", || {\n+            rustc_incremental::load_dep_graph_new(sess)\n+        });\n+\n+        DepGraph::new(prev_dep_graph)\n+    } else {\n+        DepGraph::new_disabled()\n+    };\n \n     time(time_passes, \"recursion limit\", || {\n         middle::recursion_limit::update_limits(sess, &krate);\n@@ -713,7 +722,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n     // item, much like we do for macro expansion. In other words, the hash reflects not just\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n-    let _ignore = dep_graph.in_ignore();\n     let mut crate_loader = CrateLoader::new(sess, &cstore, crate_name);\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver = Resolver::new(sess,"}, {"sha": "2f665af8433b94a0863890e96b0a077e7df1211d", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -20,7 +20,6 @@ use {abort_on_err, driver};\n use rustc::ty::{self, TyCtxt, GlobalArenas, Resolutions};\n use rustc::cfg;\n use rustc::cfg::graphviz::LabelledCFG;\n-use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n use rustc::session::config::{Input, OutputFilenames};\n@@ -848,9 +847,6 @@ pub fn print_after_parsing(sess: &Session,\n                            krate: &ast::Crate,\n                            ppm: PpMode,\n                            ofile: Option<&Path>) {\n-    let dep_graph = DepGraph::new(false);\n-    let _ignore = dep_graph.in_ignore();\n-\n     let (src, src_name) = get_source(input, sess);\n \n     let mut rdr = &*src;\n@@ -893,9 +889,6 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                 output_filenames: &OutputFilenames,\n                                                 opt_uii: Option<UserIdentifiedItem>,\n                                                 ofile: Option<&Path>) {\n-    let dep_graph = DepGraph::new(false);\n-    let _ignore = dep_graph.in_ignore();\n-\n     if ppm.needs_analysis() {\n         print_with_analysis(sess,\n                             cstore,"}, {"sha": "0fba6d8e9c67d13403e03f1d8d2807cc90cf8922", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -32,6 +32,7 @@ mod persist;\n \n pub use assert_dep_graph::assert_dep_graph;\n pub use persist::load_dep_graph;\n+pub use persist::load_dep_graph_new;\n pub use persist::save_dep_graph;\n pub use persist::save_trans_partition;\n pub use persist::save_work_products;"}, {"sha": "a6d39a918631c67c49e5d5855618c5404a2b3878", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 25, "deletions": 80, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -8,18 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Debugging code to test the state of the dependency graph just\n-//! after it is loaded from disk and just after it has been saved.\n+//! Debugging code to test fingerprints computed for query results.\n //! For each node marked with `#[rustc_clean]` or `#[rustc_dirty]`,\n-//! we will check that a suitable node for that item either appears\n-//! or does not appear in the dep-graph, as appropriate:\n+//! we will compare the fingerprint from the current and from the previous\n+//! compilation session as appropriate:\n //!\n //! - `#[rustc_dirty(label=\"TypeckTables\", cfg=\"rev2\")]` if we are\n-//!   in `#[cfg(rev2)]`, then there MUST NOT be a node\n-//!   `DepNode::TypeckTables(X)` where `X` is the def-id of the\n-//!   current node.\n+//!   in `#[cfg(rev2)]`, then the fingerprints associated with\n+//!   `DepNode::TypeckTables(X)` must be DIFFERENT (`X` is the def-id of the\n+//!   current node).\n //! - `#[rustc_clean(label=\"TypeckTables\", cfg=\"rev2\")]` same as above,\n-//!   except that the node MUST exist.\n+//!   except that the fingerprints must be the SAME.\n //!\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n@@ -40,9 +39,7 @@\n //! previous revision to compare things to.\n //!\n \n-use super::data::DepNodeIndex;\n-use super::load::DirtyNodes;\n-use rustc::dep_graph::{DepGraphQuery, DepNode, DepKind};\n+use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -51,41 +48,22 @@ use rustc::ich::{Fingerprint, ATTR_DIRTY, ATTR_CLEAN, ATTR_DIRTY_METADATA,\n                  ATTR_CLEAN_METADATA};\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use rustc_data_structures::indexed_vec::IndexVec;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n \n const LABEL: &'static str = \"label\";\n const CFG: &'static str = \"cfg\";\n \n-pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               nodes: &IndexVec<DepNodeIndex, DepNode>,\n-                                               dirty_inputs: &DirtyNodes) {\n+pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n     if !tcx.sess.features.borrow().rustc_attrs {\n         return;\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    let dirty_inputs: FxHashSet<DepNode> =\n-        dirty_inputs.keys()\n-                    .filter_map(|dep_node_index| {\n-                        let dep_node = nodes[*dep_node_index];\n-                        if dep_node.extract_def_id(tcx).is_some() {\n-                            Some(dep_node)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .collect();\n-\n-    let query = tcx.dep_graph.query();\n-    debug!(\"query-nodes: {:?}\", query.nodes());\n     let krate = tcx.hir.krate();\n     let mut dirty_clean_visitor = DirtyCleanVisitor {\n         tcx,\n-        query: &query,\n-        dirty_inputs,\n         checked_attrs: FxHashSet(),\n     };\n     krate.visit_all_item_likes(&mut dirty_clean_visitor);\n@@ -105,8 +83,6 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    query: &'a DepGraphQuery,\n-    dirty_inputs: FxHashSet<DepNode>,\n     checked_attrs: FxHashSet<ast::AttrId>,\n }\n \n@@ -143,59 +119,28 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     fn assert_dirty(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n-        match dep_node.kind {\n-            DepKind::Krate |\n-            DepKind::Hir |\n-            DepKind::HirBody => {\n-                // HIR nodes are inputs, so if we are asserting that the HIR node is\n-                // dirty, we check the dirty input set.\n-                if !self.dirty_inputs.contains(&dep_node) {\n-                    let dep_node_str = self.dep_node_str(&dep_node);\n-                    self.tcx.sess.span_err(\n-                        item_span,\n-                        &format!(\"`{}` not found in dirty set, but should be dirty\",\n-                                 dep_node_str));\n-                }\n-            }\n-            _ => {\n-                // Other kinds of nodes would be targets, so check if\n-                // the dep-graph contains the node.\n-                if self.query.contains_node(&dep_node) {\n-                    let dep_node_str = self.dep_node_str(&dep_node);\n-                    self.tcx.sess.span_err(\n-                        item_span,\n-                        &format!(\"`{}` found in dep graph, but should be dirty\", dep_node_str));\n-                }\n-            }\n+        let current_fingerprint = self.tcx.dep_graph.fingerprint_of(&dep_node);\n+        let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n+\n+        if current_fingerprint == prev_fingerprint {\n+            let dep_node_str = self.dep_node_str(&dep_node);\n+            self.tcx.sess.span_err(\n+                item_span,\n+                &format!(\"`{}` should be dirty but is not\", dep_node_str));\n         }\n     }\n \n     fn assert_clean(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n-        match dep_node.kind {\n-            DepKind::Krate |\n-            DepKind::Hir |\n-            DepKind::HirBody => {\n-                // For HIR nodes, check the inputs.\n-                if self.dirty_inputs.contains(&dep_node) {\n-                    let dep_node_str = self.dep_node_str(&dep_node);\n-                    self.tcx.sess.span_err(\n-                        item_span,\n-                        &format!(\"`{}` found in dirty-node set, but should be clean\",\n-                                 dep_node_str));\n-                }\n-            }\n-            _ => {\n-                // Otherwise, check if the dep-node exists.\n-                if !self.query.contains_node(&dep_node) {\n-                    let dep_node_str = self.dep_node_str(&dep_node);\n-                    self.tcx.sess.span_err(\n-                        item_span,\n-                        &format!(\"`{}` not found in dep graph, but should be clean\",\n-                                 dep_node_str));\n-                }\n-            }\n+        let current_fingerprint = self.tcx.dep_graph.fingerprint_of(&dep_node);\n+        let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n+\n+        if current_fingerprint != prev_fingerprint {\n+            let dep_node_str = self.dep_node_str(&dep_node);\n+            self.tcx.sess.span_err(\n+                item_span,\n+                &format!(\"`{}` should be clean but is not\", dep_node_str));\n         }\n     }\n "}, {"sha": "592b8f1a9eb20d402216b979469b8d2cbf9de108", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 5, "deletions": 120, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -114,15 +114,12 @@\n //! unsupported file system and emit a warning in that case. This is not yet\n //! implemented.\n \n-use rustc::hir::def_id::CrateNum;\n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n-use rustc::ty::TyCtxt;\n use rustc::util::fs as fs_util;\n use rustc_data_structures::{flock, base_n};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n-use std::ffi::OsString;\n use std::fs as std_fs;\n use std::io;\n use std::mem;\n@@ -132,6 +129,7 @@ use std::__rand::{thread_rng, Rng};\n \n const LOCK_FILE_EXT: &'static str = \".lock\";\n const DEP_GRAPH_FILENAME: &'static str = \"dep-graph.bin\";\n+const DEP_GRAPH_NEW_FILENAME: &'static str = \"dep-graph-new.bin\";\n const WORK_PRODUCTS_FILENAME: &'static str = \"work-products.bin\";\n const METADATA_HASHES_FILENAME: &'static str = \"metadata.bin\";\n \n@@ -145,6 +143,10 @@ pub fn dep_graph_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, DEP_GRAPH_FILENAME)\n }\n \n+pub fn dep_graph_path_new(sess: &Session) -> PathBuf {\n+    in_incr_comp_dir_sess(sess, DEP_GRAPH_NEW_FILENAME)\n+}\n+\n pub fn work_products_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, WORK_PRODUCTS_FILENAME)\n }\n@@ -153,10 +155,6 @@ pub fn metadata_hash_export_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, METADATA_HASHES_FILENAME)\n }\n \n-pub fn metadata_hash_import_path(import_session_dir: &Path) -> PathBuf {\n-    import_session_dir.join(METADATA_HASHES_FILENAME)\n-}\n-\n pub fn lock_file_path(session_dir: &Path) -> PathBuf {\n     let crate_dir = session_dir.parent().unwrap();\n \n@@ -616,70 +614,6 @@ fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n     Ok(UNIX_EPOCH + duration)\n }\n \n-fn crate_path_tcx(tcx: TyCtxt, cnum: CrateNum) -> PathBuf {\n-    crate_path(tcx.sess, &tcx.crate_name(cnum).as_str(), &tcx.crate_disambiguator(cnum).as_str())\n-}\n-\n-/// Finds the session directory containing the correct metadata hashes file for\n-/// the given crate. In order to do that it has to compute the crate directory\n-/// of the given crate, and in there, look for the session directory with the\n-/// correct SVH in it.\n-/// Note that we have to match on the exact SVH here, not just the\n-/// crate's (name, disambiguator) pair. The metadata hashes are only valid for\n-/// the exact version of the binary we are reading from now (i.e. the hashes\n-/// are part of the dependency graph of a specific compilation session).\n-pub fn find_metadata_hashes_for(tcx: TyCtxt, cnum: CrateNum) -> Option<PathBuf> {\n-    let crate_directory = crate_path_tcx(tcx, cnum);\n-\n-    if !crate_directory.exists() {\n-        return None\n-    }\n-\n-    let dir_entries = match crate_directory.read_dir() {\n-        Ok(dir_entries) => dir_entries,\n-        Err(e) => {\n-            tcx.sess\n-               .err(&format!(\"incremental compilation: Could not read crate directory `{}`: {}\",\n-                             crate_directory.display(), e));\n-            return None\n-        }\n-    };\n-\n-    let target_svh = tcx.crate_hash(cnum);\n-    let target_svh = base_n::encode(target_svh.as_u64(), INT_ENCODE_BASE);\n-\n-    let sub_dir = find_metadata_hashes_iter(&target_svh, dir_entries.filter_map(|e| {\n-        e.ok().map(|e| e.file_name().to_string_lossy().into_owned())\n-    }));\n-\n-    sub_dir.map(|sub_dir_name| crate_directory.join(&sub_dir_name))\n-}\n-\n-fn find_metadata_hashes_iter<'a, I>(target_svh: &str, iter: I) -> Option<OsString>\n-    where I: Iterator<Item=String>\n-{\n-    for sub_dir_name in iter {\n-        if !is_session_directory(&sub_dir_name) || !is_finalized(&sub_dir_name) {\n-            // This is not a usable session directory\n-            continue\n-        }\n-\n-        let is_match = if let Some(last_dash_pos) = sub_dir_name.rfind(\"-\") {\n-            let candidate_svh = &sub_dir_name[last_dash_pos + 1 .. ];\n-            target_svh == candidate_svh\n-        } else {\n-            // some kind of invalid directory name\n-            continue\n-        };\n-\n-        if is_match {\n-            return Some(OsString::from(sub_dir_name))\n-        }\n-    }\n-\n-    None\n-}\n-\n fn crate_path(sess: &Session,\n               crate_name: &str,\n               crate_disambiguator: &str)\n@@ -1019,52 +953,3 @@ fn test_find_source_directory_in_iter() {\n              PathBuf::from(\"crate-dir/s-1234-0000-working\")].into_iter(), &already_visited),\n         None);\n }\n-\n-#[test]\n-fn test_find_metadata_hashes_iter()\n-{\n-    assert_eq!(find_metadata_hashes_iter(\"testsvh2\",\n-        vec![\n-            String::from(\"s-timestamp1-testsvh1\"),\n-            String::from(\"s-timestamp2-testsvh2\"),\n-            String::from(\"s-timestamp3-testsvh3\"),\n-        ].into_iter()),\n-        Some(OsString::from(\"s-timestamp2-testsvh2\"))\n-    );\n-\n-    assert_eq!(find_metadata_hashes_iter(\"testsvh2\",\n-        vec![\n-            String::from(\"s-timestamp1-testsvh1\"),\n-            String::from(\"s-timestamp2-testsvh2\"),\n-            String::from(\"invalid-name\"),\n-        ].into_iter()),\n-        Some(OsString::from(\"s-timestamp2-testsvh2\"))\n-    );\n-\n-    assert_eq!(find_metadata_hashes_iter(\"testsvh2\",\n-        vec![\n-            String::from(\"s-timestamp1-testsvh1\"),\n-            String::from(\"s-timestamp2-testsvh2-working\"),\n-            String::from(\"s-timestamp3-testsvh3\"),\n-        ].into_iter()),\n-        None\n-    );\n-\n-    assert_eq!(find_metadata_hashes_iter(\"testsvh1\",\n-        vec![\n-            String::from(\"s-timestamp1-random1-working\"),\n-            String::from(\"s-timestamp2-random2-working\"),\n-            String::from(\"s-timestamp3-random3-working\"),\n-        ].into_iter()),\n-        None\n-    );\n-\n-    assert_eq!(find_metadata_hashes_iter(\"testsvh2\",\n-        vec![\n-            String::from(\"timestamp1-testsvh2\"),\n-            String::from(\"timestamp2-testsvh2\"),\n-            String::from(\"timestamp3-testsvh2\"),\n-        ].into_iter()),\n-        None\n-    );\n-}"}, {"sha": "f7ea0a07f3df25321ad0b8159642f05ee197d19f", "filename": "src/librustc_incremental/persist/hash.rs", "status": "removed", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/24831c7221c7b4e32a02f8e8cffe7dfacb88b520/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24831c7221c7b4e32a02f8e8cffe7dfacb88b520/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=24831c7221c7b4e32a02f8e8cffe7dfacb88b520", "patch": "@@ -1,202 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::dep_graph::{DepNode, DepKind};\n-use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::hir::svh::Svh;\n-use rustc::ich::Fingerprint;\n-use rustc::ty::TyCtxt;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::flock;\n-use rustc_serialize::Decodable;\n-use rustc_serialize::opaque::Decoder;\n-\n-use super::data::*;\n-use super::fs::*;\n-use super::file_format;\n-\n-use std::hash::Hash;\n-use std::fmt::Debug;\n-\n-pub struct HashContext<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    metadata_hashes: FxHashMap<DefId, Fingerprint>,\n-    crate_hashes: FxHashMap<CrateNum, Svh>,\n-}\n-\n-impl<'a, 'tcx> HashContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        HashContext {\n-            tcx,\n-            metadata_hashes: FxHashMap(),\n-            crate_hashes: FxHashMap(),\n-        }\n-    }\n-\n-    pub fn hash(&mut self, dep_node: &DepNode) -> Option<Fingerprint> {\n-        match dep_node.kind {\n-            // HIR nodes (which always come from our crate) are an input:\n-            DepKind::Krate |\n-            DepKind::InScopeTraits |\n-            DepKind::Hir |\n-            DepKind::HirBody => {\n-                Some(self.tcx.dep_graph.fingerprint_of(dep_node).unwrap())\n-            }\n-\n-            // MetaData from other crates is an *input* to us.\n-            // MetaData nodes from *our* crates are an *output*; we\n-            // don't hash them, but we do compute a hash for them and\n-            // save it for others to use.\n-            DepKind::MetaData => {\n-                let def_id = dep_node.extract_def_id(self.tcx).unwrap();\n-                assert!(!def_id.is_local());\n-\n-                Some(self.metadata_hash(def_id,\n-                                        def_id.krate,\n-                                        |this| &mut this.metadata_hashes))\n-            }\n-\n-            _ => {\n-                // Other kinds of nodes represent computed by-products\n-                // that we don't hash directly; instead, they should\n-                // have some transitive dependency on a Hir or\n-                // MetaData node, so we'll just hash that\n-                None\n-            }\n-        }\n-    }\n-\n-    fn metadata_hash<K, C>(&mut self,\n-                           key: K,\n-                           cnum: CrateNum,\n-                           cache: C)\n-                           -> Fingerprint\n-        where K: Hash + Eq + Debug,\n-              C: Fn(&mut Self) -> &mut FxHashMap<K, Fingerprint>,\n-    {\n-        debug!(\"metadata_hash(key={:?})\", key);\n-\n-        debug_assert!(cnum != LOCAL_CRATE);\n-        loop {\n-            // check whether we have a result cached for this def-id\n-            if let Some(&hash) = cache(self).get(&key) {\n-                return hash;\n-            }\n-\n-            // check whether we did not find detailed metadata for this\n-            // krate; in that case, we just use the krate's overall hash\n-            if let Some(&svh) = self.crate_hashes.get(&cnum) {\n-                // micro-\"optimization\": avoid a cache miss if we ask\n-                // for metadata from this particular def-id again.\n-                let fingerprint = svh_to_fingerprint(svh);\n-                cache(self).insert(key, fingerprint);\n-\n-                return fingerprint;\n-            }\n-\n-            // otherwise, load the data and repeat.\n-            self.load_data(cnum);\n-            assert!(self.crate_hashes.contains_key(&cnum));\n-        }\n-    }\n-\n-    fn load_data(&mut self, cnum: CrateNum) {\n-        debug!(\"load_data(cnum={})\", cnum);\n-\n-        let svh = self.tcx.crate_hash(cnum);\n-        let old = self.crate_hashes.insert(cnum, svh);\n-        debug!(\"load_data: svh={}\", svh);\n-        assert!(old.is_none(), \"loaded data for crate {:?} twice\", cnum);\n-\n-        if let Some(session_dir) = find_metadata_hashes_for(self.tcx, cnum) {\n-            debug!(\"load_data: session_dir={:?}\", session_dir);\n-\n-            // Lock the directory we'll be reading  the hashes from.\n-            let lock_file_path = lock_file_path(&session_dir);\n-            let _lock = match flock::Lock::new(&lock_file_path,\n-                                               false,   // don't wait\n-                                               false,   // don't create the lock-file\n-                                               false) { // shared lock\n-                Ok(lock) => lock,\n-                Err(err) => {\n-                    debug!(\"Could not acquire lock on `{}` while trying to \\\n-                            load metadata hashes: {}\",\n-                            lock_file_path.display(),\n-                            err);\n-\n-                    // Could not acquire the lock. The directory is probably in\n-                    // in the process of being deleted. It's OK to just exit\n-                    // here. It's the same scenario as if the file had not\n-                    // existed in the first place.\n-                    return\n-                }\n-            };\n-\n-            let hashes_file_path = metadata_hash_import_path(&session_dir);\n-\n-            match file_format::read_file(self.tcx.sess, &hashes_file_path)\n-            {\n-                Ok(Some(data)) => {\n-                    match self.load_from_data(cnum, &data, svh) {\n-                        Ok(()) => { }\n-                        Err(err) => {\n-                            bug!(\"decoding error in dep-graph from `{}`: {}\",\n-                                 &hashes_file_path.display(), err);\n-                        }\n-                    }\n-                }\n-                Ok(None) => {\n-                    // If the file is not found, that's ok.\n-                }\n-                Err(err) => {\n-                    self.tcx.sess.err(\n-                        &format!(\"could not load dep information from `{}`: {}\",\n-                                 hashes_file_path.display(), err));\n-                }\n-            }\n-        }\n-    }\n-\n-    fn load_from_data(&mut self,\n-                      cnum: CrateNum,\n-                      data: &[u8],\n-                      expected_svh: Svh) -> Result<(), String> {\n-        debug!(\"load_from_data(cnum={})\", cnum);\n-\n-        // Load up the hashes for the def-ids from this crate.\n-        let mut decoder = Decoder::new(data, 0);\n-        let svh_in_hashes_file = Svh::decode(&mut decoder)?;\n-\n-        if svh_in_hashes_file != expected_svh {\n-            // We should not be able to get here. If we do, then\n-            // `fs::find_metadata_hashes_for()` has messed up.\n-            bug!(\"mismatch between SVH in crate and SVH in incr. comp. hashes\")\n-        }\n-\n-        let serialized_hashes = SerializedMetadataHashes::decode(&mut decoder)?;\n-        for serialized_hash in serialized_hashes.entry_hashes {\n-            // the hashes are stored with just a def-index, which is\n-            // always relative to the old crate; convert that to use\n-            // our internal crate number\n-            let def_id = DefId { krate: cnum, index: serialized_hash.def_index };\n-\n-            // record the hash for this dep-node\n-            let old = self.metadata_hashes.insert(def_id, serialized_hash.hash);\n-            debug!(\"load_from_data: def_id={:?} hash={}\", def_id, serialized_hash.hash);\n-            assert!(old.is_none(), \"already have hash for {:?}\", def_id);\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n-fn svh_to_fingerprint(svh: Svh) -> Fingerprint {\n-    Fingerprint::from_smaller_hash(svh.as_u64())\n-}"}, {"sha": "6d019a25ed3ec4cc83ba4d2132a78b032ae005fc", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -10,7 +10,7 @@\n \n //! Code to save/load the dep-graph from files.\n \n-use rustc::dep_graph::{DepNode, WorkProductId, DepKind};\n+use rustc::dep_graph::{DepNode, WorkProductId, DepKind, PreviousDepGraph};\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n use rustc::session::Session;\n@@ -23,8 +23,6 @@ use rustc_serialize::opaque::Decoder;\n use std::path::{Path};\n \n use super::data::*;\n-use super::dirty_clean;\n-use super::hash::*;\n use super::fs::*;\n use super::file_format;\n use super::work_product;\n@@ -40,6 +38,7 @@ pub type DirtyNodes = FxHashMap<DepNodeIndex, DepNodeIndex>;\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    tcx.allocate_metadata_dep_nodes();\n     tcx.precompute_in_scope_traits_hashes();\n     if tcx.sess.incr_session_load_dep_graph() {\n         let _ignore = tcx.dep_graph.in_ignore();\n@@ -103,7 +102,7 @@ fn does_still_exist(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n         DepKind::Hir |\n         DepKind::HirBody |\n         DepKind::InScopeTraits |\n-        DepKind::MetaData => {\n+        DepKind::CrateMetadata => {\n             dep_node.extract_def_id(tcx).is_some()\n         }\n         _ => {\n@@ -186,9 +185,6 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // dirty.\n     reconcile_work_products(tcx, work_products, &clean_work_products);\n \n-    dirty_clean::check_dirty_clean_annotations(tcx,\n-                                               &serialized_dep_graph.nodes,\n-                                               &dirty_raw_nodes);\n     Ok(())\n }\n \n@@ -198,15 +194,12 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  nodes: &IndexVec<DepNodeIndex, DepNode>,\n                                  serialized_hashes: &[(DepNodeIndex, Fingerprint)])\n                                  -> DirtyNodes {\n-    let mut hcx = HashContext::new(tcx);\n     let mut dirty_nodes = FxHashMap();\n \n     for &(dep_node_index, prev_hash) in serialized_hashes {\n         let dep_node = nodes[dep_node_index];\n         if does_still_exist(tcx, &dep_node) {\n-            let current_hash = hcx.hash(&dep_node).unwrap_or_else(|| {\n-                bug!(\"Cannot find current ICH for input that still exists?\")\n-            });\n+            let current_hash = tcx.dep_graph.fingerprint_of(&dep_node);\n \n             if current_hash == prev_hash {\n                 debug!(\"initial_dirty_nodes: {:?} is clean (hash={:?})\",\n@@ -416,7 +409,7 @@ fn process_edge<'a, 'tcx, 'edges>(\n     // clean target because removing the input would have dirtied the input\n     // node and transitively dirtied the target.\n     debug_assert!(match nodes[source].kind {\n-        DepKind::Hir | DepKind::HirBody | DepKind::MetaData => {\n+        DepKind::Hir | DepKind::HirBody | DepKind::CrateMetadata => {\n             does_still_exist(tcx, &nodes[source])\n         }\n         _ => true,\n@@ -433,3 +426,38 @@ fn process_edge<'a, 'tcx, 'edges>(\n         }\n     }\n }\n+\n+pub fn load_dep_graph_new(sess: &Session) -> PreviousDepGraph {\n+    use rustc::dep_graph::SerializedDepGraph as SerializedDepGraphNew;\n+\n+    let empty = PreviousDepGraph::new(SerializedDepGraphNew::new());\n+\n+    if sess.opts.incremental.is_none() {\n+        return empty\n+    }\n+\n+    if let Some(bytes) = load_data(sess, &dep_graph_path_new(sess)) {\n+        let mut decoder = Decoder::new(&bytes, 0);\n+        let prev_commandline_args_hash = u64::decode(&mut decoder)\n+            .expect(\"Error reading commandline arg hash from cached dep-graph\");\n+\n+        if prev_commandline_args_hash != sess.opts.dep_tracking_hash() {\n+            if sess.opts.debugging_opts.incremental_info {\n+                eprintln!(\"incremental: completely ignoring cache because of \\\n+                           differing commandline arguments\");\n+            }\n+            // We can't reuse the cache, purge it.\n+            debug!(\"load_dep_graph_new: differing commandline arg hashes\");\n+\n+            // No need to do any further work\n+            return empty\n+        }\n+\n+        let dep_graph = SerializedDepGraphNew::decode(&mut decoder)\n+            .expect(\"Error reading cached dep-graph\");\n+\n+        PreviousDepGraph::new(dep_graph)\n+    } else {\n+        empty\n+    }\n+}"}, {"sha": "688d8add57e3fd49f38dc67ebe317f3433ccd2f1", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -15,7 +15,6 @@\n mod data;\n mod dirty_clean;\n mod fs;\n-mod hash;\n mod load;\n mod preds;\n mod save;\n@@ -26,6 +25,7 @@ pub use self::fs::prepare_session_directory;\n pub use self::fs::finalize_session_directory;\n pub use self::fs::in_incr_comp_dir;\n pub use self::load::load_dep_graph;\n+pub use self::load::load_dep_graph_new;\n pub use self::save::save_dep_graph;\n pub use self::save::save_work_products;\n pub use self::work_product::save_trans_partition;"}, {"sha": "a552a27c62af0f9eec9356a9a3e1ed88393d4fbf", "filename": "src/librustc_incremental/persist/preds/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -10,10 +10,10 @@\n \n use rustc::dep_graph::{DepGraphQuery, DepNode, DepKind};\n use rustc::ich::Fingerprint;\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{Graph, NodeIndex};\n \n-use super::hash::*;\n \n mod compress;\n \n@@ -40,15 +40,13 @@ pub struct Predecessors<'query> {\n }\n \n impl<'q> Predecessors<'q> {\n-    pub fn new(query: &'q DepGraphQuery, hcx: &mut HashContext) -> Self {\n-        let tcx = hcx.tcx;\n-\n+    pub fn new(tcx: TyCtxt, query: &'q DepGraphQuery) -> Self {\n         // Find the set of \"start nodes\". These are nodes that we will\n         // possibly query later.\n         let is_output = |node: &DepNode| -> bool {\n             match node.kind {\n                 DepKind::WorkProduct => true,\n-                DepKind::MetaData => {\n+                DepKind::CrateMetadata => {\n                     // We do *not* create dep-nodes for the current crate's\n                     // metadata anymore, just for metadata that we import/read\n                     // from other crates.\n@@ -74,7 +72,7 @@ impl<'q> Predecessors<'q> {\n             let input = *graph.node_data(input_index);\n             debug!(\"computing hash for input node `{:?}`\", input);\n             hashes.entry(input)\n-                  .or_insert_with(|| hcx.hash(input).unwrap());\n+                  .or_insert_with(|| tcx.dep_graph.fingerprint_of(&input));\n         }\n \n         if tcx.sess.opts.debugging_opts.query_dep_graph {\n@@ -89,7 +87,7 @@ impl<'q> Predecessors<'q> {\n \n             for node in hir_nodes {\n                 hashes.entry(node)\n-                      .or_insert_with(|| hcx.hash(node).unwrap());\n+                      .or_insert_with(|| tcx.dep_graph.fingerprint_of(&node));\n             }\n         }\n "}, {"sha": "83a618211dad3c5b213ebbc677ca5b155f6f434a", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -15,6 +15,7 @@ use rustc::ich::Fingerprint;\n use rustc::middle::cstore::EncodedMetadataHashes;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n+use rustc::util::common::time;\n use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph;\n@@ -26,7 +27,6 @@ use std::fs::{self, File};\n use std::path::PathBuf;\n \n use super::data::*;\n-use super::hash::*;\n use super::preds::*;\n use super::fs::*;\n use super::dirty_clean;\n@@ -45,13 +45,6 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return;\n     }\n \n-    let query = tcx.dep_graph.query();\n-\n-    if tcx.sess.opts.debugging_opts.incremental_info {\n-        eprintln!(\"incremental: {} nodes in dep-graph\", query.graph.len_nodes());\n-        eprintln!(\"incremental: {} edges in dep-graph\", query.graph.len_edges());\n-    }\n-\n     // We load the previous metadata hashes now before overwriting the file\n     // (if we need them for testing).\n     let prev_metadata_hashes = if tcx.sess.opts.debugging_opts.query_dep_graph {\n@@ -60,8 +53,6 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         DefIdMap()\n     };\n \n-    let mut hcx = HashContext::new(tcx);\n-    let preds = Predecessors::new(&query, &mut hcx);\n     let mut current_metadata_hashes = FxHashMap();\n \n     // IMPORTANT: We are saving the metadata hashes *before* the dep-graph,\n@@ -78,10 +69,27 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            e));\n     }\n \n-    save_in(sess,\n-            dep_graph_path(sess),\n-            |e| encode_dep_graph(tcx, &preds, e));\n+    time(sess.time_passes(), \"persist dep-graph (old)\", || {\n+        let query = tcx.dep_graph.query();\n+\n+        if tcx.sess.opts.debugging_opts.incremental_info {\n+            eprintln!(\"incremental: {} nodes in dep-graph\", query.graph.len_nodes());\n+            eprintln!(\"incremental: {} edges in dep-graph\", query.graph.len_edges());\n+        }\n+\n+        let preds = Predecessors::new(tcx, &query);\n+        save_in(sess,\n+                dep_graph_path(sess),\n+                |e| encode_dep_graph(tcx, &preds, e));\n+    });\n+\n+    time(sess.time_passes(), \"persist dep-graph (new)\", || {\n+        save_in(sess,\n+                dep_graph_path_new(sess),\n+                |e| encode_dep_graph_new(tcx, e));\n+    });\n \n+    dirty_clean::check_dirty_clean_annotations(tcx);\n     dirty_clean::check_dirty_clean_metadata(tcx,\n                                             &prev_metadata_hashes,\n                                             &current_metadata_hashes);\n@@ -174,6 +182,19 @@ fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n     }\n }\n \n+fn encode_dep_graph_new(tcx: TyCtxt,\n+                        encoder: &mut Encoder)\n+                        -> io::Result<()> {\n+    // First encode the commandline arguments hash\n+    tcx.sess.opts.dep_tracking_hash().encode(encoder)?;\n+\n+    // Encode the graph data.\n+    let serialized_graph = tcx.dep_graph.serialize();\n+    serialized_graph.encode(encoder)?;\n+\n+    Ok(())\n+}\n+\n pub fn encode_dep_graph(tcx: TyCtxt,\n                         preds: &Predecessors,\n                         encoder: &mut Encoder)"}, {"sha": "8eacc21ab003b59e96b6d303ea9671230a4a8edf", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -55,9 +55,14 @@ macro_rules! provide {\n                 let ($def_id, $other) = def_id_arg.into_args();\n                 assert!(!$def_id.is_local());\n \n-                let def_path_hash = $tcx.def_path_hash($def_id);\n-                let dep_node = def_path_hash.to_dep_node(::rustc::dep_graph::DepKind::MetaData);\n-\n+                let def_path_hash = $tcx.def_path_hash(DefId {\n+                    krate: $def_id.krate,\n+                    index: CRATE_DEF_INDEX\n+                });\n+                let dep_node = def_path_hash\n+                    .to_dep_node(::rustc::dep_graph::DepKind::CrateMetadata);\n+                // The DepNodeIndex of the DepNode::CrateMetadata should be\n+                // cached somewhere, so that we can use read_index().\n                 $tcx.dep_graph.read(dep_node);\n \n                 let $cdata = $tcx.crate_data_as_rc_any($def_id.krate);\n@@ -379,6 +384,16 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).name\n     }\n \n+    fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> Symbol\n+    {\n+        self.get_crate_data(cnum).disambiguator()\n+    }\n+\n+    fn crate_hash_untracked(&self, cnum: CrateNum) -> hir::svh::Svh\n+    {\n+        self.get_crate_data(cnum).hash()\n+    }\n+\n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to."}, {"sha": "74d610d1d120a28e52eab031752fa2598710372b", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -942,8 +942,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n \n     let crate_hash = tcx.dep_graph\n-                        .fingerprint_of(&DepNode::new_no_params(DepKind::Krate))\n-                        .unwrap();\n+                        .fingerprint_of(&DepNode::new_no_params(DepKind::Krate));\n     let link_meta = link::build_link_meta(crate_hash);\n     let exported_symbol_node_ids = find_exported_symbols(tcx);\n "}, {"sha": "355983e9ca1b9e53f3a8795d64087732ba458b41", "filename": "src/test/incremental/callee_caller_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -12,6 +12,8 @@\n // revisions:rpass1 rpass2\n // compile-flags:-Z query-dep-graph\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "d58a9bacdb53ca4c7ed10f500ea7b65257cc8815", "filename": "src/test/incremental/change_private_fn_cc/struct_point.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -15,6 +15,8 @@\n // compile-flags: -Z query-dep-graph\n // aux-build:point.rs\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]\n #![allow(dead_code)]"}, {"sha": "3f665f5c82052da07458916a2a5231583c5bec64", "filename": "src/test/incremental/change_private_impl_method_cc/struct_point.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -15,6 +15,8 @@\n // compile-flags: -Z query-dep-graph\n // aux-build:point.rs\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]\n #![allow(dead_code)]"}, {"sha": "6d54cf53660a9ce62e75c3e9fa78879cc04a7249", "filename": "src/test/incremental/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fdirty_clean.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -37,14 +37,14 @@ mod y {\n \n     #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n     pub fn y() {\n-        //[cfail2]~^ ERROR `TypeckTables(y::y)` not found in dep graph, but should be clean\n+        //[cfail2]~^ ERROR `TypeckTables(y::y)` should be clean but is not\n         x::x();\n     }\n }\n \n mod z {\n     #[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n     pub fn z() {\n-        //[cfail2]~^ ERROR `TypeckTables(z::z)` found in dep graph, but should be dirty\n+        //[cfail2]~^ ERROR `TypeckTables(z::z)` should be dirty but is not\n     }\n }"}, {"sha": "8f84266d5a4e5f7037ff4808780a6d05cb4a7034", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -143,7 +143,7 @@ enum EnumChangeValueCStyleVariant1 {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]"}, {"sha": "39065d9671ace089b3736c11403e75b6835faf48", "filename": "src/test/incremental/rlib_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -18,6 +18,8 @@\n // no-prefer-dynamic\n // compile-flags: -Z query-dep-graph\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "760975b292f95fc01bfc64fc41b679354e76b6e3", "filename": "src/test/incremental/string_constant.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fstring_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fstring_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstring_constant.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -27,7 +27,8 @@ mod x {\n     }\n \n     #[cfg(rpass2)]\n-    #[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"MirOptimized\", cfg=\"rpass2\")]\n     pub fn x() {\n         println!(\"{}\", \"2\");\n     }\n@@ -37,6 +38,7 @@ mod y {\n     use x;\n \n     #[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"MirOptimized\", cfg=\"rpass2\")]\n     pub fn y() {\n         x::x();\n     }\n@@ -46,6 +48,7 @@ mod z {\n     use y;\n \n     #[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"MirOptimized\", cfg=\"rpass2\")]\n     pub fn z() {\n         y::y();\n     }"}, {"sha": "e5ec9784847f0b4c5882a04441f0974aed7dda62", "filename": "src/test/incremental/struct_change_field_type_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -12,6 +12,8 @@\n // revisions:rpass1 rpass2\n // compile-flags: -Z query-dep-graph\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "63e1437f0687be4398da2d6805e111ed77afac69", "filename": "src/test/incremental/type_alias_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb73dbe8b311eb2ffa640ac3e01795d84159df4/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs?ref=acb73dbe8b311eb2ffa640ac3e01795d84159df4", "patch": "@@ -12,6 +12,8 @@\n // revisions:rpass1 rpass2 rpass3\n // compile-flags: -Z query-dep-graph\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n \n extern crate a;"}]}