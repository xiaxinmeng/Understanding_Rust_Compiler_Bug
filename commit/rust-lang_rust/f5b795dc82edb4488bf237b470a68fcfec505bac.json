{"sha": "f5b795dc82edb4488bf237b470a68fcfec505bac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1Yjc5NWRjODJlZGI0NDg4YmYyMzdiNDcwYTY4ZmNmZWM1MDViYWM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-10-07T16:30:35Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-11-24T12:19:26Z"}, "message": "compiletest: extend syntax with support for choosing same line as previous line.", "tree": {"sha": "99c30c5af9bee24ec15f2bc9d31ad549409a9b26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99c30c5af9bee24ec15f2bc9d31ad549409a9b26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5b795dc82edb4488bf237b470a68fcfec505bac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5b795dc82edb4488bf237b470a68fcfec505bac", "html_url": "https://github.com/rust-lang/rust/commit/f5b795dc82edb4488bf237b470a68fcfec505bac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5b795dc82edb4488bf237b470a68fcfec505bac/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bad1062caaaefe0963d7b8513786c8283e74f1e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bad1062caaaefe0963d7b8513786c8283e74f1e7", "html_url": "https://github.com/rust-lang/rust/commit/bad1062caaaefe0963d7b8513786c8283e74f1e7"}], "stats": {"total": 65, "additions": 56, "deletions": 9}, "files": [{"sha": "f15db7d9371de78a3b26c820ead946c6b076e4d1", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f5b795dc82edb4488bf237b470a68fcfec505bac/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b795dc82edb4488bf237b470a68fcfec505bac/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=f5b795dc82edb4488bf237b470a68fcfec505bac", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+use self::WhichLine::*;\n \n use std::ascii::AsciiExt;\n use std::io::{BufferedReader, File};\n@@ -18,28 +19,74 @@ pub struct ExpectedError {\n     pub msg: String,\n }\n \n-pub static EXPECTED_PATTERN : &'static str = r\"//~(?P<adjusts>\\^*)\\s*(?P<kind>\\S*)\\s*(?P<msg>.*)\";\n+/// Looks for either \"//~| KIND MESSAGE\" or \"//~^^... KIND MESSAGE\"\n+/// The former is a \"follow\" that inherits its target from the preceding line;\n+/// the latter is an \"adjusts\" that goes that many lines up.\n+///\n+/// Goal is to enable tests both like: //~^^^ ERROR go up three\n+/// and also //~^ ERROR message one for the preceding line, and\n+///          //~| ERROR message two for that same line.\n+\n+pub static EXPECTED_PATTERN : &'static str =\n+    r\"//~(?P<follow>\\|)?(?P<adjusts>\\^*)\\s*(?P<kind>\\S*)\\s*(?P<msg>.*)\";\n+\n+#[deriving(PartialEq, Show)]\n+enum WhichLine { ThisLine, FollowPrevious(uint), AdjustBackward(uint) }\n \n // Load any test directives embedded in the file\n pub fn load_errors(re: &Regex, testfile: &Path) -> Vec<ExpectedError> {\n     let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n \n+    // `last_nonfollow_error` tracks the most recently seen\n+    // line with an error template that did not use the\n+    // follow-syntax, \"//~| ...\".\n+    //\n+    // (pnkfelix could not find an easy way to compose Iterator::scan\n+    // and Iterator::filter_map to pass along this information into\n+    // `parse_expected`. So instead I am storing that state here and\n+    // updating it in the map callback below.)\n+    let mut last_nonfollow_error = None;\n+\n     rdr.lines().enumerate().filter_map(|(line_no, ln)| {\n-        parse_expected(line_no + 1, ln.unwrap().as_slice(), re)\n+        parse_expected(last_nonfollow_error,\n+                       line_no + 1,\n+                       ln.unwrap().as_slice(), re)\n+            .map(|(which, error)| {\n+                match which {\n+                    FollowPrevious(_) => {}\n+                    _ => last_nonfollow_error = Some(error.line),\n+                }\n+                error\n+            })\n     }).collect()\n }\n \n-fn parse_expected(line_num: uint, line: &str, re: &Regex) -> Option<ExpectedError> {\n+fn parse_expected(last_nonfollow_error: Option<uint>,\n+                  line_num: uint,\n+                  line: &str,\n+                  re: &Regex) -> Option<(WhichLine, ExpectedError)> {\n     re.captures(line).and_then(|caps| {\n         let adjusts = caps.name(\"adjusts\").len();\n         let kind = caps.name(\"kind\").to_ascii_lower();\n         let msg = caps.name(\"msg\").trim().to_string();\n+        let follow = caps.name(\"follow\").len() > 0;\n+\n+        let (which, line) = if follow {\n+            assert!(adjusts == 0, \"use either //~| or //~^, not both.\");\n+            let line = last_nonfollow_error.unwrap_or_else(|| {\n+                panic!(\"encountered //~| without preceding //~^ line.\")\n+            });\n+            (FollowPrevious(line), line)\n+        } else {\n+            let which =\n+                if adjusts > 0 { AdjustBackward(adjusts) } else { ThisLine };\n+            let line = line_num - adjusts;\n+            (which, line)\n+        };\n \n-        debug!(\"line={} kind={} msg={}\", line_num, kind, msg);\n-        Some(ExpectedError {\n-            line: line_num - adjusts,\n-            kind: kind,\n-            msg: msg,\n-        })\n+        debug!(\"line={} which={} kind={} msg={}\", line_num, which, kind, msg);\n+        Some((which, ExpectedError { line: line,\n+                                     kind: kind,\n+                                     msg: msg, }))\n     })\n }"}]}