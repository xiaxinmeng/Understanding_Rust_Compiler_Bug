{"sha": "d201e278ba6f9e2f8d9046eb983116b839807c98", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMDFlMjc4YmE2ZjllMmY4ZDkwNDZlYjk4MzExNmI4Mzk4MDdjOTg=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-09-20T21:29:39Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-09-22T18:33:13Z"}, "message": "review comments", "tree": {"sha": "bca65bb0561e89a2398ca53a73e50d52a98d7cba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bca65bb0561e89a2398ca53a73e50d52a98d7cba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d201e278ba6f9e2f8d9046eb983116b839807c98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d201e278ba6f9e2f8d9046eb983116b839807c98", "html_url": "https://github.com/rust-lang/rust/commit/d201e278ba6f9e2f8d9046eb983116b839807c98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d201e278ba6f9e2f8d9046eb983116b839807c98/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4be51c879e763fefd31f02766ab967d9943f65c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4be51c879e763fefd31f02766ab967d9943f65c7", "html_url": "https://github.com/rust-lang/rust/commit/4be51c879e763fefd31f02766ab967d9943f65c7"}], "stats": {"total": 39, "additions": 19, "deletions": 20}, "files": [{"sha": "38071a9e74da879792124e8e7715da558541b366", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d201e278ba6f9e2f8d9046eb983116b839807c98/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d201e278ba6f9e2f8d9046eb983116b839807c98/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d201e278ba6f9e2f8d9046eb983116b839807c98", "patch": "@@ -3481,31 +3481,30 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         errors: &mut Vec<traits::FulfillmentError<'_>>,\n         call_expr: &'tcx hir::Expr,\n     ) {\n-        if let hir::ExprKind::Call(path, _args) = &call_expr.node {\n+        if let hir::ExprKind::Call(path, _) = &call_expr.node {\n             if let hir::ExprKind::Path(qpath) = &path.node {\n-                if let hir::QPath::Resolved(_self, path) = &qpath {\n+                if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n                         if let ty::Predicate::Trait(predicate) = error.obligation.predicate {\n                             // If any of the type arguments in this path segment caused the\n                             // `FullfillmentError`, point at its span (#61860).\n-                            for segment in &path.segments {\n-                                if let Some(args) = &segment.args {\n-                                    for arg in &args.args {\n-                                        if let hir::GenericArg::Type(hir_ty) = &arg {\n-                                            if let hir::TyKind::Path(\n-                                                hir::QPath::TypeRelative(..),\n-                                            ) = &hir_ty.node {\n-                                                // Avoid ICE with associated types. As this is best\n-                                                // effort only, it's ok to ignore the case. It\n-                                                // would trigger in `is_send::<T::AssocType>();`\n-                                                // from `typeck-default-trait-impl-assoc-type.rs`.\n-                                            } else {\n-                                                let ty = AstConv::ast_ty_to_ty(self, hir_ty);\n-                                                let ty = self.resolve_vars_if_possible(&ty);\n-                                                if ty == predicate.skip_binder().self_ty() {\n-                                                    error.obligation.cause.span = hir_ty.span;\n-                                                }\n-                                            }\n+                            for arg in path.segments.iter()\n+                                .filter_map(|seg| seg.args.as_ref())\n+                                .flat_map(|a| a.args.iter())\n+                            {\n+                                if let hir::GenericArg::Type(hir_ty) = &arg {\n+                                    if let hir::TyKind::Path(\n+                                        hir::QPath::TypeRelative(..),\n+                                    ) = &hir_ty.node {\n+                                        // Avoid ICE with associated types. As this is best\n+                                        // effort only, it's ok to ignore the case. It\n+                                        // would trigger in `is_send::<T::AssocType>();`\n+                                        // from `typeck-default-trait-impl-assoc-type.rs`.\n+                                    } else {\n+                                        let ty = AstConv::ast_ty_to_ty(self, hir_ty);\n+                                        let ty = self.resolve_vars_if_possible(&ty);\n+                                        if ty == predicate.skip_binder().self_ty() {\n+                                            error.obligation.cause.span = hir_ty.span;\n                                         }\n                                     }\n                                 }"}]}