{"sha": "720bcd81de9d5fbdb60761fc929d40e487005722", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMGJjZDgxZGU5ZDVmYmRiNjA3NjFmYzkyOWQ0MGU0ODcwMDU3MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T04:32:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T04:32:22Z"}, "message": "auto merge of #10652 : jld/rust/enum-unstruct, r=thestinger\n\nThis is needed so that the FFI works as expected on platforms that don't\r\nflatten aggregates the way the AMD64 ABI does, especially for `#[repr(C)]`.\r\n\r\nThis moves more of `type_of` into `trans::adt`, because the type might\r\nor might not be an LLVM struct.\r\n\r\nCloses #10308.", "tree": {"sha": "d4b3631a582b7bca65f25945b5b22c89a3708fce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4b3631a582b7bca65f25945b5b22c89a3708fce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/720bcd81de9d5fbdb60761fc929d40e487005722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/720bcd81de9d5fbdb60761fc929d40e487005722", "html_url": "https://github.com/rust-lang/rust/commit/720bcd81de9d5fbdb60761fc929d40e487005722", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/720bcd81de9d5fbdb60761fc929d40e487005722/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffaee0fd96b5d23ae9668605d1425111f4210c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffaee0fd96b5d23ae9668605d1425111f4210c58", "html_url": "https://github.com/rust-lang/rust/commit/ffaee0fd96b5d23ae9668605d1425111f4210c58"}, {"sha": "0c04a26b3f8ba70ea686e1a365729835c62c26eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c04a26b3f8ba70ea686e1a365729835c62c26eb", "html_url": "https://github.com/rust-lang/rust/commit/0c04a26b3f8ba70ea686e1a365729835c62c26eb"}], "stats": {"total": 139, "additions": 99, "deletions": 40}, "files": [{"sha": "d75fa9341bf573844b80e704248ce724024dac63", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 46, "deletions": 20, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/720bcd81de9d5fbdb60761fc929d40e487005722/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720bcd81de9d5fbdb60761fc929d40e487005722/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=720bcd81de9d5fbdb60761fc929d40e487005722", "patch": "@@ -366,22 +366,41 @@ pub fn ty_of_inttype(ity: IntType) -> ty::t {\n \n \n /**\n- * Returns the fields of a struct for the given representation.\n- * All nominal types are LLVM structs, in order to be able to use\n- * forward-declared opaque types to prevent circularity in `type_of`.\n+ * LLVM-level types are a little complicated.\n+ *\n+ * C-like enums need to be actual ints, not wrapped in a struct,\n+ * because that changes the ABI on some platforms (see issue #10308).\n+ *\n+ * For nominal types, in some cases, we need to use LLVM named structs\n+ * and fill in the actual contents in a second pass to prevent\n+ * unbounded recursion; see also the comments in `trans::type_of`.\n  */\n-pub fn fields_of(cx: &mut CrateContext, r: &Repr) -> ~[Type] {\n-    generic_fields_of(cx, r, false)\n+pub fn type_of(cx: &mut CrateContext, r: &Repr) -> Type {\n+    generic_type_of(cx, r, None, false)\n+}\n+pub fn sizing_type_of(cx: &mut CrateContext, r: &Repr) -> Type {\n+    generic_type_of(cx, r, None, true)\n }\n-/// Like `fields_of`, but for `type_of::sizing_type_of` (q.v.).\n-pub fn sizing_fields_of(cx: &mut CrateContext, r: &Repr) -> ~[Type] {\n-    generic_fields_of(cx, r, true)\n+pub fn incomplete_type_of(cx: &mut CrateContext, r: &Repr, name: &str) -> Type {\n+    generic_type_of(cx, r, Some(name), false)\n+}\n+pub fn finish_type_of(cx: &mut CrateContext, r: &Repr, llty: &mut Type) {\n+    match *r {\n+        CEnum(*) | General(*) => { }\n+        Univariant(ref st, _) | NullablePointer{ nonnull: ref st, _ } =>\n+            llty.set_struct_body(struct_llfields(cx, st, false), st.packed)\n+    }\n }\n-fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n+\n+fn generic_type_of(cx: &mut CrateContext, r: &Repr, name: Option<&str>, sizing: bool) -> Type {\n     match *r {\n-        CEnum(ity, _, _) => ~[ll_inttype(cx, ity)],\n-        Univariant(ref st, _dtor) => struct_llfields(cx, st, sizing),\n-        NullablePointer{ nonnull: ref st, _ } => struct_llfields(cx, st, sizing),\n+        CEnum(ity, _, _) => ll_inttype(cx, ity),\n+        Univariant(ref st, _) | NullablePointer{ nonnull: ref st, _ } => {\n+            match name {\n+                None => Type::struct_(struct_llfields(cx, st, sizing), st.packed),\n+                Some(name) => { assert_eq!(sizing, false); Type::named_struct(name) }\n+            }\n+        }\n         General(ity, ref sts) => {\n             // We need a representation that has:\n             // * The alignment of the most-aligned field\n@@ -394,8 +413,7 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n             // more of its own type, then use alignment-sized ints to get the rest\n             // of the size.\n             //\n-            // Note: if/when we start exposing SIMD vector types (or f80, on some\n-            // platforms that have it), this will need some adjustment.\n+            // FIXME #10604: this breaks when vector types are present.\n             let size = sts.iter().map(|st| st.size).max().unwrap();\n             let most_aligned = sts.iter().max_by(|st| st.align).unwrap();\n             let align = most_aligned.align;\n@@ -411,9 +429,17 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n             assert_eq!(machine::llalign_of_min(cx, pad_ty) as u64, align);\n             let align_units = (size + align - 1) / align;\n             assert_eq!(align % discr_size, 0);\n-            ~[discr_ty,\n+            let fields = ~[discr_ty,\n               Type::array(&discr_ty, align / discr_size - 1),\n-              Type::array(&pad_ty, align_units - 1)]\n+              Type::array(&pad_ty, align_units - 1)];\n+            match name {\n+                None => Type::struct_(fields, false),\n+                Some(name) => {\n+                    let mut llty = Type::named_struct(name);\n+                    llty.set_struct_body(fields, false);\n+                    llty\n+                }\n+            }\n         }\n     }\n }\n@@ -460,7 +486,8 @@ pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef, cast_to:\n             signed = ity.is_signed();\n         }\n         General(ity, ref cases) => {\n-            val = load_discr(bcx, ity, scrutinee, 0, (cases.len() - 1) as Disr);\n+            let ptr = GEPi(bcx, scrutinee, [0, 0]);\n+            val = load_discr(bcx, ity, ptr, 0, (cases.len() - 1) as Disr);\n             signed = ity.is_signed();\n         }\n         Univariant(*) => {\n@@ -487,9 +514,8 @@ fn nullable_bitdiscr(bcx: @mut Block, nonnull: &Struct, nndiscr: Disr, ptrfield:\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: @mut Block, ity: IntType, scrutinee: ValueRef, min: Disr, max: Disr)\n+fn load_discr(bcx: @mut Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     -> ValueRef {\n-    let ptr = GEPi(bcx, scrutinee, [0, 0]);\n     let llty = ll_inttype(bcx.ccx(), ity);\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n     let bits = machine::llbitsize_of_real(bcx.ccx(), llty);\n@@ -546,7 +572,7 @@ pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr) {\n         CEnum(ity, min, max) => {\n             assert_discr_in_range(ity, min, max, discr);\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n-                  GEPi(bcx, val, [0, 0]))\n+                  val)\n         }\n         General(ity, _) => {\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),"}, {"sha": "0b51105cdde398d90aab3b7a651458729c6527e5", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/720bcd81de9d5fbdb60761fc929d40e487005722/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720bcd81de9d5fbdb60761fc929d40e487005722/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=720bcd81de9d5fbdb60761fc929d40e487005722", "patch": "@@ -147,18 +147,17 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n \n         ty::ty_tup(*) | ty::ty_enum(*) => {\n             let repr = adt::represent_type(cx, t);\n-            Type::struct_(adt::sizing_fields_of(cx, repr), false)\n+            adt::sizing_type_of(cx, repr)\n         }\n \n-        ty::ty_struct(did, _) => {\n+        ty::ty_struct(*) => {\n             if ty::type_is_simd(cx.tcx, t) {\n                 let et = ty::simd_type(cx.tcx, t);\n                 let n = ty::simd_size(cx.tcx, t);\n                 Type::vector(&type_of(cx, et), n as u64)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n-                let packed = ty::lookup_packed(cx.tcx, did);\n-                Type::struct_(adt::sizing_fields_of(cx, repr), packed)\n+                adt::sizing_type_of(cx, repr)\n             }\n         }\n \n@@ -217,8 +216,9 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n         // fill it in *after* placing it into the type cache. This\n         // avoids creating more than one copy of the enum when one\n         // of the enum's variants refers to the enum itself.\n-\n-        Type::named_struct(llvm_type_name(cx, an_enum, did, substs.tps))\n+        let repr = adt::represent_type(cx, t);\n+        let name = llvm_type_name(cx, an_enum, did, substs.tps);\n+        adt::incomplete_type_of(cx, repr, name)\n       }\n       ty::ty_estr(ty::vstore_box) => {\n         Type::box(cx, &Type::vec(cx.sess.targ_cfg.arch, &Type::i8())).ptr_to()\n@@ -287,7 +287,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n       ty::ty_type => cx.tydesc_type.ptr_to(),\n       ty::ty_tup(*) => {\n           let repr = adt::represent_type(cx, t);\n-          Type::struct_(adt::fields_of(cx, repr), false)\n+          adt::type_of(cx, repr)\n       }\n       ty::ty_opaque_closure_ptr(_) => Type::opaque_box(cx).ptr_to(),\n       ty::ty_struct(did, ref substs) => {\n@@ -299,7 +299,9 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n               // Only create the named struct, but don't fill it in. We fill it\n               // in *after* placing it into the type cache. This prevents\n               // infinite recursion with recursive struct types.\n-              Type::named_struct(llvm_type_name(cx, a_struct, did, substs.tps))\n+              let repr = adt::represent_type(cx, t);\n+              let name = llvm_type_name(cx, a_struct, did, substs.tps);\n+              adt::incomplete_type_of(cx, repr, name)\n           }\n       }\n       ty::ty_self(*) => cx.tcx.sess.unimpl(\"type_of: ty_self\"),\n@@ -316,19 +318,11 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n \n     // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {\n-      ty::ty_enum(*) => {\n-          let repr = adt::represent_type(cx, t);\n-          llty.set_struct_body(adt::fields_of(cx, repr), false);\n-      }\n-\n-      ty::ty_struct(did, _) => {\n-        if !ty::type_is_simd(cx.tcx, t) {\n-          let repr = adt::represent_type(cx, t);\n-          let packed = ty::lookup_packed(cx.tcx, did);\n-          llty.set_struct_body(adt::fields_of(cx, repr), packed);\n+        ty::ty_enum(*) | ty::ty_struct(*) if !ty::type_is_simd(cx.tcx, t) => {\n+            let repr = adt::represent_type(cx, t);\n+            adt::finish_type_of(cx, repr, &mut llty);\n         }\n-      }\n-      _ => ()\n+        _ => ()\n     }\n \n     return llty;"}, {"sha": "0c897b959a5a3412783e4a8105a137d3cfb80472", "filename": "src/test/run-pass/enum-clike-ffi-as-int.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/720bcd81de9d5fbdb60761fc929d40e487005722/src%2Ftest%2Frun-pass%2Fenum-clike-ffi-as-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/720bcd81de9d5fbdb60761fc929d40e487005722/src%2Ftest%2Frun-pass%2Fenum-clike-ffi-as-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-clike-ffi-as-int.rs?ref=720bcd81de9d5fbdb60761fc929d40e487005722", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * C-like enums have to be represented as LLVM ints, not wrapped in a\n+ * struct, because it's important for the FFI that they interoperate\n+ * with C integers/enums, and the ABI can treat structs differently.\n+ * For example, on i686-linux-gnu, a struct return value is passed by\n+ * storing to a hidden out parameter, whereas an integer would be\n+ * returned in a register.\n+ *\n+ * This test just checks that the ABIs for the enum and the plain\n+ * integer are compatible, rather than actually calling C code.\n+ * The unused parameter to `foo` is to increase the likelihood of\n+ * crashing if something goes wrong here.\n+ */\n+\n+#[repr(u32)]\n+enum Foo {\n+  A = 0,\n+  B = 23\n+}\n+\n+#[inline(never)]\n+extern \"C\" fn foo(_x: uint) -> Foo { B }\n+\n+pub fn main() {\n+  unsafe {\n+    let f: extern \"C\" fn(uint) -> u32 = ::std::cast::transmute(foo);\n+    assert_eq!(f(0xDEADBEEF), B as u32);\n+  }\n+}"}]}