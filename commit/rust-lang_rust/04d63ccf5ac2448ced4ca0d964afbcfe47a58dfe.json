{"sha": "04d63ccf5ac2448ced4ca0d964afbcfe47a58dfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ZDYzY2NmNWFjMjQ0OGNlZDRjYTBkOTY0YWZiY2ZlNDdhNThkZmU=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-06-16T15:28:30Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-06-16T21:00:44Z"}, "message": "Cache drops for early scope exits\n\nPreviously we would rebuild all drops on every early exit from a scope, which for code like:\n\n```rust\nmatch x {\n    a => return 1,\n    b => return 2,\n    ...\n    z => return 27\n}\n```\n\nwould produce 27 exactly same chains of drops for each return, a O(n*m) explosion in drops.", "tree": {"sha": "f5cf6d87236c1b21fc7aea45a231ca26221d0211", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5cf6d87236c1b21fc7aea45a231ca26221d0211"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04d63ccf5ac2448ced4ca0d964afbcfe47a58dfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04d63ccf5ac2448ced4ca0d964afbcfe47a58dfe", "html_url": "https://github.com/rust-lang/rust/commit/04d63ccf5ac2448ced4ca0d964afbcfe47a58dfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04d63ccf5ac2448ced4ca0d964afbcfe47a58dfe/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a479a6a7a6fa1bfe1f18d7d7411ad14e7b8ca17b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a479a6a7a6fa1bfe1f18d7d7411ad14e7b8ca17b", "html_url": "https://github.com/rust-lang/rust/commit/a479a6a7a6fa1bfe1f18d7d7411ad14e7b8ca17b"}], "stats": {"total": 57, "additions": 30, "deletions": 27}, "files": [{"sha": "65457a9cc80d6e8c57dc96e1fcffd9cb0bb4456b", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/04d63ccf5ac2448ced4ca0d964afbcfe47a58dfe/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04d63ccf5ac2448ced4ca0d964afbcfe47a58dfe/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=04d63ccf5ac2448ced4ca0d964afbcfe47a58dfe", "patch": "@@ -94,6 +94,7 @@ use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::repr::*;\n use syntax::codemap::Span;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::fnv::FnvHashMap;\n \n pub struct Scope<'tcx> {\n     /// the scope-id within the scope_auxiliary\n@@ -127,12 +128,8 @@ pub struct Scope<'tcx> {\n     /// stage.\n     free: Option<FreeData<'tcx>>,\n \n-    /// The cached block for the cleanups-on-diverge path. This block\n-    /// contains a block that will just do a RESUME to an appropriate\n-    /// place. This block does not execute any of the drops or free:\n-    /// each of those has their own cached-blocks, which will branch\n-    /// to this point.\n-    cached_block: Option<BasicBlock>\n+    /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n+    cached_exits: FnvHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n }\n \n struct DropData<'tcx> {\n@@ -172,7 +169,7 @@ pub struct LoopScope {\n     pub continue_block: BasicBlock,\n     /// Block to branch into when the loop terminates (either by being `break`-en out from, or by\n     /// having its condition to become false)\n-    pub break_block: BasicBlock, // where to go on a `break\n+    pub break_block: BasicBlock,\n     /// Indicates the reachability of the break_block for this loop\n     pub might_break: bool\n }\n@@ -183,7 +180,7 @@ impl<'tcx> Scope<'tcx> {\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n     fn invalidate_cache(&mut self) {\n-        self.cached_block = None;\n+        self.cached_exits = FnvHashMap();\n         for dropdata in &mut self.drops {\n             dropdata.cached_block = None;\n         }\n@@ -192,7 +189,7 @@ impl<'tcx> Scope<'tcx> {\n         }\n     }\n \n-    /// Returns the cached block for this scope.\n+    /// Returns the cached entrypoint for diverging exit from this scope.\n     ///\n     /// Precondition: the caches must be fully filled (i.e. diverge_cleanup is called) in order for\n     /// this method to work correctly.\n@@ -270,7 +267,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             extent: extent,\n             drops: vec![],\n             free: None,\n-            cached_block: None,\n+            cached_exits: FnvHashMap()\n         });\n         self.scope_auxiliary.push(ScopeAuxiliary {\n             extent: extent,\n@@ -314,13 +311,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                                       .unwrap_or_else(||{\n             span_bug!(span, \"extent {:?} does not enclose\", extent)\n         });\n-\n+        let len = self.scopes.len();\n+        assert!(scope_count < len, \"should not use `exit_scope` to pop ALL scopes\");\n         let tmp = self.get_unit_temp();\n-        for (idx, ref scope) in self.scopes.iter().enumerate().rev().take(scope_count) {\n-            unpack!(block = build_scope_drops(&mut self.cfg,\n-                                              scope,\n-                                              &self.scopes[..idx],\n-                                              block));\n+        {\n+        let mut rest = &mut self.scopes[(len - scope_count)..];\n+        while let Some((scope, rest_)) = {rest}.split_last_mut() {\n+            rest = rest_;\n+            block = if let Some(&e) = scope.cached_exits.get(&(target, extent)) {\n+                self.cfg.terminate(block, scope.source_info(span),\n+                                   TerminatorKind::Goto { target: e });\n+                return;\n+            } else {\n+                let b = self.cfg.start_new_block();\n+                self.cfg.terminate(block, scope.source_info(span),\n+                                   TerminatorKind::Goto { target: b });\n+                scope.cached_exits.insert((target, extent), b);\n+                b\n+            };\n+            unpack!(block = build_scope_drops(&mut self.cfg, scope, rest, block));\n             if let Some(ref free_data) = scope.free {\n                 let next = self.cfg.start_new_block();\n                 let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n@@ -331,14 +340,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 .postdoms\n                 .push(self.cfg.current_location(block));\n         }\n-\n-        assert!(scope_count < self.scopes.len(),\n-                \"should never use `exit_scope` to pop *ALL* scopes\");\n-        let scope = self.scopes.iter().rev().skip(scope_count)\n-                                            .next()\n-                                            .unwrap();\n-        self.cfg.terminate(block,\n-                           scope.source_info(span),\n+        }\n+        let scope = &self.scopes[len - scope_count];\n+        self.cfg.terminate(block, scope.source_info(span),\n                            TerminatorKind::Goto { target: target });\n     }\n \n@@ -506,10 +510,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             resumeblk\n         };\n \n-        for scope in scopes {\n+        for scope in scopes.iter_mut().filter(|s| !s.drops.is_empty() || s.free.is_some()) {\n             target = build_diverge_scope(hir.tcx(), cfg, &unit_temp, scope, target);\n         }\n-\n         Some(target)\n     }\n \n@@ -534,7 +537,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         next_target.unit()\n     }\n \n-\n+    /// Utility function for *non*-scope code to build their own drops\n     pub fn build_drop_and_replace(&mut self,\n                                   block: BasicBlock,\n                                   span: Span,"}]}