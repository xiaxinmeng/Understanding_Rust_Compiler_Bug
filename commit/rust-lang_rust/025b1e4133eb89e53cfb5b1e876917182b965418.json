{"sha": "025b1e4133eb89e53cfb5b1e876917182b965418", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNWIxZTQxMzNlYjg5ZTUzY2ZiNWIxZTg3NjkxNzE4MmI5NjU0MTg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-26T19:30:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-26T19:30:02Z"}, "message": "Do some more iflog-guarding.", "tree": {"sha": "85a974bbc8893f65f4e396093c43406f708d3ea8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85a974bbc8893f65f4e396093c43406f708d3ea8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/025b1e4133eb89e53cfb5b1e876917182b965418", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/025b1e4133eb89e53cfb5b1e876917182b965418", "html_url": "https://github.com/rust-lang/rust/commit/025b1e4133eb89e53cfb5b1e876917182b965418", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/025b1e4133eb89e53cfb5b1e876917182b965418/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "085cd2ee7dbe35a0c854d78f0e85218c6053a357", "url": "https://api.github.com/repos/rust-lang/rust/commits/085cd2ee7dbe35a0c854d78f0e85218c6053a357", "html_url": "https://github.com/rust-lang/rust/commit/085cd2ee7dbe35a0c854d78f0e85218c6053a357"}], "stats": {"total": 178, "additions": 94, "deletions": 84}, "files": [{"sha": "64836e6681443067fb166ae7b8a1deefdf4b6445", "filename": "src/boot/be/ra.ml", "status": "modified", "additions": 43, "deletions": 61, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/025b1e4133eb89e53cfb5b1e876917182b965418/src%2Fboot%2Fbe%2Fra.ml", "raw_url": "https://github.com/rust-lang/rust/raw/025b1e4133eb89e53cfb5b1e876917182b965418/src%2Fboot%2Fbe%2Fra.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fra.ml?ref=025b1e4133eb89e53cfb5b1e876917182b965418", "patch": "@@ -184,7 +184,7 @@ let calculate_live_bitvectors\n     (cx:ctxt)\n     : ((Bits.t array) * (Bits.t array)) =\n \n-  log cx \"calculating live bitvectors\";\n+  iflog cx (fun _ -> log cx \"calculating live bitvectors\");\n \n   let quads = cx.ctxt_quads in\n   let n_quads = Array.length quads in\n@@ -198,10 +198,9 @@ let calculate_live_bitvectors\n   let (quad_uncond_jmp:bool array) = Array.make n_quads false in\n   let (quad_jmp_targs:(Il.label list) array) = Array.make n_quads [] in\n \n-  let outer_changed = ref true in\n-\n   (* Working bit-vector. *)\n   let scratch = new_bitv() in\n+  let changed = ref true in\n \n   (* bit-vector helpers. *)\n     (* Setup pass. *)\n@@ -217,62 +216,39 @@ let calculate_live_bitvectors\n           (quad_defined_vregs q)\n     done;\n \n-    while !outer_changed do\n-      iflog cx (fun _ -> log cx \"iterating outer bitvector calculation\");\n-      outer_changed := false;\n-      for i = 0 to n_quads - 1 do\n-        Bits.clear live_in_vregs.(i);\n-        Bits.clear live_out_vregs.(i)\n+    while !changed do\n+      changed := false;\n+      iflog cx\n+        (fun _ ->\n+           log cx \"iterating inner bitvector calculation over %d quads\"\n+             n_quads);\n+      for i = n_quads - 1 downto 0 do\n+\n+        let note_change b = if b then changed := true in\n+        let live_in = live_in_vregs.(i) in\n+        let live_out = live_out_vregs.(i) in\n+        let used = quad_used_vrs.(i) in\n+        let defined = quad_defined_vrs.(i) in\n+\n+          (* Union in the vregs we use. *)\n+          note_change (Bits.union live_in used);\n+\n+          (* Union in all our jump targets. *)\n+          List.iter\n+            (fun i -> note_change (Bits.union live_out live_in_vregs.(i)))\n+            (quad_jmp_targs.(i));\n+\n+          (* Union in our block successor if we have one *)\n+          if i < (n_quads - 1) && (not (quad_uncond_jmp.(i)))\n+          then note_change (Bits.union live_out live_in_vregs.(i+1));\n+\n+          (* Propagate live-out to live-in on anything we don't define. *)\n+          ignore (Bits.copy scratch defined);\n+          Bits.invert scratch;\n+          ignore (Bits.intersect scratch live_out);\n+          note_change (Bits.union live_in scratch);\n+\n       done;\n-      let inner_changed = ref true in\n-        while !inner_changed do\n-          inner_changed := false;\n-          iflog cx\n-            (fun _ ->\n-               log cx \"iterating inner bitvector calculation over %d quads\"\n-                 n_quads);\n-          for i = n_quads - 1 downto 0 do\n-\n-            let note_change b = if b then inner_changed := true in\n-            let live_in = live_in_vregs.(i) in\n-            let live_out = live_out_vregs.(i) in\n-            let used = quad_used_vrs.(i) in\n-            let defined = quad_defined_vrs.(i) in\n-\n-              (* Union in the vregs we use. *)\n-              note_change (Bits.union live_in used);\n-\n-              (* Union in all our jump targets. *)\n-              List.iter\n-                (fun i -> note_change (Bits.union live_out live_in_vregs.(i)))\n-                (quad_jmp_targs.(i));\n-\n-              (* Union in our block successor if we have one *)\n-              if i < (n_quads - 1) && (not (quad_uncond_jmp.(i)))\n-              then note_change (Bits.union live_out live_in_vregs.(i+1));\n-\n-              (* Propagate live-out to live-in on anything we don't define. *)\n-              ignore (Bits.copy scratch defined);\n-              Bits.invert scratch;\n-              ignore (Bits.intersect scratch live_out);\n-              note_change (Bits.union live_in scratch);\n-\n-          done\n-        done;\n-        let kill_mov_to_dead_target i q =\n-          match q.Il.quad_body with\n-              Il.Unary { Il.unary_op=uop;\n-                         Il.unary_dst=Il.Reg (Il.Vreg v, _) }\n-                when\n-                  ((Il.is_mov uop) &&\n-                     not (Bits.get live_out_vregs.(i) v)) ->\n-                  begin\n-                    kill_quad i cx;\n-                    outer_changed := true;\n-                  end\n-            | _ -> ()\n-        in\n-          Array.iteri kill_mov_to_dead_target quads\n     done;\n     iflog cx\n       begin\n@@ -340,7 +316,10 @@ let dump_quads cx =\n         None -> \"\"\n       | Some f -> f.fixup_name ^ \":\"\n     in\n-      log cx \"[%s] %s %s\" (padded_num i len) (padded_str lab (!maxlablen)) qs\n+      iflog cx\n+        (fun _ ->\n+           log cx \"[%s] %s %s\"\n+             (padded_num i len) (padded_str lab (!maxlablen)) qs)\n   done\n ;;\n \n@@ -449,8 +428,11 @@ let reg_alloc\n                 in\n                 let spill_mem = spill_slot spill_idx in\n                 let spill_cell = Il.Mem (spill_mem, Il.ScalarTy word_ty) in\n-                  log cx \"spilling <%d> from %s to %s\"\n-                    vreg (hr_str hreg) (string_of_mem hr_str spill_mem);\n+                  iflog cx\n+                    (fun _ ->\n+                       log cx \"spilling <%d> from %s to %s\"\n+                         vreg (hr_str hreg) (string_of_mem\n+                                               hr_str spill_mem));\n                   prepend (Il.mk_quad\n                              (Il.umov spill_cell (Il.Cell (hr hreg))));\n               else ()"}, {"sha": "d7d3bd63fe6948c3499556b7bb7dcb8dd26d191c", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/025b1e4133eb89e53cfb5b1e876917182b965418/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/025b1e4133eb89e53cfb5b1e876917182b965418/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=025b1e4133eb89e53cfb5b1e876917182b965418", "patch": "@@ -25,6 +25,12 @@ let log cx =\n     cx.Semant.ctxt_sess.Session.sess_log_type\n     cx.Semant.ctxt_sess.Session.sess_log_out\n \n+let iflog cx thunk =\n+  if cx.Semant.ctxt_sess.Session.sess_log_type\n+  then thunk ()\n+  else ()\n+;;\n+\n let type_error expected actual = raise (Type_error (expected, actual))\n \n (* We explicitly curry [cx] like this to avoid threading it through all the\n@@ -65,7 +71,10 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n     let res =\n       if mutability = Ast.MUT_mutable then Ast.TY_mutable ty else ty\n     in\n-      log cx \"maybe_mutable: %a -> %a\" Ast.sprintf_ty ty Ast.sprintf_ty res;\n+      iflog cx\n+        (fun _ ->\n+           log cx \"maybe_mutable: %a -> %a\"\n+             Ast.sprintf_ty ty Ast.sprintf_ty res);\n       res\n   in\n \n@@ -238,11 +247,13 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n           demand expected actual;\n           actual\n       | Some inferred, None ->\n-          log cx \"setting auto slot #%d = %a to type %a\"\n-            (Common.int_of_node defn_id)\n-            Ast.sprintf_slot_key\n-              (Hashtbl.find cx.Semant.ctxt_slot_keys defn_id)\n-            Ast.sprintf_ty inferred;\n+          iflog cx\n+            (fun _ ->\n+               log cx \"setting auto slot #%d = %a to type %a\"\n+                 (Common.int_of_node defn_id)\n+                 Ast.sprintf_slot_key\n+                 (Hashtbl.find cx.Semant.ctxt_slot_keys defn_id)\n+                 Ast.sprintf_ty inferred);\n           let new_slot = { slot with Ast.slot_ty = Some inferred } in\n           Hashtbl.replace cx.Semant.ctxt_all_defns defn_id\n             (Semant.DEFN_slot new_slot);\n@@ -305,8 +316,11 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n         | `Module items -> Ast.sprintf_mod_items chan items\n     in\n \n-    let _ = log cx \"base lval %a, base type %a\"\n-      Ast.sprintf_lval base sprintf_itype ()\n+    let _ =\n+      iflog cx\n+        (fun _ ->\n+           log cx \"base lval %a, base type %a\"\n+             Ast.sprintf_lval base sprintf_itype ())\n     in\n \n     let rec typecheck base_ity =\n@@ -495,20 +509,26 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n      * Get the real one. *)\n     let lval_id = Semant.lval_base_id lval in\n     let lval = Hashtbl.find cx.Semant.ctxt_all_lvals lval_id in\n-    let _ = log cx \"generic_check_lval %a mut=%s deref=%s infer=%s\"\n-      Ast.sprintf_lval lval\n-      (if mut = Ast.MUT_mutable then \"mutable\" else \"immutable\")\n-      (if deref then \"true\" else \"false\")\n-      (match infer with\n-           None -> \"<none>\"\n-         | Some t -> Fmt.fmt_to_str Ast.fmt_ty t)\n+    let _ =\n+      iflog cx\n+        (fun _ ->\n+           log cx \"generic_check_lval %a mut=%s deref=%s infer=%s\"\n+             Ast.sprintf_lval lval\n+             (if mut = Ast.MUT_mutable then \"mutable\" else \"immutable\")\n+             (if deref then \"true\" else \"false\")\n+             (match infer with\n+                  None -> \"<none>\"\n+                | Some t -> Fmt.fmt_to_str Ast.fmt_ty t))\n     in\n     let (lval_ty, n_boxes) =\n       internal_check_outer_lval ~mut:mut ~deref:deref infer lval\n     in\n-    let _ = log cx \"checked lval %a with type %a\"\n-      Ast.sprintf_lval lval\n-      Ast.sprintf_ty lval_ty\n+    let _ =\n+      iflog cx\n+        (fun _ ->\n+           log cx \"checked lval %a with type %a\"\n+             Ast.sprintf_lval lval\n+             Ast.sprintf_ty lval_ty)\n     in\n \n     if Hashtbl.mem cx.Semant.ctxt_all_lval_types lval_id then\n@@ -887,7 +907,7 @@ let process_crate (cx:Semant.ctxt) (crate:Ast.crate) : unit =\n \n   (* Verify that, if main is present, it has the right form. *)\n   let verify_main (item_id:Common.node_id) : unit =\n-    let path_name = Semant.string_of_name (Semant.path_to_name path) in\n+    let path_name = Hashtbl.find cx.Semant.ctxt_all_item_names item_id in\n     if cx.Semant.ctxt_main_name = Some path_name then\n       try\n         match Hashtbl.find cx.Semant.ctxt_all_item_types item_id with\n@@ -972,11 +992,19 @@ let process_crate (cx:Semant.ctxt) (crate:Ast.crate) : unit =\n      * return void *)\n     let visit_stmt_pre (stmt:Ast.stmt) : unit =\n       try\n-        log cx \"\";\n-        log cx \"typechecking stmt: %a\" Ast.sprintf_stmt stmt;\n-        log cx \"\";\n+        iflog cx\n+          begin\n+            fun _ ->\n+              log cx \"\";\n+              log cx \"typechecking stmt: %a\" Ast.sprintf_stmt stmt;\n+              log cx \"\";\n+          end;\n         check_stmt cx (Stack.top fn_ctx_stack) stmt;\n-        log cx \"finished typechecking stmt: %a\" Ast.sprintf_stmt stmt;\n+        iflog cx\n+          begin\n+            fun _ -> \n+              log cx \"finished typechecking stmt: %a\" Ast.sprintf_stmt stmt;\n+          end;\n       with Common.Semant_err (None, msg) ->\n         raise (Common.Semant_err ((Some stmt.Common.id), msg))\n     in"}]}