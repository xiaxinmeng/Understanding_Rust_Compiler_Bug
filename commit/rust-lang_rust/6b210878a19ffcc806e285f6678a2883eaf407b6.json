{"sha": "6b210878a19ffcc806e285f6678a2883eaf407b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMjEwODc4YTE5ZmZjYzgwNmUyODVmNjY3OGEyODgzZWFmNDA3YjY=", "commit": {"author": {"name": "James Rowe", "email": "jroweboy@gmail.com", "date": "2014-07-03T21:07:16Z"}, "committer": {"name": "James Rowe", "email": "jroweboy@gmail.com", "date": "2014-07-03T21:07:16Z"}, "message": "Improved the search by including a levenshtein distance calculation which enables the docs search function to be more forgiving for spelling mistakes", "tree": {"sha": "9c6089674cf8d5f1c6f895cbcbab81ee4b2feaca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c6089674cf8d5f1c6f895cbcbab81ee4b2feaca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b210878a19ffcc806e285f6678a2883eaf407b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b210878a19ffcc806e285f6678a2883eaf407b6", "html_url": "https://github.com/rust-lang/rust/commit/6b210878a19ffcc806e285f6678a2883eaf407b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b210878a19ffcc806e285f6678a2883eaf407b6/comments", "author": {"login": "jroweboy", "id": 952515, "node_id": "MDQ6VXNlcjk1MjUxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/952515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroweboy", "html_url": "https://github.com/jroweboy", "followers_url": "https://api.github.com/users/jroweboy/followers", "following_url": "https://api.github.com/users/jroweboy/following{/other_user}", "gists_url": "https://api.github.com/users/jroweboy/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroweboy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroweboy/subscriptions", "organizations_url": "https://api.github.com/users/jroweboy/orgs", "repos_url": "https://api.github.com/users/jroweboy/repos", "events_url": "https://api.github.com/users/jroweboy/events{/privacy}", "received_events_url": "https://api.github.com/users/jroweboy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jroweboy", "id": 952515, "node_id": "MDQ6VXNlcjk1MjUxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/952515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroweboy", "html_url": "https://github.com/jroweboy", "followers_url": "https://api.github.com/users/jroweboy/followers", "following_url": "https://api.github.com/users/jroweboy/following{/other_user}", "gists_url": "https://api.github.com/users/jroweboy/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroweboy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroweboy/subscriptions", "organizations_url": "https://api.github.com/users/jroweboy/orgs", "repos_url": "https://api.github.com/users/jroweboy/repos", "events_url": "https://api.github.com/users/jroweboy/events{/privacy}", "received_events_url": "https://api.github.com/users/jroweboy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eda75bcf42ad99e3e4c99585d39705fccac606ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/eda75bcf42ad99e3e4c99585d39705fccac606ee", "html_url": "https://github.com/rust-lang/rust/commit/eda75bcf42ad99e3e4c99585d39705fccac606ee"}], "stats": {"total": 130, "additions": 86, "deletions": 44}, "files": [{"sha": "3df2bf3c33999fce16be4c2f6192b866c06b48fb", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 86, "deletions": 44, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6b210878a19ffcc806e285f6678a2883eaf407b6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/6b210878a19ffcc806e285f6678a2883eaf407b6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=6b210878a19ffcc806e285f6678a2883eaf407b6", "patch": "@@ -58,7 +58,7 @@\n             }\n             $('#' + from)[0].scrollIntoView();\n             $('.line-numbers span').removeClass('line-highlighted');\n-            for (i = from; i <= to; i += 1) {\n+            for (i = from; i <= to; ++i) {\n                 $('#' + i).addClass('line-highlighted');\n             }\n         }\n@@ -99,7 +99,7 @@\n             stripped = '',\n             len = rootPath.match(/\\.\\.\\//g).length + 1;\n \n-        for (i = 0; i < len; i += 1) {\n+        for (i = 0; i < len; ++i) {\n             match = url.match(/\\/[^\\/]*$/);\n             if (i < len - 1) {\n                 stripped = match[0] + stripped;\n@@ -111,9 +111,44 @@\n \n         document.location.href = url;\n     });\n+    /**\n+     * Code from Stackoverflow to compute the Levenshtein distance between two strings\n+     * Written by Marco de Wit at http://stackoverflow.com/a/18514751/745719\n+     */\n+    var levenshtein = (function() {\n+        var row2 = [];\n+        return function(s1, s2) {\n+            if (s1 === s2) {\n+                return 0;\n+            } else {\n+                var s1_len = s1.length, s2_len = s2.length;\n+                if (s1_len && s2_len) {\n+                    var i1 = 0, i2 = 0, a, b, c, c2, row = row2;\n+                    while (i1 < s1_len)\n+                        row[i1] = ++i1;\n+                    while (i2 < s2_len) {\n+                        c2 = s2.charCodeAt(i2);\n+                        a = i2;\n+                        ++i2;\n+                        b = i2;\n+                        for (i1 = 0; i1 < s1_len; ++i1) {\n+                            c = a + (s1.charCodeAt(i1) !== c2 ? 1 : 0);\n+                            a = row[i1];\n+                            b = b < a ? (b < c ? b + 1 : c) : (a < c ? a + 1 : c);\n+                            row[i1] = b;\n+                        }\n+                    }\n+                    return b;\n+                } else {\n+                    return s1_len + s2_len;\n+                }\n+            }\n+        };\n+    })();\n \n     function initSearch(rawSearchIndex) {\n         var currentResults, index, searchIndex;\n+        var MAX_LEV_DISTANCE = 3;\n         var params = getQueryStringParams();\n \n         // Populate search bar with query string search term when provided,\n@@ -140,7 +175,7 @@\n                 split = valLower.split(\"::\");\n \n             //remove empty keywords\n-            for (var j = 0; j < split.length; j++) {\n+            for (var j = 0; j < split.length; ++j) {\n                 split[j].toLowerCase();\n                 if (split[j] === \"\") {\n                     split.splice(j, 1);\n@@ -153,7 +188,7 @@\n                 val.charAt(val.length - 1) === val.charAt(0))\n             {\n                 val = val.substr(1, val.length - 2);\n-                for (var i = 0; i < nSearchWords; i += 1) {\n+                for (var i = 0; i < nSearchWords; ++i) {\n                     if (searchWords[i] === val) {\n                         // filter type: ... queries\n                         if (typeFilter < 0 || typeFilter === searchIndex[i].ty) {\n@@ -167,15 +202,31 @@\n             } else {\n                 // gather matching search results up to a certain maximum\n                 val = val.replace(/\\_/g, \"\");\n-                for (var i = 0; i < split.length; i++) {\n-                    for (var j = 0; j < nSearchWords; j += 1) {\n+                for (var i = 0; i < split.length; ++i) {\n+                    for (var j = 0; j < nSearchWords; ++j) {\n+                        var lev_distance;\n                         if (searchWords[j].indexOf(split[i]) > -1 ||\n                             searchWords[j].indexOf(val) > -1 ||\n                             searchWords[j].replace(/_/g, \"\").indexOf(val) > -1)\n                         {\n                             // filter type: ... queries\n                             if (typeFilter < 0 || typeFilter === searchIndex[j].ty) {\n-                                results.push({id: j, index: searchWords[j].replace(/_/g, \"\").indexOf(val)});\n+                                results.push({\n+                                    id: j,\n+                                    index: searchWords[j].replace(/_/g, \"\").indexOf(val),\n+                                    lev: 0,\n+                                });\n+                            }\n+                        } else if (\n+                            (lev_distance = levenshtein(searchWords[j], val)) <= \n+                                MAX_LEV_DISTANCE) {\n+                            if (typeFilter < 0 || typeFilter === searchIndex[j].ty) {\n+                                results.push({\n+                                    id: j,\n+                                    index: 0,\n+                                    // we want lev results to go lower than others\n+                                    lev: lev_distance,\n+                                });\n                             }\n                         }\n                         if (results.length === max) {\n@@ -186,7 +237,7 @@\n             }\n \n             var nresults = results.length;\n-            for (var i = 0; i < nresults; i += 1) {\n+            for (var i = 0; i < nresults; ++i) {\n                 results[i].word = searchWords[results[i].id];\n                 results[i].item = searchIndex[results[i].id] || {};\n             }\n@@ -198,6 +249,12 @@\n             results.sort(function(aaa, bbb) {\n                 var a, b;\n \n+                // Sort by non levenshtein results and then levenshtein results by the distance\n+                // (less changes required to match means higher rankings)\n+                a = (aaa.lev);\n+                b = (bbb.lev);\n+                if (a !== b) return a - b;\n+\n                 // sort by crate (non-current crate goes later)\n                 a = (aaa.item.crate !== window.currentCrate);\n                 b = (bbb.item.crate !== window.currentCrate);\n@@ -255,7 +312,7 @@\n                     results[i].id = -1;\n                 }\n             }\n-            for (var i = 0; i < results.length; i++) {\n+            for (var i = 0; i < results.length; ++i) {\n                 var result = results[i],\n                     name = result.item.name.toLowerCase(),\n                     path = result.item.path.toLowerCase(),\n@@ -285,38 +342,23 @@\n          * @return {[boolean]}       [Whether the result is valid or not]\n          */\n         function validateResult(name, path, keys, parent) {\n-            //initially valid\n-            var validate = true;\n-            //if there is a parent, then validate against parent\n-            if (parent !== undefined) {\n-                for (var i = 0; i < keys.length; i++) {\n-                    // if previous keys are valid and current key is in the\n-                    // path, name or parent\n-                    if ((validate) &&\n-                        (name.toLowerCase().indexOf(keys[i]) > -1 ||\n-                         path.toLowerCase().indexOf(keys[i]) > -1 ||\n-                         parent.name.toLowerCase().indexOf(keys[i]) > -1))\n-                    {\n-                        validate = true;\n-                    } else {\n-                        validate = false;\n-                    }\n-                }\n-            } else {\n-                for (var i = 0; i < keys.length; i++) {\n-                    // if previous keys are valid and current key is in the\n-                    // path, name\n-                    if ((validate) &&\n-                        (name.toLowerCase().indexOf(keys[i]) > -1 ||\n-                         path.toLowerCase().indexOf(keys[i]) > -1))\n-                    {\n-                        validate = true;\n-                    } else {\n-                        validate = false;\n-                    }\n+            for (var i=0; i < keys.length; ++i) {\n+                // each check is for validation so we negate the conditions and invalidate\n+                if (!( \n+                    // check for an exact name match\n+                    name.toLowerCase().indexOf(keys[i]) > -1 ||\n+                    // then an exact path match\n+                    path.toLowerCase().indexOf(keys[i]) > -1 ||\n+                    // next if there is a parent, check for exact parent match\n+                    (parent !== undefined && \n+                        parent.name.toLowerCase().indexOf(keys[i]) > -1) ||\n+                    // lastly check to see if the name was a levenshtein match\n+                    levenshtein(name.toLowerCase(), keys[i]) <= \n+                        MAX_LEV_DISTANCE)) {\n+                    return false;\n                 }\n             }\n-            return validate;\n+            return true;\n         }\n \n         function getQuery() {\n@@ -496,7 +538,7 @@\n \n             resultIndex = execQuery(query, 20000, index);\n             len = resultIndex.length;\n-            for (i = 0; i < len; i += 1) {\n+            for (i = 0; i < len; ++i) {\n                 if (resultIndex[i].id > -1) {\n                     obj = searchIndex[resultIndex[i].id];\n                     filterdata.push([obj.name, obj.ty, obj.path, obj.desc]);\n@@ -568,7 +610,7 @@\n                 // faster analysis operations\n                 var len = items.length;\n                 var lastPath = \"\";\n-                for (var i = 0; i < len; i += 1) {\n+                for (var i = 0; i < len; ++i) {\n                     var rawRow = items[i];\n                     var row = {crate: crate, ty: rawRow[0], name: rawRow[1],\n                                path: rawRow[2] || lastPath, desc: rawRow[3],\n@@ -640,7 +682,7 @@\n                 crates.push(crate);\n             }\n             crates.sort();\n-            for (var i = 0; i < crates.length; i++) {\n+            for (var i = 0; i < crates.length; ++i) {\n                 var klass = 'crate';\n                 if (crates[i] == window.currentCrate) {\n                     klass += ' current';\n@@ -657,10 +699,10 @@\n     window.register_implementors = function(imp) {\n         var list = $('#implementors-list');\n         var libs = Object.getOwnPropertyNames(imp);\n-        for (var i = 0; i < libs.length; i++) {\n+        for (var i = 0; i < libs.length; ++i) {\n             if (libs[i] == currentCrate) continue;\n             var structs = imp[libs[i]];\n-            for (var j = 0; j < structs.length; j++) {\n+            for (var j = 0; j < structs.length; ++j) {\n                 var code = $('<code>').append(structs[j]);\n                 $.each(code.find('a'), function(idx, a) {\n                     var href = $(a).attr('href');"}]}