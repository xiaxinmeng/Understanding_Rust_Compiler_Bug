{"sha": "346ae2ad4b389d69b4e00ebc92a3c0242541651a", "node_id": "C_kwDOAAsO6NoAKDM0NmFlMmFkNGIzODlkNjliNGUwMGViYzkyYTNjMDI0MjU0MTY1MWE", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2022-08-27T18:02:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-27T18:02:24Z"}, "message": "Merge pull request #183 from sadlerap/simd-reduction-intrinsics\n\nsimd: Implement missing reduction intrinsics", "tree": {"sha": "df7e83c92b3cb089aa9c93bfb998ecb3f73ec845", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df7e83c92b3cb089aa9c93bfb998ecb3f73ec845"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/346ae2ad4b389d69b4e00ebc92a3c0242541651a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjClwwCRBK7hj4Ov3rIwAAw78IAFbJjxRqL2/6l1mRkugtmPWG\ncJk1M3tbcwf824NOResP6YfiNa3bO1RR3r+sJ/8u+6EJeqtE8Q/R20mRHn8RKPtR\n0SgA8KsrO1/Buf27W2JGGnPPyvYbo2zxEaS9gttyVKByBCUC4ysgCivBDumAv03J\nEMQQtfDCNXue2AEd94/3S0J1i/c8UN78HW5+cAZHIggOU6HD8Q4+vXQTyVvARrPL\ngsvzhgCUiDXkO4sr8zkGOPQiof4Vwhd0Tl80/R7EHzt+jGpYve3KvckMM7zfBKaX\nU296pPoAcHSUvzxAUMycPtHtQzBii/LpBwxFcDUhA5HraUiSSgR1VOydFJ0KX3U=\n=cYyf\n-----END PGP SIGNATURE-----\n", "payload": "tree df7e83c92b3cb089aa9c93bfb998ecb3f73ec845\nparent b4626b3ca07c4fcdce1d96840567005e294e5ecc\nparent 4df874f73d329e2aa3ffa7800f26476499302ec6\nauthor antoyo <antoyo@users.noreply.github.com> 1661623344 -0400\ncommitter GitHub <noreply@github.com> 1661623344 -0400\n\nMerge pull request #183 from sadlerap/simd-reduction-intrinsics\n\nsimd: Implement missing reduction intrinsics"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/346ae2ad4b389d69b4e00ebc92a3c0242541651a", "html_url": "https://github.com/rust-lang/rust/commit/346ae2ad4b389d69b4e00ebc92a3c0242541651a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/346ae2ad4b389d69b4e00ebc92a3c0242541651a/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4626b3ca07c4fcdce1d96840567005e294e5ecc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4626b3ca07c4fcdce1d96840567005e294e5ecc", "html_url": "https://github.com/rust-lang/rust/commit/b4626b3ca07c4fcdce1d96840567005e294e5ecc"}, {"sha": "4df874f73d329e2aa3ffa7800f26476499302ec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4df874f73d329e2aa3ffa7800f26476499302ec6", "html_url": "https://github.com/rust-lang/rust/commit/4df874f73d329e2aa3ffa7800f26476499302ec6"}], "stats": {"total": 122, "additions": 105, "deletions": 17}, "files": [{"sha": "6d36c963013436422a1e94bc58d2eedd5df00335", "filename": "failing-ui-tests.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/346ae2ad4b389d69b4e00ebc92a3c0242541651a/failing-ui-tests.txt", "raw_url": "https://github.com/rust-lang/rust/raw/346ae2ad4b389d69b4e00ebc92a3c0242541651a/failing-ui-tests.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/failing-ui-tests.txt?ref=346ae2ad4b389d69b4e00ebc92a3c0242541651a", "patch": "@@ -40,7 +40,6 @@ src/test/ui/simd/intrinsic/generic-as.rs\n src/test/ui/simd/intrinsic/generic-bitmask-pass.rs\n src/test/ui/simd/intrinsic/generic-comparison-pass.rs\n src/test/ui/simd/intrinsic/generic-gather-pass.rs\n-src/test/ui/simd/intrinsic/generic-reduction-pass.rs\n src/test/ui/simd/intrinsic/generic-select-pass.rs\n src/test/ui/simd/issue-17170.rs\n src/test/ui/simd/issue-39720.rs"}, {"sha": "d0d8a08421ac95339358e944db4188b2779b94ed", "filename": "failing-ui-tests12.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/346ae2ad4b389d69b4e00ebc92a3c0242541651a/failing-ui-tests12.txt", "raw_url": "https://github.com/rust-lang/rust/raw/346ae2ad4b389d69b4e00ebc92a3c0242541651a/failing-ui-tests12.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/failing-ui-tests12.txt?ref=346ae2ad4b389d69b4e00ebc92a3c0242541651a", "patch": "@@ -11,6 +11,7 @@ src/test/ui/simd/intrinsic/generic-arithmetic-saturating-pass.rs\n src/test/ui/simd/intrinsic/generic-cast-pass.rs\n src/test/ui/simd/intrinsic/generic-cast-pointer-width.rs\n src/test/ui/simd/intrinsic/generic-elements-pass.rs\n+src/test/ui/simd/intrinsic/generic-reduction-pass.rs\n src/test/ui/simd/intrinsic/inlining-issue67557-ice.rs\n src/test/ui/simd/intrinsic/inlining-issue67557.rs\n src/test/ui/simd/monomorphize-shuffle-index.rs"}, {"sha": "899eff064120bba766d9cba73386387dffbec9ad", "filename": "src/builder.rs", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/346ae2ad4b389d69b4e00ebc92a3c0242541651a/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/346ae2ad4b389d69b4e00ebc92a3c0242541651a/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=346ae2ad4b389d69b4e00ebc92a3c0242541651a", "patch": "@@ -1460,26 +1460,99 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         unimplemented!();\n     }\n \n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fadd(&mut self, acc: RValue<'gcc>, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        (0..element_count).into_iter()\n+            .map(|i| self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue())\n+            .fold(acc, |x, i| x + i)\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fadd(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n     pub fn vector_reduce_fmul_fast(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n         unimplemented!();\n     }\n \n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fmul(&mut self, acc: RValue<'gcc>, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        (0..element_count).into_iter()\n+            .map(|i| self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue())\n+            .fold(acc, |x, i| x * i)\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fmul(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!()\n+    }\n+\n     // Inspired by Hacker's Delight min implementation.\n     pub fn vector_reduce_min(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n         self.vector_reduce(src, |a, b, context| {\n             let differences_or_zeros = difference_or_zero(a, b, context);\n-            context.new_binary_op(None, BinaryOp::Minus, a.get_type(), a, differences_or_zeros)\n+            context.new_binary_op(None, BinaryOp::Plus, b.get_type(), b, differences_or_zeros)\n         })\n     }\n \n     // Inspired by Hacker's Delight max implementation.\n     pub fn vector_reduce_max(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n         self.vector_reduce(src, |a, b, context| {\n             let differences_or_zeros = difference_or_zero(a, b, context);\n-            context.new_binary_op(None, BinaryOp::Plus, b.get_type(), b, differences_or_zeros)\n+            context.new_binary_op(None, BinaryOp::Minus, a.get_type(), a, differences_or_zeros)\n         })\n     }\n \n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fmin(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        let mut acc = self.context.new_vector_access(None, src, self.context.new_rvalue_zero(self.int_type)).to_rvalue();\n+        for i in 1..element_count {\n+            let elem = self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue();\n+            let cmp = self.context.new_comparison(None, ComparisonOp::LessThan, acc, elem);\n+            acc = self.select(cmp, acc, elem);\n+        }\n+        acc\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fmin(&mut self, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fmax(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        let mut acc = self.context.new_vector_access(None, src, self.context.new_rvalue_zero(self.int_type)).to_rvalue();\n+        for i in 1..element_count {\n+            let elem = self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue();\n+            let cmp = self.context.new_comparison(None, ComparisonOp::GreaterThan, acc, elem);\n+            acc = self.select(cmp, acc, elem);\n+        }\n+        acc\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fmax(&mut self, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+\n     pub fn vector_select(&mut self, cond: RValue<'gcc>, then_val: RValue<'gcc>, else_val: RValue<'gcc>) -> RValue<'gcc> {\n         // cond is a vector of integers, not of bools.\n         let cond_type = cond.get_type();"}, {"sha": "8aed06869a90fbc291eb4ed3fae6c93d65e3ffec", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/346ae2ad4b389d69b4e00ebc92a3c0242541651a/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/346ae2ad4b389d69b4e00ebc92a3c0242541651a/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=346ae2ad4b389d69b4e00ebc92a3c0242541651a", "patch": "@@ -2,7 +2,7 @@\n use gccjit::{ToRValue, ComparisonOp, UnaryOp};\n use gccjit::{BinaryOp, RValue, Type};\n use rustc_codegen_ssa::base::compare_simd_types;\n-use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::{IntPredicate, TypeKind, span_invalid_monomorphization_error};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n@@ -667,9 +667,24 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         mul,\n         1.0\n     );\n+    arith_red!(\n+        simd_reduce_add_ordered: BinaryOp::Plus,\n+        vector_reduce_fadd,\n+        true,\n+        add,\n+        0.0\n+    );\n+    arith_red!(\n+        simd_reduce_mul_ordered: BinaryOp::Mult,\n+        vector_reduce_fmul,\n+        true,\n+        mul,\n+        1.0\n+    );\n+\n \n     macro_rules! minmax_red {\n-        ($name:ident: $reduction:ident) => {\n+        ($name:ident: $int_red:ident, $float_red:ident) => {\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n@@ -679,7 +694,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     ret_ty\n                 );\n                 return match in_elem.kind() {\n-                    ty::Int(_) | ty::Uint(_) | ty::Float(_) => Ok(bx.$reduction(args[0].immediate())),\n+                    ty::Int(_) | ty::Uint(_) => Ok(bx.$int_red(args[0].immediate())),\n+                    ty::Float(_) => Ok(bx.$float_red(args[0].immediate())),\n                     _ => return_error!(\n                         \"unsupported {} from `{}` with element `{}` to `{}`\",\n                         sym::$name,\n@@ -692,8 +708,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         };\n     }\n \n-    minmax_red!(simd_reduce_min: vector_reduce_min);\n-    minmax_red!(simd_reduce_max: vector_reduce_max);\n+    minmax_red!(simd_reduce_min: vector_reduce_min, vector_reduce_fmin);\n+    minmax_red!(simd_reduce_max: vector_reduce_max, vector_reduce_fmax);\n+    // TODO(sadlerap): revisit these intrinsics to generate more optimal reductions\n+    minmax_red!(simd_reduce_min_nanless: vector_reduce_min, vector_reduce_fmin);\n+    minmax_red!(simd_reduce_max_nanless: vector_reduce_max, vector_reduce_fmax);\n \n     macro_rules! bitwise_red {\n         ($name:ident : $op:expr, $boolean:expr) => {\n@@ -719,15 +738,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         ),\n                     }\n \n-                    // boolean reductions operate on vectors of i1s:\n-                    let i1 = bx.type_i1();\n-                    let i1xn = bx.type_vector(i1, in_len as u64);\n-                    bx.trunc(args[0].immediate(), i1xn)\n+                    args[0].immediate()\n                 };\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n                         let r = bx.vector_reduce_op(input, $op);\n-                        Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n+                        Ok(if !$boolean { r } else { bx.icmp(IntPredicate::IntNE, r, bx.context.new_rvalue_zero(r.get_type())) })\n                     }\n                     _ => return_error!(\n                         \"unsupported {} from `{}` with element `{}` to `{}`\",\n@@ -743,6 +759,9 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n \n     bitwise_red!(simd_reduce_and: BinaryOp::BitwiseAnd, false);\n     bitwise_red!(simd_reduce_or: BinaryOp::BitwiseOr, false);\n+    bitwise_red!(simd_reduce_xor: BinaryOp::BitwiseXor, false);\n+    bitwise_red!(simd_reduce_all: BinaryOp::BitwiseAnd, true);\n+    bitwise_red!(simd_reduce_any: BinaryOp::BitwiseOr, true);\n \n     unimplemented!(\"simd {}\", name);\n }"}, {"sha": "d7eca2a33df7045826ff1f23f7ecd2ea533de4fe", "filename": "src/type_.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/346ae2ad4b389d69b4e00ebc92a3c0242541651a/src%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/346ae2ad4b389d69b4e00ebc92a3c0242541651a/src%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_.rs?ref=346ae2ad4b389d69b4e00ebc92a3c0242541651a", "patch": "@@ -247,10 +247,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n         self.context.new_array_type(None, ty, len)\n     }\n-\n-    pub fn type_bool(&self) -> Type<'gcc> {\n-        self.context.new_type::<bool>()\n-    }\n }\n \n pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>) -> (Vec<Type<'gcc>>, bool) {"}]}