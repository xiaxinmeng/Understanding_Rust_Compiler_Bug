{"sha": "1350fbdb24a06bd389cf1617ad5b78289a0c2354", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNTBmYmRiMjRhMDZiZDM4OWNmMTYxN2FkNWI3ODI4OWEwYzIzNTQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T16:06:43Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T16:06:43Z"}, "message": "rustc: de-@ some RefCell's.", "tree": {"sha": "ec77f27afd79cfe63dc3c7f4094035a409f0a5b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec77f27afd79cfe63dc3c7f4094035a409f0a5b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1350fbdb24a06bd389cf1617ad5b78289a0c2354", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1350fbdb24a06bd389cf1617ad5b78289a0c2354", "html_url": "https://github.com/rust-lang/rust/commit/1350fbdb24a06bd389cf1617ad5b78289a0c2354", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1350fbdb24a06bd389cf1617ad5b78289a0c2354/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3f8a736c94bb285c0dfdcd26dde654d00225f55", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f8a736c94bb285c0dfdcd26dde654d00225f55", "html_url": "https://github.com/rust-lang/rust/commit/f3f8a736c94bb285c0dfdcd26dde654d00225f55"}], "stats": {"total": 797, "additions": 331, "deletions": 466}, "files": [{"sha": "cf0e7e161c1fc3d89110fbe74134f1cffeb01ef4", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -316,7 +316,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                 sess.diagnostic(), krate)));\n \n     let freevars = time(time_passes, \"freevar finding\", (), |_|\n-                        freevars::annotate_freevars(def_map, krate));\n+                        freevars::annotate_freevars(&def_map, krate));\n \n     let region_map = time(time_passes, \"region resolution\", (), |_|\n                           middle::region::resolve_crate(&sess, krate));"}, {"sha": "a43c6ac594b5b2de0cadbbdae4a31b16db7480d1", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -23,7 +23,6 @@ use metadata::loader;\n use metadata::loader::Os;\n use metadata::loader::CratePaths;\n \n-use std::cell::RefCell;\n use std::rc::Rc;\n use collections::HashMap;\n use syntax::ast;\n@@ -317,7 +316,7 @@ fn resolve_crate<'a>(e: &mut Env,\n             let cnum_map = if should_link {\n                 resolve_crate_deps(e, root, metadata.as_slice(), span)\n             } else {\n-                @RefCell::new(HashMap::new())\n+                HashMap::new()\n             };\n \n             // Claim this crate number and cache it if we're linking to the\n@@ -365,20 +364,16 @@ fn resolve_crate_deps(e: &mut Env,\n     debug!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n-    let mut cnum_map = HashMap::new();\n-    let r = decoder::get_crate_deps(cdata);\n-    for dep in r.iter() {\n-        let extrn_cnum = dep.cnum;\n+    decoder::get_crate_deps(cdata).iter().map(|dep| {\n         debug!(\"resolving dep crate {} hash: `{}`\", dep.crate_id, dep.hash);\n         let (local_cnum, _, _) = resolve_crate(e, root,\n                                                dep.crate_id.name.as_slice(),\n                                                &dep.crate_id,\n                                                Some(&dep.hash),\n                                                true,\n                                                span);\n-        cnum_map.insert(extrn_cnum, local_cnum);\n-    }\n-    return @RefCell::new(cnum_map);\n+        (dep.cnum, local_cnum)\n+    }).collect()\n }\n \n pub struct Loader<'a> {"}, {"sha": "537f3cf206d81372d67640625655732f6e42aa3b", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -30,7 +30,7 @@ use syntax::parse::token::IdentInterner;\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type cnum_map = @RefCell<HashMap<ast::CrateNum, ast::CrateNum>>;\n+pub type cnum_map = HashMap<ast::CrateNum, ast::CrateNum>;\n \n pub enum MetadataBlob {\n     MetadataVec(CVec<u8>),\n@@ -155,7 +155,7 @@ impl CStore {\n                  ordering: &mut Vec<ast::CrateNum>) {\n             if ordering.as_slice().contains(&cnum) { return }\n             let meta = cstore.get_crate_data(cnum);\n-            for (_, &dep) in meta.cnum_map.borrow().iter() {\n+            for (_, &dep) in meta.cnum_map.iter() {\n                 visit(cstore, dep, ordering);\n             }\n             ordering.push(cnum);"}, {"sha": "a83ef1f5a9ff8df2add7779d3ec7952429480bc9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -1155,7 +1155,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n         return ast::DefId { krate: cdata.cnum, node: did.node };\n     }\n \n-    match cdata.cnum_map.borrow().find(&did.krate) {\n+    match cdata.cnum_map.find(&did.krate) {\n         Some(&n) => {\n             ast::DefId {\n                 krate: n,"}, {"sha": "b167af268a37eaa05e0dbf087ed31b979b585531", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 55, "deletions": 82, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -52,9 +52,6 @@ use syntax::visit;\n use syntax;\n use writer = serialize::ebml::writer;\n \n-// used by astencode:\n-pub type abbrev_map = @RefCell<HashMap<ty::t, tyencode::ty_abbrev>>;\n-\n /// A borrowed version of ast::InlinedItem.\n pub enum InlinedItemRef<'a> {\n     IIItemRef(&'a ast::Item),\n@@ -71,7 +68,7 @@ pub type EncodeInlinedItem<'a> = |ecx: &EncodeContext,\n pub struct EncodeParams<'a> {\n     pub diag: &'a SpanHandler,\n     pub tcx: &'a ty::ctxt,\n-    pub reexports2: middle::resolve::ExportMap2,\n+    pub reexports2: &'a middle::resolve::ExportMap2,\n     pub item_symbols: &'a RefCell<NodeMap<~str>>,\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n@@ -99,13 +96,13 @@ pub struct EncodeContext<'a> {\n     pub diag: &'a SpanHandler,\n     pub tcx: &'a ty::ctxt,\n     pub stats: @Stats,\n-    pub reexports2: middle::resolve::ExportMap2,\n+    pub reexports2: &'a middle::resolve::ExportMap2,\n     pub item_symbols: &'a RefCell<NodeMap<~str>>,\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n     pub encode_inlined_item: EncodeInlinedItem<'a>,\n-    pub type_abbrevs: abbrev_map,\n+    pub type_abbrevs: tyencode::abbrev_map,\n }\n \n fn encode_name(ebml_w: &mut Encoder, name: Name) {\n@@ -134,7 +131,7 @@ fn encode_trait_ref(ebml_w: &mut Encoder,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+        abbrevs: &ecx.type_abbrevs\n     };\n \n     ebml_w.start_tag(tag);\n@@ -170,7 +167,7 @@ fn encode_ty_type_param_defs(ebml_w: &mut Encoder,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+        abbrevs: &ecx.type_abbrevs\n     };\n     for param in params.iter() {\n         ebml_w.start_tag(tag);\n@@ -227,7 +224,7 @@ pub fn write_type(ecx: &EncodeContext,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+        abbrevs: &ecx.type_abbrevs\n     };\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n@@ -249,7 +246,7 @@ fn encode_method_fty(ecx: &EncodeContext,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+        abbrevs: &ecx.type_abbrevs\n     };\n     tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n \n@@ -290,7 +287,7 @@ fn encode_parent_item(ebml_w: &mut Encoder, id: DefId) {\n }\n \n fn encode_struct_fields(ebml_w: &mut Encoder,\n-                        fields: &Vec<ty::field_ty>,\n+                        fields: &[ty::field_ty],\n                         origin: DefId) {\n     for f in fields.iter() {\n         if f.name == special_idents::unnamed_field.name {\n@@ -313,7 +310,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                             ebml_w: &mut Encoder,\n                             id: NodeId,\n                             variants: &[P<Variant>],\n-                            index: @RefCell<Vec<entry<i64>> >,\n+                            index: &mut Vec<entry<i64>>,\n                             generics: &ast::Generics) {\n     debug!(\"encode_enum_variant_info(id={:?})\", id);\n \n@@ -323,7 +320,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                                ast::DefId { krate: LOCAL_CRATE, node: id });\n     for variant in variants.iter() {\n         let def_id = local_def(variant.node.id);\n-        index.borrow_mut().push(entry {\n+        index.push(entry {\n             val: variant.node.id as i64,\n             pos: ebml_w.writer.tell().unwrap(),\n         });\n@@ -347,11 +344,10 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  ebml_w,\n-                                                 &fields,\n+                                                 fields.as_slice(),\n                                                  index);\n-                encode_struct_fields(ebml_w, &fields, def_id);\n-                let bkts = create_index(idx);\n-                encode_index(ebml_w, bkts, write_i64);\n+                encode_struct_fields(ebml_w, fields.as_slice(), def_id);\n+                encode_index(ebml_w, idx, write_i64);\n             }\n         }\n         if vi.get(i).disr_val != disr_val {\n@@ -666,8 +662,8 @@ fn encode_provided_source(ebml_w: &mut Encoder,\n /* Returns an index of items in this class */\n fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut Encoder,\n-                          fields: &Vec<ty::field_ty>,\n-                          global_index: @RefCell<Vec<entry<i64>> >)\n+                          fields: &[ty::field_ty],\n+                          global_index: &mut Vec<entry<i64>>)\n                           -> Vec<entry<i64>> {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n@@ -680,7 +676,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         let id = field.id.node;\n \n         index.push(entry {val: id as i64, pos: ebml_w.writer.tell().unwrap()});\n-        global_index.borrow_mut().push(entry {\n+        global_index.push(entry {\n             val: id as i64,\n             pos: ebml_w.writer.tell().unwrap(),\n         });\n@@ -700,9 +696,9 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ebml_w: &mut Encoder,\n                                name: ast::Ident,\n                                ctor_id: NodeId,\n-                               index: @RefCell<Vec<entry<i64>> >,\n+                               index: &mut Vec<entry<i64>>,\n                                struct_id: NodeId) {\n-    index.borrow_mut().push(entry {\n+    index.push(entry {\n         val: ctor_id as i64,\n         pos: ebml_w.writer.tell().unwrap(),\n     });\n@@ -825,7 +821,7 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n                                    def_id: DefId) {\n     match ecx.tcx.inherent_impls.borrow().find(&def_id) {\n         None => {}\n-        Some(&implementations) => {\n+        Some(implementations) => {\n             for implementation in implementations.borrow().iter() {\n                 ebml_w.start_tag(tag_items_data_item_inherent_impl);\n                 encode_def_id(ebml_w, implementation.did);\n@@ -841,7 +837,7 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n                                     trait_def_id: DefId) {\n     match ecx.tcx.trait_impls.borrow().find(&trait_def_id) {\n         None => {}\n-        Some(&implementations) => {\n+        Some(implementations) => {\n             for implementation in implementations.borrow().iter() {\n                 ebml_w.start_tag(tag_items_data_item_extension_impl);\n                 encode_def_id(ebml_w, implementation.did);\n@@ -854,14 +850,14 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut Encoder,\n                         item: &Item,\n-                        index: @RefCell<Vec<entry<i64>> >,\n+                        index: &mut Vec<entry<i64>>,\n                         path: PathElems,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n     fn add_to_index(item: &Item, ebml_w: &Encoder,\n-                     index: @RefCell<Vec<entry<i64>> >) {\n-        index.borrow_mut().push(entry {\n+                    index: &mut Vec<entry<i64>>) {\n+        index.push(entry {\n             val: item.id as i64,\n             pos: ebml_w.writer.tell().unwrap(),\n         });\n@@ -988,7 +984,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            class itself */\n         let idx = encode_info_for_struct(ecx,\n                                          ebml_w,\n-                                         &fields,\n+                                         fields.as_slice(),\n                                          index);\n \n         /* Index the class*/\n@@ -1009,16 +1005,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(ebml_w, &fields, def_id);\n+        encode_struct_fields(ebml_w, fields.as_slice(), def_id);\n \n         (ecx.encode_inlined_item)(ecx, ebml_w, IIItemRef(item));\n \n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n \n         /* Each class has its own index -- encode it */\n-        let bkts = create_index(idx);\n-        encode_index(ebml_w, bkts, write_i64);\n+        encode_index(ebml_w, idx, write_i64);\n         ebml_w.end_tag();\n \n         // If this is a tuple-like struct, encode the type of the constructor.\n@@ -1077,7 +1072,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 Some(*ast_methods.get(i))\n             } else { None };\n \n-            index.borrow_mut().push(entry {\n+            index.push(entry {\n                 val: m.def_id.node as i64,\n                 pos: ebml_w.writer.tell().unwrap(),\n             });\n@@ -1135,7 +1130,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             let method_ty = ty::method(tcx, method_def_id);\n \n-            index.borrow_mut().push(entry {\n+            index.push(entry {\n                 val: method_def_id.node as i64,\n                 pos: ebml_w.writer.tell().unwrap(),\n             });\n@@ -1202,10 +1197,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut Encoder,\n                                 nitem: &ForeignItem,\n-                                index: @RefCell<Vec<entry<i64>> >,\n+                                index: &mut Vec<entry<i64>>,\n                                 path: PathElems,\n                                 abi: abi::Abi) {\n-    index.borrow_mut().push(entry {\n+    index.push(entry {\n         val: nitem.id as i64,\n         pos: ebml_w.writer.tell().unwrap(),\n     });\n@@ -1244,7 +1239,7 @@ fn my_visit_expr(_e: &Expr) { }\n fn my_visit_item(i: &Item,\n                  ebml_w: &mut Encoder,\n                  ecx_ptr: *int,\n-                 index: @RefCell<Vec<entry<i64>> >) {\n+                 index: &mut Vec<entry<i64>>) {\n     let mut ebml_w = unsafe { ebml_w.unsafe_clone() };\n     // See above\n     let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n@@ -1256,7 +1251,7 @@ fn my_visit_item(i: &Item,\n fn my_visit_foreign_item(ni: &ForeignItem,\n                          ebml_w: &mut Encoder,\n                          ecx_ptr:*int,\n-                         index: @RefCell<Vec<entry<i64>> >) {\n+                         index: &mut Vec<entry<i64>>) {\n     // See above\n     let ecx: &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n     debug!(\"writing foreign item {}::{}\",\n@@ -1277,7 +1272,7 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n struct EncodeVisitor<'a,'b> {\n     ebml_w_for_visit_item: &'a mut Encoder<'b>,\n     ecx_ptr:*int,\n-    index: @RefCell<Vec<entry<i64>> >,\n+    index: &'a mut Vec<entry<i64>>,\n }\n \n impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n@@ -1305,9 +1300,9 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                          ebml_w: &mut Encoder,\n                          krate: &Crate)\n                          -> Vec<entry<i64>> {\n-    let index = @RefCell::new(Vec::new());\n+    let mut index = Vec::new();\n     ebml_w.start_tag(tag_items_data);\n-    index.borrow_mut().push(entry {\n+    index.push(entry {\n         val: CRATE_NODE_ID as i64,\n         pos: ebml_w.writer.tell().unwrap(),\n     });\n@@ -1321,53 +1316,34 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n     // See comment in `encode_side_tables_for_ii` in astencode\n     let ecx_ptr: *int = unsafe { cast::transmute(ecx) };\n-    {\n-        let mut visitor = EncodeVisitor {\n-            index: index,\n-            ecx_ptr: ecx_ptr,\n-            ebml_w_for_visit_item: &mut *ebml_w,\n-        };\n-\n-        visit::walk_crate(&mut visitor, krate, ());\n-    }\n+    visit::walk_crate(&mut EncodeVisitor {\n+        index: &mut index,\n+        ecx_ptr: ecx_ptr,\n+        ebml_w_for_visit_item: &mut *ebml_w,\n+    }, krate, ());\n \n     ebml_w.end_tag();\n-    return /*bad*/index.borrow().clone();\n+    index\n }\n \n \n // Path and definition ID indexing\n \n-fn create_index<T:Clone + Hash + 'static>(\n-                index: Vec<entry<T>> )\n-                -> Vec<@Vec<entry<T>> > {\n-    let mut buckets: Vec<@RefCell<Vec<entry<T>> >> = Vec::new();\n-    for _ in range(0u, 256u) {\n-        buckets.push(@RefCell::new(Vec::new()));\n-    }\n-    for elt in index.iter() {\n+fn encode_index<T: Hash>(ebml_w: &mut Encoder, index: Vec<entry<T>>,\n+                         write_fn: |&mut MemWriter, &T|) {\n+    let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n+    for elt in index.move_iter() {\n         let h = hash::hash(&elt.val) as uint;\n-        buckets.get_mut(h % 256).borrow_mut().push((*elt).clone());\n-    }\n-\n-    let mut buckets_frozen = Vec::new();\n-    for bucket in buckets.iter() {\n-        buckets_frozen.push(@/*bad*/bucket.borrow().clone());\n+        buckets.get_mut(h % 256).push(elt);\n     }\n-    return buckets_frozen;\n-}\n \n-fn encode_index<T:'static>(\n-                ebml_w: &mut Encoder,\n-                buckets: Vec<@Vec<entry<T>> > ,\n-                write_fn: |&mut MemWriter, &T|) {\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs = Vec::new();\n     ebml_w.start_tag(tag_index_buckets);\n     for bucket in buckets.iter() {\n         bucket_locs.push(ebml_w.writer.tell().unwrap());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n-        for elt in (**bucket).iter() {\n+        for elt in bucket.iter() {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             {\n@@ -1614,7 +1590,7 @@ impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), _, _) => {\n-                let def_map = self.ecx.tcx.def_map;\n+                let def_map = &self.ecx.tcx.def_map;\n                 let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n                 let def_id = ast_util::def_id_of_def(trait_def);\n \n@@ -1749,19 +1725,17 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n         non_inlineable_statics,\n         ..\n     } = parms;\n-    let type_abbrevs = @RefCell::new(HashMap::new());\n-    let stats = @stats;\n     let ecx = EncodeContext {\n         diag: diag,\n         tcx: tcx,\n-        stats: stats,\n+        stats: @stats,\n         reexports2: reexports2,\n         item_symbols: item_symbols,\n         non_inlineable_statics: non_inlineable_statics,\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: encode_inlined_item,\n-        type_abbrevs: type_abbrevs,\n+        type_abbrevs: RefCell::new(HashMap::new()),\n      };\n \n     let mut ebml_w = writer::Encoder(wr);\n@@ -1815,8 +1789,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n     ecx.stats.item_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     i = ebml_w.writer.tell().unwrap();\n-    let items_buckets = create_index(items_index);\n-    encode_index(&mut ebml_w, items_buckets, write_i64);\n+    encode_index(&mut ebml_w, items_index, write_i64);\n     ecx.stats.index_bytes.set(ebml_w.writer.tell().unwrap() - i);\n     ebml_w.end_tag();\n \n@@ -1848,12 +1821,12 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n \n // Get the encoded string for a type\n pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> ~str {\n-    let cx = &tyencode::ctxt {\n+    let mut wr = MemWriter::new();\n+    tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),\n         ds: def_to_str,\n         tcx: tcx,\n-        abbrevs: tyencode::ac_no_abbrevs};\n-    let mut wr = MemWriter::new();\n-    tyencode::enc_ty(&mut wr, cx, t);\n+        abbrevs: &RefCell::new(HashMap::new())\n+    }, t);\n     str::from_utf8_owned(wr.get_ref().to_owned()).unwrap()\n }"}, {"sha": "9134afd640dc7caf2a130d6278c8119f78682f7b", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 24, "deletions": 51, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -17,7 +17,6 @@ use std::cell::RefCell;\n use collections::HashMap;\n use std::io;\n use std::io::MemWriter;\n-use std::str;\n use std::fmt;\n \n use middle::ty::param_ty;\n@@ -39,7 +38,7 @@ pub struct ctxt<'a> {\n     pub ds: fn(DefId) -> ~str,\n     // The type context.\n     pub tcx: &'a ty::ctxt,\n-    pub abbrevs: abbrev_ctxt\n+    pub abbrevs: &'a abbrev_map\n }\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n@@ -51,61 +50,35 @@ pub struct ty_abbrev {\n     s: ~str\n }\n \n-pub enum abbrev_ctxt {\n-    ac_no_abbrevs,\n-    ac_use_abbrevs(@RefCell<HashMap<ty::t, ty_abbrev>>),\n-}\n+pub type abbrev_map = RefCell<HashMap<ty::t, ty_abbrev>>;\n \n fn mywrite(w: &mut MemWriter, fmt: &fmt::Arguments) {\n     fmt::write(&mut *w as &mut io::Writer, fmt);\n }\n \n pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n-    match cx.abbrevs {\n-      ac_no_abbrevs => {\n-          let result_str_opt = cx.tcx.short_names_cache.borrow()\n-                                            .find(&t)\n-                                            .map(|result| {\n-                                                (*result).clone()\n-                                            });\n-          let result_str = match result_str_opt {\n-            Some(s) => s,\n-            None => {\n-                let wr = &mut MemWriter::new();\n-                enc_sty(wr, cx, &ty::get(t).sty);\n-                let s = str::from_utf8(wr.get_ref()).unwrap();\n-                cx.tcx.short_names_cache.borrow_mut().insert(t, s.to_str());\n-                s.to_str()\n-            }\n-          };\n-          w.write(result_str.as_bytes());\n-      }\n-      ac_use_abbrevs(abbrevs) => {\n-          match abbrevs.borrow_mut().find(&t) {\n-              Some(a) => { w.write(a.s.as_bytes()); return; }\n-              None => {}\n-          }\n-          let pos = w.tell().unwrap();\n-          enc_sty(w, cx, &ty::get(t).sty);\n-          let end = w.tell().unwrap();\n-          let len = end - pos;\n-          fn estimate_sz(u: u64) -> u64 {\n-              let mut n = u;\n-              let mut len = 0;\n-              while n != 0 { len += 1; n = n >> 4; }\n-              return len;\n-          }\n-          let abbrev_len = 3 + estimate_sz(pos) + estimate_sz(len);\n-          if abbrev_len < len {\n-              // I.e. it's actually an abbreviation.\n-              let s = format!(\"\\\\#{:x}:{:x}\\\\#\", pos, len);\n-              let a = ty_abbrev { pos: pos as uint,\n-                                  len: len as uint,\n-                                  s: s };\n-              abbrevs.borrow_mut().insert(t, a);\n-          }\n-          return;\n-      }\n+    match cx.abbrevs.borrow_mut().find(&t) {\n+        Some(a) => { w.write(a.s.as_bytes()); return; }\n+        None => {}\n+    }\n+    let pos = w.tell().unwrap();\n+    enc_sty(w, cx, &ty::get(t).sty);\n+    let end = w.tell().unwrap();\n+    let len = end - pos;\n+    fn estimate_sz(u: u64) -> u64 {\n+        let mut n = u;\n+        let mut len = 0;\n+        while n != 0 { len += 1; n = n >> 4; }\n+        return len;\n+    }\n+    let abbrev_len = 3 + estimate_sz(pos) + estimate_sz(len);\n+    if abbrev_len < len {\n+        // I.e. it's actually an abbreviation.\n+        cx.abbrevs.borrow_mut().insert(t, ty_abbrev {\n+            pos: pos as uint,\n+            len: len as uint,\n+            s: format!(\"\\\\#{:x}:{:x}\\\\#\", pos, len)\n+        });\n     }\n }\n "}, {"sha": "6cee7398877f14dde8c903b7ceabcf7130f5b8d3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -820,7 +820,7 @@ impl<'a> get_ty_str_ctxt for e::EncodeContext<'a> {\n             diag: self.tcx.sess.diagnostic(),\n             ds: e::def_to_str,\n             tcx: self.tcx,\n-            abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)\n+            abbrevs: &self.type_abbrevs\n         }\n     }\n }"}, {"sha": "ef98cdc0caef4e2fc75c3cffe635021b59bb5159", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -146,7 +146,7 @@ fn gather_loans_in_local(this: &mut GatherLoanCtxt,\n         None => {\n             // Variable declarations without initializers are considered \"moves\":\n             let tcx = this.bccx.tcx;\n-            pat_util::pat_bindings(tcx.def_map, local.pat, |_, id, span, _| {\n+            pat_util::pat_bindings(&tcx.def_map, local.pat, |_, id, span, _| {\n                 gather_moves::gather_decl(this.bccx,\n                                           &this.move_data,\n                                           id,\n@@ -821,7 +821,7 @@ impl<'a> GatherLoanCtxt<'a> {\n               ast::PatIdent(bm, _, _) if self.pat_is_binding(pat) => {\n                 // Each match binding is effectively an assignment.\n                 let tcx = self.bccx.tcx;\n-                pat_util::pat_bindings(tcx.def_map, pat, |_, id, span, _| {\n+                pat_util::pat_bindings(&tcx.def_map, pat, |_, id, span, _| {\n                     gather_moves::gather_assignment(self.bccx,\n                                                     &self.move_data,\n                                                     id,\n@@ -919,7 +919,7 @@ impl<'a> GatherLoanCtxt<'a> {\n     }\n \n     pub fn pat_is_binding(&self, pat: &ast::Pat) -> bool {\n-        pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n+        pat_util::pat_is_binding(&self.bccx.tcx.def_map, pat)\n     }\n \n     pub fn report_potential_errors(&self) {"}, {"sha": "df8d882864ebf39d4ebb7cc8a2f36a84f1477435", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -86,36 +86,35 @@ pub fn check_crate(tcx: &ty::ctxt,\n         moves_map: moves_map,\n         moved_variables_set: moved_variables_set,\n         capture_map: capture_map,\n-        root_map: root_map(),\n+        root_map: RefCell::new(HashMap::new()),\n         stats: @BorrowStats {\n             loaned_paths_same: Cell::new(0),\n             loaned_paths_imm: Cell::new(0),\n             stable_paths: Cell::new(0),\n             guaranteed_paths: Cell::new(0),\n         }\n     };\n-    let bccx = &mut bccx;\n \n-    visit::walk_crate(bccx, krate, ());\n+    visit::walk_crate(&mut bccx, krate, ());\n \n     if tcx.sess.borrowck_stats() {\n         println!(\"--- borrowck stats ---\");\n         println!(\"paths requiring guarantees: {}\",\n                  bccx.stats.guaranteed_paths.get());\n         println!(\"paths requiring loans     : {}\",\n-                 make_stat(bccx, bccx.stats.loaned_paths_same.get()));\n+                 make_stat(&bccx, bccx.stats.loaned_paths_same.get()));\n         println!(\"paths requiring imm loans : {}\",\n-                 make_stat(bccx, bccx.stats.loaned_paths_imm.get()));\n+                 make_stat(&bccx, bccx.stats.loaned_paths_imm.get()));\n         println!(\"stable paths              : {}\",\n-                 make_stat(bccx, bccx.stats.stable_paths.get()));\n+                 make_stat(&bccx, bccx.stats.stable_paths.get()));\n     }\n \n-    return bccx.root_map;\n+    return bccx.root_map.unwrap();\n \n-    fn make_stat(bccx: &mut BorrowckCtxt, stat: uint) -> ~str {\n+    fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> ~str {\n         let stat_f = stat as f64;\n         let total = bccx.stats.guaranteed_paths.get() as f64;\n-        format!(\"{} ({:.0f}%)\", stat  , stat_f * 100.0 / total)\n+        format!(\"{} ({:.0f}%)\", stat, stat_f * 100.0 / total)\n     }\n }\n \n@@ -175,7 +174,7 @@ pub struct BorrowckCtxt<'a> {\n     moves_map: &'a NodeSet,\n     moved_variables_set: &'a NodeSet,\n     capture_map: &'a moves::CaptureMap,\n-    root_map: root_map,\n+    root_map: RefCell<root_map>,\n \n     // Statistics:\n     stats: @BorrowStats\n@@ -375,11 +374,7 @@ pub struct RootInfo {\n     pub scope: ast::NodeId,\n }\n \n-pub type root_map = @RefCell<HashMap<root_map_key, RootInfo>>;\n-\n-pub fn root_map() -> root_map {\n-    return @RefCell::new(HashMap::new());\n-}\n+pub type root_map = HashMap<root_map_key, RootInfo>;\n \n ///////////////////////////////////////////////////////////////////////////\n // Errors"}, {"sha": "eb52aa18de85fa204e8dbc4af7c29605dc4f48f8", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -45,7 +45,7 @@ fn check_item(v: &mut CheckCrateVisitor, it: &Item, _is_const: bool) {\n     match it.node {\n         ItemStatic(_, _, ex) => {\n             v.visit_expr(ex, true);\n-            check_item_recursion(&v.tcx.sess, &v.tcx.map, v.tcx.def_map, it);\n+            check_item_recursion(&v.tcx.sess, &v.tcx.map, &v.tcx.def_map, it);\n         }\n         ItemEnum(ref enum_definition, _) => {\n             for var in (*enum_definition).variants.iter() {\n@@ -178,14 +178,14 @@ struct CheckItemRecursionVisitor<'a> {\n     root_it: &'a Item,\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map,\n-    def_map: resolve::DefMap,\n+    def_map: &'a resolve::DefMap,\n     idstack: Vec<NodeId> }\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n pub fn check_item_recursion<'a>(sess: &'a Session,\n                                 ast_map: &'a ast_map::Map,\n-                                def_map: resolve::DefMap,\n+                                def_map: &'a resolve::DefMap,\n                                 it: &'a Item) {\n \n     let mut visitor = CheckItemRecursionVisitor {"}, {"sha": "2ef009e36e4eadcf62293b9448c0c0f5f72b8a92", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -934,7 +934,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                        has_guard: bool,\n                                        pats: &[@Pat]) {\n     let tcx = cx.tcx;\n-    let def_map = tcx.def_map;\n+    let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n     let mut any_by_move = false;\n     for pat in pats.iter() {"}, {"sha": "cd3ab100e55c23f71fbe172296d6fb335b14d703", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -127,7 +127,7 @@ pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n             None => {}\n         }\n         let maps = astencode::Maps {\n-            root_map: @RefCell::new(HashMap::new()),\n+            root_map: HashMap::new(),\n             capture_map: RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n@@ -166,7 +166,7 @@ pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n             None => {}\n         }\n         let maps = astencode::Maps {\n-            root_map: @RefCell::new(HashMap::new()),\n+            root_map: HashMap::new(),\n             capture_map: RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, def_id,"}, {"sha": "94d3cab1ef626a1b65c28ada7076428fe1b9dafc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -339,7 +339,7 @@ impl<'a> DeadVisitor<'a> {\n         let def_id = local_def(id);\n         match self.tcx.inherent_impls.borrow().find(&def_id) {\n             None => (),\n-            Some(ref impl_list) => {\n+            Some(impl_list) => {\n                 for impl_ in impl_list.borrow().iter() {\n                     for method in impl_.methods.iter() {\n                         if self.live_symbols.contains(&method.def_id.node) {"}, {"sha": "1f7b6ea733b5d281c9044b6cf6f2db2efed0524a", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -32,13 +32,13 @@ pub struct freevar_entry {\n pub type freevar_info = @Vec<@freevar_entry> ;\n pub type freevar_map = NodeMap<freevar_info>;\n \n-struct CollectFreevarsVisitor {\n+struct CollectFreevarsVisitor<'a> {\n     seen: NodeSet,\n-    refs: Vec<@freevar_entry> ,\n-    def_map: resolve::DefMap,\n+    refs: Vec<@freevar_entry>,\n+    def_map: &'a resolve::DefMap,\n }\n \n-impl Visitor<int> for CollectFreevarsVisitor {\n+impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n \n     fn visit_item(&mut self, _: &ast::Item, _: int) {\n         // ignore_item\n@@ -87,30 +87,23 @@ impl Visitor<int> for CollectFreevarsVisitor {\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block) -> freevar_info {\n-    let seen = NodeSet::new();\n-    let refs = Vec::new();\n-\n+fn collect_freevars(def_map: &resolve::DefMap, blk: &ast::Block) -> freevar_info {\n     let mut v = CollectFreevarsVisitor {\n-        seen: seen,\n-        refs: refs,\n+        seen: NodeSet::new(),\n+        refs: Vec::new(),\n         def_map: def_map,\n     };\n \n     v.visit_block(blk, 1);\n-    let CollectFreevarsVisitor {\n-        refs,\n-        ..\n-    } = v;\n-    return @refs;\n+    @v.refs\n }\n \n-struct AnnotateFreevarsVisitor {\n-    def_map: resolve::DefMap,\n+struct AnnotateFreevarsVisitor<'a> {\n+    def_map: &'a resolve::DefMap,\n     freevars: freevar_map,\n }\n \n-impl Visitor<()> for AnnotateFreevarsVisitor {\n+impl<'a> Visitor<()> for AnnotateFreevarsVisitor<'a> {\n     fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n                 blk: &ast::Block, s: Span, nid: ast::NodeId, _: ()) {\n         let vars = collect_freevars(self.def_map, blk);\n@@ -124,19 +117,15 @@ impl Visitor<()> for AnnotateFreevarsVisitor {\n // efficient as it fully recomputes the free variables at every\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n-pub fn annotate_freevars(def_map: resolve::DefMap, krate: &ast::Crate) ->\n+pub fn annotate_freevars(def_map: &resolve::DefMap, krate: &ast::Crate) ->\n    freevar_map {\n     let mut visitor = AnnotateFreevarsVisitor {\n         def_map: def_map,\n         freevars: NodeMap::new(),\n     };\n     visit::walk_crate(&mut visitor, krate, ());\n \n-    let AnnotateFreevarsVisitor {\n-        freevars,\n-        ..\n-    } = visitor;\n-    freevars\n+    visitor.freevars\n }\n \n pub fn get_freevars(tcx: &ty::ctxt, fid: ast::NodeId) -> freevar_info {"}, {"sha": "a35b862eb9ca4170b5c8eccf7118316e9b04fdaf", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -1337,7 +1337,7 @@ fn check_unsafe_block(cx: &Context, e: &ast::Expr) {\n fn check_unused_mut_pat(cx: &Context, p: &ast::Pat) {\n     match p.node {\n         ast::PatIdent(ast::BindByValue(ast::MutMutable),\n-                      ref path, _) if pat_util::pat_is_binding(cx.tcx.def_map, p)=> {\n+                      ref path, _) if pat_util::pat_is_binding(&cx.tcx.def_map, p) => {\n             // `let mut _a = 1;` doesn't need a warning.\n             let initial_underscore = if path.segments.len() == 1 {\n                 token::get_ident(path.segments"}, {"sha": "4be9992367d5f34faffb3a1f87f86960e037431c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -368,7 +368,7 @@ fn visit_fn(ir: &mut IrMaps,\n     }\n \n     for arg in decl.inputs.iter() {\n-        pat_util::pat_bindings(ir.tcx.def_map,\n+        pat_util::pat_bindings(&ir.tcx.def_map,\n                                arg.pat,\n                                |_bm, arg_id, _x, path| {\n             debug!(\"adding argument {}\", arg_id);\n@@ -402,7 +402,7 @@ fn visit_fn(ir: &mut IrMaps,\n }\n \n fn visit_local(ir: &mut IrMaps, local: &Local) {\n-    pat_util::pat_bindings(ir.tcx.def_map, local.pat, |bm, p_id, sp, path| {\n+    pat_util::pat_bindings(&ir.tcx.def_map, local.pat, |bm, p_id, sp, path| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = ast_util::path_to_ident(path);\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -426,7 +426,7 @@ fn visit_local(ir: &mut IrMaps, local: &Local) {\n \n fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     for pat in arm.pats.iter() {\n-        pat_util::pat_bindings(ir.tcx.def_map, *pat, |bm, p_id, sp, path| {\n+        pat_util::pat_bindings(&ir.tcx.def_map, *pat, |bm, p_id, sp, path| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n@@ -596,7 +596,7 @@ impl<'a> Liveness<'a> {\n     fn pat_bindings(&mut self,\n                     pat: &Pat,\n                     f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n-        pat_util::pat_bindings(self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n+        pat_util::pat_bindings(&self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(self, ln, var, sp, p_id);\n@@ -1524,7 +1524,7 @@ impl<'a> Liveness<'a> {\n \n     fn warn_about_unused_args(&self, decl: &FnDecl, entry_ln: LiveNode) {\n         for arg in decl.inputs.iter() {\n-            pat_util::pat_bindings(self.ir.tcx.def_map,\n+            pat_util::pat_bindings(&self.ir.tcx.def_map,\n                                    arg.pat,\n                                    |_bm, p_id, sp, path| {\n                 let var = self.variable(p_id, sp);"}, {"sha": "eedcaa89e3cacdfd4e1b3ce8151dea885530cb9c", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -605,7 +605,7 @@ impl<'a> VisitContext<'a> {\n          * into itself or not based on its type and annotation.\n          */\n \n-        pat_bindings(self.tcx.def_map, pat, |bm, id, _span, path| {\n+        pat_bindings(&self.tcx.def_map, pat, |bm, id, _span, path| {\n             let binding_moves = match bm {\n                 BindByRef(_) => false,\n                 BindByValue(_) => {"}, {"sha": "842d3bae6a764cc231f63647a00fdec7fa948943", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -20,15 +20,15 @@ pub type PatIdMap = HashMap<Ident, NodeId>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n-pub fn pat_id_map(dm: resolve::DefMap, pat: &Pat) -> PatIdMap {\n+pub fn pat_id_map(dm: &resolve::DefMap, pat: &Pat) -> PatIdMap {\n     let mut map = HashMap::new();\n     pat_bindings(dm, pat, |_bm, p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n     });\n     map\n }\n \n-pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n             match dm.borrow().find(&pat.id) {\n@@ -40,7 +40,7 @@ pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_const(dm: resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_const(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(_, _, None) | PatEnum(..) => {\n             match dm.borrow().find(&pat.id) {\n@@ -52,7 +52,7 @@ pub fn pat_is_const(dm: resolve::DefMap, pat: &Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding(dm: resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_binding(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(..) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n@@ -62,7 +62,7 @@ pub fn pat_is_binding(dm: resolve::DefMap, pat: &Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_is_binding_or_wild(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(..) => pat_is_binding(dm, pat),\n         PatWild | PatWildMulti => true,\n@@ -72,7 +72,7 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: &Pat) -> bool {\n \n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings(dm: resolve::DefMap,\n+pub fn pat_bindings(dm: &resolve::DefMap,\n                     pat: &Pat,\n                     it: |BindingMode, NodeId, Span, &Path|) {\n     walk_pat(pat, |p| {\n@@ -88,7 +88,7 @@ pub fn pat_bindings(dm: resolve::DefMap,\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(dm: resolve::DefMap, pat: &Pat) -> bool {\n+pub fn pat_contains_bindings(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     let mut contains_bindings = false;\n     walk_pat(pat, |p| {\n         if pat_is_binding(dm, p) {"}, {"sha": "ff90e58d1840e570f7e987ace867614818590e99", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 106, "deletions": 139, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -16,7 +16,7 @@ use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use middle::lang_items::LanguageItems;\n use middle::lint::{UnnecessaryQualification, UnusedImports};\n use middle::pat_util::pat_bindings;\n-use util::nodemap::{NodeMap, DefIdSet};\n+use util::nodemap::{NodeMap, DefIdSet, FnvHashSet};\n \n use syntax::ast::*;\n use syntax::ast;\n@@ -38,7 +38,7 @@ use std::strbuf::StrBuf;\n use std::uint;\n \n // Definition mapping\n-pub type DefMap = @RefCell<NodeMap<Def>>;\n+pub type DefMap = RefCell<NodeMap<Def>>;\n \n struct binding_info {\n     span: Span,\n@@ -53,7 +53,7 @@ pub type TraitMap = NodeMap<Vec<DefId> >;\n \n // This is the replacement export map. It maps a module to all of the exports\n // within.\n-pub type ExportMap2 = @RefCell<NodeMap<Vec<Export2> >>;\n+pub type ExportMap2 = RefCell<NodeMap<Vec<Export2> >>;\n \n pub struct Export2 {\n     pub name: ~str,        // The name of the target.\n@@ -821,15 +821,15 @@ fn Resolver<'a>(session: &'a Session,\n \n         graph_root: graph_root,\n \n-        method_map: @RefCell::new(HashMap::new()),\n+        method_set: RefCell::new(FnvHashSet::new()),\n         structs: HashSet::new(),\n \n         unresolved_imports: 0,\n \n         current_module: current_module,\n-        value_ribs: @RefCell::new(Vec::new()),\n-        type_ribs: @RefCell::new(Vec::new()),\n-        label_ribs: @RefCell::new(Vec::new()),\n+        value_ribs: RefCell::new(Vec::new()),\n+        type_ribs: RefCell::new(Vec::new()),\n+        label_ribs: RefCell::new(Vec::new()),\n \n         current_trait_refs: None,\n \n@@ -840,8 +840,8 @@ fn Resolver<'a>(session: &'a Session,\n \n         namespaces: vec!(TypeNS, ValueNS),\n \n-        def_map: @RefCell::new(NodeMap::new()),\n-        export_map2: @RefCell::new(NodeMap::new()),\n+        def_map: RefCell::new(NodeMap::new()),\n+        export_map2: RefCell::new(NodeMap::new()),\n         trait_map: NodeMap::new(),\n         used_imports: HashSet::new(),\n         external_exports: DefIdSet::new(),\n@@ -860,7 +860,7 @@ struct Resolver<'a> {\n \n     graph_root: @NameBindings,\n \n-    method_map: @RefCell<HashMap<Name, HashSet<DefId>>>,\n+    method_set: RefCell<FnvHashSet<(Name, DefId)>>,\n     structs: HashSet<DefId>,\n \n     // The number of imports that are currently unresolved.\n@@ -871,13 +871,13 @@ struct Resolver<'a> {\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n-    value_ribs: @RefCell<Vec<@Rib> >,\n+    value_ribs: RefCell<Vec<@Rib>>,\n \n     // The current set of local scopes, for types.\n-    type_ribs: @RefCell<Vec<@Rib> >,\n+    type_ribs: RefCell<Vec<@Rib>>,\n \n     // The current set of local scopes, for labels.\n-    label_ribs: @RefCell<Vec<@Rib> >,\n+    label_ribs: RefCell<Vec<@Rib>>,\n \n     // The trait that the current context can refer to.\n     current_trait_refs: Option<Vec<DefId> >,\n@@ -1003,13 +1003,13 @@ impl<'a> Resolver<'a> {\n      * If this node does not have a module definition and we are not inside\n      * a block, fails.\n      */\n-    fn add_child(&mut self,\n-                     name: Ident,\n-                     reduced_graph_parent: ReducedGraphParent,\n-                     duplicate_checking_mode: DuplicateCheckingMode,\n-                     // For printing errors\n-                     sp: Span)\n-                     -> (@NameBindings, ReducedGraphParent) {\n+    fn add_child(&self,\n+                 name: Ident,\n+                 reduced_graph_parent: ReducedGraphParent,\n+                 duplicate_checking_mode: DuplicateCheckingMode,\n+                 // For printing errors\n+                 sp: Span)\n+                 -> (@NameBindings, ReducedGraphParent) {\n         // If this is the immediate descendant of a module, then we add the\n         // child name directly. Otherwise, we create or reuse an anonymous\n         // module and add the child to that.\n@@ -1358,8 +1358,9 @@ impl<'a> Resolver<'a> {\n                 let module_parent = ModuleReducedGraphParent(name_bindings.\n                                                              get_module());\n \n+                let def_id = local_def(item.id);\n+\n                 // Add the names of all the methods to the trait info.\n-                let mut method_names = HashMap::new();\n                 for method in methods.iter() {\n                     let ty_m = trait_method_to_ty_method(method);\n \n@@ -1388,23 +1389,8 @@ impl<'a> Resolver<'a> {\n                     method_name_bindings.define_value(def, ty_m.span, true);\n \n                     // Add it to the trait info if not static.\n-                    match ty_m.explicit_self.node {\n-                        SelfStatic => {}\n-                        _ => {\n-                            method_names.insert(ident.name, ());\n-                        }\n-                    }\n-                }\n-\n-                let def_id = local_def(item.id);\n-                for (name, _) in method_names.iter() {\n-                    let mut method_map = self.method_map.borrow_mut();\n-                    if !method_map.contains_key(name) {\n-                        method_map.insert(*name, HashSet::new());\n-                    }\n-                    match method_map.find_mut(name) {\n-                        Some(s) => { s.insert(def_id); },\n-                        _ => fail!(\"can't happen\"),\n+                    if ty_m.explicit_self.node != SelfStatic {\n+                        self.method_set.borrow_mut().insert((ident.name, def_id));\n                     }\n                 }\n \n@@ -1685,7 +1671,6 @@ impl<'a> Resolver<'a> {\n \n               let method_def_ids =\n                 csearch::get_trait_method_def_ids(&self.session.cstore, def_id);\n-              let mut interned_method_names = HashSet::new();\n               for &method_def_id in method_def_ids.iter() {\n                   let (method_name, explicit_self) =\n                       csearch::get_method_name_and_explicit_self(&self.session.cstore,\n@@ -1698,22 +1683,12 @@ impl<'a> Resolver<'a> {\n \n                   // Add it to the trait info if not static.\n                   if explicit_self != SelfStatic {\n-                      interned_method_names.insert(method_name.name);\n+                      self.method_set.borrow_mut().insert((method_name.name, def_id));\n                   }\n                   if is_exported {\n                       self.external_exports.insert(method_def_id);\n                   }\n               }\n-              for name in interned_method_names.iter() {\n-                  let mut method_map = self.method_map.borrow_mut();\n-                  if !method_map.contains_key(name) {\n-                      method_map.insert(*name, HashSet::new());\n-                  }\n-                  match method_map.find_mut(name) {\n-                      Some(s) => { s.insert(def_id); },\n-                      _ => fail!(\"can't happen\"),\n-                  }\n-              }\n \n               child_name_bindings.define_type(def, DUMMY_SP, is_public);\n \n@@ -3444,12 +3419,12 @@ impl<'a> Resolver<'a> {\n \n     /// Wraps the given definition in the appropriate number of `def_upvar`\n     /// wrappers.\n-    fn upvarify(&mut self,\n-                    ribs: &mut Vec<@Rib> ,\n-                    rib_index: uint,\n-                    def_like: DefLike,\n-                    span: Span)\n-                    -> Option<DefLike> {\n+    fn upvarify(&self,\n+                ribs: &[@Rib],\n+                rib_index: uint,\n+                def_like: DefLike,\n+                span: Span)\n+                -> Option<DefLike> {\n         let mut def;\n         let is_ty_param;\n \n@@ -3470,7 +3445,7 @@ impl<'a> Resolver<'a> {\n \n         let mut rib_index = rib_index + 1;\n         while rib_index < ribs.len() {\n-            match ribs.get(rib_index).kind {\n+            match ribs[rib_index].kind {\n                 NormalRibKind => {\n                     // Nothing to do. Continue.\n                 }\n@@ -3560,18 +3535,18 @@ impl<'a> Resolver<'a> {\n         return Some(DlDef(def));\n     }\n \n-    fn search_ribs(&mut self,\n-                       ribs: &mut Vec<@Rib> ,\n-                       name: Name,\n-                       span: Span)\n-                       -> Option<DefLike> {\n+    fn search_ribs(&self,\n+                   ribs: &[@Rib],\n+                   name: Name,\n+                   span: Span)\n+                   -> Option<DefLike> {\n         // FIXME #4950: This should not use a while loop.\n         // FIXME #4950: Try caching?\n \n         let mut i = ribs.len();\n         while i != 0 {\n             i -= 1;\n-            let binding_opt = ribs.get(i).bindings.borrow().find_copy(&name);\n+            let binding_opt = ribs[i].bindings.borrow().find_copy(&name);\n             match binding_opt {\n                 Some(def_like) => {\n                     return self.upvarify(ribs, i, def_like, span);\n@@ -4095,7 +4070,7 @@ impl<'a> Resolver<'a> {\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: @Pat) -> BindingMap {\n         let mut result = HashMap::new();\n-        pat_bindings(self.def_map, pat, |binding_mode, _id, sp, path| {\n+        pat_bindings(&self.def_map, pat, |binding_mode, _id, sp, path| {\n             let name = mtwt::resolve(path_to_ident(path));\n             result.insert(name,\n                           binding_info {span: sp,\n@@ -4786,22 +4761,17 @@ impl<'a> Resolver<'a> {\n         };\n         match containing_module.kind.get() {\n             TraitModuleKind | ImplModuleKind => {\n-                match self.method_map.borrow().find(&ident.name) {\n-                    Some(s) => {\n-                        match containing_module.def_id.get() {\n-                            Some(def_id) if s.contains(&def_id) => {\n-                                debug!(\"containing module was a trait or impl \\\n-                                        and name was a method -> not resolved\");\n-                                return None;\n-                            },\n-                            _ => (),\n-                        }\n+                match containing_module.def_id.get() {\n+                    Some(def_id) if self.method_set.borrow().contains(&(ident.name, def_id)) => {\n+                        debug!(\"containing module was a trait or impl \\\n+                                and name was a method -> not resolved\");\n+                        return None;\n                     },\n-                    None => (),\n+                    _ => (),\n                 }\n             },\n             _ => (),\n-        };\n+        }\n         return Some(def);\n     }\n \n@@ -4865,12 +4835,12 @@ impl<'a> Resolver<'a> {\n         let search_result = match namespace {\n             ValueNS => {\n                 let renamed = mtwt::resolve(ident);\n-                self.search_ribs(&mut *self.value_ribs.borrow_mut(),\n+                self.search_ribs(self.value_ribs.borrow().as_slice(),\n                                  renamed, span)\n             }\n             TypeNS => {\n                 let name = ident.name;\n-                self.search_ribs(&mut *self.type_ribs.borrow_mut(), name, span)\n+                self.search_ribs(self.type_ribs.borrow().as_slice(), name, span)\n             }\n         };\n \n@@ -4936,7 +4906,7 @@ impl<'a> Resolver<'a> {\n         rs\n     }\n \n-    fn resolve_error(&mut self, span: Span, s: &str) {\n+    fn resolve_error(&self, span: Span, s: &str) {\n         if self.emit_errors {\n             self.session.span_err(span, s);\n         }\n@@ -5115,9 +5085,9 @@ impl<'a> Resolver<'a> {\n             ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n-                let mut label_ribs = self.label_ribs.borrow_mut();\n                 let renamed = mtwt::resolve(label);\n-                match self.search_ribs(&mut *label_ribs, renamed, expr.span) {\n+                match self.search_ribs(self.label_ribs.borrow().as_slice(),\n+                                       renamed, expr.span) {\n                     None =>\n                         self.resolve_error(expr.span,\n                                               format!(\"use of undeclared label `{}`\",\n@@ -5147,14 +5117,14 @@ impl<'a> Resolver<'a> {\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.search_for_traits_containing_method(ident);\n+                let traits = self.search_for_traits_containing_method(ident.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             ExprMethodCall(ident, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording \\\n                         traits for {}\",\n                        expr.id);\n-                let traits = self.search_for_traits_containing_method(ident);\n+                let traits = self.search_for_traits_containing_method(ident.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -5163,33 +5133,43 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn search_for_traits_containing_method(&mut self, name: Ident) -> Vec<DefId> {\n+    fn search_for_traits_containing_method(&mut self, name: Name) -> Vec<DefId> {\n         debug!(\"(searching for traits containing method) looking for '{}'\",\n-               token::get_ident(name));\n+               token::get_name(name));\n+\n+        fn add_trait_info(found_traits: &mut Vec<DefId>,\n+                          trait_def_id: DefId,\n+                          name: Name) {\n+            debug!(\"(adding trait info) found trait {}:{} for method '{}'\",\n+                trait_def_id.krate,\n+                trait_def_id.node,\n+                token::get_name(name));\n+            found_traits.push(trait_def_id);\n+        }\n \n         let mut found_traits = Vec::new();\n         let mut search_module = self.current_module;\n-        match self.method_map.borrow().find(&name.name) {\n-            Some(candidate_traits) => loop {\n-                // Look for the current trait.\n-                match self.current_trait_refs {\n-                    Some(ref trait_def_ids) => {\n-                        for trait_def_id in trait_def_ids.iter() {\n-                            if candidate_traits.contains(trait_def_id) {\n-                                self.add_trait_info(&mut found_traits,\n-                                                    *trait_def_id,\n-                                                    name);\n-                            }\n+        loop {\n+            // Look for the current trait.\n+            match self.current_trait_refs {\n+                Some(ref trait_def_ids) => {\n+                    let method_set = self.method_set.borrow();\n+                    for &trait_def_id in trait_def_ids.iter() {\n+                        if method_set.contains(&(name, trait_def_id)) {\n+                            add_trait_info(&mut found_traits, trait_def_id, name);\n                         }\n                     }\n-                    None => {\n-                        // Nothing to do.\n-                    }\n                 }\n+                None => {\n+                    // Nothing to do.\n+                }\n+            }\n \n-                // Look for trait children.\n-                self.populate_module_if_necessary(search_module);\n+            // Look for trait children.\n+            self.populate_module_if_necessary(search_module);\n \n+            {\n+                let method_set = self.method_set.borrow();\n                 for (_, &child_names) in search_module.children.borrow().iter() {\n                     let def = match child_names.def_for_namespace(TypeNS) {\n                         Some(def) => def,\n@@ -5199,52 +5179,39 @@ impl<'a> Resolver<'a> {\n                         DefTrait(trait_def_id) => trait_def_id,\n                         _ => continue,\n                     };\n-                    if candidate_traits.contains(&trait_def_id) {\n-                        self.add_trait_info(&mut found_traits, trait_def_id,\n-                                            name);\n+                    if method_set.contains(&(name, trait_def_id)) {\n+                        add_trait_info(&mut found_traits, trait_def_id, name);\n                     }\n                 }\n+            }\n \n-                // Look for imports.\n-                let import_resolutions = search_module.import_resolutions\n-                                                      .borrow();\n-                for (_, &import) in import_resolutions.iter() {\n-                    let target = match import.target_for_namespace(TypeNS) {\n-                        None => continue,\n-                        Some(target) => target,\n-                    };\n-                    let did = match target.bindings.def_for_namespace(TypeNS) {\n-                        Some(DefTrait(trait_def_id)) => trait_def_id,\n-                        Some(..) | None => continue,\n-                    };\n-                    if candidate_traits.contains(&did) {\n-                        self.add_trait_info(&mut found_traits, did, name);\n-                        self.used_imports.insert((import.type_id.get(), TypeNS));\n-                    }\n+            // Look for imports.\n+            let import_resolutions = search_module.import_resolutions\n+                                                    .borrow();\n+            for (_, &import) in import_resolutions.iter() {\n+                let target = match import.target_for_namespace(TypeNS) {\n+                    None => continue,\n+                    Some(target) => target,\n+                };\n+                let did = match target.bindings.def_for_namespace(TypeNS) {\n+                    Some(DefTrait(trait_def_id)) => trait_def_id,\n+                    Some(..) | None => continue,\n+                };\n+                if self.method_set.borrow().contains(&(name, did)) {\n+                    add_trait_info(&mut found_traits, did, name);\n+                    self.used_imports.insert((import.type_id.get(), TypeNS));\n                 }\n+            }\n \n-                match search_module.parent_link {\n-                    NoParentLink | ModuleParentLink(..) => break,\n-                    BlockParentLink(parent_module, _) => {\n-                        search_module = parent_module;\n-                    }\n+            match search_module.parent_link {\n+                NoParentLink | ModuleParentLink(..) => break,\n+                BlockParentLink(parent_module, _) => {\n+                    search_module = parent_module;\n                 }\n-            },\n-            _ => ()\n+            }\n         }\n \n-        return found_traits;\n-    }\n-\n-    fn add_trait_info(&self,\n-                          found_traits: &mut Vec<DefId> ,\n-                          trait_def_id: DefId,\n-                          name: Ident) {\n-        debug!(\"(adding trait info) found trait {}:{} for method '{}'\",\n-               trait_def_id.krate,\n-               trait_def_id.node,\n-               token::get_ident(name));\n-        found_traits.push(trait_def_id);\n+        found_traits\n     }\n \n     fn record_def(&mut self, node_id: NodeId, (def, lp): (Def, LastPrivate)) {"}, {"sha": "3a1d6cab018bdaf59e83e5224ce0818a94863492", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -496,7 +496,7 @@ fn expand_nested_bindings<'r,'b>(\n }\n \n fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n-    if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n+    if !pat_is_binding_or_wild(&bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n             format!(\"expected an identifier pattern but found p: {}\",\n@@ -508,7 +508,7 @@ type enter_pat<'a> = |@ast::Pat|: 'a -> Option<Vec<@ast::Pat>>;\n \n fn enter_match<'r,'b>(\n                bcx: &'b Block<'b>,\n-               dm: DefMap,\n+               dm: &DefMap,\n                m: &[Match<'r,'b>],\n                col: uint,\n                val: ValueRef,\n@@ -556,7 +556,7 @@ fn enter_match<'r,'b>(\n \n fn enter_default<'r,'b>(\n                  bcx: &'b Block<'b>,\n-                 dm: DefMap,\n+                 dm: &DefMap,\n                  m: &[Match<'r,'b>],\n                  col: uint,\n                  val: ValueRef,\n@@ -657,10 +657,10 @@ fn enter_opt<'r,'b>(\n     // \"column\" of arm patterns and the algorithm will converge.\n     let guarded = m.iter().any(|x| x.data.arm.guard.is_some());\n     let multi_pats = m.len() > 0 && m[0].pats.len() > 1;\n-    enter_match(bcx, tcx.def_map, m, col, val, |p| {\n+    enter_match(bcx, &tcx.def_map, m, col, val, |p| {\n         let answer = match p.node {\n             ast::PatEnum(..) |\n-            ast::PatIdent(_, _, None) if pat_is_const(tcx.def_map, p) => {\n+            ast::PatIdent(_, _, None) if pat_is_const(&tcx.def_map, p) => {\n                 let const_def = tcx.def_map.borrow().get_copy(&p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n                 let konst = lit(ConstLit(const_def_id));\n@@ -684,7 +684,7 @@ fn enter_opt<'r,'b>(\n                 }\n             }\n             ast::PatIdent(_, _, None)\n-                    if pat_is_variant_or_struct(tcx.def_map, p) => {\n+                    if pat_is_variant_or_struct(&tcx.def_map, p) => {\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     Some(Vec::new())\n                 } else {\n@@ -801,7 +801,7 @@ fn enter_opt<'r,'b>(\n \n fn enter_rec_or_struct<'r,'b>(\n                        bcx: &'b Block<'b>,\n-                       dm: DefMap,\n+                       dm: &DefMap,\n                        m: &[Match<'r,'b>],\n                        col: uint,\n                        fields: &[ast::Ident],\n@@ -837,7 +837,7 @@ fn enter_rec_or_struct<'r,'b>(\n \n fn enter_tup<'r,'b>(\n              bcx: &'b Block<'b>,\n-             dm: DefMap,\n+             dm: &DefMap,\n              m: &[Match<'r,'b>],\n              col: uint,\n              val: ValueRef,\n@@ -870,7 +870,7 @@ fn enter_tup<'r,'b>(\n \n fn enter_tuple_struct<'r,'b>(\n                       bcx: &'b Block<'b>,\n-                      dm: DefMap,\n+                      dm: &DefMap,\n                       m: &[Match<'r,'b>],\n                       col: uint,\n                       val: ValueRef,\n@@ -899,7 +899,7 @@ fn enter_tuple_struct<'r,'b>(\n \n fn enter_uniq<'r,'b>(\n               bcx: &'b Block<'b>,\n-              dm: DefMap,\n+              dm: &DefMap,\n               m: &[Match<'r,'b>],\n               col: uint,\n               val: ValueRef)\n@@ -928,7 +928,7 @@ fn enter_uniq<'r,'b>(\n fn enter_region<'r,\n                 'b>(\n                 bcx: &'b Block<'b>,\n-                dm: DefMap,\n+                dm: &DefMap,\n                 m: &[Match<'r,'b>],\n                 col: uint,\n                 val: ValueRef)\n@@ -1170,7 +1170,7 @@ fn pats_require_rooting(bcx: &Block, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n         let pat_id = br.pats.get(col).id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n-        bcx.ccx().maps.root_map.borrow().contains_key(&key)\n+        bcx.ccx().maps.root_map.contains_key(&key)\n     })\n }\n \n@@ -1551,7 +1551,7 @@ fn compile_submatch_continue<'r,\n                              val: ValueRef) {\n     let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n-    let dm = tcx.def_map;\n+    let dm = &tcx.def_map;\n \n     let vals_left = Vec::from_slice(vals.slice(0u, col)).append(vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n@@ -1885,7 +1885,7 @@ fn create_bindings_map(bcx: &Block, pat: @ast::Pat) -> BindingsMap {\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n     let mut bindings_map = HashMap::new();\n-    pat_bindings(tcx.def_map, pat, |bm, p_id, span, path| {\n+    pat_bindings(&tcx.def_map, pat, |bm, p_id, span, path| {\n         let ident = path_to_ident(path);\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n@@ -2066,7 +2066,7 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n-        pat_bindings(tcx.def_map, pat, |_, p_id, _, path| {\n+        pat_bindings(&tcx.def_map, pat, |_, p_id, _, path| {\n                 let scope = cleanup::var_scope(tcx, p_id);\n                 bcx = mk_binding_alloca(\n                     bcx, p_id, path, BindLocal, scope, (),\n@@ -2199,7 +2199,7 @@ fn bind_irrefutable_pat<'a>(\n     let ccx = bcx.ccx();\n     match pat.node {\n         ast::PatIdent(pat_binding_mode, ref path, inner) => {\n-            if pat_is_binding(tcx.def_map, pat) {\n+            if pat_is_binding(&tcx.def_map, pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n                 // map."}, {"sha": "9d995ca5ef75de595fcef056bfe4d6640fe723be", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -2056,17 +2056,13 @@ pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n \n pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeInlinedItem<'r>)\n     -> encoder::EncodeParams<'r> {\n-\n-        let diag = cx.sess().diagnostic();\n-        let item_symbols = &cx.item_symbols;\n-        let link_meta = &cx.link_meta;\n         encoder::EncodeParams {\n-            diag: diag,\n+            diag: cx.sess().diagnostic(),\n             tcx: cx.tcx(),\n-            reexports2: cx.exp_map2,\n-            item_symbols: item_symbols,\n+            reexports2: &cx.exp_map2,\n+            item_symbols: &cx.item_symbols,\n             non_inlineable_statics: &cx.non_inlineable_statics,\n-            link_meta: link_meta,\n+            link_meta: &cx.link_meta,\n             cstore: &cx.sess().cstore,\n             encode_inlined_item: ie,\n         }"}, {"sha": "35fef4627357c60531975d3cc50ee48b34a60299", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -369,7 +369,7 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n     }\n \n     let cx = bcx.ccx();\n-    let def_map = cx.tcx.def_map;\n+    let def_map = &cx.tcx.def_map;\n \n     pat_util::pat_bindings(def_map, local.pat, |_, node_id, span, path_ref| {\n         let var_ident = ast_util::path_to_ident(path_ref);\n@@ -509,7 +509,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n     let fcx = bcx.fcx;\n     let cx = fcx.ccx;\n \n-    let def_map = cx.tcx.def_map;\n+    let def_map = &cx.tcx.def_map;\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     pat_util::pat_bindings(def_map, arg.pat, |_, node_id, span, path_ref| {\n@@ -2381,7 +2381,7 @@ fn populate_scope_map(cx: &CrateContext,\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n-    let def_map = cx.tcx.def_map;\n+    let def_map = &cx.tcx.def_map;\n \n     struct ScopeStackEntry {\n         scope_metadata: DIScope,\n@@ -2494,7 +2494,7 @@ fn populate_scope_map(cx: &CrateContext,\n                     scope_stack: &mut Vec<ScopeStackEntry> ,\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n-        let def_map = cx.tcx.def_map;\n+        let def_map = &cx.tcx.def_map;\n \n         // Unfortunately, we cannot just use pat_util::pat_bindings() or ast_util::walk_pat() here\n         // because we have to visit *all* nodes in order to put them into the scope map. The above"}, {"sha": "8f114827bfd27223099eb18fcb41bd2d6a1bd9ab", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -34,7 +34,7 @@ pub fn root_and_write_guard<'a, K:KindOps>(datum: &Datum<K>,\n     //\n     // (Note: root'd values are always boxes)\n     let ccx = bcx.ccx();\n-    match ccx.maps.root_map.borrow().find(&key) {\n+    match ccx.maps.root_map.find(&key) {\n         None => bcx,\n         Some(&root_info) => root(datum, bcx, span, key, root_info)\n     }"}, {"sha": "ced81b8e67129e5f6027d27e88a212cee39c6302", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -320,12 +320,12 @@ pub struct ctxt {\n     pub destructors: RefCell<DefIdSet>,\n \n     // Maps a trait onto a list of impls of that trait.\n-    pub trait_impls: RefCell<DefIdMap<@RefCell<Vec<@Impl> >>>,\n+    pub trait_impls: RefCell<DefIdMap<@RefCell<Vec<@Impl>>>>,\n \n     // Maps a def_id of a type to a list of its inherent impls.\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    pub inherent_impls: RefCell<DefIdMap<@RefCell<Vec<@Impl> >>>,\n+    pub inherent_impls: RefCell<DefIdMap<@RefCell<Vec<@Impl>>>>,\n \n     // Maps a def_id of an impl to an Impl structure.\n     // Note that this contains all of the impls that we know about,\n@@ -4386,22 +4386,17 @@ pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> @ItemVariances {\n }\n \n /// Records a trait-to-implementation mapping.\n-fn record_trait_implementation(tcx: &ctxt,\n-                               trait_def_id: DefId,\n-                               implementation: @Impl) {\n-    let implementation_list;\n-    let mut trait_impls = tcx.trait_impls.borrow_mut();\n-    match trait_impls.find(&trait_def_id) {\n-        None => {\n-            implementation_list = @RefCell::new(Vec::new());\n-            trait_impls.insert(trait_def_id, implementation_list);\n-        }\n-        Some(&existing_implementation_list) => {\n-            implementation_list = existing_implementation_list\n+pub fn record_trait_implementation(tcx: &ctxt,\n+                                   trait_def_id: DefId,\n+                                   implementation: @Impl) {\n+    match tcx.trait_impls.borrow().find(&trait_def_id) {\n+        Some(impls_for_trait) => {\n+            impls_for_trait.borrow_mut().push(implementation);\n+            return;\n         }\n+        None => {}\n     }\n-\n-    implementation_list.borrow_mut().push(implementation);\n+    tcx.trait_impls.borrow_mut().insert(trait_def_id, @RefCell::new(vec!(implementation)));\n }\n \n /// Populates the type context with all the implementations for the given type\n@@ -4437,24 +4432,20 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n             }\n         }\n \n+        // Store the implementation info.\n+        tcx.impls.borrow_mut().insert(implementation_def_id, implementation);\n+\n         // If this is an inherent implementation, record it.\n         if associated_traits.is_none() {\n-            let implementation_list;\n-            let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n-            match inherent_impls.find(&type_id) {\n-                None => {\n-                    implementation_list = @RefCell::new(Vec::new());\n-                    inherent_impls.insert(type_id, implementation_list);\n-                }\n-                Some(&existing_implementation_list) => {\n-                    implementation_list = existing_implementation_list;\n+            match tcx.inherent_impls.borrow().find(&type_id) {\n+                Some(implementation_list) => {\n+                    implementation_list.borrow_mut().push(implementation);\n+                    return;\n                 }\n+                None => {}\n             }\n-            implementation_list.borrow_mut().push(implementation);\n+            tcx.inherent_impls.borrow_mut().insert(type_id, @RefCell::new(vec!(implementation)));\n         }\n-\n-        // Store the implementation info.\n-        tcx.impls.borrow_mut().insert(implementation_def_id, implementation);\n     });\n \n     tcx.populated_external_types.borrow_mut().insert(type_id);"}, {"sha": "9ceb3132509019fd27b06dd3cc6abcc8b56b0918", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -40,7 +40,7 @@ pub fn check_match(fcx: &FnCtxt,\n     for arm in arms.iter() {\n         let mut pcx = pat_ctxt {\n             fcx: fcx,\n-            map: pat_id_map(tcx.def_map, *arm.pats.get(0)),\n+            map: pat_id_map(&tcx.def_map, *arm.pats.get(0)),\n         };\n \n         for p in arm.pats.iter() { check_pat(&mut pcx, *p, discrim_ty);}\n@@ -467,14 +467,14 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         fcx.write_ty(pat.id, b_ty);\n       }\n       ast::PatEnum(..) |\n-      ast::PatIdent(..) if pat_is_const(tcx.def_map, pat) => {\n+      ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n         let const_did = ast_util::def_id_of_def(tcx.def_map.borrow()\n                                                    .get_copy(&pat.id));\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);\n       }\n-      ast::PatIdent(bm, ref name, sub) if pat_is_binding(tcx.def_map, pat) => {\n+      ast::PatIdent(bm, ref name, sub) if pat_is_binding(&tcx.def_map, pat) => {\n         let typ = fcx.local_ty(pat.span, pat.id);\n \n         match bm {"}, {"sha": "57f6eb72516a2fc5faf245e00fff70ae717a5b7e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -155,7 +155,7 @@ pub mod method;\n /// share the inherited fields.\n pub struct Inherited<'a> {\n     infcx: infer::InferCtxt<'a>,\n-    locals: @RefCell<NodeMap<ty::t>>,\n+    locals: RefCell<NodeMap<ty::t>>,\n     param_env: ty::ParameterEnvironment,\n \n     // Temporary tables:\n@@ -260,7 +260,7 @@ impl<'a> Inherited<'a> {\n            -> Inherited<'a> {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n-            locals: @RefCell::new(NodeMap::new()),\n+            locals: RefCell::new(NodeMap::new()),\n             param_env: param_env,\n             node_types: RefCell::new(NodeMap::new()),\n             node_type_substs: RefCell::new(NodeMap::new()),\n@@ -387,7 +387,7 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n     fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n             match p.node {\n               ast::PatIdent(_, ref path, _)\n-                  if pat_util::pat_is_binding(self.fcx.ccx.tcx.def_map, p) => {\n+                  if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) => {\n                 self.assign(p.id, None);\n                 debug!(\"Pattern binding {} is assigned to {}\",\n                        token::get_ident(path.segments.get(0).identifier),\n@@ -469,7 +469,7 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n-            pat_util::pat_bindings(tcx.def_map,\n+            pat_util::pat_bindings(&tcx.def_map,\n                                    input.pat,\n                                    |_bm, pat_id, _sp, _path| {\n                                        visit.assign(pat_id, None);\n@@ -478,7 +478,7 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n             // Check the pattern.\n             let pcx = pat_ctxt {\n                 fcx: &fcx,\n-                map: pat_id_map(tcx.def_map, input.pat),\n+                map: pat_id_map(&tcx.def_map, input.pat),\n             };\n             _match::check_pat(&pcx, input.pat, *arg_ty);\n         }\n@@ -3266,7 +3266,7 @@ pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n \n     let pcx = pat_ctxt {\n         fcx: fcx,\n-        map: pat_id_map(tcx.def_map, local.pat),\n+        map: pat_id_map(&tcx.def_map, local.pat),\n     };\n     _match::check_pat(&pcx, local.pat, t);\n     let pat_ty = fcx.node_ty(local.pat.id);"}, {"sha": "abbd5b81660136583529011dcc2bf622dcb25cc1", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -361,7 +361,7 @@ fn visit_local(rcx: &mut Rcx, l: &ast::Local) {\n fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n     debug!(\"regionck::visit_pat(pat={})\", pat.repr(tcx));\n-    pat_util::pat_bindings(tcx.def_map, pat, |_, id, span, _| {\n+    pat_util::pat_bindings(&tcx.def_map, pat, |_, id, span, _| {\n         // If we have a variable that contains region'd data, that\n         // data will be accessible from anywhere that the variable is\n         // accessed. We must be wary of loops like this:"}, {"sha": "1ab4578f6ce7f4d2ca03c98b178bdfb3f2dc2112", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -28,7 +28,6 @@ use util::ppaux;\n use util::ppaux::Repr;\n \n use collections::HashSet;\n-use std::cell::RefCell;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -319,10 +318,12 @@ fn search_for_vtable(vcx: &VtableContext,\n     ty::populate_implementations_for_trait_if_necessary(tcx,\n                                                         trait_ref.def_id);\n \n-    // FIXME: this is a bad way to do this, since we do\n-    // pointless allocations.\n-    let impls = tcx.trait_impls.borrow().find(&trait_ref.def_id)\n-                               .map_or(@RefCell::new(Vec::new()), |x| *x);\n+    let impls = match tcx.trait_impls.borrow().find_copy(&trait_ref.def_id) {\n+        Some(impls) => impls,\n+        None => {\n+            return None;\n+        }\n+    };\n     // impls is the list of all impls in scope for trait_ref.\n     for im in impls.borrow().iter() {\n         // im is one specific impl of trait_ref."}, {"sha": "3843c38fd180029ca63ecdbc24b5a89ad1589386", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -380,7 +380,7 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt, decl: &ast::FnDecl,\n     for arg in decl.inputs.iter() {\n         wbcx.visit_pat(arg.pat, ());\n         // Privacy needs the type for the whole pattern, not just each binding\n-        if !pat_util::pat_is_binding(fcx.tcx().def_map, arg.pat) {\n+        if !pat_util::pat_is_binding(&fcx.tcx().def_map, arg.pat) {\n             resolve_type_vars_for_node(wbcx, arg.pat.span, arg.pat.id);\n         }\n     }"}, {"sha": "df79a448030359b88baf17d26cb217754a4f4ad1", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 15, "deletions": 35, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -366,40 +366,23 @@ impl<'a> CoherenceChecker<'a> {\n         }\n     }\n \n-    fn add_inherent_impl(&self, base_def_id: DefId,\n-                         implementation: @Impl) {\n+    fn add_inherent_impl(&self, base_def_id: DefId, implementation: @Impl) {\n         let tcx = self.crate_context.tcx;\n-        let implementation_list;\n-        let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n-        match inherent_impls.find(&base_def_id) {\n-            None => {\n-                implementation_list = @RefCell::new(Vec::new());\n-                inherent_impls.insert(base_def_id, implementation_list);\n-            }\n-            Some(&existing_implementation_list) => {\n-                implementation_list = existing_implementation_list;\n+        match tcx.inherent_impls.borrow().find(&base_def_id) {\n+            Some(implementation_list) => {\n+                implementation_list.borrow_mut().push(implementation);\n+                return;\n             }\n+            None => {}\n         }\n \n-        implementation_list.borrow_mut().push(implementation);\n+        tcx.inherent_impls.borrow_mut().insert(base_def_id, @RefCell::new(vec!(implementation)));\n     }\n \n-    fn add_trait_impl(&self, base_def_id: DefId,\n-                      implementation: @Impl) {\n-        let tcx = self.crate_context.tcx;\n-        let implementation_list;\n-        let mut trait_impls = tcx.trait_impls.borrow_mut();\n-        match trait_impls.find(&base_def_id) {\n-            None => {\n-                implementation_list = @RefCell::new(Vec::new());\n-                trait_impls.insert(base_def_id, implementation_list);\n-            }\n-            Some(&existing_implementation_list) => {\n-                implementation_list = existing_implementation_list;\n-            }\n-        }\n-\n-        implementation_list.borrow_mut().push(implementation);\n+    fn add_trait_impl(&self, base_def_id: DefId, implementation: @Impl) {\n+        ty::record_trait_implementation(self.crate_context.tcx,\n+                                        base_def_id,\n+                                        implementation);\n     }\n \n     fn check_implementation_coherence(&self) {\n@@ -538,7 +521,7 @@ impl<'a> CoherenceChecker<'a> {\n     }\n \n     fn trait_ref_to_trait_def_id(&self, trait_ref: &TraitRef) -> DefId {\n-        let def_map = self.crate_context.tcx.def_map;\n+        let def_map = &self.crate_context.tcx.def_map;\n         let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n         return trait_id;\n@@ -680,13 +663,10 @@ impl<'a> CoherenceChecker<'a> {\n             Some(id) => id, None => { return }\n         };\n \n-        let trait_impls = tcx.trait_impls.borrow();\n-        let impls_opt = trait_impls.find(&drop_trait);\n-        let impls;\n-        match impls_opt {\n+        let impls = match tcx.trait_impls.borrow().find_copy(&drop_trait) {\n             None => return, // No types with (new-style) dtors present.\n-            Some(found_impls) => impls = found_impls\n-        }\n+            Some(found_impls) => found_impls\n+        };\n \n         for impl_info in impls.borrow().iter() {\n             if impl_info.methods.len() < 1 {"}, {"sha": "7d7d5d16d74f40f36d6d709dd3a6e89143ad9fe3", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -16,12 +16,13 @@ use std::io;\n use syntax::ast;\n \n pub type FnvHashMap<K, V> = HashMap<K, V, FnvHasher>;\n+pub type FnvHashSet<V> = HashSet<V, FnvHasher>;\n \n pub type NodeMap<T> = FnvHashMap<ast::NodeId, T>;\n pub type DefIdMap<T> = FnvHashMap<ast::DefId, T>;\n \n-pub type NodeSet = HashSet<ast::NodeId, FnvHasher>;\n-pub type DefIdSet = HashSet<ast::DefId, FnvHasher>;\n+pub type NodeSet = FnvHashSet<ast::NodeId>;\n+pub type DefIdSet = FnvHashSet<ast::DefId>;\n \n // Hacks to get good names\n pub mod FnvHashMap {\n@@ -31,6 +32,13 @@ pub mod FnvHashMap {\n         HashMap::with_hasher(super::FnvHasher)\n     }\n }\n+pub mod FnvHashSet {\n+    use std::hash::Hash;\n+    use collections::HashSet;\n+    pub fn new<V: Hash<super::FnvState> + TotalEq>() -> super::FnvHashSet<V> {\n+        HashSet::with_hasher(super::FnvHasher)\n+    }\n+}\n pub mod NodeMap {\n     pub fn new<T>() -> super::NodeMap<T> {\n         super::FnvHashMap::new()\n@@ -42,15 +50,13 @@ pub mod DefIdMap {\n     }\n }\n pub mod NodeSet {\n-    use collections::HashSet;\n     pub fn new() -> super::NodeSet {\n-        HashSet::with_hasher(super::FnvHasher)\n+        super::FnvHashSet::new()\n     }\n }\n pub mod DefIdSet {\n-    use collections::HashSet;\n     pub fn new() -> super::DefIdSet {\n-        HashSet::with_hasher(super::FnvHasher)\n+        super::FnvHashSet::new()\n     }\n }\n "}, {"sha": "3038dc8259fa28e28897538b39939e829f1370f5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1350fbdb24a06bd389cf1617ad5b78289a0c2354/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1350fbdb24a06bd389cf1617ad5b78289a0c2354", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n \n-use metadata::encoder;\n use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{BrFresh, ctxt};\n@@ -469,7 +468,7 @@ pub fn parameterized(cx: &ctxt,\n }\n \n pub fn ty_to_short_str(cx: &ctxt, typ: t) -> ~str {\n-    let mut s = encoder::encoded_ty(cx, typ);\n+    let mut s = typ.repr(cx);\n     if s.len() >= 32u { s = s.slice(0u, 32u).to_owned(); }\n     return s;\n }"}]}