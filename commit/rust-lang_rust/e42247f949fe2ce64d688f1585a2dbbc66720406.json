{"sha": "e42247f949fe2ce64d688f1585a2dbbc66720406", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MjI0N2Y5NDlmZTJjZTY0ZDY4OGYxNTg1YTJkYmJjNjY3MjA0MDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-20T03:41:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-20T03:41:00Z"}, "message": "Auto merge of #56219 - arielb1:never-coerce-box, r=nikomatsakis\n\ntrigger unsized coercions keyed on Sized bounds\n\nThis PR causes unsized coercions to not be disabled by `$0: Unsize<dyn\nObject>` coercion obligations when we have an `$0: Sized` obligation somewhere.\n\nThis should be mostly backwards-compatible, because in these cases not doing the unsize coercion should have caused the `$0: Sized` obligation to fail.\n\nNote that `X: Unsize<dyn Object>` obligations can't fail *as obligations* if `X: Sized` holds, so this still maintains some version of monotonicity (I think that an unsized coercion can't be converted to no coercion by unifying type variables).\n\nFixes #49593 (unblocking never_type).\n\nr? @eddyb\ncc @nikomatsakis", "tree": {"sha": "ca530927acecbfb5add391ee6ed3221e2615c387", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca530927acecbfb5add391ee6ed3221e2615c387"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e42247f949fe2ce64d688f1585a2dbbc66720406", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e42247f949fe2ce64d688f1585a2dbbc66720406", "html_url": "https://github.com/rust-lang/rust/commit/e42247f949fe2ce64d688f1585a2dbbc66720406", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e42247f949fe2ce64d688f1585a2dbbc66720406/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/daa8792f17ad5484ec1e3b0b1e2557f8603219d0", "html_url": "https://github.com/rust-lang/rust/commit/daa8792f17ad5484ec1e3b0b1e2557f8603219d0"}, {"sha": "5b7443810794aa9f771ea26a5e72ae2b567481b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b7443810794aa9f771ea26a5e72ae2b567481b0", "html_url": "https://github.com/rust-lang/rust/commit/5b7443810794aa9f771ea26a5e72ae2b567481b0"}], "stats": {"total": 237, "additions": 172, "deletions": 65}, "files": [{"sha": "7ce59b1d9d765e59c0f8c99844731e9f7cf4339a", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e42247f949fe2ce64d688f1585a2dbbc66720406/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42247f949fe2ce64d688f1585a2dbbc66720406/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=e42247f949fe2ce64d688f1585a2dbbc66720406", "patch": "@@ -1275,6 +1275,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.inlined_shallow_resolve(typ)\n     }\n \n+    pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n+        self.type_variables.borrow_mut().root_var(var)\n+    }\n+\n     pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,"}, {"sha": "f599a2b2ece07aebd033467cff132c03671cab2b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e42247f949fe2ce64d688f1585a2dbbc66720406/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42247f949fe2ce64d688f1585a2dbbc66720406/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e42247f949fe2ce64d688f1585a2dbbc66720406", "patch": "@@ -20,7 +20,7 @@ use rustc::infer::LateBoundRegionConversionTime;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::Obligation;\n use rustc::traits::error_reporting::ArgKind;\n-use rustc::ty::{self, ToPolyTraitRef, Ty, GenericParamDefKind};\n+use rustc::ty::{self, Ty, GenericParamDefKind};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use std::cmp;\n@@ -219,13 +219,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         expected_vid: ty::TyVid,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n-        let fulfillment_cx = self.fulfillment_cx.borrow();\n-        // Here `expected_ty` is known to be a type inference variable.\n-\n-        let expected_sig = fulfillment_cx\n-            .pending_obligations()\n-            .iter()\n-            .filter_map(|obligation| {\n+        let expected_sig = self.obligations_for_self_ty(expected_vid)\n+            .find_map(|(_, obligation)| {\n                 debug!(\n                     \"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n                     obligation.predicate\n@@ -234,52 +229,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let ty::Predicate::Projection(ref proj_predicate) = obligation.predicate {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n-                    let trait_ref = proj_predicate.to_poly_trait_ref(self.tcx);\n-                    self.self_type_matches_expected_vid(trait_ref, expected_vid)\n-                        .and_then(|_| {\n-                            self.deduce_sig_from_projection(\n-                                Some(obligation.cause.span),\n-                                proj_predicate\n-                            )\n-                        })\n+                    self.deduce_sig_from_projection(\n+                        Some(obligation.cause.span),\n+                        proj_predicate\n+                    )\n                 } else {\n                     None\n                 }\n-            })\n-            .next();\n+            });\n \n         // Even if we can't infer the full signature, we may be able to\n         // infer the kind. This can occur if there is a trait-reference\n         // like `F : Fn<A>`. Note that due to subtyping we could encounter\n         // many viable options, so pick the most restrictive.\n-        let expected_kind = fulfillment_cx\n-            .pending_obligations()\n-            .iter()\n-            .filter_map(|obligation| {\n-                let opt_trait_ref = match obligation.predicate {\n-                    ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref(self.tcx)),\n-                    ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n-                    ty::Predicate::Subtype(..) => None,\n-                    ty::Predicate::RegionOutlives(..) => None,\n-                    ty::Predicate::TypeOutlives(..) => None,\n-                    ty::Predicate::WellFormed(..) => None,\n-                    ty::Predicate::ObjectSafe(..) => None,\n-                    ty::Predicate::ConstEvaluatable(..) => None,\n-\n-                    // N.B., this predicate is created by breaking down a\n-                    // `ClosureType: FnFoo()` predicate, where\n-                    // `ClosureType` represents some `Closure`. It can't\n-                    // possibly be referring to the current closure,\n-                    // because we haven't produced the `Closure` for\n-                    // this closure yet; this is exactly why the other\n-                    // code is looking for a self type of a unresolved\n-                    // inference variable.\n-                    ty::Predicate::ClosureKind(..) => None,\n-                };\n-                opt_trait_ref\n-                    .and_then(|tr| self.self_type_matches_expected_vid(tr, expected_vid))\n-                    .and_then(|tr| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n-            })\n+        let expected_kind = self.obligations_for_self_ty(expected_vid)\n+            .filter_map(|(tr, _)| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n             .fold(None, |best, cur| {\n                 Some(best.map_or(cur, |best| cmp::min(best, cur)))\n             });\n@@ -339,22 +303,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Some(ExpectedSig { cause_span, sig })\n     }\n \n-    fn self_type_matches_expected_vid(\n-        &self,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-        expected_vid: ty::TyVid,\n-    ) -> Option<ty::PolyTraitRef<'tcx>> {\n-        let self_ty = self.shallow_resolve(trait_ref.self_ty());\n-        debug!(\n-            \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n-            trait_ref, self_ty\n-        );\n-        match self_ty.sty {\n-            ty::Infer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n-            _ => None,\n-        }\n-    }\n-\n     fn sig_of_closure(\n         &self,\n         expr_def_id: DefId,"}, {"sha": "9a1f9784192c188711d7ec824c781c57b9c8e3e0", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e42247f949fe2ce64d688f1585a2dbbc66720406/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42247f949fe2ce64d688f1585a2dbbc66720406/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e42247f949fe2ce64d688f1585a2dbbc66720406", "patch": "@@ -579,7 +579,33 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             };\n             match selcx.select(&obligation.with(trait_ref)) {\n                 // Uncertain or unimplemented.\n-                Ok(None) |\n+                Ok(None) => {\n+                    if trait_ref.def_id() == unsize_did {\n+                        let trait_ref = self.resolve_type_vars_if_possible(&trait_ref);\n+                        let self_ty = trait_ref.skip_binder().self_ty();\n+                        let unsize_ty = trait_ref.skip_binder().input_types().nth(1).unwrap();\n+                        debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_ref);\n+                        match (&self_ty.sty, &unsize_ty.sty) {\n+                            (ty::Infer(ty::TyVar(v)),\n+                             ty::Dynamic(..)) if self.type_var_is_sized(*v) => {\n+                                debug!(\"coerce_unsized: have sized infer {:?}\", v);\n+                                coercion.obligations.push(obligation);\n+                                // `$0: Unsize<dyn Trait>` where we know that `$0: Sized`, try going\n+                                // for unsizing.\n+                            }\n+                            _ => {\n+                                // Some other case for `$0: Unsize<Something>`. Note that we\n+                                // hit this case even if `Something` is a sized type, so just\n+                                // don't do the coercion.\n+                                debug!(\"coerce_unsized: ambiguous unsize\");\n+                                return Err(TypeError::Mismatch);\n+                            }\n+                        }\n+                    } else {\n+                        debug!(\"coerce_unsized: early return - ambiguous\");\n+                        return Err(TypeError::Mismatch);\n+                    }\n+                }\n                 Err(traits::Unimplemented) => {\n                     debug!(\"coerce_unsized: early return - can't prove obligation\");\n                     return Err(TypeError::Mismatch);"}, {"sha": "d45f8fd6de8d9826416516063d2b4fb7befdfabc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 69, "deletions": 2, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e42247f949fe2ce64d688f1585a2dbbc66720406/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42247f949fe2ce64d688f1585a2dbbc66720406/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e42247f949fe2ce64d688f1585a2dbbc66720406", "patch": "@@ -114,8 +114,8 @@ use rustc::mir::interpret::{ConstValue, GlobalId};\n use rustc::ty::subst::{CanonicalUserSubsts, UnpackedKind, Subst, Substs,\n                        UserSelfTy, UserSubsts};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt, GenericParamDefKind, Visibility, ToPredicate,\n-                RegionKind};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt, GenericParamDefKind, RegionKind, Visibility,\n+                ToPolyTraitRef, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n@@ -143,6 +143,7 @@ use require_c_abi_if_variadic;\n use session::{CompileIncomplete, config, Session};\n use TypeAndSubsts;\n use lint;\n+use util::captures::Captures;\n use util::common::{ErrorReported, indenter};\n use util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, NodeMap};\n \n@@ -2732,6 +2733,72 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         method.sig.output()\n     }\n \n+    fn self_type_matches_expected_vid(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        expected_vid: ty::TyVid,\n+    ) -> bool {\n+        let self_ty = self.shallow_resolve(trait_ref.self_ty());\n+        debug!(\n+            \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?}, expected_vid={:?})\",\n+            trait_ref, self_ty, expected_vid\n+        );\n+        match self_ty.sty {\n+            ty::Infer(ty::TyVar(found_vid)) => {\n+                // FIXME: consider using `sub_root_var` here so we\n+                // can see through subtyping.\n+                let found_vid = self.root_var(found_vid);\n+                debug!(\"self_type_matches_expected_vid - found_vid={:?}\", found_vid);\n+                expected_vid == found_vid\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    fn obligations_for_self_ty<'b>(&'b self, self_ty: ty::TyVid)\n+        -> impl Iterator<Item=(ty::PolyTraitRef<'tcx>, traits::PredicateObligation<'tcx>)>\n+           + Captures<'gcx> + 'b\n+    {\n+        // FIXME: consider using `sub_root_var` here so we\n+        // can see through subtyping.\n+        let ty_var_root = self.root_var(self_ty);\n+        debug!(\"obligations_for_self_ty: self_ty={:?} ty_var_root={:?} pending_obligations={:?}\",\n+               self_ty, ty_var_root,\n+               self.fulfillment_cx.borrow().pending_obligations());\n+\n+        self.fulfillment_cx\n+            .borrow()\n+            .pending_obligations()\n+            .into_iter()\n+            .filter_map(move |obligation| match obligation.predicate {\n+                ty::Predicate::Projection(ref data) =>\n+                    Some((data.to_poly_trait_ref(self.tcx), obligation)),\n+                ty::Predicate::Trait(ref data) =>\n+                    Some((data.to_poly_trait_ref(), obligation)),\n+                ty::Predicate::Subtype(..) => None,\n+                ty::Predicate::RegionOutlives(..) => None,\n+                ty::Predicate::TypeOutlives(..) => None,\n+                ty::Predicate::WellFormed(..) => None,\n+                ty::Predicate::ObjectSafe(..) => None,\n+                ty::Predicate::ConstEvaluatable(..) => None,\n+                // N.B., this predicate is created by breaking down a\n+                // `ClosureType: FnFoo()` predicate, where\n+                // `ClosureType` represents some `Closure`. It can't\n+                // possibly be referring to the current closure,\n+                // because we haven't produced the `Closure` for\n+                // this closure yet; this is exactly why the other\n+                // code is looking for a self type of a unresolved\n+                // inference variable.\n+                ty::Predicate::ClosureKind(..) => None,\n+            }).filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n+    }\n+\n+    fn type_var_is_sized(&self, self_ty: ty::TyVid) -> bool {\n+        self.obligations_for_self_ty(self_ty).any(|(tr, _)| {\n+            Some(tr.def_id()) == self.tcx.lang_items().sized_trait()\n+        })\n+    }\n+\n     /// Generic function that factors out common logic from function calls,\n     /// method calls and overloaded operators.\n     fn check_argument_types(&self,"}, {"sha": "bea8586452e552877fc6699e9938fae103779d65", "filename": "src/test/ui/coercion/coerce-issue-49593-box-never.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e42247f949fe2ce64d688f1585a2dbbc66720406/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42247f949fe2ce64d688f1585a2dbbc66720406/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs?ref=e42247f949fe2ce64d688f1585a2dbbc66720406", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![feature(never_type)]\n+#![allow(unreachable_code)]\n+\n+use std::error::Error;\n+use std::mem;\n+\n+fn raw_ptr_box<T>(t: T) -> *mut T {\n+    panic!()\n+}\n+\n+fn foo(x: !) -> Box<dyn Error> {\n+    /* *mut $0 is coerced to Box<dyn Error> here */ Box::<_ /* ! */>::new(x)\n+}\n+\n+fn foo_raw_ptr(x: !) -> *mut dyn Error {\n+    /* *mut $0 is coerced to *mut Error here */ raw_ptr_box::<_ /* ! */>(x)\n+}\n+\n+fn no_coercion(d: *mut dyn Error) -> *mut dyn Error {\n+    /* an unsize coercion won't compile here, and it is indeed not used\n+       because there is nothing requiring the _ to be Sized */\n+    d as *mut _\n+}\n+\n+trait Xyz {}\n+struct S;\n+struct T;\n+impl Xyz for S {}\n+impl Xyz for T {}\n+\n+fn foo_no_never() {\n+    let mut x /* : Option<S> */ = None;\n+    let mut first_iter = false;\n+    loop {\n+        if !first_iter {\n+            let y: Box<dyn Xyz>\n+                = /* Box<$0> is coerced to Box<Xyz> here */ Box::new(x.unwrap());\n+        }\n+\n+        x = Some(S);\n+        first_iter = true;\n+    }\n+\n+    let mut y : Option<S> = None;\n+    // assert types are equal\n+    mem::swap(&mut x, &mut y);\n+}\n+\n+fn main() {\n+}"}]}