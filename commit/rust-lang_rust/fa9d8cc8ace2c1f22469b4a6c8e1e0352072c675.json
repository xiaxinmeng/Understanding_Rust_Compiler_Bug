{"sha": "fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhOWQ4Y2M4YWNlMmMxZjIyNDY5YjRhNmM4ZTFlMDM1MjA3MmM2NzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-13T00:15:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-13T00:15:26Z"}, "message": "Auto merge of #35960 - nikomatsakis:incr-comp-krate-edges, r=michaelwoerister\n\nfix a few errant `Krate` edges\n\nExploring the effect of small changes on `syntex` reuse, I discovered the following sources of unnecessary edges from `Krate`\n\nr? @michaelwoerister", "tree": {"sha": "18844ca313be6cd49c67af8a80b1c7ab7b9b3e28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18844ca313be6cd49c67af8a80b1c7ab7b9b3e28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "html_url": "https://github.com/rust-lang/rust/commit/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5531c314a2855aec368e811da6fcd9e98365af51", "url": "https://api.github.com/repos/rust-lang/rust/commits/5531c314a2855aec368e811da6fcd9e98365af51", "html_url": "https://github.com/rust-lang/rust/commit/5531c314a2855aec368e811da6fcd9e98365af51"}, {"sha": "9ca578687b88d2c7817d5709b2700fb6777348f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ca578687b88d2c7817d5709b2700fb6777348f2", "html_url": "https://github.com/rust-lang/rust/commit/9ca578687b88d2c7817d5709b2700fb6777348f2"}], "stats": {"total": 678, "additions": 473, "deletions": 205}, "files": [{"sha": "48f5b7ea2595d70c37eef2066452456661c10d4e", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -341,6 +341,8 @@ path is found (as demonstrated above).\n \n ### Debugging the dependency graph\n \n+#### Dumping the graph\n+\n The compiler is also capable of dumping the dependency graph for your\n debugging pleasure. To do so, pass the `-Z dump-dep-graph` flag. The\n graph will be dumped to `dep_graph.{txt,dot}` in the current\n@@ -392,6 +394,35 @@ This will dump out all the nodes that lead from `Hir(foo)` to\n `TypeckItemBody(bar)`, from which you can (hopefully) see the source\n of the erroneous edge.\n \n+#### Tracking down incorrect edges\n+\n+Sometimes, after you dump the dependency graph, you will find some\n+path that should not exist, but you will not be quite sure how it came\n+to be. **When the compiler is built with debug assertions,** it can\n+help you track that down. Simply set the `RUST_FORBID_DEP_GRAPH_EDGE`\n+environment variable to a filter. Every edge created in the dep-graph\n+will be tested against that filter -- if it matches, a `bug!` is\n+reported, so you can easily see the backtrace (`RUST_BACKTRACE=1`).\n+\n+The syntax for these filters is the same as described in the previous\n+section. However, note that this filter is applied to every **edge**\n+and doesn't handle longer paths in the graph, unlike the previous\n+section.\n+\n+Example:\n+\n+You find that there is a path from the `Hir` of `foo` to the type\n+check of `bar` and you don't think there should be. You dump the\n+dep-graph as described in the previous section and open `dep-graph.txt`\n+to see something like:\n+\n+    Hir(foo) -> Collect(bar)\n+    Collect(bar) -> TypeckItemBody(bar)\n+    \n+That first edge looks suspicious to you. So you set\n+`RUST_FORBID_DEP_GRAPH_EDGE` to `Hir&foo -> Collect&bar`, re-run, and\n+then observe the backtrace. Voila, bug fixed!\n+\n ### Inlining of HIR nodes\n \n For the time being, at least, we still sometimes \"inline\" HIR nodes"}, {"sha": "5b15c5e67174e2d1618495cbc0449b8aaef79591", "filename": "src/librustc/dep_graph/debug.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -66,4 +66,11 @@ impl EdgeFilter {\n             })\n         }\n     }\n+\n+    pub fn test<D: Clone + Debug>(&self,\n+                                  source: &DepNode<D>,\n+                                  target: &DepNode<D>)\n+                                  -> bool {\n+        self.source.test(source) && self.target.test(target)\n+    }\n }"}, {"sha": "51f7890c7a2f4c8e13d31b97e557a26cc0b1c8f3", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -80,6 +80,17 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n     pub fn keys(&self) -> Vec<M::Key> {\n         self.map.keys().cloned().collect()\n     }\n+\n+    /// Append `elem` to the vector stored for `k`, creating a new vector if needed.\n+    /// This is considered a write to `k`.\n+    pub fn push<E: Clone>(&mut self, k: M::Key, elem: E)\n+        where M: DepTrackingMapConfig<Value=Vec<E>>\n+    {\n+        self.write(&k);\n+        self.map.entry(k)\n+                .or_insert(Vec::new())\n+                .push(elem);\n+    }\n }\n \n impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {"}, {"sha": "c42eeead69ec1e9f28224f5cf6f89f78b4bae818", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -46,7 +46,7 @@ impl DepGraph {\n             data: Rc::new(DepGraphData {\n                 thread: DepGraphThreadData::new(enabled),\n                 previous_work_products: RefCell::new(FnvHashMap()),\n-                work_products: RefCell::new(FnvHashMap())\n+                work_products: RefCell::new(FnvHashMap()),\n             })\n         }\n     }"}, {"sha": "9c00e95c17e05f9078405da28e443cc95d026ff1", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -15,6 +15,7 @@ mod edges;\n mod graph;\n mod query;\n mod raii;\n+mod shadow;\n mod thread;\n mod visit;\n "}, {"sha": "e4f572902f9e5dba0c6e3c8d560eedc0466ea119", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -47,3 +47,4 @@ impl<'graph> Drop for IgnoreTask<'graph> {\n         self.data.enqueue(DepMessage::PopIgnore);\n     }\n }\n+"}, {"sha": "72a321425ef063ca826ab410c9e8f9cf26647017", "filename": "src/librustc/dep_graph/shadow.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fshadow.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -0,0 +1,145 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The \"Shadow Graph\" is maintained on the main thread and which\n+//! tracks each message relating to the dep-graph and applies some\n+//! sanity checks as they go by. If an error results, it means you get\n+//! a nice stack-trace telling you precisely what caused the error.\n+//!\n+//! NOTE: This is a debugging facility which can potentially have non-trivial\n+//! runtime impact. Therefore, it is largely compiled out if\n+//! debug-assertions are not enabled.\n+//!\n+//! The basic sanity check, enabled if you have debug assertions\n+//! enabled, is that there is always a task (or ignore) on the stack\n+//! when you do read/write, and that the tasks are pushed/popped\n+//! according to a proper stack discipline.\n+//!\n+//! Optionally, if you specify RUST_FORBID_DEP_GRAPH_EDGE, you can\n+//! specify an edge filter to be applied to each edge as it is\n+//! created.  See `./README.md` for details.\n+\n+use hir::def_id::DefId;\n+use std::cell::{BorrowState, RefCell};\n+use std::env;\n+\n+use super::DepNode;\n+use super::thread::DepMessage;\n+use super::debug::EdgeFilter;\n+\n+pub struct ShadowGraph {\n+    // if you push None onto the stack, that corresponds to an Ignore\n+    stack: RefCell<Vec<Option<DepNode<DefId>>>>,\n+    forbidden_edge: Option<EdgeFilter>,\n+}\n+\n+const ENABLED: bool = cfg!(debug_assertions);\n+\n+impl ShadowGraph {\n+    pub fn new() -> Self {\n+        let forbidden_edge = if !ENABLED {\n+            None\n+        } else {\n+            match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n+                Ok(s) => {\n+                    match EdgeFilter::new(&s) {\n+                        Ok(f) => Some(f),\n+                        Err(err) => bug!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n+                    }\n+                }\n+                Err(_) => None,\n+            }\n+        };\n+\n+        ShadowGraph {\n+            stack: RefCell::new(vec![]),\n+            forbidden_edge: forbidden_edge,\n+        }\n+    }\n+\n+    pub fn enqueue(&self, message: &DepMessage) {\n+        if ENABLED {\n+            match self.stack.borrow_state() {\n+                BorrowState::Unused => {}\n+                _ => {\n+                    // When we apply edge filters, that invokes the\n+                    // Debug trait on DefIds, which in turn reads from\n+                    // various bits of state and creates reads! Ignore\n+                    // those recursive reads.\n+                    return;\n+                }\n+            }\n+\n+            let mut stack = self.stack.borrow_mut();\n+            match *message {\n+                DepMessage::Read(ref n) => self.check_edge(Some(Some(n)), top(&stack)),\n+                DepMessage::Write(ref n) => self.check_edge(top(&stack), Some(Some(n))),\n+                DepMessage::PushTask(ref n) => stack.push(Some(n.clone())),\n+                DepMessage::PushIgnore => stack.push(None),\n+                DepMessage::PopTask(ref n) => {\n+                    match stack.pop() {\n+                        Some(Some(m)) => {\n+                            if *n != m {\n+                                bug!(\"stack mismatch: found {:?} expected {:?}\", m, n)\n+                            }\n+                        }\n+                        Some(None) => bug!(\"stack mismatch: found Ignore expected {:?}\", n),\n+                        None => bug!(\"stack mismatch: found empty stack, expected {:?}\", n),\n+                    }\n+                }\n+                DepMessage::PopIgnore => {\n+                    match stack.pop() {\n+                        Some(Some(m)) => bug!(\"stack mismatch: found {:?} expected ignore\", m),\n+                        Some(None) => (),\n+                        None => bug!(\"stack mismatch: found empty stack, expected ignore\"),\n+                    }\n+                }\n+                DepMessage::Query => (),\n+            }\n+        }\n+    }\n+\n+    fn check_edge(&self,\n+                  source: Option<Option<&DepNode<DefId>>>,\n+                  target: Option<Option<&DepNode<DefId>>>) {\n+        assert!(ENABLED);\n+        match (source, target) {\n+            // cannot happen, one side is always Some(Some(_))\n+            (None, None) => unreachable!(),\n+\n+            // nothing on top of the stack\n+            (None, Some(n)) | (Some(n), None) => bug!(\"read/write of {:?} but no current task\", n),\n+\n+            // this corresponds to an Ignore being top of the stack\n+            (Some(None), _) | (_, Some(None)) => (),\n+\n+            // a task is on top of the stack\n+            (Some(Some(source)), Some(Some(target))) => {\n+                if let Some(ref forbidden_edge) = self.forbidden_edge {\n+                    if forbidden_edge.test(source, target) {\n+                        bug!(\"forbidden edge {:?} -> {:?} created\", source, target)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Do a little juggling: we get back a reference to an option at the\n+// top of the stack, convert it to an optional reference.\n+fn top<'s>(stack: &'s Vec<Option<DepNode<DefId>>>) -> Option<Option<&'s DepNode<DefId>>> {\n+    stack.last()\n+        .map(|n: &'s Option<DepNode<DefId>>| -> Option<&'s DepNode<DefId>> {\n+            // (*)\n+            // (*) type annotation just there to clarify what would\n+            // otherwise be some *really* obscure code\n+            n.as_ref()\n+        })\n+}"}, {"sha": "90c42d66b7adfea37a5a24548838683fa2b3f935", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -20,13 +20,13 @@\n \n use hir::def_id::DefId;\n use rustc_data_structures::veccell::VecCell;\n-use std::cell::Cell;\n use std::sync::mpsc::{self, Sender, Receiver};\n use std::thread;\n \n use super::DepGraphQuery;\n use super::DepNode;\n use super::edges::DepGraphEdges;\n+use super::shadow::ShadowGraph;\n \n #[derive(Debug)]\n pub enum DepMessage {\n@@ -42,12 +42,16 @@ pub enum DepMessage {\n pub struct DepGraphThreadData {\n     enabled: bool,\n \n-    // Local counter that just tracks how many tasks are pushed onto the\n-    // stack, so that we still get an error in the case where one is\n-    // missing. If dep-graph construction is enabled, we'd get the same\n-    // error when processing tasks later on, but that's annoying because\n-    // it lacks precision about the source of the error.\n-    tasks_pushed: Cell<usize>,\n+    // The \"shadow graph\" is a debugging aid. We give it each message\n+    // in real time as it arrives and it checks for various errors\n+    // (for example, a read/write when there is no current task; it\n+    // can also apply user-defined filters; see `shadow` module for\n+    // details). This only occurs if debug-assertions are enabled.\n+    //\n+    // Note that in some cases the same errors will occur when the\n+    // data is processed off the main thread, but that's annoying\n+    // because it lacks precision about the source of the error.\n+    shadow_graph: ShadowGraph,\n \n     // current buffer, where we accumulate messages\n     messages: VecCell<DepMessage>,\n@@ -76,7 +80,7 @@ impl DepGraphThreadData {\n \n         DepGraphThreadData {\n             enabled: enabled,\n-            tasks_pushed: Cell::new(0),\n+            shadow_graph: ShadowGraph::new(),\n             messages: VecCell::with_capacity(INITIAL_CAPACITY),\n             swap_in: rx2,\n             swap_out: tx1,\n@@ -118,21 +122,7 @@ impl DepGraphThreadData {\n     /// the buffer is full, this may swap.)\n     #[inline]\n     pub fn enqueue(&self, message: DepMessage) {\n-        // Regardless of whether dep graph construction is enabled, we\n-        // still want to check that we always have a valid task on the\n-        // stack when a read/write/etc event occurs.\n-        match message {\n-            DepMessage::Read(_) | DepMessage::Write(_) =>\n-                if self.tasks_pushed.get() == 0 {\n-                    self.invalid_message(\"read/write but no current task\")\n-                },\n-            DepMessage::PushTask(_) | DepMessage::PushIgnore =>\n-                self.tasks_pushed.set(self.tasks_pushed.get() + 1),\n-            DepMessage::PopTask(_) | DepMessage::PopIgnore =>\n-                self.tasks_pushed.set(self.tasks_pushed.get() - 1),\n-            DepMessage::Query =>\n-                (),\n-        }\n+        self.shadow_graph.enqueue(&message);\n \n         if self.enabled {\n             self.enqueue_enabled(message);\n@@ -147,11 +137,6 @@ impl DepGraphThreadData {\n             self.swap();\n         }\n     }\n-\n-    // Outline this too.\n-    fn invalid_message(&self, string: &str) {\n-        bug!(\"{}; see src/librustc/dep_graph/README.md for more information\", string)\n-    }\n }\n \n /// Definition of the depgraph thread."}, {"sha": "16afa705e39198d145fb5f38caab9c3ac2c7d497", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -58,19 +58,14 @@ impl fmt::Debug for DefId {\n         write!(f, \"DefId {{ krate: {:?}, node: {:?}\",\n                self.krate, self.index)?;\n \n-        // Unfortunately, there seems to be no way to attempt to print\n-        // a path for a def-id, so I'll just make a best effort for now\n-        // and otherwise fallback to just printing the crate/node pair\n-        if self.is_local() { // (1)\n-            // (1) side-step fact that not all external things have paths at\n-            // the moment, such as type parameters\n-            ty::tls::with_opt(|opt_tcx| {\n-                if let Some(tcx) = opt_tcx {\n-                    write!(f, \" => {}\", tcx.item_path_str(*self))?;\n+        ty::tls::with_opt(|opt_tcx| {\n+            if let Some(tcx) = opt_tcx {\n+                if let Some(def_path) = tcx.opt_def_path(*self) {\n+                    write!(f, \" => {}\", def_path.to_string(tcx))?;\n                 }\n-                Ok(())\n-            })?;\n-        }\n+            }\n+            Ok(())\n+        })?;\n \n         write!(f, \" }}\")\n     }"}, {"sha": "5c302d927a7189c4edcfa6746984c803c7e5eb86", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -927,6 +927,8 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                                           ii: InlinedItem,\n                                           fold_ops: F)\n                                           -> &'ast InlinedItem {\n+    let _ignore = map.forest.dep_graph.in_ignore();\n+\n     let mut fld = IdAndSpanUpdater::new(fold_ops);\n     let ii = match ii {\n         II::Item(d, i) => II::Item(fld.fold_ops.new_def_id(d),"}, {"sha": "d2a2f8a972d96224ef23e2439b8835425474bdf3", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -24,6 +24,7 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(associated_consts)]\n+#![feature(borrow_state)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]"}, {"sha": "d1722ac6f2f7f249896a9beb4e7c208395f7b797", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -233,7 +233,7 @@ pub trait CrateStore<'tcx> {\n                              def: DefKey)\n                              -> Option<DefIndex>;\n     fn def_key(&self, def: DefId) -> hir_map::DefKey;\n-    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath;\n+    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n     fn variant_kind(&self, def_id: DefId) -> Option<VariantKind>;\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>;\n     fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>;\n@@ -430,7 +430,9 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // resolve\n     fn def_key(&self, def: DefId) -> hir_map::DefKey { bug!(\"def_key\") }\n-    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath { bug!(\"relative_def_path\") }\n+    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n+        bug!(\"relative_def_path\")\n+    }\n     fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> { bug!(\"variant_kind\") }\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n         { bug!(\"struct_ctor_def_id\") }"}, {"sha": "5772d16c6d43d9abe0359b0e258cf567f960211b", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -39,7 +39,7 @@ dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>\n dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n-dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Rc<Vec<DefId>> }\n+dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n dep_map_ty! { ImplItems: ImplItems(DefId) -> Vec<ty::ImplOrTraitItemId> }\n dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }"}, {"sha": "f634c8e37d7bd054db2dbe297aeb03fd99612128", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -2465,12 +2465,41 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns the `DefPath` of an item. Note that if `id` is not\n-    /// local to this crate -- or is inlined into this crate -- the\n-    /// result will be a non-local `DefPath`.\n+    /// Convert a `DefId` into its fully expanded `DefPath` (every\n+    /// `DefId` is really just an interned def-path).\n+    ///\n+    /// Note that if `id` is not local to this crate -- or is\n+    /// inlined into this crate -- the result will be a non-local\n+    /// `DefPath`.\n+    ///\n+    /// This function is only safe to use when you are sure that the\n+    /// full def-path is accessible. Examples that are known to be\n+    /// safe are local def-ids or items; see `opt_def_path` for more\n+    /// details.\n     pub fn def_path(self, id: DefId) -> ast_map::DefPath {\n+        self.opt_def_path(id).unwrap_or_else(|| {\n+            bug!(\"could not load def-path for {:?}\", id)\n+        })\n+    }\n+\n+    /// Convert a `DefId` into its fully expanded `DefPath` (every\n+    /// `DefId` is really just an interned def-path).\n+    ///\n+    /// When going across crates, we do not save the full info for\n+    /// every cross-crate def-id, and hence we may not always be able\n+    /// to create a def-path. Therefore, this returns\n+    /// `Option<DefPath>` to cover that possibility. It will always\n+    /// return `Some` for local def-ids, however, as well as for\n+    /// items. The problems arise with \"minor\" def-ids like those\n+    /// associated with a pattern, `impl Trait`, or other internal\n+    /// detail to a fn.\n+    ///\n+    /// Note that if `id` is not local to this crate -- or is\n+    /// inlined into this crate -- the result will be a non-local\n+    /// `DefPath`.\n+    pub fn opt_def_path(self, id: DefId) -> Option<ast_map::DefPath> {\n         if id.is_local() {\n-            self.map.def_path(id)\n+            Some(self.map.def_path(id))\n         } else {\n             self.sess.cstore.relative_def_path(id)\n         }\n@@ -2693,7 +2722,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n         }\n \n-        self.inherent_impls.borrow_mut().insert(type_id, Rc::new(inherent_impls));\n+        self.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n         self.populated_external_types.borrow_mut().insert(type_id);\n     }\n "}, {"sha": "b28454cddb247feedf5868d4ddc69b3cd0662abf", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 71, "deletions": 87, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -26,19 +26,20 @@\n //! used to check when paths exist or do not.\n //!\n //! The full form of the `rustc_if_this_changed` annotation is\n-//! `#[rustc_if_this_changed(id)]`. The `\"id\"` is optional and\n-//! defaults to `\"id\"` if omitted.\n+//! `#[rustc_if_this_changed(\"foo\")]`, which will report a\n+//! source node of `foo(def_id)`. The `\"foo\"` is optional and\n+//! defaults to `\"Hir\"` if omitted.\n //!\n //! Example:\n //!\n //! ```\n-//! #[rustc_if_this_changed]\n+//! #[rustc_if_this_changed(Hir)]\n //! fn foo() { }\n //!\n-//! #[rustc_then_this_would_need(\"trans\")] //~ ERROR no path from `foo`\n+//! #[rustc_then_this_would_need(trans)] //~ ERROR no path from `foo`\n //! fn bar() { }\n //!\n-//! #[rustc_then_this_would_need(\"trans\")] //~ ERROR OK\n+//! #[rustc_then_this_would_need(trans)] //~ ERROR OK\n //! fn baz() { foo(); }\n //! ```\n \n@@ -47,7 +48,7 @@ use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use rustc_data_structures::fnv::FnvHashSet;\n use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n use rustc::hir;\n use rustc::hir::intravisit::Visitor;\n@@ -61,7 +62,6 @@ use syntax_pos::Span;\n \n const IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n const THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n-const ID: &'static str = \"id\";\n \n pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n@@ -80,8 +80,9 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // Find annotations supplied by user (if any).\n     let (if_this_changed, then_this_would_need) = {\n         let mut visitor = IfThisChanged { tcx: tcx,\n-                                          if_this_changed: FnvHashMap(),\n-                                          then_this_would_need: FnvHashMap() };\n+                                          if_this_changed: vec![],\n+                                          then_this_would_need: vec![] };\n+        visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.map.krate().attrs);\n         tcx.map.krate().visit_all_items(&mut visitor);\n         (visitor.if_this_changed, visitor.then_this_would_need)\n     };\n@@ -97,58 +98,51 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     check_paths(tcx, &if_this_changed, &then_this_would_need);\n }\n \n-type SourceHashMap =\n-    FnvHashMap<InternedString,\n-               FnvHashSet<(Span, DefId, DepNode<DefId>)>>;\n-type TargetHashMap =\n-    FnvHashMap<InternedString,\n-               FnvHashSet<(Span, InternedString, ast::NodeId, DepNode<DefId>)>>;\n+type Sources = Vec<(Span, DefId, DepNode<DefId>)>;\n+type Targets = Vec<(Span, InternedString, ast::NodeId, DepNode<DefId>)>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    if_this_changed: SourceHashMap,\n-    then_this_would_need: TargetHashMap,\n+    if_this_changed: Sources,\n+    then_this_would_need: Targets,\n }\n \n impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n-    fn process_attrs(&mut self, node_id: ast::NodeId, def_id: DefId) {\n-        for attr in self.tcx.get_attrs(def_id).iter() {\n+    fn argument(&self, attr: &ast::Attribute) -> Option<InternedString> {\n+        let mut value = None;\n+        for list_item in attr.meta_item_list().unwrap_or_default() {\n+            match list_item.word() {\n+                Some(word) if value.is_none() =>\n+                    value = Some(word.name().clone()),\n+                _ =>\n+                    // FIXME better-encapsulate meta_item (don't directly access `node`)\n+                    span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node),\n+            }\n+        }\n+        value\n+    }\n+\n+    fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n+        let def_id = self.tcx.map.local_def_id(node_id);\n+        for attr in attrs {\n             if attr.check_name(IF_THIS_CHANGED) {\n-                let mut id = None;\n-                for list_item in attr.meta_item_list().unwrap_or_default() {\n-                    match list_item.word() {\n-                        Some(word) if id.is_none() => {\n-                            id = Some(word.name().clone())\n-                        },\n-                        _ => {\n-                            // FIXME better-encapsulate meta_item (don't directly access `node`)\n-                            span_bug!(list_item.span(), \"unexpected list-item {:?}\", list_item.node)\n+                let dep_node_interned = self.argument(attr);\n+                let dep_node = match dep_node_interned {\n+                    None => DepNode::Hir(def_id),\n+                    Some(ref n) => {\n+                        match DepNode::from_label_string(&n[..], def_id) {\n+                            Ok(n) => n,\n+                            Err(()) => {\n+                                self.tcx.sess.span_fatal(\n+                                    attr.span,\n+                                    &format!(\"unrecognized DepNode variant {:?}\", n));\n+                            }\n                         }\n                     }\n-                }\n-\n-                let id = id.unwrap_or(InternedString::new(ID));\n-                self.if_this_changed.entry(id)\n-                                    .or_insert(FnvHashSet())\n-                                    .insert((attr.span, def_id, DepNode::Hir(def_id)));\n+                };\n+                self.if_this_changed.push((attr.span, def_id, dep_node));\n             } else if attr.check_name(THEN_THIS_WOULD_NEED) {\n-                let mut dep_node_interned = None;\n-                let mut id = None;\n-                for list_item in attr.meta_item_list().unwrap_or_default() {\n-                    match list_item.word() {\n-                        Some(word) if dep_node_interned.is_none() => {\n-                            dep_node_interned = Some(word.name().clone());\n-                        },\n-                        Some(word) if id.is_none() => {\n-                            id = Some(word.name().clone())\n-                        },\n-                        _ => {\n-                            // FIXME better-encapsulate meta_item (don't directly access `node`)\n-                            span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node)\n-                        }\n-                    }\n-                }\n-\n+                let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     Some(ref n) => {\n                         match DepNode::from_label_string(&n[..], def_id) {\n@@ -166,59 +160,49 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                             &format!(\"missing DepNode variant\"));\n                     }\n                 };\n-                let id = id.unwrap_or(InternedString::new(ID));\n-                self.then_this_would_need\n-                    .entry(id)\n-                    .or_insert(FnvHashSet())\n-                    .insert((attr.span, dep_node_interned.clone().unwrap(), node_id, dep_node));\n+                self.then_this_would_need.push((attr.span,\n+                                                dep_node_interned.clone().unwrap(),\n+                                                node_id,\n+                                                dep_node));\n             }\n         }\n     }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let def_id = self.tcx.map.local_def_id(item.id);\n-        self.process_attrs(item.id, def_id);\n+        self.process_attrs(item.id, &item.attrs);\n     }\n }\n \n fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         if_this_changed: &SourceHashMap,\n-                         then_this_would_need: &TargetHashMap)\n+                         if_this_changed: &Sources,\n+                         then_this_would_need: &Targets)\n {\n     // Return early here so as not to construct the query, which is not cheap.\n     if if_this_changed.is_empty() {\n+        for &(target_span, _, _, _) in then_this_would_need {\n+            tcx.sess.span_err(\n+                target_span,\n+                &format!(\"no #[rustc_if_this_changed] annotation detected\"));\n+\n+        }\n         return;\n     }\n     let query = tcx.dep_graph.query();\n-    for (id, sources) in if_this_changed {\n-        let targets = match then_this_would_need.get(id) {\n-            Some(targets) => targets,\n-            None => {\n-                for &(source_span, ..) in sources.iter().take(1) {\n-                    tcx.sess.span_err(\n-                        source_span,\n-                        &format!(\"no targets for id `{}`\", id));\n-                }\n-                continue;\n-            }\n-        };\n-\n-        for &(_, source_def_id, ref source_dep_node) in sources {\n-            let dependents = query.transitive_successors(source_dep_node);\n-            for &(target_span, ref target_pass, _, ref target_dep_node) in targets {\n-                if !dependents.contains(&target_dep_node) {\n-                    tcx.sess.span_err(\n-                        target_span,\n-                        &format!(\"no path from `{}` to `{}`\",\n-                                 tcx.item_path_str(source_def_id),\n-                                 target_pass));\n-                } else {\n-                    tcx.sess.span_err(\n-                        target_span,\n-                        &format!(\"OK\"));\n-                }\n+    for &(_, source_def_id, ref source_dep_node) in if_this_changed {\n+        let dependents = query.transitive_successors(source_dep_node);\n+        for &(target_span, ref target_pass, _, ref target_dep_node) in then_this_would_need {\n+            if !dependents.contains(&target_dep_node) {\n+                tcx.sess.span_err(\n+                    target_span,\n+                    &format!(\"no path from `{}` to `{}`\",\n+                             tcx.item_path_str(source_def_id),\n+                             target_pass));\n+            } else {\n+                tcx.sess.span_err(\n+                    target_span,\n+                    &format!(\"OK\"));\n             }\n         }\n     }"}, {"sha": "29b9cc0d1d923a6b0eb6af5816e71ba3b7823344", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -149,9 +149,9 @@ pub const tag_items_data_item_visibility: usize = 0x78;\n pub const tag_items_data_item_inherent_impl: usize = 0x79;\n // GAP 0x7a\n pub const tag_mod_child: usize = 0x7b;\n-pub const tag_misc_info: usize = 0x108; // top-level only\n-pub const tag_misc_info_crate_items: usize = 0x7c;\n+// GAP 0x7c\n \n+// GAP 0x108\n pub const tag_impls: usize = 0x109; // top-level only\n pub const tag_impls_trait: usize = 0x7d;\n pub const tag_impls_trait_impl: usize = 0x7e;"}, {"sha": "d7ca93235fddbe81c584326f92f5a55ec138a9ca", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -425,13 +425,21 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to.\n     fn def_key(&self, def: DefId) -> hir_map::DefKey {\n-        self.dep_graph.read(DepNode::MetaData(def));\n+        // Note: loading the def-key (or def-path) for a def-id is not\n+        // a *read* of its metadata. This is because the def-id is\n+        // really just an interned shorthand for a def-path, which is the\n+        // canonical name for an item.\n+        //\n+        // self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::def_key(&cdata, def.index)\n     }\n \n-    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath {\n-        self.dep_graph.read(DepNode::MetaData(def));\n+    fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n+        // See `Note` above in `def_key()` for why this read is\n+        // commented out:\n+        //\n+        // self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::def_path(&cdata, def.index)\n     }"}, {"sha": "d2840fbe4fe463dff187897c3dfe5eca54e5b8e1", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -23,6 +23,7 @@ use index;\n use tls_context;\n use tydecode::TyDecoder;\n \n+use rustc::hir::def_id::CRATE_DEF_INDEX;\n use rustc::hir::svh::Svh;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::DefKey;\n@@ -727,15 +728,7 @@ pub fn each_top_level_item_of_crate<F, G>(cdata: Cmd, get_crate_data: G, callbac\n     where F: FnMut(DefLike, ast::Name, ty::Visibility),\n           G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n-    let root_doc = rbml::Doc::new(cdata.data());\n-    let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n-    let crate_items_doc = reader::get_doc(misc_info_doc,\n-                                          tag_misc_info_crate_items);\n-\n-    each_child_of_item_or_crate(cdata,\n-                                crate_items_doc,\n-                                get_crate_data,\n-                                callback)\n+    each_child_of_item(cdata, CRATE_DEF_INDEX, get_crate_data, callback)\n }\n \n pub fn get_item_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n@@ -761,7 +754,7 @@ pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id:\n         krate: cdata.cnum,\n         index: def_key(cdata, id).parent.unwrap()\n     };\n-    let mut parent_def_path = def_path(cdata, id);\n+    let mut parent_def_path = def_path(cdata, id).unwrap();\n     parent_def_path.data.pop();\n     if let Some(ast_doc) = reader::maybe_get_doc(item_doc, tag_ast as usize) {\n         let ii = decode_inlined_item(cdata,\n@@ -1628,9 +1621,16 @@ fn item_def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n     }\n }\n \n-pub fn def_path(cdata: Cmd, id: DefIndex) -> hir_map::DefPath {\n+// Returns the path leading to the thing with this `id`. Note that\n+// some def-ids don't wind up in the metadata, so `def_path` sometimes\n+// returns `None`\n+pub fn def_path(cdata: Cmd, id: DefIndex) -> Option<hir_map::DefPath> {\n     debug!(\"def_path(id={:?})\", id);\n-    hir_map::DefPath::make(cdata.cnum, id, |parent| def_key(cdata, parent))\n+    if cdata.get_item(id).is_some() {\n+        Some(hir_map::DefPath::make(cdata.cnum, id, |parent| def_key(cdata, parent)))\n+    } else {\n+        None\n+    }\n }\n \n pub fn get_panic_strategy(data: &[u8]) -> PanicStrategy {"}, {"sha": "603b7a483b90c5cfbd1cf4b3a161bb967a810f49", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 30, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -1693,30 +1693,6 @@ fn encode_impls<'a>(ecx: &'a EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn encode_misc_info(ecx: &EncodeContext,\n-                    krate: &hir::Crate,\n-                    rbml_w: &mut Encoder) {\n-    rbml_w.start_tag(tag_misc_info);\n-    rbml_w.start_tag(tag_misc_info_crate_items);\n-    for item_id in &krate.module.item_ids {\n-        rbml_w.wr_tagged_u64(tag_mod_child,\n-                             def_to_u64(ecx.tcx.map.local_def_id(item_id.id)));\n-\n-        let item = ecx.tcx.map.expect_item(item_id.id);\n-        each_auxiliary_node_id(item, |auxiliary_node_id| {\n-            rbml_w.wr_tagged_u64(tag_mod_child,\n-                                 def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n-            true\n-        });\n-    }\n-\n-    // Encode reexports for the root module.\n-    encode_reexports(ecx, rbml_w, 0);\n-\n-    rbml_w.end_tag();\n-    rbml_w.end_tag();\n-}\n-\n // Encodes all reachable symbols in this crate into the metadata.\n //\n // This pass is seeded off the reachability list calculated in the\n@@ -1861,7 +1837,7 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n         codemap_bytes: u64,\n         macro_defs_bytes: u64,\n         impl_bytes: u64,\n-        misc_bytes: u64,\n+        reachable_bytes: u64,\n         item_bytes: u64,\n         index_bytes: u64,\n         xref_bytes: u64,\n@@ -1877,7 +1853,7 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n         codemap_bytes: 0,\n         macro_defs_bytes: 0,\n         impl_bytes: 0,\n-        misc_bytes: 0,\n+        reachable_bytes: 0,\n         item_bytes: 0,\n         index_bytes: 0,\n         xref_bytes: 0,\n@@ -1931,11 +1907,10 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n     encode_impls(&ecx, krate, rbml_w);\n     stats.impl_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n-    // Encode miscellaneous info.\n+    // Encode reachability info.\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_misc_info(&ecx, krate, rbml_w);\n     encode_reachable(&ecx, rbml_w);\n-    stats.misc_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+    stats.reachable_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode and index the items.\n     rbml_w.start_tag(tag_items);\n@@ -1972,7 +1947,7 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n         println!(\"         codemap bytes: {}\", stats.codemap_bytes);\n         println!(\"       macro def bytes: {}\", stats.macro_defs_bytes);\n         println!(\"            impl bytes: {}\", stats.impl_bytes);\n-        println!(\"            misc bytes: {}\", stats.misc_bytes);\n+        println!(\"       reachable bytes: {}\", stats.reachable_bytes);\n         println!(\"            item bytes: {}\", stats.item_bytes);\n         println!(\"           index bytes: {}\", stats.index_bytes);\n         println!(\"            xref bytes: {}\", stats.xref_bytes);"}, {"sha": "26c33c00b9cf923b71db950433c38df6dd6dc3c3", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -32,10 +32,7 @@ use rustc::ty::util::CopyImplementationError;\n use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n use rustc::infer::{self, InferCtxt, TypeOrigin};\n-use std::cell::RefCell;\n-use std::rc::Rc;\n use syntax_pos::Span;\n-use util::nodemap::{DefIdMap, FnvHashMap};\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n use rustc::hir::intravisit;\n@@ -49,7 +46,6 @@ mod unsafety;\n struct CoherenceChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     crate_context: &'a CrateCtxt<'a, 'gcx>,\n     inference_context: InferCtxt<'a, 'gcx, 'tcx>,\n-    inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<DefId>>>>>,\n }\n \n struct CoherenceCheckVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n@@ -107,15 +103,6 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             DepNode::CoherenceCheckImpl,\n             &mut CoherenceCheckVisitor { cc: self });\n \n-        // Copy over the inherent impls we gathered up during the walk into\n-        // the tcx.\n-        let mut tcx_inherent_impls =\n-            self.crate_context.tcx.inherent_impls.borrow_mut();\n-        for (k, v) in self.inherent_impls.borrow().iter() {\n-            tcx_inherent_impls.insert((*k).clone(),\n-                                      Rc::new((*v.borrow()).clone()));\n-        }\n-\n         // Populate the table of destructors. It might seem a bit strange to\n         // do this here, but it's actually the most convenient place, since\n         // the coherence tables contain the trait -> type mappings.\n@@ -173,14 +160,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        if let Some(implementation_list) = self.inherent_impls.borrow().get(&base_def_id) {\n-            implementation_list.borrow_mut().push(impl_def_id);\n-            return;\n-        }\n-\n-        self.inherent_impls.borrow_mut().insert(\n-            base_def_id,\n-            Rc::new(RefCell::new(vec!(impl_def_id))));\n+        let tcx = self.crate_context.tcx;\n+        tcx.inherent_impls.borrow_mut().push(base_def_id, impl_def_id);\n     }\n \n     fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'gcx>, impl_def_id: DefId) {\n@@ -553,7 +534,6 @@ pub fn check_coherence(ccx: &CrateCtxt) {\n         CoherenceChecker {\n             crate_context: ccx,\n             inference_context: infcx,\n-            inherent_impls: RefCell::new(FnvHashMap()),\n         }.check();\n     });\n     unsafety::check(ccx.tcx);"}, {"sha": "ac6cc3e9826f1dac7230367c852c3adef09891a6", "filename": "src/test/incremental/krate-inherent.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Ftest%2Fincremental%2Fkrate-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Ftest%2Fincremental%2Fkrate-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fkrate-inherent.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![rustc_partition_reused(module=\"krate_inherent-x\", cfg=\"rpass2\")]\n+\n+fn main() { }\n+\n+mod x {\n+    struct Foo;\n+    impl Foo {\n+        fn foo(&self) { }\n+    }\n+\n+    fn method() {\n+        let x: Foo = Foo;\n+        x.foo(); // inherent methods used to add an edge from Krate\n+    }\n+}\n+\n+#[cfg(rpass1)]\n+fn bar() { } // remove this unrelated fn in rpass2, which should not affect `x::method`\n+"}, {"sha": "ba32b41983fc2bd031dab2d889ac5a2de8928232", "filename": "src/test/incremental/krate-inlined.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Ftest%2Fincremental%2Fkrate-inlined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Ftest%2Fincremental%2Fkrate-inlined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fkrate-inlined.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regr. test that using HIR inlined from another krate does *not* add\n+// a dependency from the local Krate node.\n+\n+// revisions: cfail1\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+\n+#![rustc_if_this_changed(Krate)]\n+\n+fn main() { }\n+\n+mod x {\n+    #[rustc_then_this_would_need(TransCrateItem)] //[cfail1]~ ERROR no path\n+    fn method() {\n+        // use some methods that require inlining HIR from another crate:\n+        let mut v = vec![];\n+        v.push(1);\n+    }\n+}"}, {"sha": "4d84e844dedbbc6ff84839eff5207d872072176d", "filename": "src/test/incremental/remove-private-item-cross-crate/auxiliary/a.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fauxiliary%2Fa.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+#![crate_name = \"a\"]\n+#![crate_type = \"rlib\"]\n+\n+pub fn foo(b: u8) -> u32 { b as u32 }\n+\n+#[cfg(rpass1)]\n+fn bar() { }"}, {"sha": "582ee905d7ca44347393d80dc4ca9b035379197c", "filename": "src/test/incremental/remove-private-item-cross-crate/main.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fmain.rs?ref=fa9d8cc8ace2c1f22469b4a6c8e1e0352072c675", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to reuse `main` even though a private\n+// item was removed from the root module of crate`a`.\n+\n+// revisions:rpass1 rpass2\n+// aux-build:a.rs\n+\n+#![feature(rustc_attrs)]\n+#![crate_type = \"bin\"]\n+#![rustc_partition_reused(module=\"main\", cfg=\"rpass2\")]\n+\n+extern crate a;\n+\n+pub fn main() {\n+    let vec: Vec<u8> = vec![0, 1, 2, 3];\n+    for &b in &vec {\n+        println!(\"{}\", a::foo(b));\n+    }\n+}"}]}