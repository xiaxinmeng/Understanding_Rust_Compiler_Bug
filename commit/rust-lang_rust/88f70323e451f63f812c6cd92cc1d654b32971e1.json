{"sha": "88f70323e451f63f812c6cd92cc1d654b32971e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZjcwMzIzZTQ1MWY2M2Y4MTJjNmNkOTJjYzFkNjU0YjMyOTcxZTE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-20T02:16:06Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:31Z"}, "message": "rustc_trans: nest abi::ArgType's for fat pointers instead of eagerly flattening.", "tree": {"sha": "a7531ba09b2de91cb954d2ced959dc16b6b0791c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7531ba09b2de91cb954d2ced959dc16b6b0791c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88f70323e451f63f812c6cd92cc1d654b32971e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88f70323e451f63f812c6cd92cc1d654b32971e1", "html_url": "https://github.com/rust-lang/rust/commit/88f70323e451f63f812c6cd92cc1d654b32971e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88f70323e451f63f812c6cd92cc1d654b32971e1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2e7e17d9e9b8faeb13c388c56ef135978a77c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2e7e17d9e9b8faeb13c388c56ef135978a77c58", "html_url": "https://github.com/rust-lang/rust/commit/f2e7e17d9e9b8faeb13c388c56ef135978a77c58"}], "stats": {"total": 298, "additions": 161, "deletions": 137}, "files": [{"sha": "689976b6c42fc1cfeb75a348a67f816390bfb4cf", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 81, "deletions": 27, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/88f70323e451f63f812c6cd92cc1d654b32971e1/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f70323e451f63f812c6cd92cc1d654b32971e1/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=88f70323e451f63f812c6cd92cc1d654b32971e1", "patch": "@@ -420,7 +420,7 @@ impl CastTarget {\n /// should be passed to or returned from a function\n ///\n /// This is borrowed from clang's ABIInfo.h\n-#[derive(Clone, Copy, Debug)]\n+#[derive(Debug)]\n pub struct ArgType<'tcx> {\n     kind: ArgKind,\n     pub layout: FullLayout<'tcx>,\n@@ -429,7 +429,8 @@ pub struct ArgType<'tcx> {\n     /// Dummy argument, which is emitted before the real argument.\n     pub pad: Option<Reg>,\n     /// Attributes of argument.\n-    pub attrs: ArgAttributes\n+    pub attrs: ArgAttributes,\n+    pub nested: Vec<ArgType<'tcx>>\n }\n \n impl<'a, 'tcx> ArgType<'tcx> {\n@@ -439,11 +440,13 @@ impl<'a, 'tcx> ArgType<'tcx> {\n             layout,\n             cast: None,\n             pad: None,\n-            attrs: ArgAttributes::default()\n+            attrs: ArgAttributes::default(),\n+            nested: vec![]\n         }\n     }\n \n     pub fn make_indirect(&mut self, ccx: &CrateContext<'a, 'tcx>) {\n+        assert!(self.nested.is_empty());\n         assert_eq!(self.kind, ArgKind::Direct);\n \n         // Wipe old attributes, likely not valid through indirection.\n@@ -460,6 +463,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n     }\n \n     pub fn ignore(&mut self) {\n+        assert!(self.nested.is_empty());\n         assert_eq!(self.kind, ArgKind::Direct);\n         self.kind = ArgKind::Ignore;\n     }\n@@ -482,10 +486,12 @@ impl<'a, 'tcx> ArgType<'tcx> {\n     }\n \n     pub fn cast_to<T: Into<CastTarget>>(&mut self, target: T) {\n+        assert!(self.nested.is_empty());\n         self.cast = Some(target.into());\n     }\n \n     pub fn pad_with(&mut self, reg: Reg) {\n+        assert!(self.nested.is_empty());\n         self.pad = Some(reg);\n     }\n \n@@ -561,6 +567,12 @@ impl<'a, 'tcx> ArgType<'tcx> {\n     }\n \n     pub fn store_fn_arg(&self, bcx: &Builder<'a, 'tcx>, idx: &mut usize, dst: LvalueRef<'tcx>) {\n+        if !self.nested.is_empty() {\n+            for (i, arg) in self.nested.iter().enumerate() {\n+                arg.store_fn_arg(bcx, idx, dst.project_field(bcx, i));\n+            }\n+            return;\n+        }\n         if self.pad.is_some() {\n             *idx += 1;\n         }\n@@ -578,7 +590,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n ///\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct FnType<'tcx> {\n     /// The LLVM types of each argument.\n     pub args: Vec<ArgType<'tcx>>,\n@@ -613,7 +625,8 @@ impl<'a, 'tcx> FnType<'tcx> {\n                       extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n         // Don't pass the vtable, it's not an argument of the virtual fn.\n-        fn_ty.args[1].ignore();\n+        assert_eq!(fn_ty.args[0].nested.len(), 2);\n+        fn_ty.args[0].nested[1].ignore();\n         fn_ty.adjust_for_abi(ccx, sig);\n         fn_ty\n     }\n@@ -766,7 +779,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n         for ty in inputs.iter().chain(extra_args.iter()) {\n             let mut arg = arg_of(ty, false);\n \n-            if let ty::layout::Layout::FatPointer { .. } = *arg.layout.layout {\n+            if type_is_fat_ptr(ccx, ty) {\n                 let mut data = ArgType::new(arg.layout.field(ccx, 0));\n                 let mut info = ArgType::new(arg.layout.field(ccx, 1));\n \n@@ -780,14 +793,16 @@ impl<'a, 'tcx> FnType<'tcx> {\n                         info.attrs.set(ArgAttribute::NoAlias);\n                     }\n                 }\n-                args.push(data);\n-                args.push(info);\n+                // FIXME(eddyb) other ABIs don't have logic for nested.\n+                if rust_abi {\n+                    arg.nested = vec![data, info];\n+                }\n             } else {\n                 if let Some(inner) = rust_ptr_attrs(ty, &mut arg) {\n                     arg.attrs.set_dereferenceable(ccx.size_of(inner));\n                 }\n-                args.push(arg);\n             }\n+            args.push(arg);\n         }\n \n         FnType {\n@@ -854,6 +869,13 @@ impl<'a, 'tcx> FnType<'tcx> {\n             }\n             for arg in &mut self.args {\n                 if arg.is_ignore() { continue; }\n+                if !arg.nested.is_empty() {\n+                    for arg in &mut arg.nested {\n+                        assert!(arg.nested.is_empty());\n+                        fixup(arg);\n+                    }\n+                    continue;\n+                }\n                 fixup(arg);\n             }\n             if self.ret.is_indirect() {\n@@ -915,24 +937,36 @@ impl<'a, 'tcx> FnType<'tcx> {\n             ccx.immediate_llvm_type_of(self.ret.layout.ty)\n         };\n \n-        for arg in &self.args {\n-            if arg.is_ignore() {\n-                continue;\n-            }\n-            // add padding\n-            if let Some(ty) = arg.pad {\n-                llargument_tys.push(ty.llvm_type(ccx));\n-            }\n+        {\n+            let mut push = |arg: &ArgType<'tcx>| {\n+                if arg.is_ignore() {\n+                    return;\n+                }\n+                // add padding\n+                if let Some(ty) = arg.pad {\n+                    llargument_tys.push(ty.llvm_type(ccx));\n+                }\n \n-            let llarg_ty = if arg.is_indirect() {\n-                arg.memory_ty(ccx).ptr_to()\n-            } else if let Some(cast) = arg.cast {\n-                cast.llvm_type(ccx)\n-            } else {\n-                ccx.immediate_llvm_type_of(arg.layout.ty)\n-            };\n+                let llarg_ty = if arg.is_indirect() {\n+                    arg.memory_ty(ccx).ptr_to()\n+                } else if let Some(cast) = arg.cast {\n+                    cast.llvm_type(ccx)\n+                } else {\n+                    ccx.immediate_llvm_type_of(arg.layout.ty)\n+                };\n \n-            llargument_tys.push(llarg_ty);\n+                llargument_tys.push(llarg_ty);\n+            };\n+            for arg in &self.args {\n+                if !arg.nested.is_empty() {\n+                    for arg in &arg.nested {\n+                        assert!(arg.nested.is_empty());\n+                        push(arg);\n+                    }\n+                    continue;\n+                }\n+                push(arg);\n+            }\n         }\n \n         if self.variadic {\n@@ -948,12 +982,22 @@ impl<'a, 'tcx> FnType<'tcx> {\n             self.ret.attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n         }\n         i += 1;\n-        for arg in &self.args {\n+        let mut apply = |arg: &ArgType| {\n             if !arg.is_ignore() {\n                 if arg.pad.is_some() { i += 1; }\n                 arg.attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n                 i += 1;\n             }\n+        };\n+        for arg in &self.args {\n+            if !arg.nested.is_empty() {\n+                for arg in &arg.nested {\n+                    assert!(arg.nested.is_empty());\n+                    apply(arg);\n+                }\n+                continue;\n+            }\n+            apply(arg);\n         }\n     }\n \n@@ -963,12 +1007,22 @@ impl<'a, 'tcx> FnType<'tcx> {\n             self.ret.attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n         }\n         i += 1;\n-        for arg in &self.args {\n+        let mut apply = |arg: &ArgType| {\n             if !arg.is_ignore() {\n                 if arg.pad.is_some() { i += 1; }\n                 arg.attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n                 i += 1;\n             }\n+        };\n+        for arg in &self.args {\n+            if !arg.nested.is_empty() {\n+                for arg in &arg.nested {\n+                    assert!(arg.nested.is_empty());\n+                    apply(arg);\n+                }\n+                continue;\n+            }\n+            apply(arg);\n         }\n \n         if self.cconv != llvm::CCallConv {"}, {"sha": "426a44671bccfa9c972da78180f4ad83c914301c", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/88f70323e451f63f812c6cd92cc1d654b32971e1/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f70323e451f63f812c6cd92cc1d654b32971e1/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=88f70323e451f63f812c6cd92cc1d654b32971e1", "patch": "@@ -27,7 +27,7 @@ use type_::Type;\n use value::Value;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, HasDataLayout, Layout, LayoutOf};\n+use rustc::ty::layout::{self, HasDataLayout, LayoutOf};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::hir;\n \n@@ -41,10 +41,15 @@ use syntax_pos::{Span, DUMMY_SP};\n pub use context::{CrateContext, SharedCrateContext};\n \n pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    if let Layout::FatPointer { .. } = *ccx.layout_of(ty).layout {\n-        true\n-    } else {\n-        false\n+    match ty.sty {\n+        ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+        ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+            !ccx.shared().type_is_sized(ty)\n+        }\n+        ty::TyAdt(def, _) if def.is_box() => {\n+            !ccx.shared().type_is_sized(ty.boxed_ty())\n+        }\n+        _ => false\n     }\n }\n \n@@ -63,9 +68,8 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n                                   -> bool {\n     let layout = ccx.layout_of(ty);\n-    match *layout.layout {\n-        Layout::FatPointer => true,\n-        Layout::Univariant => {\n+    match *layout.fields {\n+        layout::FieldPlacement::Arbitrary { .. } => {\n             // There must be only 2 fields.\n             if layout.fields.count() != 2 {\n                 return false;"}, {"sha": "7dbb8253e428987ee57c00b0989589fdef861861", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 28, "deletions": 47, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/88f70323e451f63f812c6cd92cc1d654b32971e1/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f70323e451f63f812c6cd92cc1d654b32971e1/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=88f70323e451f63f812c6cd92cc1d654b32971e1", "patch": "@@ -215,13 +215,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::TerminatorKind::Return => {\n-                let ret = self.fn_ty.ret;\n-                if ret.is_ignore() || ret.is_indirect() {\n+                if self.fn_ty.ret.is_ignore() || self.fn_ty.ret.is_indirect() {\n                     bcx.ret_void();\n                     return;\n                 }\n \n-                let llval = if let Some(cast_ty) = ret.cast {\n+                let llval = if let Some(cast_ty) = self.fn_ty.ret.cast {\n                     let op = match self.locals[mir::RETURN_POINTER] {\n                         LocalRef::Operand(Some(op)) => op,\n                         LocalRef::Operand(None) => bug!(\"use of return before def\"),\n@@ -234,7 +233,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let llslot = match op.val {\n                         Immediate(_) | Pair(..) => {\n-                            let scratch = LvalueRef::alloca(&bcx, ret.layout.ty, \"ret\");\n+                            let scratch = LvalueRef::alloca(&bcx, self.fn_ty.ret.layout.ty, \"ret\");\n                             op.store(&bcx, scratch);\n                             scratch.llval\n                         }\n@@ -246,7 +245,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let load = bcx.load(\n                         bcx.pointercast(llslot, cast_ty.llvm_type(bcx.ccx).ptr_to()),\n-                        Some(ret.layout.align(bcx.ccx)));\n+                        Some(self.fn_ty.ret.layout.align(bcx.ccx)));\n                     load\n                 } else {\n                     let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n@@ -562,9 +561,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     (&args[..], None)\n                 };\n \n-                let mut idx = 0;\n-                for arg in first_args {\n+                for (idx, arg) in first_args.iter().enumerate() {\n                     let mut op = self.trans_operand(&bcx, arg);\n+                    if idx == 0 {\n+                        if let Pair(_, meta) = op.val {\n+                            if let Some(ty::InstanceDef::Virtual(_, idx)) = def {\n+                                let llmeth = meth::VirtualIndex::from_index(idx)\n+                                    .get_fn(&bcx, meta);\n+                                let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n+                                llfn = Some(bcx.pointercast(llmeth, llty));\n+                            }\n+                        }\n+                    }\n \n                     // The callee needs to own the argument memory if we pass it\n                     // by-ref, so make a local copy of non-immediate constants.\n@@ -574,12 +582,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         op.val = Ref(tmp.llval, tmp.alignment);\n                     }\n \n-                    self.trans_argument(&bcx, op, &mut llargs, &fn_ty,\n-                                        &mut idx, &mut llfn, &def);\n+                    self.trans_argument(&bcx, op, &mut llargs, &fn_ty.args[idx]);\n                 }\n                 if let Some(tup) = untuple {\n-                    self.trans_arguments_untupled(&bcx, tup, &mut llargs, &fn_ty,\n-                                                  &mut idx, &mut llfn, &def)\n+                    self.trans_arguments_untupled(&bcx, tup, &mut llargs,\n+                        &fn_ty.args[first_args.len()..])\n                 }\n \n                 let fn_ptr = match (llfn, instance) {\n@@ -602,36 +609,22 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                       bcx: &Builder<'a, 'tcx>,\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n-                      fn_ty: &FnType<'tcx>,\n-                      next_idx: &mut usize,\n-                      llfn: &mut Option<ValueRef>,\n-                      def: &Option<ty::InstanceDef<'tcx>>) {\n+                      arg: &ArgType<'tcx>) {\n         if let Pair(a, b) = op.val {\n             // Treat the values in a fat pointer separately.\n-            if common::type_is_fat_ptr(bcx.ccx, op.ty) {\n-                let (ptr, meta) = (a, b);\n-                if *next_idx == 0 {\n-                    if let Some(ty::InstanceDef::Virtual(_, idx)) = *def {\n-                        let llmeth = meth::VirtualIndex::from_index(idx).get_fn(bcx, meta);\n-                        let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n-                        *llfn = Some(bcx.pointercast(llmeth, llty));\n-                    }\n-                }\n-\n+            if !arg.nested.is_empty() {\n+                assert_eq!(arg.nested.len(), 2);\n                 let imm_op = |x| OperandRef {\n                     val: Immediate(x),\n                     // We won't be checking the type again.\n                     ty: bcx.tcx().types.err\n                 };\n-                self.trans_argument(bcx, imm_op(ptr), llargs, fn_ty, next_idx, llfn, def);\n-                self.trans_argument(bcx, imm_op(meta), llargs, fn_ty, next_idx, llfn, def);\n+                self.trans_argument(bcx, imm_op(a), llargs, &arg.nested[0]);\n+                self.trans_argument(bcx, imm_op(b), llargs, &arg.nested[1]);\n                 return;\n             }\n         }\n \n-        let arg = &fn_ty.args[*next_idx];\n-        *next_idx += 1;\n-\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n             llargs.push(C_undef(ty.llvm_type(bcx.ccx)));\n@@ -686,10 +679,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 bcx: &Builder<'a, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n                                 llargs: &mut Vec<ValueRef>,\n-                                fn_ty: &FnType<'tcx>,\n-                                next_idx: &mut usize,\n-                                llfn: &mut Option<ValueRef>,\n-                                def: &Option<ty::InstanceDef<'tcx>>) {\n+                                args: &[ArgType<'tcx>]) {\n         let tuple = self.trans_operand(bcx, operand);\n \n         let arg_types = match tuple.ty.sty {\n@@ -702,18 +692,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         match tuple.val {\n             Ref(llval, align) => {\n                 let tuple_ptr = LvalueRef::new_sized(llval, tuple.ty, align);\n-                for (n, &ty) in arg_types.iter().enumerate() {\n+                for n in 0..arg_types.len() {\n                     let field_ptr = tuple_ptr.project_field(bcx, n);\n-                    let op = if common::type_is_fat_ptr(bcx.ccx, ty) {\n-                        field_ptr.load(bcx)\n-                    } else {\n-                        // trans_argument will load this if it needs to\n-                        OperandRef {\n-                            val: Ref(field_ptr.llval, field_ptr.alignment),\n-                            ty\n-                        }\n-                    };\n-                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n+                    self.trans_argument(bcx, field_ptr.load(bcx), llargs, &args[n]);\n                 }\n \n             }\n@@ -728,7 +709,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         val: Immediate(elem),\n                         ty,\n                     };\n-                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n+                    self.trans_argument(bcx, op, llargs, &args[n]);\n                 }\n             }\n             Pair(a, b) => {\n@@ -740,7 +721,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         val: Immediate(elem),\n                         ty,\n                     };\n-                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n+                    self.trans_argument(bcx, op, llargs, &args[n]);\n                 }\n             }\n         }"}, {"sha": "7440551f322f91f05279f54e1a057593f27b0afc", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 40, "deletions": 55, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/88f70323e451f63f812c6cd92cc1d654b32971e1/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f70323e451f63f812c6cd92cc1d654b32971e1/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=88f70323e451f63f812c6cd92cc1d654b32971e1", "patch": "@@ -22,7 +22,7 @@ use builder::Builder;\n use common::{self, CrateContext, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n-use abi::{self, ArgAttribute, FnType};\n+use abi::{ArgAttribute, FnType};\n use type_of;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n@@ -401,22 +401,10 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             };\n \n             let lvalue = LvalueRef::alloca(bcx, arg_ty, &name);\n-            for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n-                let dst = lvalue.project_field(bcx, i);\n+            for i in 0..tupled_arg_tys.len() {\n                 let arg = &mircx.fn_ty.args[idx];\n                 idx += 1;\n-                if common::type_is_fat_ptr(bcx.ccx, tupled_arg_ty) {\n-                    // We pass fat pointers as two words, but inside the tuple\n-                    // they are the two sub-fields of a single aggregate field.\n-                    let meta = &mircx.fn_ty.args[idx];\n-                    idx += 1;\n-                    arg.store_fn_arg(bcx, &mut llarg_idx,\n-                        dst.project_field(bcx, abi::FAT_PTR_ADDR));\n-                    meta.store_fn_arg(bcx, &mut llarg_idx,\n-                        dst.project_field(bcx, abi::FAT_PTR_EXTRA));\n-                } else {\n-                    arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n-                }\n+                arg.store_fn_arg(bcx, &mut llarg_idx, lvalue.project_field(bcx, i));\n             }\n \n             // Now that we have one alloca that contains the aggregate value,\n@@ -453,26 +441,19 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             llarg_idx += 1;\n             LvalueRef::new_sized(llarg, arg_ty, Alignment::AbiAligned)\n         } else if !lvalue_locals.contains(local.index()) &&\n-                  arg.cast.is_none() && arg_scope.is_none() {\n-            if arg.is_ignore() {\n-                return LocalRef::new_operand(bcx.ccx, arg_ty);\n-            }\n+                  !arg.nested.is_empty() {\n+            assert_eq!(arg.nested.len(), 2);\n+            let (a, b) = (&arg.nested[0], &arg.nested[1]);\n+            assert!(!a.is_ignore() && a.cast.is_none() && a.pad.is_none());\n+            assert!(!b.is_ignore() && b.cast.is_none() && b.pad.is_none());\n \n-            // We don't have to cast or keep the argument in the alloca.\n-            // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n-            // of putting everything in allocas just so we can use llvm.dbg.declare.\n-            if arg.pad.is_some() {\n-                llarg_idx += 1;\n-            }\n-            let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+            let mut a = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             llarg_idx += 1;\n-            let val = if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n-                let meta = &mircx.fn_ty.args[idx];\n-                idx += 1;\n-                assert!(meta.cast.is_none() && meta.pad.is_none());\n-                let llmeta = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n-                llarg_idx += 1;\n \n+            let mut b = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+            llarg_idx += 1;\n+\n+            if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 // FIXME(eddyb) As we can't perfectly represent the data and/or\n                 // vtable pointer in a fat pointers in Rust's typesystem, and\n                 // because we split fat pointers into two ArgType's, they're\n@@ -486,36 +467,40 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 let data_llty = bcx.ccx.llvm_type_of(pointee);\n                 let meta_llty = type_of::unsized_info_ty(bcx.ccx, pointee);\n \n-                let llarg = bcx.pointercast(llarg, data_llty.ptr_to());\n-                bcx.set_value_name(llarg, &(name.clone() + \".ptr\"));\n-                let llmeta = bcx.pointercast(llmeta, meta_llty);\n-                bcx.set_value_name(llmeta, &(name + \".meta\"));\n+                a = bcx.pointercast(a, data_llty.ptr_to());\n+                bcx.set_value_name(a, &(name.clone() + \".ptr\"));\n+                b = bcx.pointercast(b, meta_llty);\n+                bcx.set_value_name(b, &(name + \".meta\"));\n+            }\n \n-                OperandValue::Pair(llarg, llmeta)\n-            } else {\n-                bcx.set_value_name(llarg, &name);\n-                OperandValue::Immediate(llarg)\n-            };\n+            return LocalRef::Operand(Some(OperandRef {\n+                val: OperandValue::Pair(a, b),\n+                ty: arg_ty\n+            }));\n+        } else if !lvalue_locals.contains(local.index()) &&\n+                  !arg.is_indirect() && arg.cast.is_none() &&\n+                  arg_scope.is_none() {\n+            if arg.is_ignore() {\n+                return LocalRef::new_operand(bcx.ccx, arg_ty);\n+            }\n+\n+            // We don't have to cast or keep the argument in the alloca.\n+            // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n+            // of putting everything in allocas just so we can use llvm.dbg.declare.\n+            if arg.pad.is_some() {\n+                llarg_idx += 1;\n+            }\n+            let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+            bcx.set_value_name(llarg, &name);\n+            llarg_idx += 1;\n             let operand = OperandRef {\n-                val,\n+                val: OperandValue::Immediate(llarg),\n                 ty: arg_ty\n             };\n             return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n         } else {\n             let tmp = LvalueRef::alloca(bcx, arg_ty, &name);\n-            if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n-                // we pass fat pointers as two words, but we want to\n-                // represent them internally as a pointer to two words,\n-                // so make an alloca to store them in.\n-                let meta = &mircx.fn_ty.args[idx];\n-                idx += 1;\n-                arg.store_fn_arg(bcx, &mut llarg_idx, tmp.project_field(bcx, abi::FAT_PTR_ADDR));\n-                meta.store_fn_arg(bcx, &mut llarg_idx, tmp.project_field(bcx, abi::FAT_PTR_EXTRA));\n-            } else  {\n-                // otherwise, arg is passed by value, so make a\n-                // temporary and store it there\n-                arg.store_fn_arg(bcx, &mut llarg_idx, tmp);\n-            }\n+            arg.store_fn_arg(bcx, &mut llarg_idx, tmp);\n             tmp\n         };\n         arg_scope.map(|scope| {"}]}