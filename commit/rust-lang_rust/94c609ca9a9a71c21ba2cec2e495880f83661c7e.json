{"sha": "94c609ca9a9a71c21ba2cec2e495880f83661c7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YzYwOWNhOWE5YTcxYzIxYmEyY2VjMmU0OTU4ODBmODM2NjFjN2U=", "commit": {"author": {"name": "Hirokazu Hata", "email": "h.hata.ai.t@gmail.com", "date": "2019-02-07T02:42:43Z"}, "committer": {"name": "Hirokazu Hata", "email": "h.hata.ai.t@gmail.com", "date": "2019-02-07T05:15:07Z"}, "message": "Transition libserialize to 2018 edition", "tree": {"sha": "baa14813e94e5383ca02a3fcf76c883b87a0a284", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/baa14813e94e5383ca02a3fcf76c883b87a0a284"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94c609ca9a9a71c21ba2cec2e495880f83661c7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94c609ca9a9a71c21ba2cec2e495880f83661c7e", "html_url": "https://github.com/rust-lang/rust/commit/94c609ca9a9a71c21ba2cec2e495880f83661c7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94c609ca9a9a71c21ba2cec2e495880f83661c7e/comments", "author": {"login": "h-michael", "id": 4556097, "node_id": "MDQ6VXNlcjQ1NTYwOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4556097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/h-michael", "html_url": "https://github.com/h-michael", "followers_url": "https://api.github.com/users/h-michael/followers", "following_url": "https://api.github.com/users/h-michael/following{/other_user}", "gists_url": "https://api.github.com/users/h-michael/gists{/gist_id}", "starred_url": "https://api.github.com/users/h-michael/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/h-michael/subscriptions", "organizations_url": "https://api.github.com/users/h-michael/orgs", "repos_url": "https://api.github.com/users/h-michael/repos", "events_url": "https://api.github.com/users/h-michael/events{/privacy}", "received_events_url": "https://api.github.com/users/h-michael/received_events", "type": "User", "site_admin": false}, "committer": {"login": "h-michael", "id": 4556097, "node_id": "MDQ6VXNlcjQ1NTYwOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4556097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/h-michael", "html_url": "https://github.com/h-michael", "followers_url": "https://api.github.com/users/h-michael/followers", "following_url": "https://api.github.com/users/h-michael/following{/other_user}", "gists_url": "https://api.github.com/users/h-michael/gists{/gist_id}", "starred_url": "https://api.github.com/users/h-michael/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/h-michael/subscriptions", "organizations_url": "https://api.github.com/users/h-michael/orgs", "repos_url": "https://api.github.com/users/h-michael/repos", "events_url": "https://api.github.com/users/h-michael/events{/privacy}", "received_events_url": "https://api.github.com/users/h-michael/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b139669f374eb5024a50eb13f116ff763b1c5935", "url": "https://api.github.com/repos/rust-lang/rust/commits/b139669f374eb5024a50eb13f116ff763b1c5935", "html_url": "https://github.com/rust-lang/rust/commit/b139669f374eb5024a50eb13f116ff763b1c5935"}], "stats": {"total": 83, "additions": 42, "deletions": 41}, "files": [{"sha": "949af0e2b97464a9c030c054cb9fca16b004569e", "filename": "src/libserialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2FCargo.toml?ref=94c609ca9a9a71c21ba2cec2e495880f83661c7e", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"serialize\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"serialize\""}, {"sha": "c0a8fa9d0016dba395a62aa036d90b78f6b54e9c", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=94c609ca9a9a71c21ba2cec2e495880f83661c7e", "patch": "@@ -2,7 +2,7 @@\n \n use std::hash::{Hash, BuildHasher};\n \n-use {Decodable, Encodable, Decoder, Encoder};\n+use crate::{Decodable, Encodable, Decoder, Encoder};\n use std::collections::{LinkedList, VecDeque, BTreeMap, BTreeSet, HashMap, HashSet};\n use std::rc::Rc;\n use std::sync::Arc;"}, {"sha": "c5217b962ce7975b03d500c530a3c770ee52f51e", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=94c609ca9a9a71c21ba2cec2e495880f83661c7e", "patch": "@@ -60,7 +60,7 @@ pub enum FromHexError {\n }\n \n impl fmt::Display for FromHexError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             InvalidHexCharacter(ch, idx) =>\n                 write!(f, \"Invalid character '{}' at position {}\", ch, idx),\n@@ -146,7 +146,7 @@ impl FromHex for str {\n mod tests {\n     extern crate test;\n     use self::test::Bencher;\n-    use hex::{FromHex, ToHex};\n+    use crate::hex::{FromHex, ToHex};\n \n     #[test]\n     pub fn test_to_hex() {"}, {"sha": "dc089218a9fac521bb7f4b82fd690eb7310e13d8", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=94c609ca9a9a71c21ba2cec2e495880f83661c7e", "patch": "@@ -201,7 +201,7 @@ use std::string;\n use std::{char, f64, fmt, str};\n use std;\n \n-use Encodable;\n+use crate::Encodable;\n \n /// Represents a json value\n #[derive(Clone, PartialEq, PartialOrd, Debug)]\n@@ -221,8 +221,8 @@ pub type Object = BTreeMap<string::String, Json>;\n \n pub struct PrettyJson<'a> { inner: &'a Json }\n \n-pub struct AsJson<'a, T: 'a> { inner: &'a T }\n-pub struct AsPrettyJson<'a, T: 'a> { inner: &'a T, indent: Option<usize> }\n+pub struct AsJson<'a, T> { inner: &'a T }\n+pub struct AsPrettyJson<'a, T> { inner: &'a T, indent: Option<usize> }\n \n /// The errors that can arise while parsing a JSON stream.\n #[derive(Clone, Copy, PartialEq, Debug)]\n@@ -295,18 +295,18 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n }\n \n /// Shortcut function to decode a JSON `&str` into an object\n-pub fn decode<T: ::Decodable>(s: &str) -> DecodeResult<T> {\n+pub fn decode<T: crate::Decodable>(s: &str) -> DecodeResult<T> {\n     let json = match from_str(s) {\n         Ok(x) => x,\n         Err(e) => return Err(ParseError(e))\n     };\n \n     let mut decoder = Decoder::new(json);\n-    ::Decodable::decode(&mut decoder)\n+    crate::Decodable::decode(&mut decoder)\n }\n \n /// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<T: ::Encodable>(object: &T) -> Result<string::String, EncoderError> {\n+pub fn encode<T: crate::Encodable>(object: &T) -> Result<string::String, EncoderError> {\n     let mut s = String::new();\n     {\n         let mut encoder = Encoder::new(&mut s);\n@@ -316,7 +316,7 @@ pub fn encode<T: ::Encodable>(object: &T) -> Result<string::String, EncoderError\n }\n \n impl fmt::Display for ErrorCode {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         error_str(*self).fmt(f)\n     }\n }\n@@ -326,14 +326,14 @@ fn io_error_to_error(io: io::Error) -> ParserError {\n }\n \n impl fmt::Display for ParserError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME this should be a nicer error\n         fmt::Debug::fmt(self, f)\n     }\n }\n \n impl fmt::Display for DecoderError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME this should be a nicer error\n         fmt::Debug::fmt(self, f)\n     }\n@@ -344,7 +344,7 @@ impl std::error::Error for DecoderError {\n }\n \n impl fmt::Display for EncoderError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME this should be a nicer error\n         fmt::Debug::fmt(self, f)\n     }\n@@ -477,7 +477,7 @@ macro_rules! emit_enquoted_if_mapkey {\n     })\n }\n \n-impl<'a> ::Encoder for Encoder<'a> {\n+impl<'a> crate::Encoder for Encoder<'a> {\n     type Error = EncoderError;\n \n     fn emit_unit(&mut self) -> EncodeResult {\n@@ -727,7 +727,7 @@ impl<'a> PrettyEncoder<'a> {\n     }\n }\n \n-impl<'a> ::Encoder for PrettyEncoder<'a> {\n+impl<'a> crate::Encoder for PrettyEncoder<'a> {\n     type Error = EncoderError;\n \n     fn emit_unit(&mut self) -> EncodeResult {\n@@ -997,7 +997,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n }\n \n impl Encodable for Json {\n-    fn encode<E: ::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode<E: crate::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         match *self {\n             Json::I64(v) => v.encode(e),\n             Json::U64(v) => v.encode(e),\n@@ -1013,20 +1013,20 @@ impl Encodable for Json {\n \n /// Create an `AsJson` wrapper which can be used to print a value as JSON\n /// on-the-fly via `write!`\n-pub fn as_json<T>(t: &T) -> AsJson<T> {\n+pub fn as_json<T>(t: &T) -> AsJson<'_, T> {\n     AsJson { inner: t }\n }\n \n /// Create an `AsPrettyJson` wrapper which can be used to print a value as JSON\n /// on-the-fly via `write!`\n-pub fn as_pretty_json<T>(t: &T) -> AsPrettyJson<T> {\n+pub fn as_pretty_json<T>(t: &T) -> AsPrettyJson<'_, T> {\n     AsPrettyJson { inner: t, indent: None }\n }\n \n impl Json {\n     /// Borrow this json object as a pretty object to generate a pretty\n     /// representation for it via `Display`.\n-    pub fn pretty(&self) -> PrettyJson {\n+    pub fn pretty(&self) -> PrettyJson<'_> {\n         PrettyJson { inner: self }\n     }\n \n@@ -1300,7 +1300,7 @@ impl Stack {\n     /// Provides access to the StackElement at a given index.\n     /// lower indices are at the bottom of the stack while higher indices are\n     /// at the top.\n-    pub fn get(&self, idx: usize) -> StackElement {\n+    pub fn get(&self, idx: usize) -> StackElement<'_> {\n         match self.stack[idx] {\n             InternalIndex(i) => StackElement::Index(i),\n             InternalKey(start, size) => {\n@@ -1311,8 +1311,8 @@ impl Stack {\n         }\n     }\n \n-    /// Compares this stack with an array of StackElements.\n-    pub fn is_equal_to(&self, rhs: &[StackElement]) -> bool {\n+    /// Compares this stack with an array of StackElement<'_>s.\n+    pub fn is_equal_to(&self, rhs: &[StackElement<'_>]) -> bool {\n         if self.stack.len() != rhs.len() { return false; }\n         for (i, r) in rhs.iter().enumerate() {\n             if self.get(i) != *r { return false; }\n@@ -1322,7 +1322,7 @@ impl Stack {\n \n     /// Returns true if the bottom-most elements of this stack are the same as\n     /// the ones passed as parameter.\n-    pub fn starts_with(&self, rhs: &[StackElement]) -> bool {\n+    pub fn starts_with(&self, rhs: &[StackElement<'_>]) -> bool {\n         if self.stack.len() < rhs.len() { return false; }\n         for (i, r) in rhs.iter().enumerate() {\n             if self.get(i) != *r { return false; }\n@@ -1332,7 +1332,7 @@ impl Stack {\n \n     /// Returns true if the top-most elements of this stack are the same as\n     /// the ones passed as parameter.\n-    pub fn ends_with(&self, rhs: &[StackElement]) -> bool {\n+    pub fn ends_with(&self, rhs: &[StackElement<'_>]) -> bool {\n         if self.stack.len() < rhs.len() { return false; }\n         let offset = self.stack.len() - rhs.len();\n         for (i, r) in rhs.iter().enumerate() {\n@@ -1342,7 +1342,7 @@ impl Stack {\n     }\n \n     /// Returns the top-most element (if any).\n-    pub fn top(&self) -> Option<StackElement> {\n+    pub fn top(&self) -> Option<StackElement<'_>> {\n         match self.stack.last() {\n             None => None,\n             Some(&InternalIndex(i)) => Some(StackElement::Index(i)),\n@@ -2115,7 +2115,7 @@ macro_rules! read_primitive {\n     }\n }\n \n-impl ::Decoder for Decoder {\n+impl crate::Decoder for Decoder {\n     type Error = DecoderError;\n \n     fn read_nil(&mut self) -> DecodeResult<()> {\n@@ -2172,7 +2172,7 @@ impl ::Decoder for Decoder {\n         Err(ExpectedError(\"single character string\".to_owned(), s.to_string()))\n     }\n \n-    fn read_str(&mut self) -> DecodeResult<Cow<str>> {\n+    fn read_str(&mut self) -> DecodeResult<Cow<'_, str>> {\n         expect!(self.pop(), String).map(Cow::Owned)\n     }\n \n@@ -2518,7 +2518,7 @@ impl<'a, 'b> fmt::Write for FormatShim<'a, 'b> {\n \n impl fmt::Display for Json {\n     /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = Encoder::new(&mut shim);\n         match self.encode(&mut encoder) {\n@@ -2530,7 +2530,7 @@ impl fmt::Display for Json {\n \n impl<'a> fmt::Display for PrettyJson<'a> {\n     /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = PrettyEncoder::new(&mut shim);\n         match self.inner.encode(&mut encoder) {\n@@ -2542,7 +2542,7 @@ impl<'a> fmt::Display for PrettyJson<'a> {\n \n impl<'a, T: Encodable> fmt::Display for AsJson<'a, T> {\n     /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = Encoder::new(&mut shim);\n         match self.inner.encode(&mut encoder) {\n@@ -2562,7 +2562,7 @@ impl<'a, T> AsPrettyJson<'a, T> {\n \n impl<'a, T: Encodable> fmt::Display for AsPrettyJson<'a, T> {\n     /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n         let mut encoder = PrettyEncoder::new(&mut shim);\n         if let Some(n) = self.indent {\n@@ -2587,7 +2587,7 @@ mod tests {\n     extern crate test;\n     use self::Animal::*;\n     use self::test::Bencher;\n-    use {Encodable, Decodable};\n+    use crate::{Encodable, Decodable};\n     use super::Json::*;\n     use super::ErrorCode::*;\n     use super::ParserError::*;\n@@ -3515,7 +3515,7 @@ mod tests {\n     #[test]\n     fn test_hashmap_with_enum_key() {\n         use std::collections::HashMap;\n-        use json;\n+        use crate::json;\n         #[derive(RustcEncodable, Eq, Hash, PartialEq, RustcDecodable, Debug)]\n         enum Enum {\n             Foo,"}, {"sha": "9b73a5e686ead544450bbde73070a226e70b570c", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=94c609ca9a9a71c21ba2cec2e495880f83661c7e", "patch": "@@ -10,6 +10,8 @@ Core encoding and decoding interfaces.\n        html_playground_url = \"https://play.rust-lang.org/\",\n        test(attr(allow(unused_variables), deny(warnings))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n #![feature(specialization)]\n@@ -22,8 +24,6 @@ pub use self::serialize::{Decoder, Encoder, Decodable, Encodable};\n pub use self::serialize::{SpecializationError, SpecializedEncoder, SpecializedDecoder};\n pub use self::serialize::{UseSpecializedEncodable, UseSpecializedDecodable};\n \n-extern crate smallvec;\n-\n mod serialize;\n mod collection_impls;\n \n@@ -34,5 +34,5 @@ pub mod opaque;\n pub mod leb128;\n \n mod rustc_serialize {\n-    pub use serialize::*;\n+    pub use crate::serialize::*;\n }"}, {"sha": "8636c202d66ef11d244dd117e0a7daf8f75b2a71", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=94c609ca9a9a71c21ba2cec2e495880f83661c7e", "patch": "@@ -1,6 +1,6 @@\n-use leb128::{self, read_signed_leb128, write_signed_leb128};\n+use crate::leb128::{self, read_signed_leb128, write_signed_leb128};\n use std::borrow::Cow;\n-use serialize;\n+use crate::serialize;\n \n // -----------------------------------------------------------------------------\n // Encoder\n@@ -312,7 +312,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     }\n \n     #[inline]\n-    fn read_str(&mut self) -> Result<Cow<str>, Self::Error> {\n+    fn read_str(&mut self) -> Result<Cow<'_, str>, Self::Error> {\n         let len = self.read_usize()?;\n         let s = ::std::str::from_utf8(&self.data[self.position..self.position + len]).unwrap();\n         self.position += len;\n@@ -328,7 +328,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n \n #[cfg(test)]\n mod tests {\n-    use serialize::{Encodable, Decodable};\n+    use crate::serialize::{Encodable, Decodable};\n     use std::fmt::Debug;\n     use super::{Encoder, Decoder};\n "}, {"sha": "977a36a220fdd9d22293d18910a6652bddd3581b", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94c609ca9a9a71c21ba2cec2e495880f83661c7e/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=94c609ca9a9a71c21ba2cec2e495880f83661c7e", "patch": "@@ -175,7 +175,7 @@ pub trait Decoder {\n     fn read_f64(&mut self) -> Result<f64, Self::Error>;\n     fn read_f32(&mut self) -> Result<f32, Self::Error>;\n     fn read_char(&mut self) -> Result<char, Self::Error>;\n-    fn read_str(&mut self) -> Result<Cow<str>, Self::Error>;\n+    fn read_str(&mut self) -> Result<Cow<'_, str>, Self::Error>;\n \n     // Compound types:\n     fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>"}]}