{"sha": "660326e9791d5caf3186b14521498c2584a494ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MDMyNmU5NzkxZDVjYWYzMTg2YjE0NTIxNDk4YzI1ODRhNDk0YWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-17T15:14:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-17T15:14:43Z"}, "message": "Auto merge of #70072 - Centril:rollup-722hooh, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #68746 (Make macro metavars respect (non-)hygiene)\n - #69688 (Move tidy check to mingw-check)\n - #69735 (bootstrap: Use hash to determine if sanitizers needs to be rebuilt)\n - #69922 (implement zeroed and uninitialized with MaybeUninit)\n - #69956 (Ensure HAS_FREE_LOCAL_NAMES is set for ReFree)\n - #70061 (Cosmetic fixes in documentation)\n - #70064 (Update books)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "81f9edf55bd2889477d871d7d50f4e75f13ccbb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81f9edf55bd2889477d871d7d50f4e75f13ccbb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/660326e9791d5caf3186b14521498c2584a494ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/660326e9791d5caf3186b14521498c2584a494ab", "html_url": "https://github.com/rust-lang/rust/commit/660326e9791d5caf3186b14521498c2584a494ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/660326e9791d5caf3186b14521498c2584a494ab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "html_url": "https://github.com/rust-lang/rust/commit/5e9ebf4da3522c479aea9c242cb3686f8d6afa78"}, {"sha": "36da5ee48e9fdab8c0d8fe7683741d0e8919d52e", "url": "https://api.github.com/repos/rust-lang/rust/commits/36da5ee48e9fdab8c0d8fe7683741d0e8919d52e", "html_url": "https://github.com/rust-lang/rust/commit/36da5ee48e9fdab8c0d8fe7683741d0e8919d52e"}], "stats": {"total": 434, "additions": 233, "deletions": 201}, "files": [{"sha": "d4d66abd520a12b10dd9146f53e69ec9d2c97e02", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 67, "deletions": 31, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -11,6 +11,7 @@\n use std::env;\n use std::ffi::OsString;\n use std::fs::{self, File};\n+use std::io;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n@@ -54,7 +55,6 @@ impl Step for Llvm {\n             }\n         }\n \n-        let llvm_info = &builder.in_tree_llvm_info;\n         let root = \"src/llvm-project/llvm\";\n         let out_dir = builder.llvm_out(target);\n         let mut llvm_config_ret_dir = builder.llvm_out(builder.config.build);\n@@ -65,40 +65,35 @@ impl Step for Llvm {\n \n         let build_llvm_config =\n             llvm_config_ret_dir.join(exe(\"llvm-config\", &*builder.config.build));\n-        let done_stamp = out_dir.join(\"llvm-finished-building\");\n \n-        if done_stamp.exists() {\n-            if builder.config.llvm_skip_rebuild {\n-                builder.info(\n-                    \"Warning: \\\n-                    Using a potentially stale build of LLVM; \\\n-                    This may not behave well.\",\n-                );\n-                return build_llvm_config;\n-            }\n+        let stamp = out_dir.join(\"llvm-finished-building\");\n+        let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n \n-            if let Some(llvm_commit) = llvm_info.sha() {\n-                let done_contents = t!(fs::read(&done_stamp));\n+        if builder.config.llvm_skip_rebuild && stamp.path.exists() {\n+            builder.info(\n+                \"Warning: \\\n+                Using a potentially stale build of LLVM; \\\n+                This may not behave well.\",\n+            );\n+            return build_llvm_config;\n+        }\n \n-                // If LLVM was already built previously and the submodule's commit didn't change\n-                // from the previous build, then no action is required.\n-                if done_contents == llvm_commit.as_bytes() {\n-                    return build_llvm_config;\n-                }\n-            } else {\n+        if stamp.is_done() {\n+            if stamp.hash.is_none() {\n                 builder.info(\n                     \"Could not determine the LLVM submodule commit hash. \\\n                      Assuming that an LLVM rebuild is not necessary.\",\n                 );\n                 builder.info(&format!(\n                     \"To force LLVM to rebuild, remove the file `{}`\",\n-                    done_stamp.display()\n+                    stamp.path.display()\n                 ));\n-                return build_llvm_config;\n             }\n+            return build_llvm_config;\n         }\n \n         builder.info(&format!(\"Building LLVM for {}\", target));\n+        t!(stamp.remove());\n         let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n \n@@ -271,7 +266,7 @@ impl Step for Llvm {\n \n         cfg.build();\n \n-        t!(fs::write(&done_stamp, llvm_info.sha().unwrap_or(\"\")));\n+        t!(stamp.write());\n \n         build_llvm_config\n     }\n@@ -584,17 +579,21 @@ impl Step for Sanitizers {\n             return runtimes;\n         }\n \n-        let done_stamp = out_dir.join(\"sanitizers-finished-building\");\n-        if done_stamp.exists() {\n-            builder.info(&format!(\n-                \"Assuming that sanitizers rebuild is not necessary. \\\n-                To force a rebuild, remove the file `{}`\",\n-                done_stamp.display()\n-            ));\n+        let stamp = out_dir.join(\"sanitizers-finished-building\");\n+        let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n+\n+        if stamp.is_done() {\n+            if stamp.hash.is_none() {\n+                builder.info(&format!(\n+                    \"Rebuild sanitizers by removing the file `{}`\",\n+                    stamp.path.display()\n+                ));\n+            }\n             return runtimes;\n         }\n \n         builder.info(&format!(\"Building sanitizers for {}\", self.target));\n+        t!(stamp.remove());\n         let _time = util::timeit(&builder);\n \n         let mut cfg = cmake::Config::new(&compiler_rt_dir);\n@@ -623,8 +622,7 @@ impl Step for Sanitizers {\n             cfg.build_target(&runtime.cmake_target);\n             cfg.build();\n         }\n-\n-        t!(fs::write(&done_stamp, b\"\"));\n+        t!(stamp.write());\n \n         runtimes\n     }\n@@ -689,3 +687,41 @@ fn supported_sanitizers(\n     }\n     result\n }\n+\n+struct HashStamp {\n+    path: PathBuf,\n+    hash: Option<Vec<u8>>,\n+}\n+\n+impl HashStamp {\n+    fn new(path: PathBuf, hash: Option<&str>) -> Self {\n+        HashStamp { path, hash: hash.map(|s| s.as_bytes().to_owned()) }\n+    }\n+\n+    fn is_done(&self) -> bool {\n+        match fs::read(&self.path) {\n+            Ok(h) => self.hash.as_deref().unwrap_or(b\"\") == h.as_slice(),\n+            Err(e) if e.kind() == io::ErrorKind::NotFound => false,\n+            Err(e) => {\n+                panic!(\"failed to read stamp file `{}`: {}\", self.path.display(), e);\n+            }\n+        }\n+    }\n+\n+    fn remove(&self) -> io::Result<()> {\n+        match fs::remove_file(&self.path) {\n+            Ok(()) => Ok(()),\n+            Err(e) => {\n+                if e.kind() == io::ErrorKind::NotFound {\n+                    Ok(())\n+                } else {\n+                    Err(e)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn write(&self) -> io::Result<()> {\n+        fs::write(&self.path, self.hash.as_deref().unwrap_or(b\"\"))\n+    }\n+}"}, {"sha": "e973ba2e33c64340ac3435a903d15d9ddbff5305", "filename": "src/ci/docker/mingw-check/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -25,4 +25,5 @@ ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n ENV SCRIPT python2.7 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu && \\\n            python2.7 ../x.py build --stage 0 src/tools/build-manifest && \\\n            python2.7 ../x.py test --stage 0 src/tools/compiletest && \\\n+           python2.7 ../x.py test src/tools/tidy && \\\n            /scripts/validate-toolstate.sh"}, {"sha": "4b5d5cac5163cc1f46cacbe3c9f806dcbe1adcb7", "filename": "src/ci/docker/x86_64-gnu-llvm-7/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -29,7 +29,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-llvm-link-shared \\\n       --set rust.thin-lto-import-instr-limit=10\n \n-ENV SCRIPT python2.7 ../x.py test src/tools/tidy && python2.7 ../x.py test\n+ENV SCRIPT python2.7 ../x.py test --exclude src/tools/tidy && python2.7 ../x.py test src/tools/tidy\n \n # The purpose of this container isn't to test with debug assertions and\n # this is run on all PRs, so let's get speedier builds by disabling these extra"}, {"sha": "d22a9c487c78095afc4584f1d9b4ec43529d713c", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -1 +1 @@\n-Subproject commit b81ffb7a6f4c5aaed92786e770e99db116aa4ebd\n+Subproject commit d22a9c487c78095afc4584f1d9b4ec43529d713c"}, {"sha": "e2f11fe4d6a5ecb471c70323197da43c70cb96b6", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -1 +1 @@\n-Subproject commit 559e09caa9661043744cf7af7bd88432d966f743\n+Subproject commit e2f11fe4d6a5ecb471c70323197da43c70cb96b6"}, {"sha": "cb369ae95ca36b841960182d26f6d5d9b2e3cc18", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -1 +1 @@\n-Subproject commit db57f899ea2a56a544c8d280cbf033438666273d\n+Subproject commit cb369ae95ca36b841960182d26f6d5d9b2e3cc18"}, {"sha": "f7ecbd80cbcdce94c02d257938d19260e37bb6ef", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -1027,46 +1027,8 @@ extern \"rust-intrinsic\" {\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"47809\")]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n-    /// Creates a value initialized to zero.\n-    ///\n-    /// `init` is unsafe because it returns a zeroed-out datum,\n-    /// which is unsafe unless `T` is `Copy`. Also, even if T is\n-    /// `Copy`, an all-zero value may not correspond to any legitimate\n-    /// state for the type in question.\n-    ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::zeroed`](../../std/mem/fn.zeroed.html).\n-    #[unstable(\n-        feature = \"core_intrinsics\",\n-        reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n-                         they should be used through stabilized interfaces \\\n-                         in the rest of the standard library\",\n-        issue = \"none\"\n-    )]\n-    #[rustc_deprecated(reason = \"superseded by MaybeUninit, removal planned\", since = \"1.38.0\")]\n-    pub fn init<T>() -> T;\n-\n-    /// Creates an uninitialized value.\n-    ///\n-    /// `uninit` is unsafe because there is no guarantee of what its\n-    /// contents are. In particular its drop-flag may be set to any\n-    /// state, which means it may claim either dropped or\n-    /// undropped. In the general case one must use `ptr::write` to\n-    /// initialize memory previous set to the result of `uninit`.\n-    ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::MaybeUninit`](../../std/mem/union.MaybeUninit.html).\n-    #[unstable(\n-        feature = \"core_intrinsics\",\n-        reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n-                         they should be used through stabilized interfaces \\\n-                         in the rest of the standard library\",\n-        issue = \"none\"\n-    )]\n-    #[rustc_deprecated(reason = \"superseded by MaybeUninit, removal planned\", since = \"1.38.0\")]\n-    pub fn uninit<T>() -> T;\n-\n     /// Moves a value out of scope without running drop glue.\n+    /// This exists solely for `mem::forget_unsized`; normal `forget` uses `ManuallyDrop` instead.\n     pub fn forget<T: ?Sized>(_: T);\n \n     /// Reinterprets the bits of a value of one type as another type."}, {"sha": "1cf2b40e930684defa1637666a01937287eb4665", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -490,7 +490,7 @@ pub const fn needs_drop<T>() -> bool {\n ///\n /// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n /// ```\n-#[inline]\n+#[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated_in_future)]\n #[allow(deprecated)]\n@@ -500,7 +500,7 @@ pub unsafe fn zeroed<T>() -> T {\n     intrinsics::assert_zero_valid::<T>();\n     #[cfg(bootstrap)]\n     intrinsics::panic_if_uninhabited::<T>();\n-    intrinsics::init()\n+    MaybeUninit::zeroed().assume_init()\n }\n \n /// Bypasses Rust's normal memory-initialization checks by pretending to\n@@ -525,7 +525,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// [uninit]: union.MaybeUninit.html#method.uninit\n /// [assume_init]: union.MaybeUninit.html#method.assume_init\n /// [inv]: union.MaybeUninit.html#initialization-invariant\n-#[inline]\n+#[inline(always)]\n #[rustc_deprecated(since = \"1.39.0\", reason = \"use `mem::MaybeUninit` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated_in_future)]\n@@ -536,7 +536,7 @@ pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::assert_uninit_valid::<T>();\n     #[cfg(bootstrap)]\n     intrinsics::panic_if_uninhabited::<T>();\n-    intrinsics::uninit()\n+    MaybeUninit::uninit().assume_init()\n }\n \n /// Swaps the values at two mutable locations, without deinitializing either one."}, {"sha": "d622d6fbe2c1f1db0632d3cc41b0fc9f1cd4fad6", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -554,24 +554,26 @@ bitflags! {\n         /// Does this have [ConstKind::Placeholder]?\n         const HAS_CT_PLACEHOLDER        = 1 << 8;\n \n+        /// `true` if there are \"names\" of regions and so forth\n+        /// that are local to a particular fn/inferctxt\n+        const HAS_FREE_LOCAL_REGIONS    = 1 << 9;\n+\n         /// `true` if there are \"names\" of types and regions and so forth\n         /// that are local to a particular fn\n         const HAS_FREE_LOCAL_NAMES      = TypeFlags::HAS_TY_PARAM.bits\n-                                        | TypeFlags::HAS_RE_PARAM.bits\n                                         | TypeFlags::HAS_CT_PARAM.bits\n                                         | TypeFlags::HAS_TY_INFER.bits\n-                                        | TypeFlags::HAS_RE_INFER.bits\n                                         | TypeFlags::HAS_CT_INFER.bits\n                                         | TypeFlags::HAS_TY_PLACEHOLDER.bits\n-                                        | TypeFlags::HAS_RE_PLACEHOLDER.bits\n-                                        | TypeFlags::HAS_CT_PLACEHOLDER.bits;\n+                                        | TypeFlags::HAS_CT_PLACEHOLDER.bits\n+                                        | TypeFlags::HAS_FREE_LOCAL_REGIONS.bits;\n \n         /// Does this have [Projection] or [UnnormalizedProjection]?\n-        const HAS_TY_PROJECTION         = 1 << 9;\n+        const HAS_TY_PROJECTION         = 1 << 10;\n         /// Does this have [Opaque]?\n-        const HAS_TY_OPAQUE             = 1 << 10;\n+        const HAS_TY_OPAQUE             = 1 << 11;\n         /// Does this have [ConstKind::Unevaluated]?\n-        const HAS_CT_PROJECTION         = 1 << 11;\n+        const HAS_CT_PROJECTION         = 1 << 12;\n \n         /// Could this type be normalized further?\n         const HAS_PROJECTION            = TypeFlags::HAS_TY_PROJECTION.bits\n@@ -580,21 +582,21 @@ bitflags! {\n \n         /// Present if the type belongs in a local type context.\n         /// Set for placeholders and inference variables that are not \"Fresh\".\n-        const KEEP_IN_LOCAL_TCX         = 1 << 12;\n+        const KEEP_IN_LOCAL_TCX         = 1 << 13;\n \n         /// Is an error type reachable?\n-        const HAS_TY_ERR                = 1 << 13;\n+        const HAS_TY_ERR                = 1 << 14;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but [ReLateBound] and [ReErased].\n-        const HAS_FREE_REGIONS          = 1 << 14;\n+        const HAS_FREE_REGIONS          = 1 << 15;\n \n         /// Does this have any [ReLateBound] regions? Used to check\n         /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND         = 1 << 15;\n+        const HAS_RE_LATE_BOUND         = 1 << 16;\n \n         /// Does this have any [ReErased] regions?\n-        const HAS_RE_ERASED             = 1 << 16;\n+        const HAS_RE_ERASED             = 1 << 17;\n \n         /// Flags representing the nominal content of a type,\n         /// computed by FlagsComputation. If you add a new nominal\n@@ -608,6 +610,7 @@ bitflags! {\n                                         | TypeFlags::HAS_TY_PLACEHOLDER.bits\n                                         | TypeFlags::HAS_RE_PLACEHOLDER.bits\n                                         | TypeFlags::HAS_CT_PLACEHOLDER.bits\n+                                        | TypeFlags::HAS_FREE_LOCAL_REGIONS.bits\n                                         | TypeFlags::HAS_TY_PROJECTION.bits\n                                         | TypeFlags::HAS_TY_OPAQUE.bits\n                                         | TypeFlags::HAS_CT_PROJECTION.bits"}, {"sha": "e265a2f8257fb77d50bb3ed29bac88ccad11bdf0", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -1743,42 +1743,42 @@ impl RegionKind {\n         }\n     }\n \n-    pub fn keep_in_local_tcx(&self) -> bool {\n-        if let ty::ReVar(..) = self { true } else { false }\n-    }\n-\n     pub fn type_flags(&self) -> TypeFlags {\n         let mut flags = TypeFlags::empty();\n \n-        if self.keep_in_local_tcx() {\n-            flags = flags | TypeFlags::KEEP_IN_LOCAL_TCX;\n-        }\n-\n         match *self {\n             ty::ReVar(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_INFER;\n+                flags = flags | TypeFlags::KEEP_IN_LOCAL_TCX;\n             }\n             ty::RePlaceholder(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_PLACEHOLDER;\n             }\n-            ty::ReLateBound(..) => {\n-                flags = flags | TypeFlags::HAS_RE_LATE_BOUND;\n-            }\n             ty::ReEarlyBound(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_PARAM;\n             }\n-            ty::ReEmpty(_) | ty::ReStatic | ty::ReFree { .. } | ty::ReScope { .. } => {\n+            ty::ReFree { .. } | ty::ReScope { .. } => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n             }\n-            ty::ReErased => {\n-                flags = flags | TypeFlags::HAS_RE_ERASED;\n+            ty::ReEmpty(_) | ty::ReStatic => {\n+                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }\n             ty::ReClosureBound(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }\n+            ty::ReLateBound(..) => {\n+                flags = flags | TypeFlags::HAS_RE_LATE_BOUND;\n+            }\n+            ty::ReErased => {\n+                flags = flags | TypeFlags::HAS_RE_ERASED;\n+            }\n         }\n \n         debug!(\"type_flags({:?}) = {:?}\", self, flags);"}, {"sha": "1ddfde526fabde55d0804af63fad2ccde0044fa2", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -195,26 +195,8 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     .unwrap();\n                 OperandRef::from_const(self, ty_name, ret_ty).immediate_or_packed_pair(self)\n             }\n-            \"init\" => {\n-                let ty = substs.type_at(0);\n-                if !self.layout_of(ty).is_zst() {\n-                    // Just zero out the stack slot.\n-                    // If we store a zero constant, LLVM will drown in vreg allocation for large\n-                    // data structures, and the generated code will be awful. (A telltale sign of\n-                    // this is large quantities of `mov [byte ptr foo],0` in the generated code.)\n-                    memset_intrinsic(\n-                        self,\n-                        false,\n-                        ty,\n-                        llresult,\n-                        self.const_u8(0),\n-                        self.const_usize(1),\n-                    );\n-                }\n-                return;\n-            }\n-            // Effectively no-ops\n-            \"uninit\" | \"forget\" => {\n+            // Effectively no-op\n+            \"forget\" => {\n                 return;\n             }\n             \"offset\" => {"}, {"sha": "582c26162ed6d29e2cfb72cef169c71f7c7a5073", "filename": "src/librustc_expand/mbe/macro_check.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -112,7 +112,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_session::lint::builtin::META_VARIABLE_MISUSE;\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::kw;\n-use rustc_span::{symbol::Ident, MultiSpan, Span};\n+use rustc_span::{symbol::MacroRulesNormalizedIdent, MultiSpan, Span};\n \n use smallvec::SmallVec;\n \n@@ -179,7 +179,7 @@ struct BinderInfo {\n }\n \n /// An environment of meta-variables to their binder information.\n-type Binders = FxHashMap<Ident, BinderInfo>;\n+type Binders = FxHashMap<MacroRulesNormalizedIdent, BinderInfo>;\n \n /// The state at which we entered a macro definition in the RHS of another macro definition.\n struct MacroState<'a> {\n@@ -245,6 +245,7 @@ fn check_binders(\n             if macros.is_empty() {\n                 sess.span_diagnostic.span_bug(span, \"unexpected MetaVar in lhs\");\n             }\n+            let name = MacroRulesNormalizedIdent::new(name);\n             // There are 3 possibilities:\n             if let Some(prev_info) = binders.get(&name) {\n                 // 1. The meta-variable is already bound in the current LHS: This is an error.\n@@ -264,6 +265,7 @@ fn check_binders(\n             if !macros.is_empty() {\n                 sess.span_diagnostic.span_bug(span, \"unexpected MetaVarDecl in nested lhs\");\n             }\n+            let name = MacroRulesNormalizedIdent::new(name);\n             if let Some(prev_info) = get_binder_info(macros, binders, name) {\n                 // Duplicate binders at the top-level macro definition are errors. The lint is only\n                 // for nested macro definitions.\n@@ -300,7 +302,7 @@ fn check_binders(\n fn get_binder_info<'a>(\n     mut macros: &'a Stack<'a, MacroState<'a>>,\n     binders: &'a Binders,\n-    name: Ident,\n+    name: MacroRulesNormalizedIdent,\n ) -> Option<&'a BinderInfo> {\n     binders.get(&name).or_else(|| macros.find_map(|state| state.binders.get(&name)))\n }\n@@ -331,6 +333,7 @@ fn check_occurrences(\n             sess.span_diagnostic.span_bug(span, \"unexpected MetaVarDecl in rhs\")\n         }\n         TokenTree::MetaVar(span, name) => {\n+            let name = MacroRulesNormalizedIdent::new(name);\n             check_ops_is_prefix(sess, node_id, macros, binders, ops, span, name);\n         }\n         TokenTree::Delimited(_, ref del) => {\n@@ -552,7 +555,7 @@ fn check_ops_is_prefix(\n     binders: &Binders,\n     ops: &Stack<'_, KleeneToken>,\n     span: Span,\n-    name: Ident,\n+    name: MacroRulesNormalizedIdent,\n ) {\n     let macros = macros.push(MacroState { binders, ops: ops.into() });\n     // Accumulates the stacks the operators of each state until (and including when) the\n@@ -598,7 +601,7 @@ fn ops_is_prefix(\n     sess: &ParseSess,\n     node_id: NodeId,\n     span: Span,\n-    name: Ident,\n+    name: MacroRulesNormalizedIdent,\n     binder_ops: &[KleeneToken],\n     occurrence_ops: &[KleeneToken],\n ) {"}, {"sha": "3b9158f444519f1cc64c80244b9c874789242444", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -76,13 +76,13 @@ use TokenTreeOrTokenTreeSlice::*;\n \n use crate::mbe::{self, TokenTree};\n \n-use rustc_ast::ast::{Ident, Name};\n+use rustc_ast::ast::Name;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n use rustc_ast_pretty::pprust;\n use rustc_parse::parser::{FollowedByType, Parser, PathStyle};\n use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n \n use rustc_errors::{FatalError, PResult};\n use rustc_span::Span;\n@@ -273,9 +273,10 @@ crate enum ParseResult<T> {\n     Error(rustc_span::Span, String),\n }\n \n-/// A `ParseResult` where the `Success` variant contains a mapping of `Ident`s to `NamedMatch`es.\n-/// This represents the mapping of metavars to the token trees they bind to.\n-crate type NamedParseResult = ParseResult<FxHashMap<Ident, NamedMatch>>;\n+/// A `ParseResult` where the `Success` variant contains a mapping of\n+/// `MacroRulesNormalizedIdent`s to `NamedMatch`es. This represents the mapping\n+/// of metavars to the token trees they bind to.\n+crate type NamedParseResult = ParseResult<FxHashMap<MacroRulesNormalizedIdent, NamedMatch>>;\n \n /// Count how many metavars are named in the given matcher `ms`.\n pub(super) fn count_names(ms: &[TokenTree]) -> usize {\n@@ -368,7 +369,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n         sess: &ParseSess,\n         m: &TokenTree,\n         res: &mut I,\n-        ret_val: &mut FxHashMap<Ident, NamedMatch>,\n+        ret_val: &mut FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     ) -> Result<(), (rustc_span::Span, String)> {\n         match *m {\n             TokenTree::Sequence(_, ref seq) => {\n@@ -386,7 +387,9 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                     return Err((span, \"missing fragment specifier\".to_string()));\n                 }\n             }\n-            TokenTree::MetaVarDecl(sp, bind_name, _) => match ret_val.entry(bind_name) {\n+            TokenTree::MetaVarDecl(sp, bind_name, _) => match ret_val\n+                .entry(MacroRulesNormalizedIdent::new(bind_name))\n+            {\n                 Vacant(spot) => {\n                     spot.insert(res.next().unwrap());\n                 }"}, {"sha": "2268c9b3854779d94ec34bfbc2d4c0efe359e866", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -22,7 +22,7 @@ use rustc_parse::Directory;\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, MacroRulesNormalizedIdent, Symbol};\n use rustc_span::Span;\n \n use log::debug;\n@@ -411,7 +411,7 @@ pub fn compile_declarative_macro(\n     let mut valid = true;\n \n     // Extract the arguments:\n-    let lhses = match argument_map[&lhs_nm] {\n+    let lhses = match argument_map[&MacroRulesNormalizedIdent::new(lhs_nm)] {\n         MatchedSeq(ref s) => s\n             .iter()\n             .map(|m| {\n@@ -428,7 +428,7 @@ pub fn compile_declarative_macro(\n         _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n     };\n \n-    let rhses = match argument_map[&rhs_nm] {\n+    let rhses = match argument_map[&MacroRulesNormalizedIdent::new(rhs_nm)] {\n         MatchedSeq(ref s) => s\n             .iter()\n             .map(|m| {"}, {"sha": "1b1093c9529f4813a3b0b5997c49a4153e2a2fe0", "filename": "src/librustc_expand/mbe/transcribe.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -2,14 +2,15 @@ use crate::base::ExtCtxt;\n use crate::mbe;\n use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n \n-use rustc_ast::ast::{Ident, MacCall};\n+use rustc_ast::ast::MacCall;\n use rustc_ast::mut_visit::{self, MutVisitor};\n use rustc_ast::token::{self, NtTT, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::pluralize;\n use rustc_span::hygiene::{ExpnId, Transparency};\n+use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n \n use smallvec::{smallvec, SmallVec};\n@@ -81,7 +82,7 @@ impl Iterator for Frame {\n /// Along the way, we do some additional error checking.\n pub(super) fn transcribe(\n     cx: &ExtCtxt<'_>,\n-    interp: &FxHashMap<Ident, NamedMatch>,\n+    interp: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     src: Vec<mbe::TokenTree>,\n     transparency: Transparency,\n ) -> TokenStream {\n@@ -223,9 +224,10 @@ pub(super) fn transcribe(\n             }\n \n             // Replace the meta-var with the matched token tree from the invocation.\n-            mbe::TokenTree::MetaVar(mut sp, mut ident) => {\n+            mbe::TokenTree::MetaVar(mut sp, mut orignal_ident) => {\n                 // Find the matched nonterminal from the macro invocation, and use it to replace\n                 // the meta-var.\n+                let ident = MacroRulesNormalizedIdent::new(orignal_ident);\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n                     if let MatchedNonterminal(ref nt) = cur_matched {\n                         // FIXME #2887: why do we apply a mark when matching a token tree meta-var\n@@ -249,9 +251,9 @@ pub(super) fn transcribe(\n                     // If we aren't able to match the meta-var, we push it back into the result but\n                     // with modified syntax context. (I believe this supports nested macros).\n                     marker.visit_span(&mut sp);\n-                    marker.visit_ident(&mut ident);\n+                    marker.visit_ident(&mut orignal_ident);\n                     result.push(TokenTree::token(token::Dollar, sp).into());\n-                    result.push(TokenTree::Token(Token::from_ast_ident(ident)).into());\n+                    result.push(TokenTree::Token(Token::from_ast_ident(orignal_ident)).into());\n                 }\n             }\n \n@@ -287,8 +289,8 @@ pub(super) fn transcribe(\n /// into the right place in nested matchers. If we attempt to descend too far, the macro writer has\n /// made a mistake, and we return `None`.\n fn lookup_cur_matched<'a>(\n-    ident: Ident,\n-    interpolations: &'a FxHashMap<Ident, NamedMatch>,\n+    ident: MacroRulesNormalizedIdent,\n+    interpolations: &'a FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     repeats: &[(usize, usize)],\n ) -> Option<&'a NamedMatch> {\n     interpolations.get(&ident).map(|matched| {\n@@ -316,7 +318,7 @@ enum LockstepIterSize {\n \n     /// A `MetaVar` with an actual `MatchedSeq`. The length of the match and the name of the\n     /// meta-var are returned.\n-    Constraint(usize, Ident),\n+    Constraint(usize, MacroRulesNormalizedIdent),\n \n     /// Two `Constraint`s on the same sequence had different lengths. This is an error.\n     Contradiction(String),\n@@ -360,7 +362,7 @@ impl LockstepIterSize {\n /// multiple nested matcher sequences.\n fn lockstep_iter_size(\n     tree: &mbe::TokenTree,\n-    interpolations: &FxHashMap<Ident, NamedMatch>,\n+    interpolations: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     repeats: &[(usize, usize)],\n ) -> LockstepIterSize {\n     use mbe::TokenTree;\n@@ -376,6 +378,7 @@ fn lockstep_iter_size(\n             })\n         }\n         TokenTree::MetaVar(_, name) | TokenTree::MetaVarDecl(_, name, _) => {\n+            let name = MacroRulesNormalizedIdent::new(name);\n             match lookup_cur_matched(name, interpolations, repeats) {\n                 Some(matched) => match matched {\n                     MatchedNonterminal(_) => LockstepIterSize::Unconstrained,"}, {"sha": "450e6b2e2d61194fee303c9f06bca87efa057ba6", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -98,10 +98,10 @@ pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n     /// we can validate it at that layout.\n-    /// `ret` stores the block we jump to on a normal return, while 'unwind'\n-    /// stores the block used for cleanup during unwinding\n+    /// `ret` stores the block we jump to on a normal return, while `unwind`\n+    /// stores the block used for cleanup during unwinding.\n     Goto { ret: Option<mir::BasicBlock>, unwind: Option<mir::BasicBlock> },\n-    /// Just do nohing: Used by Main and for the box_alloc hook in miri.\n+    /// Just do nothing: Used by Main and for the `box_alloc` hook in miri.\n     /// `cleanup` says whether locals are deallocated. Static computation\n     /// wants them leaked to intern what they need (and just throw away\n     /// the entire `ecx` when it is done)."}, {"sha": "19754c83038e21eee97ad52285d98b0de507ccce", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -983,6 +983,31 @@ impl fmt::Display for IdentPrinter {\n     }\n }\n \n+/// An newtype around `Ident` that calls [Ident::normalize_to_macro_rules] on\n+/// construction.\n+// FIXME(matthewj, petrochenkov) Use this more often, add a similar\n+// `ModernIdent` struct and use that as well.\n+#[derive(Copy, Clone, Eq, PartialEq, Hash)]\n+pub struct MacroRulesNormalizedIdent(Ident);\n+\n+impl MacroRulesNormalizedIdent {\n+    pub fn new(ident: Ident) -> Self {\n+        Self(ident.normalize_to_macro_rules())\n+    }\n+}\n+\n+impl fmt::Debug for MacroRulesNormalizedIdent {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&self.0, f)\n+    }\n+}\n+\n+impl fmt::Display for MacroRulesNormalizedIdent {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n /// An interned string.\n ///\n /// Internally, a `Symbol` is implemented as an index, and all operations"}, {"sha": "dd5e5726e83677b520bcebb14c77046e983bde65", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -150,8 +150,6 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             \"assert_inhabited\" | \"assert_zero_valid\" | \"assert_uninit_valid\" => {\n                 (1, Vec::new(), tcx.mk_unit())\n             }\n-            \"init\" => (1, Vec::new(), param(0)),\n-            \"uninit\" => (1, Vec::new(), param(0)),\n             \"forget\" => (1, vec![param(0)], tcx.mk_unit()),\n             \"transmute\" => (2, vec![param(0)], param(1)),\n             \"move_val_init\" => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),"}, {"sha": "09070f0f561a6eb53ce05f756af2b954a5cadaee", "filename": "src/test/ui/hygiene/macro-metavars-legacy.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Ftest%2Fui%2Fhygiene%2Fmacro-metavars-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Ftest%2Fui%2Fhygiene%2Fmacro-metavars-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fmacro-metavars-legacy.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -0,0 +1,29 @@\n+// Ensure macro metavariables are compared with legacy hygiene\n+\n+#![feature(rustc_attrs)]\n+\n+// run-pass\n+\n+macro_rules! make_mac {\n+    ( $($dollar:tt $arg:ident),+ ) => {\n+        macro_rules! mac {\n+            ( $($dollar $arg : ident),+ ) => {\n+                $( $dollar $arg )-+\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! show_hygiene {\n+    ( $dollar:tt $arg:ident ) => {\n+        make_mac!($dollar $arg, $dollar arg);\n+    }\n+}\n+\n+show_hygiene!( $arg );\n+\n+fn main() {\n+    let x = 5;\n+    let y = 3;\n+    assert_eq!(2, mac!(x, y));\n+}"}, {"sha": "e475b5728a098d468255d3a562e32bb29a69becc", "filename": "src/test/ui/hygiene/macro-metavars-transparent.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Ftest%2Fui%2Fhygiene%2Fmacro-metavars-transparent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Ftest%2Fui%2Fhygiene%2Fmacro-metavars-transparent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fmacro-metavars-transparent.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -0,0 +1,24 @@\n+// Ensure macro metavariables are not compared without removing transparent\n+// marks.\n+\n+#![feature(rustc_attrs)]\n+\n+// run-pass\n+\n+#[rustc_macro_transparency = \"transparent\"]\n+macro_rules! k {\n+    ($($s:tt)*) => {\n+        macro_rules! m {\n+            ($y:tt) => {\n+                $($s)*\n+            }\n+        }\n+    }\n+}\n+\n+k!(1 + $y);\n+\n+fn main() {\n+    let x = 2;\n+    assert_eq!(3, m!(x));\n+}"}, {"sha": "ce905572f2a8cee736a5e33f3e30514097e5bb50", "filename": "src/test/ui/init-large-type.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Ftest%2Fui%2Finit-large-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Ftest%2Fui%2Finit-large-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finit-large-type.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -O\n // run-pass\n \n #![allow(unused_must_use)]\n@@ -10,17 +11,13 @@\n \n #![feature(intrinsics)]\n \n-use std::thread;\n-\n-extern \"rust-intrinsic\" {\n-    pub fn init<T>() -> T;\n-}\n+use std::{mem, thread};\n \n const SIZE: usize = 1024 * 1024;\n \n fn main() {\n     // do the test in a new thread to avoid (spurious?) stack overflows\n     thread::spawn(|| {\n-        let _memory: [u8; SIZE] = unsafe { init() };\n+        let _memory: [u8; SIZE] = unsafe { mem::zeroed() };\n     }).join();\n }"}, {"sha": "3d65cfc2340926f6b7e07a08c4d23a6b24b15245", "filename": "src/test/ui/init-unsafe.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Finit-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Finit-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finit-unsafe.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -1,9 +0,0 @@\n-#![allow(deprecated)]\n-#![feature(core_intrinsics)]\n-\n-use std::intrinsics::{init};\n-\n-// Test that the `init` intrinsic is really unsafe\n-pub fn main() {\n-    let stuff = init::<isize>(); //~ ERROR call to unsafe function is unsafe\n-}"}, {"sha": "e1126316af34ee3ab4f0839bc18f80a663d3e47e", "filename": "src/test/ui/init-unsafe.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Finit-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Finit-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finit-unsafe.stderr?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -1,11 +0,0 @@\n-error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/init-unsafe.rs:8:17\n-   |\n-LL |     let stuff = init::<isize>();\n-   |                 ^^^^^^^^^^^^^^^ call to unsafe function\n-   |\n-   = note: consult the function's documentation for information on how to avoid undefined behavior\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0133`."}, {"sha": "b672f1ed26e8d8d1dfdd81f57fa2cf929fa5f42b", "filename": "src/test/ui/intrinsics/intrinsic-move-val.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -5,7 +5,6 @@\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n-        pub fn init<T>() -> T;\n         pub fn move_val_init<T>(dst: *mut T, src: T);\n     }\n }\n@@ -15,17 +14,17 @@ pub fn main() {\n         // sanity check\n         check_drops_state(0, None);\n \n-        let mut x: Box<D> = box D(1);\n-        assert_eq!(x.0, 1);\n+        let mut x: Option<Box<D>> = Some(box D(1));\n+        assert_eq!(x.as_ref().unwrap().0, 1);\n \n         // A normal overwrite, to demonstrate `check_drops_state`.\n-        x = box D(2);\n+        x = Some(box D(2));\n \n         // At this point, one destructor has run, because the\n         // overwrite of `x` drops its initial value.\n         check_drops_state(1, Some(1));\n \n-        let mut y: Box<D> = rusti::init();\n+        let mut y: Option<Box<D>> = std::mem::zeroed();\n \n         // An initial binding does not overwrite anything.\n         check_drops_state(1, Some(1));\n@@ -51,9 +50,9 @@ pub fn main() {\n         // during such a destructor call. We do so after the end of\n         // this scope.\n \n-        assert_eq!(y.0, 2);\n-        y.0 = 3;\n-        assert_eq!(y.0, 3);\n+        assert_eq!(y.as_ref().unwrap().0, 2);\n+        y.as_mut().unwrap().0 = 3;\n+        assert_eq!(y.as_ref().unwrap().0, 3);\n \n         check_drops_state(1, Some(1));\n     }"}, {"sha": "9555efb639b50480e93a11db16d009cd23fa1f64", "filename": "src/test/ui/intrinsics/intrinsic-uninit.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9ebf4da3522c479aea9c242cb3686f8d6afa78/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-uninit.rs?ref=5e9ebf4da3522c479aea9c242cb3686f8d6afa78", "patch": "@@ -1,13 +0,0 @@\n-// run-pass\n-// pretty-expanded FIXME #23616\n-\n-#![feature(intrinsics)]\n-\n-mod rusti {\n-    extern \"rust-intrinsic\" {\n-        pub fn uninit<T>() -> T;\n-    }\n-}\n-pub fn main() {\n-    let _a : isize = unsafe {rusti::uninit()};\n-}"}, {"sha": "2ccd3f88200e340259b982ca652dc7749c35522f", "filename": "src/test/ui/proc-macro/auxiliary/derive-unstable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/660326e9791d5caf3186b14521498c2584a494ab/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/660326e9791d5caf3186b14521498c2584a494ab/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-unstable.rs?ref=660326e9791d5caf3186b14521498c2584a494ab", "patch": "@@ -10,5 +10,5 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(Unstable)]\n pub fn derive(_input: TokenStream) -> TokenStream {\n \n-    \"unsafe fn foo() -> u32 { ::std::intrinsics::init() }\".parse().unwrap()\n+    \"unsafe fn foo() -> u32 { ::std::intrinsics::abort() }\".parse().unwrap()\n }"}]}