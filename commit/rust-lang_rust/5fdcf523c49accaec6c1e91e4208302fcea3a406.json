{"sha": "5fdcf523c49accaec6c1e91e4208302fcea3a406", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmZGNmNTIzYzQ5YWNjYWVjNmMxZTkxZTQyMDgzMDJmY2VhM2E0MDY=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-05-24T12:13:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-24T12:13:25Z"}, "message": "Merge pull request #742 from RalfJung/stacked-borrows-2\n\nadd more bugs we found to README; use consistent printing in Stacked Borrows", "tree": {"sha": "557b655ed2cd9ed254a3e9d6b28e04d6a6f0794c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/557b655ed2cd9ed254a3e9d6b28e04d6a6f0794c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fdcf523c49accaec6c1e91e4208302fcea3a406", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc59/lCRBK7hj4Ov3rIwAAdHIIAEGtXwhAqwlWF1KLvnO4q7Ho\n06s7GSlDKkEqk8WS8o0gTtmwd7x0l31FUYUMe38rIk/BtNCJg+7yLNIMU9nAmBVV\nCqJmXDtEcNYfM2xOJeOFiRiMCnEFFD6zdZ3RfesXyyPvR134RqBouftTPVOg3KsA\nC5KPlmUqeo3CEhRgDaP6JRoPnIm9pbJt65UTk0FC91fVFy+jBynxa5sknMtHA3yi\nAvsZaSW7tVf6oryYn9LB1ybB8GxwfC5M/PkcOHhTi87kB6w4k6CEudq2VuPu1hmF\n8BYBNdG0gfrzgybzys5YZNvX+ujC4MdBlisdtsUhec6/juxk5R14XWmZM2x8yQk=\n=dDwK\n-----END PGP SIGNATURE-----\n", "payload": "tree 557b655ed2cd9ed254a3e9d6b28e04d6a6f0794c\nparent 5bff6258a51dd64e083174efbb311115278fd186\nparent 21fb14dba1649ef8f2be612df2943fc9313781be\nauthor Oliver Scherer <github35764891676564198441@oli-obk.de> 1558700005 +0200\ncommitter GitHub <noreply@github.com> 1558700005 +0200\n\nMerge pull request #742 from RalfJung/stacked-borrows-2\n\nadd more bugs we found to README; use consistent printing in Stacked Borrows"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fdcf523c49accaec6c1e91e4208302fcea3a406", "html_url": "https://github.com/rust-lang/rust/commit/5fdcf523c49accaec6c1e91e4208302fcea3a406", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fdcf523c49accaec6c1e91e4208302fcea3a406/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bff6258a51dd64e083174efbb311115278fd186", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bff6258a51dd64e083174efbb311115278fd186", "html_url": "https://github.com/rust-lang/rust/commit/5bff6258a51dd64e083174efbb311115278fd186"}, {"sha": "21fb14dba1649ef8f2be612df2943fc9313781be", "url": "https://api.github.com/repos/rust-lang/rust/commits/21fb14dba1649ef8f2be612df2943fc9313781be", "html_url": "https://github.com/rust-lang/rust/commit/21fb14dba1649ef8f2be612df2943fc9313781be"}], "stats": {"total": 50, "additions": 26, "deletions": 24}, "files": [{"sha": "d3a06dea6d276c6bec5426f14ab89d7f258c83b4", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fdcf523c49accaec6c1e91e4208302fcea3a406/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/5fdcf523c49accaec6c1e91e4208302fcea3a406/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=5fdcf523c49accaec6c1e91e4208302fcea3a406", "patch": "@@ -317,6 +317,7 @@ Definite bugs found:\n * [`Debug for vec_deque::Iter` accessing uninitialized memory](https://github.com/rust-lang/rust/issues/53566)\n * [`From<&[T]> for Rc` creating a not sufficiently aligned reference](https://github.com/rust-lang/rust/issues/54908)\n * [`BTreeMap` creating a shared reference pointing to a too small allocation](https://github.com/rust-lang/rust/issues/54957)\n+* [`Vec::append` creating a dangling reference](https://github.com/rust-lang/rust/pull/61082)\n * [Futures turning a shared reference into a mutable one](https://github.com/rust-lang/rust/pull/56319)\n * [`str` turning a shared reference into a mutable one](https://github.com/rust-lang/rust/pull/58200)\n * [`rand` performing unaligned reads](https://github.com/rust-random/rand/issues/779)\n@@ -326,6 +327,7 @@ Violations of Stacked Borrows found that are likely bugs (but Stacked Borrows is\n * [`VecDeque` creating overlapping mutable references](https://github.com/rust-lang/rust/pull/56161)\n * [`BTreeMap` creating mutable references that overlap with shared references](https://github.com/rust-lang/rust/pull/58431)\n * [`LinkedList` creating overlapping mutable references](https://github.com/rust-lang/rust/pull/60072)\n+* [`Vec::push` invalidating existing references into the vector](https://github.com/rust-lang/rust/issues/60847)\n \n ## License\n "}, {"sha": "f997e6316435ab8becacdd3c963a0b0fe005dc3d", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5fdcf523c49accaec6c1e91e4208302fcea3a406/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fdcf523c49accaec6c1e91e4208302fcea3a406/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=5fdcf523c49accaec6c1e91e4208302fcea3a406", "patch": "@@ -18,16 +18,16 @@ pub type PtrId = NonZeroU64;\n pub type CallId = NonZeroU64;\n \n /// Tracking pointer provenance\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n pub enum Tag {\n     Tagged(PtrId),\n     Untagged,\n }\n \n-impl fmt::Display for Tag {\n+impl fmt::Debug for Tag {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n-            Tag::Tagged(id) => write!(f, \"{}\", id),\n+            Tag::Tagged(id) => write!(f, \"<{}>\", id),\n             Tag::Untagged => write!(f, \"<untagged>\"),\n         }\n     }\n@@ -48,7 +48,7 @@ pub enum Permission {\n }\n \n /// An item in the per-location borrow stack.\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Item {\n     /// The permission this item grants.\n     perm: Permission,\n@@ -58,9 +58,9 @@ pub struct Item {\n     protector: Option<CallId>,\n }\n \n-impl fmt::Display for Item {\n+impl fmt::Debug for Item {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"[{:?} for {}\", self.perm, self.tag)?;\n+        write!(f, \"[{:?} for {:?}\", self.perm, self.tag)?;\n         if let Some(call) = self.protector {\n             write!(f, \" (call {})\", call)?;\n         }\n@@ -99,7 +99,7 @@ pub struct GlobalState {\n pub type MemoryState = Rc<RefCell<GlobalState>>;\n \n /// Indicates which kind of access is being performed.\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n pub enum AccessKind {\n     Read,\n     Write,\n@@ -108,16 +108,16 @@ pub enum AccessKind {\n impl fmt::Display for AccessKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n-            AccessKind::Read => write!(f, \"read\"),\n-            AccessKind::Write => write!(f, \"write\"),\n+            AccessKind::Read => write!(f, \"read access\"),\n+            AccessKind::Write => write!(f, \"write access\"),\n         }\n     }\n }\n \n /// Indicates which kind of reference is being created.\n /// Used by high-level `reborrow` to compute which permissions to grant to the\n /// new pointer.\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n pub enum RefKind {\n     /// `&mut` and `Box`.\n     Unique { two_phase: bool },\n@@ -261,12 +261,12 @@ impl<'tcx> Stack {\n             if global.is_active(call) {\n                 if let Some(tag) = tag {\n                     return err!(MachineError(format!(\n-                        \"not granting access to tag {} because incompatible item is protected: {}\",\n+                        \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n                         tag, item\n                     )));\n                 } else {\n                     return err!(MachineError(format!(\n-                        \"deallocating while item is protected: {}\", item\n+                        \"deallocating while item is protected: {:?}\", item\n                     )));\n                 }\n             }\n@@ -287,7 +287,7 @@ impl<'tcx> Stack {\n         // Step 1: Find granting item.\n         let granting_idx = self.find_granting(access, tag)\n             .ok_or_else(|| InterpError::MachineError(format!(\n-                \"no item granting {} access to tag {} found in borrow stack\",\n+                \"no item granting {} to tag {:?} found in borrow stack\",\n                 access, tag,\n             )))?;\n \n@@ -298,7 +298,7 @@ impl<'tcx> Stack {\n             // pointers become invalid on write accesses (ensures F2a, and ensures U2 for write accesses).\n             let first_incompatible_idx = self.find_first_write_incompaible(granting_idx);\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n-                trace!(\"access: popping item {}\", item);\n+                trace!(\"access: popping item {:?}\", item);\n                 Stack::check_protector(&item, Some(tag), global)?;\n             }\n         } else {\n@@ -313,7 +313,7 @@ impl<'tcx> Stack {\n             for idx in (granting_idx+1 .. self.borrows.len()).rev() {\n                 let item = &mut self.borrows[idx];\n                 if item.perm == Permission::Unique {\n-                    trace!(\"access: disabling item {}\", item);\n+                    trace!(\"access: disabling item {:?}\", item);\n                     Stack::check_protector(item, Some(tag), global)?;\n                     item.perm = Permission::Disabled;\n                 }\n@@ -334,7 +334,7 @@ impl<'tcx> Stack {\n         // Step 1: Find granting item.\n         self.find_granting(AccessKind::Write, tag)\n             .ok_or_else(|| InterpError::MachineError(format!(\n-                \"no item granting write access for deallocation to tag {} found in borrow stack\",\n+                \"no item granting write access for deallocation to tag {:?} found in borrow stack\",\n                 tag,\n             )))?;\n \n@@ -383,7 +383,7 @@ impl<'tcx> Stack {\n         // We use that to determine where to put the new item.\n         let granting_idx = self.find_granting(access, derived_from)\n             .ok_or_else(|| InterpError::MachineError(format!(\n-                \"trying to reborrow for {:?}, but parent tag {} does not have an appropriate item in the borrow stack\", new.perm, derived_from,\n+                \"trying to reborrow for {:?}, but parent tag {:?} does not have an appropriate item in the borrow stack\", new.perm, derived_from,\n             )))?;\n \n         // Compute where to put the new item.\n@@ -412,9 +412,9 @@ impl<'tcx> Stack {\n         // Put the new item there. As an optimization, deduplicate if it is equal to one of its new neighbors.\n         if self.borrows[new_idx-1] == new || self.borrows.get(new_idx) == Some(&new) {\n             // Optimization applies, done.\n-            trace!(\"reborrow: avoiding adding redundant item {}\", new);\n+            trace!(\"reborrow: avoiding adding redundant item {:?}\", new);\n         } else {\n-            trace!(\"reborrow: adding item {}\", new);\n+            trace!(\"reborrow: adding item {:?}\", new);\n             self.borrows.insert(new_idx, new);\n         }\n \n@@ -497,7 +497,7 @@ impl AllocationExtra<Tag> for Stacks {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"read access with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n+        trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n         alloc.extra.for_each(ptr, size, |stack, global| {\n             stack.access(AccessKind::Read, ptr.tag, global)?;\n             Ok(())\n@@ -510,7 +510,7 @@ impl AllocationExtra<Tag> for Stacks {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"write access with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n+        trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n         alloc.extra.for_each(ptr, size, |stack, global| {\n             stack.access(AccessKind::Write, ptr.tag, global)?;\n             Ok(())\n@@ -523,7 +523,7 @@ impl AllocationExtra<Tag> for Stacks {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"deallocation with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n+        trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n         alloc.extra.for_each(ptr, size, |stack, global| {\n             stack.dealloc(ptr.tag, global)\n         })\n@@ -545,8 +545,8 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let this = self.eval_context_mut();\n         let protector = if protect { Some(this.frame().extra) } else { None };\n         let ptr = place.ptr.to_ptr()?;\n-        trace!(\"reborrow: {} reference {} derived from {} (pointee {}): {:?}, size {}\",\n-            kind, new_tag, ptr.tag, place.layout.ty, ptr, size.bytes());\n+        trace!(\"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n+            kind, new_tag, ptr.tag, place.layout.ty, ptr.erase_tag(), size.bytes());\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n         let alloc = this.memory().get(ptr.alloc_id)?;"}]}