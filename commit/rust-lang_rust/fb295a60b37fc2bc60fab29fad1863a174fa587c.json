{"sha": "fb295a60b37fc2bc60fab29fad1863a174fa587c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMjk1YTYwYjM3ZmMyYmM2MGZhYjI5ZmFkMTg2M2ExNzRmYTU4N2M=", "commit": {"author": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-06-28T05:04:15Z"}, "committer": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-06-30T09:40:17Z"}, "message": "Remove NormalizingClosureTyper", "tree": {"sha": "980d570d48b321d96e3d940919813c4f9c5bcf4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/980d570d48b321d96e3d940919813c4f9c5bcf4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb295a60b37fc2bc60fab29fad1863a174fa587c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb295a60b37fc2bc60fab29fad1863a174fa587c", "html_url": "https://github.com/rust-lang/rust/commit/fb295a60b37fc2bc60fab29fad1863a174fa587c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb295a60b37fc2bc60fab29fad1863a174fa587c/comments", "author": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f13a3f361384c278041c95e9a2ba9975e6cde71", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f13a3f361384c278041c95e9a2ba9975e6cde71", "html_url": "https://github.com/rust-lang/rust/commit/0f13a3f361384c278041c95e9a2ba9975e6cde71"}], "stats": {"total": 298, "additions": 204, "deletions": 94}, "files": [{"sha": "91fee77f0a7a39ab1b1c73701018407d8fa74f47", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 160, "deletions": 4, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=fb295a60b37fc2bc60fab29fad1863a174fa587c", "patch": "@@ -19,6 +19,7 @@ pub use self::TypeOrigin::*;\n pub use self::ValuePairs::*;\n pub use self::fixup_err::*;\n pub use middle::ty::IntVarValue;\n+use middle::ty::ClosureTyper;\n pub use self::freshen::TypeFreshener;\n pub use self::region_inference::GenericKind;\n \n@@ -29,7 +30,8 @@ use middle::region::CodeExtent;\n use middle::subst;\n use middle::subst::Substs;\n use middle::subst::Subst;\n-use middle::traits;\n+use middle::traits::{self, FulfillmentContext, Normalized, MiscObligation,\n+                     SelectionContext, ObligationCause};\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n@@ -39,7 +41,7 @@ use std::cell::{RefCell, Ref};\n use std::fmt;\n use syntax::ast;\n use syntax::codemap;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n use util::nodemap::{FnvHashMap, NodeMap};\n \n use self::combine::CombineFields;\n@@ -354,6 +356,14 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n     }\n }\n \n+pub fn normalizing_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n+                                        tables: &'a RefCell<ty::Tables<'tcx>>)\n+                                        -> InferCtxt<'a, 'tcx> {\n+    let mut infcx = new_infer_ctxt(tcx, tables, None, false);\n+    infcx.normalize = true;\n+    infcx\n+}\n+\n /// Computes the least upper-bound of `a` and `b`. If this is not possible, reports an error and\n /// returns ty::err.\n pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n@@ -557,7 +567,8 @@ impl<'a, 'tcx> ty::ClosureTyper<'tcx> for InferCtxt<'a, 'tcx> {\n             // the substitutions in `substs` are already monomorphized,\n             // but we still must normalize associated types\n             // normalize_associated_type(self.param_env.tcx, &closure_ty)\n-            panic!(\"see issue 26597: fufillment context refactor must occur\")\n+            normalize_associated_type(&self.tcx, &closure_ty)\n+            // panic!(\"see issue 26597: fufillment context refactor must occur\")\n         } else {\n             closure_ty\n         }\n@@ -579,13 +590,158 @@ impl<'a, 'tcx> ty::ClosureTyper<'tcx> for InferCtxt<'a, 'tcx> {\n             // the substitutions in `substs` are already monomorphized,\n             // but we still must normalize associated types\n             // monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n-            panic!(\"see issue 26597: fufillment context refactor must occur\")\n+            // panic!(\"see issue 26597: fufillment context refactor must occur\")\n+            normalize_associated_type(&self.tcx, &result)\n         } else {\n             result\n         }\n     }\n }\n \n+pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n+    where T : TypeFoldable<'tcx> + HasTypeFlags\n+{\n+    debug!(\"normalize_associated_type(t={:?})\", value);\n+\n+    let value = erase_regions(tcx, value);\n+\n+    if !value.has_projection_types() {\n+        return value;\n+    }\n+\n+    let infcx = new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &infcx);\n+    let cause = traits::ObligationCause::dummy();\n+    let traits::Normalized { value: result, obligations } =\n+        traits::normalize(&mut selcx, cause, &value);\n+\n+    debug!(\"normalize_associated_type: result={:?} obligations={:?}\",\n+           result,\n+           obligations);\n+\n+    let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n+\n+    for obligation in obligations {\n+        fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+    }\n+\n+    let result = drain_fulfillment_cx_or_panic(DUMMY_SP, &infcx, &mut fulfill_cx, &result);\n+\n+    result\n+}\n+\n+pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n+                                                infcx: &InferCtxt<'a,'tcx>,\n+                                                fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                                result: &T)\n+                                                -> T\n+    where T : TypeFoldable<'tcx>\n+{\n+    match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n+        Ok(v) => v,\n+        Err(errors) => {\n+            infcx.tcx.sess.span_bug(\n+                span,\n+                &format!(\"Encountered errors `{:?}` fulfilling during trans\",\n+                         errors));\n+        }\n+    }\n+}\n+\n+/// Finishes processes any obligations that remain in the fulfillment\n+/// context, and then \"freshens\" and returns `result`. This is\n+/// primarily used during normalization and other cases where\n+/// processing the obligations in `fulfill_cx` may cause type\n+/// inference variables that appear in `result` to be unified, and\n+/// hence we need to process those obligations to get the complete\n+/// picture of the type.\n+pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n+                                       fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                       result: &T)\n+                                       -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n+    where T : TypeFoldable<'tcx>\n+{\n+    debug!(\"drain_fulfillment_cx(result={:?})\",\n+           result);\n+    // this is stupid but temporary\n+    let typer: &ClosureTyper<'tcx> = infcx;\n+    // In principle, we only need to do this so long as `result`\n+    // contains unbound type parameters. It could be a slight\n+    // optimization to stop iterating early.\n+    match fulfill_cx.select_all_or_error(infcx, typer) {\n+        Ok(()) => { }\n+        Err(errors) => {\n+            return Err(errors);\n+        }\n+    }\n+\n+    // Use freshen to simultaneously replace all type variables with\n+    // their bindings and replace all regions with 'static.  This is\n+    // sort of overkill because we do not expect there to be any\n+    // unbound type variables, hence no `TyFresh` types should ever be\n+    // inserted.\n+    Ok(result.fold_with(&mut infcx.freshener()))\n+}\n+\n+/// Returns an equivalent value with all free regions removed (note\n+/// that late-bound regions remain, because they are important for\n+/// subtyping, but they are anonymized and normalized as well). This\n+/// is a stronger, caching version of `ty_fold::erase_regions`.\n+pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n+    where T : TypeFoldable<'tcx>\n+{\n+    let value1 = value.fold_with(&mut RegionEraser(cx));\n+    debug!(\"erase_regions({:?}) = {:?}\",\n+           value, value1);\n+    return value1;\n+\n+    struct RegionEraser<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n+\n+    impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n+        fn tcx(&self) -> &ty::ctxt<'tcx> { self.0 }\n+\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n+                None => {}\n+                Some(u) => return u\n+            }\n+\n+            let t_norm = ty_fold::super_fold_ty(self, ty);\n+            self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n+            return t_norm;\n+        }\n+\n+        fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+            where T : TypeFoldable<'tcx>\n+        {\n+            let u = self.tcx().anonymize_late_bound_regions(t);\n+            ty_fold::super_fold_binder(self, &u)\n+        }\n+\n+        fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+            // because late-bound regions affect subtyping, we can't\n+            // erase the bound/free distinction, but we can replace\n+            // all free regions with 'static.\n+            //\n+            // Note that we *CAN* replace early-bound regions -- the\n+            // type system never \"sees\" those, they get substituted\n+            // away. In trans, they will always be erased to 'static\n+            // whenever a substitution occurs.\n+            match r {\n+                ty::ReLateBound(..) => r,\n+                _ => ty::ReStatic\n+            }\n+        }\n+\n+        fn fold_substs(&mut self,\n+                       substs: &subst::Substs<'tcx>)\n+                       -> subst::Substs<'tcx> {\n+            subst::Substs { regions: subst::ErasedRegions,\n+                            types: substs.types.fold_with(self) }\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())"}, {"sha": "b96dcf940a89555db637892eb2ed06421ce9cb2e", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=fb295a60b37fc2bc60fab29fad1863a174fa587c", "patch": "@@ -50,6 +50,7 @@ use std::rc::Rc;\n use llvm::{ValueRef, True, IntEQ, IntNE};\n use back::abi::FAT_PTR_ADDR;\n use middle::subst;\n+use middle::infer;\n use middle::ty::{self, Ty, ClosureTyper};\n use middle::ty::Disr;\n use syntax::ast;\n@@ -223,8 +224,8 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n         }\n         ty::TyClosure(def_id, substs) => {\n-            let typer = NormalizingClosureTyper::new(cx.tcx());\n-            let upvars = typer.closure_upvars(def_id, substs).unwrap();\n+            let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n+            let upvars = infcx.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n             Univariant(mk_struct(cx, &upvar_types[..], false, t), 0)\n         }\n@@ -443,8 +444,8 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // Perhaps one of the upvars of this struct is non-zero\n         // Let's recurse and find out!\n         ty::TyClosure(def_id, substs) => {\n-            let typer = NormalizingClosureTyper::new(tcx);\n-            let upvars = typer.closure_upvars(def_id, substs).unwrap();\n+            let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n+            let upvars = infcx.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n \n             for (j, &ty) in upvar_types.iter().enumerate() {"}, {"sha": "fd704ed2d378bcfd8ed5c19572fb7765f89f9019", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=fb295a60b37fc2bc60fab29fad1863a174fa587c", "patch": "@@ -12,6 +12,7 @@\n use libc::{c_uint, c_ulonglong};\n use llvm::{self, ValueRef, AttrHelper};\n use middle::ty::{self, ClosureTyper};\n+use middle::infer;\n use session::config::NoDebugInfo;\n use syntax::abi;\n use syntax::ast;\n@@ -145,8 +146,8 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n     let (fn_sig, abi, env_ty) = match fn_type.sty {\n         ty::TyBareFn(_, ref f) => (&f.sig, f.abi, None),\n         ty::TyClosure(closure_did, substs) => {\n-            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n-            function_type = typer.closure_type(closure_did, substs);\n+            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+            function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n             (&function_type.sig, abi::RustCall, Some(self_type))\n         }"}, {"sha": "088df7288bec5f38440128be6f7cca13c8cde563", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=fb295a60b37fc2bc60fab29fad1863a174fa587c", "patch": "@@ -37,6 +37,7 @@ use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n use middle::cfg;\n+use middle::infer;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n use middle::subst::Substs;\n@@ -434,8 +435,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n       }\n       ty::TyClosure(def_id, substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          let typer = common::NormalizingClosureTyper::new(cx.tcx());\n-          let upvars = typer.closure_upvars(def_id, substs).unwrap();\n+          let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n+          let upvars = infcx.closure_upvars(def_id, substs).unwrap();\n           for (i, upvar) in upvars.iter().enumerate() {\n               let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n               cx = f(cx, llupvar, upvar.ty);"}, {"sha": "c9bab6861ca05a80222fab25f771f060fa0c0155", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=fb295a60b37fc2bc60fab29fad1863a174fa587c", "patch": "@@ -12,6 +12,7 @@ use arena::TypedArena;\n use back::link::{self, mangle_internal_name_by_path_and_seq};\n use llvm::{ValueRef, get_params};\n use middle::mem_categorization::Typer;\n+use middle::infer;\n use trans::adt;\n use trans::attributes;\n use trans::base::*;\n@@ -214,8 +215,9 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // takes the same set of type arguments as the enclosing fn, and\n     // this function (`trans_closure`) is invoked at the point\n     // of the closure expression.\n-    let typer = NormalizingClosureTyper::new(tcx);\n-    let function_type = typer.closure_type(closure_id, param_substs);\n+\n+    let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+    let function_type = infcx.closure_type(closure_id, param_substs);\n \n     let freevars: Vec<ty::Freevar> =\n         tcx.with_freevars(id, |fv| fv.iter().cloned().collect());\n@@ -358,7 +360,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n            ccx.tn().val_to_string(llreffn));\n \n     let tcx = ccx.tcx();\n-    let typer = NormalizingClosureTyper::new(tcx);\n+    let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n \n     // Find a version of the closure type. Substitute static for the\n     // region since it doesn't really matter.\n@@ -367,7 +369,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), closure_ty);\n \n     // Make a version with the type of by-ref closure.\n-    let ty::ClosureTy { unsafety, abi, mut sig } = typer.closure_type(closure_def_id, substs);\n+    let ty::ClosureTy { unsafety, abi, mut sig } = infcx.closure_type(closure_def_id, substs);\n     sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n     let llref_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n                                                                abi: abi,"}, {"sha": "1fc68790db07ac696c15807bac2c8be0b9cd621a", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 15, "deletions": 66, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=fb295a60b37fc2bc60fab29fad1863a174fa587c", "patch": "@@ -24,6 +24,7 @@ use middle::infer;\n use middle::lang_items::LangItem;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Typer;\n+use middle::ty::ClosureTyper;\n use middle::region;\n use middle::subst::{self, Substs};\n use trans::base;\n@@ -642,26 +643,26 @@ impl<'blk, 'tcx> ty::ClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n                     def_id: ast::DefId)\n                     -> Option<ty::ClosureKind>\n     {\n-        let typer = NormalizingClosureTyper::new(self.tcx());\n-        typer.closure_kind(def_id)\n+        let infcx = infer::normalizing_infer_ctxt(self.tcx(), &self.tcx().tables);\n+        infcx.closure_kind(def_id)\n     }\n \n     fn closure_type(&self,\n                     def_id: ast::DefId,\n                     substs: &subst::Substs<'tcx>)\n                     -> ty::ClosureTy<'tcx>\n     {\n-        let typer = NormalizingClosureTyper::new(self.tcx());\n-        typer.closure_type(def_id, substs)\n+        let infcx = infer::normalizing_infer_ctxt(self.tcx(), &self.tcx().tables);\n+        infcx.closure_type(def_id, substs)\n     }\n \n     fn closure_upvars(&self,\n                       def_id: ast::DefId,\n                       substs: &Substs<'tcx>)\n                       -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n     {\n-        let typer = NormalizingClosureTyper::new(self.tcx());\n-        typer.closure_upvars(def_id, substs)\n+        let infcx = infer::new_infer_ctxt(self.tcx(), &self.tcx().tables, None, true);\n+        infcx.closure_upvars(def_id, substs)\n     }\n }\n \n@@ -957,12 +958,12 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            trait_ref, trait_ref.def_id());\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let typer = NormalizingClosureTyper::new(tcx);\n-    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &infcx);\n+\n     let obligation =\n         traits::Obligation::new(traits::ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n                                 trait_ref.to_poly_trait_predicate());\n@@ -1019,9 +1020,8 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            predicates);\n \n     let tcx = ccx.tcx();\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n-    let typer = NormalizingClosureTyper::new(tcx);\n-    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &infcx);\n     let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: predicates, obligations } =\n@@ -1036,57 +1036,6 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()).is_ok()\n }\n \n-// NOTE: here is another use of parameter environment without an InferCtxt,\n-// this is obviously related to the typer interface requiring a parameter env.\n-// We should pay attention to this when refactoring\n-// - @jroesch\n-pub struct NormalizingClosureTyper<'a,'tcx:'a> {\n-    param_env: ty::ParameterEnvironment<'a, 'tcx>\n-}\n-\n-impl<'a,'tcx> NormalizingClosureTyper<'a,'tcx> {\n-    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingClosureTyper<'a,'tcx> {\n-        // Parameter environment is used to give details about type parameters,\n-        // but since we are in trans, everything is fully monomorphized.\n-        NormalizingClosureTyper { param_env: tcx.empty_parameter_environment() }\n-    }\n-}\n-\n-impl<'a,'tcx> ty::ClosureTyper<'tcx> for NormalizingClosureTyper<'a,'tcx> {\n-    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n-        &self.param_env\n-    }\n-\n-    fn closure_kind(&self,\n-                    def_id: ast::DefId)\n-                    -> Option<ty::ClosureKind>\n-    {\n-        self.param_env.closure_kind(def_id)\n-    }\n-\n-    fn closure_type(&self,\n-                    def_id: ast::DefId,\n-                    substs: &subst::Substs<'tcx>)\n-                    -> ty::ClosureTy<'tcx>\n-    {\n-        // the substitutions in `substs` are already monomorphized,\n-        // but we still must normalize associated types\n-        let closure_ty = self.param_env.tcx.closure_type(def_id, substs);\n-        monomorphize::normalize_associated_type(self.param_env.tcx, &closure_ty)\n-    }\n-\n-    fn closure_upvars(&self,\n-                      def_id: ast::DefId,\n-                      substs: &Substs<'tcx>)\n-                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n-    {\n-        // the substitutions in `substs` are already monomorphized,\n-        // but we still must normalize associated types\n-        let result = self.param_env.closure_upvars(def_id, substs);\n-        monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n-    }\n-}\n-\n pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n                                                 infcx: &infer::InferCtxt<'a,'tcx>,\n                                                 fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n@@ -1120,12 +1069,12 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &infer::InferCtxt<'a,'tcx>,\n {\n     debug!(\"drain_fulfillment_cx(result={:?})\",\n            result);\n-\n+    // this is stupid but temporary\n+    let typer: &ClosureTyper<'tcx> = infcx;\n     // In principle, we only need to do this so long as `result`\n     // contains unbound type parameters. It could be a slight\n     // optimization to stop iterating early.\n-    let typer = NormalizingClosureTyper::new(infcx.tcx);\n-    match fulfill_cx.select_all_or_error(infcx, &typer) {\n+    match fulfill_cx.select_all_or_error(infcx, typer) {\n         Ok(()) => { }\n         Err(errors) => {\n             return Err(errors);"}, {"sha": "12892c87b468764befce87bde4ce6dca02bfb249", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=fb295a60b37fc2bc60fab29fad1863a174fa587c", "patch": "@@ -26,9 +26,10 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n use metadata::csearch;\n use middle::pat_util;\n use middle::subst::{self, Substs};\n+use middle::infer;\n use rustc::ast_map;\n use trans::{type_of, adt, machine, monomorphize};\n-use trans::common::{self, CrateContext, FunctionContext, NormalizingClosureTyper, Block};\n+use trans::common::{self, CrateContext, FunctionContext, Block};\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::type_::Type;\n use middle::ty::{self, Ty, ClosureTyper};\n@@ -287,8 +288,8 @@ impl<'tcx> TypeMap<'tcx> {\n                 }\n             },\n             ty::TyClosure(def_id, substs) => {\n-                let typer = NormalizingClosureTyper::new(cx.tcx());\n-                let closure_ty = typer.closure_type(def_id, substs);\n+                let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n+                let closure_ty = infcx.closure_type(def_id, substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n                                                         closure_ty,\n                                                         &mut unique_type_id);\n@@ -796,8 +797,8 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n         }\n         ty::TyClosure(def_id, substs) => {\n-            let typer = NormalizingClosureTyper::new(cx.tcx());\n-            let sig = typer.closure_type(def_id, substs).sig;\n+            let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n+            let sig = infcx.closure_type(def_id, substs).sig;\n             subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n         }\n         ty::TyStruct(def_id, substs) => {"}, {"sha": "0eaaaaa5b3414a1fe5624a326f8ad4da09585950", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=fb295a60b37fc2bc60fab29fad1863a174fa587c", "patch": "@@ -21,10 +21,10 @@\n //! * When in doubt, define.\n use llvm::{self, ValueRef};\n use middle::ty::{self, ClosureTyper};\n+use middle::infer;\n use syntax::abi;\n use trans::attributes;\n use trans::base;\n-use trans::common;\n use trans::context::CrateContext;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -117,8 +117,8 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n             (&f.sig, f.abi, None)\n         }\n         ty::TyClosure(closure_did, substs) => {\n-            let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n-            function_type = typer.closure_type(closure_did, substs);\n+            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+            function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n             let llenvironment_type = type_of::type_of_explicit_arg(ccx, self_type);\n             debug!(\"declare_rust_fn function_type={:?} self_type={:?}\","}, {"sha": "b297a731d29e7f54d9a4734d9d145139580b69a4", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb295a60b37fc2bc60fab29fad1863a174fa587c/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=fb295a60b37fc2bc60fab29fad1863a174fa587c", "patch": "@@ -324,9 +324,8 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     // FIXME(#20304) -- cache\n     // NOTE: @jroesch\n     // Here is of an example where we do not use a param_env but use a typer instead.\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n-    let typer = NormalizingClosureTyper::new(tcx);\n-    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &infcx);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: result, obligations } =\n         traits::normalize(&mut selcx, cause, &value);\n@@ -336,7 +335,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n            obligations);\n \n     let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n-    \n+\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }"}]}