{"sha": "1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNGUyYjZmOWM3NWEwZTIxNzIyYzg4YTBlM2I2MTBkNmZmYzNhZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-21T21:05:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-21T21:05:57Z"}, "message": "Auto merge of #73180 - matthewjasper:predicate-cache, r=nikomatsakis\n\nCache flags and escaping vars for predicates\n\nWith predicates becoming interned (rust-lang/compiler-team#285) this is now possible and could be a perf win. It would become an even larger win once we have recursive predicates.\n\ncc @lcnr @nikomatsakis\n\nr? @ghost", "tree": {"sha": "29efa7435788242f2238bcec7ab534b0831697f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29efa7435788242f2238bcec7ab534b0831697f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "html_url": "https://github.com/rust-lang/rust/commit/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8cf3991177f30694200002cd9479ffbbe6d9a1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8cf3991177f30694200002cd9479ffbbe6d9a1a", "html_url": "https://github.com/rust-lang/rust/commit/a8cf3991177f30694200002cd9479ffbbe6d9a1a"}, {"sha": "6e12272af0838adf4b13fe69c1c62e24d0755125", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e12272af0838adf4b13fe69c1c62e24d0755125", "html_url": "https://github.com/rust-lang/rust/commit/6e12272af0838adf4b13fe69c1c62e24d0755125"}], "stats": {"total": 421, "additions": 321, "deletions": 100}, "files": [{"sha": "2254d553337d5fed65d94daa7b19b3d40311af0f", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "patch": "@@ -294,15 +294,36 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n \n         let key = ty::CReaderCacheKey { cnum: self.cdata().cnum, pos: shorthand };\n \n-        if let Some(&ty) = tcx.rcache.borrow().get(&key) {\n+        if let Some(&ty) = tcx.ty_rcache.borrow().get(&key) {\n             return Ok(ty);\n         }\n \n         let ty = or_insert_with(self)?;\n-        tcx.rcache.borrow_mut().insert(key, ty);\n+        tcx.ty_rcache.borrow_mut().insert(key, ty);\n         Ok(ty)\n     }\n \n+    fn cached_predicate_for_shorthand<F>(\n+        &mut self,\n+        shorthand: usize,\n+        or_insert_with: F,\n+    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n+    where\n+        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>,\n+    {\n+        let tcx = self.tcx();\n+\n+        let key = ty::CReaderCacheKey { cnum: self.cdata().cnum, pos: shorthand };\n+\n+        if let Some(&pred) = tcx.pred_rcache.borrow().get(&key) {\n+            return Ok(pred);\n+        }\n+\n+        let pred = or_insert_with(self)?;\n+        tcx.pred_rcache.borrow_mut().insert(key, pred);\n+        Ok(pred)\n+    }\n+\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,"}, {"sha": "d01c767e2bc044219b9c74695c9370e69c90e33c", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "patch": "@@ -239,6 +239,17 @@ where\n     }\n }\n \n+impl<'b, 'tcx> SpecializedEncoder<ty::Predicate<'b>> for EncodeContext<'tcx> {\n+    fn specialized_encode(&mut self, predicate: &ty::Predicate<'b>) -> Result<(), Self::Error> {\n+        debug_assert!(self.tcx.lift(predicate).is_some());\n+        let predicate =\n+            unsafe { std::mem::transmute::<&ty::Predicate<'b>, &ty::Predicate<'tcx>>(predicate) };\n+        ty_codec::encode_with_shorthand(self, predicate, |encoder| {\n+            &mut encoder.predicate_shorthands\n+        })\n+    }\n+}\n+\n impl<'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n         use std::collections::hash_map::Entry;\n@@ -256,22 +267,6 @@ impl<'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> SpecializedEncoder<&'a [(ty::Predicate<'b>, Span)]> for EncodeContext<'tcx> {\n-    fn specialized_encode(\n-        &mut self,\n-        predicates: &&'a [(ty::Predicate<'b>, Span)],\n-    ) -> Result<(), Self::Error> {\n-        debug_assert!(self.tcx.lift(*predicates).is_some());\n-        let predicates = unsafe {\n-            std::mem::transmute::<\n-                &&'a [(ty::Predicate<'b>, Span)],\n-                &&'tcx [(ty::Predicate<'tcx>, Span)],\n-            >(predicates)\n-        };\n-        ty_codec::encode_spanned_predicates(self, &predicates, |ecx| &mut ecx.predicate_shorthands)\n-    }\n-}\n-\n impl<'tcx> SpecializedEncoder<Fingerprint> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n         f.encode_opaque(&mut self.opaque)"}, {"sha": "4f1889aeb162a4a4cc6b2824bdf5034a1ea86557", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "patch": "@@ -100,6 +100,7 @@ macro_rules! arena_types {\n \n             // Interned types\n             [] tys: rustc_middle::ty::TyS<$tcx>, rustc_middle::ty::TyS<'_x>;\n+            [] predicates: rustc_middle::ty::PredicateInner<$tcx>, rustc_middle::ty::PredicateInner<'_x>;\n \n             // HIR query types\n             [few] indexed_hir: rustc_middle::hir::map::IndexedHir<$tcx>, rustc_middle::hir::map::IndexedHir<'_x>;"}, {"sha": "67ceaca103e9f172333b2f34a74bad96d067d64d", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "patch": "@@ -10,7 +10,7 @@ use crate::arena::ArenaAllocatable;\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::mir::{self, interpret::Allocation};\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, List, ToPredicate, Ty, TyCtxt};\n+use crate::ty::{self, List, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n@@ -95,23 +95,6 @@ where\n     Ok(())\n }\n \n-pub fn encode_spanned_predicates<'tcx, E, C>(\n-    encoder: &mut E,\n-    predicates: &[(ty::Predicate<'tcx>, Span)],\n-    cache: C,\n-) -> Result<(), E::Error>\n-where\n-    E: TyEncoder,\n-    C: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<ty::Predicate<'tcx>, usize>,\n-{\n-    predicates.len().encode(encoder)?;\n-    for (predicate, span) in predicates {\n-        encode_with_shorthand(encoder, predicate, &cache)?;\n-        span.encode(encoder)?;\n-    }\n-    Ok(())\n-}\n-\n pub trait TyDecoder<'tcx>: Decoder {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n \n@@ -127,6 +110,14 @@ pub trait TyDecoder<'tcx>: Decoder {\n     where\n         F: FnOnce(&mut Self) -> Result<Ty<'tcx>, Self::Error>;\n \n+    fn cached_predicate_for_shorthand<F>(\n+        &mut self,\n+        shorthand: usize,\n+        or_insert_with: F,\n+    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n+    where\n+        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>;\n+\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R;\n@@ -188,6 +179,26 @@ where\n     }\n }\n \n+#[inline]\n+pub fn decode_predicate<D>(decoder: &mut D) -> Result<ty::Predicate<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n+{\n+    // Handle shorthands first, if we have an usize > 0x80.\n+    if decoder.positioned_at_shorthand() {\n+        let pos = decoder.read_usize()?;\n+        assert!(pos >= SHORTHAND_OFFSET);\n+        let shorthand = pos - SHORTHAND_OFFSET;\n+\n+        decoder.cached_predicate_for_shorthand(shorthand, |decoder| {\n+            decoder.with_position(shorthand, ty::Predicate::decode)\n+        })\n+    } else {\n+        let tcx = decoder.tcx();\n+        Ok(tcx.mk_predicate(ty::PredicateKind::decode(decoder)?))\n+    }\n+}\n+\n #[inline]\n pub fn decode_spanned_predicates<D>(\n     decoder: &mut D,\n@@ -198,20 +209,7 @@ where\n     let tcx = decoder.tcx();\n     Ok(tcx.arena.alloc_from_iter(\n         (0..decoder.read_usize()?)\n-            .map(|_| {\n-                // Handle shorthands first, if we have an usize > 0x80.\n-                let predicate_kind = if decoder.positioned_at_shorthand() {\n-                    let pos = decoder.read_usize()?;\n-                    assert!(pos >= SHORTHAND_OFFSET);\n-                    let shorthand = pos - SHORTHAND_OFFSET;\n-\n-                    decoder.with_position(shorthand, ty::PredicateKind::decode)\n-                } else {\n-                    ty::PredicateKind::decode(decoder)\n-                }?;\n-                let predicate = predicate_kind.to_predicate(tcx);\n-                Ok((predicate, Decodable::decode(decoder)?))\n-            })\n+            .map(|_| Decodable::decode(decoder))\n             .collect::<Result<Vec<_>, _>>()?,\n     ))\n }\n@@ -421,7 +419,6 @@ macro_rules! implement_ty_decoder {\n             // FIXME(#36588): These impls are horribly unsound as they allow\n             // the caller to pick any lifetime for `'tcx`, including `'static`.\n \n-            rustc_hir::arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);\n             arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);\n \n             impl<$($typaram),*> SpecializedDecoder<CrateNum>\n@@ -436,7 +433,24 @@ macro_rules! implement_ty_decoder {\n             where &'_x ty::TyS<'_y>: UseSpecializedDecodable\n             {\n                 fn specialized_decode(&mut self) -> Result<&'_x ty::TyS<'_y>, Self::Error> {\n-                    unsafe { transmute::<Result<ty::Ty<'tcx>, Self::Error>, Result<&'_x ty::TyS<'_y>, Self::Error>>(decode_ty(self)) }\n+                    unsafe {\n+                        transmute::<\n+                            Result<ty::Ty<'tcx>, Self::Error>,\n+                            Result<&'_x ty::TyS<'_y>, Self::Error>,\n+                        >(decode_ty(self))\n+                    }\n+                }\n+            }\n+\n+            impl<'_x, $($typaram),*> SpecializedDecoder<ty::Predicate<'_x>>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self) -> Result<ty::Predicate<'_x>, Self::Error> {\n+                    unsafe {\n+                        transmute::<\n+                            Result<ty::Predicate<'tcx>, Self::Error>,\n+                            Result<ty::Predicate<'_x>, Self::Error>,\n+                        >(decode_predicate(self))\n+                    }\n                 }\n             }\n "}, {"sha": "56f4ae9e9848bc66322501c5967a7a397f8c9696", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 52, "deletions": 13, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "patch": "@@ -19,8 +19,9 @@ use crate::ty::TyKind::*;\n use crate::ty::{\n     self, query, AdtDef, AdtKind, BindingMode, BoundVar, CanonicalPolyFnSig, Const, ConstVid,\n     DefIdTree, ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy,\n-    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateKind, ProjectionTy,\n-    Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut,\n+    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind,\n+    ProjectionTy, Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar,\n+    TyVid, TypeAndMut,\n };\n use rustc_ast::ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -76,7 +77,7 @@ pub struct CtxtInterners<'tcx> {\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo>>,\n     region: InternedSet<'tcx, RegionKind>,\n     existential_predicates: InternedSet<'tcx, List<ExistentialPredicate<'tcx>>>,\n-    predicate_kind: InternedSet<'tcx, PredicateKind<'tcx>>,\n+    predicate: InternedSet<'tcx, PredicateInner<'tcx>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n@@ -95,7 +96,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             region: Default::default(),\n             existential_predicates: Default::default(),\n             canonical_var_infos: Default::default(),\n-            predicate_kind: Default::default(),\n+            predicate: Default::default(),\n             predicates: Default::default(),\n             projs: Default::default(),\n             place_elems: Default::default(),\n@@ -123,6 +124,23 @@ impl<'tcx> CtxtInterners<'tcx> {\n             })\n             .0\n     }\n+\n+    #[inline(never)]\n+    fn intern_predicate(&self, kind: PredicateKind<'tcx>) -> &'tcx PredicateInner<'tcx> {\n+        self.predicate\n+            .intern(kind, |kind| {\n+                let flags = super::flags::FlagComputation::for_predicate(&kind);\n+\n+                let predicate_struct = PredicateInner {\n+                    kind,\n+                    flags: flags.flags,\n+                    outer_exclusive_binder: flags.outer_exclusive_binder,\n+                };\n+\n+                Interned(self.arena.alloc(predicate_struct))\n+            })\n+            .0\n+    }\n }\n \n pub struct CommonTypes<'tcx> {\n@@ -938,8 +956,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// via `extern crate` item and not `--extern` option or compiler built-in.\n     pub extern_prelude: FxHashMap<Symbol, bool>,\n \n-    // Internal cache for metadata decoding. No need to track deps on this.\n-    pub rcache: Lock<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n+    // Internal caches for metadata decoding. No need to track deps on this.\n+    pub ty_rcache: Lock<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n+    pub pred_rcache: Lock<FxHashMap<ty::CReaderCacheKey, Predicate<'tcx>>>,\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n@@ -1128,7 +1147,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             definitions,\n             def_path_hash_to_def_id,\n             queries: query::Queries::new(providers, extern_providers, on_disk_query_result_cache),\n-            rcache: Default::default(),\n+            ty_rcache: Default::default(),\n+            pred_rcache: Default::default(),\n             selection_cache: Default::default(),\n             evaluation_cache: Default::default(),\n             crate_name: Symbol::intern(crate_name),\n@@ -1625,7 +1645,7 @@ macro_rules! nop_list_lift {\n nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n nop_lift! {region; Region<'a> => Region<'tcx>}\n nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n-nop_lift! {predicate_kind; &'a PredicateKind<'a> => &'tcx PredicateKind<'tcx>}\n+nop_lift! {predicate; &'a PredicateInner<'a> => &'tcx PredicateInner<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n nop_list_lift! {existential_predicates; ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n@@ -1984,6 +2004,26 @@ impl<'tcx> Borrow<TyKind<'tcx>> for Interned<'tcx, TyS<'tcx>> {\n         &self.0.kind\n     }\n }\n+// N.B., an `Interned<PredicateInner>` compares and hashes as a `PredicateKind`.\n+impl<'tcx> PartialEq for Interned<'tcx, PredicateInner<'tcx>> {\n+    fn eq(&self, other: &Interned<'tcx, PredicateInner<'tcx>>) -> bool {\n+        self.0.kind == other.0.kind\n+    }\n+}\n+\n+impl<'tcx> Eq for Interned<'tcx, PredicateInner<'tcx>> {}\n+\n+impl<'tcx> Hash for Interned<'tcx, PredicateInner<'tcx>> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.0.kind.hash(s)\n+    }\n+}\n+\n+impl<'tcx> Borrow<PredicateKind<'tcx>> for Interned<'tcx, PredicateInner<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a PredicateKind<'tcx> {\n+        &self.0.kind\n+    }\n+}\n \n // N.B., an `Interned<List<T>>` compares and hashes as its elements.\n impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, List<T>> {\n@@ -2050,11 +2090,10 @@ macro_rules! direct_interners {\n     }\n }\n \n-direct_interners!(\n+direct_interners! {\n     region: mk_region(RegionKind),\n     const_: mk_const(Const<'tcx>),\n-    predicate_kind: intern_predicate_kind(PredicateKind<'tcx>),\n-);\n+}\n \n macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ty)),+) => (\n@@ -2125,8 +2164,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_predicate(&self, kind: PredicateKind<'tcx>) -> Predicate<'tcx> {\n-        let kind = self.intern_predicate_kind(kind);\n-        Predicate { kind }\n+        let inner = self.interners.intern_predicate(kind);\n+        Predicate { inner }\n     }\n \n     pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {"}, {"sha": "c782eee938721aca7f3c2c0c7bf47fd4dbb60dcf", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 73, "deletions": 9, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "patch": "@@ -1,5 +1,6 @@\n use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::{self, InferConst, Ty, TypeFlags};\n+use std::slice;\n \n #[derive(Debug)]\n pub struct FlagComputation {\n@@ -21,6 +22,12 @@ impl FlagComputation {\n         result\n     }\n \n+    pub fn for_predicate(kind: &ty::PredicateKind<'_>) -> FlagComputation {\n+        let mut result = FlagComputation::new();\n+        result.add_predicate_kind(kind);\n+        result\n+    }\n+\n     pub fn for_const(c: &ty::Const<'_>) -> TypeFlags {\n         let mut result = FlagComputation::new();\n         result.add_const(c);\n@@ -32,7 +39,7 @@ impl FlagComputation {\n     }\n \n     /// indicates that `self` refers to something at binding level `binder`\n-    fn add_binder(&mut self, binder: ty::DebruijnIndex) {\n+    fn add_bound_var(&mut self, binder: ty::DebruijnIndex) {\n         let exclusive_binder = binder.shifted_in(1);\n         self.add_exclusive_binder(exclusive_binder);\n     }\n@@ -46,7 +53,7 @@ impl FlagComputation {\n \n     /// Adds the flags/depth from a set of types that appear within the current type, but within a\n     /// region binder.\n-    fn add_bound_computation(&mut self, computation: &FlagComputation) {\n+    fn add_bound_computation(&mut self, computation: FlagComputation) {\n         self.add_flags(computation.flags);\n \n         // The types that contributed to `computation` occurred within\n@@ -84,15 +91,15 @@ impl FlagComputation {\n             &ty::GeneratorWitness(ref ts) => {\n                 let mut computation = FlagComputation::new();\n                 computation.add_tys(&ts.skip_binder()[..]);\n-                self.add_bound_computation(&computation);\n+                self.add_bound_computation(computation);\n             }\n \n             &ty::Closure(_, ref substs) => {\n                 self.add_substs(substs);\n             }\n \n             &ty::Bound(debruijn, _) => {\n-                self.add_binder(debruijn);\n+                self.add_bound_var(debruijn);\n             }\n \n             &ty::Placeholder(..) => {\n@@ -133,12 +140,12 @@ impl FlagComputation {\n                         ty::ExistentialPredicate::Projection(p) => {\n                             let mut proj_computation = FlagComputation::new();\n                             proj_computation.add_existential_projection(&p);\n-                            self.add_bound_computation(&proj_computation);\n+                            self.add_bound_computation(proj_computation);\n                         }\n                         ty::ExistentialPredicate::AutoTrait(_) => {}\n                     }\n                 }\n-                self.add_bound_computation(&computation);\n+                self.add_bound_computation(computation);\n                 self.add_region(r);\n             }\n \n@@ -172,6 +179,63 @@ impl FlagComputation {\n         }\n     }\n \n+    fn add_predicate_kind(&mut self, kind: &ty::PredicateKind<'_>) {\n+        match kind {\n+            ty::PredicateKind::Trait(trait_pred, _constness) => {\n+                let mut computation = FlagComputation::new();\n+                computation.add_substs(trait_pred.skip_binder().trait_ref.substs);\n+\n+                self.add_bound_computation(computation);\n+            }\n+            ty::PredicateKind::RegionOutlives(poly_outlives) => {\n+                let mut computation = FlagComputation::new();\n+                let ty::OutlivesPredicate(a, b) = poly_outlives.skip_binder();\n+                computation.add_region(a);\n+                computation.add_region(b);\n+\n+                self.add_bound_computation(computation);\n+            }\n+            ty::PredicateKind::TypeOutlives(poly_outlives) => {\n+                let mut computation = FlagComputation::new();\n+                let ty::OutlivesPredicate(ty, region) = poly_outlives.skip_binder();\n+                computation.add_ty(ty);\n+                computation.add_region(region);\n+\n+                self.add_bound_computation(computation);\n+            }\n+            ty::PredicateKind::Subtype(poly_subtype) => {\n+                let mut computation = FlagComputation::new();\n+                let ty::SubtypePredicate { a_is_expected: _, a, b } = poly_subtype.skip_binder();\n+                computation.add_ty(a);\n+                computation.add_ty(b);\n+\n+                self.add_bound_computation(computation);\n+            }\n+            ty::PredicateKind::Projection(projection) => {\n+                let mut computation = FlagComputation::new();\n+                let ty::ProjectionPredicate { projection_ty, ty } = projection.skip_binder();\n+                computation.add_projection_ty(projection_ty);\n+                computation.add_ty(ty);\n+\n+                self.add_bound_computation(computation);\n+            }\n+            ty::PredicateKind::WellFormed(arg) => {\n+                self.add_substs(slice::from_ref(arg));\n+            }\n+            ty::PredicateKind::ObjectSafe(_def_id) => {}\n+            ty::PredicateKind::ClosureKind(_def_id, substs, _kind) => {\n+                self.add_substs(substs);\n+            }\n+            ty::PredicateKind::ConstEvaluatable(_def_id, substs) => {\n+                self.add_substs(substs);\n+            }\n+            ty::PredicateKind::ConstEquate(expected, found) => {\n+                self.add_const(expected);\n+                self.add_const(found);\n+            }\n+        }\n+    }\n+\n     fn add_ty(&mut self, ty: Ty<'_>) {\n         self.add_flags(ty.flags);\n         self.add_exclusive_binder(ty.outer_exclusive_binder);\n@@ -189,13 +253,13 @@ impl FlagComputation {\n         computation.add_tys(fn_sig.skip_binder().inputs());\n         computation.add_ty(fn_sig.skip_binder().output());\n \n-        self.add_bound_computation(&computation);\n+        self.add_bound_computation(computation);\n     }\n \n     fn add_region(&mut self, r: ty::Region<'_>) {\n         self.add_flags(r.type_flags());\n         if let ty::ReLateBound(debruijn, _) = *r {\n-            self.add_binder(debruijn);\n+            self.add_bound_var(debruijn);\n         }\n     }\n \n@@ -214,7 +278,7 @@ impl FlagComputation {\n                 }\n             }\n             ty::ConstKind::Bound(debruijn, _) => {\n-                self.add_binder(debruijn);\n+                self.add_bound_var(debruijn);\n             }\n             ty::ConstKind::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_CT_PARAM);"}, {"sha": "2d25c7c6ac983546a87cfb4f954f235f3b88ef97", "filename": "src/librustc_middle/ty/fold.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffold.rs?ref=1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "patch": "@@ -31,6 +31,7 @@\n //! These methods return true to indicate that the visitor has found what it is\n //! looking for, and does not need to visit anything else.\n \n+use crate::ty::structural_impls::PredicateVisitor;\n use crate::ty::{self, flags::FlagComputation, Binder, Ty, TyCtxt, TypeFlags};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -908,6 +909,12 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n     }\n }\n \n+impl<'tcx> PredicateVisitor<'tcx> for HasEscapingVarsVisitor {\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n+        predicate.inner.outer_exclusive_binder > self.outer_index\n+    }\n+}\n+\n // FIXME: Optimize for checking for infer flags\n struct HasTypeFlagsVisitor {\n     flags: ty::TypeFlags,\n@@ -932,6 +939,15 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n }\n \n+impl<'tcx> PredicateVisitor<'tcx> for HasTypeFlagsVisitor {\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n+        debug!(\n+            \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\",\n+            predicate, predicate.inner.flags, self.flags\n+        );\n+        predicate.inner.flags.intersects(self.flags)\n+    }\n+}\n /// Collects all the late-bound regions at the innermost binding level\n /// into a hash set.\n struct LateBoundRegionsCollector {"}, {"sha": "6b7940ed7abcc1f66b794cab63bcb3e22273c9c3", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "patch": "@@ -627,7 +627,7 @@ impl<'tcx> Hash for TyS<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::TyS<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ty::TyS {\n             ref kind,\n@@ -1001,16 +1001,35 @@ impl<'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Hash, RustcEncodable, RustcDecodable, Lift)]\n-#[derive(HashStable)]\n+#[derive(Debug)]\n+crate struct PredicateInner<'tcx> {\n+    kind: PredicateKind<'tcx>,\n+    flags: TypeFlags,\n+    /// See the comment for the corresponding field of [TyS].\n+    outer_exclusive_binder: ty::DebruijnIndex,\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PredicateInner<'_>, 40);\n+\n+#[derive(Clone, Copy, Lift)]\n pub struct Predicate<'tcx> {\n-    kind: &'tcx PredicateKind<'tcx>,\n+    inner: &'tcx PredicateInner<'tcx>,\n }\n \n+impl rustc_serialize::UseSpecializedEncodable for Predicate<'_> {}\n+impl rustc_serialize::UseSpecializedDecodable for Predicate<'_> {}\n+\n impl<'tcx> PartialEq for Predicate<'tcx> {\n     fn eq(&self, other: &Self) -> bool {\n         // `self.kind` is always interned.\n-        ptr::eq(self.kind, other.kind)\n+        ptr::eq(self.inner, other.inner)\n+    }\n+}\n+\n+impl Hash for Predicate<'_> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self.inner as *const PredicateInner<'_>).hash(s)\n     }\n }\n \n@@ -1019,7 +1038,22 @@ impl<'tcx> Eq for Predicate<'tcx> {}\n impl<'tcx> Predicate<'tcx> {\n     #[inline(always)]\n     pub fn kind(self) -> &'tcx PredicateKind<'tcx> {\n-        self.kind\n+        &self.inner.kind\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        let PredicateInner {\n+            ref kind,\n+\n+            // The other fields just provide fast access to information that is\n+            // also contained in `kind`, so no need to hash them.\n+            flags: _,\n+            outer_exclusive_binder: _,\n+        } = self.inner;\n+\n+        kind.hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "c84a7c38d0a0e70f5417b0a7ff986f78ba9a73c1", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "patch": "@@ -524,16 +524,39 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n         let cache_key =\n             ty::CReaderCacheKey { cnum: CrateNum::ReservedForIncrCompCache, pos: shorthand };\n \n-        if let Some(&ty) = tcx.rcache.borrow().get(&cache_key) {\n+        if let Some(&ty) = tcx.ty_rcache.borrow().get(&cache_key) {\n             return Ok(ty);\n         }\n \n         let ty = or_insert_with(self)?;\n         // This may overwrite the entry, but it should overwrite with the same value.\n-        tcx.rcache.borrow_mut().insert_same(cache_key, ty);\n+        tcx.ty_rcache.borrow_mut().insert_same(cache_key, ty);\n         Ok(ty)\n     }\n \n+    fn cached_predicate_for_shorthand<F>(\n+        &mut self,\n+        shorthand: usize,\n+        or_insert_with: F,\n+    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n+    where\n+        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>,\n+    {\n+        let tcx = self.tcx();\n+\n+        let cache_key =\n+            ty::CReaderCacheKey { cnum: CrateNum::ReservedForIncrCompCache, pos: shorthand };\n+\n+        if let Some(&pred) = tcx.pred_rcache.borrow().get(&cache_key) {\n+            return Ok(pred);\n+        }\n+\n+        let pred = or_insert_with(self)?;\n+        // This may overwrite the entry, but it should overwrite with the same value.\n+        tcx.pred_rcache.borrow_mut().insert_same(cache_key, pred);\n+        Ok(pred)\n+    }\n+\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n@@ -820,24 +843,16 @@ where\n     }\n }\n \n-impl<'a, 'b, 'c, 'tcx, E> SpecializedEncoder<&'b [(ty::Predicate<'c>, Span)]>\n-    for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'b, 'tcx, E> SpecializedEncoder<ty::Predicate<'b>> for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + TyEncoder,\n {\n     #[inline]\n-    fn specialized_encode(\n-        &mut self,\n-        predicates: &&'b [(ty::Predicate<'c>, Span)],\n-    ) -> Result<(), Self::Error> {\n-        debug_assert!(self.tcx.lift(*predicates).is_some());\n-        let predicates = unsafe {\n-            std::mem::transmute::<\n-                &&'b [(ty::Predicate<'c>, Span)],\n-                &&'tcx [(ty::Predicate<'tcx>, Span)],\n-            >(predicates)\n-        };\n-        ty_codec::encode_spanned_predicates(self, predicates, |encoder| {\n+    fn specialized_encode(&mut self, predicate: &ty::Predicate<'b>) -> Result<(), Self::Error> {\n+        debug_assert!(self.tcx.lift(predicate).is_some());\n+        let predicate =\n+            unsafe { std::mem::transmute::<&ty::Predicate<'b>, &ty::Predicate<'tcx>>(predicate) };\n+        ty_codec::encode_with_shorthand(self, predicate, |encoder| {\n             &mut encoder.predicate_shorthands\n         })\n     }"}, {"sha": "f736037b5c15a598eccd5ccb8b093e73b72e307e", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "patch": "@@ -987,12 +987,34 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let new = ty::PredicateKind::super_fold_with(self.kind, folder);\n-        if new != *self.kind { folder.tcx().mk_predicate(new) } else { *self }\n+        let new = ty::PredicateKind::super_fold_with(&self.inner.kind, folder);\n+        if new != self.inner.kind { folder.tcx().mk_predicate(new) } else { *self }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        ty::PredicateKind::super_visit_with(self.kind, visitor)\n+        ty::PredicateKind::super_visit_with(&self.inner.kind, visitor)\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_predicate(*self)\n+    }\n+\n+    fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n+        self.inner.outer_exclusive_binder > binder\n+    }\n+\n+    fn has_type_flags(&self, flags: ty::TypeFlags) -> bool {\n+        self.inner.flags.intersects(flags)\n+    }\n+}\n+\n+pub(super) trait PredicateVisitor<'tcx>: TypeVisitor<'tcx> {\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool;\n+}\n+\n+impl<T: TypeVisitor<'tcx>> PredicateVisitor<'tcx> for T {\n+    default fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n+        predicate.super_visit_with(self)\n     }\n }\n "}, {"sha": "32ab63458e7528aa65a9b2a72cf98ccc9ad2ca33", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=1a4e2b6f9c75a0e21722c88a0e3b610d6ffc3ae3", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             ty::PredicateKind::Trait(ref data, _) => {\n                 let trait_obligation = obligation.with(*data);\n \n-                if data.is_global() {\n+                if obligation.predicate.is_global() {\n                     // no type variables present, can use evaluation for better caching.\n                     // FIXME: consider caching errors too.\n                     if infcx.predicate_must_hold_considering_regions(&obligation) {"}]}