{"sha": "47def3ef27a2e027f1a93ef7870ff131ee7926fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZGVmM2VmMjdhMmUwMjdmMWE5M2VmNzg3MGZmMTMxZWU3OTI2ZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-13T00:34:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-13T00:34:21Z"}, "message": "Auto merge of #23849 - bcoopers:master, r=pnkfelix\n\nRight now, if the user requests to increase the vector size via reserve() or push_back() and the request brings the attempted memory above usize::MAX, we panic.\r\n\r\nWith this change there is only a panic if the minimum requested memory that could meet the requirement is above usize::MAX- otherwise it simply requests its largest capacity possible, usize::MAX.", "tree": {"sha": "7cc0ea5f165b931074a29de01cebccdc1f5e7538", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cc0ea5f165b931074a29de01cebccdc1f5e7538"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47def3ef27a2e027f1a93ef7870ff131ee7926fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47def3ef27a2e027f1a93ef7870ff131ee7926fd", "html_url": "https://github.com/rust-lang/rust/commit/47def3ef27a2e027f1a93ef7870ff131ee7926fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47def3ef27a2e027f1a93ef7870ff131ee7926fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3947061d6a914e9f1ac6267b2b079ce851d0e62", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3947061d6a914e9f1ac6267b2b079ce851d0e62", "html_url": "https://github.com/rust-lang/rust/commit/c3947061d6a914e9f1ac6267b2b079ce851d0e62"}, {"sha": "ac617b628899282f714fd6a91471d1f0b1cc3217", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac617b628899282f714fd6a91471d1f0b1cc3217", "html_url": "https://github.com/rust-lang/rust/commit/ac617b628899282f714fd6a91471d1f0b1cc3217"}], "stats": {"total": 24, "additions": 18, "deletions": 6}, "files": [{"sha": "240a55181de74e44b5fa94fcbc2c8514338cc8c8", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/47def3ef27a2e027f1a93ef7870ff131ee7926fd/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47def3ef27a2e027f1a93ef7870ff131ee7926fd/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=47def3ef27a2e027f1a93ef7870ff131ee7926fd", "patch": "@@ -65,10 +65,14 @@ use core::ops;\n use core::ptr;\n use core::ptr::Unique;\n use core::slice;\n+use core::isize;\n use core::usize;\n \n use borrow::{Cow, IntoCow};\n \n+// FIXME- fix places which assume the max vector allowed has memory usize::MAX.\n+static MAX_MEMORY_SIZE: usize = isize::MAX as usize;\n+\n /// A growable list type, written `Vec<T>` but pronounced 'vector.'\n ///\n /// # Examples\n@@ -307,10 +311,15 @@ impl<T> Vec<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n         if self.cap - self.len < additional {\n-            let err_msg = \"Vec::reserve: `usize` overflow\";\n-            let new_cap = self.len.checked_add(additional).expect(err_msg)\n-                .checked_next_power_of_two().expect(err_msg);\n-            self.grow_capacity(new_cap);\n+            const ERR_MSG: &'static str  = \"Vec::reserve: `isize` overflow\";\n+\n+            let new_min_cap = self.len.checked_add(additional).expect(ERR_MSG);\n+            if new_min_cap > MAX_MEMORY_SIZE { panic!(ERR_MSG) }\n+            self.grow_capacity(match new_min_cap.checked_next_power_of_two() {\n+                Some(x) if x > MAX_MEMORY_SIZE => MAX_MEMORY_SIZE,\n+                None => MAX_MEMORY_SIZE,\n+                Some(x) => x,\n+            });\n         }\n     }\n \n@@ -647,8 +656,11 @@ impl<T> Vec<T> {\n         #[inline(never)]\n         fn resize<T>(vec: &mut Vec<T>) {\n             let old_size = vec.cap * mem::size_of::<T>();\n-            let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n-            if old_size > size { panic!(\"capacity overflow\") }\n+            if old_size >= MAX_MEMORY_SIZE { panic!(\"capacity overflow\") }\n+            let mut size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n+            if old_size > size || size > MAX_MEMORY_SIZE {\n+                size = MAX_MEMORY_SIZE;\n+            }\n             unsafe {\n                 let ptr = alloc_or_realloc(*vec.ptr, old_size, size);\n                 if ptr.is_null() { ::alloc::oom() }"}]}