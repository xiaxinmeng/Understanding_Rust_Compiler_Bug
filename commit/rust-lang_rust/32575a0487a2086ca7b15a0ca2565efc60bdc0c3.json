{"sha": "32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNTc1YTA0ODdhMjA4NmNhN2IxNWEwY2EyNTY1ZWZjNjBiZGMwYzM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-03-08T17:30:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-10T16:21:45Z"}, "message": "Give spans to individual path segments in AST", "tree": {"sha": "3b1694a1dfda636e7809ac8157e6e07e57c253a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b1694a1dfda636e7809ac8157e6e07e57c253a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "html_url": "https://github.com/rust-lang/rust/commit/32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f573db4f80c75f156df8a743f456bf087ec81dc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f573db4f80c75f156df8a743f456bf087ec81dc2", "html_url": "https://github.com/rust-lang/rust/commit/f573db4f80c75f156df8a743f456bf087ec81dc2"}], "stats": {"total": 101, "additions": 60, "deletions": 41}, "files": [{"sha": "105af23d05c057b436cd5a49d708437a7fd100a7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "patch": "@@ -3124,11 +3124,10 @@ impl<'a> Resolver<'a> {\n                 if ident.name == lookup_name && ns == namespace {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n-                        let span = name_binding.span;\n                         let mut segms = path_segments.clone();\n-                        segms.push(ident.into());\n+                        segms.push(ast::PathSegment::from_ident(ident, name_binding.span));\n                         let path = Path {\n-                            span: span,\n+                            span: name_binding.span,\n                             segments: segms,\n                         };\n                         // the entity is accessible in the following cases:\n@@ -3148,7 +3147,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(module) = name_binding.module() {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n-                    path_segments.push(ident.into());\n+                    path_segments.push(ast::PathSegment::from_ident(ident, name_binding.span));\n \n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup"}, {"sha": "d81bdf17034e6edec2db0f53366a6641606d6db7", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "patch": "@@ -110,8 +110,11 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     path.segments[0].identifier.name = keywords::CrateRoot.name();\n                     let module = self.0.resolve_crate_var(ident.ctxt);\n                     if !module.is_local() {\n+                        let span = path.segments[0].span;\n                         path.segments.insert(1, match module.kind {\n-                            ModuleKind::Def(_, name) => ast::Ident::with_empty_ctxt(name).into(),\n+                            ModuleKind::Def(_, name) => ast::PathSegment::from_ident(\n+                                ast::Ident::with_empty_ctxt(name), span\n+                            ),\n                             _ => unreachable!(),\n                         })\n                     }"}, {"sha": "adb7e8d101fd1867b1c8c44a500bd244eca9a1ff", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "patch": "@@ -134,7 +134,7 @@ impl Path {\n     pub fn from_ident(s: Span, identifier: Ident) -> Path {\n         Path {\n             span: s,\n-            segments: vec![identifier.into()],\n+            segments: vec![PathSegment::from_ident(identifier, s)],\n         }\n     }\n \n@@ -159,6 +159,8 @@ impl Path {\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub identifier: Ident,\n+    /// Span of the segment identifier.\n+    pub span: Span,\n \n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n@@ -170,16 +172,14 @@ pub struct PathSegment {\n     pub parameters: Option<P<PathParameters>>,\n }\n \n-impl From<Ident> for PathSegment {\n-    fn from(id: Ident) -> Self {\n-        PathSegment { identifier: id, parameters: None }\n-    }\n-}\n-\n impl PathSegment {\n+    pub fn from_ident(ident: Ident, span: Span) -> Self {\n+        PathSegment { identifier: ident, span: span, parameters: None }\n+    }\n     pub fn crate_root() -> Self {\n         PathSegment {\n             identifier: keywords::CrateRoot.ident(),\n+            span: DUMMY_SP,\n             parameters: None,\n         }\n     }"}, {"sha": "e0fb46ff5eb095a01c659ab0a6e124c30f82c577", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "patch": "@@ -38,11 +38,11 @@ pub trait AstBuilder {\n \n     fn qpath(&self, self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n-             ident: ast::Ident)\n+             ident: ast::SpannedIdent)\n              -> (ast::QSelf, ast::Path);\n     fn qpath_all(&self, self_type: P<ast::Ty>,\n                 trait_path: ast::Path,\n-                ident: ast::Ident,\n+                ident: ast::SpannedIdent,\n                 lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>>,\n                 bindings: Vec<ast::TypeBinding>)\n@@ -323,7 +323,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             segments.push(ast::PathSegment::crate_root());\n         }\n \n-        segments.extend(idents.into_iter().map(Into::into));\n+        segments.extend(idents.into_iter().map(|i| ast::PathSegment::from_ident(i, sp)));\n         let parameters = if lifetimes.is_empty() && types.is_empty() && bindings.is_empty() {\n             None\n         } else {\n@@ -333,7 +333,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 bindings: bindings,\n             })))\n         };\n-        segments.push(ast::PathSegment { identifier: last_identifier, parameters: parameters });\n+        segments.push(ast::PathSegment {\n+            identifier: last_identifier,\n+            span: sp,\n+            parameters: parameters\n+        });\n         ast::Path {\n             span: sp,\n             segments: segments,\n@@ -346,7 +350,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn qpath(&self,\n              self_type: P<ast::Ty>,\n              trait_path: ast::Path,\n-             ident: ast::Ident)\n+             ident: ast::SpannedIdent)\n              -> (ast::QSelf, ast::Path) {\n         self.qpath_all(self_type, trait_path, ident, vec![], vec![], vec![])\n     }\n@@ -357,7 +361,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn qpath_all(&self,\n                  self_type: P<ast::Ty>,\n                  trait_path: ast::Path,\n-                 ident: ast::Ident,\n+                 ident: ast::SpannedIdent,\n                  lifetimes: Vec<ast::Lifetime>,\n                  types: Vec<P<ast::Ty>>,\n                  bindings: Vec<ast::TypeBinding>)\n@@ -369,7 +373,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             bindings: bindings,\n         };\n         path.segments.push(ast::PathSegment {\n-            identifier: ident,\n+            identifier: ident.node,\n+            span: ident.span,\n             parameters: Some(P(ast::PathParameters::AngleBracketed(parameters))),\n         });\n "}, {"sha": "665f48ab45679c2dbd1a2a5aced36aee449fdc20", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "patch": "@@ -434,8 +434,9 @@ pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n \n pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) -> Path {\n     Path {\n-        segments: segments.move_map(|PathSegment {identifier, parameters}| PathSegment {\n+        segments: segments.move_map(|PathSegment {identifier, span, parameters}| PathSegment {\n             identifier: fld.fold_ident(identifier),\n+            span: fld.new_span(span),\n             parameters: parameters.map(|ps| ps.map(|ps| fld.fold_path_parameters(ps))),\n         }),\n         span: fld.new_span(span)"}, {"sha": "88535f91379f72330ed449f407519d05b9edeb8a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "patch": "@@ -617,13 +617,17 @@ mod tests {\n         Span {lo: BytePos(a), hi: BytePos(b), expn_id: NO_EXPANSION}\n     }\n \n+    fn str2seg(s: &str, lo: u32, hi: u32) -> ast::PathSegment {\n+        ast::PathSegment::from_ident(Ident::from_str(s), sp(lo, hi))\n+    }\n+\n     #[test] fn path_exprs_1() {\n         assert!(string_to_expr(\"a\".to_string()) ==\n                    P(ast::Expr{\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 1),\n-                        segments: vec![Ident::from_str(\"a\").into()],\n+                        segments: vec![str2seg(\"a\", 0, 1)],\n                     }),\n                     span: sp(0, 1),\n                     attrs: ThinVec::new(),\n@@ -637,8 +641,8 @@ mod tests {\n                     node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 6),\n                         segments: vec![ast::PathSegment::crate_root(),\n-                                       Ident::from_str(\"a\").into(),\n-                                       Ident::from_str(\"b\").into()]\n+                                       str2seg(\"a\", 2, 3),\n+                                       str2seg(\"b\", 5, 6)]\n                     }),\n                     span: sp(0, 6),\n                     attrs: ThinVec::new(),\n@@ -744,7 +748,7 @@ mod tests {\n                         id: ast::DUMMY_NODE_ID,\n                         node:ast::ExprKind::Path(None, ast::Path{\n                             span: sp(7, 8),\n-                            segments: vec![Ident::from_str(\"d\").into()],\n+                            segments: vec![str2seg(\"d\", 7, 8)],\n                         }),\n                         span:sp(7,8),\n                         attrs: ThinVec::new(),\n@@ -761,7 +765,7 @@ mod tests {\n                            id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprKind::Path(None, ast::Path {\n                                span:sp(0,1),\n-                               segments: vec![Ident::from_str(\"b\").into()],\n+                               segments: vec![str2seg(\"b\", 0, 1)],\n                             }),\n                            span: sp(0,1),\n                            attrs: ThinVec::new()})),\n@@ -802,7 +806,7 @@ mod tests {\n                                     ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                   node: ast::TyKind::Path(None, ast::Path{\n                                         span:sp(10,13),\n-                                        segments: vec![Ident::from_str(\"i32\").into()],\n+                                        segments: vec![str2seg(\"i32\", 10, 13)],\n                                         }),\n                                         span:sp(10,13)\n                                     }),\n@@ -844,7 +848,7 @@ mod tests {\n                                                 node: ast::ExprKind::Path(None,\n                                                       ast::Path{\n                                                         span:sp(17,18),\n-                                                        segments: vec![Ident::from_str(\"b\").into()],\n+                                                        segments: vec![str2seg(\"b\", 17, 18)],\n                                                       }),\n                                                 span: sp(17,18),\n                                                 attrs: ThinVec::new()})),"}, {"sha": "002f1359b6fa5e83bf5565c5a1dcb18d156435dd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "patch": "@@ -27,7 +27,7 @@ use ast::Local;\n use ast::MacStmtStyle;\n use ast::Mac_;\n use ast::{MutTy, Mutability};\n-use ast::{Pat, PatKind};\n+use ast::{Pat, PatKind, PathSegment};\n use ast::{PolyTraitRef, QSelf};\n use ast::{Stmt, StmtKind};\n use ast::{VariantData, StructField};\n@@ -1811,7 +1811,7 @@ impl<'a> Parser<'a> {\n         };\n \n         if is_global {\n-            segments.insert(0, ast::PathSegment::crate_root());\n+            segments.insert(0, PathSegment::crate_root());\n         }\n \n         // Assemble the span.\n@@ -1829,11 +1829,12 @@ impl<'a> Parser<'a> {\n     /// - `a::b<T,U>::c<V,W>`\n     /// - `a::b<T,U>::c(V) -> W`\n     /// - `a::b<T,U>::c(V)`\n-    pub fn parse_path_segments_without_colons(&mut self) -> PResult<'a, Vec<ast::PathSegment>> {\n+    pub fn parse_path_segments_without_colons(&mut self) -> PResult<'a, Vec<PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n             let identifier = self.parse_path_segment_ident()?;\n+            let ident_span = self.prev_span;\n \n             if self.check(&token::ModSep) && self.look_ahead(1, |t| *t == token::Lt) {\n                 self.bump();\n@@ -1881,7 +1882,11 @@ impl<'a> Parser<'a> {\n             };\n \n             // Assemble and push the result.\n-            segments.push(ast::PathSegment { identifier: identifier, parameters: parameters });\n+            segments.push(PathSegment {\n+                identifier: identifier,\n+                span: ident_span,\n+                parameters: parameters\n+            });\n \n             // Continue only if we see a `::`\n             if !self.eat(&token::ModSep) {\n@@ -1892,15 +1897,16 @@ impl<'a> Parser<'a> {\n \n     /// Examples:\n     /// - `a::b::<T,U>::c`\n-    pub fn parse_path_segments_with_colons(&mut self) -> PResult<'a, Vec<ast::PathSegment>> {\n+    pub fn parse_path_segments_with_colons(&mut self) -> PResult<'a, Vec<PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n             let identifier = self.parse_path_segment_ident()?;\n+            let ident_span = self.prev_span;\n \n             // If we do not see a `::`, stop.\n             if !self.eat(&token::ModSep) {\n-                segments.push(identifier.into());\n+                segments.push(PathSegment::from_ident(identifier, ident_span));\n                 return Ok(segments);\n             }\n \n@@ -1909,8 +1915,9 @@ impl<'a> Parser<'a> {\n                 // Consumed `a::b::<`, go look for types\n                 let (lifetimes, types, bindings) = self.parse_generic_args()?;\n                 self.expect_gt()?;\n-                segments.push(ast::PathSegment {\n+                segments.push(PathSegment {\n                     identifier: identifier,\n+                    span: ident_span,\n                     parameters: ast::AngleBracketedParameterData {\n                         lifetimes: lifetimes,\n                         types: types,\n@@ -1924,22 +1931,22 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 // Consumed `a::`, go look for `b`\n-                segments.push(identifier.into());\n+                segments.push(PathSegment::from_ident(identifier, ident_span));\n             }\n         }\n     }\n \n     /// Examples:\n     /// - `a::b::c`\n     pub fn parse_path_segments_without_types(&mut self)\n-                                             -> PResult<'a, Vec<ast::PathSegment>> {\n+                                             -> PResult<'a, Vec<PathSegment>> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n             let identifier = self.parse_path_segment_ident()?;\n \n             // Assemble and push the result.\n-            segments.push(identifier.into());\n+            segments.push(PathSegment::from_ident(identifier, self.prev_span));\n \n             // If we do not see a `::` or see `::{`/`::*`, stop.\n             if !self.check(&token::ModSep) || self.is_import_coupler() {\n@@ -5902,7 +5909,7 @@ impl<'a> Parser<'a> {\n             // `{foo, bar}`, `::{foo, bar}`, `*`, or `::*`.\n             self.eat(&token::ModSep);\n             let prefix = ast::Path {\n-                segments: vec![ast::PathSegment::crate_root()],\n+                segments: vec![PathSegment::crate_root()],\n                 span: mk_sp(lo, self.span.hi),\n             };\n             let view_path_kind = if self.eat(&token::BinOp(token::Star)) {"}, {"sha": "2192d203cdc23cce08e67e73d352d4e35640d5b4", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "patch": "@@ -82,7 +82,7 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n             segments: [\"{{root}}\", name, \"prelude\", \"v1\"].into_iter().map(|name| {\n-                ast::Ident::from_str(name).into()\n+                ast::PathSegment::from_ident(ast::Ident::from_str(name), DUMMY_SP)\n             }).collect(),\n             span: span,\n         })))),"}, {"sha": "e052d2cda3a42469b000be576f82b416a08bb20c", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "patch": "@@ -580,7 +580,7 @@ fn nospan<T>(t: T) -> codemap::Spanned<T> {\n fn path_node(ids: Vec<Ident>) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n-        segments: ids.into_iter().map(Into::into).collect(),\n+        segments: ids.into_iter().map(|id| ast::PathSegment::from_ident(id, DUMMY_SP)).collect(),\n     }\n }\n "}, {"sha": "dc4b8eb24cd0a570ce18531a84024bd2e90ebff9", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32575a0487a2086ca7b15a0ca2565efc60bdc0c3/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=32575a0487a2086ca7b15a0ca2565efc60bdc0c3", "patch": "@@ -61,7 +61,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n         fn path(&self) -> ast::Path {\n             ast::Path {\n                 span: self.span,\n-                segments: vec![self.ident.into()],\n+                segments: vec![ast::PathSegment::from_ident(self.ident, self.span)],\n             }\n         }\n     }"}]}