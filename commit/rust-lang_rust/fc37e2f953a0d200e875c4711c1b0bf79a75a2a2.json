{"sha": "fc37e2f953a0d200e875c4711c1b0bf79a75a2a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMzdlMmY5NTNhMGQyMDBlODc1YzQ3MTFjMWIwYmY3OWE3NWEyYTI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-27T21:28:14Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-27T21:28:14Z"}, "message": "Attribute completion is context aware", "tree": {"sha": "9cd8d24d855969c91d8bf81d14af034856d08674", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cd8d24d855969c91d8bf81d14af034856d08674"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc37e2f953a0d200e875c4711c1b0bf79a75a2a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc37e2f953a0d200e875c4711c1b0bf79a75a2a2", "html_url": "https://github.com/rust-lang/rust/commit/fc37e2f953a0d200e875c4711c1b0bf79a75a2a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc37e2f953a0d200e875c4711c1b0bf79a75a2a2/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01bfc5f5c0cf6b73c26d006802016c9b02066f94", "url": "https://api.github.com/repos/rust-lang/rust/commits/01bfc5f5c0cf6b73c26d006802016c9b02066f94", "html_url": "https://github.com/rust-lang/rust/commit/01bfc5f5c0cf6b73c26d006802016c9b02066f94"}], "stats": {"total": 178, "additions": 150, "deletions": 28}, "files": [{"sha": "192f0efc2a8836c90f1f90d3f6dde552063aa0ec", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc37e2f953a0d200e875c4711c1b0bf79a75a2a2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fc37e2f953a0d200e875c4711c1b0bf79a75a2a2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fc37e2f953a0d200e875c4711c1b0bf79a75a2a2", "patch": "@@ -647,6 +647,7 @@ dependencies = [\n  \"ide_db\",\n  \"itertools\",\n  \"log\",\n+ \"once_cell\",\n  \"profile\",\n  \"rustc-hash\",\n  \"stdx\","}, {"sha": "ba81c9e04ab5f264ff2df4138850e804947a80e9", "filename": "crates/ide_completion/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc37e2f953a0d200e875c4711c1b0bf79a75a2a2/crates%2Fide_completion%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fc37e2f953a0d200e875c4711c1b0bf79a75a2a2/crates%2Fide_completion%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2FCargo.toml?ref=fc37e2f953a0d200e875c4711c1b0bf79a75a2a2", "patch": "@@ -15,6 +15,7 @@ itertools = \"0.10.0\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n either = \"1.6.1\"\n+once_cell = \"1.7\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "0997302a6286bb043fd0e44fec2305fc85c8271a", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 141, "deletions": 28, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/fc37e2f953a0d200e875c4711c1b0bf79a75a2a2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc37e2f953a0d200e875c4711c1b0bf79a75a2a2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=fc37e2f953a0d200e875c4711c1b0bf79a75a2a2", "patch": "@@ -4,8 +4,9 @@\n //! for built-in attributes.\n \n use itertools::Itertools;\n-use rustc_hash::FxHashSet;\n-use syntax::{ast, AstNode, T};\n+use once_cell::sync::Lazy;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use syntax::{ast, AstNode, SyntaxKind, T};\n \n use crate::{\n     context::CompletionContext,\n@@ -20,27 +21,34 @@ pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext)\n     }\n \n     let attribute = ctx.attribute_under_caret.as_ref()?;\n-    match (attribute.path(), attribute.token_tree()) {\n-        (Some(path), Some(token_tree)) => {\n-            let path = path.syntax().text();\n-            if path == \"derive\" {\n-                complete_derive(acc, ctx, token_tree)\n-            } else if path == \"feature\" {\n-                complete_lint(acc, ctx, token_tree, FEATURES)\n-            } else if path == \"allow\" || path == \"warn\" || path == \"deny\" || path == \"forbid\" {\n+    match (attribute.path().and_then(|p| p.as_single_name_ref()), attribute.token_tree()) {\n+        (Some(path), Some(token_tree)) => match path.text().as_str() {\n+            \"derive\" => complete_derive(acc, ctx, token_tree),\n+            \"feature\" => complete_lint(acc, ctx, token_tree, FEATURES),\n+            \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n                 complete_lint(acc, ctx, token_tree.clone(), DEFAULT_LINT_COMPLETIONS);\n                 complete_lint(acc, ctx, token_tree, CLIPPY_LINTS);\n             }\n-        }\n-        (_, Some(_token_tree)) => {}\n-        _ => complete_attribute_start(acc, ctx, attribute),\n+            _ => (),\n+        },\n+        (None, Some(_)) => (),\n+        _ => complete_new_attribute(acc, ctx, attribute),\n     }\n     Some(())\n }\n \n-fn complete_attribute_start(acc: &mut Completions, ctx: &CompletionContext, attribute: &ast::Attr) {\n+fn complete_new_attribute(acc: &mut Completions, ctx: &CompletionContext, attribute: &ast::Attr) {\n+    let attribute_annotated_item_kind = attribute.syntax().parent().map(|it| it.kind());\n+    let attributes = attribute_annotated_item_kind.and_then(|kind| {\n+        if ast::Expr::can_cast(kind) {\n+            Some(EXPR_ATTRIBUTES)\n+        } else {\n+            KIND_TO_ATTRIBUTES.get(&kind).copied()\n+        }\n+    });\n     let is_inner = attribute.kind() == ast::AttrKind::Inner;\n-    for attr_completion in ATTRIBUTES.iter().filter(|compl| is_inner || !compl.prefer_inner) {\n+\n+    let add_completion = |attr_completion: &AttrCompletion| {\n         let mut item = CompletionItem::new(\n             CompletionKind::Attribute,\n             ctx.source_range(),\n@@ -56,9 +64,19 @@ fn complete_attribute_start(acc: &mut Completions, ctx: &CompletionContext, attr\n             item.insert_snippet(cap, snippet);\n         }\n \n-        if attribute.kind() == ast::AttrKind::Inner || !attr_completion.prefer_inner {\n+        if is_inner || !attr_completion.prefer_inner {\n             acc.add(item.build());\n         }\n+    };\n+\n+    match attributes {\n+        Some(applicable) => applicable\n+            .iter()\n+            .flat_map(|name| ATTRIBUTES.binary_search_by(|attr| attr.key().cmp(name)).ok())\n+            .flat_map(|idx| ATTRIBUTES.get(idx))\n+            .for_each(add_completion),\n+        None if is_inner => ATTRIBUTES.iter().for_each(add_completion),\n+        None => ATTRIBUTES.iter().filter(|compl| !compl.prefer_inner).for_each(add_completion),\n     }\n }\n \n@@ -70,6 +88,10 @@ struct AttrCompletion {\n }\n \n impl AttrCompletion {\n+    fn key(&self) -> &'static str {\n+        self.lookup.unwrap_or(self.label)\n+    }\n+\n     const fn prefer_inner(self) -> AttrCompletion {\n         AttrCompletion { prefer_inner: true, ..self }\n     }\n@@ -83,26 +105,81 @@ const fn attr(\n     AttrCompletion { label, lookup, snippet, prefer_inner: false }\n }\n \n+macro_rules! attrs {\n+    [$($($mac:ident!),+;)? $($key:literal),*] => {\n+        &[\"allow\", \"cfg\", \"cfg_attr\", \"deny\", \"forbid\", \"warn\", $($($mac!()),+,)? $($key),*] as _\n+    }\n+}\n+macro_rules! item_attrs {\n+    () => {\n+        \"deprecated\"\n+    };\n+}\n+\n+static KIND_TO_ATTRIBUTES: Lazy<FxHashMap<SyntaxKind, &[&str]>> = Lazy::new(|| {\n+    std::array::IntoIter::new([\n+        (SyntaxKind::SOURCE_FILE, attrs!(item_attrs!;\"crate_name\")),\n+        (SyntaxKind::MODULE, attrs!(item_attrs!;)),\n+        (SyntaxKind::ITEM_LIST, attrs!(item_attrs!;)),\n+        (SyntaxKind::MACRO_RULES, attrs!(item_attrs!;)),\n+        (SyntaxKind::MACRO_DEF, attrs!(item_attrs!;)),\n+        (SyntaxKind::EXTERN_CRATE, attrs!(item_attrs!;)),\n+        (SyntaxKind::USE, attrs!(item_attrs!;)),\n+        (SyntaxKind::FN, attrs!(item_attrs!;\"cold\", \"must_use\")),\n+        (SyntaxKind::TYPE_ALIAS, attrs!(item_attrs!;)),\n+        (SyntaxKind::STRUCT, attrs!(item_attrs!;\"must_use\")),\n+        (SyntaxKind::ENUM, attrs!(item_attrs!;\"must_use\")),\n+        (SyntaxKind::UNION, attrs!(item_attrs!;\"must_use\")),\n+        (SyntaxKind::CONST, attrs!(item_attrs!;)),\n+        (SyntaxKind::STATIC, attrs!(item_attrs!;)),\n+        (SyntaxKind::TRAIT, attrs!(item_attrs!; \"must_use\")),\n+        (SyntaxKind::IMPL, attrs!(item_attrs!;\"automatically_derived\")),\n+        (SyntaxKind::ASSOC_ITEM_LIST, attrs!(item_attrs!;)),\n+        (SyntaxKind::EXTERN_BLOCK, attrs!(item_attrs!;)),\n+        (SyntaxKind::EXTERN_ITEM_LIST, attrs!(item_attrs!;)),\n+        (SyntaxKind::MACRO_CALL, attrs!()),\n+        (SyntaxKind::SELF_PARAM, attrs!()),\n+        (SyntaxKind::PARAM, attrs!()),\n+        (SyntaxKind::RECORD_FIELD, attrs!()),\n+        (SyntaxKind::VARIANT, attrs!()),\n+        (SyntaxKind::TYPE_PARAM, attrs!()),\n+        (SyntaxKind::CONST_PARAM, attrs!()),\n+        (SyntaxKind::LIFETIME_PARAM, attrs!()),\n+        (SyntaxKind::LET_STMT, attrs!()),\n+        (SyntaxKind::EXPR_STMT, attrs!()),\n+        (SyntaxKind::LITERAL, attrs!()),\n+        (SyntaxKind::RECORD_EXPR_FIELD_LIST, attrs!()),\n+        (SyntaxKind::RECORD_EXPR_FIELD, attrs!()),\n+        (SyntaxKind::MATCH_ARM_LIST, attrs!()),\n+        (SyntaxKind::MATCH_ARM, attrs!()),\n+        (SyntaxKind::IDENT_PAT, attrs!()),\n+        (SyntaxKind::RECORD_PAT_FIELD, attrs!()),\n+    ])\n+    .collect()\n+});\n+const EXPR_ATTRIBUTES: &[&str] = attrs!();\n+\n /// https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index\n+// Keep these sorted for the binary search!\n const ATTRIBUTES: &[AttrCompletion] = &[\n     attr(\"allow(\u2026)\", Some(\"allow\"), Some(\"allow(${0:lint})\")),\n     attr(\"automatically_derived\", None, None),\n-    attr(\"cfg_attr(\u2026)\", Some(\"cfg_attr\"), Some(\"cfg_attr(${1:predicate}, ${0:attr})\")),\n     attr(\"cfg(\u2026)\", Some(\"cfg\"), Some(\"cfg(${0:predicate})\")),\n+    attr(\"cfg_attr(\u2026)\", Some(\"cfg_attr\"), Some(\"cfg_attr(${1:predicate}, ${0:attr})\")),\n     attr(\"cold\", None, None),\n     attr(r#\"crate_name = \"\"\"#, Some(\"crate_name\"), Some(r#\"crate_name = \"${0:crate_name}\"\"#))\n         .prefer_inner(),\n     attr(\"deny(\u2026)\", Some(\"deny\"), Some(\"deny(${0:lint})\")),\n     attr(r#\"deprecated\"#, Some(\"deprecated\"), Some(r#\"deprecated\"#)),\n     attr(\"derive(\u2026)\", Some(\"derive\"), Some(r#\"derive(${0:Debug})\"#)),\n+    attr(r#\"doc = \"\u2026\"\"#, Some(\"doc\"), Some(r#\"doc = \"${0:docs}\"\"#)),\n+    attr(r#\"doc(alias = \"\u2026\")\"#, Some(\"docalias\"), Some(r#\"doc(alias = \"${0:docs}\")\"#)),\n+    attr(r#\"doc(hidden)\"#, Some(\"dochidden\"), Some(r#\"doc(hidden)\"#)),\n     attr(\n         r#\"export_name = \"\u2026\"\"#,\n         Some(\"export_name\"),\n         Some(r#\"export_name = \"${0:exported_symbol_name}\"\"#),\n     ),\n-    attr(r#\"doc(alias = \"\u2026\")\"#, Some(\"docalias\"), Some(r#\"doc(alias = \"${0:docs}\")\"#)),\n-    attr(r#\"doc = \"\u2026\"\"#, Some(\"doc\"), Some(r#\"doc = \"${0:docs}\"\"#)),\n-    attr(r#\"doc(hidden)\"#, Some(\"dochidden\"), Some(r#\"doc(hidden)\"#)),\n     attr(\"feature(\u2026)\", Some(\"feature\"), Some(\"feature(${0:flag})\")).prefer_inner(),\n     attr(\"forbid(\u2026)\", Some(\"forbid\"), Some(\"forbid(${0:lint})\")),\n     // FIXME: resolve through macro resolution?\n@@ -119,8 +196,8 @@ const ATTRIBUTES: &[AttrCompletion] = &[\n     attr(\"macro_export\", None, None),\n     attr(\"macro_use\", None, None),\n     attr(r#\"must_use\"#, Some(\"must_use\"), Some(r#\"must_use\"#)),\n-    attr(\"no_link\", None, None).prefer_inner(),\n     attr(\"no_implicit_prelude\", None, None).prefer_inner(),\n+    attr(\"no_link\", None, None).prefer_inner(),\n     attr(\"no_main\", None, None).prefer_inner(),\n     attr(\"no_mangle\", None, None),\n     attr(\"no_std\", None, None).prefer_inner(),\n@@ -153,6 +230,22 @@ const ATTRIBUTES: &[AttrCompletion] = &[\n     .prefer_inner(),\n ];\n \n+#[test]\n+fn attributes_are_sorted() {\n+    let mut attrs = ATTRIBUTES.iter().map(|attr| attr.key());\n+    let mut prev = attrs.next().unwrap();\n+\n+    attrs.for_each(|next| {\n+        assert!(\n+            prev < next,\n+            r#\"Attributes are not sorted, \"{}\" should come after \"{}\"\"#,\n+            prev,\n+            next\n+        );\n+        prev = next;\n+    });\n+}\n+\n fn complete_derive(acc: &mut Completions, ctx: &CompletionContext, derive_input: ast::TokenTree) {\n     if let Ok(existing_derives) = parse_comma_sep_input(derive_input) {\n         for derive_completion in DEFAULT_DERIVE_COMPLETIONS\n@@ -409,6 +502,26 @@ mod tests {\n         expect.assert_eq(&actual);\n     }\n \n+    #[test]\n+    fn complete_attribute_on_struct() {\n+        check(\n+            r#\"\n+#[$0]\n+struct Test {}\n+        \"#,\n+            expect![[r#\"\n+                at allow(\u2026)\n+                at cfg(\u2026)\n+                at cfg_attr(\u2026)\n+                at deny(\u2026)\n+                at forbid(\u2026)\n+                at warn(\u2026)\n+                at deprecated\n+                at must_use\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn empty_derive_completion() {\n         check(\n@@ -468,16 +581,16 @@ struct Test {}\n             expect![[r#\"\n                 at allow(\u2026)\n                 at automatically_derived\n-                at cfg_attr(\u2026)\n                 at cfg(\u2026)\n+                at cfg_attr(\u2026)\n                 at cold\n                 at deny(\u2026)\n                 at deprecated\n                 at derive(\u2026)\n-                at export_name = \"\u2026\"\n-                at doc(alias = \"\u2026\")\n                 at doc = \"\u2026\"\n+                at doc(alias = \"\u2026\")\n                 at doc(hidden)\n+                at export_name = \"\u2026\"\n                 at forbid(\u2026)\n                 at ignore = \"\u2026\"\n                 at inline\n@@ -516,17 +629,17 @@ struct Test {}\n             expect![[r#\"\n                 at allow(\u2026)\n                 at automatically_derived\n-                at cfg_attr(\u2026)\n                 at cfg(\u2026)\n+                at cfg_attr(\u2026)\n                 at cold\n                 at crate_name = \"\"\n                 at deny(\u2026)\n                 at deprecated\n                 at derive(\u2026)\n-                at export_name = \"\u2026\"\n-                at doc(alias = \"\u2026\")\n                 at doc = \"\u2026\"\n+                at doc(alias = \"\u2026\")\n                 at doc(hidden)\n+                at export_name = \"\u2026\"\n                 at feature(\u2026)\n                 at forbid(\u2026)\n                 at global_allocator\n@@ -538,8 +651,8 @@ struct Test {}\n                 at macro_export\n                 at macro_use\n                 at must_use\n-                at no_link\n                 at no_implicit_prelude\n+                at no_link\n                 at no_main\n                 at no_mangle\n                 at no_std"}, {"sha": "884fe0739dba4da6787a52596f3a1a3b9dea4656", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fc37e2f953a0d200e875c4711c1b0bf79a75a2a2/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc37e2f953a0d200e875c4711c1b0bf79a75a2a2/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=fc37e2f953a0d200e875c4711c1b0bf79a75a2a2", "patch": "@@ -243,6 +243,13 @@ impl ast::Path {\n         }\n     }\n \n+    pub fn as_single_name_ref(&self) -> Option<ast::NameRef> {\n+        match self.qualifier() {\n+            Some(_) => None,\n+            None => self.segment()?.name_ref(),\n+        }\n+    }\n+\n     pub fn first_qualifier_or_self(&self) -> ast::Path {\n         successors(Some(self.clone()), ast::Path::qualifier).last().unwrap()\n     }"}]}