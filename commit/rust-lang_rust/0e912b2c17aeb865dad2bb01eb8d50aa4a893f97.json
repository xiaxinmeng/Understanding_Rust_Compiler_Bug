{"sha": "0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlOTEyYjJjMTdhZWI4NjVkYWQyYmIwMWViOGQ1MGFhNGE4OTNmOTc=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-11-10T23:21:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-10T23:21:11Z"}, "message": "Rollup merge of #55687 - alexreg:fix-24010, r=scalexm\n\nTake supertraits into account when calculating associated types\n\nFixes #24010 and #23856. Applies to trait aliases too.\n\nAs a by-product, this PR also makes repeated bindings of the same associated item in the same definition a hard error. This was previously a warning with a note about it becoming a hard error in the future. See #50589 for more info.\n\nI talked about this with @nikomatsakis recently, but only very superficially, so this shouldn't stop anyone from assigning it to themself to review and r+.\n\nN.B. The \"WIP\" commits represent imperfect attempts to solve the problem just for trait objects, but I've left them in for reference for the sake of whomever is reviewing this.\n\nCC @carllerche @theemathas @durka @mbrubeck", "tree": {"sha": "183f92093a82a01472ce3161ad8d1fc0ce863e30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/183f92093a82a01472ce3161ad8d1fc0ce863e30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb52fnCRBK7hj4Ov3rIwAAdHIIAEzgG7mXi8r0Ad2kk1/DQ4Gc\nHKdEXIF8VdXtyd7OHzqYCZK0UDfaenhbsyrXE0zlvw6I/Ws7qp7J6MtZvZMxgfw4\nzkg3WYLC9NbJJVkgm3GrikhYuTxvvZQAXHuFoJW/k8rlBzMdg/rW7i0hnMF2riox\n8MRUywWC4bh3RVz0hF3xc7eNDN0IeYb9t1AdgapIbEHS9NHST2cWnAohId9rBZJL\neKfheb3OYPIO9ej3onjd8Cy2Fvnm4ujBtQixCBuKszLP89nmqxUjoMXr43peERzv\na3II4//GMQ7AkdIbveNgcnSMRg3LbqaWX6PmPDEexTOCoF8ZcM6q18P7Qr3h99I=\n=PMrA\n-----END PGP SIGNATURE-----\n", "payload": "tree 183f92093a82a01472ce3161ad8d1fc0ce863e30\nparent 6e9b84296223126a0a59bde63a0f97011bb7b0f5\nparent 90a14389d1823e4b8dc4ee2e306dd953e1992e08\nauthor Pietro Albini <pietro@pietroalbini.org> 1541892071 +0100\ncommitter GitHub <noreply@github.com> 1541892071 +0100\n\nRollup merge of #55687 - alexreg:fix-24010, r=scalexm\n\nTake supertraits into account when calculating associated types\n\nFixes #24010 and #23856. Applies to trait aliases too.\n\nAs a by-product, this PR also makes repeated bindings of the same associated item in the same definition a hard error. This was previously a warning with a note about it becoming a hard error in the future. See #50589 for more info.\n\nI talked about this with @nikomatsakis recently, but only very superficially, so this shouldn't stop anyone from assigning it to themself to review and r+.\n\nN.B. The \"WIP\" commits represent imperfect attempts to solve the problem just for trait objects, but I've left them in for reference for the sake of whomever is reviewing this.\n\nCC @carllerche @theemathas @durka @mbrubeck\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "html_url": "https://github.com/rust-lang/rust/commit/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e9b84296223126a0a59bde63a0f97011bb7b0f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e9b84296223126a0a59bde63a0f97011bb7b0f5", "html_url": "https://github.com/rust-lang/rust/commit/6e9b84296223126a0a59bde63a0f97011bb7b0f5"}, {"sha": "90a14389d1823e4b8dc4ee2e306dd953e1992e08", "url": "https://api.github.com/repos/rust-lang/rust/commits/90a14389d1823e4b8dc4ee2e306dd953e1992e08", "html_url": "https://github.com/rust-lang/rust/commit/90a14389d1823e4b8dc4ee2e306dd953e1992e08"}], "stats": {"total": 501, "additions": 302, "deletions": 199}, "files": [{"sha": "96590c1fc72d400c8724e663dd39598da5fad024", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -2134,7 +2134,7 @@ static X: u32 = 42;\n \n \n register_diagnostics! {\n-//  E0006 // merged with E0005\n+//  E0006, // merged with E0005\n //  E0101, // replaced with E0282\n //  E0102, // replaced with E0282\n //  E0134,\n@@ -2183,9 +2183,7 @@ register_diagnostics! {\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n-\n     E0697, // closures cannot be static\n-\n     E0707, // multiple elided lifetimes used in arguments of `async fn`\n     E0708, // `async` non-`move` closures with arguments are not currently supported\n     E0709, // multiple different lifetimes used in arguments of `async fn`"}, {"sha": "f57e3ff913b38dd407a7b856fde7093c2281edc4", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -506,9 +506,9 @@ pub enum TraitBoundModifier {\n }\n \n /// The AST represents all type param bounds as types.\n-/// typeck::collect::compute_bounds matches these against\n-/// the \"special\" built-in traits (see middle::lang_items) and\n-/// detects Copy, Send and Sync.\n+/// `typeck::collect::compute_bounds` matches these against\n+/// the \"special\" built-in traits (see `middle::lang_items`) and\n+/// detects `Copy`, `Send` and `Sync`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),"}, {"sha": "01d87bdbf63374ff4b38e86f077bd8444c38fdfd", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -300,12 +300,6 @@ declare_lint! {\n     \"detects labels that are never used\"\n }\n \n-declare_lint! {\n-    pub DUPLICATE_ASSOCIATED_TYPE_BINDINGS,\n-    Warn,\n-    \"warns about duplicate associated type bindings in generics\"\n-}\n-\n declare_lint! {\n     pub DUPLICATE_MACRO_EXPORTS,\n     Deny,\n@@ -418,7 +412,6 @@ impl LintPass for HardwiredLints {\n             ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n             UNSTABLE_NAME_COLLISIONS,\n             IRREFUTABLE_LET_PATTERNS,\n-            DUPLICATE_ASSOCIATED_TYPE_BINDINGS,\n             DUPLICATE_MACRO_EXPORTS,\n             INTRA_DOC_LINK_RESOLUTION_FAILURE,\n             MISSING_DOC_CODE_EXAMPLES,"}, {"sha": "33b689c60a1188dad35d27597bbe23a67b77ce53", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -50,11 +50,8 @@ pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::find_associated_item;\n pub use self::engine::{TraitEngine, TraitEngineExt};\n-pub use self::util::elaborate_predicates;\n-pub use self::util::supertraits;\n-pub use self::util::Supertraits;\n-pub use self::util::supertrait_def_ids;\n-pub use self::util::SupertraitDefIds;\n+pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n+pub use self::util::{supertraits, supertrait_def_ids, Supertraits, SupertraitDefIds};\n pub use self::util::transitive_bounds;\n \n #[allow(dead_code)]"}, {"sha": "24097fcca703b934e89c59ec813643ae3b571497", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -333,7 +333,7 @@ impl<I> FilterToTraits<I> {\n     }\n }\n \n-impl<'tcx,I:Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n+impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {"}, {"sha": "ef9b3e3efab275f3421c3ea5eb9bcede113efa92", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -294,7 +294,7 @@ impl Visibility {\n         }\n     }\n \n-    /// Returns true if an item with this visibility is accessible from the given block.\n+    /// Returns `true` if an item with this visibility is accessible from the given block.\n     pub fn is_accessible_from<T: DefIdTree>(self, module: DefId, tree: T) -> bool {\n         let restriction = match self {\n             // Public items are visible everywhere.\n@@ -309,7 +309,7 @@ impl Visibility {\n         tree.is_descendant_of(module, restriction)\n     }\n \n-    /// Returns true if this visibility is at least as accessible as the given visibility\n+    /// Returns `true` if this visibility is at least as accessible as the given visibility\n     pub fn is_at_least<T: DefIdTree>(self, vis: Visibility, tree: T) -> bool {\n         let vis_restriction = match vis {\n             Visibility::Public => return self == Visibility::Public,\n@@ -320,7 +320,7 @@ impl Visibility {\n         self.is_accessible_from(vis_restriction, tree)\n     }\n \n-    // Returns true if this item is visible anywhere in the local crate.\n+    // Returns `true` if this item is visible anywhere in the local crate.\n     pub fn is_visible_locally(self) -> bool {\n         match self {\n             Visibility::Public => true,\n@@ -451,7 +451,7 @@ bitflags! {\n         // FIXME: Rename this to the actual property since it's used for generators too\n         const HAS_TY_CLOSURE     = 1 << 9;\n \n-        // true if there are \"names\" of types and regions and so forth\n+        // `true` if there are \"names\" of types and regions and so forth\n         // that are local to a particular fn\n         const HAS_FREE_LOCAL_NAMES    = 1 << 10;\n \n@@ -544,14 +544,14 @@ impl<'tcx> TyS<'tcx> {\n     pub fn is_primitive_ty(&self) -> bool {\n         match self.sty {\n             TyKind::Bool |\n-                TyKind::Char |\n-                TyKind::Int(_) |\n-                TyKind::Uint(_) |\n-                TyKind::Float(_) |\n-                TyKind::Infer(InferTy::IntVar(_)) |\n-                TyKind::Infer(InferTy::FloatVar(_)) |\n-                TyKind::Infer(InferTy::FreshIntTy(_)) |\n-                TyKind::Infer(InferTy::FreshFloatTy(_)) => true,\n+            TyKind::Char |\n+            TyKind::Int(_) |\n+            TyKind::Uint(_) |\n+            TyKind::Float(_) |\n+            TyKind::Infer(InferTy::IntVar(_)) |\n+            TyKind::Infer(InferTy::FloatVar(_)) |\n+            TyKind::Infer(InferTy::FreshIntTy(_)) |\n+            TyKind::Infer(InferTy::FreshFloatTy(_)) => true,\n             TyKind::Ref(_, x, _) => x.is_primitive_ty(),\n             _ => false,\n         }\n@@ -953,7 +953,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n                 _ => bug!(\"expected lifetime parameter, but found another generic parameter\")\n             }\n         } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n                .region_param(param, tcx)\n         }\n     }\n@@ -970,7 +970,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n                 _ => bug!(\"expected type parameter, but found another generic parameter\")\n             }\n         } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n                .type_param(param, tcx)\n         }\n     }\n@@ -993,6 +993,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n         self.instantiate_into(tcx, &mut instantiated, substs);\n         instantiated\n     }\n+\n     pub fn instantiate_own(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                            -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n@@ -1041,15 +1042,15 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Predicate<'tcx> {\n-    /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n+    /// Corresponds to `where Foo: Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n     Trait(PolyTraitPredicate<'tcx>),\n \n-    /// where `'a : 'b`\n+    /// where `'a: 'b`\n     RegionOutlives(PolyRegionOutlivesPredicate<'tcx>),\n \n-    /// where `T : 'a`\n+    /// where `T: 'a`\n     TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n \n     /// where `<T as TraitRef>::Name == X`, approximately.\n@@ -1062,7 +1063,7 @@ pub enum Predicate<'tcx> {\n     /// trait must be object-safe\n     ObjectSafe(DefId),\n \n-    /// No direct syntax. May be thought of as `where T : FnFoo<...>`\n+    /// No direct syntax. May be thought of as `where T: FnFoo<...>`\n     /// for some substitutions `...` and `T` being a closure type.\n     /// Satisfied (or refuted) once we know the closure's kind.\n     ClosureKind(DefId, ClosureSubsts<'tcx>, ClosureKind),\n@@ -1111,11 +1112,11 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n         //\n         // Let's start with an easy case. Consider two traits:\n         //\n-        //     trait Foo<'a> : Bar<'a,'a> { }\n+        //     trait Foo<'a>: Bar<'a,'a> { }\n         //     trait Bar<'b,'c> { }\n         //\n-        // Now, if we have a trait reference `for<'x> T : Foo<'x>`, then\n-        // we can deduce that `for<'x> T : Bar<'x,'x>`. Basically, if we\n+        // Now, if we have a trait reference `for<'x> T: Foo<'x>`, then\n+        // we can deduce that `for<'x> T: Bar<'x,'x>`. Basically, if we\n         // knew that `Foo<'x>` (for any 'x) then we also know that\n         // `Bar<'x,'x>` (for any 'x). This more-or-less falls out from\n         // normal substitution.\n@@ -1128,21 +1129,21 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n         //\n         // Another example to be careful of is this:\n         //\n-        //     trait Foo1<'a> : for<'b> Bar1<'a,'b> { }\n+        //     trait Foo1<'a>: for<'b> Bar1<'a,'b> { }\n         //     trait Bar1<'b,'c> { }\n         //\n-        // Here, if we have `for<'x> T : Foo1<'x>`, then what do we know?\n-        // The answer is that we know `for<'x,'b> T : Bar1<'x,'b>`. The\n+        // Here, if we have `for<'x> T: Foo1<'x>`, then what do we know?\n+        // The answer is that we know `for<'x,'b> T: Bar1<'x,'b>`. The\n         // reason is similar to the previous example: any impl of\n-        // `T:Foo1<'x>` must show that `for<'b> T : Bar1<'x, 'b>`.  So\n+        // `T:Foo1<'x>` must show that `for<'b> T: Bar1<'x, 'b>`.  So\n         // basically we would want to collapse the bound lifetimes from\n         // the input (`trait_ref`) and the supertraits.\n         //\n         // To achieve this in practice is fairly straightforward. Let's\n         // consider the more complicated scenario:\n         //\n-        // - We start out with `for<'x> T : Foo1<'x>`. In this case, `'x`\n-        //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T : Bar1<'x,'b>`,\n+        // - We start out with `for<'x> T: Foo1<'x>`. In this case, `'x`\n+        //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T: Bar1<'x,'b>`,\n         //   where both `'x` and `'b` would have a DB index of 1.\n         //   The substitution from the input trait-ref is therefore going to be\n         //   `'a => 'x` (where `'x` has a DB index of 1).\n@@ -1194,6 +1195,7 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>\n }\n+\n pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n \n impl<'tcx> TraitPredicate<'tcx> {\n@@ -1218,7 +1220,7 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n+pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A: B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>,\n                                                            ty::Region<'tcx>>;\n@@ -1238,11 +1240,11 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n ///\n-/// 1. `T : TraitRef<..., Item=Type>`\n+/// 1. `T: TraitRef<..., Item=Type>`\n /// 2. `<T as TraitRef<...>>::Item == Type` (NYI)\n ///\n /// In particular, form #1 is \"desugared\" to the combination of a\n-/// normal trait predicate (`T : TraitRef<...>`) and one of these\n+/// normal trait predicate (`T: TraitRef<...>`) and one of these\n /// predicates. Form #2 is a broader form in that it also permits\n /// equality between arbitrary types. Processing an instance of\n /// Form #2 eventually yields one of these `ProjectionPredicate`\n@@ -1256,14 +1258,14 @@ pub struct ProjectionPredicate<'tcx> {\n pub type PolyProjectionPredicate<'tcx> = Binder<ProjectionPredicate<'tcx>>;\n \n impl<'tcx> PolyProjectionPredicate<'tcx> {\n-    /// Returns the def-id of the associated item being projected.\n+    /// Returns the `DefId` of the associated item being projected.\n     pub fn item_def_id(&self) -> DefId {\n         self.skip_binder().projection_ty.item_def_id\n     }\n \n     pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'_, '_, '_>) -> PolyTraitRef<'tcx> {\n-        // Note: unlike with TraitRef::to_poly_trait_ref(),\n-        // self.0.trait_ref is permitted to have escaping regions.\n+        // Note: unlike with `TraitRef::to_poly_trait_ref()`,\n+        // `self.0.trait_ref` is permitted to have escaping regions.\n         // This is because here `self` has a `Binder` and so does our\n         // return value, so we are preserving the number of binding\n         // levels.\n@@ -1274,12 +1276,12 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.map_bound(|predicate| predicate.ty)\n     }\n \n-    /// The DefId of the TraitItem for the associated type.\n+    /// The `DefId` of the `TraitItem` for the associated type.\n     ///\n-    /// Note that this is not the DefId of the TraitRef containing this\n-    /// associated type, which is in tcx.associated_item(projection_def_id()).container.\n+    /// Note that this is not the `DefId` of the `TraitRef` containing this\n+    /// associated type, which is in `tcx.associated_item(projection_def_id()).container`.\n     pub fn projection_def_id(&self) -> DefId {\n-        // ok to skip binder since trait def-id does not care about regions\n+        // okay to skip binder since trait def-id does not care about regions\n         self.skip_binder().projection_ty.item_def_id\n     }\n }\n@@ -1515,14 +1517,14 @@ impl UniverseIndex {\n         UniverseIndex::from_u32(self.private.checked_add(1).unwrap())\n     }\n \n-    /// True if `self` can name a name from `other` -- in other words,\n+    /// Returns `true` if `self` can name a name from `other` -- in other words,\n     /// if the set of names in `self` is a superset of those in\n     /// `other` (`self >= other`).\n     pub fn can_name(self, other: UniverseIndex) -> bool {\n         self.private >= other.private\n     }\n \n-    /// True if `self` cannot name some names from `other` -- in other\n+    /// Returns `true` if `self` cannot name some names from `other` -- in other\n     /// words, if the set of names in `self` is a strict subset of\n     /// those in `other` (`self < other`).\n     pub fn cannot_name(self, other: UniverseIndex) -> bool {\n@@ -1574,7 +1576,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// are revealed. This is suitable for monomorphized, post-typeck\n     /// environments like codegen or doing optimizations.\n     ///\n-    /// NB. If you want to have predicates in scope, use `ParamEnv::new`,\n+    /// N.B. If you want to have predicates in scope, use `ParamEnv::new`,\n     /// or invoke `param_env.with_reveal_all()`.\n     pub fn reveal_all() -> Self {\n         Self::new(List::empty(), Reveal::All)\n@@ -1979,14 +1981,14 @@ impl ReprOptions {\n         self.int.unwrap_or(attr::SignedInt(ast::IntTy::Isize))\n     }\n \n-    /// Returns true if this `#[repr()]` should inhabit \"smart enum\n+    /// Returns `true` if this `#[repr()]` should inhabit \"smart enum\n     /// layout\" optimizations, such as representing `Foo<&T>` as a\n     /// single pointer.\n     pub fn inhibit_enum_layout_opt(&self) -> bool {\n         self.c() || self.int.is_some()\n     }\n \n-    /// Returns true if this `#[repr()]` should inhibit struct field reordering\n+    /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n     /// optimizations, such as with repr(C) or repr(packed(1)).\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n         !(self.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty() || (self.pack == 1)\n@@ -2089,7 +2091,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.intersects(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n-    /// Returns true if this is PhantomData<T>.\n+    /// Returns `true` if this is PhantomData<T>.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n         self.flags.intersects(AdtFlags::IS_PHANTOM_DATA)\n@@ -2105,7 +2107,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.intersects(AdtFlags::IS_RC)\n     }\n \n-    /// Returns true if this is Box<T>.\n+    /// Returns `true` if this is Box<T>.\n     #[inline]\n     pub fn is_box(&self) -> bool {\n         self.flags.intersects(AdtFlags::IS_BOX)\n@@ -2422,7 +2424,7 @@ impl<'a, 'tcx> ClosureKind {\n         }\n     }\n \n-    /// True if this a type that impls this closure kind\n+    /// Returns `true` if this a type that impls this closure kind\n     /// must also implement `other`.\n     pub fn extends(self, other: ty::ClosureKind) -> bool {\n         match (self, other) {\n@@ -2475,7 +2477,7 @@ impl<'tcx> TyS<'tcx> {\n     ///\n     /// Note: prefer `ty.walk()` where possible.\n     pub fn maybe_walk<F>(&'tcx self, mut f: F)\n-        where F : FnMut(Ty<'tcx>) -> bool\n+        where F: FnMut(Ty<'tcx>) -> bool\n     {\n         let mut walker = self.walk();\n         while let Some(ty) = walker.next() {\n@@ -2678,7 +2680,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             as Box<dyn Iterator<Item = AssociatedItem> + 'a>\n     }\n \n-    /// Returns true if the impls are the same polarity and the trait either\n+    /// Returns `true` if the impls are the same polarity and the trait either\n     /// has no items or is annotated #[marker] and prevents item overrides.\n     pub fn impls_are_allowed_to_overlap(self, def_id1: DefId, def_id2: DefId) -> bool {\n         if self.features().overlapping_marker_traits {\n@@ -2802,7 +2804,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         attr::contains_name(&self.get_attrs(did), attr)\n     }\n \n-    /// Returns true if this is an `auto trait`.\n+    /// Returns `true` if this is an `auto trait`.\n     pub fn trait_is_auto(self, trait_def_id: DefId) -> bool {\n         self.trait_def(trait_def_id).has_auto_impl\n     }"}, {"sha": "5c8549cba2333e3a37a5a7ee43a69709d16af263", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -627,7 +627,7 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n /// A complete reference to a trait. These take numerous guises in syntax,\n /// but perhaps the most recognizable form is in a where clause:\n ///\n-///     T : Foo<U>\n+///     T: Foo<U>\n ///\n /// This would be represented by a trait-reference where the def-id is the\n /// def-id for the trait `Foo` and the substs define `T` as parameter 0,\n@@ -637,8 +637,8 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n /// that case the `Self` parameter is absent from the substitutions.\n ///\n /// Note that a `TraitRef` introduces a level of region binding, to\n-/// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n-/// U>` or higher-ranked object types.\n+/// account for higher-ranked trait bounds like `T: for<'a> Foo<&'a U>`\n+/// or higher-ranked object types.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n@@ -663,7 +663,7 @@ impl<'tcx> TraitRef<'tcx> {\n         self.substs.type_at(0)\n     }\n \n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n@@ -886,16 +886,16 @@ pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n     pub substs: &'tcx Substs<'tcx>,\n \n-    /// The DefId of the TraitItem for the associated type N.\n+    /// The `DefId` of the `TraitItem` for the associated type `N`.\n     ///\n-    /// Note that this is not the DefId of the TraitRef containing this\n-    /// associated type, which is in tcx.associated_item(item_def_id).container.\n+    /// Note that this is not the `DefId` of the `TraitRef` containing this\n+    /// associated type, which is in `tcx.associated_item(item_def_id).container`.\n     pub item_def_id: DefId,\n }\n \n impl<'a, 'tcx> ProjectionTy<'tcx> {\n-    /// Construct a ProjectionTy by searching the trait from trait_ref for the\n-    /// associated item named item_name.\n+    /// Construct a `ProjectionTy` by searching the trait from `trait_ref` for the\n+    /// associated item named `item_name`.\n     pub fn from_ref_and_name(\n         tcx: TyCtxt<'_, '_, '_>, trait_ref: ty::TraitRef<'tcx>, item_name: Ident\n     ) -> ProjectionTy<'tcx> {"}, {"sha": "b28e7c9fb199be7daaacce299e889784c7375078", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -27,7 +27,7 @@ use std::marker::PhantomData;\n use std::mem;\n use std::num::NonZeroUsize;\n \n-/// An entity in the Rust typesystem, which can be one of\n+/// An entity in the Rust type system, which can be one of\n /// several kinds (only types and lifetimes for now).\n /// To reduce memory usage, a `Kind` is a interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n@@ -171,17 +171,17 @@ impl<'tcx> Decodable for Kind<'tcx> {\n pub type Substs<'tcx> = List<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n-    /// Creates a Substs that maps each generic parameter to itself.\n+    /// Creates a `Substs` that maps each generic parameter to itself.\n     pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId)\n                              -> &'tcx Substs<'tcx> {\n         Substs::for_item(tcx, def_id, |param, _| {\n             tcx.mk_param_from_def(param)\n         })\n     }\n \n-    /// Creates a Substs for generic parameter definitions,\n+    /// Creates a `Substs` for generic parameter definitions,\n     /// by calling closures to obtain each kind.\n-    /// The closures get to observe the Substs as they're\n+    /// The closures get to observe the `Substs` as they're\n     /// being built, which can be used to correctly\n     /// substitute defaults of generic parameters.\n     pub fn for_item<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -242,7 +242,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn types(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+    pub fn types(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n             if let UnpackedKind::Type(ty) = k.unpack() {\n                 Some(ty)\n@@ -253,7 +253,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=ty::Region<'tcx>> + 'a {\n+    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item = ty::Region<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n             if let UnpackedKind::Lifetime(lt) = k.unpack() {\n                 Some(lt)\n@@ -332,7 +332,7 @@ impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n // `foo`. Or use `foo.subst_spanned(tcx, substs, Some(span))` when\n // there is more information available (for better errors).\n \n-pub trait Subst<'tcx> : Sized {\n+pub trait Subst<'tcx>: Sized {\n     fn subst<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                        substs: &[Kind<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)"}, {"sha": "8c0e9bd11a173da5813c13157f8244af22204632", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -317,11 +317,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             reference: \"issue #51443 <https://github.com/rust-lang/rust/issues/51443>\",\n             edition: None,\n         },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(DUPLICATE_ASSOCIATED_TYPE_BINDINGS),\n-            reference: \"issue #50589 <https://github.com/rust-lang/rust/issues/50589>\",\n-            edition: None,\n-        },\n         FutureIncompatibleInfo {\n             id: LintId::of(PROC_MACRO_DERIVE_RESOLUTION_FALLBACK),\n             reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\","}, {"sha": "572e79407a10be41586bc8b9d38d5aeb33de66a6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 57, "deletions": 51, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -37,7 +37,7 @@ use std::iter;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax_pos::{Span, MultiSpan};\n+use syntax_pos::{DUMMY_SP, Span, MultiSpan};\n \n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n@@ -451,7 +451,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         }\n \n         // We manually build up the substitution, rather than using convenience\n-        // methods in subst.rs so that we can iterate over the arguments and\n+        // methods in `subst.rs` so that we can iterate over the arguments and\n         // parameters in lock-step linearly, rather than trying to match each pair.\n         let mut substs: SmallVec<[Kind<'tcx>; 8]> = SmallVec::with_capacity(count);\n \n@@ -469,7 +469,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 }\n             }\n \n-            // (Unless it's been handled in `parent_substs`) `Self` is handled first.\n+            // `Self` is handled first, unless it's been handled in `parent_substs`.\n             if has_self {\n                 if let Some(&param) = params.peek() {\n                     if param.index == 0 {\n@@ -698,7 +698,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                         trait_ref.path.segments.last().unwrap())\n     }\n \n-    /// Get the DefId of the given trait ref. It _must_ actually be a trait.\n+    /// Get the `DefId` of the given trait ref. It _must_ actually be a trait.\n     fn trait_def_id(&self, trait_ref: &hir::TraitRef) -> DefId {\n         let path = &trait_ref.path;\n         match path.def {\n@@ -711,7 +711,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    /// The given `trait_ref` must actually be trait.\n+    /// The given trait ref must actually be a trait.\n     pub(super) fn instantiate_poly_trait_ref_inner(&self,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>,\n@@ -738,7 +738,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             let predicate: Result<_, ErrorReported> =\n                 self.ast_type_binding_to_poly_projection_predicate(\n                     trait_ref.ref_id, poly_trait_ref, binding, speculative, &mut dup_bindings);\n-            // ok to ignore Err because ErrorReported (see above)\n+            // okay to ignore Err because of ErrorReported (see above)\n             Some((predicate.ok()?, binding.span))\n         }));\n \n@@ -831,15 +831,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n \n         if !speculative {\n-            // Given something like `U : SomeTrait<T=X>`, we want to produce a\n+            // Given something like `U: SomeTrait<T = X>`, we want to produce a\n             // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n             // subtle in the event that `T` is defined in a supertrait of\n             // `SomeTrait`, because in that case we need to upcast.\n             //\n             // That is, consider this case:\n             //\n             // ```\n-            // trait SubTrait : SuperTrait<int> { }\n+            // trait SubTrait: SuperTrait<int> { }\n             // trait SuperTrait<A> { type T; }\n             //\n             // ... B : SubTrait<T=foo> ...\n@@ -908,16 +908,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         if !speculative {\n             dup_bindings.entry(assoc_ty.def_id)\n                 .and_modify(|prev_span| {\n-                    let mut err = self.tcx().struct_span_lint_node(\n-                        ::rustc::lint::builtin::DUPLICATE_ASSOCIATED_TYPE_BINDINGS,\n-                        ref_id,\n-                        binding.span,\n-                        &format!(\"associated type binding `{}` specified more than once\",\n-                                 binding.item_name)\n-                    );\n-                    err.span_label(binding.span, \"used more than once\");\n-                    err.span_label(*prev_span, format!(\"first use of `{}`\", binding.item_name));\n-                    err.emit();\n+                    struct_span_err!(self.tcx().sess, binding.span, E0719,\n+                                     \"the value of the associated type `{}` (from the trait `{}`) \\\n+                                      is already specified\",\n+                                     binding.item_name,\n+                                     tcx.item_path_str(assoc_ty.container.id()))\n+                        .span_label(binding.span, \"re-bound here\")\n+                        .span_label(*prev_span, format!(\"`{}` bound here first\", binding.item_name))\n+                        .emit();\n                 })\n                 .or_insert(binding.span);\n         }\n@@ -969,7 +967,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        let mut projection_bounds = vec![];\n+        let mut projection_bounds = Vec::new();\n         let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n         let principal = self.instantiate_poly_trait_ref(&trait_bounds[0],\n                                                         dummy_self,\n@@ -994,23 +992,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 .emit();\n         }\n \n-        // Erase the dummy_self (TRAIT_OBJECT_DUMMY_SELF) used above.\n-        let existential_principal = principal.map_bound(|trait_ref| {\n-            self.trait_ref_to_existential(trait_ref)\n-        });\n-        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n-            bound.map_bound(|b| {\n-                let trait_ref = self.trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n-                ty::ExistentialProjection {\n-                    ty: b.ty,\n-                    item_def_id: b.projection_ty.item_def_id,\n-                    substs: trait_ref.substs,\n-                }\n-            })\n-        });\n-\n         // Check that there are no gross object safety violations;\n-        // most importantly, that the supertraits don't contain Self,\n+        // most importantly, that the supertraits don't contain `Self`,\n         // to avoid ICEs.\n         let object_safety_violations =\n             tcx.global_tcx().astconv_object_safety_violations(principal.def_id());\n@@ -1021,13 +1004,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        // Use a BTreeSet to keep output in a more consistent order.\n+        // Use a `BTreeSet` to keep output in a more consistent order.\n         let mut associated_types = BTreeSet::default();\n \n-        for tr in traits::supertraits(tcx, principal) {\n-            associated_types.extend(tcx.associated_items(tr.def_id())\n-                .filter(|item| item.kind == ty::AssociatedKind::Type)\n-                .map(|item| item.def_id));\n+        for tr in traits::elaborate_trait_ref(tcx, principal) {\n+            match tr {\n+                ty::Predicate::Trait(pred) => {\n+                    associated_types.extend(tcx.associated_items(pred.def_id())\n+                                    .filter(|item| item.kind == ty::AssociatedKind::Type)\n+                                    .map(|item| item.def_id));\n+                }\n+                ty::Predicate::Projection(pred) => {\n+                    // Include projections defined on supertraits.\n+                    projection_bounds.push((pred, DUMMY_SP))\n+                }\n+                _ => ()\n+            }\n         }\n \n         for (projection_bound, _) in &projection_bounds {\n@@ -1046,11 +1038,26 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 .emit();\n         }\n \n+        // Erase the `dummy_self` (`TRAIT_OBJECT_DUMMY_SELF`) used above.\n+        let existential_principal = principal.map_bound(|trait_ref| {\n+            self.trait_ref_to_existential(trait_ref)\n+        });\n+        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n+            bound.map_bound(|b| {\n+                let trait_ref = self.trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n+                ty::ExistentialProjection {\n+                    ty: b.ty,\n+                    item_def_id: b.projection_ty.item_def_id,\n+                    substs: trait_ref.substs,\n+                }\n+            })\n+        });\n+\n         // Dedup auto traits so that `dyn Trait + Send + Send` is the same as `dyn Trait + Send`.\n         auto_traits.sort();\n         auto_traits.dedup();\n \n-        // skip_binder is okay, because the predicates are re-bound.\n+        // Calling `skip_binder` is okay, because the predicates are re-bound.\n         let mut v =\n             iter::once(ty::ExistentialPredicate::Trait(*existential_principal.skip_binder()))\n             .chain(auto_traits.into_iter().map(ty::ExistentialPredicate::AutoTrait))\n@@ -1128,8 +1135,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                       span)\n     }\n \n-\n-    // Checks that bounds contains exactly one element and reports appropriate\n+    // Checks that `bounds` contains exactly one element and reports appropriate\n     // errors otherwise.\n     fn one_bound_for_assoc_type<I>(&self,\n                                    mut bounds: I,\n@@ -1186,11 +1192,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     }\n \n     // Create a type from a path to an associated type.\n-    // For a path A::B::C::D, ty and ty_path_def are the type and def for A::B::C\n-    // and item_segment is the path segment for D. We return a type and a def for\n+    // For a path `A::B::C::D`, `ty` and `ty_path_def` are the type and def for `A::B::C`\n+    // and item_segment is the path segment for `D`. We return a type and a def for\n     // the whole path.\n-    // Will fail except for T::A and Self::A; i.e., if ty/ty_path_def are not a type\n-    // parameter or Self.\n+    // Will fail except for `T::A` and `Self::A`; i.e., if `ty`/`ty_path_def` are not a type\n+    // parameter or `Self`.\n     pub fn associated_path_def_to_ty(&self,\n                                      ref_id: ast::NodeId,\n                                      span: Span,\n@@ -1210,7 +1216,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         // item is declared.\n         let bound = match (&ty.sty, ty_path_def) {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n-                // `Self` in an impl of a trait - we have a concrete self type and a\n+                // `Self` in an impl of a trait - we have a concrete `self` type and a\n                 // trait reference.\n                 let trait_ref = match tcx.impl_trait_ref(impl_def_id) {\n                     Some(trait_ref) => trait_ref,\n@@ -1361,7 +1367,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let span = path.span;\n         match path.def {\n             Def::Existential(did) => {\n-                // check for desugared impl trait\n+                // Check for desugared impl trait.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();\n                 self.prohibit_generics(item_segment.1);\n@@ -1398,15 +1404,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 tcx.mk_ty_param(index, tcx.hir.name(node_id).as_interned_str())\n             }\n             Def::SelfTy(_, Some(def_id)) => {\n-                // Self in impl (we know the concrete type).\n+                // `Self` in impl (we know the concrete type)\n \n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n \n                 tcx.at(span).type_of(def_id)\n             }\n             Def::SelfTy(Some(_), None) => {\n-                // Self in trait.\n+                // `Self` in trait\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n                 tcx.mk_self_type()"}, {"sha": "8574443190d7c7a2d6a70f8737e3b1b7565de272", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -28,9 +28,9 @@ use errors::{DiagnosticBuilder, DiagnosticId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n \n-/// Helper type of a temporary returned by .for_item(...).\n+/// Helper type of a temporary returned by `.for_item(...)`.\n /// Necessary because we can't write the following bound:\n-/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>).\n+/// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>)`.\n struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n     id: ast::NodeId,\n@@ -186,6 +186,8 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    item_id: ast::NodeId,\n                                    span: Span,\n                                    sig_if_method: Option<&hir::MethodSig>) {\n+    debug!(\"check_associated_item: {:?}\", item_id);\n+\n     let code = ObligationCauseCode::MiscObligation;\n     for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n         let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n@@ -311,6 +313,8 @@ fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n+    debug!(\"check_trait: {:?}\", item.id);\n+\n     let trait_def_id = tcx.hir.local_def_id(item.id);\n \n     let trait_def = tcx.trait_def(trait_def_id);\n@@ -1012,7 +1016,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             None => {\n-                // Inherent impl: take implied bounds from the self type.\n+                // Inherent impl: take implied bounds from the `self` type.\n                 let self_ty = self.tcx.type_of(impl_def_id);\n                 let self_ty = self.normalize_associated_types_in(span, &self_ty);\n                 vec![self_ty]"}, {"sha": "d5f5cbb562e78514581bea80c91fc6e1237add51", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -1978,18 +1978,18 @@ pub enum SizedByDefault {\n     No,\n }\n \n-/// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n-/// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n-/// built-in trait (formerly known as kind): Send.\n+/// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped `Ty`\n+/// or a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n+/// built-in trait `Send`.\n pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n     astconv: &dyn AstConv<'gcx, 'tcx>,\n     param_ty: Ty<'tcx>,\n     ast_bounds: &[hir::GenericBound],\n     sized_by_default: SizedByDefault,\n     span: Span,\n ) -> Bounds<'tcx> {\n-    let mut region_bounds = vec![];\n-    let mut trait_bounds = vec![];\n+    let mut region_bounds = Vec::new();\n+    let mut trait_bounds = Vec::new();\n \n     for ast_bound in ast_bounds {\n         match *ast_bound {\n@@ -1999,7 +1999,7 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(\n         }\n     }\n \n-    let mut projection_bounds = vec![];\n+    let mut projection_bounds = Vec::new();\n \n     let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n         (astconv.instantiate_poly_trait_ref(bound, param_ty, &mut projection_bounds), bound.span)"}, {"sha": "a985c3e9fdf449bfc8b57664c867ef065d1025f6", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -4909,4 +4909,5 @@ register_diagnostics! {\n     E0641, // cannot cast to/from a pointer with an unknown kind\n     E0645, // trait aliases not finished\n     E0698, // type inside generator must be known in this context\n+    E0719, // duplicate values for associated type binding\n }"}, {"sha": "e69c0af2be768dfa4c51c41117eb44894ef04f66", "filename": "src/test/run-pass/associated-types/associated-types-from-supertrait.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-from-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-from-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-from-supertrait.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo: Iterator<Item = i32> {}\n+trait Bar: Foo {}\n+\n+fn main() {\n+    let _: &dyn Bar;\n+}"}, {"sha": "cce8bb84837f3b2fde9928063a557647e3a82013", "filename": "src/test/run-pass/issues/issue-24010.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24010.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24010.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24010.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo: Fn(i32) -> i32 + Send {}\n+\n+impl<T: ?Sized + Fn(i32) -> i32 + Send> Foo for T {}\n+\n+fn wants_foo(f: Box<Foo>) -> i32 {\n+    f(42)\n+}\n+\n+fn main() {\n+    let f = Box::new(|x| x);\n+    assert_eq!(wants_foo(f), 42);\n+}"}, {"sha": "adac28eeb1292d40797fc1f322aba3b1fdb7e030", "filename": "src/test/run-pass/traits/trait-alias-object.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -21,7 +21,6 @@ pub fn main() {\n     let b = Box::new(456) as Box<dyn Foo>;\n     assert!(*b == 456);\n \n-    // FIXME(alexreg): associated type should be gotten from trait alias definition\n-    // let c: &dyn I32Iterator = &vec![123].into_iter();\n-    // assert_eq!(c.next(), Some(123));\n+    let c: &mut dyn I32Iterator = &mut vec![123].into_iter();\n+    assert_eq!(c.next(), Some(123));\n }", "previous_filename": "src/test/run-pass/traits/trait-alias-object-type.rs"}, {"sha": "8d91561b7d64feb218d1a0ff9d71c2834a3573ec", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+trait I32Iterator = Iterator<Item = i32>;\n+\n+fn main() {\n+    let _: &I32Iterator<Item = u32> = &vec![42].into_iter();\n+}"}, {"sha": "536cd945083a60cb8b6f77919a45ea6da7175b0c", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -0,0 +1,13 @@\n+error[E0271]: type mismatch resolving `<std::vec::IntoIter<u32> as std::iter::Iterator>::Item == i32`\n+  --> $DIR/associated-types-overridden-binding-2.rs:16:39\n+   |\n+LL |     let _: &I32Iterator<Item = u32> = &vec![42].into_iter();\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^ expected u32, found i32\n+   |\n+   = note: expected type `u32`\n+              found type `i32`\n+   = note: required for the cast to the object type `dyn I32Iterator<Item=u32, Item=i32>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "ed2211ecffd2bff8fba1f529674d4eda3138e3ce", "filename": "src/test/ui/associated-types/associated-types-overridden-binding.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+trait Foo: Iterator<Item = i32> {}\n+trait Bar: Foo<Item = u32> {}\n+\n+trait I32Iterator = Iterator<Item = i32>;\n+trait U32Iterator = I32Iterator<Item = u32>;\n+\n+fn main() {\n+    let _: &I32Iterator<Item = u32>;\n+}"}, {"sha": "216aa097db9fb7c44f0af2ea27b691c859415ec6", "filename": "src/test/ui/associated-types/associated-types-overridden-binding.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding.stderr?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -0,0 +1,15 @@\n+error[E0284]: type annotations required: cannot resolve `<Self as std::iter::Iterator>::Item == i32`\n+  --> $DIR/associated-types-overridden-binding.rs:14:1\n+   |\n+LL | trait Bar: Foo<Item = u32> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: required by `Foo`\n+  --> $DIR/associated-types-overridden-binding.rs:13:1\n+   |\n+LL | trait Foo: Iterator<Item = i32> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "c35c7e10f5a38500ab26cff4ab0cc8854964f397", "filename": "src/test/ui/error-codes/E0191.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Ferror-codes%2FE0191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Ferror-codes%2FE0191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0191.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -14,5 +14,4 @@ trait Trait {\n \n type Foo = Trait; //~ ERROR E0191\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "c7bfa85093f2da7147a162af5bdbe627a9c5c32f", "filename": "src/test/ui/error-codes/E0719.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Ferror-codes%2FE0719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Ferror-codes%2FE0719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -8,16 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-pass\n-\n-use std::iter::Iterator;\n+trait Foo: Iterator<Item = i32, Item = i32> {}\n \n type Unit = ();\n \n-fn test() ->  Box<Iterator<Item = (), Item = Unit>> {\n+fn test() -> Box<Iterator<Item = (), Item = Unit>> {\n     Box::new(None.into_iter())\n }\n \n fn main() {\n+    let _: &Iterator<Item = i32, Item = i32>;\n     test();\n }", "previous_filename": "src/test/ui/lint/issue-50589-multiple-associated-types.rs"}, {"sha": "3a908fceced6028cd4612ee7b1753115350cb04d", "filename": "src/test/ui/error-codes/E0719.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -0,0 +1,19 @@\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/E0719.rs:11:33\n+   |\n+LL | trait Foo: Iterator<Item = i32, Item = i32> {}\n+   |                     ----------  ^^^^^^^^^^ re-bound here\n+   |                     |\n+   |                     `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/E0719.rs:15:38\n+   |\n+LL | fn test() -> Box<Iterator<Item = (), Item = Unit>> {\n+   |                           ---------  ^^^^^^^^^^^ re-bound here\n+   |                           |\n+   |                           `Item` bound here first\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0719`."}, {"sha": "7b79807e4d7ff5df6ffa42a3e4a12a3ec698367d", "filename": "src/test/ui/issue-51947.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6e9b84296223126a0a59bde63a0f97011bb7b0f5/src%2Ftest%2Fui%2Fissue-51947.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9b84296223126a0a59bde63a0f97011bb7b0f5/src%2Ftest%2Fui%2Fissue-51947.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-51947.rs?ref=6e9b84296223126a0a59bde63a0f97011bb7b0f5", "patch": "@@ -1,17 +0,0 @@\n-// compile-pass\n-\n-#![crate_type = \"lib\"]\n-#![feature(linkage)]\n-\n-// MergeFunctions will merge these via an anonymous internal\n-// backing function, which must be named if ThinLTO buffers are used\n-\n-#[linkage = \"weak\"]\n-pub fn fn1(a: u32, b: u32, c: u32) -> u32 {\n-    a + b + c\n-}\n-\n-#[linkage = \"weak\"]\n-pub fn fn2(a: u32, b: u32, c: u32) -> u32 {\n-    a + b + c\n-}"}, {"sha": "3e0c3c002f64962cb97c905a8f8e1faa239c30d7", "filename": "src/test/ui/issues/issue-51947.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Fissues%2Fissue-51947.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Fissues%2Fissue-51947.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51947.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![crate_type = \"lib\"]\n+#![feature(linkage)]\n+\n+// MergeFunctions will merge these via an anonymous internal\n+// backing function, which must be named if ThinLTO buffers are used\n+\n+#[linkage = \"weak\"]\n+pub fn fn1(a: u32, b: u32, c: u32) -> u32 {\n+    a + b + c\n+}\n+\n+#[linkage = \"weak\"]\n+pub fn fn2(a: u32, b: u32, c: u32) -> u32 {\n+    a + b + c\n+}"}, {"sha": "7f0a1ee1f3307b2a4f3f226d88f715a50af84def", "filename": "src/test/ui/lint/issue-50589-multiple-associated-types.stderr", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6e9b84296223126a0a59bde63a0f97011bb7b0f5/src%2Ftest%2Fui%2Flint%2Fissue-50589-multiple-associated-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e9b84296223126a0a59bde63a0f97011bb7b0f5/src%2Ftest%2Fui%2Flint%2Fissue-50589-multiple-associated-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-50589-multiple-associated-types.stderr?ref=6e9b84296223126a0a59bde63a0f97011bb7b0f5", "patch": "@@ -1,23 +0,0 @@\n-warning: associated type binding `Item` specified more than once\n-  --> $DIR/issue-50589-multiple-associated-types.rs:17:39\n-   |\n-LL | fn test() ->  Box<Iterator<Item = (), Item = Unit>> {\n-   |                            ---------  ^^^^^^^^^^^ used more than once\n-   |                            |\n-   |                            first use of `Item`\n-   |\n-   = note: #[warn(duplicate_associated_type_bindings)] on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #50589 <https://github.com/rust-lang/rust/issues/50589>\n-\n-warning: associated type binding `Item` specified more than once\n-  --> $DIR/issue-50589-multiple-associated-types.rs:17:39\n-   |\n-LL | fn test() ->  Box<Iterator<Item = (), Item = Unit>> {\n-   |                            ---------  ^^^^^^^^^^^ used more than once\n-   |                            |\n-   |                            first use of `Item`\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #50589 <https://github.com/rust-lang/rust/issues/50589>\n-"}, {"sha": "3adcd8436d8a1c2c9075aaf5b7bbfe67552660da", "filename": "src/test/ui/traits/trait-alias-object.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.rs?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "previous_filename": "src/test/ui/traits/trait-alias-objects.rs"}, {"sha": "6b7b322a53d9e86ec530d55da1ef9a887bbd02ff", "filename": "src/test/ui/traits/trait-alias-object.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e912b2c17aeb865dad2bb01eb8d50aa4a893f97/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr?ref=0e912b2c17aeb865dad2bb01eb8d50aa4a893f97", "patch": "@@ -1,13 +1,13 @@\n error[E0038]: the trait `EqAlias` cannot be made into an object\n-  --> $DIR/trait-alias-objects.rs:17:13\n+  --> $DIR/trait-alias-object.rs:17:13\n    |\n LL |     let _: &dyn EqAlias = &123;\n    |             ^^^^^^^^^^^ the trait `EqAlias` cannot be made into an object\n    |\n    = note: the trait cannot use `Self` as a type parameter in the supertraits or where-clauses\n \n error[E0191]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified\n-  --> $DIR/trait-alias-objects.rs:18:13\n+  --> $DIR/trait-alias-object.rs:18:13\n    |\n LL |     let _: &dyn IteratorAlias = &vec![123].into_iter();\n    |             ^^^^^^^^^^^^^^^^^ missing associated type `Item` value", "previous_filename": "src/test/ui/traits/trait-alias-objects.stderr"}]}