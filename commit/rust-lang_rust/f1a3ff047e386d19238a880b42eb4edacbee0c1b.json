{"sha": "f1a3ff047e386d19238a880b42eb4edacbee0c1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYTNmZjA0N2UzODZkMTkyMzhhODgwYjQyZWI0ZWRhY2JlZTBjMWI=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2014-12-20T05:53:37Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2014-12-22T23:29:52Z"}, "message": "Use type-alignment-sized integer for discriminant types\n\nThe previous behaviour of using the smallest type possible caused LLVM\nto treat padding too conservatively, causing poor codegen. This commit\nchanges the behaviour to use an type-alignment-sized integer as the\ndiscriminant. This keeps types the same size, but helps LLVM understand\nthe data structure a little better, resulting in better codegen.", "tree": {"sha": "f6a85e57fa6e9174314eb195a53d5cb135b84b0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6a85e57fa6e9174314eb195a53d5cb135b84b0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1a3ff047e386d19238a880b42eb4edacbee0c1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1a3ff047e386d19238a880b42eb4edacbee0c1b", "html_url": "https://github.com/rust-lang/rust/commit/f1a3ff047e386d19238a880b42eb4edacbee0c1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1a3ff047e386d19238a880b42eb4edacbee0c1b/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f3cff6956d56048ef7afb6d33e17cbdb2dcf038", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038", "html_url": "https://github.com/rust-lang/rust/commit/2f3cff6956d56048ef7afb6d33e17cbdb2dcf038"}], "stats": {"total": 83, "additions": 77, "deletions": 6}, "files": [{"sha": "73aa7d2090950499c2700d5c6c2d5e35d1b61cc1", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f1a3ff047e386d19238a880b42eb4edacbee0c1b/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a3ff047e386d19238a880b42eb4edacbee0c1b/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=f1a3ff047e386d19238a880b42eb4edacbee0c1b", "patch": "@@ -256,7 +256,62 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             assert!((cases.len() - 1) as i64 >= 0);\n             let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n                                      slo: 0, shi: (cases.len() - 1) as i64 };\n-            let ity = range_to_inttype(cx, hint, &bounds);\n+            let min_ity = range_to_inttype(cx, hint, &bounds);\n+\n+            // Create the set of structs that represent each variant\n+            // Use the minimum integer type we figured out above\n+            let fields : Vec<_> = cases.iter().map(|c| {\n+                let mut ftys = vec!(ty_of_inttype(min_ity));\n+                ftys.push_all(c.tys.as_slice());\n+                if dtor { ftys.push(ty::mk_bool()); }\n+                mk_struct(cx, ftys.as_slice(), false, t)\n+            }).collect();\n+\n+\n+            // Check to see if we should use a different type for the\n+            // discriminant. If the overall alignment of the type is\n+            // the same as the first field in each variant, we can safely use\n+            // an alignment-sized type.\n+            // We increase the size of the discriminant to avoid LLVM copying\n+            // padding when it doesn't need to. This normally causes unaligned\n+            // load/stores and excessive memcpy/memset operations. By using a\n+            // bigger integer size, LLVM can be sure about it's contents and\n+            // won't be so conservative.\n+            // This check is needed to avoid increasing the size of types when\n+            // the alignment of the first field is smaller than the overall\n+            // alignment of the type.\n+            let (_, align) = union_size_and_align(fields.as_slice());\n+            let mut use_align = true;\n+            for st in fields.iter() {\n+                // Get the first non-zero-sized field\n+                let field = st.fields.iter().skip(1).filter(|ty| {\n+                    let t = type_of::sizing_type_of(cx, **ty);\n+                    machine::llsize_of_real(cx, t) != 0 ||\n+                    // This case is only relevant for zero-sized types with large alignment\n+                    machine::llalign_of_min(cx, t) != 1\n+                }).next();\n+\n+                if let Some(field) = field {\n+                    let field_align = type_of::align_of(cx, *field);\n+                    if field_align != align {\n+                        use_align = false;\n+                        break;\n+                    }\n+                }\n+            }\n+            let ity = if use_align {\n+                // Use the overall alignment\n+                match align {\n+                    1 => attr::UnsignedInt(ast::TyU8),\n+                    2 => attr::UnsignedInt(ast::TyU16),\n+                    4 => attr::UnsignedInt(ast::TyU32),\n+                    8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n+                        attr::UnsignedInt(ast::TyU64),\n+                    _ => min_ity // use min_ity as a fallback\n+                }\n+            } else {\n+                min_ity\n+            };\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(ity));\n@@ -570,7 +625,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let discr_ty = ll_inttype(cx, ity);\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty);\n             let align_units = (size + align_s - 1) / align_s - 1;\n-            let pad_ty = match align_s {\n+            let fill_ty = match align_s {\n                 1 => Type::array(&Type::i8(cx), align_units),\n                 2 => Type::array(&Type::i16(cx), align_units),\n                 4 => Type::array(&Type::i32(cx), align_units),\n@@ -580,11 +635,11 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                               align_units),\n                 _ => panic!(\"unsupported enum alignment: {}\", align)\n             };\n-            assert_eq!(machine::llalign_of_min(cx, pad_ty), align);\n+            assert_eq!(machine::llalign_of_min(cx, fill_ty), align);\n             assert_eq!(align_s % discr_size, 0);\n-            let fields = vec!(discr_ty,\n-                           Type::array(&discr_ty, align_s / discr_size - 1),\n-                           pad_ty);\n+            let fields = [discr_ty,\n+                          Type::array(&discr_ty, align_s / discr_size - 1),\n+                          fill_ty];\n             match name {\n                 None => Type::struct_(cx, fields.as_slice(), false),\n                 Some(name) => {"}, {"sha": "30cae08381af55aeb887a1cb325033bc885277f6", "filename": "src/test/run-pass/type-sizes.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1a3ff047e386d19238a880b42eb4edacbee0c1b/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a3ff047e386d19238a880b42eb4edacbee0c1b/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=f1a3ff047e386d19238a880b42eb4edacbee0c1b", "patch": "@@ -18,6 +18,16 @@ struct w {a: int, b: ()}\n struct x {a: int, b: (), c: ()}\n struct y {x: int}\n \n+enum e1 {\n+    a(u8, u32), b(u32), c\n+}\n+enum e2 {\n+    a(u32), b\n+}\n+enum e3 {\n+    a([u64, ..0], u32), b\n+}\n+\n pub fn main() {\n     assert_eq!(size_of::<u8>(), 1 as uint);\n     assert_eq!(size_of::<u32>(), 4 as uint);\n@@ -34,4 +44,10 @@ pub fn main() {\n     assert_eq!(size_of::<w>(), size_of::<int>());\n     assert_eq!(size_of::<x>(), size_of::<int>());\n     assert_eq!(size_of::<int>(), size_of::<y>());\n+\n+    // Make sure enum types are the appropriate size, mostly\n+    // around ensuring alignment is handled properly\n+    assert_eq!(size_of::<e1>(), 8 as uint);\n+    assert_eq!(size_of::<e2>(), 8 as uint);\n+    assert_eq!(size_of::<e3>(), 16 as uint);\n }"}]}