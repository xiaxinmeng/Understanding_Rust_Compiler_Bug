{"sha": "d3ed9a9e3bbcbdb6b098f8b7c8edc283f317cd30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZWQ5YTllM2JiY2JkYjZiMDk4ZjhiN2M4ZWRjMjgzZjMxN2NkMzA=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-17T06:10:03Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-17T06:19:24Z"}, "message": "std: lots of docs for std::rt::io::file\n\ni hope they don't bitrot", "tree": {"sha": "c6f88767023e84d59068b4b225a16248c6927a36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6f88767023e84d59068b4b225a16248c6927a36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3ed9a9e3bbcbdb6b098f8b7c8edc283f317cd30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3ed9a9e3bbcbdb6b098f8b7c8edc283f317cd30", "html_url": "https://github.com/rust-lang/rust/commit/d3ed9a9e3bbcbdb6b098f8b7c8edc283f317cd30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3ed9a9e3bbcbdb6b098f8b7c8edc283f317cd30/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60ba17098b92f4631e032040e547405ad046172d", "url": "https://api.github.com/repos/rust-lang/rust/commits/60ba17098b92f4631e032040e547405ad046172d", "html_url": "https://github.com/rust-lang/rust/commit/60ba17098b92f4631e032040e547405ad046172d"}], "stats": {"total": 350, "additions": 298, "deletions": 52}, "files": [{"sha": "8227f3a1cb560abf583498fbf43a5f6ff5456446", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 298, "deletions": 52, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/d3ed9a9e3bbcbdb6b098f8b7c8edc283f317cd30/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ed9a9e3bbcbdb6b098f8b7c8edc283f317cd30/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=d3ed9a9e3bbcbdb6b098f8b7c8edc283f317cd30", "patch": "@@ -23,7 +23,73 @@ use option::{Some, None};\n use path::Path;\n use super::super::test::*;\n \n-/// Open a file for reading/writing, as indicated by `path`.\n+/*! Synchronous File I/O\n+\n+This module provides a set of functions and traits for working\n+with regular files & directories on a filesystem.\n+\n+At the top-level of the module are a set of freestanding functions,\n+associated with various filesystem operations. They all operate\n+on a `PathLike` object.\n+\n+All operations in this module, including those as part of `FileStream` et al\n+block the task during execution. Most will raise `std::rt::io::{io_error,read_error}`\n+conditions in the event of failure.\n+\n+Also included in this module are the `FileInfo` and `DirectoryInfo` traits. When\n+`use`'d alongside a value whose type implements them (A `std::path::Path` impl is\n+a part of this module), they expose a set of functions for operations against\n+a given file location, depending on whether the path already exists. Whenever\n+possible, the `{FileInfo, DirectoryInfo}` preserve the same semantics as their\n+free function counterparts.\n+*/\n+\n+/*! Open a file for reading/writing, as indicated by `path`.\n+\n+# Example\n+\n+    use std;\n+    use std::path::Path;\n+    use std::rt::io::support::PathLike;\n+    use std::rt::io::file::open;\n+    use std::rt::io::{FileMode, FileAccess};\n+\n+    let p = &Path(\"/some/file/path.txt\");\n+    \n+    do io_error::cond.trap(|_| {\n+        // hoo-boy...\n+    }).inside {\n+        let stream = match open(p, Create, ReadWrite) {\n+            Some(s) => s,\n+            None => fail!(\"whoops! I'm sure this raised, anyways..\");\n+        }\n+        // do some stuff with that stream\n+\n+        // the file stream will be closed at the end of this block\n+    }\n+    // ..\n+\n+`FileMode` and `FileAccess` provide information about the permissions\n+context in which a given stream is created. More information about them\n+can be found in `std::rt::io`'s docs.\n+\n+Note that, with this function, a `FileStream` is returned regardless of\n+the access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n+`FileStream` opened as `ReadOnly` will raise an `io_error` condition at runtime). If you\n+desire a more-correctly-constrained interface to files, use the\n+`{open_stream, open_reader, open_writer}` methods that are a part of `FileInfo`\n+\n+# Errors\n+\n+This function will raise an `io_error` condition under a number of different circumstances,\n+to include but not limited to:\n+\n+* Opening a file that already exists with `FileMode` of `Create` or vice versa (e.g.\n+  opening a non-existant file with `FileMode` or `Open`)\n+* Attempting to open a file with a `FileAccess` that the user lacks permissions\n+  for\n+* Filesystem-level errors (full disk, etc)\n+*/\n pub fn open<P: PathLike>(path: &P,\n                          mode: FileMode,\n                          access: FileAccess\n@@ -44,8 +110,29 @@ pub fn open<P: PathLike>(path: &P,\n     }\n }\n \n-/// Unlink (remove) a file from the filesystem, as indicated\n-/// by `path`.\n+/*! Unlink a file from the underlying filesystem.\n+\n+# Example\n+\n+    use std;\n+    use std::path::Path;\n+    use std::rt::io::support::PathLike;\n+    use std::rt::io::file::unlink;\n+\n+    let p = &Path(\"/some/file/path.txt\");\n+    unlink(p);\n+    // if we made it here without failing, then the\n+    // unlink operation was successful\n+\n+Note that, just because an unlink call was successful, it is not\n+guaranteed that a file is immediately deleted (e.g. depending on\n+platform, other open file descriptors may prevent immediate removal)\n+\n+# Errors\n+\n+This function will raise an `io_error` condition if the user lacks permissions to\n+remove the file or if some other filesystem-level error occurs\n+*/\n pub fn unlink<P: PathLike>(path: &P) {\n     let unlink_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n@@ -59,8 +146,24 @@ pub fn unlink<P: PathLike>(path: &P) {\n     }\n }\n \n-/// Create a new directory with default permissions (process user\n-/// has read/write privs)\n+/*! Create a new, empty directory at the provided path\n+\n+# Example\n+\n+    use std;\n+    use std::path::Path;\n+    use std::rt::io::support::PathLike;\n+    use std::rt::io::file::mkdir;\n+\n+    let p = &Path(\"/some/dir\");\n+    mkdir(p);\n+    // If we got here, our directory exists! Horray!\n+\n+# Errors\n+\n+This call will raise an `io_error` condition if the user lacks permissions to make a\n+new directory at the provided path, or if the directory already exists\n+*/\n pub fn mkdir<P: PathLike>(path: &P) {\n     let mkdir_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n@@ -73,7 +176,25 @@ pub fn mkdir<P: PathLike>(path: &P) {\n         }\n     }\n }\n-/// Removes a directory\n+\n+/*! Remove an existing, empty directory\n+\n+# Example\n+\n+    use std;\n+    use std::path::Path;\n+    use std::rt::io::support::PathLike;\n+    use std::rt::io::file::rmdir;\n+\n+    let p = &Path(\"/some/dir\");\n+    rmdir(p);\n+    // good riddance, you mean ol' directory\n+\n+# Errors\n+\n+This call will raise an `io_error` condition if the user lacks permissions to remove the\n+directory at the provided path, or if the directory isn't empty\n+*/\n pub fn rmdir<P: PathLike>(path: &P) {\n     let rmdir_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n@@ -87,11 +208,43 @@ pub fn rmdir<P: PathLike>(path: &P) {\n     }\n }\n \n-/// Given a `rt::io::support::PathLike`, query the file system to get\n-/// information about a file, directory, etc.\n-///\n-/// Returns a `Some(PathInfo)` on success, and raises a `rt::io::IoError` condition\n-/// on failure and returns `None`.\n+/*! Get information on the file, directory, etc at the provided path\n+\n+Given a `rt::io::support::PathLike`, query the file system to get\n+information about a file, directory, etc.\n+\n+Returns a `Some(std::rt::io::PathInfo)` on success\n+\n+# Example\n+\n+    use std;\n+    use std::path::Path;\n+    use std::rt::io::support::PathLike;\n+    use std::rt::io::file::stat;\n+\n+    let p = &Path(\"/some/file/path.txt\");\n+\n+    do io_error::cond.trap(|_| {\n+        // hoo-boy...\n+    }).inside {\n+        let info = match stat(p) {\n+            Some(s) => s,\n+            None => fail!(\"whoops! I'm sure this raised, anyways..\");\n+        }\n+        if stat.is_file {\n+            // just imagine the possibilities ...\n+        }\n+\n+        // the file stream will be closed at the end of this block\n+    }\n+    // ..\n+\n+# Errors\n+\n+This call will raise an `io_error` condition if the user lacks the requisite\n+permissions to perform a `stat` call on the given path or if there is no\n+entry in the filesystem at the provided path.\n+*/\n pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n     let open_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n@@ -108,6 +261,8 @@ pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n     }\n }\n \n+/*! Retrieve a vector containing all entries within a provided directory\n+*/\n pub fn readdir<P: PathLike>(path: &P) -> Option<~[Path]> {\n     let readdir_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n@@ -124,9 +279,13 @@ pub fn readdir<P: PathLike>(path: &P) -> Option<~[Path]> {\n     }\n }\n \n-/// Read-only view of file\n+/*! Constrained version of `FileStream` that only exposes read-specific operations.\n+\n+Can be retreived via `FileInfo.open_reader()`.\n+*/\n pub struct FileReader { priv stream: FileStream }\n \n+/// a `std::rt::io::Reader` trait impl for file I/O.\n impl Reader for FileReader {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         self.stream.read(buf)\n@@ -137,6 +296,7 @@ impl Reader for FileReader {\n     }\n }\n \n+/// a `std::rt::io::Seek` trait impl for file I/O.\n impl Seek for FileReader {\n     fn tell(&self) -> u64 {\n         self.stream.tell()\n@@ -147,9 +307,13 @@ impl Seek for FileReader {\n     }\n }\n \n-/// Write-only view of a file\n+/*! Constrained version of `FileStream` that only exposes write-specific operations.\n+\n+Can be retreived via `FileInfo.open_writer()`.\n+*/\n pub struct FileWriter { priv stream: FileStream }\n \n+/// a `std::rt::io::Writer` trait impl for file I/O.\n impl Writer for FileWriter {\n     fn write(&mut self, buf: &[u8]) {\n         self.stream.write(buf);\n@@ -160,6 +324,7 @@ impl Writer for FileWriter {\n     }\n }\n \n+/// a `std::rt::io::Seek` trait impl for file I/O.\n impl Seek for FileWriter {\n     fn tell(&self) -> u64 {\n         self.stream.tell()\n@@ -170,13 +335,25 @@ impl Seek for FileWriter {\n     }\n }\n \n-/// Internal representation of a FileStream, used to consolidate functionality\n-/// exposed in the public API\n+/*! Unconstrained file access type that exposes read and write operations\n+\n+Can be retreived via `file::open()` and `FileInfo.open_stream()`.\n+\n+# Errors\n+\n+This type will raise an io_error condition if operations are attempted against\n+it for which its underlying file descriptor was not configured at creation\n+time, via the `FileAccess` parameter to `file::open()`.\n+\n+For this reason, it is best to use the access-constrained wrappers that are\n+exposed via `FileInfo.open_reader()` and `FileInfo.open_writer()`.\n+*/\n pub struct FileStream {\n     fd: ~RtioFileStream,\n     last_nread: int,\n }\n \n+/// a `std::rt::io::Reader` trait impl for file I/O.\n impl Reader for FileStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         match self.fd.read(buf) {\n@@ -202,6 +379,7 @@ impl Reader for FileStream {\n     }\n }\n \n+/// a `std::rt::io::Writer` trait impl for file I/O.\n impl Writer for FileStream {\n     fn write(&mut self, buf: &[u8]) {\n         match self.fd.write(buf) {\n@@ -222,6 +400,7 @@ impl Writer for FileStream {\n     }\n }\n \n+/// a `std::rt::io:Seek` trait impl for file I/O.\n impl Seek for FileStream {\n     fn tell(&self) -> u64 {\n         let res = self.fd.tell();\n@@ -256,14 +435,21 @@ pub trait FileSystemInfo {\n     /// later creates\n     fn get_path<'a>(&'a self) -> &'a Path;\n \n-    /// Ask the operating system for information about the path,\n-    /// will raise a condition if an error occurs during the process\n+    /*! Get information on the file, directory, etc at the provided path\n+\n+    Consult the `file::stat` documentation for more info.\n+\n+    This call preserves identical runtime/error semantics\n+    */\n     fn stat(&self) -> Option<FileStat> {\n         stat(self.get_path())\n     }\n \n-    /// returns `true` if the location pointed at by the enclosing\n-    /// exists on the filesystem\n+    /// Boolean value indicator whether the underlying file exists on the filesystem\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will not raise a condition\n     fn exists(&self) -> bool {\n         match ignore_io_error(|| self.stat()) {\n             Some(_) => true,\n@@ -273,21 +459,32 @@ pub trait FileSystemInfo {\n \n }\n \n-/// Represents passive information about a file (primarily exposed\n-/// via the `stat()` method. Also provides methods for opening\n-/// a file in various modes/permissions.\n-///\n-/// # Example\n-///\n-/// * Check if a file exists, reading from it if so\n-///\n-///     let f = &Path(\"/some/file/path.txt\");\n-///     if f.exists() {\n-///         let reader = f.open_reader(Open);\n-///         let mut mem = [0u8, 8*64000];\n-///         reader.read(mem);\n-///         // ...\n-///     }\n+/*! Represents a file, whose underlying path may or may not be valid\n+\n+# Example\n+\n+* Check if a file exists, reading from it if so\n+\n+    use std;\n+    use std::path::Path;\n+    use std::rt::io::file::{FileInfo, FileReader};\n+\n+    let f = &Path(\"/some/file/path.txt\");\n+    if f.exists() {\n+        let reader = f.open_reader(Open);\n+        let mut mem = [0u8, 8*64000];\n+        reader.read(mem);\n+        // ...\n+    }\n+\n+* Is the given path a file?\n+\n+   let f = get_file_path_from_wherever();\n+   match f.is_file() {\n+       true => doing_something_with_a_file(f),\n+       _ => {}\n+   }\n+*/\n pub trait FileInfo : FileSystemInfo {\n     /// Whether the underlying implemention (be it a file path,\n     /// or something else) points at a \"regular file\" on the FS. Will return\n@@ -302,6 +499,8 @@ pub trait FileInfo : FileSystemInfo {\n \n     /// Attempts to open a regular file for reading/writing based\n     /// on provided inputs\n+    ///\n+    /// See `file::open` for more information on runtime semantics and error conditions\n     fn open_stream(&self, mode: FileMode, access: FileAccess) -> Option<FileStream> {\n         match ignore_io_error(|| self.stat()) {\n             Some(s) => match s.is_file {\n@@ -311,26 +510,32 @@ pub trait FileInfo : FileSystemInfo {\n             None => open(self.get_path(), mode, access)\n         }\n     }\n-    /// Attempts to open a regular file for reading-only based\n+\n+    /// Attempts to open a regular file in read-only mode, based\n     /// on provided inputs\n+    ///\n+    /// See `file::open` for more information on runtime semantics and error conditions\n     fn open_reader(&self, mode: FileMode) -> Option<FileReader> {\n         match self.open_stream(mode, Read) {\n             Some(s) => Some(FileReader { stream: s}),\n             None => None\n         }\n     }\n \n-    /// Attempts to open a regular file for writing-only based\n+    /// Attempts to open a regular file in write-only mode, based\n     /// on provided inputs\n+    ///\n+    /// See `file::open` for more information on runtime semantics and error conditions\n     fn open_writer(&self, mode: FileMode) -> Option<FileWriter> {\n         match self.open_stream(mode, Write) {\n             Some(s) => Some(FileWriter { stream: s}),\n             None => None\n         }\n     }\n \n-    /// Attempt to remove a file from the filesystem, pending the closing\n-    /// of any open file descriptors pointing to the file\n+    /// Attempt to remove a file from the filesystem\n+    ///\n+    /// See `file::unlink` for more information on runtime semantics and error conditions\n     fn unlink(&self) {\n         unlink(self.get_path());\n     }\n@@ -340,28 +545,59 @@ pub trait FileInfo : FileSystemInfo {\n impl FileSystemInfo for Path {\n     fn get_path<'a>(&'a self) -> &'a Path { self }\n }\n+\n /// `FileInfo` implementation for `Path`s\n impl FileInfo for Path { }\n \n-/// Passive information about a directory on the filesystem. Includes\n-/// Convenience methods to iterate over a directory's contents (via `readdir`, as\n-/// as `mkdir` and `rmdir` operations.\n+/*! Represents a directory, whose underlying path may or may not be valid\n+\n+# Example\n+\n+* Check if a directory exists, `mkdir`'ing it if not\n+\n+    use std;\n+    use std::path::Path;\n+    use std::rt::io::file::{DirectoryInfo};\n+\n+    let dir = &Path(\"/some/dir\");\n+    if !dir.exists() {\n+        dir.mkdir();\n+    }\n+\n+* Is the given path a directory? If so, iterate on its contents\n+\n+    fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n+        if dir.is_dir() {\n+            let contents = dir.readdir();\n+            for entry in contents.iter() {\n+                if entry.is_dir() { visit_dirs(entry, cb); }\n+                else { cb(entry); }\n+            }\n+        }\n+        else { fail!(\"nope\"); }\n+    }\n+*/\n trait DirectoryInfo : FileSystemInfo {\n     /// Whether the underlying implemention (be it a file path,\n-    /// or something else) points at a directory file\" on the FS. Will return\n-    /// false for paths to non-existent locations or if the item is\n+    /// or something else) is pointing at a directory in the underlying FS.\n+    /// Will return false for paths to non-existent locations or if the item is\n     /// not a directory (eg files, named pipes, links, etc)\n     fn is_dir(&self) -> bool {\n         match ignore_io_error(|| self.stat()) {\n             Some(s) => s.is_dir,\n             None => false\n         }\n     }\n+\n     /// Create a directory at the location pointed to by the\n-    /// type underlying the given `DirectoryInfo`. Raises a\n-    /// condition if a file, directory, etc already exists\n-    /// at that location or if some other error occurs during\n-    /// the mkdir operation\n+    /// type underlying the given `DirectoryInfo`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This method will raise a `PathAlreadyExists` kind of `io_error` condition\n+    /// if the provided path exists\n+    ///\n+    /// See `file::mkdir` for more information on runtime semantics and error conditions\n     fn mkdir(&self) {\n         match ignore_io_error(|| self.stat()) {\n             Some(_) => {\n@@ -375,9 +611,17 @@ trait DirectoryInfo : FileSystemInfo {\n             None => mkdir(self.get_path())\n         }\n     }\n-    /// Remove a directory at the given location pointed to by\n-    /// the type underlying the given `DirectoryInfo`. Will fail\n-    /// if there is no directory at the given location or if\n+\n+    /// Remove a directory at the given location.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This method will raise a `PathDoesntExist` kind of `io_error` condition\n+    /// if the provided path exists. It will raise a `MismatchedFileTypeForOperation`\n+    /// kind of `io_error` condition if the provided path points at any\n+    /// non-directory file type\n+    ///\n+    /// See `file::rmdir` for more information on runtime semantics and error conditions\n     fn rmdir(&self) {\n         match ignore_io_error(|| self.stat()) {\n             Some(s) => {\n@@ -403,13 +647,15 @@ trait DirectoryInfo : FileSystemInfo {\n                 })\n         }\n     }\n+\n+    // Get a collection of all entries at the given\n+    // directory\n     fn readdir(&self) -> Option<~[Path]> {\n         readdir(self.get_path())\n     }\n-    //fn get_subdirs(&self, filter: &str) -> ~[Path];\n-    //fn get_files(&self, filter: &str) -> ~[Path];\n }\n \n+/// `DirectoryInfo` impl for `path::Path`\n impl DirectoryInfo for Path { }\n \n fn file_test_smoke_test_impl() {"}]}