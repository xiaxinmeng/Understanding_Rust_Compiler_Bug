{"sha": "e7108fb5b198d4fe416ce2408afaa86f1020c37d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MTA4ZmI1YjE5OGQ0ZmU0MTZjZTI0MDhhZmFhODZmMTAyMGMzN2Q=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-29T16:24:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-29T16:24:16Z"}, "message": "Merge #7491\n\n7491: Simplify mbe match error. r=edwin0cheng a=edwin0cheng\n\nHandle parse error in rule parsing instead of matching in mbe.\r\n\r\nbors r+\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "95766e6af68b0bd0d832180ce640ef0da868a76e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95766e6af68b0bd0d832180ce640ef0da868a76e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7108fb5b198d4fe416ce2408afaa86f1020c37d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgFDawCRBK7hj4Ov3rIwAAdHIIAGN2qroygtage/gkmDYl3Rfo\n0L88HDZi5AcpeT0XUENZo7EJeA/ru88S6bWaCLpmsY0xTHec4TRMmmKRxnYPAY00\nxttUlbucKgkovQtfSacrX9dpK5Ro5LO+MVY2ZEqA8Oe8vfatUIeJS9GIpdz0LM2s\nUI7q68B2TnQip6eaa7AS7AY6f+TAin4bhUKuufs/cgx8cUAUeAJu0ASqadh6ISD1\nG+2bQ1yg6JqrCRnYOgeXCIMZc1ZDLgIwkW3yoQ4KajMDE5AXM+FEURWUe1BLbIPX\nyYNqz539KalJc2pDrN4eGSfVt0lArSx8MJbJFV5DU/s9ijVFZCY3exLZ7+BL11o=\n=wAHA\n-----END PGP SIGNATURE-----\n", "payload": "tree 95766e6af68b0bd0d832180ce640ef0da868a76e\nparent d2a73c61641d065fd70e54a37442386deee6f013\nparent 706ac8256d878626126756969b48b262d2e187b5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1611937456 +0000\ncommitter GitHub <noreply@github.com> 1611937456 +0000\n\nMerge #7491\n\n7491: Simplify mbe match error. r=edwin0cheng a=edwin0cheng\n\nHandle parse error in rule parsing instead of matching in mbe.\r\n\r\nbors r+\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7108fb5b198d4fe416ce2408afaa86f1020c37d", "html_url": "https://github.com/rust-lang/rust/commit/e7108fb5b198d4fe416ce2408afaa86f1020c37d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7108fb5b198d4fe416ce2408afaa86f1020c37d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2a73c61641d065fd70e54a37442386deee6f013", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2a73c61641d065fd70e54a37442386deee6f013", "html_url": "https://github.com/rust-lang/rust/commit/d2a73c61641d065fd70e54a37442386deee6f013"}, {"sha": "706ac8256d878626126756969b48b262d2e187b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/706ac8256d878626126756969b48b262d2e187b5", "html_url": "https://github.com/rust-lang/rust/commit/706ac8256d878626126756969b48b262d2e187b5"}], "stats": {"total": 390, "additions": 180, "deletions": 210}, "files": [{"sha": "e7e14b3ccee4d34409dbf9fe339c59c85c3b21e7", "filename": "crates/mbe/src/expander.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7108fb5b198d4fe416ce2408afaa86f1020c37d/crates%2Fmbe%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7108fb5b198d4fe416ce2408afaa86f1020c37d/crates%2Fmbe%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander.rs?ref=e7108fb5b198d4fe416ce2408afaa86f1020c37d", "patch": "@@ -16,13 +16,8 @@ pub(crate) fn expand_rules(\n ) -> ExpandResult<tt::Subtree> {\n     let mut match_: Option<(matcher::Match, &crate::Rule)> = None;\n     for rule in rules {\n-        let new_match = match matcher::match_(&rule.lhs, input) {\n-            Ok(m) => m,\n-            Err(_e) => {\n-                // error in pattern parsing\n-                continue;\n-            }\n-        };\n+        let new_match = matcher::match_(&rule.lhs, input);\n+\n         if new_match.err.is_none() {\n             // If we find a rule that applies without errors, we're done.\n             // Unconditionally returning the transcription here makes the"}, {"sha": "987a4f676d3eb2445f0f3cc7aac2292249bfa7e0", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 137, "deletions": 149, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/e7108fb5b198d4fe416ce2408afaa86f1020c37d/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7108fb5b198d4fe416ce2408afaa86f1020c37d/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=e7108fb5b198d4fe416ce2408afaa86f1020c37d", "patch": "@@ -77,35 +77,26 @@ impl Match {\n     }\n }\n \n-// General note: These functions have two channels to return errors, a `Result`\n-// return value and the `&mut Match`. The returned Result is for pattern parsing\n-// errors; if a branch of the macro definition doesn't parse, it doesn't make\n-// sense to try using it. Matching errors are added to the `Match`. It might\n-// make sense to make pattern parsing a separate step?\n-\n-pub(super) fn match_(pattern: &MetaTemplate, src: &tt::Subtree) -> Result<Match, ExpandError> {\n+/// Matching errors are added to the `Match`.\n+pub(super) fn match_(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n     assert!(pattern.delimiter == None);\n \n     let mut res = Match::default();\n     let mut src = TtIter::new(src);\n \n-    match_subtree(&mut res, pattern, &mut src)?;\n+    match_subtree(&mut res, pattern, &mut src);\n \n     if src.len() > 0 {\n         res.unmatched_tts += src.len();\n         res.add_err(err!(\"leftover tokens\"));\n     }\n \n-    Ok(res)\n+    res\n }\n \n-fn match_subtree(\n-    res: &mut Match,\n-    pattern: &MetaTemplate,\n-    src: &mut TtIter,\n-) -> Result<(), ExpandError> {\n+fn match_subtree(res: &mut Match, pattern: &MetaTemplate, src: &mut TtIter) {\n     for op in pattern.iter() {\n-        match op.as_ref().map_err(|err| err.clone())? {\n+        match op {\n             Op::Leaf(lhs) => {\n                 let rhs = match src.expect_leaf() {\n                     Ok(l) => l,\n@@ -145,7 +136,7 @@ fn match_subtree(\n                     continue;\n                 }\n                 let mut src = TtIter::new(rhs);\n-                match_subtree(res, lhs, &mut src)?;\n+                match_subtree(res, lhs, &mut src);\n                 if src.len() > 0 {\n                     res.add_err(err!(\"leftover tokens\"));\n                 }\n@@ -172,11 +163,139 @@ fn match_subtree(\n                 }\n             }\n             Op::Repeat { subtree, kind, separator } => {\n-                match_repeat(res, subtree, *kind, separator, src)?;\n+                match_repeat(res, subtree, *kind, separator, src);\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn match_repeat(\n+    res: &mut Match,\n+    pattern: &MetaTemplate,\n+    kind: RepeatKind,\n+    separator: &Option<Separator>,\n+    src: &mut TtIter,\n+) {\n+    // Dirty hack to make macro-expansion terminate.\n+    // This should be replaced by a proper macro-by-example implementation\n+    let mut limit = 65536;\n+    let mut counter = 0;\n+\n+    for i in 0.. {\n+        let mut fork = src.clone();\n+\n+        if let Some(separator) = &separator {\n+            if i != 0 && !fork.eat_separator(separator) {\n+                break;\n+            }\n+        }\n+\n+        let mut nested = Match::default();\n+        match_subtree(&mut nested, pattern, &mut fork);\n+        if nested.err.is_none() {\n+            limit -= 1;\n+            if limit == 0 {\n+                log::warn!(\n+                    \"match_lhs exceeded repeat pattern limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\",\n+                    pattern,\n+                    src,\n+                    kind,\n+                    separator\n+                );\n+                break;\n+            }\n+            *src = fork;\n+\n+            if let Err(err) = res.bindings.push_nested(counter, nested.bindings) {\n+                res.add_err(err);\n+            }\n+            counter += 1;\n+            if counter == 1 {\n+                if let RepeatKind::ZeroOrOne = kind {\n+                    break;\n+                }\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    match (kind, counter) {\n+        (RepeatKind::OneOrMore, 0) => {\n+            res.add_err(ExpandError::UnexpectedToken);\n+        }\n+        (_, 0) => {\n+            // Collect all empty variables in subtrees\n+            let mut vars = Vec::new();\n+            collect_vars(&mut vars, pattern);\n+            for var in vars {\n+                res.bindings.push_empty(&var)\n             }\n         }\n+        _ => (),\n+    }\n+}\n+\n+fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragment>> {\n+    let fragment = match kind {\n+        \"path\" => Path,\n+        \"expr\" => Expr,\n+        \"ty\" => Type,\n+        \"pat\" => Pattern,\n+        \"stmt\" => Statement,\n+        \"block\" => Block,\n+        \"meta\" => MetaItem,\n+        \"item\" => Item,\n+        _ => {\n+            let tt_result = match kind {\n+                \"ident\" => input\n+                    .expect_ident()\n+                    .map(|ident| Some(tt::Leaf::from(ident.clone()).into()))\n+                    .map_err(|()| err!(\"expected ident\")),\n+                \"tt\" => input.expect_tt().map(Some).map_err(|()| err!()),\n+                \"lifetime\" => input\n+                    .expect_lifetime()\n+                    .map(|tt| Some(tt))\n+                    .map_err(|()| err!(\"expected lifetime\")),\n+                \"literal\" => {\n+                    let neg = input.eat_char('-');\n+                    input\n+                        .expect_literal()\n+                        .map(|literal| {\n+                            let lit = tt::Leaf::from(literal.clone());\n+                            match neg {\n+                                None => Some(lit.into()),\n+                                Some(neg) => Some(tt::TokenTree::Subtree(tt::Subtree {\n+                                    delimiter: None,\n+                                    token_trees: vec![neg, lit.into()],\n+                                })),\n+                            }\n+                        })\n+                        .map_err(|()| err!())\n+                }\n+                // `vis` is optional\n+                \"vis\" => match input.eat_vis() {\n+                    Some(vis) => Ok(Some(vis)),\n+                    None => Ok(None),\n+                },\n+                _ => Err(ExpandError::UnexpectedToken),\n+            };\n+            return tt_result.map(|it| it.map(Fragment::Tokens)).into();\n+        }\n+    };\n+    let result = input.expect_fragment(fragment);\n+    result.map(|tt| if kind == \"expr\" { tt.map(Fragment::Ast) } else { tt.map(Fragment::Tokens) })\n+}\n+\n+fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &MetaTemplate) {\n+    for op in pattern.iter() {\n+        match op {\n+            Op::Var { name, .. } => buf.push(name.clone()),\n+            Op::Leaf(_) => (),\n+            Op::Subtree(subtree) => collect_vars(buf, subtree),\n+            Op::Repeat { subtree, .. } => collect_vars(buf, subtree),\n+        }\n     }\n-    Ok(())\n }\n \n impl<'a> TtIter<'a> {\n@@ -369,134 +488,3 @@ impl<'a> TtIter<'a> {\n         }\n     }\n }\n-\n-pub(super) fn match_repeat(\n-    res: &mut Match,\n-    pattern: &MetaTemplate,\n-    kind: RepeatKind,\n-    separator: &Option<Separator>,\n-    src: &mut TtIter,\n-) -> Result<(), ExpandError> {\n-    // Dirty hack to make macro-expansion terminate.\n-    // This should be replaced by a proper macro-by-example implementation\n-    let mut limit = 65536;\n-    let mut counter = 0;\n-\n-    for i in 0.. {\n-        let mut fork = src.clone();\n-\n-        if let Some(separator) = &separator {\n-            if i != 0 && !fork.eat_separator(separator) {\n-                break;\n-            }\n-        }\n-\n-        let mut nested = Match::default();\n-        match_subtree(&mut nested, pattern, &mut fork)?;\n-        if nested.err.is_none() {\n-            limit -= 1;\n-            if limit == 0 {\n-                log::warn!(\n-                    \"match_lhs exceeded repeat pattern limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\",\n-                    pattern,\n-                    src,\n-                    kind,\n-                    separator\n-                );\n-                break;\n-            }\n-            *src = fork;\n-\n-            if let Err(err) = res.bindings.push_nested(counter, nested.bindings) {\n-                res.add_err(err);\n-            }\n-            counter += 1;\n-            if counter == 1 {\n-                if let RepeatKind::ZeroOrOne = kind {\n-                    break;\n-                }\n-            }\n-        } else {\n-            break;\n-        }\n-    }\n-\n-    match (kind, counter) {\n-        (RepeatKind::OneOrMore, 0) => {\n-            res.add_err(ExpandError::UnexpectedToken);\n-        }\n-        (_, 0) => {\n-            // Collect all empty variables in subtrees\n-            let mut vars = Vec::new();\n-            collect_vars(&mut vars, pattern)?;\n-            for var in vars {\n-                res.bindings.push_empty(&var)\n-            }\n-        }\n-        _ => (),\n-    }\n-    Ok(())\n-}\n-\n-fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragment>> {\n-    let fragment = match kind {\n-        \"path\" => Path,\n-        \"expr\" => Expr,\n-        \"ty\" => Type,\n-        \"pat\" => Pattern,\n-        \"stmt\" => Statement,\n-        \"block\" => Block,\n-        \"meta\" => MetaItem,\n-        \"item\" => Item,\n-        _ => {\n-            let tt_result = match kind {\n-                \"ident\" => input\n-                    .expect_ident()\n-                    .map(|ident| Some(tt::Leaf::from(ident.clone()).into()))\n-                    .map_err(|()| err!(\"expected ident\")),\n-                \"tt\" => input.expect_tt().map(Some).map_err(|()| err!()),\n-                \"lifetime\" => input\n-                    .expect_lifetime()\n-                    .map(|tt| Some(tt))\n-                    .map_err(|()| err!(\"expected lifetime\")),\n-                \"literal\" => {\n-                    let neg = input.eat_char('-');\n-                    input\n-                        .expect_literal()\n-                        .map(|literal| {\n-                            let lit = tt::Leaf::from(literal.clone());\n-                            match neg {\n-                                None => Some(lit.into()),\n-                                Some(neg) => Some(tt::TokenTree::Subtree(tt::Subtree {\n-                                    delimiter: None,\n-                                    token_trees: vec![neg, lit.into()],\n-                                })),\n-                            }\n-                        })\n-                        .map_err(|()| err!())\n-                }\n-                // `vis` is optional\n-                \"vis\" => match input.eat_vis() {\n-                    Some(vis) => Ok(Some(vis)),\n-                    None => Ok(None),\n-                },\n-                _ => Err(ExpandError::UnexpectedToken),\n-            };\n-            return tt_result.map(|it| it.map(Fragment::Tokens)).into();\n-        }\n-    };\n-    let result = input.expect_fragment(fragment);\n-    result.map(|tt| if kind == \"expr\" { tt.map(Fragment::Ast) } else { tt.map(Fragment::Tokens) })\n-}\n-\n-fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &MetaTemplate) -> Result<(), ExpandError> {\n-    for op in pattern.iter() {\n-        match op.as_ref().map_err(|e| e.clone())? {\n-            Op::Var { name, .. } => buf.push(name.clone()),\n-            Op::Leaf(_) => (),\n-            Op::Subtree(subtree) => collect_vars(buf, subtree)?,\n-            Op::Repeat { subtree, .. } => collect_vars(buf, subtree)?,\n-        }\n-    }\n-    Ok(())\n-}"}, {"sha": "30c090f32bde98b8fdb8a4fc19f3511d2c9a0918", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7108fb5b198d4fe416ce2408afaa86f1020c37d/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7108fb5b198d4fe416ce2408afaa86f1020c37d/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=e7108fb5b198d4fe416ce2408afaa86f1020c37d", "patch": "@@ -86,13 +86,6 @@ fn expand_subtree(\n     let start_elements = arena.len();\n     let mut err = None;\n     for op in template.iter() {\n-        let op = match op {\n-            Ok(op) => op,\n-            Err(e) => {\n-                err = Some(e.clone());\n-                break;\n-            }\n-        };\n         match op {\n             Op::Leaf(tt) => arena.push(tt.clone().into()),\n             Op::Subtree(tt) => {"}, {"sha": "56c632665ea4e0beca1b0f60bc9efe82f40fd2da", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e7108fb5b198d4fe416ce2408afaa86f1020c37d/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7108fb5b198d4fe416ce2408afaa86f1020c37d/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=e7108fb5b198d4fe416ce2408afaa86f1020c37d", "patch": "@@ -24,7 +24,9 @@ use crate::{\n \n #[derive(Debug, PartialEq, Eq)]\n pub enum ParseError {\n+    UnexpectedToken(String),\n     Expected(String),\n+    InvalidRepeat,\n     RepetitionEmptyTokenTree,\n }\n \n@@ -34,7 +36,6 @@ pub enum ExpandError {\n     UnexpectedToken,\n     BindingError(String),\n     ConversionError,\n-    InvalidRepeat,\n     ProcMacroError(tt::ExpansionError),\n     UnresolvedProcMacro,\n     Other(String),\n@@ -53,7 +54,6 @@ impl fmt::Display for ExpandError {\n             ExpandError::UnexpectedToken => f.write_str(\"unexpected token in input\"),\n             ExpandError::BindingError(e) => f.write_str(e),\n             ExpandError::ConversionError => f.write_str(\"could not convert tokens\"),\n-            ExpandError::InvalidRepeat => f.write_str(\"invalid repeat expression\"),\n             ExpandError::ProcMacroError(e) => e.fmt(f),\n             ExpandError::UnresolvedProcMacro => f.write_str(\"unresolved proc macro\"),\n             ExpandError::Other(e) => f.write_str(e),\n@@ -94,11 +94,11 @@ struct Rule {\n #[derive(Clone, Debug, PartialEq, Eq)]\n struct MetaTemplate {\n     delimiter: Option<Delimiter>,\n-    tokens: Vec<Result<Op, ExpandError>>,\n+    tokens: Vec<Op>,\n }\n \n impl<'a> MetaTemplate {\n-    fn iter(&self) -> impl Iterator<Item = &Result<Op, ExpandError>> {\n+    fn iter(&self) -> impl Iterator<Item = &Op> {\n         self.tokens.iter()\n     }\n \n@@ -288,25 +288,15 @@ impl Rule {\n             .expect_subtree()\n             .map_err(|()| ParseError::Expected(\"expected subtree\".to_string()))?;\n \n-        let lhs = MetaTemplate { tokens: parse_pattern(&lhs), delimiter: None };\n-        let rhs = MetaTemplate { tokens: parse_template(&rhs), delimiter: None };\n+        let lhs = MetaTemplate { tokens: parse_pattern(&lhs)?, delimiter: None };\n+        let rhs = MetaTemplate { tokens: parse_template(&rhs)?, delimiter: None };\n \n         Ok(crate::Rule { lhs, rhs })\n     }\n }\n \n-fn to_parse_error(e: &ExpandError) -> ParseError {\n-    let msg = match e {\n-        ExpandError::InvalidRepeat => \"invalid repeat\".to_string(),\n-        _ => \"invalid macro definition\".to_string(),\n-    };\n-    ParseError::Expected(msg)\n-}\n-\n fn validate(pattern: &MetaTemplate) -> Result<(), ParseError> {\n     for op in pattern.iter() {\n-        let op = op.as_ref().map_err(|e| to_parse_error(&e))?;\n-\n         match op {\n             Op::Subtree(subtree) => validate(&subtree)?,\n             Op::Repeat { subtree, separator, .. } => {\n@@ -315,20 +305,21 @@ fn validate(pattern: &MetaTemplate) -> Result<(), ParseError> {\n \n                 if separator.is_none() {\n                     if subtree.iter().all(|child_op| {\n-                        match child_op.as_ref().map_err(to_parse_error) {\n-                            Ok(Op::Var { kind, .. }) => {\n+                        match child_op {\n+                            Op::Var { kind, .. } => {\n                                 // vis is optional\n                                 if kind.as_ref().map_or(false, |it| it == \"vis\") {\n                                     return true;\n                                 }\n                             }\n-                            Ok(Op::Repeat { kind, .. }) => {\n+                            Op::Repeat { kind, .. } => {\n                                 return matches!(\n                                     kind,\n                                     parser::RepeatKind::ZeroOrMore | parser::RepeatKind::ZeroOrOne\n                                 )\n                             }\n-                            _ => {}\n+                            Op::Leaf(_) => {}\n+                            Op::Subtree(_) => {}\n                         }\n                         false\n                     }) {"}, {"sha": "b90ae7015db7c811a5e97bed9165855cd14f4035", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e7108fb5b198d4fe416ce2408afaa86f1020c37d/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7108fb5b198d4fe416ce2408afaa86f1020c37d/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=e7108fb5b198d4fe416ce2408afaa86f1020c37d", "patch": "@@ -4,7 +4,7 @@\n use smallvec::SmallVec;\n use syntax::SmolStr;\n \n-use crate::{tt_iter::TtIter, ExpandError, MetaTemplate};\n+use crate::{tt_iter::TtIter, MetaTemplate, ParseError};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Op {\n@@ -46,12 +46,12 @@ impl PartialEq for Separator {\n     }\n }\n \n-pub(crate) fn parse_template(template: &tt::Subtree) -> Vec<Result<Op, ExpandError>> {\n-    parse_inner(&template, Mode::Template)\n+pub(crate) fn parse_template(template: &tt::Subtree) -> Result<Vec<Op>, ParseError> {\n+    parse_inner(&template, Mode::Template).into_iter().collect()\n }\n \n-pub(crate) fn parse_pattern(pattern: &tt::Subtree) -> Vec<Result<Op, ExpandError>> {\n-    parse_inner(&pattern, Mode::Pattern)\n+pub(crate) fn parse_pattern(pattern: &tt::Subtree) -> Result<Vec<Op>, ParseError> {\n+    parse_inner(&pattern, Mode::Pattern).into_iter().collect()\n }\n \n #[derive(Clone, Copy)]\n@@ -60,7 +60,7 @@ enum Mode {\n     Template,\n }\n \n-fn parse_inner(tt: &tt::Subtree, mode: Mode) -> Vec<Result<Op, ExpandError>> {\n+fn parse_inner(tt: &tt::Subtree, mode: Mode) -> Vec<Result<Op, ParseError>> {\n     let mut src = TtIter::new(&tt);\n     std::iter::from_fn(move || {\n         let first = src.next()?;\n@@ -71,7 +71,7 @@ fn parse_inner(tt: &tt::Subtree, mode: Mode) -> Vec<Result<Op, ExpandError>> {\n \n macro_rules! err {\n     ($($tt:tt)*) => {\n-        ExpandError::UnexpectedToken\n+        ParseError::UnexpectedToken(($($tt)*).to_string())\n     };\n }\n \n@@ -81,7 +81,7 @@ macro_rules! bail {\n     };\n }\n \n-fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Result<Op, ExpandError> {\n+fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Result<Op, ParseError> {\n     let res = match first {\n         tt::TokenTree::Leaf(leaf @ tt::Leaf::Punct(tt::Punct { char: '$', .. })) => {\n             // Note that the '$' itself is a valid token inside macro_rules.\n@@ -93,7 +93,9 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                 tt::TokenTree::Subtree(subtree) => {\n                     let (separator, kind) = parse_repeat(src)?;\n                     let delimiter = subtree.delimiter;\n-                    let tokens = parse_inner(&subtree, mode);\n+                    let tokens = parse_inner(&subtree, mode)\n+                        .into_iter()\n+                        .collect::<Result<Vec<Op>, ParseError>>()?;\n                     let subtree = MetaTemplate { tokens, delimiter };\n                     Op::Repeat { subtree, separator, kind }\n                 }\n@@ -102,7 +104,7 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                         static UNDERSCORE: SmolStr = SmolStr::new_inline(\"_\");\n \n                         if punct.char != '_' {\n-                            return Err(ExpandError::UnexpectedToken);\n+                            return Err(ParseError::Expected(\"_\".to_string()));\n                         }\n                         let name = UNDERSCORE.clone();\n                         let kind = eat_fragment_kind(src, mode)?;\n@@ -135,15 +137,17 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n         tt::TokenTree::Leaf(tt) => Op::Leaf(tt.clone()),\n         tt::TokenTree::Subtree(subtree) => {\n             let delimiter = subtree.delimiter;\n-            let tokens = parse_inner(&subtree, mode);\n+            let tokens =\n+                parse_inner(&subtree, mode).into_iter().collect::<Result<Vec<Op>, ParseError>>()?;\n+\n             let subtree = MetaTemplate { tokens, delimiter };\n             Op::Subtree(subtree)\n         }\n     };\n     Ok(res)\n }\n \n-fn eat_fragment_kind<'a>(src: &mut TtIter<'a>, mode: Mode) -> Result<Option<SmolStr>, ExpandError> {\n+fn eat_fragment_kind<'a>(src: &mut TtIter<'a>, mode: Mode) -> Result<Option<SmolStr>, ParseError> {\n     if let Mode::Pattern = mode {\n         src.expect_char(':').map_err(|()| err!(\"bad fragment specifier 1\"))?;\n         let ident = src.expect_ident().map_err(|()| err!(\"bad fragment specifier 1\"))?;\n@@ -156,20 +160,20 @@ fn is_boolean_literal(lit: &tt::Literal) -> bool {\n     matches!(lit.text.as_str(), \"true\" | \"false\")\n }\n \n-fn parse_repeat(src: &mut TtIter) -> Result<(Option<Separator>, RepeatKind), ExpandError> {\n+fn parse_repeat(src: &mut TtIter) -> Result<(Option<Separator>, RepeatKind), ParseError> {\n     let mut separator = Separator::Puncts(SmallVec::new());\n     for tt in src {\n         let tt = match tt {\n             tt::TokenTree::Leaf(leaf) => leaf,\n-            tt::TokenTree::Subtree(_) => return Err(ExpandError::InvalidRepeat),\n+            tt::TokenTree::Subtree(_) => return Err(ParseError::InvalidRepeat),\n         };\n         let has_sep = match &separator {\n             Separator::Puncts(puncts) => !puncts.is_empty(),\n             _ => true,\n         };\n         match tt {\n             tt::Leaf::Ident(_) | tt::Leaf::Literal(_) if has_sep => {\n-                return Err(ExpandError::InvalidRepeat)\n+                return Err(ParseError::InvalidRepeat)\n             }\n             tt::Leaf::Ident(ident) => separator = Separator::Ident(ident.clone()),\n             tt::Leaf::Literal(lit) => separator = Separator::Literal(lit.clone()),\n@@ -182,11 +186,11 @@ fn parse_repeat(src: &mut TtIter) -> Result<(Option<Separator>, RepeatKind), Exp\n                         match &mut separator {\n                             Separator::Puncts(puncts) => {\n                                 if puncts.len() == 3 {\n-                                    return Err(ExpandError::InvalidRepeat);\n+                                    return Err(ParseError::InvalidRepeat);\n                                 }\n                                 puncts.push(punct.clone())\n                             }\n-                            _ => return Err(ExpandError::InvalidRepeat),\n+                            _ => return Err(ParseError::InvalidRepeat),\n                         }\n                         continue;\n                     }\n@@ -196,5 +200,5 @@ fn parse_repeat(src: &mut TtIter) -> Result<(Option<Separator>, RepeatKind), Exp\n             }\n         }\n     }\n-    Err(ExpandError::InvalidRepeat)\n+    Err(ParseError::InvalidRepeat)\n }"}, {"sha": "1c467facdc3a5b075387a3110eb9f5476a6fc70b", "filename": "crates/mbe/src/tests.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e7108fb5b198d4fe416ce2408afaa86f1020c37d/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7108fb5b198d4fe416ce2408afaa86f1020c37d/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=e7108fb5b198d4fe416ce2408afaa86f1020c37d", "patch": "@@ -33,19 +33,18 @@ mod rule_parsing {\n \n     #[test]\n     fn test_invalid_arms() {\n-        fn check(macro_body: &str, err: &str) {\n+        fn check(macro_body: &str, err: ParseError) {\n             let m = parse_macro_arm(macro_body);\n-            assert_eq!(m, Err(ParseError::Expected(String::from(err))));\n+            assert_eq!(m, Err(err.into()));\n         }\n+        check(\"invalid\", ParseError::Expected(\"expected subtree\".into()));\n \n-        check(\"invalid\", \"expected subtree\");\n+        check(\"$i:ident => ()\", ParseError::Expected(\"expected subtree\".into()));\n+        check(\"($i:ident) ()\", ParseError::Expected(\"expected `=`\".into()));\n+        check(\"($($i:ident)_) => ()\", ParseError::InvalidRepeat);\n \n-        check(\"$i:ident => ()\", \"expected subtree\");\n-        check(\"($i:ident) ()\", \"expected `=`\");\n-        check(\"($($i:ident)_) => ()\", \"invalid repeat\");\n-\n-        check(\"($i) => ($i)\", \"invalid macro definition\");\n-        check(\"($i:) => ($i)\", \"invalid macro definition\");\n+        check(\"($i) => ($i)\", ParseError::UnexpectedToken(\"bad fragment specifier 1\".into()));\n+        check(\"($i:) => ($i)\", ParseError::UnexpectedToken(\"bad fragment specifier 1\".into()));\n     }\n \n     fn parse_macro_arm(arm_definition: &str) -> Result<crate::MacroRules, ParseError> {"}]}