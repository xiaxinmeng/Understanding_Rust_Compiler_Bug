{"sha": "64c561dc2253463659a8ae93b3d265dda45c6ee9", "node_id": "C_kwDOAAsO6NoAKDY0YzU2MWRjMjI1MzQ2MzY1OWE4YWU5M2IzZDI2NWRkYTQ1YzZlZTk", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2021-09-26T16:20:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-26T16:20:02Z"}, "message": "Fix global initialization (#91)\n\n* Make define_global() return a RValue directly\r\n* Return LValue in functions declaring a global variable\r\n* Remove useless cast\r\n* Fix bytes_in_context to use an array rvalue\r\n* Remove global_names which is unused\r\n* Make const_struct create a constant struct\r\n* Correctly initialize global in static_addr_of_mut\r\n* Fix global variable initialization\r\n* Remove workaround for ARGV", "tree": {"sha": "6cb8b4c4a56a1384f3ae15115204d2711692a5e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cb8b4c4a56a1384f3ae15115204d2711692a5e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64c561dc2253463659a8ae93b3d265dda45c6ee9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhUJ2yCRBK7hj4Ov3rIwAAljIIAJB4mk0QtNJUzVWYmGWS/bm4\nWvonmi11t9OrHOrTw9tTx+UZEyTyn4EyjrnhDSbcQydVc01JLMeOpFvD5dBZggPL\nfVvo4teSwnOq3EjWjsesluqR9bhSneX6fO9aIexBvQwVPhFarcI4s+wnYWeL6ZhU\nYo93O3vv3vEE0dP4dKxNYNr173mkevg6QyZu9gxLBaj2fECy5M6o4FJ1lXO3buhn\nbNwqhxZDqkt61h/cbSOE7JW/V/zT4uIDTndUAUBAMppf0B0EOu99GNz0se96H7rd\nu5NdDrbG82c1RpKSr6pzB65TRgia+qzksjS8iC9wOMFuQROJQZzD1Z7JmQi5D3s=\n=vqaX\n-----END PGP SIGNATURE-----\n", "payload": "tree 6cb8b4c4a56a1384f3ae15115204d2711692a5e3\nparent 4e7e822f39fca4ccf146a71dbb1098b76ecea1af\nauthor antoyo <antoyo@users.noreply.github.com> 1632673202 -0400\ncommitter GitHub <noreply@github.com> 1632673202 -0400\n\nFix global initialization (#91)\n\n* Make define_global() return a RValue directly\r\n* Return LValue in functions declaring a global variable\r\n* Remove useless cast\r\n* Fix bytes_in_context to use an array rvalue\r\n* Remove global_names which is unused\r\n* Make const_struct create a constant struct\r\n* Correctly initialize global in static_addr_of_mut\r\n* Fix global variable initialization\r\n* Remove workaround for ARGV"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64c561dc2253463659a8ae93b3d265dda45c6ee9", "html_url": "https://github.com/rust-lang/rust/commit/64c561dc2253463659a8ae93b3d265dda45c6ee9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64c561dc2253463659a8ae93b3d265dda45c6ee9/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e7e822f39fca4ccf146a71dbb1098b76ecea1af", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e7e822f39fca4ccf146a71dbb1098b76ecea1af", "html_url": "https://github.com/rust-lang/rust/commit/4e7e822f39fca4ccf146a71dbb1098b76ecea1af"}], "stats": {"total": 376, "additions": 93, "deletions": 283}, "files": [{"sha": "60a2101c689cc2d1d6102a682956e61190f370cd", "filename": "Cargo.lock", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/64c561dc2253463659a8ae93b3d265dda45c6ee9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/64c561dc2253463659a8ae93b3d265dda45c6ee9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=64c561dc2253463659a8ae93b3d265dda45c6ee9", "patch": "@@ -25,9 +25,9 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"bitflags\"\n-version = \"1.2.1\"\n+version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n+checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -56,15 +56,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#54be27e41fff7b6ab532e2e21a82df50a12b9ad3\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#2d4fea7319f80531b2e5d264fca9f1c498a3a62e\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#54be27e41fff7b6ab532e2e21a82df50a12b9ad3\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#2d4fea7319f80531b2e5d264fca9f1c498a3a62e\"\n dependencies = [\n  \"libc 0.1.12\",\n ]\n@@ -85,7 +85,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7fcd999463524c52659517fe2cea98493cfe485d10565e7b0fb07dbba7ad2753\"\n dependencies = [\n  \"cfg-if\",\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n  \"wasi\",\n ]\n \n@@ -101,7 +101,7 @@ version = \"0.1.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n dependencies = [\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n ]\n \n [[package]]\n@@ -122,7 +122,7 @@ checksum = \"96bd995a092cac79868250589869b5a5d656b02a02bd74c8ebdc566dc7203090\"\n dependencies = [\n  \"fm\",\n  \"getopts\",\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n  \"num_cpus\",\n  \"termcolor\",\n  \"threadpool\",\n@@ -138,15 +138,15 @@ checksum = \"e32a70cf75e5846d53a673923498228bbec6a8624708a9ea5645f075d6276122\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.98\"\n+version = \"0.2.102\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"320cfe77175da3a483efed4bc0adc1968ca050b098ce4f2f1c13a56626128790\"\n+checksum = \"a2a5ac8f984bfcf3a823267e5fde638acc3325f6496633a5da6bb6eb2171e103\"\n \n [[package]]\n name = \"memchr\"\n-version = \"2.4.0\"\n+version = \"2.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b16bd47d9e329435e309c58469fe0791c2d0d1ba96ec0954152a5ae2b04387dc\"\n+checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n \n [[package]]\n name = \"num_cpus\"\n@@ -155,7 +155,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"05499f3756671c15885fee9034446956fff3f243d6077b91e5767df161f766b3\"\n dependencies = [\n  \"hermit-abi\",\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n ]\n \n [[package]]\n@@ -181,7 +181,7 @@ version = \"0.8.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2e7573632e6454cf6b99d7aac4ccca54be06da05aca2ef7423d22d27d4d4bcd8\"\n dependencies = [\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n  \"rand_chacha\",\n  \"rand_core\",\n  \"rand_hc\",\n@@ -217,9 +217,9 @@ dependencies = [\n \n [[package]]\n name = \"redox_syscall\"\n-version = \"0.2.9\"\n+version = \"0.2.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5ab49abadf3f9e1c4bc499e8845e152ad87d2ad2d30371841171169e9d75feee\"\n+checksum = \"8383f39639269cde97d255a32bdb68c047337295414940c68bdd30c2e13203ff\"\n dependencies = [\n  \"bitflags\",\n ]\n@@ -284,7 +284,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dac1c663cfc93810f88aed9b8941d48cabf856a1b111c29a40439018d870eb22\"\n dependencies = [\n  \"cfg-if\",\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n  \"rand\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n@@ -311,17 +311,17 @@ dependencies = [\n \n [[package]]\n name = \"unicode-width\"\n-version = \"0.1.8\"\n+version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9337591893a19b88d8d87f2cec1e73fad5cdfd10e5a6f349f498ad6ea2ffb1e3\"\n+checksum = \"3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973\"\n \n [[package]]\n name = \"wait-timeout\"\n version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9f200f5b12eb75f8c1ed65abd4b2db8a6e1b138a20de009dacee265a2498f3f6\"\n dependencies = [\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n ]\n \n [[package]]"}, {"sha": "9fd043607fc7e25bb9a81c11823b106af686c7db", "filename": "src/base.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=64c561dc2253463659a8ae93b3d265dda45c6ee9", "patch": "@@ -1,13 +1,11 @@\n use std::env;\n-use std::sync::Once;\n use std::time::Instant;\n \n use gccjit::{\n     Context,\n     FunctionType,\n     GlobalKind,\n };\n-use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::dep_graph;\n use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::middle::exported_symbols;\n@@ -20,7 +18,7 @@ use rustc_codegen_ssa::traits::DebugInfoMethods;\n use rustc_session::config::DebugInfo;\n use rustc_span::Symbol;\n \n-use crate::{GccContext, create_function_calling_initializers};\n+use crate::GccContext;\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n \n@@ -97,15 +95,6 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n         {\n             let cx = CodegenCx::new(&context, cgu, tcx);\n \n-            static START: Once = Once::new();\n-            START.call_once(|| {\n-                let initializer_name = format!(\"__gccGlobalCrateInit{}\", tcx.crate_name(LOCAL_CRATE));\n-                let func = context.new_function(None, FunctionType::Exported, context.new_type::<()>(), &[], initializer_name, false);\n-                let block = func.new_block(\"initial\");\n-                create_function_calling_initializers(tcx, &context, block);\n-                block.end_with_void_return(None);\n-            });\n-\n             let mono_items = cgu.items_in_deterministic_order(tcx);\n             for &(mono_item, (linkage, visibility)) in &mono_items {\n                 mono_item.predefine::<Builder<'_, '_, '_>>(&cx, linkage, visibility);\n@@ -124,8 +113,6 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n             if cx.sess().opts.debuginfo != DebugInfo::None {\n                 cx.debuginfo_finalize();\n             }\n-\n-            cx.global_init_block.end_with_void_return(None);\n         }\n \n         ModuleCodegen {"}, {"sha": "fd3710062ee4517b3d919b81fd82c7bc44bedac0", "filename": "src/builder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=64c561dc2253463659a8ae93b3d265dda45c6ee9", "patch": "@@ -505,7 +505,6 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // FIXME(antoyo): rustc_codegen_ssa::mir::intrinsic uses different types for a and b but they\n         // should be the same.\n         let typ = a.get_type().to_signed(self);\n-        let a = self.context.new_cast(None, a, typ);\n         let b = self.context.new_cast(None, b, typ);\n         a / b\n     }\n@@ -1413,7 +1412,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n impl<'a, 'gcc, 'tcx> StaticBuilderMethods for Builder<'a, 'gcc, 'tcx> {\n     fn get_static(&mut self, def_id: DefId) -> RValue<'gcc> {\n         // Forward to the `get_static` method of `CodegenCx`\n-        self.cx().get_static(def_id)\n+        self.cx().get_static(def_id).get_address(None)\n     }\n }\n "}, {"sha": "aa86332c475cf1de7a078f76a173fe884bbc4a17", "filename": "src/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcallee.rs?ref=64c561dc2253463659a8ae93b3d265dda45c6ee9", "patch": "@@ -20,7 +20,7 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n-    if let Some(&func) = cx.instances.borrow().get(&instance) {\n+    if let Some(&func) = cx.function_instances.borrow().get(&instance) {\n         return func;\n     }\n \n@@ -72,7 +72,7 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n             func\n         };\n \n-    cx.instances.borrow_mut().insert(instance, func);\n+    cx.function_instances.borrow_mut().insert(instance, func);\n \n     func\n }"}, {"sha": "c60cbd81f636a299deacf035e9601210f43fb643", "filename": "src/common.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=64c561dc2253463659a8ae93b3d265dda45c6ee9", "patch": "@@ -1,6 +1,7 @@\n use std::convert::TryFrom;\n use std::convert::TryInto;\n \n+use gccjit::LValue;\n use gccjit::{Block, CType, RValue, Type, ToRValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{\n@@ -10,7 +11,6 @@ use rustc_codegen_ssa::traits::{\n     MiscMethods,\n     StaticMethods,\n };\n-use rustc_middle::bug;\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty::ScalarInt;\n use rustc_middle::ty::layout::{TyAndLayout, LayoutOf};\n@@ -27,28 +27,27 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         bytes_in_context(self, bytes)\n     }\n \n-    fn const_cstr(&self, symbol: Symbol, _null_terminated: bool) -> RValue<'gcc> {\n+    fn const_cstr(&self, symbol: Symbol, _null_terminated: bool) -> LValue<'gcc> {\n         // TODO(antoyo): handle null_terminated.\n         if let Some(&value) = self.const_cstr_cache.borrow().get(&symbol) {\n-            return value.to_rvalue();\n+            return value;\n         }\n \n         let global = self.global_string(&*symbol.as_str());\n \n-        self.const_cstr_cache.borrow_mut().insert(symbol, global.dereference(None));\n+        self.const_cstr_cache.borrow_mut().insert(symbol, global);\n         global\n     }\n \n-    fn global_string(&self, string: &str) -> RValue<'gcc> {\n+    fn global_string(&self, string: &str) -> LValue<'gcc> {\n         // TODO(antoyo): handle non-null-terminated strings.\n         let string = self.context.new_string_literal(&*string);\n         let sym = self.generate_local_symbol_name(\"str\");\n         // NOTE: TLS is always off for a string litteral.\n         // NOTE: string litterals do not have a link section.\n-        let global = self.define_global(&sym, self.val_ty(string), false, None)\n-            .unwrap_or_else(|| bug!(\"symbol `{}` is already defined\", sym));\n-        self.global_init_block.add_assignment(None, global.dereference(None), string);\n-        global.to_rvalue()\n+        let global = self.declare_private_global(&sym, self.val_ty(string));\n+        global.global_set_initializer_value(string); // TODO: only set if not imported?\n+        global\n         // TODO(antoyo): set linkage.\n     }\n \n@@ -76,10 +75,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) -> RValue<'gcc> {\n     let context = &cx.context;\n-    let typ = context.new_array_type(None, context.new_type::<u8>(), bytes.len() as i32);\n-    let global = cx.declare_unnamed_global(typ);\n-    global.global_set_initializer(bytes);\n-    global.to_rvalue()\n+    let byte_type = context.new_type::<u8>();\n+    let typ = context.new_array_type(None, byte_type, bytes.len() as i32);\n+    let elements: Vec<_> =\n+        bytes.iter()\n+        .map(|&byte| context.new_rvalue_from_int(byte_type, byte as i32))\n+        .collect();\n+    context.new_rvalue_from_array(None, typ, &elements)\n }\n \n pub fn type_is_pointer<'gcc>(typ: Type<'gcc>) -> bool {\n@@ -180,7 +182,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     fn const_str(&self, s: Symbol) -> (RValue<'gcc>, RValue<'gcc>) {\n         let len = s.as_str().len();\n-        let cs = self.const_ptrcast(self.const_cstr(s, false),\n+        let cs = self.const_ptrcast(self.const_cstr(s, false).get_address(None),\n             self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self, true)),\n         );\n         (cs, self.const_usize(len as u64))\n@@ -191,16 +193,9 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             .map(|value| value.get_type())\n             .collect();\n         // TODO(antoyo): cache the type? It's anonymous, so probably not.\n-        let name = fields.iter().map(|typ| format!(\"{:?}\", typ)).collect::<Vec<_>>().join(\"_\");\n         let typ = self.type_struct(&fields, packed);\n-        let structure = self.global_init_func.new_local(None, typ, &name);\n         let struct_type = typ.is_struct().expect(\"struct type\");\n-        for (index, value) in values.iter().enumerate() {\n-            let field = struct_type.get_field(index as i32);\n-            let field_lvalue = structure.access_field(None, field);\n-            self.global_init_block.add_assignment(None, field_lvalue, *value);\n-        }\n-        self.lvalue_to_rvalue(structure)\n+        self.context.new_rvalue_from_struct(None, struct_type, values)\n     }\n \n     fn const_to_opt_uint(&self, _v: RValue<'gcc>) -> Option<u64> {\n@@ -260,19 +255,18 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                         },\n                         GlobalAlloc::Static(def_id) => {\n                             assert!(self.tcx.is_static(def_id));\n-                            self.get_static(def_id)\n+                            self.get_static(def_id).get_address(None)\n                         },\n                     };\n                 let ptr_type = base_addr.get_type();\n                 let base_addr = self.const_bitcast(base_addr, self.usize_type);\n                 let offset = self.context.new_rvalue_from_long(self.usize_type, offset.bytes() as i64);\n                 let ptr = self.const_bitcast(base_addr + offset, ptr_type);\n-                let value = ptr.dereference(None);\n                 if layout.value != Pointer {\n-                    self.const_bitcast(value.to_rvalue(), ty)\n+                    self.const_bitcast(ptr.dereference(None).to_rvalue(), ty)\n                 }\n                 else {\n-                    self.const_bitcast(value.get_address(None), ty)\n+                    self.const_bitcast(ptr, ty)\n                 }\n             }\n         }"}, {"sha": "205498acc3187beb9260e194db2e3de1c06d5426", "filename": "src/consts.rs", "status": "modified", "additions": 22, "deletions": 67, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=64c561dc2253463659a8ae93b3d265dda45c6ee9", "patch": "@@ -1,4 +1,4 @@\n-use gccjit::{RValue, Type};\n+use gccjit::{LValue, RValue, ToRValue, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, DerivedTypeMethods, StaticMethods};\n use rustc_hir as hir;\n use rustc_hir::Node;\n@@ -14,7 +14,6 @@ use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRan\n \n use crate::base;\n use crate::context::CodegenCx;\n-use crate::mangled_std_symbols::{ARGC, ARGV, ARGV_INIT_ARRAY};\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -45,17 +44,13 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n     fn codegen_static(&self, def_id: DefId, is_mutable: bool) {\n         let attrs = self.tcx.codegen_fn_attrs(def_id);\n \n-        let instance = Instance::mono(self.tcx, def_id);\n-        let name = &*self.tcx.symbol_name(instance).name;\n-\n-        let (value, alloc) =\n+        let value =\n             match codegen_static_initializer(&self, def_id) {\n-                Ok(value) => value,\n+                Ok((value, _)) => value,\n                 // Error has already been reported\n                 Err(_) => return,\n             };\n \n-        let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n         let global = self.get_static(def_id);\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n@@ -73,45 +68,16 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n         let gcc_type = self.layout_of(ty).gcc_type(self, true);\n \n-        let global =\n-            if val_llty == gcc_type {\n-                global\n+        // TODO(antoyo): set alignment.\n+\n+        let value =\n+            if value.get_type() != gcc_type {\n+                self.context.new_bitcast(None, value, gcc_type)\n             }\n             else {\n-                // If we created the global with the wrong type,\n-                // correct the type.\n-                // TODO(antoyo): set value name, linkage and visibility.\n-\n-                let new_global = self.get_or_insert_global(&name, val_llty, is_tls, attrs.link_section);\n-\n-                // To avoid breaking any invariants, we leave around the old\n-                // global for the moment; we'll replace all references to it\n-                // with the new global later. (See base::codegen_backend.)\n-                //self.statics_to_rauw.borrow_mut().push((global, new_global));\n-                new_global\n+                value\n             };\n-        // TODO(antoyo): set alignment and initializer.\n-        let value = self.rvalue_as_lvalue(value);\n-        let value = value.get_address(None);\n-        let dest_typ = global.get_type();\n-        let value = self.context.new_cast(None, value, dest_typ);\n-\n-        // NOTE: do not init the variables related to argc/argv because it seems we cannot\n-        // overwrite those variables.\n-        // FIXME(antoyo): correctly support global variable initialization.\n-        let skip_init = [\n-            ARGV_INIT_ARRAY,\n-            ARGC,\n-            ARGV,\n-        ];\n-        if !skip_init.iter().any(|symbol_name| name.starts_with(symbol_name)) {\n-            // TODO(antoyo): switch to set_initializer when libgccjit supports that.\n-            let memcpy = self.context.get_builtin_function(\"memcpy\");\n-            let dst = self.context.new_cast(None, global, self.type_i8p());\n-            let src = self.context.new_cast(None, value, self.type_ptr_to(self.type_void()));\n-            let size = self.context.new_rvalue_from_long(self.sizet_type, alloc.size().bytes() as i64);\n-            self.global_init_block.add_eval(None, self.context.new_call(None, memcpy, &[dst, src, size]));\n-        }\n+        global.global_set_initializer_value(value);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n@@ -175,7 +141,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n         }\n \n         if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n-            self.add_used_global(global);\n+            self.add_used_global(global.to_rvalue());\n         }\n     }\n \n@@ -191,38 +157,31 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn static_addr_of_mut(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n-        let (name, gv) =\n+        let global =\n             match kind {\n                 Some(kind) if !self.tcx.sess.fewer_names() => {\n                     let name = self.generate_local_symbol_name(kind);\n                     // TODO(antoyo): check if it's okay that TLS is off here.\n                     // TODO(antoyo): check if it's okay that link_section is None here.\n                     // TODO(antoyo): set alignment here as well.\n-                    let gv = self.define_global(&name[..], self.val_ty(cv), false, None).unwrap_or_else(|| {\n-                        bug!(\"symbol `{}` is already defined\", name);\n-                    });\n+                    let global = self.define_global(&name[..], self.val_ty(cv), false, None);\n                     // TODO(antoyo): set linkage.\n-                    (name, gv)\n+                    global\n                 }\n                 _ => {\n-                    let index = self.global_gen_sym_counter.get();\n-                    let name = format!(\"global_{}_{}\", index, self.codegen_unit.name());\n                     let typ = self.val_ty(cv).get_aligned(align.bytes());\n-                    let global = self.define_private_global(typ);\n-                    (name, global)\n+                    let global = self.declare_unnamed_global(typ);\n+                    global\n                 },\n             };\n         // FIXME(antoyo): I think the name coming from generate_local_symbol_name() above cannot be used\n         // globally.\n-        // NOTE: global seems to only be global in a module. So save the name instead of the value\n-        // to import it later.\n-        self.global_names.borrow_mut().insert(cv, name);\n-        self.global_init_block.add_assignment(None, gv.dereference(None), cv);\n+        global.global_set_initializer_value(cv);\n         // TODO(antoyo): set unnamed address.\n-        gv\n+        global.get_address(None)\n     }\n \n-    pub fn get_static(&self, def_id: DefId) -> RValue<'gcc> {\n+    pub fn get_static(&self, def_id: DefId) -> LValue<'gcc> {\n         let instance = Instance::mono(self.tcx, def_id);\n         let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n         if let Some(&global) = self.instances.borrow().get(&instance) {\n@@ -380,7 +339,7 @@ pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id\n     Ok((const_alloc_to_gcc(cx, alloc), alloc))\n }\n \n-fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str, span: Span) -> RValue<'gcc> {\n+fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str, span: Span) -> LValue<'gcc> {\n     let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n     let llty = cx.layout_of(ty).gcc_type(cx, true);\n     if let Some(linkage) = attrs.linkage {\n@@ -410,13 +369,9 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // zero.\n         let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n         real_name.push_str(&sym);\n-        let global2 =\n-            cx.define_global(&real_name, llty, is_tls, attrs.link_section).unwrap_or_else(|| {\n-                cx.sess().span_fatal(span, &format!(\"symbol `{}` is already defined\", &sym))\n-            });\n+        let global2 = cx.define_global(&real_name, llty, is_tls, attrs.link_section);\n         // TODO(antoyo): set linkage.\n-        let lvalue = global2.dereference(None);\n-        cx.global_init_block.add_assignment(None, lvalue, global1);\n+        global2.global_set_initializer_value(global1.get_address(None));\n         // TODO(antoyo): use global_set_initializer() when it will work.\n         global2\n     }"}, {"sha": "29b6e3313073534eb934ff19bb19e0483fac0f66", "filename": "src/context.rs", "status": "modified", "additions": 5, "deletions": 40, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=64c561dc2253463659a8ae93b3d265dda45c6ee9", "patch": "@@ -46,10 +46,6 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub current_func: RefCell<Option<Function<'gcc>>>,\n     pub normal_function_addresses: RefCell<FxHashSet<RValue<'gcc>>>,\n \n-    /// The function where globals are initialized.\n-    pub global_init_func: Function<'gcc>,\n-    pub global_init_block: Block<'gcc>,\n-\n     pub functions: RefCell<FxHashMap<String, Function<'gcc>>>,\n \n     pub tls_model: gccjit::TlsModel,\n@@ -89,23 +85,20 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub types_with_fields_to_set: RefCell<FxHashMap<Type<'gcc>, (Struct<'gcc>, TyAndLayout<'tcx>)>>,\n \n     /// Cache instances of monomorphic and polymorphic items\n-    pub instances: RefCell<FxHashMap<Instance<'tcx>, RValue<'gcc>>>,\n+    pub instances: RefCell<FxHashMap<Instance<'tcx>, LValue<'gcc>>>,\n+    /// Cache function instances of monomorphic and polymorphic items\n+    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, RValue<'gcc>>>,\n     /// Cache generated vtables\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n \n     /// Cache of emitted const globals (value -> global)\n     pub const_globals: RefCell<FxHashMap<RValue<'gcc>, RValue<'gcc>>>,\n \n-    pub init_argv_var: RefCell<String>,\n-    pub argv_initialized: Cell<bool>,\n-\n     /// Cache of constant strings,\n     pub const_cstr_cache: RefCell<FxHashMap<Symbol, LValue<'gcc>>>,\n \n     /// Cache of globals.\n     pub globals: RefCell<FxHashMap<String, RValue<'gcc>>>,\n-    // TODO(antoyo): remove global_names.\n-    pub global_names: RefCell<FxHashMap<RValue<'gcc>, String>>,\n \n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n@@ -118,16 +111,9 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     /// NOTE: a hack is used because the rustc API is not suitable to libgccjit and as such,\n     /// `const_undef()` returns struct as pointer so that they can later be assigned a value.\n     /// As such, this set remembers which of these pointers were returned by this function so that\n-    /// they can be derefered later.\n+    /// they can be deferenced later.\n     /// FIXME(antoyo): fix the rustc API to avoid having this hack.\n     pub structs_as_pointer: RefCell<FxHashSet<RValue<'gcc>>>,\n-\n-    /// Store the pointer of different types for safety.\n-    /// When casting the values back to their original types, check that they are indeed that type\n-    /// with these sets.\n-    /// FIXME(antoyo): remove when the API supports more types.\n-    #[cfg(debug_assertions)]\n-    lvalues: RefCell<FxHashSet<LValue<'gcc>>>,\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -180,10 +166,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             functions.insert(builtin.to_string(), context.get_builtin_function(builtin));\n         }\n \n-        let global_init_func = context.new_function(None, FunctionType::Exported, context.new_type::<()>(), &[],\n-            &format!(\"__gccGlobalInit{}\", unit_name(&codegen_unit)), false);\n-        let global_init_block = global_init_func.new_block(\"initial\");\n-\n         Self {\n             check_overflow,\n             codegen_unit,\n@@ -192,8 +174,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             current_func: RefCell::new(None),\n             normal_function_addresses: Default::default(),\n             functions: RefCell::new(functions),\n-            global_init_func,\n-            global_init_block,\n \n             tls_model,\n \n@@ -221,15 +201,11 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             double_type,\n \n             linkage: Cell::new(FunctionType::Internal),\n-            #[cfg(debug_assertions)]\n-            lvalues: Default::default(),\n             instances: Default::default(),\n+            function_instances: Default::default(),\n             vtables: Default::default(),\n             const_globals: Default::default(),\n-            init_argv_var: RefCell::new(String::new()),\n-            argv_initialized: Cell::new(false),\n             const_cstr_cache: Default::default(),\n-            global_names: Default::default(),\n             globals: Default::default(),\n             scalar_types: Default::default(),\n             types: Default::default(),\n@@ -244,24 +220,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         }\n     }\n \n-    pub fn lvalue_to_rvalue(&self, value: LValue<'gcc>) -> RValue<'gcc> {\n-        #[cfg(debug_assertions)]\n-        self.lvalues.borrow_mut().insert(value);\n-        unsafe { std::mem::transmute(value) }\n-    }\n-\n     pub fn rvalue_as_function(&self, value: RValue<'gcc>) -> Function<'gcc> {\n         let function: Function<'gcc> = unsafe { std::mem::transmute(value) };\n         debug_assert!(self.functions.borrow().values().find(|value| **value == function).is_some(),\n             \"{:?} ({:?}) is not a function\", value, value.get_type());\n         function\n     }\n \n-    pub fn rvalue_as_lvalue(&self, value: RValue<'gcc>) -> LValue<'gcc> {\n-        let lvalue: LValue<'gcc> = unsafe { std::mem::transmute(value) };\n-        lvalue\n-    }\n-\n     pub fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }"}, {"sha": "4d3b4f04badec86dd9149a9421036a3c81e52518", "filename": "src/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo.rs?ref=64c561dc2253463659a8ae93b3d265dda45c6ee9", "patch": "@@ -1,11 +1,9 @@\n-use gccjit::{FunctionType, RValue};\n+use gccjit::RValue;\n use rustc_codegen_ssa::mir::debuginfo::{FunctionDebugContext, VariableKind};\n-use rustc_codegen_ssa::traits::{BuilderMethods, DebugInfoBuilderMethods, DebugInfoMethods};\n-use rustc_middle::middle::cstore::CrateDepKind;\n+use rustc_codegen_ssa::traits::{DebugInfoBuilderMethods, DebugInfoMethods};\n use rustc_middle::mir;\n use rustc_middle::ty::{Instance, Ty};\n use rustc_span::{SourceFile, Span, Symbol};\n-use rustc_span::def_id::LOCAL_CRATE;\n use rustc_target::abi::Size;\n use rustc_target::abi::call::FnAbi;\n \n@@ -20,25 +18,6 @@ impl<'a, 'gcc, 'tcx> DebugInfoBuilderMethods for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self) {\n-        // TODO(antoyo): replace with gcc_jit_context_new_global_with_initializer() if it's added:\n-        // https://gcc.gnu.org/pipermail/jit/2020q3/001225.html\n-        //\n-        // Call the function to initialize global values here.\n-        // We assume this is only called for the main function.\n-        use std::iter;\n-\n-        for crate_num in self.cx.tcx.crates(()).iter().copied().chain(iter::once(LOCAL_CRATE)) {\n-            // FIXME(antoyo): better way to find if a crate is of proc-macro type?\n-            if crate_num == LOCAL_CRATE || self.cx.tcx.dep_kind(crate_num) != CrateDepKind::MacrosOnly {\n-                // NOTE: proc-macro crates are not included in the executable, so don't call their\n-                // initialization routine.\n-                let initializer_name = format!(\"__gccGlobalCrateInit{}\", self.cx.tcx.crate_name(crate_num));\n-                let codegen_init_func = self.context.new_function(None, FunctionType::Extern, self.context.new_type::<()>(), &[],\n-                initializer_name, false);\n-                self.llbb().add_eval(None, self.context.new_call(None, codegen_init_func, &[]));\n-            }\n-        }\n-\n         // TODO(antoyo): insert reference to gdb debug scripts section global.\n     }\n "}, {"sha": "b43f68f878d7a3207885cbe4eecb9c1e21caeaa7", "filename": "src/declare.rs", "status": "modified", "additions": 18, "deletions": 67, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdeclare.rs?ref=64c561dc2253463659a8ae93b3d265dda45c6ee9", "patch": "@@ -7,10 +7,9 @@ use rustc_target::abi::call::FnAbi;\n use crate::abi::FnAbiGccExt;\n use crate::context::{CodegenCx, unit_name};\n use crate::intrinsic::llvm;\n-use crate::mangled_std_symbols::{ARGV_INIT_ARRAY, ARGV_INIT_WRAPPER};\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n-    pub fn get_or_insert_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> RValue<'gcc> {\n+    pub fn get_or_insert_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n         if self.globals.borrow().contains_key(name) {\n             let typ = self.globals.borrow().get(name).expect(\"global\").get_type();\n             let global = self.context.new_global(None, GlobalKind::Imported, typ, name);\n@@ -20,7 +19,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             if let Some(link_section) = link_section {\n                 global.set_link_section(&link_section.as_str());\n             }\n-            global.get_address(None)\n+            global\n         }\n         else {\n             self.declare_global(name, ty, is_tls, link_section)\n@@ -34,13 +33,10 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         self.context.new_global(None, GlobalKind::Exported, ty, &name)\n     }\n \n-    pub fn declare_global_with_linkage(&self, name: &str, ty: Type<'gcc>, linkage: GlobalKind) -> RValue<'gcc> {\n-        let global = self.context.new_global(None, linkage, ty, name)\n-            .get_address(None);\n-        self.globals.borrow_mut().insert(name.to_string(), global);\n-        // NOTE: global seems to only be global in a module. So save the name instead of the value\n-        // to import it later.\n-        self.global_names.borrow_mut().insert(global, name.to_string());\n+    pub fn declare_global_with_linkage(&self, name: &str, ty: Type<'gcc>, linkage: GlobalKind) -> LValue<'gcc> {\n+        let global = self.context.new_global(None, linkage, ty, name);\n+        let global_address = global.get_address(None);\n+        self.globals.borrow_mut().insert(name.to_string(), global_address);\n         global\n     }\n \n@@ -51,31 +47,23 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         unsafe { std::mem::transmute(func) }\n     }\n \n-    pub fn declare_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> RValue<'gcc> {\n-        // FIXME(antoyo): correctly support global variable initialization.\n-        if name.starts_with(ARGV_INIT_ARRAY) {\n-            // NOTE: hack to avoid having to update the names in mangled_std_symbols: we save the\n-            // name of the variable now to actually declare it later.\n-            *self.init_argv_var.borrow_mut() = name.to_string();\n-\n-            let global = self.context.new_global(None, GlobalKind::Imported, ty, name);\n-            if let Some(link_section) = link_section {\n-                global.set_link_section(&link_section.as_str());\n-            }\n-            return global.get_address(None);\n-        }\n+    pub fn declare_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n         let global = self.context.new_global(None, GlobalKind::Exported, ty, name);\n         if is_tls {\n             global.set_tls_model(self.tls_model);\n         }\n         if let Some(link_section) = link_section {\n             global.set_link_section(&link_section.as_str());\n         }\n-        let global = global.get_address(None);\n-        self.globals.borrow_mut().insert(name.to_string(), global);\n-        // NOTE: global seems to only be global in a module. So save the name instead of the value\n-        // to import it later.\n-        self.global_names.borrow_mut().insert(global, name.to_string());\n+        let global_address = global.get_address(None);\n+        self.globals.borrow_mut().insert(name.to_string(), global_address);\n+        global\n+    }\n+\n+    pub fn declare_private_global(&self, name: &str, ty: Type<'gcc>) -> LValue<'gcc> {\n+        let global = self.context.new_global(None, GlobalKind::Internal, ty, name);\n+        let global_address = global.get_address(None);\n+        self.globals.borrow_mut().insert(name.to_string(), global_address);\n         global\n     }\n \n@@ -94,51 +82,14 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n \n     pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> RValue<'gcc> {\n-        // NOTE: hack to avoid having to update the names in mangled_std_symbols: we found the name\n-        // of the variable earlier, so we declare it now.\n-        // Since we don't correctly support initializers yet, we initialize this variable manually\n-        // for now.\n-        if name.starts_with(ARGV_INIT_WRAPPER) && !self.argv_initialized.get() {\n-            let global_name = &*self.init_argv_var.borrow();\n-            let return_type = self.type_void();\n-            let params = [\n-                self.context.new_parameter(None, self.int_type, \"argc\"),\n-                self.context.new_parameter(None, self.u8_type.make_pointer().make_pointer(), \"argv\"),\n-                self.context.new_parameter(None, self.u8_type.make_pointer().make_pointer(), \"envp\"),\n-            ];\n-            let function = self.context.new_function(None, FunctionType::Extern, return_type, &params, name, false);\n-            let initializer = function.get_address(None);\n-\n-            let param_types = [\n-                self.int_type,\n-                self.u8_type.make_pointer().make_pointer(),\n-                self.u8_type.make_pointer().make_pointer(),\n-            ];\n-            let ty = self.context.new_function_pointer_type(None, return_type, &param_types, false);\n-\n-            let global = self.context.new_global(None, GlobalKind::Exported, ty, global_name);\n-            global.set_link_section(\".init_array.00099\");\n-            global.global_set_initializer_value(initializer);\n-            let global = global.get_address(None);\n-            self.globals.borrow_mut().insert(global_name.to_string(), global);\n-            // NOTE: global seems to only be global in a module. So save the name instead of the value\n-            // to import it later.\n-            self.global_names.borrow_mut().insert(global, global_name.to_string());\n-            self.argv_initialized.set(true);\n-        }\n         let (return_type, params, variadic) = fn_abi.gcc_type(self);\n         let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic);\n         // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n         unsafe { std::mem::transmute(func) }\n     }\n \n-    pub fn define_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> Option<RValue<'gcc>> {\n-        Some(self.get_or_insert_global(name, ty, is_tls, link_section))\n-    }\n-\n-    pub fn define_private_global(&self, ty: Type<'gcc>) -> RValue<'gcc> {\n-        let global = self.declare_unnamed_global(ty);\n-        global.get_address(None)\n+    pub fn define_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n+        self.get_or_insert_global(name, ty, is_tls, link_section)\n     }\n \n     pub fn get_declared_value(&self, name: &str) -> Option<RValue<'gcc>> {"}, {"sha": "3c3a3568228c6ad4a6907f585d3a010a9707eb60", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=64c561dc2253463659a8ae93b3d265dda45c6ee9", "patch": "@@ -43,15 +43,14 @@ mod coverageinfo;\n mod debuginfo;\n mod declare;\n mod intrinsic;\n-mod mangled_std_symbols;\n mod mono_item;\n mod type_;\n mod type_of;\n \n use std::any::Any;\n use std::sync::Arc;\n \n-use gccjit::{Block, Context, FunctionType, OptimizationLevel};\n+use gccjit::{Context, OptimizationLevel};\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, ModuleCodegen};\n use rustc_codegen_ssa::base::codegen_crate;\n@@ -69,8 +68,6 @@ use rustc_session::Session;\n use rustc_span::Symbol;\n use rustc_span::fatal_error::FatalError;\n \n-use crate::context::unit_name;\n-\n pub struct PrintOnPanic<F: Fn() -> String>(pub F);\n \n impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n@@ -203,6 +200,7 @@ impl WriteBackendMethods for GccCodegenBackend {\n     fn run_fat_lto(_cgcx: &CodegenContext<Self>, mut modules: Vec<FatLTOInput<Self>>, _cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>) -> Result<LtoModuleCodegen<Self>, FatalError> {\n         // TODO(antoyo): implement LTO by sending -flto to libgccjit and adding the appropriate gcc linker plugins.\n         // NOTE: implemented elsewhere.\n+        // TODO: what is implemented elsewhere ^ ?\n         let module =\n             match modules.remove(0) {\n                 FatLTOInput::InMemory(module) => module,\n@@ -273,15 +271,6 @@ fn to_gcc_opt_level(optlevel: Option<OptLevel>) -> OptimizationLevel {\n     }\n }\n \n-fn create_function_calling_initializers<'gcc, 'tcx>(tcx: TyCtxt<'tcx>, context: &Context<'gcc>, block: Block<'gcc>) {\n-    let codegen_units = tcx.collect_and_partition_mono_items(()).1;\n-    for codegen_unit in codegen_units {\n-        let codegen_init_func = context.new_function(None, FunctionType::Extern, context.new_type::<()>(), &[],\n-            &format!(\"__gccGlobalInit{}\", unit_name(&codegen_unit)), false);\n-        block.add_eval(None, context.new_call(None, codegen_init_func, &[]));\n-    }\n-}\n-\n fn handle_native(name: &str) -> &str {\n     if name != \"native\" {\n         return name;"}, {"sha": "b0c3f214d66c15510342df74221e469054ddb619", "filename": "src/mangled_std_symbols.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e7e822f39fca4ccf146a71dbb1098b76ecea1af/src%2Fmangled_std_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e7e822f39fca4ccf146a71dbb1098b76ecea1af/src%2Fmangled_std_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmangled_std_symbols.rs?ref=4e7e822f39fca4ccf146a71dbb1098b76ecea1af", "patch": "@@ -1,4 +0,0 @@\n-pub const ARGV_INIT_ARRAY: &str = \"_ZN3std3sys4unix4args3imp15ARGV_INIT_ARRAY\";\n-pub const ARGV_INIT_WRAPPER: &str = \"_ZN3std3sys4unix4args3imp15ARGV_INIT_ARRAY12init_wrapper\";\n-pub const ARGC: &str = \"_ZN3std3sys4unix4args3imp4ARGC\";\n-pub const ARGV: &str = \"_ZN3std3sys4unix4args3imp4ARGV\";"}, {"sha": "a34c68a4e22d39733cdd21b810d50d335c1eb4ea", "filename": "src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c561dc2253463659a8ae93b3d265dda45c6ee9/src%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_item.rs?ref=64c561dc2253463659a8ae93b3d265dda45c6ee9", "patch": "@@ -18,12 +18,7 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         let gcc_type = self.layout_of(ty).gcc_type(self, true);\n \n         let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-        let global = self.define_global(symbol_name, gcc_type, is_tls, attrs.link_section).unwrap_or_else(|| {\n-            self.sess().span_fatal(\n-                self.tcx.def_span(def_id),\n-                &format!(\"symbol `{}` is already defined\", symbol_name),\n-            )\n-        });\n+        let global = self.define_global(symbol_name, gcc_type, is_tls, attrs.link_section);\n \n         // TODO(antoyo): set linkage and visibility.\n         self.instances.borrow_mut().insert(instance, global);"}]}