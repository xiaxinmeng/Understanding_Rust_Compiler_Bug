{"sha": "e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNjgzZjUwYzAwMjk3ZTk5MDhhZTAyOGZhMWQ0MWI5YTUyYTZmNmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-30T05:36:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-30T05:36:25Z"}, "message": "auto merge of #15030 : sfackler/rust/partial-cmp, r=huonw\n\nI ended up altering the semantics of Json's PartialOrd implementation.\r\nIt used to be the case that Null < Null, but I can't think of any reason\r\nfor an ordering other than the default one so I just switched it over to\r\nusing the derived implementation.\r\n\r\nThis also fixes broken `PartialOrd` implementations for `Vec` and\r\n`TreeMap`.\r\n\r\n# Note\r\nThis isn't ready to merge yet since libcore tests are broken as you end up with 2 versions of `Option`. The rest should be reviewable though.\r\n\r\nRFC: 0028-partial-cmp", "tree": {"sha": "e1f34ea8fa1e5c887ed724e41a029cab323ad455", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1f34ea8fa1e5c887ed724e41a029cab323ad455"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "html_url": "https://github.com/rust-lang/rust/commit/e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e25eb6b223d86047dc807a167f3dd4bf492bbf41", "url": "https://api.github.com/repos/rust-lang/rust/commits/e25eb6b223d86047dc807a167f3dd4bf492bbf41", "html_url": "https://github.com/rust-lang/rust/commit/e25eb6b223d86047dc807a167f3dd4bf492bbf41"}, {"sha": "55cae0a094bbdcd0e9d5e697ce4f38cbd783bbc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/55cae0a094bbdcd0e9d5e697ce4f38cbd783bbc7", "html_url": "https://github.com/rust-lang/rust/commit/55cae0a094bbdcd0e9d5e697ce4f38cbd783bbc7"}], "stats": {"total": 510, "additions": 346, "deletions": 164}, "files": [{"sha": "addec396bbef8715d14e88ea237671424b1621b2", "filename": "src/liballoc/owned.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Fliballoc%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Fliballoc%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fowned.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -18,6 +18,7 @@ use core::fmt;\n use core::intrinsics;\n use core::kinds::Send;\n use core::mem;\n+use core::option::Option;\n use core::raw::TraitObject;\n use core::result::{Ok, Err, Result};\n \n@@ -64,6 +65,10 @@ impl<T:PartialEq> PartialEq for Box<T> {\n     fn ne(&self, other: &Box<T>) -> bool { *(*self) != *(*other) }\n }\n impl<T:PartialOrd> PartialOrd for Box<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n+        (**self).partial_cmp(*other)\n+    }\n     #[inline]\n     fn lt(&self, other: &Box<T>) -> bool { *(*self) < *(*other) }\n     #[inline]"}, {"sha": "83cc4a0b6620df31d0a83f73a03b7ba2ff92b9b4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -170,6 +170,11 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n impl<T: Eq> Eq for Rc<T> {}\n \n impl<T: PartialOrd> PartialOrd for Rc<T> {\n+    #[inline(always)]\n+    fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> {\n+        (**self).partial_cmp(&**other)\n+    }\n+\n     #[inline(always)]\n     fn lt(&self, other: &Rc<T>) -> bool { **self < **other }\n "}, {"sha": "92abfaad3483301016fa4449e51221967446f2c9", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -107,8 +107,8 @@ impl<K: Ord, V: Eq> PartialEq for BTree<K, V> {\n impl<K: Ord, V: Eq> Eq for BTree<K, V> {}\n \n impl<K: Ord, V: Eq> PartialOrd for BTree<K, V> {\n-    fn lt(&self, other: &BTree<K, V>) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &BTree<K, V>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -229,8 +229,8 @@ impl<K: Ord, V: Eq> PartialEq for Node<K, V> {\n impl<K: Ord, V: Eq> Eq for Node<K, V> {}\n \n impl<K: Ord, V: Eq> PartialOrd for Node<K, V> {\n-    fn lt(&self, other: &Node<K, V>) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &Node<K, V>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -408,8 +408,8 @@ impl<K: Ord, V: Eq> PartialEq for Leaf<K, V> {\n impl<K: Ord, V: Eq> Eq for Leaf<K, V> {}\n \n impl<K: Ord, V: Eq> PartialOrd for Leaf<K, V> {\n-    fn lt(&self, other: &Leaf<K, V>) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &Leaf<K, V>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -638,8 +638,8 @@ impl<K: Ord, V: Eq> PartialEq for Branch<K, V> {\n impl<K: Ord, V: Eq> Eq for Branch<K, V> {}\n \n impl<K: Ord, V: Eq> PartialOrd for Branch<K, V> {\n-    fn lt(&self, other: &Branch<K, V>) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &Branch<K, V>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -706,8 +706,8 @@ impl<K: Ord, V: Eq> PartialEq for LeafElt<K, V> {\n impl<K: Ord, V: Eq> Eq for LeafElt<K, V> {}\n \n impl<K: Ord, V: Eq> PartialOrd for LeafElt<K, V> {\n-    fn lt(&self, other: &LeafElt<K, V>) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &LeafElt<K, V>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -755,8 +755,8 @@ impl<K: Ord, V: Eq> PartialEq for BranchElt<K, V>{\n impl<K: Ord, V: Eq> Eq for BranchElt<K, V>{}\n \n impl<K: Ord, V: Eq> PartialOrd for BranchElt<K, V> {\n-    fn lt(&self, other: &BranchElt<K, V>) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &BranchElt<K, V>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n "}, {"sha": "4114c8cb1c4ddc8b7a5a489de9ea5ee1f7a8c518", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -595,17 +595,8 @@ impl<A: PartialEq> PartialEq for DList<A> {\n }\n \n impl<A: PartialOrd> PartialOrd for DList<A> {\n-    fn lt(&self, other: &DList<A>) -> bool {\n-        iter::order::lt(self.iter(), other.iter())\n-    }\n-    fn le(&self, other: &DList<A>) -> bool {\n-        iter::order::le(self.iter(), other.iter())\n-    }\n-    fn gt(&self, other: &DList<A>) -> bool {\n-        iter::order::gt(self.iter(), other.iter())\n-    }\n-    fn ge(&self, other: &DList<A>) -> bool {\n-        iter::order::ge(self.iter(), other.iter())\n+    fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> {\n+        iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n "}, {"sha": "b5424d1683fca566bba7a5296876c36c10113cea", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -572,8 +572,8 @@ impl<'a> Eq for MaybeOwned<'a> {}\n \n impl<'a> PartialOrd for MaybeOwned<'a> {\n     #[inline]\n-    fn lt(&self, other: &MaybeOwned) -> bool {\n-        self.as_slice().lt(&other.as_slice())\n+    fn partial_cmp(&self, other: &MaybeOwned) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n "}, {"sha": "becceffe6d0270254fe0017f0c3be5e4cee6abb9", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -56,23 +56,11 @@ impl<K: PartialEq + Ord, V: PartialEq> PartialEq for TreeMap<K, V> {\n     }\n }\n \n-// Lexicographical comparison\n-fn lt<K: PartialOrd + Ord, V: PartialOrd>(a: &TreeMap<K, V>,\n-                                 b: &TreeMap<K, V>) -> bool {\n-    // the Zip iterator is as long as the shortest of a and b.\n-    for ((key_a, value_a), (key_b, value_b)) in a.iter().zip(b.iter()) {\n-        if *key_a < *key_b { return true; }\n-        if *key_a > *key_b { return false; }\n-        if *value_a < *value_b { return true; }\n-        if *value_a > *value_b { return false; }\n-    }\n-\n-    a.len() < b.len()\n-}\n-\n-impl<K: PartialOrd + Ord, V: PartialOrd> PartialOrd for TreeMap<K, V> {\n+impl<K: Ord, V: PartialOrd> PartialOrd for TreeMap<K, V> {\n     #[inline]\n-    fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n+    fn partial_cmp(&self, other: &TreeMap<K, V>) -> Option<Ordering> {\n+        iter::order::partial_cmp(self.iter(), other.iter())\n+    }\n }\n \n impl<K: Ord + Show, V: Show> Show for TreeMap<K, V> {\n@@ -568,9 +556,11 @@ impl<T: PartialEq + Ord> PartialEq for TreeSet<T> {\n     fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n }\n \n-impl<T: PartialOrd + Ord> PartialOrd for TreeSet<T> {\n+impl<T: Ord> PartialOrd for TreeSet<T> {\n     #[inline]\n-    fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n+    fn partial_cmp(&self, other: &TreeSet<T>) -> Option<Ordering> {\n+        self.map.partial_cmp(&other.map)\n+    }\n }\n \n impl<T: Ord + Show> Show for TreeSet<T> {"}, {"sha": "2ffc168f82c0eef4b4d77244a873ed3cd327d1a6", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -389,8 +389,8 @@ impl<T: PartialEq> PartialEq for Vec<T> {\n \n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n-    fn lt(&self, other: &Vec<T>) -> bool {\n-        self.as_slice() < other.as_slice()\n+    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n+        self.as_slice().partial_cmp(&other.as_slice())\n     }\n }\n "}, {"sha": "8696d385c44884d6d257b03818de2360e7f574c3", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 72, "deletions": 9, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -37,6 +37,10 @@\n //! assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n //! ```\n \n+use option::{Option, Some};\n+#[cfg(stage0)]\n+use option::None;\n+\n /// Trait for values that can be compared for equality and inequality.\n ///\n /// This trait allows for partial equality, for types that do not have an\n@@ -127,7 +131,9 @@ impl Ord for Ordering {\n \n impl PartialOrd for Ordering {\n     #[inline]\n-    fn lt(&self, other: &Ordering) -> bool { (*self as int) < (*other as int) }\n+    fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n+        (*self as int).partial_cmp(&(*other as int))\n+    }\n }\n \n /// Combine orderings, lexically.\n@@ -145,7 +151,7 @@ pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n \n /// Trait for values that can be compared for a sort-order.\n ///\n-/// PartialOrd only requires implementation of the `lt` method,\n+/// PartialOrd only requires implementation of the `partial_cmp` method,\n /// with the others generated from default implementations.\n ///\n /// However it remains possible to implement the others separately for types\n@@ -154,20 +160,57 @@ pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n /// 5.11).\n #[lang=\"ord\"]\n pub trait PartialOrd: PartialEq {\n+    /// This method returns an ordering between `self` and `other` values\n+    /// if one exists.\n+    #[cfg(stage0)]\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        match (!self.lt(other), !other.lt(self)) {\n+            (false, false) => None,\n+            (false, true) => Some(Less),\n+            (true, false) => Some(Greater),\n+            (true, true) => Some(Equal),\n+        }\n+    }\n+\n+    /// This method returns an ordering between `self` and `other` values\n+    /// if one exists.\n+    #[cfg(not(stage0))]\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering>;\n+\n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n-    fn lt(&self, other: &Self) -> bool;\n+    fn lt(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Less) => true,\n+            _ => false,\n+        }\n+    }\n \n     /// This method tests less than or equal to (`<=`).\n     #[inline]\n-    fn le(&self, other: &Self) -> bool { !other.lt(self) }\n+    fn le(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Less) | Some(Equal) => true,\n+            _ => false,\n+        }\n+    }\n \n     /// This method tests greater than (`>`).\n     #[inline]\n-    fn gt(&self, other: &Self) -> bool {  other.lt(self) }\n+    fn gt(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Greater) => true,\n+            _ => false,\n+        }\n+    }\n \n     /// This method tests greater than or equal to (`>=`).\n     #[inline]\n-    fn ge(&self, other: &Self) -> bool { !self.lt(other) }\n+    fn ge(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Greater) | Some(Equal) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n /// The equivalence relation. Two values may be equivalent even if they are\n@@ -195,6 +238,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n mod impls {\n     use cmp::{PartialOrd, Ord, PartialEq, Eq, Ordering,\n               Less, Greater, Equal};\n+    use option::{Option, Some, None};\n \n     macro_rules! eq_impl(\n         ($($t:ty)*) => ($(\n@@ -227,6 +271,15 @@ mod impls {\n     macro_rules! ord_impl(\n         ($($t:ty)*) => ($(\n             impl PartialOrd for $t {\n+                #[inline]\n+                fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n+                    match (self <= other, self >= other) {\n+                        (false, false) => None,\n+                        (false, true) => Some(Greater),\n+                        (true, false) => Some(Less),\n+                        (true, true) => Some(Equal),\n+                    }\n+                }\n                 #[inline]\n                 fn lt(&self, other: &$t) -> bool { (*self) < (*other) }\n                 #[inline]\n@@ -241,13 +294,15 @@ mod impls {\n \n     impl PartialOrd for () {\n         #[inline]\n-        fn lt(&self, _other: &()) -> bool { false }\n+        fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n+            Some(Equal)\n+        }\n     }\n \n     impl PartialOrd for bool {\n         #[inline]\n-        fn lt(&self, other: &bool) -> bool {\n-            (*self as u8) < (*other as u8)\n+        fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n+            (*self as u8).partial_cmp(&(*other as u8))\n         }\n     }\n \n@@ -288,6 +343,10 @@ mod impls {\n         fn ne(&self, other: & &'a T) -> bool { *(*self) != *(*other) }\n     }\n     impl<'a, T: PartialOrd> PartialOrd for &'a T {\n+        #[inline]\n+        fn partial_cmp(&self, other: &&'a T) -> Option<Ordering> {\n+            (**self).partial_cmp(*other)\n+        }\n         #[inline]\n         fn lt(&self, other: & &'a T) -> bool { *(*self) < *(*other) }\n         #[inline]\n@@ -311,6 +370,10 @@ mod impls {\n         fn ne(&self, other: &&'a mut T) -> bool { **self != *(*other) }\n     }\n     impl<'a, T: PartialOrd> PartialOrd for &'a mut T {\n+        #[inline]\n+        fn partial_cmp(&self, other: &&'a mut T) -> Option<Ordering> {\n+            (**self).partial_cmp(*other)\n+        }\n         #[inline]\n         fn lt(&self, other: &&'a mut T) -> bool { **self < **other }\n         #[inline]"}, {"sha": "5895d871dbe18e2bb3467f72c09f1fb630e3b9c0", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -2183,7 +2183,7 @@ impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};\n-    use option::{Some, None};\n+    use option::{Option, Some, None};\n     use super::Iterator;\n \n     /// Compare `a` and `b` for equality using `Eq`\n@@ -2212,6 +2212,22 @@ pub mod order {\n         }\n     }\n \n+    /// Order `a` and `b` lexicographically using `PartialOrd`\n+    pub fn partial_cmp<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S)\n+            -> Option<cmp::Ordering> {\n+        loop {\n+            match (a.next(), b.next()) {\n+                (None, None) => return Some(cmp::Equal),\n+                (None, _   ) => return Some(cmp::Less),\n+                (_   , None) => return Some(cmp::Greater),\n+                (Some(x), Some(y)) => match x.partial_cmp(&y) {\n+                    Some(cmp::Equal) => (),\n+                    non_eq => return non_eq,\n+                },\n+            }\n+        }\n+    }\n+\n     /// Compare `a` and `b` for equality (Using partial equality, `PartialEq`)\n     pub fn eq<A: PartialEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n         loop {"}, {"sha": "093591cd796d1cf4026605f338da2be55a87af46", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -93,7 +93,7 @@ use intrinsics;\n use iter::{range, Iterator};\n use option::{Some, None, Option};\n \n-use cmp::{PartialEq, Eq, PartialOrd, Equiv};\n+use cmp::{PartialEq, Eq, PartialOrd, Equiv, Ordering, Less, Equal, Greater};\n \n /// Create a null pointer.\n ///\n@@ -488,11 +488,51 @@ mod externfnpointers {\n \n // Comparison for pointers\n impl<T> PartialOrd for *const T {\n+    #[inline]\n+    fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n+        if self < other {\n+            Some(Less)\n+        } else if self == other {\n+            Some(Equal)\n+        } else {\n+            Some(Greater)\n+        }\n+    }\n+\n     #[inline]\n     fn lt(&self, other: &*const T) -> bool { *self < *other }\n+\n+    #[inline]\n+    fn le(&self, other: &*const T) -> bool { *self <= *other }\n+\n+    #[inline]\n+    fn gt(&self, other: &*const T) -> bool { *self > *other }\n+\n+    #[inline]\n+    fn ge(&self, other: &*const T) -> bool { *self >= *other }\n }\n \n impl<T> PartialOrd for *mut T {\n+    #[inline]\n+    fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {\n+        if self < other {\n+            Some(Less)\n+        } else if self == other {\n+            Some(Equal)\n+        } else {\n+            Some(Greater)\n+        }\n+    }\n+\n     #[inline]\n     fn lt(&self, other: &*mut T) -> bool { *self < *other }\n+\n+    #[inline]\n+    fn le(&self, other: &*mut T) -> bool { *self <= *other }\n+\n+    #[inline]\n+    fn gt(&self, other: &*mut T) -> bool { *self > *other }\n+\n+    #[inline]\n+    fn ge(&self, other: &*mut T) -> bool { *self >= *other }\n }"}, {"sha": "a9e7efdf05a5ada6177858be6609b33f093ee568", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -253,6 +253,7 @@ pub mod traits {\n     use cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering, Equiv};\n     use iter::order;\n     use collections::Collection;\n+    use option::Option;\n \n     impl<'a,T:PartialEq> PartialEq for &'a [T] {\n         fn eq(&self, other: & &'a [T]) -> bool {\n@@ -279,6 +280,11 @@ pub mod traits {\n     }\n \n     impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n+        #[inline]\n+        fn partial_cmp(&self, other: &&'a [T]) -> Option<Ordering> {\n+            order::partial_cmp(self.iter(), other.iter())\n+        }\n+        #[inline]\n         fn lt(&self, other: & &'a [T]) -> bool {\n             order::lt(self.iter(), other.iter())\n         }"}, {"sha": "de23e04393be1bb99e22a3c66d2a0c79d94160e4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -931,7 +931,7 @@ pub mod traits {\n     use cmp::{Ord, Ordering, Less, Equal, Greater, PartialEq, PartialOrd, Equiv, Eq};\n     use collections::Collection;\n     use iter::Iterator;\n-    use option::{Some, None};\n+    use option::{Option, Some, None};\n     use str::{Str, StrSlice, eq_slice};\n \n     impl<'a> Ord for &'a str {\n@@ -962,7 +962,9 @@ pub mod traits {\n \n     impl<'a> PartialOrd for &'a str {\n         #[inline]\n-        fn lt(&self, other: & &'a str) -> bool { self.cmp(other) == Less }\n+        fn partial_cmp(&self, other: &&'a str) -> Option<Ordering> {\n+            Some(self.cmp(other))\n+        }\n     }\n \n     impl<'a, S: Str> Equiv<S> for &'a str {"}, {"sha": "0e3722894bc467771f52af3266c888691733581a", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -64,6 +64,7 @@\n use clone::Clone;\n use cmp::*;\n use default::Default;\n+use option::{Option, Some};\n \n // macro for implementing n-ary tuple functions and operations\n macro_rules! tuple_impls {\n@@ -125,6 +126,10 @@ macro_rules! tuple_impls {\n             impl<$($T:Eq),+> Eq for ($($T,)+) {}\n \n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n+                #[inline]\n+                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n+                    lexical_partial_cmp!($(self.$refN(), other.$refN()),+)\n+                }\n                 #[inline]\n                 fn lt(&self, other: &($($T,)+)) -> bool {\n                     lexical_ord!(lt, $(self.$refN(), other.$refN()),+)\n@@ -172,6 +177,16 @@ macro_rules! lexical_ord {\n     ($rel: ident, $a:expr, $b:expr) => { (*$a) . $rel ($b) };\n }\n \n+macro_rules! lexical_partial_cmp {\n+    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n+        match ($a).partial_cmp($b) {\n+            Some(Equal) => lexical_partial_cmp!($($rest_a, $rest_b),+),\n+            ordering   => ordering\n+        }\n+    };\n+    ($a:expr, $b:expr) => { ($a).partial_cmp($b) };\n+}\n+\n macro_rules! lexical_cmp {\n     ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n         match ($a).cmp($b) {"}, {"sha": "86b5ffece41033c7a8b851a637b2490c4b2ccee9", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -707,8 +707,8 @@ fn test_range() {\n     }\n \n     impl PartialOrd for Foo {\n-        fn lt(&self, _: &Foo) -> bool {\n-            false\n+        fn partial_cmp(&self, _: &Foo) -> Option<Ordering> {\n+            None\n         }\n     }\n "}, {"sha": "bd19f19cec6b2f86a9a1beee94f87b60c3720eab", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -73,8 +73,8 @@ impl<'a, T: PartialEq> PartialEq for MaybeOwnedVector<'a, T> {\n impl<'a, T: Eq> Eq for MaybeOwnedVector<'a, T> {}\n \n impl<'a, T: PartialOrd> PartialOrd for MaybeOwnedVector<'a, T> {\n-    fn lt(&self, other: &MaybeOwnedVector<T>) -> bool {\n-        self.as_slice().lt(&other.as_slice())\n+    fn partial_cmp(&self, other: &MaybeOwnedVector<T>) -> Option<Ordering> {\n+        self.as_slice().partial_cmp(&other.as_slice())\n     }\n }\n "}, {"sha": "cc3753def59f4cc2a6ed98d1080f4a36fc33ae28", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -91,8 +91,8 @@ impl Eq for BigUint {}\n \n impl PartialOrd for BigUint {\n     #[inline]\n-    fn lt(&self, other: &BigUint) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &BigUint) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n \n@@ -816,8 +816,8 @@ impl Eq for BigInt {}\n \n impl PartialOrd for BigInt {\n     #[inline]\n-    fn lt(&self, other: &BigInt) -> bool {\n-        self.cmp(other) == Less\n+    fn partial_cmp(&self, other: &BigInt) -> Option<Ordering> {\n+        Some(self.cmp(other))\n     }\n }\n "}, {"sha": "9a455edf2c086e8d034b5c178847fda15b556ae5", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -193,7 +193,8 @@ macro_rules! cmp_impl {\n     };\n }\n cmp_impl!(impl PartialEq, eq, ne)\n-cmp_impl!(impl PartialOrd, lt, gt, le, ge)\n+cmp_impl!(impl PartialOrd, lt -> bool, gt -> bool, le -> bool, ge -> bool,\n+          partial_cmp -> Option<cmp::Ordering>)\n cmp_impl!(impl Eq, )\n cmp_impl!(impl Ord, cmp -> cmp::Ordering)\n "}, {"sha": "675b2e507b3e9073448bfc99dc6369c53b39ed27", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -55,12 +55,12 @@ pub enum Identifier {\n \n impl cmp::PartialOrd for Identifier {\n     #[inline]\n-    fn lt(&self, other: &Identifier) -> bool {\n+    fn partial_cmp(&self, other: &Identifier) -> Option<Ordering> {\n         match (self, other) {\n-            (&Numeric(a), &Numeric(b)) => a < b,\n-            (&Numeric(_), _) => true,\n-            (&AlphaNumeric(ref a), &AlphaNumeric(ref b)) => *a < *b,\n-            (&AlphaNumeric(_), _) => false\n+            (&Numeric(a), &Numeric(ref b)) => a.partial_cmp(b),\n+            (&Numeric(_), _) => Some(Less),\n+            (&AlphaNumeric(ref a), &AlphaNumeric(ref b)) => a.partial_cmp(b),\n+            (&AlphaNumeric(_), _) => Some(Greater)\n         }\n     }\n }\n@@ -130,30 +130,31 @@ impl cmp::PartialEq for Version {\n \n impl cmp::PartialOrd for Version {\n     #[inline]\n-    fn lt(&self, other: &Version) -> bool {\n-\n-        self.major < other.major ||\n-\n-            (self.major == other.major &&\n-             self.minor < other.minor) ||\n-\n-            (self.major == other.major &&\n-             self.minor == other.minor &&\n-             self.patch < other.patch) ||\n-\n-            (self.major == other.major &&\n-             self.minor == other.minor &&\n-             self.patch == other.patch &&\n-             // NB: semver spec says 0.0.0-pre < 0.0.0\n-             // but the version of ord defined for vec\n-             // says that [] < [pre], so we alter it\n-             // here.\n-             (match (self.pre.len(), other.pre.len()) {\n-                 (0, 0) => false,\n-                 (0, _) => false,\n-                 (_, 0) => true,\n-                 (_, _) => self.pre < other.pre\n-             }))\n+    fn partial_cmp(&self, other: &Version) -> Option<Ordering> {\n+        match self.major.partial_cmp(&other.major) {\n+            Some(Equal) => {}\n+            r => return r,\n+        }\n+\n+        match self.minor.partial_cmp(&other.minor) {\n+            Some(Equal) => {}\n+            r => return r,\n+        }\n+\n+        match self.patch.partial_cmp(&other.patch) {\n+            Some(Equal) => {}\n+            r => return r,\n+        }\n+\n+        // NB: semver spec says 0.0.0-pre < 0.0.0\n+        // but the version of ord defined for vec\n+        // says that [] < [pre] so we alter it here\n+        match (self.pre.len(), other.pre.len()) {\n+            (0, 0) => Some(Equal),\n+            (0, _) => Some(Greater),\n+            (_, 0) => Some(Less),\n+            (_, _) => self.pre.partial_cmp(&other.pre)\n+        }\n     }\n }\n "}, {"sha": "9f5f020152f9e17d8bebf1fe9a2654dbc6e00c60", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 57, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -244,7 +244,7 @@ use std::vec::Vec;\n use Encodable;\n \n /// Represents a json value\n-#[deriving(Clone, PartialEq)]\n+#[deriving(Clone, PartialEq, PartialOrd)]\n pub enum Json {\n     Number(f64),\n     String(String),\n@@ -2087,62 +2087,6 @@ impl ::Decoder<DecoderError> for Decoder {\n     }\n }\n \n-/// Test if two json values are less than one another\n-impl PartialOrd for Json {\n-    fn lt(&self, other: &Json) -> bool {\n-        match *self {\n-            Number(f0) => {\n-                match *other {\n-                    Number(f1) => f0 < f1,\n-                    String(_) | Boolean(_) | List(_) | Object(_) |\n-                    Null => true\n-                }\n-            }\n-\n-            String(ref s0) => {\n-                match *other {\n-                    Number(_) => false,\n-                    String(ref s1) => s0 < s1,\n-                    Boolean(_) | List(_) | Object(_) | Null => true\n-                }\n-            }\n-\n-            Boolean(b0) => {\n-                match *other {\n-                    Number(_) | String(_) => false,\n-                    Boolean(b1) => b0 < b1,\n-                    List(_) | Object(_) | Null => true\n-                }\n-            }\n-\n-            List(ref l0) => {\n-                match *other {\n-                    Number(_) | String(_) | Boolean(_) => false,\n-                    List(ref l1) => (*l0) < (*l1),\n-                    Object(_) | Null => true\n-                }\n-            }\n-\n-            Object(ref d0) => {\n-                match *other {\n-                    Number(_) | String(_) | Boolean(_) | List(_) => false,\n-                    Object(ref d1) => d0 < d1,\n-                    Null => true\n-                }\n-            }\n-\n-            Null => {\n-                match *other {\n-                    Number(_) | String(_) | Boolean(_) | List(_) |\n-                    Object(_) =>\n-                        false,\n-                    Null => true\n-                }\n-            }\n-        }\n-    }\n-}\n-\n /// A trait for converting values to JSON\n pub trait ToJson {\n     /// Converts the value of `self` to an instance of JSON"}, {"sha": "80f1cbe6cb29e3bcdc07836c4c347bebef525f7d", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -24,6 +24,7 @@ use default::Default;\n use fmt;\n use hash;\n use kinds::marker;\n+use option::Option;\n use ops::Deref;\n use raw;\n \n@@ -58,6 +59,10 @@ impl<T: PartialEq + 'static> PartialEq for Gc<T> {\n     fn ne(&self, other: &Gc<T>) -> bool { *(*self) != *(*other) }\n }\n impl<T: PartialOrd + 'static> PartialOrd for Gc<T> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Gc<T>) -> Option<Ordering> {\n+        (**self).partial_cmp(&**other)\n+    }\n     #[inline]\n     fn lt(&self, other: &Gc<T>) -> bool { *(*self) < *(*other) }\n     #[inline]"}, {"sha": "59cdec1ea88f07f240ad27aca105053111f6b475", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 99, "deletions": 5, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -43,22 +43,116 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n         } }\n     );\n \n+    let ordering_ty = Literal(Path::new(vec![\"std\", \"cmp\", \"Ordering\"]));\n+    let ret_ty = Literal(Path::new_(vec![\"std\", \"option\", \"Option\"],\n+                                    None,\n+                                    vec![box ordering_ty],\n+                                    true));\n+\n+    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let attrs = vec!(cx.attribute(span, inline));\n+\n+    let partial_cmp_def = MethodDef {\n+        name: \"partial_cmp\",\n+        generics: LifetimeBounds::empty(),\n+        explicit_self: borrowed_explicit_self(),\n+        args: vec![borrowed_self()],\n+        ret_ty: ret_ty,\n+        attributes: attrs,\n+        const_nonmatching: false,\n+        combine_substructure: combine_substructure(|cx, span, substr| {\n+            cs_partial_cmp(cx, span, substr)\n+        })\n+    };\n+\n     let trait_def = TraitDef {\n         span: span,\n-        attributes: Vec::new(),\n-        path: Path::new(vec!(\"std\", \"cmp\", \"PartialOrd\")),\n-        additional_bounds: Vec::new(),\n+        attributes: vec![],\n+        path: Path::new(vec![\"std\", \"cmp\", \"PartialOrd\"]),\n+        additional_bounds: vec![],\n         generics: LifetimeBounds::empty(),\n-        methods: vec!(\n+        methods: vec![\n+            partial_cmp_def,\n             md!(\"lt\", true, false),\n             md!(\"le\", true, true),\n             md!(\"gt\", false, false),\n             md!(\"ge\", false, true)\n-        )\n+        ]\n     };\n     trait_def.expand(cx, mitem, item, push)\n }\n \n+pub fn some_ordering_const(cx: &mut ExtCtxt, span: Span, cnst: Ordering) -> Gc<ast::Expr> {\n+    let cnst = match cnst {\n+        Less => \"Less\",\n+        Equal => \"Equal\",\n+        Greater => \"Greater\"\n+    };\n+    let ordering = cx.path_global(span,\n+                                  vec!(cx.ident_of(\"std\"),\n+                                       cx.ident_of(\"cmp\"),\n+                                       cx.ident_of(cnst)));\n+    let ordering = cx.expr_path(ordering);\n+    cx.expr_some(span, ordering)\n+}\n+\n+pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n+              substr: &Substructure) -> Gc<Expr> {\n+    let test_id = cx.ident_of(\"__test\");\n+    let equals_expr = some_ordering_const(cx, span, Equal);\n+\n+    /*\n+    Builds:\n+\n+    let __test = self_field1.partial_cmp(&other_field2);\n+    if __test == ::std::option::Some(::std::cmp::Equal) {\n+        let __test = self_field2.partial_cmp(&other_field2);\n+        if __test == ::std::option::Some(::std::cmp::Equal) {\n+            ...\n+        } else {\n+            __test\n+        }\n+    } else {\n+        __test\n+    }\n+\n+    FIXME #6449: These `if`s could/should be `match`es.\n+    */\n+    cs_same_method_fold(\n+        // foldr nests the if-elses correctly, leaving the first field\n+        // as the outermost one, and the last as the innermost.\n+        false,\n+        |cx, span, old, new| {\n+            // let __test = new;\n+            // if __test == Some(::std::cmp::Equal) {\n+            //    old\n+            // } else {\n+            //    __test\n+            // }\n+\n+            let assign = cx.stmt_let(span, false, test_id, new);\n+\n+            let cond = cx.expr_binary(span, ast::BiEq,\n+                                      cx.expr_ident(span, test_id),\n+                                      equals_expr.clone());\n+            let if_ = cx.expr_if(span,\n+                                 cond,\n+                                 old, Some(cx.expr_ident(span, test_id)));\n+            cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n+        },\n+        equals_expr.clone(),\n+        |cx, span, list, _| {\n+            match list {\n+                // an earlier nonmatching variant is Less than a\n+                // later one.\n+                [(self_var, _, _), (other_var, _, _)] =>\n+                     some_ordering_const(cx, span, self_var.cmp(&other_var)),\n+                _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n+            }\n+        },\n+        cx, span, substr)\n+}\n+\n /// Strict inequality.\n fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span,\n          substr: &Substructure) -> Gc<Expr> {"}, {"sha": "dd6c11d2b39932b2846af2c42fc0ec2902160105", "filename": "src/test/compile-fail/deriving-span-PartialOrd-enum-struct-variant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-enum-struct-variant.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -27,6 +27,7 @@ enum Enum {\n //~^^^^^ ERROR\n //~^^^^^^ ERROR\n //~^^^^^^^ ERROR\n+//~^^^^^^^^ ERROR\n    }\n }\n "}, {"sha": "1b3d73a6f8bee9381534fe2ca11bd57e926a9a78", "filename": "src/test/compile-fail/deriving-span-PartialOrd-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-enum.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -27,6 +27,7 @@ enum Enum {\n //~^^^^^ ERROR\n //~^^^^^^ ERROR\n //~^^^^^^^ ERROR\n+//~^^^^^^^^ ERROR\n      )\n }\n "}, {"sha": "2ef3b4dfe8a2f1218bc8e2ad19665713f8a4fbbf", "filename": "src/test/compile-fail/deriving-span-PartialOrd-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-struct.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -26,6 +26,7 @@ struct Struct {\n //~^^^^^ ERROR\n //~^^^^^^ ERROR\n //~^^^^^^^ ERROR\n+//~^^^^^^^^ ERROR\n }\n \n fn main() {}"}, {"sha": "303896737dc28183ec4123cfafc036c2d5164db1", "filename": "src/test/compile-fail/deriving-span-PartialOrd-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-PartialOrd-tuple-struct.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -26,6 +26,7 @@ struct Struct(\n //~^^^^^ ERROR\n //~^^^^^^ ERROR\n //~^^^^^^^ ERROR\n+//~^^^^^^^^ ERROR\n );\n \n fn main() {}"}, {"sha": "293f372866d1097ea62b9348b65f4ff9a768ce05", "filename": "src/test/compile-fail/issue-3344.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -10,7 +10,7 @@\n \n #[deriving(PartialEq)]\n struct thing(uint);\n-impl PartialOrd for thing { //~ ERROR not all trait methods implemented, missing: `lt`\n+impl PartialOrd for thing { //~ ERROR not all trait methods implemented, missing: `partial_cmp`\n     fn le(&self, other: &thing) -> bool { true }\n     fn ge(&self, other: &thing) -> bool { true }\n }"}, {"sha": "cfba87c3f6994aef1b7795847f94bab737859796", "filename": "src/test/run-pass/cmp-default.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Frun-pass%2Fcmp-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Frun-pass%2Fcmp-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcmp-default.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -31,10 +31,10 @@ impl PartialEq for Int {\n }\n \n impl PartialOrd for Int {\n-    fn lt(&self, other: &Int) -> bool {\n+    fn partial_cmp(&self, other: &Int) -> Option<Ordering> {\n         let Int(this) = *self;\n         let Int(other) = *other;\n-        this < other\n+        this.partial_cmp(&other)\n     }\n }\n \n@@ -49,10 +49,10 @@ impl PartialEq for RevInt {\n }\n \n impl PartialOrd for RevInt {\n-    fn lt(&self, other: &RevInt) -> bool {\n+    fn partial_cmp(&self, other: &RevInt) -> Option<Ordering> {\n         let RevInt(this) = *self;\n         let RevInt(other) = *other;\n-        this > other\n+        other.partial_cmp(&this)\n     }\n }\n "}, {"sha": "df5c58ff04b6d7f8cc8c0c7dad5bc9f9c86f35b9", "filename": "src/test/run-pass/deriving-cmp-shortcircuit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Frun-pass%2Fderiving-cmp-shortcircuit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1683f50c00297e9908ae028fa1d41b9a52a6f6f/src%2Ftest%2Frun-pass%2Fderiving-cmp-shortcircuit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-shortcircuit.rs?ref=e1683f50c00297e9908ae028fa1d41b9a52a6f6f", "patch": "@@ -18,7 +18,7 @@ impl PartialEq for FailCmp {\n }\n \n impl PartialOrd for FailCmp {\n-    fn lt(&self, _: &FailCmp) -> bool { fail!(\"lt\") }\n+    fn partial_cmp(&self, _: &FailCmp) -> Option<Ordering> { fail!(\"partial_cmp\") }\n }\n \n impl Eq for FailCmp {}"}]}