{"sha": "5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNmJkNmVjMGFjNDIyOTkxYjg5YmI4NjQzZWFhNWQ5ZDQ2ZWVkMTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-04T11:22:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-04T11:22:45Z"}, "message": "Auto merge of #74850 - TimDiekmann:remove-in-place-alloc, r=Amanieu\n\nRemove in-place allocation and revert to separate methods for zeroed allocations\n\ncloses rust-lang/wg-allocators#58", "tree": {"sha": "5462d06142c3bf69251f984fff0aeb0cc7a549fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5462d06142c3bf69251f984fff0aeb0cc7a549fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "html_url": "https://github.com/rust-lang/rust/commit/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9b80bb3ff194d488fdd95da2ef23bd466f921cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b80bb3ff194d488fdd95da2ef23bd466f921cb", "html_url": "https://github.com/rust-lang/rust/commit/c9b80bb3ff194d488fdd95da2ef23bd466f921cb"}, {"sha": "6395659168a760b31365e925dc5be5a201ac10ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/6395659168a760b31365e925dc5be5a201ac10ae", "html_url": "https://github.com/rust-lang/rust/commit/6395659168a760b31365e925dc5be5a201ac10ae"}], "stats": {"total": 787, "additions": 391, "deletions": 396}, "files": [{"sha": "111ef406c001d0c05f84ee41230649f40e86b05c", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 89, "deletions": 64, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -164,25 +164,34 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n-        unsafe {\n-            let size = layout.size();\n-            if size == 0 {\n-                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n-            } else {\n-                let raw_ptr = match init {\n-                    AllocInit::Uninitialized => alloc(layout),\n-                    AllocInit::Zeroed => alloc_zeroed(layout),\n-                };\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok(MemoryBlock { ptr, size })\n-            }\n-        }\n+    fn alloc(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+        let size = layout.size();\n+        let ptr = if size == 0 {\n+            layout.dangling()\n+        } else {\n+            // SAFETY: `layout` is non-zero in size,\n+            unsafe { NonNull::new(alloc(layout)).ok_or(AllocErr)? }\n+        };\n+        Ok(MemoryBlock { ptr, size })\n+    }\n+\n+    #[inline]\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+        let size = layout.size();\n+        let ptr = if size == 0 {\n+            layout.dangling()\n+        } else {\n+            // SAFETY: `layout` is non-zero in size,\n+            unsafe { NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr)? }\n+        };\n+        Ok(MemoryBlock { ptr, size })\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n+            // SAFETY: `layout` is non-zero in size,\n+            // other conditions must be upheld by the caller\n             unsafe { dealloc(ptr.as_ptr(), layout) }\n         }\n     }\n@@ -193,38 +202,55 @@ unsafe impl AllocRef for Global {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n-        init: AllocInit,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n         debug_assert!(\n-            new_size >= size,\n-            \"`new_size` must be greater than or equal to `memory.size()`\"\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n+        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n+        // Other conditions must be upheld by the caller\n+        unsafe {\n+            match layout.size() {\n+                old_size if old_size == new_size => Ok(MemoryBlock { ptr, size: new_size }),\n+                0 => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n+                old_size => {\n+                    // `realloc` probably checks for `new_size > size` or something similar.\n+                    intrinsics::assume(new_size > old_size);\n+                    let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                    Ok(MemoryBlock { ptr, size: new_size })\n+                }\n+            }\n         }\n+    }\n \n-        match placement {\n-            ReallocPlacement::InPlace => Err(AllocErr),\n-            ReallocPlacement::MayMove if layout.size() == 0 => {\n-                let new_layout =\n-                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-                self.alloc(new_layout, init)\n-            }\n-            ReallocPlacement::MayMove => {\n-                // `realloc` probably checks for `new_size > size` or something similar.\n-                let ptr = unsafe {\n-                    intrinsics::assume(new_size > size);\n-                    realloc(ptr.as_ptr(), layout, new_size)\n-                };\n-                let memory =\n-                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-                unsafe {\n-                    init.init_offset(memory, size);\n+    #[inline]\n+    unsafe fn grow_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        debug_assert!(\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n+        );\n+\n+        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n+        // Other conditions must be upheld by the caller\n+        unsafe {\n+            match layout.size() {\n+                old_size if old_size == new_size => Ok(MemoryBlock { ptr, size: new_size }),\n+                0 => self.alloc_zeroed(Layout::from_size_align_unchecked(new_size, layout.align())),\n+                old_size => {\n+                    // `realloc` probably checks for `new_size > size` or something similar.\n+                    intrinsics::assume(new_size > old_size);\n+                    let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n+                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                    Ok(MemoryBlock { ptr, size: new_size })\n                 }\n-                Ok(memory)\n             }\n         }\n     }\n@@ -235,35 +261,34 @@ unsafe impl AllocRef for Global {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n+        let old_size = layout.size();\n         debug_assert!(\n-            new_size <= size,\n-            \"`new_size` must be smaller than or equal to `memory.size()`\"\n+            new_size <= old_size,\n+            \"`new_size` must be smaller than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n-        }\n-\n-        match placement {\n-            ReallocPlacement::InPlace => Err(AllocErr),\n-            ReallocPlacement::MayMove if new_size == 0 => {\n-                unsafe {\n-                    self.dealloc(ptr, layout);\n-                }\n-                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n+        let ptr = if new_size == old_size {\n+            ptr\n+        } else if new_size == 0 {\n+            // SAFETY: `layout` is non-zero in size as `old_size` != `new_size`\n+            // Other conditions must be upheld by the caller\n+            unsafe {\n+                self.dealloc(ptr, layout);\n             }\n-            ReallocPlacement::MayMove => {\n-                // `realloc` probably checks for `new_size < size` or something similar.\n-                let ptr = unsafe {\n-                    intrinsics::assume(new_size < size);\n-                    realloc(ptr.as_ptr(), layout, new_size)\n-                };\n-                Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n-            }\n-        }\n+            layout.dangling()\n+        } else {\n+            // SAFETY: new_size is not zero,\n+            // Other conditions must be upheld by the caller\n+            let raw_ptr = unsafe {\n+                // `realloc` probably checks for `new_size < old_size` or something similar.\n+                intrinsics::assume(new_size < old_size);\n+                realloc(ptr.as_ptr(), layout, new_size)\n+            };\n+            NonNull::new(raw_ptr).ok_or(AllocErr)?\n+        };\n+\n+        Ok(MemoryBlock { ptr, size: new_size })\n     }\n }\n \n@@ -274,7 +299,7 @@ unsafe impl AllocRef for Global {\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n-    match Global.alloc(layout, AllocInit::Uninitialized) {\n+    match Global.alloc(layout) {\n         Ok(memory) => memory.ptr.as_ptr(),\n         Err(_) => handle_alloc_error(layout),\n     }"}, {"sha": "2b4cb946bb447d70da5695604c768a06eb7694b6", "filename": "library/alloc/src/alloc/tests.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -8,9 +8,8 @@ use test::Bencher;\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let memory = Global\n-            .alloc(layout.clone(), AllocInit::Zeroed)\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let memory =\n+            Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         let mut i = memory.ptr.cast::<u8>().as_ptr();\n         let end = i.add(layout.size());"}, {"sha": "cff219ec29da063fad699de6514e92d24ba730ae", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -146,7 +146,7 @@ use core::pin::Pin;\n use core::ptr::{self, Unique};\n use core::task::{Context, Poll};\n \n-use crate::alloc::{self, AllocInit, AllocRef, Global};\n+use crate::alloc::{self, AllocRef, Global};\n use crate::borrow::Cow;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n@@ -197,11 +197,8 @@ impl<T> Box<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n-        let ptr = Global\n-            .alloc(layout, AllocInit::Uninitialized)\n-            .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n-            .ptr\n-            .cast();\n+        let ptr =\n+            Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).ptr.cast();\n         unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n \n@@ -227,7 +224,7 @@ impl<T> Box<T> {\n     pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n         let ptr = Global\n-            .alloc(layout, AllocInit::Zeroed)\n+            .alloc_zeroed(layout)\n             .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n             .ptr\n             .cast();"}, {"sha": "99ac027bf0b9f9439f9bbedc50f9b8a3312009e4", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -8,18 +8,20 @@ use core::ops::Drop;\n use core::ptr::{NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{\n-    handle_alloc_error,\n-    AllocInit::{self, *},\n-    AllocRef, Global, Layout,\n-    ReallocPlacement::{self, *},\n-};\n+use crate::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n use crate::boxed::Box;\n use crate::collections::TryReserveError::{self, *};\n \n #[cfg(test)]\n mod tests;\n \n+enum AllocInit {\n+    /// The contents of the new memory are uninitialized.\n+    Uninitialized,\n+    /// The new memory is guaranteed to be zeroed.\n+    Zeroed,\n+}\n+\n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n /// a buffer of memory on the heap without having to worry about all the corner cases\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n@@ -156,14 +158,14 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// allocator for the returned `RawVec`.\n     #[inline]\n     pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n-        Self::allocate_in(capacity, Uninitialized, alloc)\n+        Self::allocate_in(capacity, AllocInit::Uninitialized, alloc)\n     }\n \n     /// Like `with_capacity_zeroed`, but parameterized over the choice\n     /// of allocator for the returned `RawVec`.\n     #[inline]\n     pub fn with_capacity_zeroed_in(capacity: usize, alloc: A) -> Self {\n-        Self::allocate_in(capacity, Zeroed, alloc)\n+        Self::allocate_in(capacity, AllocInit::Zeroed, alloc)\n     }\n \n     fn allocate_in(capacity: usize, init: AllocInit, mut alloc: A) -> Self {\n@@ -180,7 +182,11 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                 Ok(_) => {}\n                 Err(_) => capacity_overflow(),\n             }\n-            let memory = match alloc.alloc(layout, init) {\n+            let result = match init {\n+                AllocInit::Uninitialized => alloc.alloc(layout),\n+                AllocInit::Zeroed => alloc.alloc_zeroed(layout),\n+            };\n+            let memory = match result {\n                 Ok(memory) => memory,\n                 Err(_) => handle_alloc_error(layout),\n             };\n@@ -358,7 +364,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     ///\n     /// Aborts on OOM.\n     pub fn shrink_to_fit(&mut self, amount: usize) {\n-        match self.shrink(amount, MayMove) {\n+        match self.shrink(amount) {\n             Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n             Ok(()) => { /* yay */ }\n@@ -450,22 +456,16 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         Ok(())\n     }\n \n-    fn shrink(\n-        &mut self,\n-        amount: usize,\n-        placement: ReallocPlacement,\n-    ) -> Result<(), TryReserveError> {\n+    fn shrink(&mut self, amount: usize) -> Result<(), TryReserveError> {\n         assert!(amount <= self.capacity(), \"Tried to shrink to a larger capacity\");\n \n         let (ptr, layout) = if let Some(mem) = self.current_memory() { mem } else { return Ok(()) };\n         let new_size = amount * mem::size_of::<T>();\n \n         let memory = unsafe {\n-            self.alloc.shrink(ptr, layout, new_size, placement).map_err(|_| {\n-                TryReserveError::AllocError {\n-                    layout: Layout::from_size_align_unchecked(new_size, layout.align()),\n-                    non_exhaustive: (),\n-                }\n+            self.alloc.shrink(ptr, layout, new_size).map_err(|_| TryReserveError::AllocError {\n+                layout: Layout::from_size_align_unchecked(new_size, layout.align()),\n+                non_exhaustive: (),\n             })?\n         };\n         self.set_memory(memory);\n@@ -492,9 +492,9 @@ where\n \n     let memory = if let Some((ptr, old_layout)) = current_memory {\n         debug_assert_eq!(old_layout.align(), new_layout.align());\n-        unsafe { alloc.grow(ptr, old_layout, new_layout.size(), MayMove, Uninitialized) }\n+        unsafe { alloc.grow(ptr, old_layout, new_layout.size()) }\n     } else {\n-        alloc.alloc(new_layout, Uninitialized)\n+        alloc.alloc(new_layout)\n     }\n     .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?;\n "}, {"sha": "08a5cbee5a712cbd80a8d5b9f4d8ecd6e4a928e1", "filename": "library/alloc/src/raw_vec/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -20,12 +20,12 @@ fn allocator_param() {\n         fuel: usize,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n+        fn alloc(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);\n             }\n-            match Global.alloc(layout, init) {\n+            match Global.alloc(layout) {\n                 ok @ Ok(_) => {\n                     self.fuel -= size;\n                     ok"}, {"sha": "c0c638292bb598610d418e322e0545e765a0d322", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -250,7 +250,7 @@ use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::slice::from_raw_parts_mut;\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::string::String;\n use crate::vec::Vec;\n@@ -928,9 +928,7 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n         // Allocate for the layout.\n-        let mem = Global\n-            .alloc(layout, AllocInit::Uninitialized)\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let mem = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n         let inner = mem_to_rcbox(mem.ptr.as_ptr());"}, {"sha": "7d5f24ec4ad9b2672460546c9f87a63bb53de499", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -23,7 +23,7 @@ use core::slice::from_raw_parts_mut;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n@@ -883,9 +883,7 @@ impl<T: ?Sized> Arc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n-        let mem = Global\n-            .alloc(layout, AllocInit::Uninitialized)\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let mem = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n         let inner = mem_to_arcinner(mem.ptr.as_ptr());"}, {"sha": "a05340dc79a8307dabb77c53f4df66280d1eaf8b", "filename": "library/alloc/tests/heap.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Falloc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fheap.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -1,4 +1,4 @@\n-use std::alloc::{AllocInit, AllocRef, Global, Layout, System};\n+use std::alloc::{AllocRef, Global, Layout, System};\n \n /// Issue #45955 and #62251.\n #[test]\n@@ -20,13 +20,7 @@ fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n             unsafe {\n                 let pointers: Vec<_> = (0..iterations)\n                     .map(|_| {\n-                        allocator\n-                            .alloc(\n-                                Layout::from_size_align(size, align).unwrap(),\n-                                AllocInit::Uninitialized,\n-                            )\n-                            .unwrap()\n-                            .ptr\n+                        allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap().ptr\n                     })\n                     .collect();\n                 for &ptr in &pointers {"}, {"sha": "9ab5352c1dd098cb81c172ec5845c3fbf4347924", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 165, "deletions": 173, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -29,66 +29,6 @@ impl fmt::Display for AllocErr {\n     }\n }\n \n-/// A desired initial state for allocated memory.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub enum AllocInit {\n-    /// The contents of the new memory are uninitialized.\n-    Uninitialized,\n-    /// The new memory is guaranteed to be zeroed.\n-    Zeroed,\n-}\n-\n-impl AllocInit {\n-    /// Initialize the specified memory block.\n-    ///\n-    /// This behaves like calling [`AllocInit::init_offset(memory, 0)`][off].\n-    ///\n-    /// [off]: AllocInit::init_offset\n-    ///\n-    /// # Safety\n-    ///\n-    /// * `memory.ptr` must be [valid] for writes of `memory.size` bytes.\n-    ///\n-    /// [valid]: ../../core/ptr/index.html#safety\n-    #[inline]\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub unsafe fn init(self, memory: MemoryBlock) {\n-        // SAFETY: the safety contract for `init_offset` must be\n-        // upheld by the caller.\n-        unsafe { self.init_offset(memory, 0) }\n-    }\n-\n-    /// Initialize the memory block like specified by `init` at the specified `offset`.\n-    ///\n-    /// This is a no-op for [`AllocInit::Uninitialized`][] and writes zeroes for\n-    /// [`AllocInit::Zeroed`][] at `ptr + offset` until `ptr + layout.size()`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// * `memory.ptr` must be [valid] for writes of `memory.size` bytes.\n-    /// * `offset` must be smaller than or equal to `memory.size`\n-    ///\n-    /// [valid]: ../../core/ptr/index.html#safety\n-    #[inline]\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub unsafe fn init_offset(self, memory: MemoryBlock, offset: usize) {\n-        debug_assert!(\n-            offset <= memory.size,\n-            \"`offset` must be smaller than or equal to `memory.size`\"\n-        );\n-        match self {\n-            AllocInit::Uninitialized => (),\n-            AllocInit::Zeroed => {\n-                // SAFETY: the caller must guarantee that `offset` is smaller than or equal to `memory.size`,\n-                // so the memory from `memory.ptr + offset` of length `memory.size - offset`\n-                // is guaranteed to be contaned in `memory` and thus valid for writes.\n-                unsafe { memory.ptr.as_ptr().add(offset).write_bytes(0, memory.size - offset) }\n-            }\n-        }\n-    }\n-}\n-\n /// Represents a block of allocated memory returned by an allocator.\n #[derive(Debug, Copy, Clone)]\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n@@ -97,24 +37,6 @@ pub struct MemoryBlock {\n     pub size: usize,\n }\n \n-/// A placement constraint when growing or shrinking an existing allocation.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub enum ReallocPlacement {\n-    /// The allocator is allowed to move the allocation to a different memory address.\n-    // FIXME(wg-allocators#46): Add a section to the module documentation \"What is a legal\n-    //                          allocator\" and link it at \"valid location\".\n-    ///\n-    /// If the allocation _does_ move, it's the responsibility of the allocator\n-    /// to also move the data from the previous location to the new location.\n-    MayMove,\n-    /// The address of the new memory must not change.\n-    ///\n-    /// If the allocation would have to be moved to a new location to fit, the\n-    /// reallocation request will fail.\n-    InPlace,\n-}\n-\n /// An implementation of `AllocRef` can allocate, grow, shrink, and deallocate arbitrary blocks of\n /// data described via [`Layout`][].\n ///\n@@ -177,10 +99,25 @@ pub unsafe trait AllocRef {\n     ///\n     /// On success, returns a [`MemoryBlock`][] meeting the size and alignment guarantees of `layout`.\n     ///\n-    /// The returned block may have a larger size than specified by `layout.size()` and is\n-    /// initialized as specified by [`init`], all the way up to the returned size of the block.\n+    /// The returned block may have a larger size than specified by `layout.size()`, and may or may\n+    /// not have its contents initialized.\n     ///\n-    /// [`init`]: AllocInit\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or `layout` does not meet\n+    /// allocator's size or alignment constraints.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n+    /// aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n+    /// this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an allocation error are encouraged to\n+    /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    fn alloc(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr>;\n+\n+    /// Behaves like `alloc`, but also ensures that the returned memory is zero-initialized.\n     ///\n     /// # Errors\n     ///\n@@ -195,7 +132,12 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr>;\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+        let memory = self.alloc(layout)?;\n+        // SAFETY: `alloc` returns a valid memory block\n+        unsafe { memory.ptr.as_ptr().write_bytes(0, memory.size) }\n+        Ok(memory)\n+    }\n \n     /// Deallocates the memory referenced by `ptr`.\n     ///\n@@ -213,31 +155,86 @@ pub unsafe trait AllocRef {\n     /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n     /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may extend the\n-    /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n-    /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n-    ///\n-    /// If [`MayMove`] is used then ownership of the memory block referenced by `ptr`\n-    /// is transferred to this allocator. The memory may or may not be freed, and should be\n-    /// considered unusable (unless of course it is transferred back to the caller again via the\n-    /// return value of this method).\n+    /// allocation referenced by `ptr` to fit the new layout.\n     ///\n     /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n     /// this allocator, and the contents of the memory block are unaltered.\n     ///\n-    /// The memory block will contain the following contents after a successful call to `grow`:\n+    /// # Safety\n+    ///\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.),\n+    /// * `new_size` must be greater than or equal to `layout.size()`, and\n+    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n+    ///   (i.e., the rounded value must be less than or equal to `usize::MAX`).\n+    // Note: We can't require that `new_size` is strictly greater than `layout.size()` because of ZSTs.\n+    // alternative: `new_size must be strictly greater than `layout.size()` or both are zero\n+    ///\n+    /// [*currently allocated*]: #currently-allocated-memory\n+    /// [*fit*]: #memory-fitting\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err` if the new layout does not meet the allocator's size and alignment\n+    /// constraints of the allocator, or if growing otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n+    /// aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n+    /// this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an allocation error are encouraged to\n+    /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn grow(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        let size = layout.size();\n+        debug_assert!(\n+            new_size >= size,\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n+        );\n+\n+        if new_size == size {\n+            return Ok(MemoryBlock { ptr, size });\n+        }\n+\n+        let new_layout =\n+            // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+            // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+            // The caller must ensure that `new_size` is greater than or equal to zero. If it's equal\n+            // to zero, it's catched beforehand.\n+            unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+        let new_memory = self.alloc(new_layout)?;\n+\n+        // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n+        // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n+        // allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n+        // `copy_nonoverlapping` is safe.\n+        // The safety contract for `dealloc` must be upheld by the caller.\n+        unsafe {\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n+            self.dealloc(ptr, layout);\n+            Ok(new_memory)\n+        }\n+    }\n+\n+    /// Behaves like `grow`, but also ensures that the new contents are set to zero before being\n+    /// returned.\n+    ///\n+    /// The memory block will contain the following contents after a successful call to\n+    /// `grow_zeroed`:\n     ///   * Bytes `0..layout.size()` are preserved from the original allocation.\n-    ///   * Bytes `layout.size()..old_size` will either be preserved or initialized according to\n-    ///     [`init`], depending on the allocator implementation. `old_size` refers to the size of\n-    ///     the `MemoryBlock` prior to the `grow` call, which may be larger than the size\n+    ///   * Bytes `layout.size()..old_size` will either be preserved or zeroed,\n+    ///     depending on the allocator implementation. `old_size` refers to the size of\n+    ///     the `MemoryBlock` prior to the `grow_zeroed` call, which may be larger than the size\n     ///     that was originally requested when it was allocated.\n-    ///   * Bytes `old_size..new_size` are initialized according to [`init`]. `new_size` refers to\n+    ///   * Bytes `old_size..new_size` are zeroed. `new_size` refers to\n     ///     the size of the `MemoryBlock` returned by the `grow` call.\n     ///\n-    /// [`InPlace`]: ReallocPlacement::InPlace\n-    /// [`MayMove`]: ReallocPlacement::MayMove\n-    /// [`placement`]: ReallocPlacement\n-    /// [`init`]: AllocInit\n-    ///\n     /// # Safety\n     ///\n     /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n@@ -265,45 +262,39 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn grow(\n+    unsafe fn grow_zeroed(\n         &mut self,\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n-        init: AllocInit,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        match placement {\n-            ReallocPlacement::InPlace => Err(AllocErr),\n-            ReallocPlacement::MayMove => {\n-                let size = layout.size();\n-                debug_assert!(\n-                    new_size >= size,\n-                    \"`new_size` must be greater than or equal to `layout.size()`\"\n-                );\n+        let size = layout.size();\n+        debug_assert!(\n+            new_size >= size,\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n+        );\n \n-                if new_size == size {\n-                    return Ok(MemoryBlock { ptr, size });\n-                }\n+        if new_size == size {\n+            return Ok(MemoryBlock { ptr, size });\n+        }\n \n-                let new_layout =\n-                    // SAFETY: the caller must ensure that the `new_size` does not overflow.\n-                    // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n-                    // The caller must ensure that `new_size` is greater than zero.\n-                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-                let new_memory = self.alloc(new_layout, init)?;\n+        let new_layout =\n+            // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+            // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+            // The caller must ensure that `new_size` is greater than or equal to zero. If it's equal\n+            // to zero, it's caught beforehand.\n+            unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+        let new_memory = self.alloc_zeroed(new_layout)?;\n \n-                // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n-                // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n-                // allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n-                // `copy_nonoverlapping` is safe.\n-                // The safety contract for `dealloc` must be upheld by the caller.\n-                unsafe {\n-                    ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n-                    self.dealloc(ptr, layout);\n-                    Ok(new_memory)\n-                }\n-            }\n+        // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n+        // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n+        // allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n+        // `copy_nonoverlapping` is safe.\n+        // The safety contract for `dealloc` must be upheld by the caller.\n+        unsafe {\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n+            self.dealloc(ptr, layout);\n+            Ok(new_memory)\n         }\n     }\n \n@@ -312,8 +303,7 @@ pub unsafe trait AllocRef {\n     /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n     /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may shrink the\n-    /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n-    /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n+    /// allocation referenced by `ptr` to fit the new layout.\n     ///\n     /// If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n     /// transferred to this allocator. The memory may or may not have been freed, and should be\n@@ -323,11 +313,6 @@ pub unsafe trait AllocRef {\n     /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n     /// this allocator, and the contents of the memory block are unaltered.\n     ///\n-    /// The behavior of how the allocator tries to shrink the memory is specified by [`placement`].\n-    ///\n-    /// [`InPlace`]: ReallocPlacement::InPlace\n-    /// [`placement`]: ReallocPlacement\n-    ///\n     /// # Safety\n     ///\n     /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n@@ -358,39 +343,33 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        match placement {\n-            ReallocPlacement::InPlace => Err(AllocErr),\n-            ReallocPlacement::MayMove => {\n-                let size = layout.size();\n-                debug_assert!(\n-                    new_size <= size,\n-                    \"`new_size` must be smaller than or equal to `layout.size()`\"\n-                );\n+        let size = layout.size();\n+        debug_assert!(\n+            new_size <= size,\n+            \"`new_size` must be smaller than or equal to `layout.size()`\"\n+        );\n \n-                if new_size == size {\n-                    return Ok(MemoryBlock { ptr, size });\n-                }\n+        if new_size == size {\n+            return Ok(MemoryBlock { ptr, size });\n+        }\n \n-                let new_layout =\n-                // SAFETY: the caller must ensure that the `new_size` does not overflow.\n-                // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n-                // The caller must ensure that `new_size` is greater than zero.\n-                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-                let new_memory = self.alloc(new_layout, AllocInit::Uninitialized)?;\n+        let new_layout =\n+        // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+        // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+        // The caller must ensure that `new_size` is greater than zero.\n+            unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+        let new_memory = self.alloc(new_layout)?;\n \n-                // SAFETY: because `new_size` must be lower than or equal to `size`, both the old and new\n-                // memory allocation are valid for reads and writes for `new_size` bytes. Also, because the\n-                // old allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n-                // `copy_nonoverlapping` is safe.\n-                // The safety contract for `dealloc` must be upheld by the caller.\n-                unsafe {\n-                    ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), new_size);\n-                    self.dealloc(ptr, layout);\n-                    Ok(new_memory)\n-                }\n-            }\n+        // SAFETY: because `new_size` must be lower than or equal to `size`, both the old and new\n+        // memory allocation are valid for reads and writes for `new_size` bytes. Also, because the\n+        // old allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n+        // `copy_nonoverlapping` is safe.\n+        // The safety contract for `dealloc` must be upheld by the caller.\n+        unsafe {\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), new_size);\n+            self.dealloc(ptr, layout);\n+            Ok(new_memory)\n         }\n     }\n \n@@ -409,8 +388,13 @@ where\n     A: AllocRef + ?Sized,\n {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n-        (**self).alloc(layout, init)\n+    fn alloc(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+        (**self).alloc(layout)\n+    }\n+\n+    #[inline]\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+        (**self).alloc_zeroed(layout)\n     }\n \n     #[inline]\n@@ -425,11 +409,20 @@ where\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n-        init: AllocInit,\n     ) -> Result<MemoryBlock, AllocErr> {\n         // SAFETY: the safety contract must be upheld by the caller\n-        unsafe { (**self).grow(ptr, layout, new_size, placement, init) }\n+        unsafe { (**self).grow(ptr, layout, new_size) }\n+    }\n+\n+    #[inline]\n+    unsafe fn grow_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        // SAFETY: the safety contract must be upheld by the caller\n+        unsafe { (**self).grow_zeroed(ptr, layout, new_size) }\n     }\n \n     #[inline]\n@@ -438,9 +431,8 @@ where\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n     ) -> Result<MemoryBlock, AllocErr> {\n         // SAFETY: the safety contract must be upheld by the caller\n-        unsafe { (**self).shrink(ptr, layout, new_size, placement) }\n+        unsafe { (**self).shrink(ptr, layout, new_size) }\n     }\n }"}, {"sha": "b71a392b703a248568f58c45003ab5b76561a5bb", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 90, "deletions": 92, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -140,28 +140,35 @@ pub struct System;\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for System {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n-        unsafe {\n-            let size = layout.size();\n-            if size == 0 {\n-                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n-            } else {\n-                let raw_ptr = match init {\n-                    AllocInit::Uninitialized => GlobalAlloc::alloc(self, layout),\n-                    AllocInit::Zeroed => GlobalAlloc::alloc_zeroed(self, layout),\n-                };\n-                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok(MemoryBlock { ptr, size })\n-            }\n-        }\n+    fn alloc(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+        let size = layout.size();\n+        let ptr = if size == 0 {\n+            layout.dangling()\n+        } else {\n+            // SAFETY: `layout` is non-zero in size,\n+            unsafe { NonNull::new(GlobalAlloc::alloc(&System, layout)).ok_or(AllocErr)? }\n+        };\n+        Ok(MemoryBlock { ptr, size })\n+    }\n+\n+    #[inline]\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+        let size = layout.size();\n+        let ptr = if size == 0 {\n+            layout.dangling()\n+        } else {\n+            // SAFETY: `layout` is non-zero in size,\n+            unsafe { NonNull::new(GlobalAlloc::alloc_zeroed(&System, layout)).ok_or(AllocErr)? }\n+        };\n+        Ok(MemoryBlock { ptr, size })\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n-            // SAFETY: The safety guarantees are explained in the documentation\n-            // for the `GlobalAlloc` trait and its `dealloc` method.\n-            unsafe { GlobalAlloc::dealloc(self, ptr.as_ptr(), layout) }\n+            // SAFETY: `layout` is non-zero in size,\n+            // other conditions must be upheld by the caller\n+            unsafe { GlobalAlloc::dealloc(&System, ptr.as_ptr(), layout) }\n         }\n     }\n \n@@ -171,53 +178,55 @@ unsafe impl AllocRef for System {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n-        init: AllocInit,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n         debug_assert!(\n-            new_size >= size,\n-            \"`new_size` must be greater than or equal to `memory.size()`\"\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n+        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n+        // Other conditions must be upheld by the caller\n+        unsafe {\n+            match layout.size() {\n+                old_size if old_size == new_size => Ok(MemoryBlock { ptr, size: new_size }),\n+                0 => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n+                old_size => {\n+                    // `realloc` probably checks for `new_size > size` or something similar.\n+                    intrinsics::assume(new_size > old_size);\n+                    let raw_ptr = GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size);\n+                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                    Ok(MemoryBlock { ptr, size: new_size })\n+                }\n+            }\n         }\n+    }\n \n-        match placement {\n-            ReallocPlacement::InPlace => Err(AllocErr),\n-            ReallocPlacement::MayMove if layout.size() == 0 => {\n-                let new_layout =\n-                    // SAFETY: The new size and layout alignement guarantees\n-                    // are transferred to the caller (they come from parameters).\n-                    //\n-                    // See the preconditions for `Layout::from_size_align` to\n-                    // see what must be checked.\n-                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-                self.alloc(new_layout, init)\n-            }\n-            ReallocPlacement::MayMove => {\n-                // SAFETY:\n-                //\n-                // The safety guarantees are explained in the documentation\n-                // for the `GlobalAlloc` trait and its `dealloc` method.\n-                //\n-                // `realloc` probably checks for `new_size > size` or something\n-                // similar.\n-                //\n-                // For the guarantees about `init_offset`, see its documentation:\n-                // `ptr` is assumed valid (and checked for non-NUL) and\n-                // `memory.size` is set to `new_size` so the offset being `size`\n-                // is valid.\n-                let memory = unsafe {\n-                    intrinsics::assume(new_size > size);\n-                    let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                    let memory =\n-                        MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-                    init.init_offset(memory, size);\n-                    memory\n-                };\n-                Ok(memory)\n+    #[inline]\n+    unsafe fn grow_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        debug_assert!(\n+            new_size >= layout.size(),\n+            \"`new_size` must be greater than or equal to `layout.size()`\"\n+        );\n+\n+        // SAFETY: `new_size` must be non-zero, which is checked in the match expression.\n+        // Other conditions must be upheld by the caller\n+        unsafe {\n+            match layout.size() {\n+                old_size if old_size == new_size => Ok(MemoryBlock { ptr, size: new_size }),\n+                0 => self.alloc_zeroed(Layout::from_size_align_unchecked(new_size, layout.align())),\n+                old_size => {\n+                    // `realloc` probably checks for `new_size > size` or something similar.\n+                    intrinsics::assume(new_size > old_size);\n+                    let raw_ptr = GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size);\n+                    raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n+                    let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                    Ok(MemoryBlock { ptr, size: new_size })\n+                }\n             }\n         }\n     }\n@@ -228,45 +237,34 @@ unsafe impl AllocRef for System {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-        placement: ReallocPlacement,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        let size = layout.size();\n+        let old_size = layout.size();\n         debug_assert!(\n-            new_size <= size,\n-            \"`new_size` must be smaller than or equal to `memory.size()`\"\n+            new_size <= old_size,\n+            \"`new_size` must be smaller than or equal to `layout.size()`\"\n         );\n \n-        if size == new_size {\n-            return Ok(MemoryBlock { ptr, size });\n-        }\n-\n-        match placement {\n-            ReallocPlacement::InPlace => Err(AllocErr),\n-            ReallocPlacement::MayMove if new_size == 0 => {\n-                // SAFETY: see `GlobalAlloc::dealloc` for the guarantees that\n-                // must be respected. `ptr` and `layout` are parameters and so\n-                // those guarantees must be checked by the caller.\n-                unsafe { self.dealloc(ptr, layout) };\n-                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n+        let ptr = if new_size == old_size {\n+            ptr\n+        } else if new_size == 0 {\n+            // SAFETY: `layout` is non-zero in size as `old_size` != `new_size`\n+            // Other conditions must be upheld by the caller\n+            unsafe {\n+                self.dealloc(ptr, layout);\n             }\n-            ReallocPlacement::MayMove => {\n-                // SAFETY:\n-                //\n-                // See `GlobalAlloc::realloc` for more informations about the\n-                // guarantees expected by this method. `ptr`, `layout` and\n-                // `new_size` are parameters and the responsibility for their\n-                // correctness is left to the caller.\n-                //\n-                // `realloc` probably checks for `new_size < size` or something\n-                // similar.\n-                let memory = unsafe {\n-                    intrinsics::assume(new_size < size);\n-                    let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size }\n-                };\n-                Ok(memory)\n-            }\n-        }\n+            layout.dangling()\n+        } else {\n+            // SAFETY: new_size is not zero,\n+            // Other conditions must be upheld by the caller\n+            let raw_ptr = unsafe {\n+                // `realloc` probably checks for `new_size < old_size` or something similar.\n+                intrinsics::assume(new_size < old_size);\n+                GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size)\n+            };\n+            NonNull::new(raw_ptr).ok_or(AllocErr)?\n+        };\n+\n+        Ok(MemoryBlock { ptr, size: new_size })\n     }\n }\n static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());"}, {"sha": "f10d29f33fcb7e49e438528da79438477e45d8ea", "filename": "src/test/ui/allocator/custom.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -7,7 +7,7 @@\n \n extern crate helper;\n \n-use std::alloc::{self, AllocInit, AllocRef, Global, Layout, System};\n+use std::alloc::{self, AllocRef, Global, Layout, System};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n static HITS: AtomicUsize = AtomicUsize::new(0);\n@@ -37,7 +37,7 @@ fn main() {\n     unsafe {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let memory = Global.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n+        let memory = Global.alloc(layout.clone()).unwrap();\n         helper::work_with(&memory.ptr);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 1);\n         Global.dealloc(memory.ptr, layout);\n@@ -49,7 +49,7 @@ fn main() {\n         drop(s);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n \n-        let memory = System.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n+        let memory = System.alloc(layout.clone()).unwrap();\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n         helper::work_with(&memory.ptr);\n         System.dealloc(memory.ptr, layout);"}, {"sha": "c7d31f71074bac0a074165fb7f47f548ce046f05", "filename": "src/test/ui/allocator/xcrate-use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -9,7 +9,7 @@\n extern crate custom;\n extern crate helper;\n \n-use std::alloc::{AllocInit, AllocRef, Global, Layout, System};\n+use std::alloc::{AllocRef, Global, Layout, System};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n #[global_allocator]\n@@ -20,13 +20,13 @@ fn main() {\n         let n = GLOBAL.0.load(Ordering::SeqCst);\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let memory = Global.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n+        let memory = Global.alloc(layout.clone()).unwrap();\n         helper::work_with(&memory.ptr);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n         Global.dealloc(memory.ptr, layout);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n \n-        let memory = System.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n+        let memory = System.alloc(layout.clone()).unwrap();\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n         helper::work_with(&memory.ptr);\n         System.dealloc(memory.ptr, layout);"}, {"sha": "e9435bb476cfd20a44cf3ec80889ca5891aa2f1f", "filename": "src/test/ui/realloc-16687.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/src%2Ftest%2Fui%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/src%2Ftest%2Fui%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frealloc-16687.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -6,7 +6,7 @@\n \n #![feature(allocator_api)]\n \n-use std::alloc::{handle_alloc_error, AllocInit, AllocRef, Global, Layout, ReallocPlacement};\n+use std::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n use std::ptr::{self, NonNull};\n \n fn main() {\n@@ -41,9 +41,7 @@ unsafe fn test_triangle() -> bool {\n             println!(\"allocate({:?})\", layout);\n         }\n \n-        let memory = Global\n-            .alloc(layout, AllocInit::Uninitialized)\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let memory = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         if PRINT {\n             println!(\"allocate({:?}) = {:?}\", layout, memory.ptr);\n@@ -70,11 +68,9 @@ unsafe fn test_triangle() -> bool {\n                 NonNull::new_unchecked(ptr),\n                 old,\n                 new.size(),\n-                ReallocPlacement::MayMove,\n-                AllocInit::Uninitialized,\n             )\n         } else {\n-            Global.shrink(NonNull::new_unchecked(ptr), old, new.size(), ReallocPlacement::MayMove)\n+            Global.shrink(NonNull::new_unchecked(ptr), old, new.size())\n         };\n \n         let memory = memory.unwrap_or_else(|_| {"}, {"sha": "7d433530033ed9c0256f32c41acc8db369336164", "filename": "src/test/ui/regions/regions-mock-codegen.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs?ref=5f6bd6ec0ac422991b89bb8643eaa5d9d46eed11", "patch": "@@ -4,7 +4,7 @@\n // pretty-expanded FIXME #23616\n #![feature(allocator_api)]\n \n-use std::alloc::{handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n+use std::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n use std::ptr::NonNull;\n \n struct arena(());\n@@ -25,9 +25,7 @@ struct Ccx {\n fn alloc(_bcx: &arena) -> &Bcx<'_> {\n     unsafe {\n         let layout = Layout::new::<Bcx>();\n-        let memory = Global\n-            .alloc(layout, AllocInit::Uninitialized)\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let memory = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n         &*(memory.ptr.as_ptr() as *const _)\n     }\n }"}]}