{"sha": "e545dc9e2c1fe9852032ee753c0006b25e164d38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NDVkYzllMmMxZmU5ODUyMDMyZWU3NTNjMDAwNmIyNWUxNjRkMzg=", "commit": {"author": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2018-09-28T16:32:59Z"}, "committer": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2018-09-28T16:32:59Z"}, "message": "Compute Android gdb version in compiletest\n\ncompiletest has special code for running gdb for Android targets.  In\nparticular it computes a different path to gdb.  However, this gdb is\nnot used for the version test, which results in some tests being run\nwhen they should not be.  You can see this in #54004.\n\nThis patch moves the special case to analyze_gdb and a new helper\nfunction to decide whether the case applies.  This causes the version\ncheck to work properly.\n\nNote that the bulk of the runtest.rs change is just reindentation\ncaused by moving from a \"match\" to an \"if\" -- but there is a (small)\nchange buried in there.", "tree": {"sha": "9e261dd86243a18e394d2e8a3bc48f33b39aac96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e261dd86243a18e394d2e8a3bc48f33b39aac96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e545dc9e2c1fe9852032ee753c0006b25e164d38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e545dc9e2c1fe9852032ee753c0006b25e164d38", "html_url": "https://github.com/rust-lang/rust/commit/e545dc9e2c1fe9852032ee753c0006b25e164d38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e545dc9e2c1fe9852032ee753c0006b25e164d38/comments", "author": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80e6e3e582a9eb9115900d51ae6edecf46d81f6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/80e6e3e582a9eb9115900d51ae6edecf46d81f6e", "html_url": "https://github.com/rust-lang/rust/commit/80e6e3e582a9eb9115900d51ae6edecf46d81f6e"}], "stats": {"total": 428, "additions": 225, "deletions": 203}, "files": [{"sha": "2fa459bec9455d930b8f5d3176078fba774e2d1c", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e545dc9e2c1fe9852032ee753c0006b25e164d38/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e545dc9e2c1fe9852032ee753c0006b25e164d38/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=e545dc9e2c1fe9852032ee753c0006b25e164d38", "patch": "@@ -278,7 +278,10 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         }\n     }\n \n-    let (gdb, gdb_version, gdb_native_rust) = analyze_gdb(matches.opt_str(\"gdb\"));\n+    let target = opt_str2(matches.opt_str(\"target\"));\n+    let android_cross_path = opt_path(matches, \"android-cross-path\");\n+    let (gdb, gdb_version, gdb_native_rust) = analyze_gdb(matches.opt_str(\"gdb\"), &target,\n+                                                          &android_cross_path);\n \n     let color = match matches.opt_str(\"color\").as_ref().map(|x| &**x) {\n         Some(\"auto\") | None => ColorConfig::AutoColor,\n@@ -318,15 +321,15 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         runtool: matches.opt_str(\"runtool\"),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n         target_rustcflags: matches.opt_str(\"target-rustcflags\"),\n-        target: opt_str2(matches.opt_str(\"target\")),\n+        target: target,\n         host: opt_str2(matches.opt_str(\"host\")),\n         gdb,\n         gdb_version,\n         gdb_native_rust,\n         lldb_version: extract_lldb_version(matches.opt_str(\"lldb-version\")),\n         llvm_version: matches.opt_str(\"llvm-version\"),\n         system_llvm: matches.opt_present(\"system-llvm\"),\n-        android_cross_path: opt_path(matches, \"android-cross-path\"),\n+        android_cross_path: android_cross_path,\n         adb_path: opt_str2(matches.opt_str(\"adb-path\")),\n         adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")),\n         adb_device_status: opt_str2(matches.opt_str(\"target\")).contains(\"android\")\n@@ -780,23 +783,46 @@ fn make_test_closure(\n     }))\n }\n \n+/// Returns true if the given target is an Android target for the\n+/// purposes of GDB testing.\n+fn is_android_gdb_target(target: &String) -> bool {\n+    match &target[..] {\n+        \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => true,\n+        _ => false,\n+    }\n+}\n+\n /// Returns (Path to GDB, GDB Version, GDB has Rust Support)\n-fn analyze_gdb(gdb: Option<String>) -> (Option<String>, Option<u32>, bool) {\n+fn analyze_gdb(gdb: Option<String>, target: &String, android_cross_path: &PathBuf)\n+               -> (Option<String>, Option<u32>, bool) {\n     #[cfg(not(windows))]\n     const GDB_FALLBACK: &str = \"gdb\";\n     #[cfg(windows)]\n     const GDB_FALLBACK: &str = \"gdb.exe\";\n \n     const MIN_GDB_WITH_RUST: u32 = 7011010;\n \n+    let fallback_gdb = || {\n+        if is_android_gdb_target(target) {\n+            let mut gdb_path = match android_cross_path.to_str() {\n+                Some(x) => x.to_owned(),\n+                None => panic!(\"cannot find android cross path\"),\n+            };\n+            gdb_path.push_str(\"/bin/gdb\");\n+            gdb_path\n+        } else {\n+            GDB_FALLBACK.to_owned()\n+        }\n+    };\n+\n     let gdb = match gdb {\n-        None => GDB_FALLBACK,\n-        Some(ref s) if s.is_empty() => GDB_FALLBACK, // may be empty if configure found no gdb\n-        Some(ref s) => s,\n+        None => fallback_gdb(),\n+        Some(ref s) if s.is_empty() => fallback_gdb(), // may be empty if configure found no gdb\n+        Some(ref s) => s.to_owned(),\n     };\n \n     let mut version_line = None;\n-    if let Ok(output) = Command::new(gdb).arg(\"--version\").output() {\n+    if let Ok(output) = Command::new(&gdb).arg(\"--version\").output() {\n         if let Some(first_line) = String::from_utf8_lossy(&output.stdout).lines().next() {\n             version_line = Some(first_line.to_string());\n         }\n@@ -809,7 +835,7 @@ fn analyze_gdb(gdb: Option<String>) -> (Option<String>, Option<u32>, bool) {\n \n     let gdb_native_rust = version.map_or(false, |v| v >= MIN_GDB_WITH_RUST);\n \n-    (Some(gdb.to_owned()), version, gdb_native_rust)\n+    (Some(gdb), version, gdb_native_rust)\n }\n \n fn extract_gdb_version(full_version_line: &str) -> Option<u32> {"}, {"sha": "de3db96155bb6a68ada24dbb4544ea3ec072a6ec", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 190, "deletions": 194, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/e545dc9e2c1fe9852032ee753c0006b25e164d38/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e545dc9e2c1fe9852032ee753c0006b25e164d38/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=e545dc9e2c1fe9852032ee753c0006b25e164d38", "patch": "@@ -38,6 +38,7 @@ use std::process::{Child, Command, ExitStatus, Output, Stdio};\n use std::str;\n \n use extract_gdb_version;\n+use is_android_gdb_target;\n \n #[cfg(windows)]\n fn disable_error_reporting<F: FnOnce() -> R, R>(f: F) -> R {\n@@ -666,222 +667,217 @@ impl<'test> TestCx<'test> {\n         let exe_file = self.make_exe_name();\n \n         let debugger_run_result;\n-        match &*self.config.target {\n-            \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => {\n-                cmds = cmds.replace(\"run\", \"continue\");\n+        if is_android_gdb_target(&self.config.target) {\n+            cmds = cmds.replace(\"run\", \"continue\");\n \n-                let tool_path = match self.config.android_cross_path.to_str() {\n-                    Some(x) => x.to_owned(),\n-                    None => self.fatal(\"cannot find android cross path\"),\n-                };\n+            let tool_path = match self.config.android_cross_path.to_str() {\n+                Some(x) => x.to_owned(),\n+                None => self.fatal(\"cannot find android cross path\"),\n+            };\n \n-                // write debugger script\n-                let mut script_str = String::with_capacity(2048);\n-                script_str.push_str(&format!(\"set charset {}\\n\", Self::charset()));\n-                script_str.push_str(&format!(\"set sysroot {}\\n\", tool_path));\n-                script_str.push_str(&format!(\"file {}\\n\", exe_file.to_str().unwrap()));\n-                script_str.push_str(\"target remote :5039\\n\");\n-                script_str.push_str(&format!(\n-                    \"set solib-search-path \\\n-                     ./{}/stage2/lib/rustlib/{}/lib/\\n\",\n-                    self.config.host, self.config.target\n-                ));\n-                for line in &breakpoint_lines {\n-                    script_str.push_str(\n-                        &format!(\n-                            \"break {:?}:{}\\n\",\n-                            self.testpaths.file.file_name().unwrap().to_string_lossy(),\n-                            *line\n-                        )[..],\n-                    );\n-                }\n-                script_str.push_str(&cmds);\n-                script_str.push_str(\"\\nquit\\n\");\n-\n-                debug!(\"script_str = {}\", script_str);\n-                self.dump_output_file(&script_str, \"debugger.script\");\n-\n-                let adb_path = &self.config.adb_path;\n-\n-                Command::new(adb_path)\n-                    .arg(\"push\")\n-                    .arg(&exe_file)\n-                    .arg(&self.config.adb_test_dir)\n-                    .status()\n-                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n-\n-                Command::new(adb_path)\n-                    .args(&[\"forward\", \"tcp:5039\", \"tcp:5039\"])\n-                    .status()\n-                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n-\n-                let adb_arg = format!(\n-                    \"export LD_LIBRARY_PATH={}; \\\n-                     gdbserver{} :5039 {}/{}\",\n-                    self.config.adb_test_dir.clone(),\n-                    if self.config.target.contains(\"aarch64\") {\n-                        \"64\"\n-                    } else {\n-                        \"\"\n-                    },\n-                    self.config.adb_test_dir.clone(),\n-                    exe_file.file_name().unwrap().to_str().unwrap()\n+            // write debugger script\n+            let mut script_str = String::with_capacity(2048);\n+            script_str.push_str(&format!(\"set charset {}\\n\", Self::charset()));\n+            script_str.push_str(&format!(\"set sysroot {}\\n\", tool_path));\n+            script_str.push_str(&format!(\"file {}\\n\", exe_file.to_str().unwrap()));\n+            script_str.push_str(\"target remote :5039\\n\");\n+            script_str.push_str(&format!(\n+                \"set solib-search-path \\\n+                 ./{}/stage2/lib/rustlib/{}/lib/\\n\",\n+                self.config.host, self.config.target\n+            ));\n+            for line in &breakpoint_lines {\n+                script_str.push_str(\n+                    &format!(\n+                        \"break {:?}:{}\\n\",\n+                        self.testpaths.file.file_name().unwrap().to_string_lossy(),\n+                        *line\n+                    )[..],\n                 );\n+            }\n+            script_str.push_str(&cmds);\n+            script_str.push_str(\"\\nquit\\n\");\n \n-                debug!(\"adb arg: {}\", adb_arg);\n-                let mut adb = Command::new(adb_path)\n-                    .args(&[\"shell\", &adb_arg])\n-                    .stdout(Stdio::piped())\n-                    .stderr(Stdio::inherit())\n-                    .spawn()\n-                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n-\n-                // Wait for the gdbserver to print out \"Listening on port ...\"\n-                // at which point we know that it's started and then we can\n-                // execute the debugger below.\n-                let mut stdout = BufReader::new(adb.stdout.take().unwrap());\n-                let mut line = String::new();\n-                loop {\n-                    line.truncate(0);\n-                    stdout.read_line(&mut line).unwrap();\n-                    if line.starts_with(\"Listening on port 5039\") {\n-                        break;\n-                    }\n-                }\n-                drop(stdout);\n-\n-                let debugger_script = self.make_out_name(\"debugger.script\");\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                let debugger_opts = vec![\n-                    \"-quiet\".to_owned(),\n-                    \"-batch\".to_owned(),\n-                    \"-nx\".to_owned(),\n-                    format!(\"-command={}\", debugger_script.to_str().unwrap()),\n-                ];\n-\n-                let mut gdb_path = tool_path;\n-                gdb_path.push_str(\"/bin/gdb\");\n-                let Output {\n-                    status,\n-                    stdout,\n-                    stderr,\n-                } = Command::new(&gdb_path)\n-                    .args(&debugger_opts)\n-                    .output()\n-                    .expect(&format!(\"failed to exec `{:?}`\", gdb_path));\n-                let cmdline = {\n-                    let mut gdb = Command::new(&format!(\"{}-gdb\", self.config.target));\n-                    gdb.args(&debugger_opts);\n-                    let cmdline = self.make_cmdline(&gdb, \"\");\n-                    logv(self.config, format!(\"executing {}\", cmdline));\n-                    cmdline\n-                };\n+            debug!(\"script_str = {}\", script_str);\n+            self.dump_output_file(&script_str, \"debugger.script\");\n \n-                debugger_run_result = ProcRes {\n-                    status,\n-                    stdout: String::from_utf8(stdout).unwrap(),\n-                    stderr: String::from_utf8(stderr).unwrap(),\n-                    cmdline,\n-                };\n-                if adb.kill().is_err() {\n-                    println!(\"Adb process is already finished.\");\n+            let adb_path = &self.config.adb_path;\n+\n+            Command::new(adb_path)\n+                .arg(\"push\")\n+                .arg(&exe_file)\n+                .arg(&self.config.adb_test_dir)\n+                .status()\n+                .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n+\n+            Command::new(adb_path)\n+                .args(&[\"forward\", \"tcp:5039\", \"tcp:5039\"])\n+                .status()\n+                .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n+\n+            let adb_arg = format!(\n+                \"export LD_LIBRARY_PATH={}; \\\n+                 gdbserver{} :5039 {}/{}\",\n+                self.config.adb_test_dir.clone(),\n+                if self.config.target.contains(\"aarch64\") {\n+                    \"64\"\n+                } else {\n+                    \"\"\n+                },\n+                self.config.adb_test_dir.clone(),\n+                exe_file.file_name().unwrap().to_str().unwrap()\n+            );\n+\n+            debug!(\"adb arg: {}\", adb_arg);\n+            let mut adb = Command::new(adb_path)\n+                .args(&[\"shell\", &adb_arg])\n+                .stdout(Stdio::piped())\n+                .stderr(Stdio::inherit())\n+                .spawn()\n+                .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n+\n+            // Wait for the gdbserver to print out \"Listening on port ...\"\n+            // at which point we know that it's started and then we can\n+            // execute the debugger below.\n+            let mut stdout = BufReader::new(adb.stdout.take().unwrap());\n+            let mut line = String::new();\n+            loop {\n+                line.truncate(0);\n+                stdout.read_line(&mut line).unwrap();\n+                if line.starts_with(\"Listening on port 5039\") {\n+                    break;\n                 }\n             }\n+            drop(stdout);\n \n-            _ => {\n-                let rust_src_root = self\n-                    .config\n-                    .find_rust_src_root()\n-                    .expect(\"Could not find Rust source root\");\n-                let rust_pp_module_rel_path = Path::new(\"./src/etc\");\n-                let rust_pp_module_abs_path = rust_src_root\n-                    .join(rust_pp_module_rel_path)\n-                    .to_str()\n-                    .unwrap()\n-                    .to_owned();\n-                // write debugger script\n-                let mut script_str = String::with_capacity(2048);\n-                script_str.push_str(&format!(\"set charset {}\\n\", Self::charset()));\n-                script_str.push_str(\"show version\\n\");\n-\n-                match self.config.gdb_version {\n-                    Some(version) => {\n-                        println!(\n-                            \"NOTE: compiletest thinks it is using GDB version {}\",\n-                            version\n-                        );\n+            let debugger_script = self.make_out_name(\"debugger.script\");\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            let debugger_opts = vec![\n+                \"-quiet\".to_owned(),\n+                \"-batch\".to_owned(),\n+                \"-nx\".to_owned(),\n+                format!(\"-command={}\", debugger_script.to_str().unwrap()),\n+            ];\n \n-                        if version > extract_gdb_version(\"7.4\").unwrap() {\n-                            // Add the directory containing the pretty printers to\n-                            // GDB's script auto loading safe path\n-                            script_str.push_str(&format!(\n-                                \"add-auto-load-safe-path {}\\n\",\n-                                rust_pp_module_abs_path.replace(r\"\\\", r\"\\\\\")\n-                            ));\n-                        }\n-                    }\n-                    _ => {\n-                        println!(\n-                            \"NOTE: compiletest does not know which version of \\\n-                             GDB it is using\"\n-                        );\n+            let gdb_path = self.config.gdb.as_ref().unwrap();\n+            let Output {\n+                status,\n+                stdout,\n+                stderr,\n+            } = Command::new(&gdb_path)\n+                .args(&debugger_opts)\n+                .output()\n+                .expect(&format!(\"failed to exec `{:?}`\", gdb_path));\n+            let cmdline = {\n+                let mut gdb = Command::new(&format!(\"{}-gdb\", self.config.target));\n+                gdb.args(&debugger_opts);\n+                let cmdline = self.make_cmdline(&gdb, \"\");\n+                logv(self.config, format!(\"executing {}\", cmdline));\n+                cmdline\n+            };\n+\n+            debugger_run_result = ProcRes {\n+                status,\n+                stdout: String::from_utf8(stdout).unwrap(),\n+                stderr: String::from_utf8(stderr).unwrap(),\n+                cmdline,\n+            };\n+            if adb.kill().is_err() {\n+                println!(\"Adb process is already finished.\");\n+            }\n+        } else {\n+            let rust_src_root = self\n+                .config\n+                .find_rust_src_root()\n+                .expect(\"Could not find Rust source root\");\n+            let rust_pp_module_rel_path = Path::new(\"./src/etc\");\n+            let rust_pp_module_abs_path = rust_src_root\n+                .join(rust_pp_module_rel_path)\n+                .to_str()\n+                .unwrap()\n+                .to_owned();\n+            // write debugger script\n+            let mut script_str = String::with_capacity(2048);\n+            script_str.push_str(&format!(\"set charset {}\\n\", Self::charset()));\n+            script_str.push_str(\"show version\\n\");\n+\n+            match self.config.gdb_version {\n+                Some(version) => {\n+                    println!(\n+                        \"NOTE: compiletest thinks it is using GDB version {}\",\n+                        version\n+                    );\n+\n+                    if version > extract_gdb_version(\"7.4\").unwrap() {\n+                        // Add the directory containing the pretty printers to\n+                        // GDB's script auto loading safe path\n+                        script_str.push_str(&format!(\n+                            \"add-auto-load-safe-path {}\\n\",\n+                            rust_pp_module_abs_path.replace(r\"\\\", r\"\\\\\")\n+                        ));\n                     }\n                 }\n+                _ => {\n+                    println!(\n+                        \"NOTE: compiletest does not know which version of \\\n+                         GDB it is using\"\n+                    );\n+                }\n+            }\n \n-                // The following line actually doesn't have to do anything with\n-                // pretty printing, it just tells GDB to print values on one line:\n-                script_str.push_str(\"set print pretty off\\n\");\n+            // The following line actually doesn't have to do anything with\n+            // pretty printing, it just tells GDB to print values on one line:\n+            script_str.push_str(\"set print pretty off\\n\");\n \n-                // Add the pretty printer directory to GDB's source-file search path\n-                script_str.push_str(&format!(\"directory {}\\n\", rust_pp_module_abs_path));\n+            // Add the pretty printer directory to GDB's source-file search path\n+            script_str.push_str(&format!(\"directory {}\\n\", rust_pp_module_abs_path));\n \n-                // Load the target executable\n-                script_str.push_str(&format!(\n-                    \"file {}\\n\",\n-                    exe_file.to_str().unwrap().replace(r\"\\\", r\"\\\\\")\n-                ));\n+            // Load the target executable\n+            script_str.push_str(&format!(\n+                \"file {}\\n\",\n+                exe_file.to_str().unwrap().replace(r\"\\\", r\"\\\\\")\n+            ));\n \n-                // Force GDB to print values in the Rust format.\n-                if self.config.gdb_native_rust {\n-                    script_str.push_str(\"set language rust\\n\");\n-                }\n+            // Force GDB to print values in the Rust format.\n+            if self.config.gdb_native_rust {\n+                script_str.push_str(\"set language rust\\n\");\n+            }\n \n-                // Add line breakpoints\n-                for line in &breakpoint_lines {\n-                    script_str.push_str(&format!(\n-                        \"break '{}':{}\\n\",\n-                        self.testpaths.file.file_name().unwrap().to_string_lossy(),\n-                        *line\n-                    ));\n-                }\n+            // Add line breakpoints\n+            for line in &breakpoint_lines {\n+                script_str.push_str(&format!(\n+                    \"break '{}':{}\\n\",\n+                    self.testpaths.file.file_name().unwrap().to_string_lossy(),\n+                    *line\n+                ));\n+            }\n \n-                script_str.push_str(&cmds);\n-                script_str.push_str(\"\\nquit\\n\");\n+            script_str.push_str(&cmds);\n+            script_str.push_str(\"\\nquit\\n\");\n \n-                debug!(\"script_str = {}\", script_str);\n-                self.dump_output_file(&script_str, \"debugger.script\");\n+            debug!(\"script_str = {}\", script_str);\n+            self.dump_output_file(&script_str, \"debugger.script\");\n \n-                let debugger_script = self.make_out_name(\"debugger.script\");\n+            let debugger_script = self.make_out_name(\"debugger.script\");\n \n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                let debugger_opts = vec![\n-                    \"-quiet\".to_owned(),\n-                    \"-batch\".to_owned(),\n-                    \"-nx\".to_owned(),\n-                    format!(\"-command={}\", debugger_script.to_str().unwrap()),\n-                ];\n+            // FIXME (#9639): This needs to handle non-utf8 paths\n+            let debugger_opts = vec![\n+                \"-quiet\".to_owned(),\n+                \"-batch\".to_owned(),\n+                \"-nx\".to_owned(),\n+                format!(\"-command={}\", debugger_script.to_str().unwrap()),\n+            ];\n \n-                let mut gdb = Command::new(self.config.gdb.as_ref().unwrap());\n-                gdb.args(&debugger_opts)\n-                    .env(\"PYTHONPATH\", rust_pp_module_abs_path);\n+            let mut gdb = Command::new(self.config.gdb.as_ref().unwrap());\n+            gdb.args(&debugger_opts)\n+                .env(\"PYTHONPATH\", rust_pp_module_abs_path);\n \n-                debugger_run_result = self.compose_and_run(\n-                    gdb,\n-                    self.config.run_lib_path.to_str().unwrap(),\n-                    None,\n-                    None,\n-                );\n-            }\n+            debugger_run_result = self.compose_and_run(\n+                gdb,\n+                self.config.run_lib_path.to_str().unwrap(),\n+                None,\n+                None,\n+            );\n         }\n \n         if !debugger_run_result.status.success() {"}]}