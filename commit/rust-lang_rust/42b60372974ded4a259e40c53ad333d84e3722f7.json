{"sha": "42b60372974ded4a259e40c53ad333d84e3722f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYjYwMzcyOTc0ZGVkNGEyNTllNDBjNTNhZDMzM2Q4NGUzNzIyZjc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-25T23:53:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-25T23:53:23Z"}, "message": "rustc: Remove most of the code that generates shapes", "tree": {"sha": "2efc159b8e8d6518d4d39c80e4dc2e5b3b743e70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2efc159b8e8d6518d4d39c80e4dc2e5b3b743e70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42b60372974ded4a259e40c53ad333d84e3722f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42b60372974ded4a259e40c53ad333d84e3722f7", "html_url": "https://github.com/rust-lang/rust/commit/42b60372974ded4a259e40c53ad333d84e3722f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42b60372974ded4a259e40c53ad333d84e3722f7/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a66e23d236bfcfbd1fd1829565ce56d696b19b8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a66e23d236bfcfbd1fd1829565ce56d696b19b8b", "html_url": "https://github.com/rust-lang/rust/commit/a66e23d236bfcfbd1fd1829565ce56d696b19b8b"}], "stats": {"total": 376, "additions": 0, "deletions": 376}, "files": [{"sha": "7640cd095dc9b92866ef857ab4a1bdac44db8d9c", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 0, "deletions": 376, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/42b60372974ded4a259e40c53ad333d84e3722f7/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b60372974ded4a259e40c53ad333d84e3722f7/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=42b60372974ded4a259e40c53ad333d84e3722f7", "patch": "@@ -215,379 +215,3 @@ fn add_substr(&dest: ~[u8], src: ~[u8]) {\n     dest += src;\n }\n \n-fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n-    match ty::get(t).sty {\n-        ty::ty_nil | ty::ty_bool | ty::ty_uint(ast::ty_u8) |\n-        ty::ty_bot => ~[shape_u8],\n-        ty::ty_int(ast::ty_i) => ~[s_int(ccx.tcx)],\n-        ty::ty_float(ast::ty_f) => ~[s_float(ccx.tcx)],\n-        ty::ty_uint(ast::ty_u) | ty::ty_ptr(_) => ~[s_uint(ccx.tcx)],\n-        ty::ty_type => ~[s_tydesc(ccx.tcx)],\n-        ty::ty_int(ast::ty_i8) => ~[shape_i8],\n-        ty::ty_uint(ast::ty_u16) => ~[shape_u16],\n-        ty::ty_int(ast::ty_i16) => ~[shape_i16],\n-        ty::ty_uint(ast::ty_u32) => ~[shape_u32],\n-        ty::ty_int(ast::ty_i32) | ty::ty_int(ast::ty_char) => ~[shape_i32],\n-        ty::ty_uint(ast::ty_u64) => ~[shape_u64],\n-        ty::ty_int(ast::ty_i64) => ~[shape_i64],\n-        ty::ty_float(ast::ty_f32) => ~[shape_f32],\n-        ty::ty_float(ast::ty_f64) => ~[shape_f64],\n-        ty::ty_estr(ty::vstore_uniq) => {\n-            shape_of(ccx, tvec::expand_boxed_vec_ty(ccx.tcx, t))\n-        }\n-        ty::ty_enum(did, substs) => {\n-            match enum_kind(ccx, did) {\n-                tk_unit => ~[s_variant_enum_t(ccx.tcx)],\n-                tk_enum => ~[s_variant_enum_t(ccx.tcx)],\n-                tk_newtype | tk_complex => {\n-                    let mut s = ~[shape_enum], id;\n-                    let nom_id = mk_nominal_id(ccx.tcx, did,\n-                                               None, substs.tps);\n-                    match ccx.shape_cx.tag_id_to_index.find(nom_id) {\n-                        None => {\n-                            id = ccx.shape_cx.next_tag_id;\n-                            ccx.shape_cx.tag_id_to_index.insert(nom_id, id);\n-                            ccx.shape_cx.tag_order.push({did: did,\n-                                                         substs: substs});\n-                            ccx.shape_cx.next_tag_id += 1u16;\n-                        }\n-                        Some(existing_id) => id = existing_id,\n-                    }\n-                    add_u16(s, id as u16);\n-\n-                    s\n-                }\n-            }\n-        }\n-        ty::ty_estr(ty::vstore_box) |\n-        ty::ty_evec(_, ty::vstore_box) |\n-        ty::ty_box(_) | ty::ty_opaque_box => ~[shape_box],\n-        ty::ty_uniq(mt) => {\n-            let mut s = ~[shape_uniq];\n-            add_substr(s, shape_of(ccx, mt.ty));\n-            s\n-        }\n-        ty::ty_unboxed_vec(mt) => {\n-            let mut s = ~[shape_unboxed_vec];\n-            add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n-            add_substr(s, shape_of(ccx, mt.ty));\n-            s\n-        }\n-        ty::ty_evec(_, ty::vstore_uniq) => {\n-            shape_of(ccx, tvec::expand_boxed_vec_ty(ccx.tcx, t))\n-        }\n-\n-        ty::ty_estr(ty::vstore_fixed(n)) => {\n-            let mut s = ~[shape_fixedvec];\n-            let u8_t = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n-            assert (n + 1u) <= 0xffffu;\n-            add_u16(s, (n + 1u) as u16);\n-            add_bool(s, true);\n-            add_substr(s, shape_of(ccx, u8_t));\n-            s\n-        }\n-\n-        ty::ty_evec(mt, ty::vstore_fixed(n)) => {\n-            let mut s = ~[shape_fixedvec];\n-            assert n <= 0xffffu;\n-            add_u16(s, n as u16);\n-            add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n-            add_substr(s, shape_of(ccx, mt.ty));\n-            s\n-        }\n-\n-        ty::ty_estr(ty::vstore_slice(_)) => {\n-            let mut s = ~[shape_slice];\n-            let u8_t = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n-            add_bool(s, true); // is_pod\n-            add_bool(s, true); // is_str\n-            add_substr(s, shape_of(ccx, u8_t));\n-            s\n-        }\n-\n-        ty::ty_evec(mt, ty::vstore_slice(_)) => {\n-            let mut s = ~[shape_slice];\n-            add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n-            add_bool(s, false); // is_str\n-            add_substr(s, shape_of(ccx, mt.ty));\n-            s\n-        }\n-\n-        ty::ty_rec(fields) => {\n-            let mut s = ~[shape_struct], sub = ~[];\n-            for vec::each(fields) |f| {\n-                sub += shape_of(ccx, f.mt.ty);\n-            }\n-            add_substr(s, sub);\n-            s\n-        }\n-        ty::ty_tup(elts) => {\n-            let mut s = ~[shape_struct], sub = ~[];\n-            for vec::each(elts) |elt| {\n-                sub += shape_of(ccx, *elt);\n-            }\n-            add_substr(s, sub);\n-            s\n-        }\n-        ty::ty_trait(_, _, _) => ~[shape_box_fn],\n-        ty::ty_class(did, ref substs) => {\n-            // same as records, unless there's a dtor\n-            let tps = substs.tps;\n-            let m_dtor_did = ty::ty_dtor(ccx.tcx, did);\n-            let mut s = if m_dtor_did.is_some() {\n-                ~[shape_res]\n-            }\n-            else { ~[shape_struct] }, sub = ~[];\n-            do m_dtor_did.iter |dtor_did| {\n-                let ri = @{did: dtor_did, parent_id: Some(did), tps: tps};\n-                let id = ccx.shape_cx.resources.intern(ri);\n-                add_u16(s, id as u16);\n-            };\n-            for ty::class_items_as_mutable_fields(ccx.tcx, did,\n-                                                  substs).each |f| {\n-                sub += shape_of(ccx, f.mt.ty);\n-            }\n-            add_substr(s, sub);\n-            s\n-        }\n-        ty::ty_rptr(_, mt) => {\n-            let mut s = ~[shape_rptr];\n-            add_substr(s, shape_of(ccx, mt.ty));\n-            s\n-        }\n-        ty::ty_param(*) => {\n-            ccx.tcx.sess.bug(~\"non-monomorphized type parameter\");\n-        }\n-        ty::ty_fn(ref fn_ty) => {\n-            match fn_ty.meta.proto {\n-                ty::proto_vstore(ty::vstore_box) => ~[shape_box_fn],\n-                ty::proto_vstore(ty::vstore_uniq) => ~[shape_uniq_fn],\n-                ty::proto_vstore(ty::vstore_slice(_)) => ~[shape_stack_fn],\n-                ty::proto_bare => ~[shape_bare_fn],\n-                ty::proto_vstore(ty::vstore_fixed(_)) =>\n-                fail ~\"fixed vstore is impossible\",\n-            }\n-        }\n-        ty::ty_opaque_closure_ptr(_) => ~[shape_opaque_closure_ptr],\n-        ty::ty_infer(_) | ty::ty_self => {\n-            ccx.sess.bug(~\"shape_of: unexpected type struct found\")\n-        }\n-    }\n-}\n-\n-fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info) -> ~[u8] {\n-    let mut s = ~[];\n-    for vec::each(v.args) |t| { s += shape_of(ccx, *t); }\n-    return s;\n-}\n-\n-fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n-    // Loop over all the enum variants and write their shapes into a\n-    // data buffer. As we do this, it's possible for us to discover\n-    // new enums, so we must do this first.\n-    let mut data = ~[];\n-    let mut offsets = ~[];\n-    let mut i = 0u;\n-    let mut enum_variants = ~[];\n-    while i < ccx.shape_cx.tag_order.len() {\n-        let {did, substs} = ccx.shape_cx.tag_order[i];\n-        let variants = @ty::substd_enum_variants(ccx.tcx, did, &substs);\n-        for vec::each(*variants) |v| {\n-            offsets += ~[vec::len(data) as u16];\n-\n-            let variant_shape = shape_of_variant(ccx, *v);\n-            add_substr(data, variant_shape);\n-\n-            let zname = str::to_bytes(ccx.sess.str_of(v.name)) + ~[0u8];\n-            add_substr(data, zname);\n-        }\n-        enum_variants += ~[variants];\n-        i += 1u;\n-    }\n-\n-    // Now calculate the sizes of the header space (which contains offsets to\n-    // info records for each enum) and the info space (which contains offsets\n-    // to each variant shape). As we do so, build up the header.\n-\n-    let mut header = ~[];\n-    let mut inf = ~[];\n-    let header_sz = 2u16 * ccx.shape_cx.next_tag_id;\n-    let data_sz = vec::len(data) as u16;\n-\n-    let mut inf_sz = 0u16;\n-    for enum_variants.each |variants| {\n-        let num_variants = vec::len(**variants) as u16;\n-        add_u16(header, header_sz + inf_sz);\n-        inf_sz += 2u16 * (num_variants + 2u16) + 3u16;\n-    }\n-\n-    // Construct the info tables, which contain offsets to the shape of each\n-    // variant. Also construct the largest-variant table for each enum, which\n-    // contains the variants that the size-of operation needs to look at.\n-\n-    let mut lv_table = ~[];\n-    let mut i = 0u;\n-    for enum_variants.each |variants| {\n-        add_u16(inf, vec::len(**variants) as u16);\n-\n-        // Construct the largest-variants table.\n-        add_u16(inf,\n-                header_sz + inf_sz + data_sz + (vec::len(lv_table) as u16));\n-\n-        let lv = largest_variants(ccx, *variants);\n-        add_u16(lv_table, vec::len(lv) as u16);\n-        for vec::each(lv) |v| { add_u16(lv_table, *v as u16); }\n-\n-        // Determine whether the enum has dynamic size.\n-        assert !variants.any(|v| v.args.any(|t| ty::type_has_params(t)));\n-\n-        // If we can, write in the static size and alignment of the enum.\n-        // Otherwise, write a placeholder.\n-        let size_align = compute_static_enum_size(ccx, lv, *variants);\n-\n-        // Write in the static size and alignment of the enum.\n-        add_u16(inf, size_align.size);\n-        inf += ~[size_align.align];\n-\n-        // Now write in the offset of each variant.\n-        for variants.each |_v| {\n-            add_u16(inf, header_sz + inf_sz + offsets[i]);\n-            i += 1u;\n-        }\n-    }\n-\n-    assert (i == vec::len(offsets));\n-    assert (header_sz == vec::len(header) as u16);\n-    assert (inf_sz == vec::len(inf) as u16);\n-    assert (data_sz == vec::len(data) as u16);\n-\n-    header += inf;\n-    header += data;\n-    header += lv_table;\n-\n-    return mk_global(ccx, ~\"tag_shapes\", C_bytes(header), true);\n-\n-/* tjc: Not annotating FIXMEs in this module because of #1498 */\n-    fn largest_variants(ccx: @crate_ctxt,\n-                        variants: @~[ty::variant_info]) -> ~[uint] {\n-        // Compute the minimum and maximum size and alignment for each\n-        // variant.\n-        //\n-        // NB: We could do better here; e.g. we know that any\n-        // variant that contains (T,T) must be as least as large as\n-        // any variant that contains just T.\n-        let mut ranges = ~[];\n-        for vec::each(*variants) |variant| {\n-            let mut bounded = true;\n-            let mut min_size = 0u, min_align = 0u;\n-            for vec::each(variant.args) |elem_t| {\n-                if ty::type_has_params(*elem_t) {\n-                    // NB: We could do better here; this causes us to\n-                    // conservatively assume that (int, T) has minimum size 0,\n-                    // when in fact it has minimum size sizeof(int).\n-                    bounded = false;\n-                } else {\n-                    let llty = type_of::type_of(ccx, *elem_t);\n-                    min_size += llsize_of_real(ccx, llty);\n-                    min_align += llalign_of_pref(ccx, llty);\n-                }\n-            }\n-\n-            ranges +=\n-                ~[{size: {min: min_size, bounded: bounded},\n-                  align: {min: min_align, bounded: bounded}}];\n-        }\n-\n-        // Initialize the candidate set to contain all variants.\n-        let mut candidates = ~[mut];\n-        for vec::each(*variants) |_v| { candidates += ~[mut true]; }\n-\n-        // Do a pairwise comparison among all variants still in the\n-        // candidate set.  Throw out any variant that we know has size\n-        // and alignment at least as small as some other variant.\n-        let mut i = 0u;\n-        while i < vec::len(ranges) - 1u {\n-            if candidates[i] {\n-                let mut j = i + 1u;\n-                while j < vec::len(ranges) {\n-                    if candidates[j] {\n-                        if ranges[i].size.bounded &&\n-                            ranges[i].align.bounded &&\n-                            ranges[j].size.bounded &&\n-                            ranges[j].align.bounded {\n-                            if ranges[i].size.min >= ranges[j].size.min &&\n-                                ranges[i].align.min >= ranges[j].align.min {\n-                                // Throw out j.\n-                                candidates[j] = false;\n-                            } else if ranges[j].size.min >=\n-                                    ranges[i].size.min &&\n-                                ranges[j].align.min >=\n-                                    ranges[j].align.min {\n-                                // Throw out i.\n-                                candidates[i] = false;\n-                            }\n-                        }\n-                    }\n-                    j += 1u;\n-                }\n-            }\n-            i += 1u;\n-        }\n-\n-        // Return the resulting set.\n-        let mut result = ~[];\n-        let mut i = 0u;\n-        while i < vec::len(candidates) {\n-            if candidates[i] { vec::push(result, i); }\n-            i += 1u;\n-        }\n-        return result;\n-    }\n-\n-    fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: ~[uint],\n-                                variants: @~[ty::variant_info])\n-        -> size_align {\n-        let mut max_size = 0u16;\n-        let mut max_align = 1u8;\n-        for vec::each(largest_variants) |vid| {\n-            // We increment a \"virtual data pointer\" to compute the size.\n-            let mut lltys = ~[];\n-            for vec::each(variants[*vid].args) |typ| {\n-                lltys += ~[type_of::type_of(ccx, *typ)];\n-            }\n-\n-            let llty = trans::common::T_struct(lltys);\n-            let dp = llsize_of_real(ccx, llty) as u16;\n-            let variant_align = llalign_of_pref(ccx, llty) as u8;\n-\n-            if max_size < dp { max_size = dp; }\n-            if max_align < variant_align { max_align = variant_align; }\n-        }\n-\n-        // Add space for the enum if applicable.\n-        // FIXME (issue #792): This is wrong. If the enum starts with an\n-        // 8 byte aligned quantity, we don't align it.\n-        if vec::len(*variants) > 1u {\n-            let variant_t = T_enum_discrim(ccx);\n-            max_size += llsize_of_real(ccx, variant_t) as u16;\n-            let align = llalign_of_pref(ccx, variant_t) as u8;\n-            if max_align < align { max_align = align; }\n-        }\n-\n-        return {size: max_size, align: max_align};\n-    }\n-}\n-\n-fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n-    let mut dtors = ~[];\n-    let len = ccx.shape_cx.resources.len();\n-    for uint::range(0u, len) |i| {\n-        let ri = ccx.shape_cx.resources.get(i);\n-        for ri.tps.each() |s| { assert !ty::type_has_params(*s); }\n-        do ri.parent_id.iter |id| {\n-            dtors += ~[trans::base::get_res_dtor(ccx, ri.did, id, ri.tps)];\n-        }\n-    }\n-    return mk_global(ccx, ~\"resource_shapes\", C_struct(dtors), true);\n-}\n-"}]}