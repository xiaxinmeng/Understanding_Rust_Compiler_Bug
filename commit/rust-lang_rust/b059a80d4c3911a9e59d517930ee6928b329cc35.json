{"sha": "b059a80d4c3911a9e59d517930ee6928b329cc35", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNTlhODBkNGMzOTExYTllNTlkNTE3OTMwZWU2OTI4YjMyOWNjMzU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-12-29T00:23:38Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-12-29T05:17:07Z"}, "message": "Support --emit=foo,metadata", "tree": {"sha": "72ce2210b39c5a7880ed7e625da09a6588baf2f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72ce2210b39c5a7880ed7e625da09a6588baf2f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b059a80d4c3911a9e59d517930ee6928b329cc35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b059a80d4c3911a9e59d517930ee6928b329cc35", "html_url": "https://github.com/rust-lang/rust/commit/b059a80d4c3911a9e59d517930ee6928b329cc35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b059a80d4c3911a9e59d517930ee6928b329cc35/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c8916661105322df7774378a264eb25b873401b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c8916661105322df7774378a264eb25b873401b", "html_url": "https://github.com/rust-lang/rust/commit/9c8916661105322df7774378a264eb25b873401b"}], "stats": {"total": 92, "additions": 66, "deletions": 26}, "files": [{"sha": "e60d0533c9f8166be71f6991e22e84c36a43ab71", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b059a80d4c3911a9e59d517930ee6928b329cc35/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b059a80d4c3911a9e59d517930ee6928b329cc35/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=b059a80d4c3911a9e59d517930ee6928b329cc35", "patch": "@@ -103,7 +103,7 @@ pub fn calculate(sess: &session::Session) {\n \n fn calculate_type(sess: &session::Session,\n                   ty: config::CrateType) -> DependencyList {\n-    if sess.opts.output_types.contains_key(&config::OutputType::Metadata) {\n+    if !sess.opts.output_types.should_trans() {\n         return Vec::new();\n     }\n "}, {"sha": "b3cb5ace45bc04e702d8b16a506f48f1b9277cea", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b059a80d4c3911a9e59d517930ee6928b329cc35/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b059a80d4c3911a9e59d517930ee6928b329cc35/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=b059a80d4c3911a9e59d517930ee6928b329cc35", "patch": "@@ -156,6 +156,19 @@ impl OutputTypes {\n     pub fn values<'a>(&'a self) -> BTreeMapValuesIter<'a, OutputType, Option<PathBuf>> {\n         self.0.values()\n     }\n+\n+    // True if any of the output types require codegen or linking.\n+    pub fn should_trans(&self) -> bool {\n+        self.0.keys().any(|k| match *k {\n+            OutputType::Bitcode |\n+            OutputType::Assembly |\n+            OutputType::LlvmAssembly |\n+            OutputType::Object |\n+            OutputType::Exe => true,\n+            OutputType::Metadata |\n+            OutputType::DepInfo => false,\n+        })\n+    }\n }\n \n "}, {"sha": "defbb44448a9f3a5f4b7ce77ecc494086f5a9f61", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 52, "deletions": 25, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b059a80d4c3911a9e59d517930ee6928b329cc35/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b059a80d4c3911a9e59d517930ee6928b329cc35/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=b059a80d4c3911a9e59d517930ee6928b329cc35", "patch": "@@ -192,7 +192,7 @@ pub fn link_binary(sess: &Session,\n     for &crate_type in sess.crate_types.borrow().iter() {\n         // Ignore executable crates if we have -Z no-trans, as they will error.\n         if (sess.opts.debugging_opts.no_trans ||\n-            sess.opts.output_types.contains_key(&OutputType::Metadata)) &&\n+            !sess.opts.output_types.should_trans()) &&\n            crate_type == config::CrateTypeExecutable {\n             continue;\n         }\n@@ -201,13 +201,13 @@ pub fn link_binary(sess: &Session,\n            bug!(\"invalid output type `{:?}` for target os `{}`\",\n                 crate_type, sess.opts.target_triple);\n         }\n-        let out_file = link_binary_output(sess, trans, crate_type, outputs, crate_name);\n-        out_filenames.push(out_file);\n+        let mut out_files = link_binary_output(sess, trans, crate_type, outputs, crate_name);\n+        out_filenames.append(&mut out_files);\n     }\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n-        if !sess.opts.output_types.contains_key(&OutputType::Metadata) {\n+        if sess.opts.output_types.should_trans() {\n             for obj in object_filenames(trans, outputs) {\n                 remove(sess, &obj);\n             }\n@@ -256,16 +256,21 @@ fn is_writeable(p: &Path) -> bool {\n     }\n }\n \n+fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilenames) -> PathBuf {\n+    let out_filename = outputs.single_output_file.clone()\n+        .unwrap_or(outputs\n+            .out_directory\n+            .join(&format!(\"lib{}{}.rmeta\", crate_name, sess.opts.cg.extra_filename)));\n+    check_file_is_writeable(&out_filename, sess);\n+    out_filename\n+}\n+\n pub fn filename_for_input(sess: &Session,\n                           crate_type: config::CrateType,\n                           crate_name: &str,\n                           outputs: &OutputFilenames) -> PathBuf {\n     let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n \n-    if outputs.outputs.contains_key(&OutputType::Metadata) {\n-        return outputs.out_directory.join(&format!(\"lib{}.rmeta\", libname));\n-    }\n-\n     match crate_type {\n         config::CrateTypeRlib => {\n             outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n@@ -327,37 +332,58 @@ pub fn each_linked_rlib(sess: &Session,\n     }\n }\n \n+fn out_filename(sess: &Session,\n+                crate_type: config::CrateType,\n+                outputs: &OutputFilenames,\n+                crate_name: &str)\n+                -> PathBuf {\n+    let default_filename = filename_for_input(sess, crate_type, crate_name, outputs);\n+    let out_filename = outputs.outputs.get(&OutputType::Exe)\n+                              .and_then(|s| s.to_owned())\n+                              .or_else(|| outputs.single_output_file.clone())\n+                              .unwrap_or(default_filename);\n+\n+    check_file_is_writeable(&out_filename, sess);\n+\n+    out_filename\n+}\n+\n+// Make sure files are writeable.  Mac, FreeBSD, and Windows system linkers\n+// check this already -- however, the Linux linker will happily overwrite a\n+// read-only file.  We should be consistent.\n+fn check_file_is_writeable(file: &Path, sess: &Session) {\n+    if !is_writeable(file) {\n+        sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n+                            permissions\", file.display()));\n+    }\n+}\n+\n fn link_binary_output(sess: &Session,\n                       trans: &CrateTranslation,\n                       crate_type: config::CrateType,\n                       outputs: &OutputFilenames,\n-                      crate_name: &str) -> PathBuf {\n+                      crate_name: &str) -> Vec<PathBuf> {\n     let objects = object_filenames(trans, outputs);\n-    let default_filename = filename_for_input(sess, crate_type, crate_name,\n-                                              outputs);\n-    let out_filename = outputs.outputs.get(&OutputType::Exe)\n-                              .and_then(|s| s.to_owned())\n-                              .or_else(|| outputs.single_output_file.clone())\n-                              .unwrap_or(default_filename);\n \n-    // Make sure files are writeable.  Mac, FreeBSD, and Windows system linkers\n-    // check this already -- however, the Linux linker will happily overwrite a\n-    // read-only file.  We should be consistent.\n-    for file in objects.iter().chain(Some(&out_filename)) {\n-        if !is_writeable(file) {\n-            sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n-                                permissions\", file.display()));\n-        }\n+    for file in &objects {\n+        check_file_is_writeable(file, sess);\n     }\n \n     let tmpdir = match TempDir::new(\"rustc\") {\n         Ok(tmpdir) => tmpdir,\n         Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n     };\n \n+    let mut out_filenames = vec![];\n+\n     if outputs.outputs.contains_key(&OutputType::Metadata) {\n+        let out_filename = filename_for_metadata(sess, crate_name, outputs);\n         emit_metadata(sess, trans, &out_filename);\n-    } else {\n+        out_filenames.push(out_filename);\n+    }\n+\n+    if outputs.outputs.should_trans() {\n+        let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n         match crate_type {\n             config::CrateTypeRlib => {\n                 link_rlib(sess, Some(trans), &objects, &out_filename,\n@@ -371,9 +397,10 @@ fn link_binary_output(sess: &Session,\n                               outputs, tmpdir.path());\n             }\n         }\n+        out_filenames.push(out_filename);\n     }\n \n-    out_filename\n+    out_filenames\n }\n \n fn object_filenames(trans: &CrateTranslation,"}]}