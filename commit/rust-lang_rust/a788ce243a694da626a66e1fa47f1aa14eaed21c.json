{"sha": "a788ce243a694da626a66e1fa47f1aa14eaed21c", "node_id": "C_kwDOAAsO6NoAKGE3ODhjZTI0M2E2OTRkYTYyNmE2NmUxZmE0N2YxYWExNGVhZWQyMWM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-01-25T11:31:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-25T11:31:42Z"}, "message": "Rollup merge of #107166 - petrochenkov:nooptable, r=oli-obk\n\nrustc_metadata: Support non-`Option` nullable values in metadata tables\n\nThis is a convenience feature for cases in which \"no value in the table\" and \"default value in the table\" are equivalent.\nTables using `Table<DefIndex, ()>` are migrated in this PR, some other cases can be migrated later.\nThis helps `DocFlags` in https://github.com/rust-lang/rust/pull/107136 in particular.", "tree": {"sha": "26748e98a04430e430ae2684ff72a48c3905860a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26748e98a04430e430ae2684ff72a48c3905860a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a788ce243a694da626a66e1fa47f1aa14eaed21c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj0RMeCRBK7hj4Ov3rIwAAxCcIAARYcgj3pZrx9ZXW99a61uSk\n2YQqkt1bGVgtljjWGSIvkUClb4PST1T3mXMWeABQhnZmfaclUKfDu8yWcZNwUdSf\nlH+v5zkjgKGA+pqngBO+29sQ19W6WY98xjoY1Vy3RfcKaDWL77dYevRXpOtGLUk8\n24ZUw4YV67LgmwQee2LkDh4rK1M1SNULsBzxmgGSGhM7ROKwtcdHRcrKKiF47btb\n+vVVKbTepuujVC1/EA7cDOHZZQv1n8lmJi3hkE0GJMXJNyRTxP22ClLWq+Y4WZRP\nQIU/ItR5K07sJGeKVPsQDnrL+85kZZQWQiN5XYL5ahxCjZh4YeWi4+0joaVsCR8=\n=Jbav\n-----END PGP SIGNATURE-----\n", "payload": "tree 26748e98a04430e430ae2684ff72a48c3905860a\nparent 0c53b215de0c57833756300e81ac9c5f84a541a3\nparent 91fdbd73437aa53d1cc74faa41ae62951839f13a\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1674646302 +0530\ncommitter GitHub <noreply@github.com> 1674646302 +0530\n\nRollup merge of #107166 - petrochenkov:nooptable, r=oli-obk\n\nrustc_metadata: Support non-`Option` nullable values in metadata tables\n\nThis is a convenience feature for cases in which \"no value in the table\" and \"default value in the table\" are equivalent.\nTables using `Table<DefIndex, ()>` are migrated in this PR, some other cases can be migrated later.\nThis helps `DocFlags` in https://github.com/rust-lang/rust/pull/107136 in particular.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a788ce243a694da626a66e1fa47f1aa14eaed21c", "html_url": "https://github.com/rust-lang/rust/commit/a788ce243a694da626a66e1fa47f1aa14eaed21c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a788ce243a694da626a66e1fa47f1aa14eaed21c/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c53b215de0c57833756300e81ac9c5f84a541a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c53b215de0c57833756300e81ac9c5f84a541a3", "html_url": "https://github.com/rust-lang/rust/commit/0c53b215de0c57833756300e81ac9c5f84a541a3"}, {"sha": "91fdbd73437aa53d1cc74faa41ae62951839f13a", "url": "https://api.github.com/repos/rust-lang/rust/commits/91fdbd73437aa53d1cc74faa41ae62951839f13a", "html_url": "https://github.com/rust-lang/rust/commit/91fdbd73437aa53d1cc74faa41ae62951839f13a"}], "stats": {"total": 140, "additions": 64, "deletions": 76}, "files": [{"sha": "bb2dd290c6d5d1edef0ef7f26ae3f0bbb1793d69", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a788ce243a694da626a66e1fa47f1aa14eaed21c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a788ce243a694da626a66e1fa47f1aa14eaed21c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=a788ce243a694da626a66e1fa47f1aa14eaed21c", "patch": "@@ -985,7 +985,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         let vis = self.get_visibility(id);\n         let span = self.get_span(id, sess);\n         let macro_rules = match kind {\n-            DefKind::Macro(..) => self.root.tables.macro_rules.get(self, id).is_some(),\n+            DefKind::Macro(..) => self.root.tables.is_macro_rules.get(self, id),\n             _ => false,\n         };\n \n@@ -1283,7 +1283,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn get_macro(self, id: DefIndex, sess: &Session) -> ast::MacroDef {\n         match self.def_kind(id) {\n             DefKind::Macro(_) => {\n-                let macro_rules = self.root.tables.macro_rules.get(self, id).is_some();\n+                let macro_rules = self.root.tables.is_macro_rules.get(self, id);\n                 let body =\n                     self.root.tables.macro_definition.get(self, id).unwrap().decode((self, sess));\n                 ast::MacroDef { macro_rules, body: ast::ptr::P(body) }\n@@ -1595,11 +1595,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_attr_flags(self, index: DefIndex) -> AttrFlags {\n-        self.root.tables.attr_flags.get(self, index).unwrap_or(AttrFlags::empty())\n+        self.root.tables.attr_flags.get(self, index)\n     }\n \n     fn get_is_intrinsic(self, index: DefIndex) -> bool {\n-        self.root.tables.is_intrinsic.get(self, index).is_some()\n+        self.root.tables.is_intrinsic.get(self, index)\n     }\n }\n "}, {"sha": "eebc2f21dfe4e8e4a79cc888f0aa41c8147d335e", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a788ce243a694da626a66e1fa47f1aa14eaed21c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a788ce243a694da626a66e1fa47f1aa14eaed21c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=a788ce243a694da626a66e1fa47f1aa14eaed21c", "patch": "@@ -226,12 +226,7 @@ provide! { tcx, def_id, other, cdata,\n     deduced_param_attrs => { table }\n     is_type_alias_impl_trait => {\n         debug_assert_eq!(tcx.def_kind(def_id), DefKind::OpaqueTy);\n-        cdata\n-            .root\n-            .tables\n-            .is_type_alias_impl_trait\n-            .get(cdata, def_id.index)\n-            .is_some()\n+        cdata.root.tables.is_type_alias_impl_trait.get(cdata, def_id.index)\n     }\n     collect_return_position_impl_trait_in_trait_tys => {\n         Ok(cdata"}, {"sha": "97f0457ba711677e0ea326bb1d099460da3672b9", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a788ce243a694da626a66e1fa47f1aa14eaed21c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a788ce243a694da626a66e1fa47f1aa14eaed21c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=a788ce243a694da626a66e1fa47f1aa14eaed21c", "patch": "@@ -483,7 +483,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy(DefPathHashMapRef::BorrowedFromTcx(self.tcx.def_path_hash_to_def_index_map()))\n     }\n \n-    fn encode_source_map(&mut self) -> LazyTable<u32, LazyValue<rustc_span::SourceFile>> {\n+    fn encode_source_map(&mut self) -> LazyTable<u32, Option<LazyValue<rustc_span::SourceFile>>> {\n         let source_map = self.tcx.sess.source_map();\n         let all_source_files = source_map.files();\n \n@@ -1130,7 +1130,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             attr_flags |= AttrFlags::IS_DOC_HIDDEN;\n         }\n         if !attr_flags.is_empty() {\n-            self.tables.attr_flags.set(def_id.local_def_index, attr_flags);\n+            self.tables.attr_flags.set_nullable(def_id.local_def_index, attr_flags);\n         }\n     }\n \n@@ -1387,7 +1387,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         if impl_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set(def_id.index, ());\n+                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n             }\n         }\n     }\n@@ -1519,7 +1519,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 if macro_def.macro_rules {\n-                    self.tables.macro_rules.set(def_id.index, ());\n+                    self.tables.is_macro_rules.set_nullable(def_id.index, true);\n                 }\n                 record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n@@ -1529,7 +1529,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::OpaqueTy(ref opaque) => {\n                 self.encode_explicit_item_bounds(def_id);\n                 if matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias) {\n-                    self.tables.is_type_alias_impl_trait.set(def_id.index, ());\n+                    self.tables.is_type_alias_impl_trait.set_nullable(def_id.index, true);\n                 }\n             }\n             hir::ItemKind::Enum(..) => {\n@@ -1636,7 +1636,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         if let hir::ItemKind::Fn(..) = item.kind {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set(def_id.index, ());\n+                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n             }\n         }\n         if let hir::ItemKind::Impl { .. } = item.kind {\n@@ -2038,7 +2038,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n             if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set(def_id.index, ());\n+                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n             }\n         }\n     }"}, {"sha": "698b2ebc4732a0d0d66c60bc8a1277b973a30b46", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a788ce243a694da626a66e1fa47f1aa14eaed21c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a788ce243a694da626a66e1fa47f1aa14eaed21c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=a788ce243a694da626a66e1fa47f1aa14eaed21c", "patch": "@@ -185,9 +185,9 @@ enum LazyState {\n     Previous(NonZeroUsize),\n }\n \n-type SyntaxContextTable = LazyTable<u32, LazyValue<SyntaxContextData>>;\n-type ExpnDataTable = LazyTable<ExpnIndex, LazyValue<ExpnData>>;\n-type ExpnHashTable = LazyTable<ExpnIndex, LazyValue<ExpnHash>>;\n+type SyntaxContextTable = LazyTable<u32, Option<LazyValue<SyntaxContextData>>>;\n+type ExpnDataTable = LazyTable<ExpnIndex, Option<LazyValue<ExpnData>>>;\n+type ExpnHashTable = LazyTable<ExpnIndex, Option<LazyValue<ExpnHash>>>;\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n pub(crate) struct ProcMacroData {\n@@ -253,7 +253,7 @@ pub(crate) struct CrateRoot {\n \n     def_path_hash_map: LazyValue<DefPathHashMapRef<'static>>,\n \n-    source_map: LazyTable<u32, LazyValue<rustc_span::SourceFile>>,\n+    source_map: LazyTable<u32, Option<LazyValue<rustc_span::SourceFile>>>,\n \n     compiler_builtins: bool,\n     needs_allocator: bool,\n@@ -315,31 +315,43 @@ pub(crate) struct IncoherentImpls {\n \n /// Define `LazyTables` and `TableBuilders` at the same time.\n macro_rules! define_tables {\n-    ($($name:ident: Table<$IDX:ty, $T:ty>),+ $(,)?) => {\n+    (\n+        - nullable: $($name1:ident: Table<$IDX1:ty, $T1:ty>,)+\n+        - optional: $($name2:ident: Table<$IDX2:ty, $T2:ty>,)+\n+    ) => {\n         #[derive(MetadataEncodable, MetadataDecodable)]\n         pub(crate) struct LazyTables {\n-            $($name: LazyTable<$IDX, $T>),+\n+            $($name1: LazyTable<$IDX1, $T1>,)+\n+            $($name2: LazyTable<$IDX2, Option<$T2>>,)+\n         }\n \n         #[derive(Default)]\n         struct TableBuilders {\n-            $($name: TableBuilder<$IDX, $T>),+\n+            $($name1: TableBuilder<$IDX1, $T1>,)+\n+            $($name2: TableBuilder<$IDX2, Option<$T2>>,)+\n         }\n \n         impl TableBuilders {\n             fn encode(&self, buf: &mut FileEncoder) -> LazyTables {\n                 LazyTables {\n-                    $($name: self.$name.encode(buf)),+\n+                    $($name1: self.$name1.encode(buf),)+\n+                    $($name2: self.$name2.encode(buf),)+\n                 }\n             }\n         }\n     }\n }\n \n define_tables! {\n+- nullable:\n+    is_intrinsic: Table<DefIndex, bool>,\n+    is_macro_rules: Table<DefIndex, bool>,\n+    is_type_alias_impl_trait: Table<DefIndex, bool>,\n+    attr_flags: Table<DefIndex, AttrFlags>,\n+\n+- optional:\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,\n     children: Table<DefIndex, LazyArray<DefIndex>>,\n-\n     opt_def_kind: Table<DefIndex, DefKind>,\n     visibility: Table<DefIndex, LazyValue<ty::Visibility<DefIndex>>>,\n     def_span: Table<DefIndex, LazyValue<Span>>,\n@@ -370,7 +382,6 @@ define_tables! {\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n     constness: Table<DefIndex, hir::Constness>,\n-    is_intrinsic: Table<DefIndex, ()>,\n     impl_defaultness: Table<DefIndex, hir::Defaultness>,\n     // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n     coerce_unsized_info: Table<DefIndex, LazyValue<ty::adjustment::CoerceUnsizedInfo>>,\n@@ -380,7 +391,6 @@ define_tables! {\n     fn_arg_names: Table<DefIndex, LazyArray<Ident>>,\n     generator_kind: Table<DefIndex, LazyValue<hir::GeneratorKind>>,\n     trait_def: Table<DefIndex, LazyValue<ty::TraitDef>>,\n-\n     trait_item_def_id: Table<DefIndex, RawDefId>,\n     inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n     expn_that_defined: Table<DefIndex, LazyValue<ExpnId>>,\n@@ -395,18 +405,12 @@ define_tables! {\n     def_path_hashes: Table<DefIndex, DefPathHash>,\n     proc_macro_quoted_spans: Table<usize, LazyValue<Span>>,\n     generator_diagnostic_data: Table<DefIndex, LazyValue<GeneratorDiagnosticData<'static>>>,\n-    attr_flags: Table<DefIndex, AttrFlags>,\n     variant_data: Table<DefIndex, LazyValue<VariantData>>,\n     assoc_container: Table<DefIndex, ty::AssocItemContainer>,\n-    // Slot is full when macro is macro_rules.\n-    macro_rules: Table<DefIndex, ()>,\n     macro_definition: Table<DefIndex, LazyValue<ast::DelimArgs>>,\n     proc_macro: Table<DefIndex, MacroKind>,\n     module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n     deduced_param_attrs: Table<DefIndex, LazyArray<DeducedParamAttrs>>,\n-    // Slot is full when opaque is TAIT.\n-    is_type_alias_impl_trait: Table<DefIndex, ()>,\n-\n     trait_impl_trait_tys: Table<DefIndex, LazyValue<FxHashMap<DefId, Ty<'static>>>>,\n }\n \n@@ -419,6 +423,7 @@ struct VariantData {\n }\n \n bitflags::bitflags! {\n+    #[derive(Default)]\n     pub struct AttrFlags: u8 {\n         const MAY_HAVE_DOC_LINKS = 1 << 0;\n         const IS_DOC_HIDDEN      = 1 << 1;"}, {"sha": "70dbf6476e2fab40d8c4a89b575528b3bd3f6f6b", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 30, "deletions": 42, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a788ce243a694da626a66e1fa47f1aa14eaed21c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a788ce243a694da626a66e1fa47f1aa14eaed21c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=a788ce243a694da626a66e1fa47f1aa14eaed21c", "patch": "@@ -16,6 +16,7 @@ use std::num::NonZeroUsize;\n /// but this has no impact on safety.\n pub(super) trait FixedSizeEncoding: Default {\n     /// This should be `[u8; BYTE_LEN]`;\n+    /// Cannot use an associated `const BYTE_LEN: usize` instead due to const eval limitations.\n     type ByteArray;\n \n     fn from_bytes(b: &Self::ByteArray) -> Self;\n@@ -199,31 +200,31 @@ impl FixedSizeEncoding for Option<RawDefId> {\n     }\n }\n \n-impl FixedSizeEncoding for Option<AttrFlags> {\n+impl FixedSizeEncoding for AttrFlags {\n     type ByteArray = [u8; 1];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 1]) -> Self {\n-        (b[0] != 0).then(|| AttrFlags::from_bits_truncate(b[0]))\n+        AttrFlags::from_bits_truncate(b[0])\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 1]) {\n-        b[0] = self.map_or(0, |flags| flags.bits())\n+        b[0] = self.bits();\n     }\n }\n \n-impl FixedSizeEncoding for Option<()> {\n+impl FixedSizeEncoding for bool {\n     type ByteArray = [u8; 1];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 1]) -> Self {\n-        (b[0] != 0).then(|| ())\n+        b[0] != 0\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 1]) {\n-        b[0] = self.is_some() as u8\n+        b[0] = self as u8\n     }\n }\n \n@@ -273,44 +274,38 @@ impl<T> FixedSizeEncoding for Option<LazyArray<T>> {\n }\n \n /// Helper for constructing a table's serialization (also see `Table`).\n-pub(super) struct TableBuilder<I: Idx, T>\n-where\n-    Option<T>: FixedSizeEncoding,\n-{\n-    blocks: IndexVec<I, <Option<T> as FixedSizeEncoding>::ByteArray>,\n+pub(super) struct TableBuilder<I: Idx, T: FixedSizeEncoding> {\n+    blocks: IndexVec<I, T::ByteArray>,\n     _marker: PhantomData<T>,\n }\n \n-impl<I: Idx, T> Default for TableBuilder<I, T>\n-where\n-    Option<T>: FixedSizeEncoding,\n-{\n+impl<I: Idx, T: FixedSizeEncoding> Default for TableBuilder<I, T> {\n     fn default() -> Self {\n         TableBuilder { blocks: Default::default(), _marker: PhantomData }\n     }\n }\n \n-impl<I: Idx, T> TableBuilder<I, T>\n+impl<I: Idx, const N: usize, T> TableBuilder<I, Option<T>>\n where\n-    Option<T>: FixedSizeEncoding,\n+    Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n {\n-    pub(crate) fn set<const N: usize>(&mut self, i: I, value: T)\n-    where\n-        Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n-    {\n+    pub(crate) fn set(&mut self, i: I, value: T) {\n+        self.set_nullable(i, Some(value))\n+    }\n+}\n+\n+impl<I: Idx, const N: usize, T: FixedSizeEncoding<ByteArray = [u8; N]>> TableBuilder<I, T> {\n+    pub(crate) fn set_nullable(&mut self, i: I, value: T) {\n         // FIXME(eddyb) investigate more compact encodings for sparse tables.\n         // On the PR @michaelwoerister mentioned:\n         // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n         // > trick (i.e. divide things into buckets of 32 or 64 items and then\n         // > store bit-masks of which item in each bucket is actually serialized).\n         self.blocks.ensure_contains_elem(i, || [0; N]);\n-        Some(value).write_to_bytes(&mut self.blocks[i]);\n+        value.write_to_bytes(&mut self.blocks[i]);\n     }\n \n-    pub(crate) fn encode<const N: usize>(&self, buf: &mut FileEncoder) -> LazyTable<I, T>\n-    where\n-        Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n-    {\n+    pub(crate) fn encode(&self, buf: &mut FileEncoder) -> LazyTable<I, T> {\n         let pos = buf.position();\n         for block in &self.blocks {\n             buf.emit_raw_bytes(block);\n@@ -323,34 +318,27 @@ where\n     }\n }\n \n-impl<I: Idx, T: ParameterizedOverTcx> LazyTable<I, T>\n+impl<I: Idx, const N: usize, T: FixedSizeEncoding<ByteArray = [u8; N]> + ParameterizedOverTcx>\n+    LazyTable<I, T>\n where\n-    Option<T>: FixedSizeEncoding,\n+    for<'tcx> T::Value<'tcx>: FixedSizeEncoding<ByteArray = [u8; N]>,\n {\n     /// Given the metadata, extract out the value at a particular index (if any).\n     #[inline(never)]\n-    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>, const N: usize>(\n-        &self,\n-        metadata: M,\n-        i: I,\n-    ) -> Option<T::Value<'tcx>>\n-    where\n-        Option<T::Value<'tcx>>: FixedSizeEncoding<ByteArray = [u8; N]>,\n-    {\n+    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(&self, metadata: M, i: I) -> T::Value<'tcx> {\n         debug!(\"LazyTable::lookup: index={:?} len={:?}\", i, self.encoded_size);\n \n         let start = self.position.get();\n         let bytes = &metadata.blob()[start..start + self.encoded_size];\n         let (bytes, []) = bytes.as_chunks::<N>() else { panic!() };\n-        let bytes = bytes.get(i.index())?;\n-        FixedSizeEncoding::from_bytes(bytes)\n+        match bytes.get(i.index()) {\n+            Some(bytes) => FixedSizeEncoding::from_bytes(bytes),\n+            None => FixedSizeEncoding::from_bytes(&[0; N]),\n+        }\n     }\n \n     /// Size of the table in entries, including possible gaps.\n-    pub(super) fn size<const N: usize>(&self) -> usize\n-    where\n-        for<'tcx> Option<T::Value<'tcx>>: FixedSizeEncoding<ByteArray = [u8; N]>,\n-    {\n+    pub(super) fn size(&self) -> usize {\n         self.encoded_size / N\n     }\n }"}]}