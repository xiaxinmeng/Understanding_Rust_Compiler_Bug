{"sha": "fd774dbba3068b5915ebb8d216a34a63bc974121", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNzc0ZGJiYTMwNjhiNTkxNWViYjhkMjE2YTM0YTYzYmM5NzQxMjE=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-02-24T23:47:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-24T23:47:32Z"}, "message": "Merge pull request #2485 from topecongiro/attr\n\nAdd `attr` modules and allow `#[name = value]` to exceed max width", "tree": {"sha": "a0fada6238a2b9c10bf535d91618fd7e5d58d586", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0fada6238a2b9c10bf535d91618fd7e5d58d586"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd774dbba3068b5915ebb8d216a34a63bc974121", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJakfmUCRBK7hj4Ov3rIwAAdHIIAB3HiRfmLALPmwKBbgAKW4Dz\nDXxAUsSg65A1DCvX63LEDwvCIE582lHwhVNCt2hakskHHLXb6xVlb1VUZ3FC7dDX\n8fp7UrhB6T7qO3MDrS5/7yX0T1RCuskzj+ynP0XuAshG3/XA1AJ3kjJu6CYDtl0V\nAkLQRFvncs8RTX5OQgo7u0L2R0xGdNUzZYcj9sj/un7YInmZejNCWsvTCnPX32Mu\nr3YtQD3RRGJhaiayB0D78xF3LleXa8cqJ6lLYcnZf4eEeZlCJGh7L7nBTCSSS17x\nUYfU+xTc1shIYaFwjgj+OWrSZy3PKv6MGxoUfSopReO7A0KXlTbC2azSjl4OHgE=\n=0Myz\n-----END PGP SIGNATURE-----\n", "payload": "tree a0fada6238a2b9c10bf535d91618fd7e5d58d586\nparent 4d3b73e075193f2e575d93bfa2bcddab422af55d\nparent 75cf0be87b78c2a2aaf9e4270192942e2603e0e5\nauthor Nick Cameron <nrc@ncameron.org> 1519516052 +1300\ncommitter GitHub <noreply@github.com> 1519516052 +1300\n\nMerge pull request #2485 from topecongiro/attr\n\nAdd `attr` modules and allow `#[name = value]` to exceed max width"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd774dbba3068b5915ebb8d216a34a63bc974121", "html_url": "https://github.com/rust-lang/rust/commit/fd774dbba3068b5915ebb8d216a34a63bc974121", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd774dbba3068b5915ebb8d216a34a63bc974121/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d3b73e075193f2e575d93bfa2bcddab422af55d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d3b73e075193f2e575d93bfa2bcddab422af55d", "html_url": "https://github.com/rust-lang/rust/commit/4d3b73e075193f2e575d93bfa2bcddab422af55d"}, {"sha": "75cf0be87b78c2a2aaf9e4270192942e2603e0e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/75cf0be87b78c2a2aaf9e4270192942e2603e0e5", "html_url": "https://github.com/rust-lang/rust/commit/75cf0be87b78c2a2aaf9e4270192942e2603e0e5"}], "stats": {"total": 717, "additions": 381, "deletions": 336}, "files": [{"sha": "5d22bd9ffe7fa87d8f33279522d8f873f0416e31", "filename": "rustfmt-core/src/attr.rs", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fattr.rs?ref=fd774dbba3068b5915ebb8d216a34a63bc974121", "patch": "@@ -0,0 +1,323 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Format attributes and meta items.\n+\n+use config::lists::*;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+use comment::{combine_strs_with_missing_comments, contains_comment, rewrite_doc_comment};\n+use expr::rewrite_literal;\n+use lists::{itemize_list, write_list, ListFormatting};\n+use rewrite::{Rewrite, RewriteContext};\n+use shape::Shape;\n+use utils::{count_newlines, mk_sp};\n+\n+use std::cmp;\n+\n+/// Returns attributes on the given statement.\n+pub fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n+    match stmt.node {\n+        ast::StmtKind::Local(ref local) => &local.attrs,\n+        ast::StmtKind::Item(ref item) => &item.attrs,\n+        ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => &expr.attrs,\n+        ast::StmtKind::Mac(ref mac) => &mac.2,\n+    }\n+}\n+\n+/// Returns attributes that are within `outer_span`.\n+pub fn filter_inline_attrs(attrs: &[ast::Attribute], outer_span: Span) -> Vec<ast::Attribute> {\n+    attrs\n+        .iter()\n+        .filter(|a| outer_span.lo() <= a.span.lo() && a.span.hi() <= outer_span.hi())\n+        .cloned()\n+        .collect()\n+}\n+\n+fn is_derive(attr: &ast::Attribute) -> bool {\n+    attr.check_name(\"derive\")\n+}\n+\n+/// Returns the arguments of `#[derive(...)]`.\n+fn get_derive_args<'a>(context: &'a RewriteContext, attr: &ast::Attribute) -> Option<Vec<&'a str>> {\n+    attr.meta_item_list().map(|meta_item_list| {\n+        meta_item_list\n+            .iter()\n+            .map(|nested_meta_item| context.snippet(nested_meta_item.span))\n+            .collect()\n+    })\n+}\n+\n+// Format `#[derive(..)]`, using visual indent & mixed style when we need to go multiline.\n+fn format_derive(context: &RewriteContext, derive_args: &[&str], shape: Shape) -> Option<String> {\n+    let mut result = String::with_capacity(128);\n+    result.push_str(\"#[derive(\");\n+    // 11 = `#[derive()]`\n+    let initial_budget = shape.width.checked_sub(11)?;\n+    let mut budget = initial_budget;\n+    let num = derive_args.len();\n+    for (i, a) in derive_args.iter().enumerate() {\n+        // 2 = `, ` or `)]`\n+        let width = a.len() + 2;\n+        if width > budget {\n+            if i > 0 {\n+                // Remove trailing whitespace.\n+                result.pop();\n+            }\n+            result.push('\\n');\n+            // 9 = `#[derive(`\n+            result.push_str(&(shape.indent + 9).to_string(context.config));\n+            budget = initial_budget;\n+        } else {\n+            budget = budget.checked_sub(width).unwrap_or(0);\n+        }\n+        result.push_str(a);\n+        if i != num - 1 {\n+            result.push_str(\", \")\n+        }\n+    }\n+    result.push_str(\")]\");\n+    Some(result)\n+}\n+\n+/// Returns the first group of attributes that fills the given predicate.\n+/// We consider two doc comments are in different group if they are separated by normal comments.\n+fn take_while_with_pred<'a, P>(\n+    context: &RewriteContext,\n+    attrs: &'a [ast::Attribute],\n+    pred: P,\n+) -> &'a [ast::Attribute]\n+where\n+    P: Fn(&ast::Attribute) -> bool,\n+{\n+    let mut last_index = 0;\n+    let mut iter = attrs.iter().enumerate().peekable();\n+    while let Some((i, attr)) = iter.next() {\n+        if !pred(attr) {\n+            break;\n+        }\n+        if let Some(&(_, next_attr)) = iter.peek() {\n+            // Extract comments between two attributes.\n+            let span_between_attr = mk_sp(attr.span.hi(), next_attr.span.lo());\n+            let snippet = context.snippet(span_between_attr);\n+            if count_newlines(snippet) >= 2 || snippet.contains('/') {\n+                break;\n+            }\n+        }\n+        last_index = i;\n+    }\n+    if last_index == 0 {\n+        &[]\n+    } else {\n+        &attrs[..last_index + 1]\n+    }\n+}\n+\n+/// Rewrite the same kind of attributes at the same time. This includes doc\n+/// comments and derives.\n+fn rewrite_first_group_attrs(\n+    context: &RewriteContext,\n+    attrs: &[ast::Attribute],\n+    shape: Shape,\n+) -> Option<(usize, String)> {\n+    if attrs.is_empty() {\n+        return Some((0, String::new()));\n+    }\n+    // Rewrite doc comments\n+    let sugared_docs = take_while_with_pred(context, attrs, |a| a.is_sugared_doc);\n+    if !sugared_docs.is_empty() {\n+        let snippet = sugared_docs\n+            .iter()\n+            .map(|a| context.snippet(a.span))\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        return Some((\n+            sugared_docs.len(),\n+            rewrite_doc_comment(&snippet, shape, context.config)?,\n+        ));\n+    }\n+    // Rewrite `#[derive(..)]`s.\n+    if context.config.merge_derives() {\n+        let derives = take_while_with_pred(context, attrs, is_derive);\n+        if !derives.is_empty() {\n+            let mut derive_args = vec![];\n+            for derive in derives {\n+                derive_args.append(&mut get_derive_args(context, derive)?);\n+            }\n+            return Some((derives.len(), format_derive(context, &derive_args, shape)?));\n+        }\n+    }\n+    // Rewrite the first attribute.\n+    Some((1, attrs[0].rewrite(context, shape)?))\n+}\n+\n+impl Rewrite for ast::NestedMetaItem {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        match self.node {\n+            ast::NestedMetaItemKind::MetaItem(ref meta_item) => meta_item.rewrite(context, shape),\n+            ast::NestedMetaItemKind::Literal(ref l) => rewrite_literal(context, l, shape),\n+        }\n+    }\n+}\n+\n+fn has_newlines_before_after_comment(comment: &str) -> (&str, &str) {\n+    // Look at before and after comment and see if there are any empty lines.\n+    let comment_begin = comment.chars().position(|c| c == '/');\n+    let len = comment_begin.unwrap_or_else(|| comment.len());\n+    let mlb = count_newlines(&comment[..len]) > 1;\n+    let mla = if comment_begin.is_none() {\n+        mlb\n+    } else {\n+        let comment_end = comment.chars().rev().position(|c| !c.is_whitespace());\n+        let len = comment_end.unwrap();\n+        comment\n+            .chars()\n+            .rev()\n+            .take(len)\n+            .filter(|c| *c == '\\n')\n+            .count() > 1\n+    };\n+    (if mlb { \"\\n\" } else { \"\" }, if mla { \"\\n\" } else { \"\" })\n+}\n+\n+impl Rewrite for ast::MetaItem {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        Some(match self.node {\n+            ast::MetaItemKind::Word => String::from(&*self.name.as_str()),\n+            ast::MetaItemKind::List(ref list) => {\n+                let name = self.name.as_str();\n+                // 1 = `(`, 2 = `]` and `)`\n+                let item_shape = shape\n+                    .visual_indent(0)\n+                    .shrink_left(name.len() + 1)\n+                    .and_then(|s| s.sub_width(2))?;\n+                let items = itemize_list(\n+                    context.snippet_provider,\n+                    list.iter(),\n+                    \")\",\n+                    \",\",\n+                    |nested_meta_item| nested_meta_item.span.lo(),\n+                    |nested_meta_item| nested_meta_item.span.hi(),\n+                    |nested_meta_item| nested_meta_item.rewrite(context, item_shape),\n+                    self.span.lo(),\n+                    self.span.hi(),\n+                    false,\n+                );\n+                let item_vec = items.collect::<Vec<_>>();\n+                let fmt = ListFormatting {\n+                    tactic: DefinitiveListTactic::Mixed,\n+                    separator: \",\",\n+                    trailing_separator: SeparatorTactic::Never,\n+                    separator_place: SeparatorPlace::Back,\n+                    shape: item_shape,\n+                    ends_with_newline: false,\n+                    preserve_newline: false,\n+                    config: context.config,\n+                };\n+                format!(\"{}({})\", name, write_list(&item_vec, &fmt)?)\n+            }\n+            ast::MetaItemKind::NameValue(ref literal) => {\n+                let name = self.name.as_str();\n+                // 3 = ` = `\n+                let lit_shape = shape.shrink_left(name.len() + 3)?;\n+                // `rewrite_literal` returns `None` when `literal` exceeds max\n+                // width. Since a literal is basically unformattable unless it\n+                // is a string literal (and only if `format_strings` is set),\n+                // we might be better off ignoring the fact that the attribute\n+                // is longer than the max width and contiue on formatting.\n+                // See #2479 for example.\n+                let value = rewrite_literal(context, literal, lit_shape)\n+                    .unwrap_or_else(|| context.snippet(literal.span).to_owned());\n+                format!(\"{} = {}\", name, value)\n+            }\n+        })\n+    }\n+}\n+\n+impl Rewrite for ast::Attribute {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        let prefix = match self.style {\n+            ast::AttrStyle::Inner => \"#!\",\n+            ast::AttrStyle::Outer => \"#\",\n+        };\n+        let snippet = context.snippet(self.span);\n+        if self.is_sugared_doc {\n+            let doc_shape = Shape {\n+                width: cmp::min(shape.width, context.config.comment_width())\n+                    .checked_sub(shape.indent.width())\n+                    .unwrap_or(0),\n+                ..shape\n+            };\n+            rewrite_doc_comment(snippet, doc_shape, context.config)\n+        } else {\n+            if contains_comment(snippet) {\n+                return Some(snippet.to_owned());\n+            }\n+            // 1 = `[`\n+            let shape = shape.offset_left(prefix.len() + 1)?;\n+            Some(\n+                self.meta()\n+                    .and_then(|meta| meta.rewrite(context, shape))\n+                    .map_or_else(|| snippet.to_owned(), |rw| format!(\"{}[{}]\", prefix, rw)),\n+            )\n+        }\n+    }\n+}\n+\n+impl<'a> Rewrite for [ast::Attribute] {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        if self.is_empty() {\n+            return Some(String::new());\n+        }\n+        let (first_group_len, first_group_str) = rewrite_first_group_attrs(context, self, shape)?;\n+        if self.len() == 1 || first_group_len == self.len() {\n+            Some(first_group_str)\n+        } else {\n+            let rest_str = self[first_group_len..].rewrite(context, shape)?;\n+            let missing_span = mk_sp(\n+                self[first_group_len - 1].span.hi(),\n+                self[first_group_len].span.lo(),\n+            );\n+            // Preserve an empty line before/after doc comments.\n+            if self[0].is_sugared_doc || self[first_group_len].is_sugared_doc {\n+                let snippet = context.snippet(missing_span);\n+                let (mla, mlb) = has_newlines_before_after_comment(snippet);\n+                let comment = ::comment::recover_missing_comment_in_span(\n+                    missing_span,\n+                    shape.with_max_width(context.config),\n+                    context,\n+                    0,\n+                )?;\n+                let comment = if comment.is_empty() {\n+                    format!(\"\\n{}\", mlb)\n+                } else {\n+                    format!(\"{}{}\\n{}\", mla, comment, mlb)\n+                };\n+                Some(format!(\n+                    \"{}{}{}{}\",\n+                    first_group_str,\n+                    comment,\n+                    shape.indent.to_string(context.config),\n+                    rest_str\n+                ))\n+            } else {\n+                combine_strs_with_missing_comments(\n+                    context,\n+                    &first_group_str,\n+                    &rest_str,\n+                    missing_span,\n+                    shape,\n+                    false,\n+                )\n+            }\n+        }\n+    }\n+}"}, {"sha": "3503546c0102d881e2900e80c491ec2401016608", "filename": "rustfmt-core/src/items.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Fsrc%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Fsrc%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fitems.rs?ref=fd774dbba3068b5915ebb8d216a34a63bc974121", "patch": "@@ -14,6 +14,7 @@ use std::borrow::Cow;\n use std::cmp::min;\n \n use config::lists::*;\n+use regex::Regex;\n use syntax::{abi, ast, ptr, symbol};\n use syntax::ast::{CrateSugar, ImplItem};\n use syntax::codemap::{BytePos, Span};\n@@ -2854,3 +2855,37 @@ pub fn rewrite_mod(item: &ast::Item) -> String {\n     result.push(';');\n     result\n }\n+\n+/// Rewrite `extern crate foo;` WITHOUT attributes.\n+pub fn rewrite_extern_crate(context: &RewriteContext, item: &ast::Item) -> Option<String> {\n+    assert!(is_extern_crate(item));\n+    let new_str = context.snippet(item.span);\n+    Some(if contains_comment(new_str) {\n+        new_str.to_owned()\n+    } else {\n+        let no_whitespace = &new_str.split_whitespace().collect::<Vec<&str>>().join(\" \");\n+        String::from(&*Regex::new(r\"\\s;\").unwrap().replace(no_whitespace, \";\"))\n+    })\n+}\n+\n+/// Returns true for `mod foo;`, false for `mod foo { .. }`.\n+pub fn is_mod_decl(item: &ast::Item) -> bool {\n+    match item.node {\n+        ast::ItemKind::Mod(ref m) => m.inner.hi() != item.span.hi(),\n+        _ => false,\n+    }\n+}\n+\n+pub fn is_use_item(item: &ast::Item) -> bool {\n+    match item.node {\n+        ast::ItemKind::Use(_) => true,\n+        _ => false,\n+    }\n+}\n+\n+pub fn is_extern_crate(item: &ast::Item) -> bool {\n+    match item.node {\n+        ast::ItemKind::ExternCrate(..) => true,\n+        _ => false,\n+    }\n+}"}, {"sha": "6e9554f68554a008a4263b4a8916f72122348027", "filename": "rustfmt-core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Flib.rs?ref=fd774dbba3068b5915ebb8d216a34a63bc974121", "patch": "@@ -53,6 +53,7 @@ pub use config::summary::Summary;\n #[macro_use]\n mod utils;\n \n+mod attr;\n mod chains;\n mod checkstyle;\n mod closures;"}, {"sha": "d4bc36fc83f3fbfb605d9649230c72956f2809c9", "filename": "rustfmt-core/src/reorder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Fsrc%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Fsrc%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Freorder.rs?ref=fd774dbba3068b5915ebb8d216a34a63bc974121", "patch": "@@ -19,16 +19,17 @@\n use config::{Config, lists::*};\n use syntax::{ast, attr, codemap::Span};\n \n+use attr::filter_inline_attrs;\n use codemap::LineRangeUtils;\n use comment::combine_strs_with_missing_comments;\n use imports::{path_to_imported_ident, rewrite_import};\n-use items::rewrite_mod;\n+use items::{rewrite_extern_crate, rewrite_mod};\n use lists::{itemize_list, write_list, ListFormatting};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n use utils::mk_sp;\n-use visitor::{filter_inline_attrs, rewrite_extern_crate, FmtVisitor};\n+use visitor::FmtVisitor;\n \n use std::cmp::Ordering;\n "}, {"sha": "35102f58609063d1afab46d31a249f27e473992a", "filename": "rustfmt-core/src/visitor.rs", "status": "modified", "additions": 5, "deletions": 334, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fvisitor.rs?ref=fd774dbba3068b5915ebb8d216a34a63bc974121", "patch": "@@ -8,61 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp;\n-\n-use config::lists::*;\n use syntax::{ast, visit};\n use syntax::attr::HasAttrs;\n use syntax::codemap::{self, BytePos, CodeMap, Pos, Span};\n use syntax::parse::ParseSess;\n \n+use attr::*;\n use codemap::{LineRangeUtils, SpanUtils};\n-use comment::{combine_strs_with_missing_comments, contains_comment, CodeCharKind,\n-              CommentCodeSlices, FindUncommented};\n-use comment::rewrite_doc_comment;\n+use comment::{CodeCharKind, CommentCodeSlices, FindUncommented};\n use config::{BraceStyle, Config};\n-use expr::rewrite_literal;\n-use items::{format_impl, format_trait, format_trait_alias, rewrite_associated_impl_type,\n-            rewrite_associated_type, rewrite_type_alias, FnSig, StaticParts, StructParts};\n-use lists::{itemize_list, write_list, ListFormatting};\n+use items::{format_impl, format_trait, format_trait_alias, is_mod_decl, is_use_item,\n+            rewrite_associated_impl_type, rewrite_associated_type, rewrite_extern_crate,\n+            rewrite_type_alias, FnSig, StaticParts, StructParts};\n use macros::{rewrite_macro, rewrite_macro_def, MacroPosition};\n-use regex::Regex;\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use spanned::Spanned;\n use utils::{self, contains_skip, count_newlines, inner_attributes, mk_sp, ptr_vec_to_ref_vec};\n \n-/// Returns attributes that are within `outer_span`.\n-pub fn filter_inline_attrs(attrs: &[ast::Attribute], outer_span: Span) -> Vec<ast::Attribute> {\n-    attrs\n-        .iter()\n-        .filter(|a| outer_span.lo() <= a.span.lo() && a.span.hi() <= outer_span.hi())\n-        .cloned()\n-        .collect()\n-}\n-\n-/// Returns true for `mod foo;`, false for `mod foo { .. }`.\n-fn is_mod_decl(item: &ast::Item) -> bool {\n-    match item.node {\n-        ast::ItemKind::Mod(ref m) => m.inner.hi() != item.span.hi(),\n-        _ => false,\n-    }\n-}\n-\n-fn is_use_item(item: &ast::Item) -> bool {\n-    match item.node {\n-        ast::ItemKind::Use(_) => true,\n-        _ => false,\n-    }\n-}\n-\n-fn is_extern_crate(item: &ast::Item) -> bool {\n-    match item.node {\n-        ast::ItemKind::ExternCrate(..) => true,\n-        _ => false,\n-    }\n-}\n-\n /// Creates a string slice corresponding to the specified span.\n pub struct SnippetProvider<'a> {\n     /// A pointer to the content of the file we are formatting.\n@@ -735,295 +698,3 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n }\n-\n-impl Rewrite for ast::NestedMetaItem {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        match self.node {\n-            ast::NestedMetaItemKind::MetaItem(ref meta_item) => meta_item.rewrite(context, shape),\n-            ast::NestedMetaItemKind::Literal(ref l) => rewrite_literal(context, l, shape),\n-        }\n-    }\n-}\n-\n-impl Rewrite for ast::MetaItem {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        Some(match self.node {\n-            ast::MetaItemKind::Word => String::from(&*self.name.as_str()),\n-            ast::MetaItemKind::List(ref list) => {\n-                let name = self.name.as_str();\n-                // 1 = `(`, 2 = `]` and `)`\n-                let item_shape = shape\n-                    .visual_indent(0)\n-                    .shrink_left(name.len() + 1)\n-                    .and_then(|s| s.sub_width(2))?;\n-                let items = itemize_list(\n-                    context.snippet_provider,\n-                    list.iter(),\n-                    \")\",\n-                    \",\",\n-                    |nested_meta_item| nested_meta_item.span.lo(),\n-                    |nested_meta_item| nested_meta_item.span.hi(),\n-                    |nested_meta_item| nested_meta_item.rewrite(context, item_shape),\n-                    self.span.lo(),\n-                    self.span.hi(),\n-                    false,\n-                );\n-                let item_vec = items.collect::<Vec<_>>();\n-                let fmt = ListFormatting {\n-                    tactic: DefinitiveListTactic::Mixed,\n-                    separator: \",\",\n-                    trailing_separator: SeparatorTactic::Never,\n-                    separator_place: SeparatorPlace::Back,\n-                    shape: item_shape,\n-                    ends_with_newline: false,\n-                    preserve_newline: false,\n-                    config: context.config,\n-                };\n-                format!(\"{}({})\", name, write_list(&item_vec, &fmt)?)\n-            }\n-            ast::MetaItemKind::NameValue(ref literal) => {\n-                let name = self.name.as_str();\n-                // 3 = ` = `\n-                let lit_shape = shape.shrink_left(name.len() + 3)?;\n-                let value = rewrite_literal(context, literal, lit_shape)?;\n-                format!(\"{} = {}\", name, value)\n-            }\n-        })\n-    }\n-}\n-\n-impl Rewrite for ast::Attribute {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let prefix = match self.style {\n-            ast::AttrStyle::Inner => \"#!\",\n-            ast::AttrStyle::Outer => \"#\",\n-        };\n-        let snippet = context.snippet(self.span);\n-        if self.is_sugared_doc {\n-            let doc_shape = Shape {\n-                width: cmp::min(shape.width, context.config.comment_width())\n-                    .checked_sub(shape.indent.width())\n-                    .unwrap_or(0),\n-                ..shape\n-            };\n-            rewrite_doc_comment(snippet, doc_shape, context.config)\n-        } else {\n-            if contains_comment(snippet) {\n-                return Some(snippet.to_owned());\n-            }\n-            // 1 = `[`\n-            let shape = shape.offset_left(prefix.len() + 1)?;\n-            Some(\n-                self.meta()\n-                    .and_then(|meta| meta.rewrite(context, shape))\n-                    .map_or_else(|| snippet.to_owned(), |rw| format!(\"{}[{}]\", prefix, rw)),\n-            )\n-        }\n-    }\n-}\n-\n-/// Returns the first group of attributes that fills the given predicate.\n-/// We consider two doc comments are in different group if they are separated by normal comments.\n-fn take_while_with_pred<'a, P>(\n-    context: &RewriteContext,\n-    attrs: &'a [ast::Attribute],\n-    pred: P,\n-) -> &'a [ast::Attribute]\n-where\n-    P: Fn(&ast::Attribute) -> bool,\n-{\n-    let mut last_index = 0;\n-    let mut iter = attrs.iter().enumerate().peekable();\n-    while let Some((i, attr)) = iter.next() {\n-        if !pred(attr) {\n-            break;\n-        }\n-        if let Some(&(_, next_attr)) = iter.peek() {\n-            // Extract comments between two attributes.\n-            let span_between_attr = mk_sp(attr.span.hi(), next_attr.span.lo());\n-            let snippet = context.snippet(span_between_attr);\n-            if count_newlines(snippet) >= 2 || snippet.contains('/') {\n-                break;\n-            }\n-        }\n-        last_index = i;\n-    }\n-    if last_index == 0 {\n-        &[]\n-    } else {\n-        &attrs[..last_index + 1]\n-    }\n-}\n-\n-fn rewrite_first_group_attrs(\n-    context: &RewriteContext,\n-    attrs: &[ast::Attribute],\n-    shape: Shape,\n-) -> Option<(usize, String)> {\n-    if attrs.is_empty() {\n-        return Some((0, String::new()));\n-    }\n-    // Rewrite doc comments\n-    let sugared_docs = take_while_with_pred(context, attrs, |a| a.is_sugared_doc);\n-    if !sugared_docs.is_empty() {\n-        let snippet = sugared_docs\n-            .iter()\n-            .map(|a| context.snippet(a.span))\n-            .collect::<Vec<_>>()\n-            .join(\"\\n\");\n-        return Some((\n-            sugared_docs.len(),\n-            rewrite_doc_comment(&snippet, shape, context.config)?,\n-        ));\n-    }\n-    // Rewrite `#[derive(..)]`s.\n-    if context.config.merge_derives() {\n-        let derives = take_while_with_pred(context, attrs, is_derive);\n-        if !derives.is_empty() {\n-            let mut derive_args = vec![];\n-            for derive in derives {\n-                derive_args.append(&mut get_derive_args(context, derive)?);\n-            }\n-            return Some((derives.len(), format_derive(context, &derive_args, shape)?));\n-        }\n-    }\n-    // Rewrite the first attribute.\n-    Some((1, attrs[0].rewrite(context, shape)?))\n-}\n-\n-fn has_newlines_before_after_comment(comment: &str) -> (&str, &str) {\n-    // Look at before and after comment and see if there are any empty lines.\n-    let comment_begin = comment.chars().position(|c| c == '/');\n-    let len = comment_begin.unwrap_or_else(|| comment.len());\n-    let mlb = count_newlines(&comment[..len]) > 1;\n-    let mla = if comment_begin.is_none() {\n-        mlb\n-    } else {\n-        let comment_end = comment.chars().rev().position(|c| !c.is_whitespace());\n-        let len = comment_end.unwrap();\n-        comment\n-            .chars()\n-            .rev()\n-            .take(len)\n-            .filter(|c| *c == '\\n')\n-            .count() > 1\n-    };\n-    (if mlb { \"\\n\" } else { \"\" }, if mla { \"\\n\" } else { \"\" })\n-}\n-\n-impl<'a> Rewrite for [ast::Attribute] {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        if self.is_empty() {\n-            return Some(String::new());\n-        }\n-        let (first_group_len, first_group_str) = rewrite_first_group_attrs(context, self, shape)?;\n-        if self.len() == 1 || first_group_len == self.len() {\n-            Some(first_group_str)\n-        } else {\n-            let rest_str = self[first_group_len..].rewrite(context, shape)?;\n-            let missing_span = mk_sp(\n-                self[first_group_len - 1].span.hi(),\n-                self[first_group_len].span.lo(),\n-            );\n-            // Preserve an empty line before/after doc comments.\n-            if self[0].is_sugared_doc || self[first_group_len].is_sugared_doc {\n-                let snippet = context.snippet(missing_span);\n-                let (mla, mlb) = has_newlines_before_after_comment(snippet);\n-                let comment = ::comment::recover_missing_comment_in_span(\n-                    missing_span,\n-                    shape.with_max_width(context.config),\n-                    context,\n-                    0,\n-                )?;\n-                let comment = if comment.is_empty() {\n-                    format!(\"\\n{}\", mlb)\n-                } else {\n-                    format!(\"{}{}\\n{}\", mla, comment, mlb)\n-                };\n-                Some(format!(\n-                    \"{}{}{}{}\",\n-                    first_group_str,\n-                    comment,\n-                    shape.indent.to_string(context.config),\n-                    rest_str\n-                ))\n-            } else {\n-                combine_strs_with_missing_comments(\n-                    context,\n-                    &first_group_str,\n-                    &rest_str,\n-                    missing_span,\n-                    shape,\n-                    false,\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-// Format `#[derive(..)]`, using visual indent & mixed style when we need to go multiline.\n-fn format_derive(context: &RewriteContext, derive_args: &[&str], shape: Shape) -> Option<String> {\n-    let mut result = String::with_capacity(128);\n-    result.push_str(\"#[derive(\");\n-    // 11 = `#[derive()]`\n-    let initial_budget = shape.width.checked_sub(11)?;\n-    let mut budget = initial_budget;\n-    let num = derive_args.len();\n-    for (i, a) in derive_args.iter().enumerate() {\n-        // 2 = `, ` or `)]`\n-        let width = a.len() + 2;\n-        if width > budget {\n-            if i > 0 {\n-                // Remove trailing whitespace.\n-                result.pop();\n-            }\n-            result.push('\\n');\n-            // 9 = `#[derive(`\n-            result.push_str(&(shape.indent + 9).to_string(context.config));\n-            budget = initial_budget;\n-        } else {\n-            budget = budget.checked_sub(width).unwrap_or(0);\n-        }\n-        result.push_str(a);\n-        if i != num - 1 {\n-            result.push_str(\", \")\n-        }\n-    }\n-    result.push_str(\")]\");\n-    Some(result)\n-}\n-\n-fn is_derive(attr: &ast::Attribute) -> bool {\n-    attr.check_name(\"derive\")\n-}\n-\n-/// Returns the arguments of `#[derive(...)]`.\n-fn get_derive_args<'a>(context: &'a RewriteContext, attr: &ast::Attribute) -> Option<Vec<&'a str>> {\n-    attr.meta_item_list().map(|meta_item_list| {\n-        meta_item_list\n-            .iter()\n-            .map(|nested_meta_item| context.snippet(nested_meta_item.span))\n-            .collect()\n-    })\n-}\n-\n-// Rewrite `extern crate foo;` WITHOUT attributes.\n-pub fn rewrite_extern_crate(context: &RewriteContext, item: &ast::Item) -> Option<String> {\n-    assert!(is_extern_crate(item));\n-    let new_str = context.snippet(item.span);\n-    Some(if contains_comment(new_str) {\n-        new_str.to_owned()\n-    } else {\n-        let no_whitespace = &new_str.split_whitespace().collect::<Vec<&str>>().join(\" \");\n-        String::from(&*Regex::new(r\"\\s;\").unwrap().replace(no_whitespace, \";\"))\n-    })\n-}\n-\n-fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n-    match stmt.node {\n-        ast::StmtKind::Local(ref local) => &local.attrs,\n-        ast::StmtKind::Item(ref item) => &item.attrs,\n-        ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => &expr.attrs,\n-        ast::StmtKind::Mac(ref mac) => &mac.2,\n-    }\n-}"}, {"sha": "df50236d05d34dab250467ec489125cb14d51940", "filename": "rustfmt-core/tests/source/issue-2479.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Ftests%2Fsource%2Fissue-2479.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Ftests%2Fsource%2Fissue-2479.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Ftests%2Fsource%2Fissue-2479.rs?ref=fd774dbba3068b5915ebb8d216a34a63bc974121", "patch": "@@ -0,0 +1,2 @@\n+// Long attributes.\n+# [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum POLARITYR {    # [ doc = \"Task mode: No effect on pin from OUT[n] task. Event mode: no IN[n] event generated on pin activity.\" ] NONE , # [ doc = \"Task mode: Set pin from OUT[n] task. Event mode: Generate IN[n] event when rising edge on pin.\" ] LOTOHI , # [ doc = \"Task mode: Clear pin from OUT[n] task. Event mode: Generate IN[n] event when falling edge on pin.\" ] HITOLO , # [ doc = \"Task mode: Toggle pin from OUT[n]. Event mode: Generate IN[n] when any change on pin.\" ] TOGGLE }"}, {"sha": "3683ab2208955136ebaf665a281446ef8d8a308a", "filename": "rustfmt-core/tests/target/issue-2479.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Ftests%2Ftarget%2Fissue-2479.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd774dbba3068b5915ebb8d216a34a63bc974121/rustfmt-core%2Ftests%2Ftarget%2Fissue-2479.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Ftests%2Ftarget%2Fissue-2479.rs?ref=fd774dbba3068b5915ebb8d216a34a63bc974121", "patch": "@@ -0,0 +1,12 @@\n+// Long attributes.\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub enum POLARITYR {\n+    #[doc = \"Task mode: No effect on pin from OUT[n] task. Event mode: no IN[n] event generated on pin activity.\"]\n+    NONE,\n+    #[doc = \"Task mode: Set pin from OUT[n] task. Event mode: Generate IN[n] event when rising edge on pin.\"]\n+    LOTOHI,\n+    #[doc = \"Task mode: Clear pin from OUT[n] task. Event mode: Generate IN[n] event when falling edge on pin.\"]\n+    HITOLO,\n+    #[doc = \"Task mode: Toggle pin from OUT[n]. Event mode: Generate IN[n] when any change on pin.\"]\n+    TOGGLE,\n+}"}]}