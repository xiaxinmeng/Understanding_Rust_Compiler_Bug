{"sha": "3257c3401d68057e83089f3b8da27f7ecc21e228", "node_id": "C_kwDOAAsO6NoAKDMyNTdjMzQwMWQ2ODA1N2U4MzA4OWYzYjhkYTI3ZjdlY2MyMWUyMjg", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-20T10:47:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-20T10:47:22Z"}, "message": "Rollup merge of #99485 - mdholloway:unused-qualifications-in-derive, r=oli-obk\n\nStop injecting `#[allow(unused_qualifications)]` in generated `derive` implementations\n\nCurrently, the `#[derive]` attribute always injects an `#[allow(unused_qualifications)]` attribute in the generated implementation. This results in an error when a derive is used in combination with `#![forbid(unused_qualifications)]`, because the `forbid` rule by definition cannot be overridden by `allow`.\n\nIt appears that the original issue that prompted the inclusion of `#[allow(unused_qualifications)]` (#19102) is no longer present in the current stable release, and the associated [test case](https://github.com/rust-lang/rust/blob/master/src/test/ui/issues/issue-19102.rs) still passes, so the `allow` is simply removed here.\n\nFixes #71898.", "tree": {"sha": "072b4dc85dff6ce5db5cd9d67d20b767d671099f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/072b4dc85dff6ce5db5cd9d67d20b767d671099f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3257c3401d68057e83089f3b8da27f7ecc21e228", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi1906CRBK7hj4Ov3rIwAAJPwIAK12cwfimBvreXC8x8cG7X7n\naw011KgEofJuVA2C/ejBby6vRLuHxppq+AiuFtdrxiUPyKYagyzd1bNP923FYYbQ\nJxmyB8OJFv+CEP5YKCCLtJWbURU3QhsnCoN3gIdTbBh4p0b7e5nMZa2olpde9EIE\n1qO4xg18b/ieO12x5Qj+fscJ6cp+HnQBp/FOZ30Xdezy7rmMA0TGTXBOJ1xgyWnp\nswbfy+/ernOuhqv8CfBu32FbbGhWF5Mfzc8hlSU1GqgTJ68iKHB0Rm477F9E1MkO\nrJhSTUd0lURHoWSiTXeImwZa+nrhEIhFyxBsGmbo+WlokBSwBe5hiA+s65B6sng=\n=MCc2\n-----END PGP SIGNATURE-----\n", "payload": "tree 072b4dc85dff6ce5db5cd9d67d20b767d671099f\nparent d9a71c1e0225e6179f75f7bb9d7e4e9c67cb71c7\nparent 05bb8782616e61fc6dbeb712fceee8b96102f6ec\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1658314042 +0530\ncommitter GitHub <noreply@github.com> 1658314042 +0530\n\nRollup merge of #99485 - mdholloway:unused-qualifications-in-derive, r=oli-obk\n\nStop injecting `#[allow(unused_qualifications)]` in generated `derive` implementations\n\nCurrently, the `#[derive]` attribute always injects an `#[allow(unused_qualifications)]` attribute in the generated implementation. This results in an error when a derive is used in combination with `#![forbid(unused_qualifications)]`, because the `forbid` rule by definition cannot be overridden by `allow`.\n\nIt appears that the original issue that prompted the inclusion of `#[allow(unused_qualifications)]` (#19102) is no longer present in the current stable release, and the associated [test case](https://github.com/rust-lang/rust/blob/master/src/test/ui/issues/issue-19102.rs) still passes, so the `allow` is simply removed here.\n\nFixes #71898.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3257c3401d68057e83089f3b8da27f7ecc21e228", "html_url": "https://github.com/rust-lang/rust/commit/3257c3401d68057e83089f3b8da27f7ecc21e228", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3257c3401d68057e83089f3b8da27f7ecc21e228/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9a71c1e0225e6179f75f7bb9d7e4e9c67cb71c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9a71c1e0225e6179f75f7bb9d7e4e9c67cb71c7", "html_url": "https://github.com/rust-lang/rust/commit/d9a71c1e0225e6179f75f7bb9d7e4e9c67cb71c7"}, {"sha": "05bb8782616e61fc6dbeb712fceee8b96102f6ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/05bb8782616e61fc6dbeb712fceee8b96102f6ec", "html_url": "https://github.com/rust-lang/rust/commit/05bb8782616e61fc6dbeb712fceee8b96102f6ec"}], "stats": {"total": 147, "additions": 39, "deletions": 108}, "files": [{"sha": "735017aa5a850f9d3ec9690aab3e029b7bfba649", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3257c3401d68057e83089f3b8da27f7ecc21e228/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3257c3401d68057e83089f3b8da27f7ecc21e228/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=3257c3401d68057e83089f3b8da27f7ecc21e228", "patch": "@@ -727,16 +727,8 @@ impl<'a> TraitDef<'a> {\n \n         let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n         let opt_trait_ref = Some(trait_ref);\n-        let unused_qual = {\n-            let word = rustc_ast::attr::mk_nested_word_item(Ident::new(\n-                sym::unused_qualifications,\n-                self.span,\n-            ));\n-            let list = rustc_ast::attr::mk_list_item(Ident::new(sym::allow, self.span), vec![word]);\n-            cx.attribute(list)\n-        };\n \n-        let mut a = vec![attr, unused_qual];\n+        let mut a = vec![attr];\n         a.extend(self.attributes.iter().cloned());\n \n         cx.item("}, {"sha": "21fe663f06706da81320fc90a42ca695edc2ca0a", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/3257c3401d68057e83089f3b8da27f7ecc21e228/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/3257c3401d68057e83089f3b8da27f7ecc21e228/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=3257c3401d68057e83089f3b8da27f7ecc21e228", "patch": "@@ -25,50 +25,42 @@ extern crate std;\n // Empty struct.\n struct Empty;\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Empty {\n     #[inline]\n     fn clone(&self) -> Empty { *self }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for Empty { }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Empty {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         ::core::fmt::Formatter::write_str(f, \"Empty\")\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for Empty {\n     #[inline]\n     fn default() -> Empty { Empty {} }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Empty {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}\n }\n impl ::core::marker::StructuralPartialEq for Empty {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Empty {\n     #[inline]\n     fn eq(&self, other: &Empty) -> bool { true }\n }\n impl ::core::marker::StructuralEq for Empty {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Empty {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Empty {\n     #[inline]\n     fn partial_cmp(&self, other: &Empty)\n@@ -77,7 +69,6 @@ impl ::core::cmp::PartialOrd for Empty {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Empty {\n     #[inline]\n     fn cmp(&self, other: &Empty) -> ::core::cmp::Ordering {\n@@ -91,7 +82,6 @@ struct Point {\n     y: u32,\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Point {\n     #[inline]\n     fn clone(&self) -> Point {\n@@ -100,18 +90,15 @@ impl ::core::clone::Clone for Point {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for Point { }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Point {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         ::core::fmt::Formatter::debug_struct_field2_finish(f, \"Point\", \"x\",\n             &&self.x, \"y\", &&self.y)\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for Point {\n     #[inline]\n     fn default() -> Point {\n@@ -122,7 +109,6 @@ impl ::core::default::Default for Point {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Point {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         ::core::hash::Hash::hash(&self.x, state);\n@@ -131,7 +117,6 @@ impl ::core::hash::Hash for Point {\n }\n impl ::core::marker::StructuralPartialEq for Point {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Point {\n     #[inline]\n     fn eq(&self, other: &Point) -> bool {\n@@ -144,7 +129,6 @@ impl ::core::cmp::PartialEq for Point {\n }\n impl ::core::marker::StructuralEq for Point {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Point {\n     #[inline]\n     #[doc(hidden)]\n@@ -154,7 +138,6 @@ impl ::core::cmp::Eq for Point {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Point {\n     #[inline]\n     fn partial_cmp(&self, other: &Point)\n@@ -167,7 +150,6 @@ impl ::core::cmp::PartialOrd for Point {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Point {\n     #[inline]\n     fn cmp(&self, other: &Point) -> ::core::cmp::Ordering {\n@@ -191,7 +173,6 @@ struct Big {\n     b8: u32,\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Big {\n     #[inline]\n     fn clone(&self) -> Big {\n@@ -208,7 +189,6 @@ impl ::core::clone::Clone for Big {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Big {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         let names: &'static _ =\n@@ -221,7 +201,6 @@ impl ::core::fmt::Debug for Big {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for Big {\n     #[inline]\n     fn default() -> Big {\n@@ -238,7 +217,6 @@ impl ::core::default::Default for Big {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Big {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         ::core::hash::Hash::hash(&self.b1, state);\n@@ -253,7 +231,6 @@ impl ::core::hash::Hash for Big {\n }\n impl ::core::marker::StructuralPartialEq for Big {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Big {\n     #[inline]\n     fn eq(&self, other: &Big) -> bool {\n@@ -272,7 +249,6 @@ impl ::core::cmp::PartialEq for Big {\n }\n impl ::core::marker::StructuralEq for Big {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Big {\n     #[inline]\n     #[doc(hidden)]\n@@ -282,7 +258,6 @@ impl ::core::cmp::Eq for Big {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Big {\n     #[inline]\n     fn partial_cmp(&self, other: &Big)\n@@ -331,7 +306,6 @@ impl ::core::cmp::PartialOrd for Big {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Big {\n     #[inline]\n     fn cmp(&self, other: &Big) -> ::core::cmp::Ordering {\n@@ -370,23 +344,20 @@ impl ::core::cmp::Ord for Big {\n // A struct with an unsized field. Some derives are not usable in this case.\n struct Unsized([u32]);\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Unsized {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Unsized\",\n             &&self.0)\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Unsized {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         ::core::hash::Hash::hash(&self.0, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for Unsized {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Unsized {\n     #[inline]\n     fn eq(&self, other: &Unsized) -> bool { self.0 == other.0 }\n@@ -395,7 +366,6 @@ impl ::core::cmp::PartialEq for Unsized {\n }\n impl ::core::marker::StructuralEq for Unsized {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Unsized {\n     #[inline]\n     #[doc(hidden)]\n@@ -405,7 +375,6 @@ impl ::core::cmp::Eq for Unsized {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Unsized {\n     #[inline]\n     fn partial_cmp(&self, other: &Unsized)\n@@ -414,7 +383,6 @@ impl ::core::cmp::PartialOrd for Unsized {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Unsized {\n     #[inline]\n     fn cmp(&self, other: &Unsized) -> ::core::cmp::Ordering {\n@@ -426,7 +394,6 @@ impl ::core::cmp::Ord for Unsized {\n #[repr(packed)]\n struct PackedCopy(u32);\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for PackedCopy {\n     #[inline]\n     fn clone(&self) -> PackedCopy {\n@@ -435,34 +402,29 @@ impl ::core::clone::Clone for PackedCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for PackedCopy { }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for PackedCopy {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"PackedCopy\",\n             &&{ self.0 })\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for PackedCopy {\n     #[inline]\n     fn default() -> PackedCopy {\n         PackedCopy(::core::default::Default::default())\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for PackedCopy {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         ::core::hash::Hash::hash(&{ self.0 }, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for PackedCopy {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for PackedCopy {\n     #[inline]\n     fn eq(&self, other: &PackedCopy) -> bool { { self.0 } == { other.0 } }\n@@ -471,7 +433,6 @@ impl ::core::cmp::PartialEq for PackedCopy {\n }\n impl ::core::marker::StructuralEq for PackedCopy {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for PackedCopy {\n     #[inline]\n     #[doc(hidden)]\n@@ -481,7 +442,6 @@ impl ::core::cmp::Eq for PackedCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for PackedCopy {\n     #[inline]\n     fn partial_cmp(&self, other: &PackedCopy)\n@@ -490,7 +450,6 @@ impl ::core::cmp::PartialOrd for PackedCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for PackedCopy {\n     #[inline]\n     fn cmp(&self, other: &PackedCopy) -> ::core::cmp::Ordering {\n@@ -506,7 +465,6 @@ impl ::core::cmp::Ord for PackedCopy {\n #[repr(packed)]\n struct PackedNonCopy(u8);\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for PackedNonCopy {\n     #[inline]\n     fn clone(&self) -> PackedNonCopy {\n@@ -515,7 +473,6 @@ impl ::core::clone::Clone for PackedNonCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for PackedNonCopy {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         let Self(ref __self_0_0) = *self;\n@@ -524,15 +481,13 @@ impl ::core::fmt::Debug for PackedNonCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for PackedNonCopy {\n     #[inline]\n     fn default() -> PackedNonCopy {\n         PackedNonCopy(::core::default::Default::default())\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for PackedNonCopy {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         let Self(ref __self_0_0) = *self;\n@@ -541,7 +496,6 @@ impl ::core::hash::Hash for PackedNonCopy {\n }\n impl ::core::marker::StructuralPartialEq for PackedNonCopy {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for PackedNonCopy {\n     #[inline]\n     fn eq(&self, other: &PackedNonCopy) -> bool {\n@@ -558,7 +512,6 @@ impl ::core::cmp::PartialEq for PackedNonCopy {\n }\n impl ::core::marker::StructuralEq for PackedNonCopy {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for PackedNonCopy {\n     #[inline]\n     #[doc(hidden)]\n@@ -568,7 +521,6 @@ impl ::core::cmp::Eq for PackedNonCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for PackedNonCopy {\n     #[inline]\n     fn partial_cmp(&self, other: &PackedNonCopy)\n@@ -579,7 +531,6 @@ impl ::core::cmp::PartialOrd for PackedNonCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for PackedNonCopy {\n     #[inline]\n     fn cmp(&self, other: &PackedNonCopy) -> ::core::cmp::Ordering {\n@@ -592,31 +543,26 @@ impl ::core::cmp::Ord for PackedNonCopy {\n // An empty enum.\n enum Enum0 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Enum0 {\n     #[inline]\n     fn clone(&self) -> Enum0 { *self }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for Enum0 { }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Enum0 {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         unsafe { ::core::intrinsics::unreachable() }\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Enum0 {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         unsafe { ::core::intrinsics::unreachable() }\n     }\n }\n impl ::core::marker::StructuralPartialEq for Enum0 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Enum0 {\n     #[inline]\n     fn eq(&self, other: &Enum0) -> bool {\n@@ -625,15 +571,13 @@ impl ::core::cmp::PartialEq for Enum0 {\n }\n impl ::core::marker::StructuralEq for Enum0 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Enum0 {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Enum0 {\n     #[inline]\n     fn partial_cmp(&self, other: &Enum0)\n@@ -642,7 +586,6 @@ impl ::core::cmp::PartialOrd for Enum0 {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Enum0 {\n     #[inline]\n     fn cmp(&self, other: &Enum0) -> ::core::cmp::Ordering {\n@@ -657,7 +600,6 @@ enum Enum1 {\n     },\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Enum1 {\n     #[inline]\n     fn clone(&self) -> Enum1 {\n@@ -668,7 +610,6 @@ impl ::core::clone::Clone for Enum1 {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Enum1 {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         match self {\n@@ -679,7 +620,6 @@ impl ::core::fmt::Debug for Enum1 {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Enum1 {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         match self {\n@@ -690,7 +630,6 @@ impl ::core::hash::Hash for Enum1 {\n }\n impl ::core::marker::StructuralPartialEq for Enum1 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Enum1 {\n     #[inline]\n     fn eq(&self, other: &Enum1) -> bool {\n@@ -709,7 +648,6 @@ impl ::core::cmp::PartialEq for Enum1 {\n }\n impl ::core::marker::StructuralEq for Enum1 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Enum1 {\n     #[inline]\n     #[doc(hidden)]\n@@ -719,7 +657,6 @@ impl ::core::cmp::Eq for Enum1 {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Enum1 {\n     #[inline]\n     fn partial_cmp(&self, other: &Enum1)\n@@ -731,7 +668,6 @@ impl ::core::cmp::PartialOrd for Enum1 {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Enum1 {\n     #[inline]\n     fn cmp(&self, other: &Enum1) -> ::core::cmp::Ordering {\n@@ -749,47 +685,40 @@ enum Fieldless1 {\n     A,\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Fieldless1 {\n     #[inline]\n     fn clone(&self) -> Fieldless1 { Fieldless1::A }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fieldless1 {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         ::core::fmt::Formatter::write_str(f, \"A\")\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for Fieldless1 {\n     #[inline]\n     fn default() -> Fieldless1 { Self::A }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fieldless1 {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}\n }\n impl ::core::marker::StructuralPartialEq for Fieldless1 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Fieldless1 {\n     #[inline]\n     fn eq(&self, other: &Fieldless1) -> bool { true }\n }\n impl ::core::marker::StructuralEq for Fieldless1 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Fieldless1 {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Fieldless1 {\n     #[inline]\n     fn partial_cmp(&self, other: &Fieldless1)\n@@ -798,7 +727,6 @@ impl ::core::cmp::PartialOrd for Fieldless1 {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Fieldless1 {\n     #[inline]\n     fn cmp(&self, other: &Fieldless1) -> ::core::cmp::Ordering {\n@@ -815,16 +743,13 @@ enum Fieldless {\n     C,\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Fieldless {\n     #[inline]\n     fn clone(&self) -> Fieldless { *self }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for Fieldless { }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fieldless {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         match self {\n@@ -835,13 +760,11 @@ impl ::core::fmt::Debug for Fieldless {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for Fieldless {\n     #[inline]\n     fn default() -> Fieldless { Self::A }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fieldless {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n@@ -850,7 +773,6 @@ impl ::core::hash::Hash for Fieldless {\n }\n impl ::core::marker::StructuralPartialEq for Fieldless {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Fieldless {\n     #[inline]\n     fn eq(&self, other: &Fieldless) -> bool {\n@@ -861,15 +783,13 @@ impl ::core::cmp::PartialEq for Fieldless {\n }\n impl ::core::marker::StructuralEq for Fieldless {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Fieldless {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Fieldless {\n     #[inline]\n     fn partial_cmp(&self, other: &Fieldless)\n@@ -880,7 +800,6 @@ impl ::core::cmp::PartialOrd for Fieldless {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Fieldless {\n     #[inline]\n     fn cmp(&self, other: &Fieldless) -> ::core::cmp::Ordering {\n@@ -903,7 +822,6 @@ enum Mixed {\n     },\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Mixed {\n     #[inline]\n     fn clone(&self) -> Mixed {\n@@ -912,10 +830,8 @@ impl ::core::clone::Clone for Mixed {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for Mixed { }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Mixed {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         match self {\n@@ -931,13 +847,11 @@ impl ::core::fmt::Debug for Mixed {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for Mixed {\n     #[inline]\n     fn default() -> Mixed { Self::P }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Mixed {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n@@ -954,7 +868,6 @@ impl ::core::hash::Hash for Mixed {\n }\n impl ::core::marker::StructuralPartialEq for Mixed {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Mixed {\n     #[inline]\n     fn eq(&self, other: &Mixed) -> bool {\n@@ -987,7 +900,6 @@ impl ::core::cmp::PartialEq for Mixed {\n }\n impl ::core::marker::StructuralEq for Mixed {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Mixed {\n     #[inline]\n     #[doc(hidden)]\n@@ -997,7 +909,6 @@ impl ::core::cmp::Eq for Mixed {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Mixed {\n     #[inline]\n     fn partial_cmp(&self, other: &Mixed)\n@@ -1025,7 +936,6 @@ impl ::core::cmp::PartialOrd for Mixed {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Mixed {\n     #[inline]\n     fn cmp(&self, other: &Mixed) -> ::core::cmp::Ordering {\n@@ -1054,7 +964,6 @@ impl ::core::cmp::Ord for Mixed {\n // for this enum.\n enum Fielded { X(u32), Y(bool), Z(Option<i32>), }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Fielded {\n     #[inline]\n     fn clone(&self) -> Fielded {\n@@ -1069,7 +978,6 @@ impl ::core::clone::Clone for Fielded {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fielded {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         match self {\n@@ -1086,7 +994,6 @@ impl ::core::fmt::Debug for Fielded {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fielded {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n@@ -1100,7 +1007,6 @@ impl ::core::hash::Hash for Fielded {\n }\n impl ::core::marker::StructuralPartialEq for Fielded {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Fielded {\n     #[inline]\n     fn eq(&self, other: &Fielded) -> bool {\n@@ -1135,7 +1041,6 @@ impl ::core::cmp::PartialEq for Fielded {\n }\n impl ::core::marker::StructuralEq for Fielded {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Fielded {\n     #[inline]\n     #[doc(hidden)]\n@@ -1147,7 +1052,6 @@ impl ::core::cmp::Eq for Fielded {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Fielded {\n     #[inline]\n     fn partial_cmp(&self, other: &Fielded)\n@@ -1170,7 +1074,6 @@ impl ::core::cmp::PartialOrd for Fielded {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Fielded {\n     #[inline]\n     fn cmp(&self, other: &Fielded) -> ::core::cmp::Ordering {\n@@ -1199,7 +1102,6 @@ pub union Union {\n     pub i: i32,\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Union {\n     #[inline]\n     fn clone(&self) -> Union {\n@@ -1208,5 +1110,4 @@ impl ::core::clone::Clone for Union {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for Union { }"}, {"sha": "9d0e3068aed73a41dd9c89df2e42a09735d9396d", "filename": "src/test/ui/lint/auxiliary/add-impl.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3257c3401d68057e83089f3b8da27f7ecc21e228/src%2Ftest%2Fui%2Flint%2Fauxiliary%2Fadd-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3257c3401d68057e83089f3b8da27f7ecc21e228/src%2Ftest%2Fui%2Flint%2Fauxiliary%2Fadd-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fauxiliary%2Fadd-impl.rs?ref=3257c3401d68057e83089f3b8da27f7ecc21e228", "patch": "@@ -0,0 +1,22 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(AddImpl)]\n+// Unnecessary qualification `bar::foo`\n+// https://github.com/rust-lang/rust/issues/71898\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    \"impl B {\n+            fn foo(&self) { use bar::foo; bar::foo() }\n+        }\n+\n+        fn foo() {}\n+\n+        mod bar { pub fn foo() {} }\n+    \".parse().unwrap()\n+}"}, {"sha": "c2efbf507fec88c06f79091a0d6c2f781bbd7698", "filename": "src/test/ui/lint/unused-qualification-in-derive-expansion.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3257c3401d68057e83089f3b8da27f7ecc21e228/src%2Ftest%2Fui%2Flint%2Funused-qualification-in-derive-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3257c3401d68057e83089f3b8da27f7ecc21e228/src%2Ftest%2Fui%2Flint%2Funused-qualification-in-derive-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused-qualification-in-derive-expansion.rs?ref=3257c3401d68057e83089f3b8da27f7ecc21e228", "patch": "@@ -0,0 +1,16 @@\n+// run-pass\n+// aux-build:add-impl.rs\n+\n+#![forbid(unused_qualifications)]\n+\n+#[macro_use]\n+extern crate add_impl;\n+\n+#[derive(AddImpl)]\n+struct B;\n+\n+fn main() {\n+    B.foo();\n+    foo();\n+    bar::foo();\n+}"}]}