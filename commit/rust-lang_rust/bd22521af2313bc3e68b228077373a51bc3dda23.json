{"sha": "bd22521af2313bc3e68b228077373a51bc3dda23", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMjI1MjFhZjIzMTNiYzNlNjhiMjI4MDc3MzczYTUxYmMzZGRhMjM=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-21T15:11:34Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-25T15:36:46Z"}, "message": "shadowing detection", "tree": {"sha": "195c55358f4256c17109d0ab711c9f973d30341a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/195c55358f4256c17109d0ab711c9f973d30341a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd22521af2313bc3e68b228077373a51bc3dda23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd22521af2313bc3e68b228077373a51bc3dda23", "html_url": "https://github.com/rust-lang/rust/commit/bd22521af2313bc3e68b228077373a51bc3dda23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd22521af2313bc3e68b228077373a51bc3dda23/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b13d318f48f181292e8efbdd4fe2d0353e1f51d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b13d318f48f181292e8efbdd4fe2d0353e1f51d2", "html_url": "https://github.com/rust-lang/rust/commit/b13d318f48f181292e8efbdd4fe2d0353e1f51d2"}], "stats": {"total": 67, "additions": 43, "deletions": 24}, "files": [{"sha": "1c09bffd9e625328a45d751fae8fc4ff17015a1f", "filename": "src/shadow.rs", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bd22521af2313bc3e68b228077373a51bc3dda23/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd22521af2313bc3e68b228077373a51bc3dda23/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=bd22521af2313bc3e68b228077373a51bc3dda23", "patch": "@@ -39,12 +39,6 @@ fn check_fn(cx: &Context, decl: &FnDecl, block: &Block) {\n     check_block(cx, block, &mut bindings);\n }\n \n-fn named(pat: &Pat) -> Option<Name> {\n-    if let PatIdent(_, ident, _) = pat.node {\n-       Some(ident.node.name)\n-    } else { None }\n-}\n-\n fn check_block(cx: &Context, block: &Block, bindings: &mut Vec<Name>) {\n     let len = bindings.len();\n     for stmt in &block.stmts {\n@@ -64,25 +58,46 @@ fn check_decl(cx: &Context, decl: &Decl, bindings: &mut Vec<Name>) {\n     if let DeclLocal(ref local) = decl.node {\n         let Local{ ref pat, ref ty, ref init, id: _, span } = **local;\n         if let &Some(ref t) = ty { check_ty(cx, t, bindings) }\n-        check_pat(cx, pat, init, span, bindings);\n         if let &Some(ref o) = init { check_expr(cx, o, bindings) }\n+        check_pat(cx, pat, init, span, bindings);\n     }\n }\n \n fn check_pat<T>(cx: &Context, pat: &Pat, init: &Option<T>, span: Span,  \n         bindings: &mut Vec<Name>) where T: Deref<Target=Expr> {\n     //TODO: match more stuff / destructuring\n-    named(pat).map(|name| {\n-        if let &Some(ref o) = init {\n-            if !in_external_macro(cx, o.span) {\n-                check_expr(cx, o, bindings);\n+    match pat.node {\n+        PatIdent(_, ref ident, ref inner) => {\n+            let name = ident.node.name;\n+            if pat_is_binding(&cx.tcx.def_map, pat) {\n+                if bindings.contains(&name) {\n+                    lint_shadow(cx, name, span, pat.span, init);\n+                }\n+                bindings.push(name);\n             }\n-        }\n-        if bindings.contains(&name) {\n-            lint_shadow(cx, name, span, pat.span, init);\n-        }\n-        bindings.push(name);\n-    });\n+            if let Some(ref p) = *inner { check_pat(cx, p, init, span, bindings); }\n+        },\n+        //PatEnum(Path, Option<Vec<P<Pat>>>),\n+        //PatQPath(QSelf, Path),\n+        //PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n+        //PatTup(Vec<P<Pat>>),\n+        PatBox(ref inner) => {\n+            if let Some(ref initp) = *init {\n+                match initp.node {\n+                    ExprBox(_, ref inner_init) => \n+                        check_pat(cx, inner, &Some(&**inner_init), span, bindings),\n+                    //TODO: ExprCall on Box::new\n+                    _ => check_pat(cx, inner, init, span, bindings),\n+                }\n+            } else {\n+                check_pat(cx, inner, init, span, bindings);\n+            }\n+        },\n+        //PatRegion(P<Pat>, Mutability),\n+        //PatRange(P<Expr>, P<Expr>),\n+        //PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+        _ => (),\n+    }\n }\n \n fn lint_shadow<T>(cx: &Context, name: Name, span: Span, lspan: Span, init: \n@@ -122,6 +137,8 @@ fn check_expr(cx: &Context, expr: &Expr, bindings: &mut Vec<Name>) {\n             check_expr(cx, place, bindings); check_expr(cx, e, bindings) }\n         ExprBlock(ref block) | ExprLoop(ref block, _) =>\n             { check_block(cx, block, bindings) },\n+        //ExprCall\n+        //ExprMethodCall\n         ExprVec(ref v) | ExprTup(ref v) =>\n             for ref e in v { check_expr(cx, e, bindings) },\n         ExprIf(ref cond, ref then, ref otherwise) => {\n@@ -133,17 +150,19 @@ fn check_expr(cx: &Context, expr: &Expr, bindings: &mut Vec<Name>) {\n             check_expr(cx, cond, bindings);\n             check_block(cx, block, bindings);\n         },\n-        ExprMatch(ref init, ref arms, _) =>\n+        ExprMatch(ref init, ref arms, _) => {\n+            check_expr(cx, init, bindings);\n             for ref arm in arms {\n                 for ref pat in &arm.pats {\n+                    check_pat(cx, &pat, &Some(&**init), pat.span, bindings);\n                     //TODO: This is ugly, but needed to get the right type\n-                    check_pat(cx, pat, &Some(&**init), pat.span, bindings);\n                 }\n                 if let Some(ref guard) = arm.guard {\n                     check_expr(cx, guard, bindings);\n                 }\n-                check_expr(cx, &*arm.body, bindings);\n-            },\n+                check_expr(cx, &arm.body, bindings);\n+            }\n+        },\n         _ => ()\n     }\n }\n@@ -179,7 +198,8 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n }\n \n fn path_eq_name(name: Name, path: &Path) -> bool {\n-    path.segments.len() == 1 && path.segments[0].identifier.name == name\n+    !path.global && path.segments.len() == 1 && \n+        path.segments[0].identifier.name == name\n }\n \n fn contains_self(name: Name, expr: &Expr) -> bool {\n@@ -205,8 +225,7 @@ fn contains_self(name: Name, expr: &Expr) -> bool {\n         ExprMatch(ref e, ref arms, _) => \n             arms.iter().any(|ref arm| arm.pats.iter().any(|ref pat| \n                 contains_pat_self(name, pat))) || contains_self(name, e),\n-        ExprPath(_, ref path) => path.segments.len() == 1 &&\n-            path.segments[0].identifier.name == name,\n+        ExprPath(_, ref path) => path_eq_name(name, path),\n         _ => false\n     }\n }"}]}