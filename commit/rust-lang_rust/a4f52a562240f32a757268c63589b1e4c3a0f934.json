{"sha": "a4f52a562240f32a757268c63589b1e4c3a0f934", "node_id": "C_kwDOAAsO6NoAKGE0ZjUyYTU2MjI0MGYzMmE3NTcyNjhjNjM1ODliMWU0YzNhMGY5MzQ", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-10T12:40:18Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-10T12:40:18Z"}, "message": "remove Clean trait implementation for ty::AssocItem", "tree": {"sha": "e9cc9e4dfec58ff122ee7dc0d342ec91ced1f835", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9cc9e4dfec58ff122ee7dc0d342ec91ced1f835"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4f52a562240f32a757268c63589b1e4c3a0f934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4f52a562240f32a757268c63589b1e4c3a0f934", "html_url": "https://github.com/rust-lang/rust/commit/a4f52a562240f32a757268c63589b1e4c3a0f934", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4f52a562240f32a757268c63589b1e4c3a0f934/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1603a70f82240ba2d27f72f964e36614d7620ad3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1603a70f82240ba2d27f72f964e36614d7620ad3", "html_url": "https://github.com/rust-lang/rust/commit/1603a70f82240ba2d27f72f964e36614d7620ad3"}], "stats": {"total": 347, "additions": 175, "deletions": 172}, "files": [{"sha": "da15c3c2b1fabe2dd2ebf888fc2d7bb737077cdf", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4f52a562240f32a757268c63589b1e4c3a0f934/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f52a562240f32a757268c63589b1e4c3a0f934/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=a4f52a562240f32a757268c63589b1e4c3a0f934", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             items: cx.tcx\n                                 .associated_items(impl_def_id)\n                                 .in_definition_order()\n-                                .map(|x| x.clean(cx))\n+                                .map(|x| clean_middle_assoc_item(x, cx))\n                                 .collect::<Vec<_>>(),\n                             polarity: ty::ImplPolarity::Positive,\n                             kind: ImplKind::Blanket(Box::new(clean_middle_ty(trait_ref.0.self_ty(), cx, None))),"}, {"sha": "e56a715e85780668e0a0a5915390d5c320300a35", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a4f52a562240f32a757268c63589b1e4c3a0f934/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f52a562240f32a757268c63589b1e4c3a0f934/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=a4f52a562240f32a757268c63589b1e4c3a0f934", "patch": "@@ -16,9 +16,10 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n-    self, clean_fn_decl_from_did_and_sig, clean_generics, clean_impl_item, clean_middle_field,\n-    clean_middle_ty, clean_trait_ref_with_bindings, clean_ty, clean_ty_generics, clean_variant_def,\n-    clean_visibility, utils, Attributes, AttributesExt, Clean, ImplKind, ItemId, Type, Visibility,\n+    self, clean_fn_decl_from_did_and_sig, clean_generics, clean_impl_item, clean_middle_assoc_item,\n+    clean_middle_field, clean_middle_ty, clean_trait_ref_with_bindings, clean_ty,\n+    clean_ty_generics, clean_variant_def, clean_visibility, utils, Attributes, AttributesExt,\n+    ImplKind, ItemId, Type, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -217,7 +218,7 @@ pub(crate) fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean\n             // which causes methods to have a `pub` prefix, which is invalid since items in traits\n             // can not have a visibility prefix. Thus we override the visibility here manually.\n             // See https://github.com/rust-lang/rust/issues/81274\n-            clean::Item { visibility: Visibility::Inherited, ..item.clean(cx) }\n+            clean::Item { visibility: Visibility::Inherited, ..clean_middle_assoc_item(item, cx) }\n         })\n         .collect();\n \n@@ -452,7 +453,7 @@ pub(crate) fn build_impl(\n                         item.visibility(tcx).is_public()\n                     }\n                 })\n-                .map(|item| item.clean(cx))\n+                .map(|item| clean_middle_assoc_item(item, cx))\n                 .collect::<Vec<_>>(),\n             clean::enter_impl_trait(cx, |cx| {\n                 clean_ty_generics(cx, tcx.generics_of(did), predicates)"}, {"sha": "8c983e3e23055294bc31221b0d2a349911bdbe99", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 168, "deletions": 166, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/a4f52a562240f32a757268c63589b1e4c3a0f934/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f52a562240f32a757268c63589b1e4c3a0f934/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a4f52a562240f32a757268c63589b1e4c3a0f934", "patch": "@@ -1092,199 +1092,201 @@ pub(crate) fn clean_impl_item<'tcx>(\n     })\n }\n \n-impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        let tcx = cx.tcx;\n-        let kind = match self.kind {\n-            ty::AssocKind::Const => {\n-                let ty = clean_middle_ty(tcx.type_of(self.def_id), cx, Some(self.def_id));\n-\n-                let provided = match self.container {\n-                    ty::ImplContainer => true,\n-                    ty::TraitContainer => tcx.impl_defaultness(self.def_id).has_value(),\n-                };\n-                if provided {\n-                    AssocConstItem(ty, ConstantKind::Extern { def_id: self.def_id })\n-                } else {\n-                    TyAssocConstItem(ty)\n-                }\n+pub(crate) fn clean_middle_assoc_item<'tcx>(\n+    assoc_item: &ty::AssocItem,\n+    cx: &mut DocContext<'tcx>,\n+) -> Item {\n+    let tcx = cx.tcx;\n+    let kind = match assoc_item.kind {\n+        ty::AssocKind::Const => {\n+            let ty = clean_middle_ty(tcx.type_of(assoc_item.def_id), cx, Some(assoc_item.def_id));\n+\n+            let provided = match assoc_item.container {\n+                ty::ImplContainer => true,\n+                ty::TraitContainer => tcx.impl_defaultness(assoc_item.def_id).has_value(),\n+            };\n+            if provided {\n+                AssocConstItem(ty, ConstantKind::Extern { def_id: assoc_item.def_id })\n+            } else {\n+                TyAssocConstItem(ty)\n             }\n-            ty::AssocKind::Fn => {\n-                let generics = clean_ty_generics(\n-                    cx,\n-                    tcx.generics_of(self.def_id),\n-                    tcx.explicit_predicates_of(self.def_id),\n-                );\n-                let sig = tcx.fn_sig(self.def_id);\n-                let mut decl = clean_fn_decl_from_did_and_sig(cx, Some(self.def_id), sig);\n-\n-                if self.fn_has_self_parameter {\n-                    let self_ty = match self.container {\n-                        ty::ImplContainer => tcx.type_of(self.container_id(tcx)),\n-                        ty::TraitContainer => tcx.types.self_param,\n-                    };\n-                    let self_arg_ty = sig.input(0).skip_binder();\n-                    if self_arg_ty == self_ty {\n-                        decl.inputs.values[0].type_ = Generic(kw::SelfUpper);\n-                    } else if let ty::Ref(_, ty, _) = *self_arg_ty.kind() {\n-                        if ty == self_ty {\n-                            match decl.inputs.values[0].type_ {\n-                                BorrowedRef { ref mut type_, .. } => {\n-                                    **type_ = Generic(kw::SelfUpper)\n-                                }\n-                                _ => unreachable!(),\n-                            }\n+        }\n+        ty::AssocKind::Fn => {\n+            let generics = clean_ty_generics(\n+                cx,\n+                tcx.generics_of(assoc_item.def_id),\n+                tcx.explicit_predicates_of(assoc_item.def_id),\n+            );\n+            let sig = tcx.fn_sig(assoc_item.def_id);\n+            let mut decl = clean_fn_decl_from_did_and_sig(cx, Some(assoc_item.def_id), sig);\n+\n+            if assoc_item.fn_has_self_parameter {\n+                let self_ty = match assoc_item.container {\n+                    ty::ImplContainer => tcx.type_of(assoc_item.container_id(tcx)),\n+                    ty::TraitContainer => tcx.types.self_param,\n+                };\n+                let self_arg_ty = sig.input(0).skip_binder();\n+                if self_arg_ty == self_ty {\n+                    decl.inputs.values[0].type_ = Generic(kw::SelfUpper);\n+                } else if let ty::Ref(_, ty, _) = *self_arg_ty.kind() {\n+                    if ty == self_ty {\n+                        match decl.inputs.values[0].type_ {\n+                            BorrowedRef { ref mut type_, .. } => **type_ = Generic(kw::SelfUpper),\n+                            _ => unreachable!(),\n                         }\n                     }\n                 }\n+            }\n \n-                let provided = match self.container {\n-                    ty::ImplContainer => true,\n-                    ty::TraitContainer => self.defaultness(tcx).has_value(),\n+            let provided = match assoc_item.container {\n+                ty::ImplContainer => true,\n+                ty::TraitContainer => assoc_item.defaultness(tcx).has_value(),\n+            };\n+            if provided {\n+                let defaultness = match assoc_item.container {\n+                    ty::ImplContainer => Some(assoc_item.defaultness(tcx)),\n+                    ty::TraitContainer => None,\n                 };\n-                if provided {\n-                    let defaultness = match self.container {\n-                        ty::ImplContainer => Some(self.defaultness(tcx)),\n-                        ty::TraitContainer => None,\n-                    };\n-                    MethodItem(Box::new(Function { generics, decl }), defaultness)\n-                } else {\n-                    TyMethodItem(Box::new(Function { generics, decl }))\n-                }\n+                MethodItem(Box::new(Function { generics, decl }), defaultness)\n+            } else {\n+                TyMethodItem(Box::new(Function { generics, decl }))\n             }\n-            ty::AssocKind::Type => {\n-                let my_name = self.name;\n-\n-                fn param_eq_arg(param: &GenericParamDef, arg: &GenericArg) -> bool {\n-                    match (&param.kind, arg) {\n-                        (GenericParamDefKind::Type { .. }, GenericArg::Type(Type::Generic(ty)))\n-                            if *ty == param.name =>\n-                        {\n-                            true\n-                        }\n-                        (\n-                            GenericParamDefKind::Lifetime { .. },\n-                            GenericArg::Lifetime(Lifetime(lt)),\n-                        ) if *lt == param.name => true,\n-                        (GenericParamDefKind::Const { .. }, GenericArg::Const(c)) => {\n-                            match &c.kind {\n-                                ConstantKind::TyConst { expr } => expr == param.name.as_str(),\n-                                _ => false,\n-                            }\n-                        }\n-                        _ => false,\n+        }\n+        ty::AssocKind::Type => {\n+            let my_name = assoc_item.name;\n+\n+            fn param_eq_arg(param: &GenericParamDef, arg: &GenericArg) -> bool {\n+                match (&param.kind, arg) {\n+                    (GenericParamDefKind::Type { .. }, GenericArg::Type(Type::Generic(ty)))\n+                        if *ty == param.name =>\n+                    {\n+                        true\n                     }\n+                    (GenericParamDefKind::Lifetime { .. }, GenericArg::Lifetime(Lifetime(lt)))\n+                        if *lt == param.name =>\n+                    {\n+                        true\n+                    }\n+                    (GenericParamDefKind::Const { .. }, GenericArg::Const(c)) => match &c.kind {\n+                        ConstantKind::TyConst { expr } => expr == param.name.as_str(),\n+                        _ => false,\n+                    },\n+                    _ => false,\n                 }\n+            }\n \n-                if let ty::TraitContainer = self.container {\n-                    let bounds = tcx.explicit_item_bounds(self.def_id);\n-                    let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n-                    let mut generics =\n-                        clean_ty_generics(cx, tcx.generics_of(self.def_id), predicates);\n-                    // Filter out the bounds that are (likely?) directly attached to the associated type,\n-                    // as opposed to being located in the where clause.\n-                    let mut bounds = generics\n-                        .where_predicates\n-                        .drain_filter(|pred| match *pred {\n-                            WherePredicate::BoundPredicate {\n-                                ty: QPath { ref assoc, ref self_type, ref trait_, .. },\n-                                ..\n-                            } => {\n-                                if assoc.name != my_name {\n-                                    return false;\n-                                }\n-                                if trait_.def_id() != self.container_id(tcx) {\n-                                    return false;\n-                                }\n-                                match **self_type {\n-                                    Generic(ref s) if *s == kw::SelfUpper => {}\n-                                    _ => return false,\n-                                }\n-                                match &assoc.args {\n-                                    GenericArgs::AngleBracketed { args, bindings } => {\n-                                        if !bindings.is_empty()\n-                                            || generics\n-                                                .params\n-                                                .iter()\n-                                                .zip(args.iter())\n-                                                .any(|(param, arg)| !param_eq_arg(param, arg))\n-                                        {\n-                                            return false;\n-                                        }\n-                                    }\n-                                    GenericArgs::Parenthesized { .. } => {\n-                                        // The only time this happens is if we're inside the rustdoc for Fn(),\n-                                        // which only has one associated type, which is not a GAT, so whatever.\n+            if let ty::TraitContainer = assoc_item.container {\n+                let bounds = tcx.explicit_item_bounds(assoc_item.def_id);\n+                let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n+                let mut generics =\n+                    clean_ty_generics(cx, tcx.generics_of(assoc_item.def_id), predicates);\n+                // Filter out the bounds that are (likely?) directly attached to the associated type,\n+                // as opposed to being located in the where clause.\n+                let mut bounds = generics\n+                    .where_predicates\n+                    .drain_filter(|pred| match *pred {\n+                        WherePredicate::BoundPredicate {\n+                            ty: QPath { ref assoc, ref self_type, ref trait_, .. },\n+                            ..\n+                        } => {\n+                            if assoc.name != my_name {\n+                                return false;\n+                            }\n+                            if trait_.def_id() != assoc_item.container_id(tcx) {\n+                                return false;\n+                            }\n+                            match **self_type {\n+                                Generic(ref s) if *s == kw::SelfUpper => {}\n+                                _ => return false,\n+                            }\n+                            match &assoc.args {\n+                                GenericArgs::AngleBracketed { args, bindings } => {\n+                                    if !bindings.is_empty()\n+                                        || generics\n+                                            .params\n+                                            .iter()\n+                                            .zip(args.iter())\n+                                            .any(|(param, arg)| !param_eq_arg(param, arg))\n+                                    {\n+                                        return false;\n                                     }\n                                 }\n-                                true\n-                            }\n-                            _ => false,\n-                        })\n-                        .flat_map(|pred| {\n-                            if let WherePredicate::BoundPredicate { bounds, .. } = pred {\n-                                bounds\n-                            } else {\n-                                unreachable!()\n+                                GenericArgs::Parenthesized { .. } => {\n+                                    // The only time this happens is if we're inside the rustdoc for Fn(),\n+                                    // which only has one associated type, which is not a GAT, so whatever.\n+                                }\n                             }\n-                        })\n-                        .collect::<Vec<_>>();\n-                    // Our Sized/?Sized bound didn't get handled when creating the generics\n-                    // because we didn't actually get our whole set of bounds until just now\n-                    // (some of them may have come from the trait). If we do have a sized\n-                    // bound, we remove it, and if we don't then we add the `?Sized` bound\n-                    // at the end.\n-                    match bounds.iter().position(|b| b.is_sized_bound(cx)) {\n-                        Some(i) => {\n-                            bounds.remove(i);\n+                            true\n                         }\n-                        None => bounds.push(GenericBound::maybe_sized(cx)),\n+                        _ => false,\n+                    })\n+                    .flat_map(|pred| {\n+                        if let WherePredicate::BoundPredicate { bounds, .. } = pred {\n+                            bounds\n+                        } else {\n+                            unreachable!()\n+                        }\n+                    })\n+                    .collect::<Vec<_>>();\n+                // Our Sized/?Sized bound didn't get handled when creating the generics\n+                // because we didn't actually get our whole set of bounds until just now\n+                // (some of them may have come from the trait). If we do have a sized\n+                // bound, we remove it, and if we don't then we add the `?Sized` bound\n+                // at the end.\n+                match bounds.iter().position(|b| b.is_sized_bound(cx)) {\n+                    Some(i) => {\n+                        bounds.remove(i);\n                     }\n+                    None => bounds.push(GenericBound::maybe_sized(cx)),\n+                }\n \n-                    if tcx.impl_defaultness(self.def_id).has_value() {\n-                        AssocTypeItem(\n-                            Box::new(Typedef {\n-                                type_: clean_middle_ty(\n-                                    tcx.type_of(self.def_id),\n-                                    cx,\n-                                    Some(self.def_id),\n-                                ),\n-                                generics,\n-                                // FIXME: should we obtain the Type from HIR and pass it on here?\n-                                item_type: None,\n-                            }),\n-                            bounds,\n-                        )\n-                    } else {\n-                        TyAssocTypeItem(Box::new(generics), bounds)\n-                    }\n-                } else {\n-                    // FIXME: when could this happen? Associated items in inherent impls?\n+                if tcx.impl_defaultness(assoc_item.def_id).has_value() {\n                     AssocTypeItem(\n                         Box::new(Typedef {\n-                            type_: clean_middle_ty(tcx.type_of(self.def_id), cx, Some(self.def_id)),\n-                            generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n+                            type_: clean_middle_ty(\n+                                tcx.type_of(assoc_item.def_id),\n+                                cx,\n+                                Some(assoc_item.def_id),\n+                            ),\n+                            generics,\n+                            // FIXME: should we obtain the Type from HIR and pass it on here?\n                             item_type: None,\n                         }),\n-                        Vec::new(),\n+                        bounds,\n                     )\n+                } else {\n+                    TyAssocTypeItem(Box::new(generics), bounds)\n                 }\n+            } else {\n+                // FIXME: when could this happen? Associated items in inherent impls?\n+                AssocTypeItem(\n+                    Box::new(Typedef {\n+                        type_: clean_middle_ty(\n+                            tcx.type_of(assoc_item.def_id),\n+                            cx,\n+                            Some(assoc_item.def_id),\n+                        ),\n+                        generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n+                        item_type: None,\n+                    }),\n+                    Vec::new(),\n+                )\n             }\n-        };\n-\n-        let mut what_rustc_thinks =\n-            Item::from_def_id_and_parts(self.def_id, Some(self.name), kind, cx);\n+        }\n+    };\n \n-        let impl_ref = tcx.impl_trait_ref(tcx.parent(self.def_id));\n+    let mut what_rustc_thinks =\n+        Item::from_def_id_and_parts(assoc_item.def_id, Some(assoc_item.name), kind, cx);\n \n-        // Trait impl items always inherit the impl's visibility --\n-        // we don't want to show `pub`.\n-        if impl_ref.is_some() {\n-            what_rustc_thinks.visibility = Visibility::Inherited;\n-        }\n+    let impl_ref = tcx.impl_trait_ref(tcx.parent(assoc_item.def_id));\n \n-        what_rustc_thinks\n+    // Trait impl items always inherit the impl's visibility --\n+    // we don't want to show `pub`.\n+    if impl_ref.is_some() {\n+        what_rustc_thinks.visibility = Visibility::Inherited;\n     }\n+\n+    what_rustc_thinks\n }\n \n fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type {"}]}