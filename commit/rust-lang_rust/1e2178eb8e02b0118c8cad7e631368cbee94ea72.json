{"sha": "1e2178eb8e02b0118c8cad7e631368cbee94ea72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMjE3OGViOGUwMmIwMTE4YzhjYWQ3ZTYzMTM2OGNiZWU5NGVhNzI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-07T13:22:18Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-07T13:22:18Z"}, "message": "Merge #1103\n\n1103: Array inference r=flodiebold a=Lapz\n\nFixes the final item in #394. The only problem is that infering the repeat cause some types to be infered twices.\r\ni.e \r\n```rust\r\nfn test() {\r\n    let y = unknown;\r\n    [y, &y];\r\n}\r\n```\r\n\r\nresults in the following diff:\r\n\r\n```diff\r\n[11; 48) '{     ...&y]; }': ()\r\n[21; 22) 'y': &{unknown}\r\n[25; 32) 'unknown': &{unknown}\r\n-[38; 45) '[y, &y]': [&&{unknown}]\r\n+[38; 45) '[y, &y]': [&&{unknown};usize]\r\n[39; 40) 'y': &{unknown}\r\n+[39; 40) 'y': &{unknown}\r\n[42; 44) '&y': &&{unknown}\r\n[43; 44) 'y': &{unknown}\r\n```\r\n\r\nShould the code produce two inference results for 'y' and if not could any tell me what needs to change.\n\nCo-authored-by: Lenard Pratt <l3np27@gmail.com>", "tree": {"sha": "141bc3c57c8b1436e188abb6fd73468567a7d411", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/141bc3c57c8b1436e188abb6fd73468567a7d411"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e2178eb8e02b0118c8cad7e631368cbee94ea72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e2178eb8e02b0118c8cad7e631368cbee94ea72", "html_url": "https://github.com/rust-lang/rust/commit/1e2178eb8e02b0118c8cad7e631368cbee94ea72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e2178eb8e02b0118c8cad7e631368cbee94ea72/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "36f5d997565b6390a4b524e7e1d0d805f0f26bdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/36f5d997565b6390a4b524e7e1d0d805f0f26bdb", "html_url": "https://github.com/rust-lang/rust/commit/36f5d997565b6390a4b524e7e1d0d805f0f26bdb"}, {"sha": "b27fa33a9f459feb442682026670ca8e6001a424", "url": "https://api.github.com/repos/rust-lang/rust/commits/b27fa33a9f459feb442682026670ca8e6001a424", "html_url": "https://github.com/rust-lang/rust/commit/b27fa33a9f459feb442682026670ca8e6001a424"}], "stats": {"total": 179, "additions": 124, "deletions": 55}, "files": [{"sha": "589a9b2db2aa322487385e3a74b840843c61c559", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1e2178eb8e02b0118c8cad7e631368cbee94ea72/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2178eb8e02b0118c8cad7e631368cbee94ea72/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=1e2178eb8e02b0118c8cad7e631368cbee94ea72", "patch": "@@ -6,7 +6,7 @@ use rustc_hash::FxHashMap;\n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use ra_syntax::{\n     SyntaxNodePtr, AstPtr, AstNode,\n-    ast::{self, LoopBodyOwner, ArgListOwner, NameOwner, LiteralKind, TypeAscriptionOwner}\n+    ast::{self, LoopBodyOwner, ArgListOwner, NameOwner, LiteralKind,ArrayExprKind, TypeAscriptionOwner}\n };\n \n use crate::{\n@@ -238,14 +238,17 @@ pub enum Expr {\n     Tuple {\n         exprs: Vec<ExprId>,\n     },\n-    Array {\n-        exprs: Vec<ExprId>,\n-    },\n+    Array(Array),\n     Literal(Literal),\n }\n \n pub use ra_syntax::ast::PrefixOp as UnaryOp;\n pub use ra_syntax::ast::BinOp as BinaryOp;\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Array {\n+    ElementList(Vec<ExprId>),\n+    Repeat { initializer: ExprId, repeat: ExprId },\n+}\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct MatchArm {\n@@ -348,11 +351,22 @@ impl Expr {\n             | Expr::UnaryOp { expr, .. } => {\n                 f(*expr);\n             }\n-            Expr::Tuple { exprs } | Expr::Array { exprs } => {\n+            Expr::Tuple { exprs } => {\n                 for expr in exprs {\n                     f(*expr);\n                 }\n             }\n+            Expr::Array(a) => match a {\n+                Array::ElementList(exprs) => {\n+                    for expr in exprs {\n+                        f(*expr);\n+                    }\n+                }\n+                Array::Repeat { initializer, repeat } => {\n+                    f(*initializer);\n+                    f(*repeat)\n+                }\n+            },\n             Expr::Literal(_) => {}\n         }\n     }\n@@ -723,10 +737,26 @@ impl ExprCollector {\n                 let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n                 self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n             }\n+\n             ast::ExprKind::ArrayExpr(e) => {\n-                let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n-                self.alloc_expr(Expr::Array { exprs }, syntax_ptr)\n+                let kind = e.kind();\n+\n+                match kind {\n+                    ArrayExprKind::ElementList(e) => {\n+                        let exprs = e.map(|expr| self.collect_expr(expr)).collect();\n+                        self.alloc_expr(Expr::Array(Array::ElementList(exprs)), syntax_ptr)\n+                    }\n+                    ArrayExprKind::Repeat { initializer, repeat } => {\n+                        let initializer = self.collect_expr_opt(initializer);\n+                        let repeat = self.collect_expr_opt(repeat);\n+                        self.alloc_expr(\n+                            Expr::Array(Array::Repeat { initializer, repeat }),\n+                            syntax_ptr,\n+                        )\n+                    }\n+                }\n             }\n+\n             ast::ExprKind::Literal(e) => {\n                 let lit = match e.kind() {\n                     LiteralKind::IntNumber { suffix } => {"}, {"sha": "20e55d92d09ab08c445ff8eee3817a7737a9c45b", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e2178eb8e02b0118c8cad7e631368cbee94ea72/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2178eb8e02b0118c8cad7e631368cbee94ea72/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=1e2178eb8e02b0118c8cad7e631368cbee94ea72", "patch": "@@ -353,10 +353,14 @@ impl HirDisplay for ApplicationTy {\n             TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n             TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n             TypeCtor::Str => write!(f, \"str\")?,\n-            TypeCtor::Slice | TypeCtor::Array => {\n+            TypeCtor::Slice => {\n                 let t = self.parameters.as_single();\n                 write!(f, \"[{}]\", t.display(f.db))?;\n             }\n+            TypeCtor::Array => {\n+                let t = self.parameters.as_single();\n+                write!(f, \"[{};_]\", t.display(f.db))?;\n+            }\n             TypeCtor::RawPtr(m) => {\n                 let t = self.parameters.as_single();\n                 write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t.display(f.db))?;"}, {"sha": "9ace6b13a01b039f2294e9dea6e6addac0abd79f", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1e2178eb8e02b0118c8cad7e631368cbee94ea72/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2178eb8e02b0118c8cad7e631368cbee94ea72/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=1e2178eb8e02b0118c8cad7e631368cbee94ea72", "patch": "@@ -32,7 +32,7 @@ use crate::{\n     DefWithBody,\n     ImplItem,\n     type_ref::{TypeRef, Mutability},\n-    expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat, self},\n+    expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat,Array, self},\n     generics::GenericParams,\n     path::{GenericArgs, GenericArg},\n     adt::VariantDef,\n@@ -1074,7 +1074,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 Ty::apply(TypeCtor::Tuple, Substs(ty_vec.into()))\n             }\n-            Expr::Array { exprs } => {\n+            Expr::Array(array) => {\n                 let elem_ty = match &expected.ty {\n                     Ty::Apply(a_ty) => match a_ty.ctor {\n                         TypeCtor::Slice | TypeCtor::Array => {\n@@ -1085,8 +1085,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     _ => self.new_type_var(),\n                 };\n \n-                for expr in exprs.iter() {\n-                    self.infer_expr(*expr, &Expectation::has_type(elem_ty.clone()));\n+                match array {\n+                    Array::ElementList(items) => {\n+                        for expr in items.iter() {\n+                            self.infer_expr(*expr, &Expectation::has_type(elem_ty.clone()));\n+                        }\n+                    }\n+                    Array::Repeat { initializer, repeat } => {\n+                        self.infer_expr(*initializer, &Expectation::has_type(elem_ty.clone()));\n+                        self.infer_expr(\n+                            *repeat,\n+                            &Expectation::has_type(Ty::simple(TypeCtor::Int(\n+                                primitive::UncertainIntTy::Known(primitive::IntTy::usize()),\n+                            ))),\n+                        );\n+                    }\n                 }\n \n                 Ty::apply_one(TypeCtor::Array, elem_ty)"}, {"sha": "f6a325033dacba47558007f4eb1f453fa17df100", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1e2178eb8e02b0118c8cad7e631368cbee94ea72/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2178eb8e02b0118c8cad7e631368cbee94ea72/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=1e2178eb8e02b0118c8cad7e631368cbee94ea72", "patch": "@@ -697,58 +697,58 @@ fn test(x: &str, y: isize) {\n [9; 10) 'x': &str\n [18; 19) 'y': isize\n [28; 324) '{     ... 3]; }': ()\n-[38; 39) 'a': [&str]\n-[42; 45) '[x]': [&str]\n+[38; 39) 'a': [&str;_]\n+[42; 45) '[x]': [&str;_]\n [43; 44) 'x': &str\n-[55; 56) 'b': [[&str]]\n-[59; 65) '[a, a]': [[&str]]\n-[60; 61) 'a': [&str]\n-[63; 64) 'a': [&str]\n-[75; 76) 'c': [[[&str]]]\n-[79; 85) '[b, b]': [[[&str]]]\n-[80; 81) 'b': [[&str]]\n-[83; 84) 'b': [[&str]]\n-[96; 97) 'd': [isize]\n-[100; 112) '[y, 1, 2, 3]': [isize]\n+[55; 56) 'b': [[&str;_];_]\n+[59; 65) '[a, a]': [[&str;_];_]\n+[60; 61) 'a': [&str;_]\n+[63; 64) 'a': [&str;_]\n+[75; 76) 'c': [[[&str;_];_];_]\n+[79; 85) '[b, b]': [[[&str;_];_];_]\n+[80; 81) 'b': [[&str;_];_]\n+[83; 84) 'b': [[&str;_];_]\n+[96; 97) 'd': [isize;_]\n+[100; 112) '[y, 1, 2, 3]': [isize;_]\n [101; 102) 'y': isize\n [104; 105) '1': isize\n [107; 108) '2': isize\n [110; 111) '3': isize\n-[122; 123) 'd': [isize]\n-[126; 138) '[1, y, 2, 3]': [isize]\n+[122; 123) 'd': [isize;_]\n+[126; 138) '[1, y, 2, 3]': [isize;_]\n [127; 128) '1': isize\n [130; 131) 'y': isize\n [133; 134) '2': isize\n [136; 137) '3': isize\n-[148; 149) 'e': [isize]\n-[152; 155) '[y]': [isize]\n+[148; 149) 'e': [isize;_]\n+[152; 155) '[y]': [isize;_]\n [153; 154) 'y': isize\n-[165; 166) 'f': [[isize]]\n-[169; 175) '[d, d]': [[isize]]\n-[170; 171) 'd': [isize]\n-[173; 174) 'd': [isize]\n-[185; 186) 'g': [[isize]]\n-[189; 195) '[e, e]': [[isize]]\n-[190; 191) 'e': [isize]\n-[193; 194) 'e': [isize]\n-[206; 207) 'h': [i32]\n-[210; 216) '[1, 2]': [i32]\n+[165; 166) 'f': [[isize;_];_]\n+[169; 175) '[d, d]': [[isize;_];_]\n+[170; 171) 'd': [isize;_]\n+[173; 174) 'd': [isize;_]\n+[185; 186) 'g': [[isize;_];_]\n+[189; 195) '[e, e]': [[isize;_];_]\n+[190; 191) 'e': [isize;_]\n+[193; 194) 'e': [isize;_]\n+[206; 207) 'h': [i32;_]\n+[210; 216) '[1, 2]': [i32;_]\n [211; 212) '1': i32\n [214; 215) '2': i32\n-[226; 227) 'i': [&str]\n-[230; 240) '[\"a\", \"b\"]': [&str]\n+[226; 227) 'i': [&str;_]\n+[230; 240) '[\"a\", \"b\"]': [&str;_]\n [231; 234) '\"a\"': &str\n [236; 239) '\"b\"': &str\n-[251; 252) 'b': [[&str]]\n-[255; 265) '[a, [\"b\"]]': [[&str]]\n-[256; 257) 'a': [&str]\n-[259; 264) '[\"b\"]': [&str]\n+[251; 252) 'b': [[&str;_];_]\n+[255; 265) '[a, [\"b\"]]': [[&str;_];_]\n+[256; 257) 'a': [&str;_]\n+[259; 264) '[\"b\"]': [&str;_]\n [260; 263) '\"b\"': &str\n-[275; 276) 'x': [u8]\n-[288; 290) '[]': [u8]\n-[300; 301) 'z': &[u8]\n-[311; 321) '&[1, 2, 3]': &[u8]\n-[312; 321) '[1, 2, 3]': [u8]\n+[275; 276) 'x': [u8;_]\n+[288; 290) '[]': [u8;_]\n+[300; 301) 'z': &[u8;_]\n+[311; 321) '&[1, 2, 3]': &[u8;_]\n+[312; 321) '[1, 2, 3]': [u8;_]\n [313; 314) '1': u8\n [316; 317) '2': u8\n [319; 320) '3': u8\"###\n@@ -1553,7 +1553,7 @@ fn test() {\n [11; 48) '{     ...&y]; }': ()\n [21; 22) 'y': &{unknown}\n [25; 32) 'unknown': &{unknown}\n-[38; 45) '[y, &y]': [&&{unknown}]\n+[38; 45) '[y, &y]': [&&{unknown};_]\n [39; 40) 'y': &{unknown}\n [42; 44) '&y': &&{unknown}\n [43; 44) 'y': &{unknown}\"###\n@@ -1578,7 +1578,7 @@ fn test() {\n [25; 32) 'unknown': &&{unknown}\n [42; 43) 'y': &&{unknown}\n [46; 53) 'unknown': &&{unknown}\n-[59; 77) '[(x, y..., &x)]': [(&&{unknown}, &&{unknown})]\n+[59; 77) '[(x, y..., &x)]': [(&&{unknown}, &&{unknown});_]\n [60; 66) '(x, y)': (&&{unknown}, &&{unknown})\n [61; 62) 'x': &&{unknown}\n [64; 65) 'y': &&{unknown}\n@@ -1670,8 +1670,8 @@ fn test_line_buffer() {\n \"#),\n         @r###\"\n [23; 53) '{     ...n']; }': ()\n-[29; 50) '&[0, b...b'\\n']': &[u8]\n-[30; 50) '[0, b'...b'\\n']': [u8]\n+[29; 50) '&[0, b...b'\\n']': &[u8;_]\n+[30; 50) '[0, b'...b'\\n']': [u8;_]\n [31; 32) '0': u8\n [34; 39) 'b'\\n'': u8\n [41; 42) '1': u8"}, {"sha": "c2ab19d97b88edb799dbea45ee96678f772ad733", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e2178eb8e02b0118c8cad7e631368cbee94ea72/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2178eb8e02b0118c8cad7e631368cbee94ea72/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=1e2178eb8e02b0118c8cad7e631368cbee94ea72", "patch": "@@ -17,8 +17,8 @@ pub use self::{\n     generated::*,\n     traits::*,\n     tokens::*,\n-    extensions::{PathSegmentKind, StructKind, FieldKind, SelfParamKind},\n-    expr_extensions::{ElseBranch, PrefixOp, BinOp, LiteralKind},\n+    extensions::{PathSegmentKind, StructKind,FieldKind, SelfParamKind},\n+    expr_extensions::{ElseBranch, PrefixOp, BinOp, LiteralKind,ArrayExprKind},\n };\n \n /// The main trait to go from untyped `SyntaxNode`  to a typed ast. The"}, {"sha": "9484c3b9b57965ae925f3b577a4a15f497c1df2d", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1e2178eb8e02b0118c8cad7e631368cbee94ea72/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2178eb8e02b0118c8cad7e631368cbee94ea72/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=1e2178eb8e02b0118c8cad7e631368cbee94ea72", "patch": "@@ -193,6 +193,28 @@ impl ast::BinExpr {\n     }\n }\n \n+pub enum ArrayExprKind<'a> {\n+    Repeat { initializer: Option<&'a ast::Expr>, repeat: Option<&'a ast::Expr> },\n+    ElementList(AstChildren<'a, ast::Expr>),\n+}\n+\n+impl ast::ArrayExpr {\n+    pub fn kind(&self) -> ArrayExprKind {\n+        if self.is_repeat() {\n+            ArrayExprKind::Repeat {\n+                initializer: children(self).nth(0),\n+                repeat: children(self).nth(1),\n+            }\n+        } else {\n+            ArrayExprKind::ElementList(children(self))\n+        }\n+    }\n+\n+    fn is_repeat(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|it| it.kind() == SEMI)\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub enum LiteralKind {\n     String,"}]}