{"sha": "5f4e73c4a4212922f0c24c6743b3837902619200", "node_id": "C_kwDOAAsO6NoAKDVmNGU3M2M0YTQyMTI5MjJmMGMyNGM2NzQzYjM4Mzc5MDI2MTkyMDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-12T08:03:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-12T08:03:01Z"}, "message": "Auto merge of #104310 - Dylan-DPC:rollup-wgt1z4a, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #102049 (Add the `#[derive_const]` attribute)\n - #103970 (Unhide unknown spans)\n - #104206 (Remove `save_and_restore_in_snapshot_flag`, use `ObligationCtxt` more)\n - #104214 (Emit error in `collecting_trait_impl_trait_tys` on mismatched signatures)\n - #104267 (rustdoc: use checkbox instead of switch for settings toggles)\n - #104302 (Update cargo)\n - #104303 (UI tests can be assigned to T-compiler)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "80f8aeffccad3f1429e4d205a41257497fcb740b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80f8aeffccad3f1429e4d205a41257497fcb740b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f4e73c4a4212922f0c24c6743b3837902619200", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f4e73c4a4212922f0c24c6743b3837902619200", "html_url": "https://github.com/rust-lang/rust/commit/5f4e73c4a4212922f0c24c6743b3837902619200", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f4e73c4a4212922f0c24c6743b3837902619200/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "825f8edc2fff167304d40c826f136e82967d68f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/825f8edc2fff167304d40c826f136e82967d68f3", "html_url": "https://github.com/rust-lang/rust/commit/825f8edc2fff167304d40c826f136e82967d68f3"}, {"sha": "feff57b3e8152660bb11cfb871546e0afc90abc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/feff57b3e8152660bb11cfb871546e0afc90abc2", "html_url": "https://github.com/rust-lang/rust/commit/feff57b3e8152660bb11cfb871546e0afc90abc2"}], "stats": {"total": 1272, "additions": 796, "deletions": 476}, "files": [{"sha": "c105d04c1f44004e673deec3060417603cca9ba1", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -273,7 +273,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.67.0\"\n+version = \"0.68.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\","}, {"sha": "86df3c44eb334e7b51aa65ad268417f170162c4b", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -34,6 +34,7 @@ impl MultiItemModifier for Expander {\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        _is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let template = AttributeTemplate { list: Some(\"path\"), ..Default::default() };\n         let attr = &ecx.attribute(meta_item.clone());"}, {"sha": "01f237e6ab5fa3d085a9b1e09ab103bc31e97dc9", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -10,7 +10,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n-pub(crate) struct Expander;\n+pub(crate) struct Expander(pub bool);\n \n impl MultiItemModifier for Expander {\n     fn expand(\n@@ -19,6 +19,7 @@ impl MultiItemModifier for Expander {\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        _: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let sess = ecx.sess;\n         if report_bad_target(sess, &item, span) {\n@@ -58,20 +59,20 @@ impl MultiItemModifier for Expander {\n                         report_path_args(sess, &meta);\n                         meta.path\n                     })\n-                    .map(|path| (path, dummy_annotatable(), None))\n+                    .map(|path| (path, dummy_annotatable(), None, self.0))\n                     .collect();\n \n                 // Do not configure or clone items unless necessary.\n                 match &mut resolutions[..] {\n                     [] => {}\n-                    [(_, first_item, _), others @ ..] => {\n+                    [(_, first_item, ..), others @ ..] => {\n                         *first_item = cfg_eval(\n                             sess,\n                             features,\n                             item.clone(),\n                             ecx.current_expansion.lint_node_id,\n                         );\n-                        for (_, item, _) in others {\n+                        for (_, item, _, _) in others {\n                             *item = first_item.clone();\n                         }\n                     }"}, {"sha": "345db700298a81813d544b00197b4a89b1daba3f", "filename": "compiler/rustc_builtin_macros/src/deriving/bounds.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -12,6 +12,7 @@ pub fn expand_deriving_copy(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let trait_def = TraitDef {\n         span,\n@@ -22,6 +23,7 @@ pub fn expand_deriving_copy(\n         supports_unions: true,\n         methods: Vec::new(),\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand(cx, mitem, item, push);"}, {"sha": "55cbb65472328bd88554fb009226f98cb14a8829", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -14,6 +14,7 @@ pub fn expand_deriving_clone(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     // The simple form is `fn clone(&self) -> Self { *self }`, possibly with\n     // some additional `AssertParamIsClone` assertions.\n@@ -87,6 +88,7 @@ pub fn expand_deriving_clone(\n             combine_substructure: substructure,\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand_ext(cx, mitem, item, push, is_simple)"}, {"sha": "6190b7a8c779eb385bc4db2b7c05b4b8bd815c03", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -15,6 +15,7 @@ pub fn expand_deriving_eq(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let span = cx.with_def_site_ctxt(span);\n     let inline = cx.meta_word(span, sym::inline);\n@@ -42,6 +43,7 @@ pub fn expand_deriving_eq(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     super::inject_impl_of_structural_trait(cx, span, item, path_std!(marker::StructuralEq), push);"}, {"sha": "d2412b20a09c80d251d1aeaf90cd2b39a62bd2ed", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -13,6 +13,7 @@ pub fn expand_deriving_ord(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let inline = cx.meta_word(span, sym::inline);\n     let attrs = thin_vec![cx.attribute(inline)];\n@@ -34,6 +35,7 @@ pub fn expand_deriving_ord(\n             combine_substructure: combine_substructure(Box::new(|a, b, c| cs_cmp(a, b, c))),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "353f28fc45fb70f59cebb83084b7e1e02e5443eb", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -14,6 +14,7 @@ pub fn expand_deriving_partial_eq(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     fn cs_eq(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n         let base = true;\n@@ -89,6 +90,7 @@ pub fn expand_deriving_partial_eq(\n         supports_unions: false,\n         methods,\n         associated_types: Vec::new(),\n+        is_const,\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "e7458b23ef3879e62332d938ee655b2da0d5c75f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -13,6 +13,7 @@ pub fn expand_deriving_partial_ord(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let ordering_ty = Path(path_std!(cmp::Ordering));\n     let ret_ty =\n@@ -43,6 +44,7 @@ pub fn expand_deriving_partial_ord(\n         supports_unions: false,\n         methods: vec![partial_cmp_def],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "e6d5759bb5210dd99ef6aecf2eba1d71f6a6bad4", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -13,6 +13,7 @@ pub fn expand_deriving_debug(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ref(Box::new(Path(path_std!(fmt::Formatter))), ast::Mutability::Mut);\n@@ -37,6 +38,7 @@ pub fn expand_deriving_debug(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "37aa665e5c607e26ed86b9440fc8b31720d1551d", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -16,6 +16,7 @@ pub fn expand_deriving_rustc_decodable(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let krate = sym::rustc_serialize;\n     let typaram = sym::__D;\n@@ -55,6 +56,7 @@ pub fn expand_deriving_rustc_decodable(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "234957ab8a16b7ea1e76ef2b7f8fa4849db5db8a", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -16,6 +16,7 @@ pub fn expand_deriving_default(\n     mitem: &ast::MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     item.visit_with(&mut DetectNonVariantDefaultAttr { cx });\n \n@@ -47,6 +48,7 @@ pub fn expand_deriving_default(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "baacaa8b979e184906b2f0f593266ca4c2e7fac6", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -100,6 +100,7 @@ pub fn expand_deriving_rustc_encodable(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let krate = sym::rustc_serialize;\n     let typaram = sym::__S;\n@@ -139,6 +140,7 @@ pub fn expand_deriving_rustc_encodable(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "3972c3b493410b277991d12cea7fa45c16de51ff", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -171,7 +171,7 @@ use rustc_ast::{GenericArg, GenericParamKind, VariantData};\n use rustc_attr as attr;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n use std::cell::RefCell;\n use std::iter;\n use std::ops::Not;\n@@ -204,6 +204,8 @@ pub struct TraitDef<'a> {\n     pub methods: Vec<MethodDef<'a>>,\n \n     pub associated_types: Vec<(Ident, Ty)>,\n+\n+    pub is_const: bool,\n }\n \n pub struct MethodDef<'a> {\n@@ -730,7 +732,7 @@ impl<'a> TraitDef<'a> {\n                 unsafety: ast::Unsafe::No,\n                 polarity: ast::ImplPolarity::Positive,\n                 defaultness: ast::Defaultness::Final,\n-                constness: ast::Const::No,\n+                constness: if self.is_const { ast::Const::Yes(DUMMY_SP) } else { ast::Const::No },\n                 generics: trait_generics,\n                 of_trait: opt_trait_ref,\n                 self_ty: self_type,"}, {"sha": "8fb1a4ba262abda904460b7bf5b290d86c99c105", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -13,6 +13,7 @@ pub fn expand_deriving_hash(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let path = Path::new_(pathvec_std!(hash::Hash), vec![], PathKind::Std);\n \n@@ -39,6 +40,7 @@ pub fn expand_deriving_hash(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     hash_trait_def.expand(cx, mitem, item, push);"}, {"sha": "73a1df5d426d264fdb5ad7a1d008c2a575418449", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -38,9 +38,10 @@ pub mod partial_ord;\n \n pub mod generic;\n \n-pub(crate) struct BuiltinDerive(\n-    pub(crate) fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable)),\n-);\n+pub(crate) type BuiltinDeriveFn =\n+    fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable), bool);\n+\n+pub(crate) struct BuiltinDerive(pub(crate) BuiltinDeriveFn);\n \n impl MultiItemModifier for BuiltinDerive {\n     fn expand(\n@@ -49,6 +50,7 @@ impl MultiItemModifier for BuiltinDerive {\n         span: Span,\n         meta_item: &MetaItem,\n         item: Annotatable,\n+        is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         // FIXME: Built-in derives often forget to give spans contexts,\n         // so we are doing it here in a centralized way.\n@@ -57,21 +59,28 @@ impl MultiItemModifier for BuiltinDerive {\n         match item {\n             Annotatable::Stmt(stmt) => {\n                 if let ast::StmtKind::Item(item) = stmt.into_inner().kind {\n-                    (self.0)(ecx, span, meta_item, &Annotatable::Item(item), &mut |a| {\n-                        // Cannot use 'ecx.stmt_item' here, because we need to pass 'ecx'\n-                        // to the function\n-                        items.push(Annotatable::Stmt(P(ast::Stmt {\n-                            id: ast::DUMMY_NODE_ID,\n-                            kind: ast::StmtKind::Item(a.expect_item()),\n-                            span,\n-                        })));\n-                    });\n+                    (self.0)(\n+                        ecx,\n+                        span,\n+                        meta_item,\n+                        &Annotatable::Item(item),\n+                        &mut |a| {\n+                            // Cannot use 'ecx.stmt_item' here, because we need to pass 'ecx'\n+                            // to the function\n+                            items.push(Annotatable::Stmt(P(ast::Stmt {\n+                                id: ast::DUMMY_NODE_ID,\n+                                kind: ast::StmtKind::Item(a.expect_item()),\n+                                span,\n+                            })));\n+                        },\n+                        is_derive_const,\n+                    );\n                 } else {\n                     unreachable!(\"should have already errored on non-item statement\")\n                 }\n             }\n             _ => {\n-                (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a));\n+                (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a), is_derive_const);\n             }\n         }\n         ExpandResult::Ready(items)"}, {"sha": "1cbbfb432647cebca15bfa72ac207eac463fb1da", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -99,7 +99,8 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n         bench: test::expand_bench,\n         cfg_accessible: cfg_accessible::Expander,\n         cfg_eval: cfg_eval::expand,\n-        derive: derive::Expander,\n+        derive: derive::Expander(false),\n+        derive_const: derive::Expander(true),\n         global_allocator: global_allocator::expand,\n         test: test::expand_test,\n         test_case: test::expand_test_case,"}, {"sha": "001e53d1d0e4ce52953539a295d5a3cf0ded2475", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -47,7 +47,10 @@ passes_no_coverage_not_coverable =\n \n passes_should_be_applied_to_fn =\n     attribute should be applied to a function definition\n-    .label = not a function definition\n+    .label = {$on_crate ->\n+        [true] cannot be applied to crates\n+        *[false] not a function definition\n+    }\n \n passes_naked_tracked_caller =\n     cannot use `#[track_caller]` with `#[naked]`"}, {"sha": "c450c276366e156220e09c14077eb72c23e4727b", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -52,7 +52,6 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n-            &self.source_map,\n             &mut primary_span,\n             &mut children,\n             &diag.level,"}, {"sha": "55c7997a513636bc38d48f8acfc74da9e3c61dd9", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -314,7 +314,6 @@ pub trait Emitter: Translate {\n \n     fn fix_multispans_in_extern_macros_and_render_macro_backtrace(\n         &self,\n-        source_map: &Option<Lrc<SourceMap>>,\n         span: &mut MultiSpan,\n         children: &mut Vec<SubDiagnostic>,\n         level: &Level,\n@@ -340,7 +339,7 @@ pub trait Emitter: Translate {\n             .collect();\n \n         if !backtrace {\n-            self.fix_multispans_in_extern_macros(source_map, span, children);\n+            self.fix_multispans_in_extern_macros(span, children);\n         }\n \n         self.render_multispans_macro_backtrace(span, children, backtrace);\n@@ -480,23 +479,22 @@ pub trait Emitter: Translate {\n     // this will change the span to point at the use site.\n     fn fix_multispans_in_extern_macros(\n         &self,\n-        source_map: &Option<Lrc<SourceMap>>,\n         span: &mut MultiSpan,\n         children: &mut Vec<SubDiagnostic>,\n     ) {\n-        let Some(source_map) = source_map else { return };\n         debug!(\"fix_multispans_in_extern_macros: before: span={:?} children={:?}\", span, children);\n-        self.fix_multispan_in_extern_macros(source_map, span);\n+        self.fix_multispan_in_extern_macros(span);\n         for child in children.iter_mut() {\n-            self.fix_multispan_in_extern_macros(source_map, &mut child.span);\n+            self.fix_multispan_in_extern_macros(&mut child.span);\n         }\n         debug!(\"fix_multispans_in_extern_macros: after: span={:?} children={:?}\", span, children);\n     }\n \n     // This \"fixes\" MultiSpans that contain `Span`s pointing to locations inside of external macros.\n     // Since these locations are often difficult to read,\n     // we move these spans from the external macros to their corresponding use site.\n-    fn fix_multispan_in_extern_macros(&self, source_map: &Lrc<SourceMap>, span: &mut MultiSpan) {\n+    fn fix_multispan_in_extern_macros(&self, span: &mut MultiSpan) {\n+        let Some(source_map) = self.source_map() else { return };\n         // First, find all the spans in external macros and point instead at their use site.\n         let replacements: Vec<(Span, Span)> = span\n             .primary_spans()\n@@ -544,7 +542,6 @@ impl Emitter for EmitterWriter {\n         debug!(\"emit_diagnostic: suggestions={:?}\", suggestions);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n-            &self.sm,\n             &mut primary_span,\n             &mut children,\n             &diag.level,\n@@ -2213,22 +2210,45 @@ impl FileWithAnnotatedLines {\n \n         if let Some(ref sm) = emitter.source_map() {\n             for span_label in msp.span_labels() {\n+                let fixup_lo_hi = |span: Span| {\n+                    let lo = sm.lookup_char_pos(span.lo());\n+                    let mut hi = sm.lookup_char_pos(span.hi());\n+\n+                    // Watch out for \"empty spans\". If we get a span like 6..6, we\n+                    // want to just display a `^` at 6, so convert that to\n+                    // 6..7. This is degenerate input, but it's best to degrade\n+                    // gracefully -- and the parser likes to supply a span like\n+                    // that for EOF, in particular.\n+\n+                    if lo.col_display == hi.col_display && lo.line == hi.line {\n+                        hi.col_display += 1;\n+                    }\n+                    (lo, hi)\n+                };\n+\n                 if span_label.span.is_dummy() {\n+                    if let Some(span) = msp.primary_span() {\n+                        // if we don't know where to render the annotation, emit it as a note\n+                        // on the primary span.\n+\n+                        let (lo, hi) = fixup_lo_hi(span);\n+\n+                        let ann = Annotation {\n+                            start_col: lo.col_display,\n+                            end_col: hi.col_display,\n+                            is_primary: span_label.is_primary,\n+                            label: span_label\n+                                .label\n+                                .as_ref()\n+                                .map(|m| emitter.translate_message(m, args).to_string()),\n+                            annotation_type: AnnotationType::Singleline,\n+                        };\n+                        add_annotation_to_file(&mut output, lo.file, lo.line, ann);\n+                    }\n                     continue;\n                 }\n \n-                let lo = sm.lookup_char_pos(span_label.span.lo());\n-                let mut hi = sm.lookup_char_pos(span_label.span.hi());\n-\n-                // Watch out for \"empty spans\". If we get a span like 6..6, we\n-                // want to just display a `^` at 6, so convert that to\n-                // 6..7. This is degenerate input, but it's best to degrade\n-                // gracefully -- and the parser likes to supply a span like\n-                // that for EOF, in particular.\n-\n-                if lo.col_display == hi.col_display && lo.line == hi.line {\n-                    hi.col_display += 1;\n-                }\n+                let (lo, hi) = fixup_lo_hi(span_label.span);\n \n                 if lo.line != hi.line {\n                     let ml = MultilineAnnotation {"}, {"sha": "1294f1e17d412a7469cf564760f1df89a2f68583", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -250,6 +250,7 @@ pub trait MultiItemModifier {\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable>;\n }\n \n@@ -263,6 +264,7 @@ where\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        _is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         ExpandResult::Ready(self(ecx, span, meta_item, item))\n     }\n@@ -873,7 +875,7 @@ impl SyntaxExtension {\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n-pub type DeriveResolutions = Vec<(ast::Path, Annotatable, Option<Lrc<SyntaxExtension>>)>;\n+pub type DeriveResolutions = Vec<(ast::Path, Annotatable, Option<Lrc<SyntaxExtension>>, bool)>;\n \n pub trait ResolverExpand {\n     fn next_node_id(&mut self) -> NodeId;"}, {"sha": "3d37e2c6568518cf5a5615a350c4a22241e175ac", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -337,6 +337,7 @@ pub enum InvocationKind {\n     },\n     Derive {\n         path: ast::Path,\n+        is_const: bool,\n         item: Annotatable,\n     },\n }\n@@ -478,13 +479,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             derive_invocations.reserve(derives.len());\n                             derives\n                                 .into_iter()\n-                                .map(|(path, item, _exts)| {\n+                                .map(|(path, item, _exts, is_const)| {\n                                     // FIXME: Consider using the derive resolutions (`_exts`)\n                                     // instead of enqueuing the derives to be resolved again later.\n                                     let expn_id = LocalExpnId::fresh_empty();\n                                     derive_invocations.push((\n                                         Invocation {\n-                                            kind: InvocationKind::Derive { path, item },\n+                                            kind: InvocationKind::Derive { path, item, is_const },\n                                             fragment_kind,\n                                             expansion_data: ExpansionData {\n                                                 id: expn_id,\n@@ -717,7 +718,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n                     match validate_attr::parse_meta(&self.cx.sess.parse_sess, &attr) {\n                         Ok(meta) => {\n-                            let items = match expander.expand(self.cx, span, &meta, item) {\n+                            let items = match expander.expand(self.cx, span, &meta, item, false) {\n                                 ExpandResult::Ready(items) => items,\n                                 ExpandResult::Retry(item) => {\n                                     // Reassemble the original invocation for retrying.\n@@ -749,19 +750,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 _ => unreachable!(),\n             },\n-            InvocationKind::Derive { path, item } => match ext {\n+            InvocationKind::Derive { path, item, is_const } => match ext {\n                 SyntaxExtensionKind::Derive(expander)\n                 | SyntaxExtensionKind::LegacyDerive(expander) => {\n                     if let SyntaxExtensionKind::Derive(..) = ext {\n                         self.gate_proc_macro_input(&item);\n                     }\n                     let meta = ast::MetaItem { kind: MetaItemKind::Word, span, path };\n-                    let items = match expander.expand(self.cx, span, &meta, item) {\n+                    let items = match expander.expand(self.cx, span, &meta, item, is_const) {\n                         ExpandResult::Ready(items) => items,\n                         ExpandResult::Retry(item) => {\n                             // Reassemble the original invocation for retrying.\n                             return ExpandResult::Retry(Invocation {\n-                                kind: InvocationKind::Derive { path: meta.path, item },\n+                                kind: InvocationKind::Derive { path: meta.path, item, is_const },\n                                 ..invoc\n                             });\n                         }"}, {"sha": "e9a69192068941167386c97429d4ec96bbd217b1", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -112,6 +112,7 @@ impl MultiItemModifier for DeriveProcMacro {\n         span: Span,\n         _meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        _is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         // We need special handling for statement items\n         // (e.g. `fn foo() { #[derive(Debug)] struct Bar; }`)"}, {"sha": "7c99896b4571427d08543e8031e4ab20b99e30b8", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 142, "deletions": 105, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -9,14 +9,15 @@ use rustc_hir::intravisit;\n use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{self, TyCtxtInferExt};\n+use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::util::ExplicitSelf;\n-use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{\n-    self, AssocItem, DefIdTree, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+    self, AssocItem, DefIdTree, TraitRef, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitable,\n };\n+use rustc_middle::ty::{FnSig, InternalSubsts};\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n@@ -303,102 +304,19 @@ fn compare_predicate_entailment<'tcx>(\n     }\n \n     if let Err(terr) = result {\n-        debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n+        debug!(?terr, \"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n \n-        let (impl_err_span, trait_err_span) =\n-            extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n-\n-        cause.span = impl_err_span;\n-\n-        let mut diag = struct_span_err!(\n-            tcx.sess,\n-            cause.span(),\n-            E0053,\n-            \"method `{}` has an incompatible type for trait\",\n-            trait_m.name\n-        );\n-        match &terr {\n-            TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n-                if trait_m.fn_has_self_parameter =>\n-            {\n-                let ty = trait_sig.inputs()[0];\n-                let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty()) {\n-                    ExplicitSelf::ByValue => \"self\".to_owned(),\n-                    ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n-                    ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n-                    _ => format!(\"self: {ty}\"),\n-                };\n-\n-                // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n-                // span points only at the type `Box<Self`>, but we want to cover the whole\n-                // argument pattern and type.\n-                let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                    ImplItemKind::Fn(ref sig, body) => tcx\n-                        .hir()\n-                        .body_param_names(body)\n-                        .zip(sig.decl.inputs.iter())\n-                        .map(|(param, ty)| param.span.to(ty.span))\n-                        .next()\n-                        .unwrap_or(impl_err_span),\n-                    _ => bug!(\"{:?} is not a method\", impl_m),\n-                };\n-\n-                diag.span_suggestion(\n-                    span,\n-                    \"change the self-receiver type to match the trait\",\n-                    sugg,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n-                if trait_sig.inputs().len() == *i {\n-                    // Suggestion to change output type. We do not suggest in `async` functions\n-                    // to avoid complex logic or incorrect output.\n-                    match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                        ImplItemKind::Fn(ref sig, _)\n-                            if sig.header.asyncness == hir::IsAsync::NotAsync =>\n-                        {\n-                            let msg = \"change the output type to match the trait\";\n-                            let ap = Applicability::MachineApplicable;\n-                            match sig.decl.output {\n-                                hir::FnRetTy::DefaultReturn(sp) => {\n-                                    let sugg = format!(\"-> {} \", trait_sig.output());\n-                                    diag.span_suggestion_verbose(sp, msg, sugg, ap);\n-                                }\n-                                hir::FnRetTy::Return(hir_ty) => {\n-                                    let sugg = trait_sig.output();\n-                                    diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n-                                }\n-                            };\n-                        }\n-                        _ => {}\n-                    };\n-                } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n-                    diag.span_suggestion(\n-                        impl_err_span,\n-                        \"change the parameter type to match the trait\",\n-                        trait_ty,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        infcx.err_ctxt().note_type_err(\n-            &mut diag,\n-            &cause,\n-            trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n-            Some(infer::ValuePairs::Terms(ExpectedFound {\n-                expected: trait_fty.into(),\n-                found: impl_fty.into(),\n-            })),\n+        let emitted = report_trait_method_mismatch(\n+            tcx,\n+            &mut cause,\n+            &infcx,\n             terr,\n-            false,\n-            false,\n+            (trait_m, trait_fty),\n+            (impl_m, impl_fty),\n+            &trait_sig,\n+            &impl_trait_ref,\n         );\n-\n-        return Err(diag.emit());\n+        return Err(emitted);\n     }\n \n     // Check that all obligations are satisfied by the implementation's\n@@ -424,6 +342,7 @@ fn compare_predicate_entailment<'tcx>(\n     Ok(())\n }\n \n+#[instrument(skip(tcx), level = \"debug\", ret)]\n pub fn collect_trait_impl_trait_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n@@ -437,7 +356,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n \n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n     let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n-    let cause = ObligationCause::new(\n+    let mut cause = ObligationCause::new(\n         return_span,\n         impl_m_hir_id,\n         ObligationCauseCode::CompareImplItemObligation {\n@@ -514,23 +433,35 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n         }\n     }\n \n+    debug!(?trait_sig, ?impl_sig, \"equating function signatures\");\n+\n+    let trait_fty = tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig));\n+    let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n+\n     // Unify the whole function signature. We need to do this to fully infer\n     // the lifetimes of the return type, but do this after unifying just the\n     // return types, since we want to avoid duplicating errors from\n     // `compare_predicate_entailment`.\n-    match infcx\n-        .at(&cause, param_env)\n-        .eq(tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig)), tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig)))\n-    {\n+    match infcx.at(&cause, param_env).eq(trait_fty, impl_fty) {\n         Ok(infer::InferOk { value: (), obligations }) => {\n             ocx.register_obligations(obligations);\n         }\n         Err(terr) => {\n-            let guar = tcx.sess.delay_span_bug(\n-                return_span,\n-                format!(\"could not unify `{trait_sig}` and `{impl_sig}`: {terr:?}\"),\n+            // This function gets called during `compare_predicate_entailment` when normalizing a\n+            // signature that contains RPITIT. When the method signatures don't match, we have to\n+            // emit an error now because `compare_predicate_entailment` will not report the error\n+            // when normalization fails.\n+            let emitted = report_trait_method_mismatch(\n+                tcx,\n+                &mut cause,\n+                infcx,\n+                terr,\n+                (trait_m, trait_fty),\n+                (impl_m, impl_fty),\n+                &trait_sig,\n+                &impl_trait_ref,\n             );\n-            return Err(guar);\n+            return Err(emitted);\n         }\n     }\n \n@@ -690,6 +621,112 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n     }\n }\n \n+fn report_trait_method_mismatch<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cause: &mut ObligationCause<'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n+    terr: TypeError<'tcx>,\n+    (trait_m, trait_fty): (&AssocItem, Ty<'tcx>),\n+    (impl_m, impl_fty): (&AssocItem, Ty<'tcx>),\n+    trait_sig: &FnSig<'tcx>,\n+    impl_trait_ref: &TraitRef<'tcx>,\n+) -> ErrorGuaranteed {\n+    let (impl_err_span, trait_err_span) =\n+        extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n+\n+    cause.span = impl_err_span;\n+\n+    let mut diag = struct_span_err!(\n+        tcx.sess,\n+        cause.span(),\n+        E0053,\n+        \"method `{}` has an incompatible type for trait\",\n+        trait_m.name\n+    );\n+    match &terr {\n+        TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n+            if trait_m.fn_has_self_parameter =>\n+        {\n+            let ty = trait_sig.inputs()[0];\n+            let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty()) {\n+                ExplicitSelf::ByValue => \"self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n+                _ => format!(\"self: {ty}\"),\n+            };\n+\n+            // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n+            // span points only at the type `Box<Self`>, but we want to cover the whole\n+            // argument pattern and type.\n+            let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n+                ImplItemKind::Fn(ref sig, body) => tcx\n+                    .hir()\n+                    .body_param_names(body)\n+                    .zip(sig.decl.inputs.iter())\n+                    .map(|(param, ty)| param.span.to(ty.span))\n+                    .next()\n+                    .unwrap_or(impl_err_span),\n+                _ => bug!(\"{:?} is not a method\", impl_m),\n+            };\n+\n+            diag.span_suggestion(\n+                span,\n+                \"change the self-receiver type to match the trait\",\n+                sugg,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n+            if trait_sig.inputs().len() == *i {\n+                // Suggestion to change output type. We do not suggest in `async` functions\n+                // to avoid complex logic or incorrect output.\n+                match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n+                    ImplItemKind::Fn(ref sig, _)\n+                        if sig.header.asyncness == hir::IsAsync::NotAsync =>\n+                    {\n+                        let msg = \"change the output type to match the trait\";\n+                        let ap = Applicability::MachineApplicable;\n+                        match sig.decl.output {\n+                            hir::FnRetTy::DefaultReturn(sp) => {\n+                                let sugg = format!(\"-> {} \", trait_sig.output());\n+                                diag.span_suggestion_verbose(sp, msg, sugg, ap);\n+                            }\n+                            hir::FnRetTy::Return(hir_ty) => {\n+                                let sugg = trait_sig.output();\n+                                diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n+                            }\n+                        };\n+                    }\n+                    _ => {}\n+                };\n+            } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n+                diag.span_suggestion(\n+                    impl_err_span,\n+                    \"change the parameter type to match the trait\",\n+                    trait_ty,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    infcx.err_ctxt().note_type_err(\n+        &mut diag,\n+        &cause,\n+        trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n+        Some(infer::ValuePairs::Terms(ExpectedFound {\n+            expected: trait_fty.into(),\n+            found: impl_fty.into(),\n+        })),\n+        terr,\n+        false,\n+        false,\n+    );\n+\n+    return diag.emit();\n+}\n+\n fn check_region_bounds_on_impl_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,"}, {"sha": "c6bd771fad2568e4b8578316c80013836f845e38", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -18,6 +18,7 @@ use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryRespons\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n@@ -32,9 +33,7 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{\n-    self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt,\n-};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, ObligationCtxt};\n \n use std::collections::hash_map::Entry;\n use std::slice;\n@@ -766,34 +765,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let expect_args = self\n             .fudge_inference_if_ok(|| {\n+                let ocx = ObligationCtxt::new_in_snapshot(self);\n+\n                 // Attempt to apply a subtyping relationship between the formal\n                 // return type (likely containing type variables if the function\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n                 let origin = self.misc(call_span);\n-                let ures = self.at(&origin, self.param_env).sup(ret_ty, formal_ret);\n-\n-                // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n-                // to identity so the resulting type is not constrained.\n-                match ures {\n-                    Ok(ok) => {\n-                        // Process any obligations locally as much as\n-                        // we can.  We don't care if some things turn\n-                        // out unconstrained or ambiguous, as we're\n-                        // just trying to get hints here.\n-                        let errors = self.save_and_restore_in_snapshot_flag(|_| {\n-                            let mut fulfill = <dyn TraitEngine<'_>>::new(self.tcx);\n-                            for obligation in ok.obligations {\n-                                fulfill.register_predicate_obligation(self, obligation);\n-                            }\n-                            fulfill.select_where_possible(self)\n-                        });\n-\n-                        if !errors.is_empty() {\n-                            return Err(());\n-                        }\n-                    }\n-                    Err(_) => return Err(()),\n+                ocx.sup(&origin, self.param_env, ret_ty, formal_ret)?;\n+                if !ocx.select_where_possible().is_empty() {\n+                    return Err(TypeError::Mismatch);\n                 }\n \n                 // Record all the argument types, with the substitutions"}, {"sha": "fd3b3e4d59fa699d7570a708814025e0519e7e3e", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -778,32 +778,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n     }\n \n-    /// Clear the \"currently in a snapshot\" flag, invoke the closure,\n-    /// then restore the flag to its original value. This flag is a\n-    /// debugging measure designed to detect cases where we start a\n-    /// snapshot, create type variables, and register obligations\n-    /// which may involve those type variables in the fulfillment cx,\n-    /// potentially leaving \"dangling type variables\" behind.\n-    /// In such cases, an assertion will fail when attempting to\n-    /// register obligations, within a snapshot. Very useful, much\n-    /// better than grovelling through megabytes of `RUSTC_LOG` output.\n-    ///\n-    /// HOWEVER, in some cases the flag is unhelpful. In particular, we\n-    /// sometimes create a \"mini-fulfilment-cx\" in which we enroll\n-    /// obligations. As long as this fulfillment cx is fully drained\n-    /// before we return, this is not a problem, as there won't be any\n-    /// escaping obligations in the main cx. In those cases, you can\n-    /// use this function.\n-    pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R\n-    where\n-        F: FnOnce(&Self) -> R,\n-    {\n-        let flag = self.in_snapshot.replace(false);\n-        let result = func(self);\n-        self.in_snapshot.set(flag);\n-        result\n-    }\n-\n     fn start_snapshot(&self) -> CombinedSnapshot<'tcx> {\n         debug!(\"start_snapshot()\");\n "}, {"sha": "2b6ff0a5cb9d38ce25a35bbbd871e27dc904cbfc", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -119,13 +119,13 @@ impl CheckAttrVisitor<'_> {\n                 }\n                 sym::naked => self.check_naked(hir_id, attr, span, target),\n                 sym::rustc_legacy_const_generics => {\n-                    self.check_rustc_legacy_const_generics(&attr, span, target, item)\n+                    self.check_rustc_legacy_const_generics(hir_id, &attr, span, target, item)\n                 }\n                 sym::rustc_lint_query_instability => {\n-                    self.check_rustc_lint_query_instability(&attr, span, target)\n+                    self.check_rustc_lint_query_instability(hir_id, &attr, span, target)\n                 }\n                 sym::rustc_lint_diagnostics => {\n-                    self.check_rustc_lint_diagnostics(&attr, span, target)\n+                    self.check_rustc_lint_diagnostics(hir_id, &attr, span, target)\n                 }\n                 sym::rustc_lint_opt_ty => self.check_rustc_lint_opt_ty(&attr, span, target),\n                 sym::rustc_lint_opt_deny_field_access => {\n@@ -135,7 +135,9 @@ impl CheckAttrVisitor<'_> {\n                 | sym::rustc_dirty\n                 | sym::rustc_if_this_changed\n                 | sym::rustc_then_this_would_need => self.check_rustc_dirty_clean(&attr),\n-                sym::cmse_nonsecure_entry => self.check_cmse_nonsecure_entry(attr, span, target),\n+                sym::cmse_nonsecure_entry => {\n+                    self.check_cmse_nonsecure_entry(hir_id, attr, span, target)\n+                }\n                 sym::collapse_debuginfo => self.check_collapse_debuginfo(attr, span, target),\n                 sym::const_trait => self.check_const_trait(attr, span, target),\n                 sym::must_not_suspend => self.check_must_not_suspend(&attr, span, target),\n@@ -386,21 +388,29 @@ impl CheckAttrVisitor<'_> {\n                 self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n                     attr_span: attr.span,\n                     defn_span: span,\n+                    on_crate: hir_id == CRATE_HIR_ID,\n                 });\n                 false\n             }\n         }\n     }\n \n     /// Checks if `#[cmse_nonsecure_entry]` is applied to a function definition.\n-    fn check_cmse_nonsecure_entry(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n+    fn check_cmse_nonsecure_entry(\n+        &self,\n+        hir_id: HirId,\n+        attr: &Attribute,\n+        span: Span,\n+        target: Target,\n+    ) -> bool {\n         match target {\n             Target::Fn\n             | Target::Method(MethodKind::Trait { body: true } | MethodKind::Inherent) => true,\n             _ => {\n                 self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n                     attr_span: attr.span,\n                     defn_span: span,\n+                    on_crate: hir_id == CRATE_HIR_ID,\n                 });\n                 false\n             }\n@@ -465,9 +475,11 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .emit_err(errors::TrackedCallerWrongLocation { attr_span, defn_span: span });\n+                self.tcx.sess.emit_err(errors::TrackedCallerWrongLocation {\n+                    attr_span,\n+                    defn_span: span,\n+                    on_crate: hir_id == CRATE_HIR_ID,\n+                });\n                 false\n             }\n         }\n@@ -576,6 +588,7 @@ impl CheckAttrVisitor<'_> {\n                 self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n                     attr_span: attr.span,\n                     defn_span: span,\n+                    on_crate: hir_id == CRATE_HIR_ID,\n                 });\n                 false\n             }\n@@ -1230,7 +1243,7 @@ impl CheckAttrVisitor<'_> {\n                     UNUSED_ATTRIBUTES,\n                     hir_id,\n                     attr.span,\n-                    errors::Cold { span },\n+                    errors::Cold { span, on_crate: hir_id == CRATE_HIR_ID },\n                 );\n             }\n         }\n@@ -1366,6 +1379,7 @@ impl CheckAttrVisitor<'_> {\n     /// Checks if `#[rustc_legacy_const_generics]` is applied to a function and has a valid argument.\n     fn check_rustc_legacy_const_generics(\n         &self,\n+        hir_id: HirId,\n         attr: &Attribute,\n         span: Span,\n         target: Target,\n@@ -1376,6 +1390,7 @@ impl CheckAttrVisitor<'_> {\n             self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n                 attr_span: attr.span,\n                 defn_span: span,\n+                on_crate: hir_id == CRATE_HIR_ID,\n             });\n             return false;\n         }\n@@ -1440,12 +1455,19 @@ impl CheckAttrVisitor<'_> {\n \n     /// Helper function for checking that the provided attribute is only applied to a function or\n     /// method.\n-    fn check_applied_to_fn_or_method(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n+    fn check_applied_to_fn_or_method(\n+        &self,\n+        hir_id: HirId,\n+        attr: &Attribute,\n+        span: Span,\n+        target: Target,\n+    ) -> bool {\n         let is_function = matches!(target, Target::Fn | Target::Method(..));\n         if !is_function {\n             self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n                 attr_span: attr.span,\n                 defn_span: span,\n+                on_crate: hir_id == CRATE_HIR_ID,\n             });\n             false\n         } else {\n@@ -1457,17 +1479,24 @@ impl CheckAttrVisitor<'_> {\n     /// or method.\n     fn check_rustc_lint_query_instability(\n         &self,\n+        hir_id: HirId,\n         attr: &Attribute,\n         span: Span,\n         target: Target,\n     ) -> bool {\n-        self.check_applied_to_fn_or_method(attr, span, target)\n+        self.check_applied_to_fn_or_method(hir_id, attr, span, target)\n     }\n \n     /// Checks that the `#[rustc_lint_diagnostics]` attribute is only applied to a function or\n     /// method.\n-    fn check_rustc_lint_diagnostics(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n-        self.check_applied_to_fn_or_method(attr, span, target)\n+    fn check_rustc_lint_diagnostics(\n+        &self,\n+        hir_id: HirId,\n+        attr: &Attribute,\n+        span: Span,\n+        target: Target,\n+    ) -> bool {\n+        self.check_applied_to_fn_or_method(hir_id, attr, span, target)\n     }\n \n     /// Checks that the `#[rustc_lint_opt_ty]` attribute is only applied to a struct."}, {"sha": "c6cd69add28a04837c20fa0640419cee5ccb7af7", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -81,6 +81,7 @@ pub struct AttrShouldBeAppliedToFn {\n     pub attr_span: Span,\n     #[label]\n     pub defn_span: Span,\n+    pub on_crate: bool,\n }\n \n #[derive(Diagnostic)]\n@@ -97,6 +98,7 @@ pub struct TrackedCallerWrongLocation {\n     pub attr_span: Span,\n     #[label]\n     pub defn_span: Span,\n+    pub on_crate: bool,\n }\n \n #[derive(Diagnostic)]\n@@ -367,6 +369,7 @@ pub struct MustNotSuspend {\n pub struct Cold {\n     #[label]\n     pub span: Span,\n+    pub on_crate: bool,\n }\n \n #[derive(LintDiagnostic)]"}, {"sha": "a12918b2979906021789ef8f5936bc59eb42c02c", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -241,10 +241,12 @@ impl<'a> Resolver<'a> {\n         ));\n \n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n-        err.span_label(\n-            self.session.source_map().guess_head_span(old_binding.span),\n-            format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n-        );\n+        if !old_binding.span.is_dummy() && old_binding.span != span {\n+            err.span_label(\n+                self.session.source_map().guess_head_span(old_binding.span),\n+                format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n+            );\n+        }\n \n         // See https://github.com/rust-lang/rust/issues/32354\n         use NameBindingKind::Import;"}, {"sha": "95eff92ef5e2471775f13aa5fa13cd2e84eb5532", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -807,14 +807,16 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         err.code(rustc_errors::error_code!(E0411));\n         err.span_label(span, \"`Self` is only available in impls, traits, and type definitions\");\n         if let Some(item_kind) = self.diagnostic_metadata.current_item {\n-            err.span_label(\n-                item_kind.ident.span,\n-                format!(\n-                    \"`Self` not allowed in {} {}\",\n-                    item_kind.kind.article(),\n-                    item_kind.kind.descr()\n-                ),\n-            );\n+            if !item_kind.ident.span.is_dummy() {\n+                err.span_label(\n+                    item_kind.ident.span,\n+                    format!(\n+                        \"`Self` not allowed in {} {}\",\n+                        item_kind.kind.article(),\n+                        item_kind.kind.descr()\n+                    ),\n+                );\n+            }\n         }\n         true\n     }"}, {"sha": "8c7972f8eebb92f09698ad625382f0a49f4bfd91", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -356,7 +356,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n             has_derive_copy: false,\n         });\n         let parent_scope = self.invocation_parent_scopes[&expn_id];\n-        for (i, (path, _, opt_ext)) in entry.resolutions.iter_mut().enumerate() {\n+        for (i, (path, _, opt_ext, _)) in entry.resolutions.iter_mut().enumerate() {\n             if opt_ext.is_none() {\n                 *opt_ext = Some(\n                     match self.resolve_macro_path("}, {"sha": "b48db73618b0b9278bbc9aad5abd6b399da076d2", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -620,6 +620,7 @@ symbols! {\n         deref_mut,\n         deref_target,\n         derive,\n+        derive_const,\n         derive_default_enum,\n         destruct,\n         destructuring_assignment,"}, {"sha": "22e7d3ea5dd5ba1ab468e6bf1faa2b2b1187f88f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -2445,12 +2445,12 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             (Ok(l), Ok(r)) => l.line == r.line,\n                             _ => true,\n                         };\n-                    if !ident.span.overlaps(span) && !same_line {\n+                    if !ident.span.is_dummy() && !ident.span.overlaps(span) && !same_line {\n                         multispan.push_span_label(ident.span, \"required by a bound in this\");\n                     }\n                 }\n                 let descr = format!(\"required by a bound in `{}`\", item_name);\n-                if span != DUMMY_SP {\n+                if !span.is_dummy() {\n                     let msg = format!(\"required by this bound in `{}`\", item_name);\n                     multispan.push_span_label(span, msg);\n                     err.span_note(multispan, &descr);"}, {"sha": "231a18f86eae72eaea55261dc2344e087e7d12ba", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -10,10 +10,12 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/specialization.html\n \n pub mod specialization_graph;\n+use rustc_infer::traits::{TraitEngine, TraitEngineExt as _};\n use specialization_graph::GraphExt;\n \n use crate::errors::NegativePositiveConflict;\n use crate::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause};\n use rustc_data_structures::fx::FxIndexSet;\n@@ -200,36 +202,32 @@ fn fulfill_implication<'tcx>(\n         return Err(());\n     };\n \n+    // Needs to be `in_snapshot` because this function is used to rebase\n+    // substitutions, which may happen inside of a select within a probe.\n+    let mut engine = <dyn TraitEngine<'tcx>>::new_in_snapshot(infcx.tcx);\n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n+    engine.register_predicate_obligations(infcx, obligations.chain(more_obligations));\n \n-    infcx.save_and_restore_in_snapshot_flag(|infcx| {\n-        let errors = traits::fully_solve_obligations(&infcx, obligations.chain(more_obligations));\n-        match &errors[..] {\n-            [] => {\n-                debug!(\n-                    \"fulfill_implication: an impl for {:?} specializes {:?}\",\n-                    source_trait, target_trait\n-                );\n+    let errors = engine.select_all_or_error(infcx);\n+    if !errors.is_empty() {\n+        // no dice!\n+        debug!(\n+            \"fulfill_implication: for impls on {:?} and {:?}, \\\n+                 could not fulfill: {:?} given {:?}\",\n+            source_trait,\n+            target_trait,\n+            errors,\n+            param_env.caller_bounds()\n+        );\n+        return Err(());\n+    }\n \n-                // Now resolve the *substitution* we built for the target earlier, replacing\n-                // the inference variables inside with whatever we got from fulfillment.\n-                Ok(infcx.resolve_vars_if_possible(target_substs))\n-            }\n-            errors => {\n-                // no dice!\n-                debug!(\n-                    \"fulfill_implication: for impls on {:?} and {:?}, \\\n-                     could not fulfill: {:?} given {:?}\",\n-                    source_trait,\n-                    target_trait,\n-                    errors,\n-                    param_env.caller_bounds()\n-                );\n-                Err(())\n-            }\n-        }\n-    })\n+    debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\", source_trait, target_trait);\n+\n+    // Now resolve the *substitution* we built for the target earlier, replacing\n+    // the inference variables inside with whatever we got from fulfillment.\n+    Ok(infcx.resolve_vars_if_possible(target_substs))\n }\n \n // Query provider for `specialization_graph_of`."}, {"sha": "7b4ad9fea137a7bd30bf835c5a86f528b058f764", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 97, "deletions": 110, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -2,20 +2,18 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{self, EarlyBinder, ParamEnvAnd, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n+use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::dropck_outlives::trivial_dropck_outlives;\n use rustc_trait_selection::traits::query::dropck_outlives::{\n     DropckConstraint, DropckOutlivesResult,\n };\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc_trait_selection::traits::{\n-    Normalized, ObligationCause, TraitEngine, TraitEngineExt as _,\n-};\n+use rustc_trait_selection::traits::{Normalized, ObligationCause};\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { dropck_outlives, adt_dtorck_constraint, ..*p };\n@@ -27,120 +25,109 @@ fn dropck_outlives<'tcx>(\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>, NoSolution> {\n     debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n \n-    let (ref infcx, goal, canonical_inference_vars) =\n-        tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-    let tcx = infcx.tcx;\n-    let ParamEnvAnd { param_env, value: for_ty } = goal;\n-\n-    let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n-\n-    // A stack of types left to process. Each round, we pop\n-    // something from the stack and invoke\n-    // `dtorck_constraint_for_ty`. This may produce new types that\n-    // have to be pushed on the stack. This continues until we have explored\n-    // all the reachable types from the type `for_ty`.\n-    //\n-    // Example: Imagine that we have the following code:\n-    //\n-    // ```rust\n-    // struct A {\n-    //     value: B,\n-    //     children: Vec<A>,\n-    // }\n-    //\n-    // struct B {\n-    //     value: u32\n-    // }\n-    //\n-    // fn f() {\n-    //   let a: A = ...;\n-    //   ..\n-    // } // here, `a` is dropped\n-    // ```\n-    //\n-    // at the point where `a` is dropped, we need to figure out\n-    // which types inside of `a` contain region data that may be\n-    // accessed by any destructors in `a`. We begin by pushing `A`\n-    // onto the stack, as that is the type of `a`. We will then\n-    // invoke `dtorck_constraint_for_ty` which will expand `A`\n-    // into the types of its fields `(B, Vec<A>)`. These will get\n-    // pushed onto the stack. Eventually, expanding `Vec<A>` will\n-    // lead to us trying to push `A` a second time -- to prevent\n-    // infinite recursion, we notice that `A` was already pushed\n-    // once and stop.\n-    let mut ty_stack = vec![(for_ty, 0)];\n-\n-    // Set used to detect infinite recursion.\n-    let mut ty_set = FxHashSet::default();\n-\n-    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-    let cause = ObligationCause::dummy();\n-    let mut constraints = DropckConstraint::empty();\n-    while let Some((ty, depth)) = ty_stack.pop() {\n-        debug!(\n-            \"{} kinds, {} overflows, {} ty_stack\",\n-            result.kinds.len(),\n-            result.overflows.len(),\n-            ty_stack.len()\n-        );\n-        dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n-\n-        // \"outlives\" represent types/regions that may be touched\n-        // by a destructor.\n-        result.kinds.append(&mut constraints.outlives);\n-        result.overflows.append(&mut constraints.overflows);\n-\n-        // If we have even one overflow, we should stop trying to evaluate further --\n-        // chances are, the subsequent overflows for this evaluation won't provide useful\n-        // information and will just decrease the speed at which we can emit these errors\n-        // (since we'll be printing for just that much longer for the often enormous types\n-        // that result here).\n-        if !result.overflows.is_empty() {\n-            break;\n-        }\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonical_goal, |ocx, goal| {\n+        let tcx = ocx.infcx.tcx;\n+        let ParamEnvAnd { param_env, value: for_ty } = goal;\n+\n+        let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+\n+        // A stack of types left to process. Each round, we pop\n+        // something from the stack and invoke\n+        // `dtorck_constraint_for_ty`. This may produce new types that\n+        // have to be pushed on the stack. This continues until we have explored\n+        // all the reachable types from the type `for_ty`.\n+        //\n+        // Example: Imagine that we have the following code:\n+        //\n+        // ```rust\n+        // struct A {\n+        //     value: B,\n+        //     children: Vec<A>,\n+        // }\n+        //\n+        // struct B {\n+        //     value: u32\n+        // }\n+        //\n+        // fn f() {\n+        //   let a: A = ...;\n+        //   ..\n+        // } // here, `a` is dropped\n+        // ```\n+        //\n+        // at the point where `a` is dropped, we need to figure out\n+        // which types inside of `a` contain region data that may be\n+        // accessed by any destructors in `a`. We begin by pushing `A`\n+        // onto the stack, as that is the type of `a`. We will then\n+        // invoke `dtorck_constraint_for_ty` which will expand `A`\n+        // into the types of its fields `(B, Vec<A>)`. These will get\n+        // pushed onto the stack. Eventually, expanding `Vec<A>` will\n+        // lead to us trying to push `A` a second time -- to prevent\n+        // infinite recursion, we notice that `A` was already pushed\n+        // once and stop.\n+        let mut ty_stack = vec![(for_ty, 0)];\n+\n+        // Set used to detect infinite recursion.\n+        let mut ty_set = FxHashSet::default();\n+\n+        let cause = ObligationCause::dummy();\n+        let mut constraints = DropckConstraint::empty();\n+        while let Some((ty, depth)) = ty_stack.pop() {\n+            debug!(\n+                \"{} kinds, {} overflows, {} ty_stack\",\n+                result.kinds.len(),\n+                result.overflows.len(),\n+                ty_stack.len()\n+            );\n+            dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n+\n+            // \"outlives\" represent types/regions that may be touched\n+            // by a destructor.\n+            result.kinds.append(&mut constraints.outlives);\n+            result.overflows.append(&mut constraints.overflows);\n+\n+            // If we have even one overflow, we should stop trying to evaluate further --\n+            // chances are, the subsequent overflows for this evaluation won't provide useful\n+            // information and will just decrease the speed at which we can emit these errors\n+            // (since we'll be printing for just that much longer for the often enormous types\n+            // that result here).\n+            if !result.overflows.is_empty() {\n+                break;\n+            }\n \n-        // dtorck types are \"types that will get dropped but which\n-        // do not themselves define a destructor\", more or less. We have\n-        // to push them onto the stack to be expanded.\n-        for ty in constraints.dtorck_types.drain(..) {\n-            match infcx.at(&cause, param_env).normalize(ty) {\n-                Ok(Normalized { value: ty, obligations }) => {\n-                    fulfill_cx.register_predicate_obligations(infcx, obligations);\n-\n-                    debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n-\n-                    match ty.kind() {\n-                        // All parameters live for the duration of the\n-                        // function.\n-                        ty::Param(..) => {}\n-\n-                        // A projection that we couldn't resolve - it\n-                        // might have a destructor.\n-                        ty::Projection(..) | ty::Opaque(..) => {\n-                            result.kinds.push(ty.into());\n-                        }\n+            // dtorck types are \"types that will get dropped but which\n+            // do not themselves define a destructor\", more or less. We have\n+            // to push them onto the stack to be expanded.\n+            for ty in constraints.dtorck_types.drain(..) {\n+                let Normalized { value: ty, obligations } =\n+                    ocx.infcx.at(&cause, param_env).normalize(ty)?;\n+                ocx.register_obligations(obligations);\n+\n+                debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n+\n+                match ty.kind() {\n+                    // All parameters live for the duration of the\n+                    // function.\n+                    ty::Param(..) => {}\n+\n+                    // A projection that we couldn't resolve - it\n+                    // might have a destructor.\n+                    ty::Projection(..) | ty::Opaque(..) => {\n+                        result.kinds.push(ty.into());\n+                    }\n \n-                        _ => {\n-                            if ty_set.insert(ty) {\n-                                ty_stack.push((ty, depth + 1));\n-                            }\n+                    _ => {\n+                        if ty_set.insert(ty) {\n+                            ty_stack.push((ty, depth + 1));\n                         }\n                     }\n                 }\n-\n-                // We don't actually expect to fail to normalize.\n-                // That implies a WF error somewhere else.\n-                Err(NoSolution) => {\n-                    return Err(NoSolution);\n-                }\n             }\n         }\n-    }\n-\n-    debug!(\"dropck_outlives: result = {:#?}\", result);\n \n-    infcx.make_canonicalized_query_response(canonical_inference_vars, result, &mut *fulfill_cx)\n+        debug!(\"dropck_outlives: result = {:#?}\", result);\n+        Ok(result)\n+    })\n }\n \n /// Returns a set of constraints that needs to be satisfied in"}, {"sha": "32bdc26bc51adad308ff88f7fbbcde931af04230", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -1464,6 +1464,19 @@ pub(crate) mod builtin {\n         /* compiler built-in */\n     }\n \n+    /// Attribute macro used to apply derive macros for implementing traits\n+    /// in a const context.\n+    ///\n+    /// See [the reference] for more info.\n+    ///\n+    /// [the reference]: ../../../reference/attributes/derive.html\n+    #[unstable(feature = \"derive_const\", issue = \"none\")]\n+    #[rustc_builtin_macro]\n+    #[cfg(not(bootstrap))]\n+    pub macro derive_const($item:item) {\n+        /* compiler built-in */\n+    }\n+\n     /// Attribute macro applied to a function to turn it into a unit test.\n     ///\n     /// See [the reference] for more info."}, {"sha": "d3d255a802d7f626ec89be2d0d5f683ec5914254", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -81,6 +81,10 @@ pub use crate::macros::builtin::alloc_error_handler;\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n pub use crate::macros::builtin::{bench, derive, global_allocator, test, test_case};\n \n+#[unstable(feature = \"derive_const\", issue = \"none\")]\n+#[cfg(not(bootstrap))]\n+pub use crate::macros::builtin::derive_const;\n+\n #[unstable(\n     feature = \"cfg_accessible\",\n     issue = \"64797\","}, {"sha": "d5ac16e6b94e27a6f80b83c475e4500f4128e615", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -65,6 +65,10 @@ pub use core::prelude::v1::alloc_error_handler;\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n pub use core::prelude::v1::{bench, derive, global_allocator, test, test_case};\n \n+#[unstable(feature = \"derive_const\", issue = \"none\")]\n+#[cfg(not(bootstrap))]\n+pub use core::prelude::v1::derive_const;\n+\n // Do not `doc(no_inline)` either.\n #[unstable(\n     feature = \"cfg_accessible\","}, {"sha": "1f6fb961e918d430a5ad45ba293819769717c982", "filename": "src/librustdoc/html/static/css/settings.css", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -8,7 +8,8 @@\n \tflex-wrap: wrap;\n }\n \n-.setting-line .radio-line input {\n+.setting-line .radio-line input,\n+.setting-line .toggle input {\n \tmargin-right: 0.3em;\n \theight: 1.2rem;\n \twidth: 1.2rem;\n@@ -17,9 +18,18 @@\n \toutline: none;\n \t-webkit-appearance: none;\n \tcursor: pointer;\n+}\n+.setting-line .radio-line input {\n \tborder-radius: 50%;\n }\n-.setting-line .radio-line input + span {\n+.setting-line .toggle input:checked {\n+\tcontent: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 40 40\">\\\n+\t\t<path d=\"M7,25L17,32L33,12\" fill=\"none\" stroke=\"black\" stroke-width=\"5\"/>\\\n+\t\t<path d=\"M7,23L17,30L33,10\" fill=\"none\" stroke=\"white\" stroke-width=\"5\"/></svg>');\n+}\n+\n+.setting-line .radio-line input + span,\n+.setting-line .toggle span {\n \tpadding-bottom: 1px;\n }\n \n@@ -49,37 +59,6 @@\n \tcursor: pointer;\n }\n \n-.toggle input {\n-\topacity: 0;\n-\tposition: absolute;\n-}\n-\n-.slider {\n-\tposition: relative;\n-\twidth: 45px;\n-\tmin-width: 45px;\n-\tdisplay: block;\n-\theight: 28px;\n-\tmargin-right: 20px;\n-\tcursor: pointer;\n-\tbackground-color: #ccc;\n-\ttransition: .3s;\n-}\n-\n-.slider:before {\n-\tposition: absolute;\n-\tcontent: \"\";\n-\theight: 19px;\n-\twidth: 19px;\n-\tleft: 4px;\n-\tbottom: 4px;\n-\ttransition: .3s;\n-}\n-\n-input:checked + .slider:before {\n-\ttransform: translateX(19px);\n-}\n-\n .setting-line > .sub-settings {\n \tpadding-left: 42px;\n \twidth: 100%;\n@@ -94,17 +73,19 @@ input:checked + .slider:before {\n \tbox-shadow: inset 0 0 0 3px var(--main-background-color);\n \tbackground-color: var(--settings-input-color);\n }\n-.setting-line .radio-line input:focus {\n+.setting-line .toggle input:checked {\n+\tbackground-color: var(--settings-input-color);\n+}\n+.setting-line .radio-line input:focus,\n+.setting-line .toggle input:focus {\n \tbox-shadow: 0 0 1px 1px var(--settings-input-color);\n }\n /* In here we combine both `:focus` and `:checked` properties. */\n .setting-line .radio-line input:checked:focus {\n \tbox-shadow: inset 0 0 0 3px var(--main-background-color),\n \t\t0 0 2px 2px var(--settings-input-color);\n }\n-.setting-line .radio-line input:hover {\n+.setting-line .radio-line input:hover,\n+.setting-line .toggle input:hover {\n \tborder-color: var(--settings-input-color) !important;\n }\n-input:checked + .slider {\n-\tbackground-color: var(--settings-input-color);\n-}"}, {"sha": "4beca56b66a6238f60988e71c716160206fac632", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -77,16 +77,6 @@ Original by Dempfi (https://github.com/dempfi/ayu)\n \t--crate-search-hover-border: #e0e0e0;\n }\n \n-.slider {\n-\tbackground-color: #ccc;\n-}\n-.slider:before {\n-\tbackground-color: white;\n-}\n-input:focus + .slider {\n-\tbox-shadow: 0 0 0 2px #0a84ff, 0 0 0 6px rgba(10, 132, 255, 0.3);\n-}\n-\n h1, h2, h3, h4 {\n \tcolor: white;\n }"}, {"sha": "9b0bd8c8f0a4bb67e9a1e37a35f4a4f51fa69ca4", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -72,16 +72,6 @@\n \t--crate-search-hover-border: #2196f3;\n }\n \n-.slider {\n-\tbackground-color: #ccc;\n-}\n-.slider:before {\n-\tbackground-color: white;\n-}\n-input:focus + .slider {\n-\tbox-shadow: 0 0 0 2px #0a84ff, 0 0 0 6px rgba(10, 132, 255, 0.3);\n-}\n-\n .content .item-info::before { color: #ccc; }\n \n body.source .example-wrap pre.rust a {"}, {"sha": "f12fb61d879b2b95f9a30bcd5224b798eb9082fe", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -69,15 +69,6 @@\n \t--crate-search-hover-border: #717171;\n }\n \n-.slider {\n-\tbackground-color: #ccc;\n-}\n-.slider:before {\n-\tbackground-color: white;\n-}\n-input:focus + .slider {\n-\tbox-shadow: 0 0 0 2px #0a84ff, 0 0 0 6px rgba(10, 132, 255, 0.3);\n-}\n \n .content .item-info::before { color: #ccc; }\n "}, {"sha": "95cc265f1bdf6b96d05fe637d1295e14b3b8d474", "filename": "src/librustdoc/html/static/js/settings.js", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -66,8 +66,7 @@\n \n     function setEvents(settingsElement) {\n         updateLightAndDark();\n-        onEachLazy(settingsElement.getElementsByClassName(\"slider\"), elem => {\n-            const toggle = elem.previousElementSibling;\n+        onEachLazy(settingsElement.querySelectorAll(\"input[type=\\\"checkbox\\\"]\"), toggle => {\n             const settingId = toggle.id;\n             const settingValue = getSettingValue(settingId);\n             if (settingValue !== null) {\n@@ -139,7 +138,6 @@\n                 const checked = setting[\"default\"] === true ? \" checked\" : \"\";\n                 output += `<label class=\"toggle\">\\\n                         <input type=\"checkbox\" id=\"${js_data_name}\"${checked}>\\\n-                        <span class=\"slider\"></span>\\\n                         <span class=\"label\">${setting_name}</span>\\\n                     </label>`;\n             }"}, {"sha": "fec21ad35c3ebe098cbebcd4d24d7bf1e87d249f", "filename": "src/test/rustdoc-gui/docblock-code-block-line-number.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Frustdoc-gui%2Fdocblock-code-block-line-number.goml", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Frustdoc-gui%2Fdocblock-code-block-line-number.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fdocblock-code-block-line-number.goml?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -30,10 +30,10 @@ wait-for: \"#settings\"\n assert-css: (\"#settings\", {\"display\": \"block\"})\n \n // Then, click the toggle button.\n-click: \"input#line-numbers + .slider\"\n+click: \"input#line-numbers\"\n wait-for: 100 // wait-for-false does not exist\n assert-false: \"pre.example-line-numbers\"\n \n // Finally, turn it on again.\n-click: \"input#line-numbers + .slider\"\n+click: \"input#line-numbers\"\n wait-for: \"pre.example-line-numbers\""}, {"sha": "7e7971d47fbcaf7d200d92c682ee738f2a6d3c79", "filename": "src/test/rustdoc-gui/settings.goml", "status": "modified", "additions": 82, "deletions": 10, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Frustdoc-gui%2Fsettings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Frustdoc-gui%2Fsettings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsettings.goml?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -48,7 +48,8 @@ assert: \".setting-line.hidden #preferred-light-theme\"\n assert-property: (\"#theme .choices #theme-dark\", {\"checked\": \"true\"})\n \n // Some style checks...\n-// First we check the \"default\" display.\n+move-cursor-to: \"#settings-menu > a\"\n+// First we check the \"default\" display for radio buttons.\n assert-css: (\n     \"#theme-dark\",\n     {\n@@ -57,7 +58,7 @@ assert-css: (\n     },\n )\n assert-css: (\"#theme-light\", {\"border-color\": \"rgb(221, 221, 221)\", \"box-shadow\": \"none\"})\n-// Let's start with the hover.\n+// Let's start with the hover for radio buttons.\n move-cursor-to: \"#theme-dark\"\n assert-css: (\n     \"#theme-dark\",\n@@ -69,7 +70,7 @@ assert-css: (\n move-cursor-to: \"#theme-light\"\n assert-css: (\"#theme-light\", {\"border-color\": \"rgb(33, 150, 243)\", \"box-shadow\": \"none\"})\n move-cursor-to: \"#theme-ayu\"\n-// Let's now check with the focus.\n+// Let's now check with the focus for radio buttons.\n focus: \"#theme-dark\"\n assert-css: (\n     \"#theme-dark\",\n@@ -86,7 +87,7 @@ assert-css: (\n         \"box-shadow\": \"rgb(33, 150, 243) 0px 0px 1px 1px\",\n     },\n )\n-// Now we check we both focus and hover.\n+// Now we check we both focus and hover for radio buttons.\n move-cursor-to: \"#theme-dark\"\n focus: \"#theme-dark\"\n assert-css: (\n@@ -106,6 +107,80 @@ assert-css: (\n     },\n )\n \n+// First we check the \"default\" display for toggles.\n+assert-css: (\n+    \"#auto-hide-large-items\",\n+    {\n+        \"background-color\": \"rgb(33, 150, 243)\",\n+        \"border-color\": \"rgb(221, 221, 221)\",\n+    },\n+)\n+assert-css: (\n+    \"#use-system-theme\",\n+    {\n+        \"background-color\": \"rgba(0, 0, 0, 0)\",\n+        \"border-color\": \"rgb(221, 221, 221)\",\n+    }\n+)\n+// Let's start with the hover for toggles.\n+move-cursor-to: \"#auto-hide-large-items\"\n+assert-css: (\n+    \"#auto-hide-large-items\",\n+    {\n+        \"background-color\": \"rgb(33, 150, 243)\",\n+        \"border-color\": \"rgb(33, 150, 243)\",\n+    },\n+)\n+move-cursor-to: \"#use-system-theme\"\n+assert-css: (\n+    \"#use-system-theme\",\n+    {\n+        \"background-color\": \"rgba(0, 0, 0, 0)\",\n+        \"border-color\": \"rgb(33, 150, 243)\",\n+    }\n+)\n+move-cursor-to: \"#settings-menu > a\"\n+// Let's now check with the focus for toggles.\n+focus: \"#auto-hide-large-items\"\n+assert-css: (\n+    \"#auto-hide-large-items\",\n+    {\n+        \"background-color\": \"rgb(33, 150, 243)\",\n+        \"border-color\": \"rgb(221, 221, 221)\",\n+        \"box-shadow\": \"rgb(33, 150, 243) 0px 0px 1px 1px\",\n+    },\n+)\n+focus: \"#use-system-theme\"\n+assert-css: (\n+    \"#use-system-theme\",\n+    {\n+        \"background-color\": \"rgba(0, 0, 0, 0)\",\n+        \"border-color\": \"rgb(221, 221, 221)\",\n+        \"box-shadow\": \"rgb(33, 150, 243) 0px 0px 1px 1px\",\n+    },\n+)\n+// Now we check we both focus and hover for toggles.\n+move-cursor-to: \"#auto-hide-large-items\"\n+focus: \"#auto-hide-large-items\"\n+assert-css: (\n+    \"#auto-hide-large-items\",\n+    {\n+        \"background-color\": \"rgb(33, 150, 243)\",\n+        \"border-color\": \"rgb(33, 150, 243)\",\n+        \"box-shadow\": \"rgb(33, 150, 243) 0px 0px 1px 1px\",\n+    },\n+)\n+move-cursor-to: \"#use-system-theme\"\n+focus: \"#use-system-theme\"\n+assert-css: (\n+    \"#use-system-theme\",\n+    {\n+        \"background-color\": \"rgba(0, 0, 0, 0)\",\n+        \"border-color\": \"rgb(33, 150, 243)\",\n+        \"box-shadow\": \"rgb(33, 150, 243) 0px 0px 1px 1px\",\n+    },\n+)\n+\n // We now switch the display.\n click: \"#use-system-theme\"\n // Wait for the hidden element to show up.\n@@ -118,7 +193,7 @@ assert: \".setting-line.hidden #theme\"\n assert-text: (\"#preferred-dark-theme .setting-name\", \"Preferred dark theme\")\n assert-text: (\"#preferred-light-theme .setting-name\", \"Preferred light theme\")\n \n-// We now check that clicking on the \"sliders\"' text is like clicking on the slider.\n+// We now check that clicking on the toggles' text is like clicking on the checkbox.\n // To test it, we use the \"Disable keyboard shortcuts\".\n local-storage: {\"rustdoc-disable-shortcuts\": \"false\"}\n click: \".setting-line:last-child .toggle .label\"\n@@ -141,10 +216,7 @@ assert-css: (\"#settings-menu .popover\", {\"display\": \"none\"})\n // Now we go to the settings page to check that the CSS is loaded as expected.\n goto: \"file://\" + |DOC_PATH| + \"/settings.html\"\n wait-for: \"#settings\"\n-assert-css: (\n-    \".setting-line .toggle .slider\",\n-    {\"width\": \"45px\", \"margin-right\": \"20px\", \"border\": \"0px none rgb(0, 0, 0)\"},\n-)\n+assert-css: (\".setting-line\", {\"position\": \"relative\"})\n \n assert-attribute-false: (\"#settings\", {\"class\": \"popover\"}, CONTAINS)\n compare-elements-position: (\".sub form\", \"#settings\", (\"x\"))\n@@ -162,4 +234,4 @@ reload:\n size: (300, 1000)\n click: \"#settings-menu\"\n wait-for: \"#settings\"\n-assert-css: (\"#settings .slider\", {\"width\": \"45px\"}, ALL)\n+assert-css: (\".setting-line\", {\"position\": \"relative\"})"}, {"sha": "e8ddccc854abe3b8f65a7ee77b3510682c22c97f", "filename": "src/test/ui/asm/naked-invalid-attr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fasm%2Fnaked-invalid-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fasm%2Fnaked-invalid-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fnaked-invalid-attr.stderr?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -36,7 +36,7 @@ error: attribute should be applied to a function definition\n   --> $DIR/naked-invalid-attr.rs:5:1\n    |\n LL | #![naked]\n-   | ^^^^^^^^^\n+   | ^^^^^^^^^ cannot be applied to crates\n \n error: aborting due to 5 previous errors\n "}, {"sha": "7876704042188d065caab0e78b41f97c30366d29", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-builtin-attrs-error.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs-error.stderr?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -110,19 +110,19 @@ error: attribute should be applied to an `extern crate` item\n   --> $DIR/issue-43106-gating-of-builtin-attrs-error.rs:25:1\n    |\n LL | #![no_link]\n-   | ^^^^^^^^^^^\n+   | ^^^^^^^^^^^ not an `extern crate` item\n \n error: attribute should be applied to a free function, impl method or static\n   --> $DIR/issue-43106-gating-of-builtin-attrs-error.rs:27:1\n    |\n LL | #![export_name = \"2200\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^ not a free function, impl method or static\n \n error[E0518]: attribute should be applied to function or closure\n   --> $DIR/issue-43106-gating-of-builtin-attrs-error.rs:29:1\n    |\n LL | #![inline]\n-   | ^^^^^^^^^^\n+   | ^^^^^^^^^^ not a function or closure\n \n error: `macro_export` attribute cannot be used at crate level\n   --> $DIR/issue-43106-gating-of-builtin-attrs-error.rs:12:1"}, {"sha": "1fa315f3d215987d28050aad84ba0c94eb9497d4", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-builtin-attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -1,6 +1,6 @@\n //~ NOTE not a function\n //~| NOTE not a foreign function or static\n-//~| NOTE not a function or static\n+//~| NOTE cannot be applied to crates\n //~| NOTE not an `extern` block\n // This test enumerates as many compiler-builtin ungated attributes as\n // possible (that is, all the mutually compatible ones), and checks"}, {"sha": "30039267979fb6db14c533f4306f9ca40ec9787f", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-builtin-attrs.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -403,31 +403,31 @@ warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:62:1\n    |\n LL | #![cold]\n-   | ^^^^^^^^\n+   | ^^^^^^^^ cannot be applied to crates\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to an `extern` block with non-Rust ABI\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:64:1\n    |\n LL | #![link()]\n-   | ^^^^^^^^^^\n+   | ^^^^^^^^^^ not an `extern` block\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a foreign function or static\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:66:1\n    |\n LL | #![link_name = \"1900\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^ not a foreign function or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n warning: attribute should be applied to a function or static\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:69:1\n    |\n LL | #![link_section = \"1800\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ not a function or static\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n "}, {"sha": "c848ee3f643deb1d7459999e540fc10cf23b4e8d", "filename": "src/test/ui/impl-trait/in-trait/method-signature-matches.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -0,0 +1,51 @@\n+// edition: 2021\n+\n+#![feature(return_position_impl_trait_in_trait, async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+trait Uwu {\n+    fn owo(x: ()) -> impl Sized;\n+}\n+\n+impl Uwu for () {\n+    fn owo(_: u8) {}\n+    //~^ ERROR method `owo` has an incompatible type for trait\n+}\n+\n+trait AsyncUwu {\n+    async fn owo(x: ()) {}\n+}\n+\n+impl AsyncUwu for () {\n+    async fn owo(_: u8) {}\n+    //~^ ERROR method `owo` has an incompatible type for trait\n+}\n+\n+trait TooMuch {\n+    fn calm_down_please() -> impl Sized;\n+}\n+\n+impl TooMuch for () {\n+    fn calm_down_please(_: (), _: (), _: ()) {}\n+    //~^ ERROR method `calm_down_please` has 3 parameters but the declaration in trait `TooMuch::calm_down_please` has 0\n+}\n+\n+trait TooLittle {\n+    fn come_on_a_little_more_effort(_: (), _: (), _: ()) -> impl Sized;\n+}\n+\n+impl TooLittle for () {\n+    fn come_on_a_little_more_effort() {}\n+    //~^ ERROR method `come_on_a_little_more_effort` has 0 parameters but the declaration in trait `TooLittle::come_on_a_little_more_effort` has 3\n+}\n+\n+trait Lifetimes {\n+    fn early<'early, T>(x: &'early T) -> impl Sized;\n+}\n+\n+impl Lifetimes for () {\n+    fn early<'late, T>(_: &'late ()) {}\n+    //~^ ERROR method `early` has an incompatible type for trait\n+}\n+\n+fn main() {}"}, {"sha": "2b32c52c829ec4075449fb3d2ee77f86e0b304af", "filename": "src/test/ui/impl-trait/in-trait/method-signature-matches.stderr", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.stderr?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -0,0 +1,84 @@\n+error[E0053]: method `owo` has an incompatible type for trait\n+  --> $DIR/method-signature-matches.rs:11:15\n+   |\n+LL |     fn owo(_: u8) {}\n+   |               ^^\n+   |               |\n+   |               expected `()`, found `u8`\n+   |               help: change the parameter type to match the trait: `()`\n+   |\n+note: type in trait\n+  --> $DIR/method-signature-matches.rs:7:15\n+   |\n+LL |     fn owo(x: ()) -> impl Sized;\n+   |               ^^\n+   = note: expected fn pointer `fn(())`\n+              found fn pointer `fn(u8)`\n+\n+error[E0053]: method `owo` has an incompatible type for trait\n+  --> $DIR/method-signature-matches.rs:20:21\n+   |\n+LL |     async fn owo(_: u8) {}\n+   |                     ^^\n+   |                     |\n+   |                     expected `()`, found `u8`\n+   |                     help: change the parameter type to match the trait: `()`\n+   |\n+note: while checking the return type of the `async fn`\n+  --> $DIR/method-signature-matches.rs:20:25\n+   |\n+LL |     async fn owo(_: u8) {}\n+   |                         ^ checked the `Output` of this `async fn`, expected opaque type\n+note: while checking the return type of the `async fn`\n+  --> $DIR/method-signature-matches.rs:20:25\n+   |\n+LL |     async fn owo(_: u8) {}\n+   |                         ^ checked the `Output` of this `async fn`, found opaque type\n+note: type in trait\n+  --> $DIR/method-signature-matches.rs:16:21\n+   |\n+LL |     async fn owo(x: ()) {}\n+   |                     ^^\n+   = note: expected fn pointer `fn(()) -> _`\n+              found fn pointer `fn(u8) -> _`\n+\n+error[E0050]: method `calm_down_please` has 3 parameters but the declaration in trait `TooMuch::calm_down_please` has 0\n+  --> $DIR/method-signature-matches.rs:29:28\n+   |\n+LL |     fn calm_down_please() -> impl Sized;\n+   |     ------------------------------------ trait requires 0 parameters\n+...\n+LL |     fn calm_down_please(_: (), _: (), _: ()) {}\n+   |                            ^^^^^^^^^^^^^^^^ expected 0 parameters, found 3\n+\n+error[E0050]: method `come_on_a_little_more_effort` has 0 parameters but the declaration in trait `TooLittle::come_on_a_little_more_effort` has 3\n+  --> $DIR/method-signature-matches.rs:38:5\n+   |\n+LL |     fn come_on_a_little_more_effort(_: (), _: (), _: ()) -> impl Sized;\n+   |                                        ---------------- trait requires 3 parameters\n+...\n+LL |     fn come_on_a_little_more_effort() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 3 parameters, found 0\n+\n+error[E0053]: method `early` has an incompatible type for trait\n+  --> $DIR/method-signature-matches.rs:47:27\n+   |\n+LL |     fn early<'late, T>(_: &'late ()) {}\n+   |                     -     ^^^^^^^^^\n+   |                     |     |\n+   |                     |     expected type parameter `T`, found `()`\n+   |                     |     help: change the parameter type to match the trait: `&'early T`\n+   |                     this type parameter\n+   |\n+note: type in trait\n+  --> $DIR/method-signature-matches.rs:43:28\n+   |\n+LL |     fn early<'early, T>(x: &'early T) -> impl Sized;\n+   |                            ^^^^^^^^^\n+   = note: expected fn pointer `fn(&'early T)`\n+              found fn pointer `fn(&())`\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0050, E0053.\n+For more information about an error, try `rustc --explain E0050`."}, {"sha": "5a758c7002b92b6a54deb76a08a8fed43667611a", "filename": "src/test/ui/issues/issue-32655.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fissues%2Fissue-32655.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fissues%2Fissue-32655.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32655.stderr?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -2,18 +2,28 @@ error: cannot find attribute `derive_Clone` in this scope\n   --> $DIR/issue-32655.rs:3:11\n    |\n LL |         #[derive_Clone]\n-   |           ^^^^^^^^^^^^\n+   |           ^^^^^^^^^^^^ help: an attribute macro with a similar name exists: `derive_const`\n ...\n LL | foo!();\n    | ------ in this macro invocation\n    |\n+  ::: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+   |\n+LL |     pub macro derive_const($item:item) {\n+   |     ---------------------- similarly named attribute macro `derive_const` defined here\n+   |\n    = note: this error originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: cannot find attribute `derive_Clone` in this scope\n   --> $DIR/issue-32655.rs:15:7\n    |\n LL |     #[derive_Clone]\n-   |       ^^^^^^^^^^^^\n+   |       ^^^^^^^^^^^^ help: an attribute macro with a similar name exists: `derive_const`\n+   |\n+  ::: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+   |\n+LL |     pub macro derive_const($item:item) {\n+   |     ---------------------- similarly named attribute macro `derive_const` defined here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "89aeafebac497da7cb98c81f6408934209e310b2", "filename": "src/test/ui/issues/issue-69396-const-no-type-in-macro.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.stderr?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -2,10 +2,7 @@ error[E0428]: the name `A` is defined multiple times\n   --> $DIR/issue-69396-const-no-type-in-macro.rs:4:13\n    |\n LL |               const A = \"A\".$fn();\n-   |               ^^^^^^^^^^^^^^^^^^^^\n-   |               |\n-   |               `A` redefined here\n-   |               previous definition of the value `A` here\n+   |               ^^^^^^^^^^^^^^^^^^^^ `A` redefined here\n ...\n LL | / suite! {\n LL | |     len;"}, {"sha": "4c424999b754d5e867f0e402da5b3f318b1f33f0", "filename": "src/test/ui/iterators/collect-into-array.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -1,5 +1,4 @@\n fn main() {\n-    //~^ NOTE required by a bound in this\n     let whatever: [u32; 10] = (0..10).collect();\n     //~^ ERROR an array of type `[u32; 10]` cannot be built directly from an iterator\n     //~| NOTE try collecting into a `Vec<{integer}>`, then using `.try_into()`"}, {"sha": "a23a36a88abb336dd24a54ec7ce3f41c9654ee90", "filename": "src/test/ui/iterators/collect-into-array.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-array.stderr?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: an array of type `[u32; 10]` cannot be built directly from an iterator\n-  --> $DIR/collect-into-array.rs:3:31\n+  --> $DIR/collect-into-array.rs:2:31\n    |\n LL |     let whatever: [u32; 10] = (0..10).collect();\n    |                               ^^^^^^^ ------- required by a bound introduced by this call"}, {"sha": "09832c260d04e82e5e64d0ccc510bf49ae6a42a6", "filename": "src/test/ui/iterators/collect-into-slice.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -1,6 +1,4 @@\n fn process_slice(data: &[i32]) {\n-    //~^ NOTE required by a bound in this\n-    //~| NOTE required by a bound in this\n     todo!()\n }\n "}, {"sha": "bc152467ce3a5c5d94d1c06ca790ec3793a38492", "filename": "src/test/ui/iterators/collect-into-slice.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fcollect-into-slice.stderr?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the size for values of type `[i32]` cannot be known at compilation time\n-  --> $DIR/collect-into-slice.rs:8:9\n+  --> $DIR/collect-into-slice.rs:6:9\n    |\n LL |     let some_generated_vec = (0..10).collect();\n    |         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n@@ -9,7 +9,7 @@ LL |     let some_generated_vec = (0..10).collect();\n    = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `[i32]` cannot be known at compilation time\n-  --> $DIR/collect-into-slice.rs:8:38\n+  --> $DIR/collect-into-slice.rs:6:38\n    |\n LL |     let some_generated_vec = (0..10).collect();\n    |                                      ^^^^^^^ doesn't have a size known at compile-time\n@@ -22,7 +22,7 @@ LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n    |                ^ required by this bound in `collect`\n \n error[E0277]: a slice of type `[i32]` cannot be built since `[i32]` has no definite size\n-  --> $DIR/collect-into-slice.rs:8:30\n+  --> $DIR/collect-into-slice.rs:6:30\n    |\n LL |     let some_generated_vec = (0..10).collect();\n    |                              ^^^^^^^ ------- required by a bound introduced by this call"}, {"sha": "348ca0ab1906b8c720d7ceb712790a96de2459e7", "filename": "src/test/ui/rfc-2632-const-trait-impl/const_derives/derive-const-gate.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-gate.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -0,0 +1,4 @@\n+#[derive_const(Default)] //~ ERROR use of unstable library feature\n+pub struct S;\n+\n+fn main() {}"}, {"sha": "cc9bdd2715f70fa04014c2c022e82bab8b48646f", "filename": "src/test/ui/rfc-2632-const-trait-impl/const_derives/derive-const-gate.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-gate.stderr?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: use of unstable library feature 'derive_const'\n+  --> $DIR/derive-const-gate.rs:1:3\n+   |\n+LL | #[derive_const(Default)]\n+   |   ^^^^^^^^^^^^\n+   |\n+   = help: add `#![feature(derive_const)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "92843a8a2da488391b596b5ac51793c5a7975787", "filename": "src/test/ui/rfc-2632-const-trait-impl/const_derives/derive-const-non-const-type.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-non-const-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-non-const-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-non-const-type.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -0,0 +1,13 @@\n+#![feature(derive_const)]\n+\n+pub struct A;\n+\n+impl Default for A {\n+    fn default() -> A { A }\n+}\n+\n+#[derive_const(Default)]\n+pub struct S(A);\n+//~^ cannot call non-const fn\n+\n+fn main() {}"}, {"sha": "d463c774e289efbf876ea902009d996c528207e8", "filename": "src/test/ui/rfc-2632-const-trait-impl/const_derives/derive-const-non-const-type.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-non-const-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-non-const-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-non-const-type.stderr?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -0,0 +1,14 @@\n+error[E0015]: cannot call non-const fn `<A as Default>::default` in constant functions\n+  --> $DIR/derive-const-non-const-type.rs:10:14\n+   |\n+LL | #[derive_const(Default)]\n+   |                ------- in this derive macro expansion\n+LL | pub struct S(A);\n+   |              ^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the derive macro `Default` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0015`."}, {"sha": "d1fbeac8598e47294bbab4def7f4bc6082291dff", "filename": "src/test/ui/rfc-2632-const-trait-impl/const_derives/derive-const-use.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst_derives%2Fderive-const-use.rs?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+#![feature(const_trait_impl, const_cmp, const_default_impls, derive_const)]\n+\n+pub struct A;\n+\n+impl const Default for A {\n+    fn default() -> A { A }\n+}\n+\n+impl const PartialEq for A {\n+    fn eq(&self, _: &A) -> bool { true }\n+}\n+\n+#[derive_const(Default, PartialEq)]\n+pub struct S((), A);\n+\n+const _: () = assert!(S((), A) == S::default());\n+\n+fn main() {}"}, {"sha": "a3dfea71ca0c888a88111086898aa833c291d497", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -1 +1 @@\n-Subproject commit 9286a1beba5b28b115bad67de2ae91fb1c61eb0b\n+Subproject commit a3dfea71ca0c888a88111086898aa833c291d497"}, {"sha": "8efd9af41a42df4e4d14ea192d7de37516c87ed0", "filename": "triagebot.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f4e73c4a4212922f0c24c6743b3837902619200/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5f4e73c4a4212922f0c24c6743b3837902619200/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=5f4e73c4a4212922f0c24c6743b3837902619200", "patch": "@@ -573,6 +573,7 @@ fallback = [\n \"/src/llvm-project\" =                        [\"@cuviper\"]\n \"/src/rustdoc-json-types\" =                  [\"rustdoc\"]\n \"/src/stage0.json\" =                         [\"bootstrap\"]\n+\"/src/test/ui\" =                             [\"compiler\"]\n \"/src/tools/cargo\" =                         [\"@ehuss\", \"@joshtriplett\"]\n \"/src/tools/compiletest\" =                   [\"bootstrap\"]\n \"/src/tools/linkchecker\" =                   [\"@ehuss\"]"}]}