{"sha": "1dde5e7fc2ed6c1530919a0298bd3691feca3e2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZGU1ZTdmYzJlZDZjMTUzMDkxOWEwMjk4YmQzNjkxZmVjYTNlMmY=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-24T23:58:48Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-25T19:12:25Z"}, "message": "Thread spans through the pipe compiler. They aren't perfect, but they make debugging far easier than core.rc:0:0.\n\nChanged the is_bounded check, so we fail compiling core right now due to not supporting type parameters.", "tree": {"sha": "5af656f1318fe06b7e51ad4c37c3592362f37677", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5af656f1318fe06b7e51ad4c37c3592362f37677"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f", "html_url": "https://github.com/rust-lang/rust/commit/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ecddb2771922bcd0f117a3a3f681da9bcb8b70c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ecddb2771922bcd0f117a3a3f681da9bcb8b70c", "html_url": "https://github.com/rust-lang/rust/commit/7ecddb2771922bcd0f117a3a3f681da9bcb8b70c"}], "stats": {"total": 162, "additions": 91, "deletions": 71}, "files": [{"sha": "27cd8ef7cafa043a7089a7d0c909f67633d969ce", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=1dde5e7fc2ed6c1530919a0298bd3691feca3e2f", "patch": "@@ -8,7 +8,7 @@ import arc::methods;\n // Things used by code generated by the pipe compiler.\n export entangle, get_buffer, drop_buffer;\n export send_packet_buffered, recv_packet_buffered;\n-export packet, mk_packet, entangle_buffer, has_buffer;\n+export packet, mk_packet, entangle_buffer, has_buffer, buffer_header;\n \n // export these so we can find them in the buffer_resource\n // destructor. This is probably another metadata bug."}, {"sha": "c9b35e561bb4511ae20f7c164c9f1631249abd87", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=1dde5e7fc2ed6c1530919a0298bd3691feca3e2f", "patch": "@@ -19,30 +19,25 @@ fn ident(s: ~str) -> ast::ident {\n     @(copy s)\n }\n \n-fn empty_span() -> span {\n-    {lo: 0, hi: 0, expn_info: none}\n-}\n-\n-fn span<T>(+x: T) -> ast::spanned<T> {\n-    {node: x,\n-     span: empty_span()}\n-}\n-\n-fn path(id: ident) -> @ast::path {\n-    @{span: empty_span(),\n+fn path(id: ident, span: span) -> @ast::path {\n+    @{span: span,\n       global: false,\n       idents: ~[id],\n       rp: none,\n       types: ~[]}\n }\n \n+fn empty_span() -> span {\n+    {lo: 0, hi: 0, expn_info: none}\n+}\n+\n trait path_concat {\n     fn +(id: ident) -> @ast::path;\n }\n \n impl methods of path_concat for ident {\n     fn +(id: ident) -> @ast::path {\n-        path(self) + id\n+        path(self, empty_span()) + id\n     }\n }\n \n@@ -107,19 +102,24 @@ trait ext_ctxt_ast_builder {\n     fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt;\n     fn stmt_expr(e: @ast::expr) -> @ast::stmt;\n     fn block_expr(b: ast::blk) -> @ast::expr;\n+    fn empty_span() -> span;\n }\n \n impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n+    fn empty_span() -> span {\n+        {lo: 0, hi: 0, expn_info: self.backtrace()}\n+    }\n+\n     fn block_expr(b: ast::blk) -> @ast::expr {\n         @{id: self.next_id(),\n           callee_id: self.next_id(),\n           node: ast::expr_block(b),\n-          span: empty_span()}\n+          span: self.empty_span()}\n     }\n \n     fn stmt_expr(e: @ast::expr) -> @ast::stmt {\n         @{node: ast::stmt_expr(e, self.next_id()),\n-          span: empty_span()}\n+          span: self.empty_span()}\n     }\n \n     fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt {\n@@ -133,43 +133,44 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n             @{node: {is_mutbl: false,\n                      ty: self.ty_infer(),\n                      pat: @{id: self.next_id(),\n-                            node: ast::pat_ident(path(ident), none),\n-                            span: empty_span()},\n+                            node: ast::pat_ident(\n+                                path(ident, self.empty_span()), none),\n+                            span: self.empty_span()},\n                      init: some({op: ast::init_move,\n                                  expr: e}),\n                      id: self.next_id()},\n-              span: empty_span()}]),\n-                               span: empty_span()}, self.next_id()),\n-         span: empty_span()}\n+              span: self.empty_span()}]),\n+                               span: self.empty_span()}, self.next_id()),\n+         span: self.empty_span()}\n     }\n \n     fn field_imm(name: ident, e: @ast::expr) -> ast::field {\n         {node: {mutbl: ast::m_imm, ident: name, expr: e},\n-         span: empty_span()}\n+         span: self.empty_span()}\n     }\n \n     fn rec(+fields: ~[ast::field]) -> @ast::expr {\n         @{id: self.next_id(),\n           callee_id: self.next_id(),\n           node: ast::expr_rec(fields, none),\n-          span: empty_span()}\n+          span: self.empty_span()}\n     }\n \n     fn ty_field_imm(name: ident, ty: @ast::ty) -> ast::ty_field {\n         {node: {ident: name, mt: { ty: ty, mutbl: ast::m_imm } },\n-          span: empty_span()}\n+          span: self.empty_span()}\n     }\n \n     fn ty_rec(+fields: ~[ast::ty_field]) -> @ast::ty {\n         @{id: self.next_id(),\n           node: ast::ty_rec(fields),\n-          span: empty_span()}\n+          span: self.empty_span()}\n     }\n \n     fn ty_infer() -> @ast::ty {\n         @{id: self.next_id(),\n           node: ast::ty_infer,\n-          span: empty_span()}\n+          span: self.empty_span()}\n     }\n \n     fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n@@ -201,7 +202,7 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n                    rules: ast::default_blk};\n \n         {node: blk,\n-         span: empty_span()}\n+         span: self.empty_span()}\n     }\n \n     fn expr_block(e: @ast::expr) -> ast::blk {\n@@ -223,7 +224,7 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n          id: self.next_id(),\n          node: node,\n          vis: ast::public,\n-         span: empty_span()}\n+         span: self.empty_span()}\n     }\n \n     fn item_fn_poly(name: ident,\n@@ -261,12 +262,13 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n                +tys: ~[@ast::ty]) -> ast::variant {\n         let args = tys.map(|ty| {ty: ty, id: self.next_id()});\n \n-        span({name: name,\n-              attrs: ~[],\n-              args: args,\n-              id: self.next_id(),\n-              disr_expr: none,\n-              vis: ast::public})\n+        {node: {name: name,\n+                attrs: ~[],\n+                args: args,\n+                id: self.next_id(),\n+                disr_expr: none,\n+                vis: ast::public},\n+         span: self.empty_span()}\n     }\n \n     fn item_mod(name: ident,\n@@ -281,13 +283,13 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n         // FIXME #2886: make sure the node ids are legal.\n         @{id: self.next_id(),\n           node: ast::ty_path(path, self.next_id()),\n-          span: empty_span()}\n+          span: self.empty_span()}\n     }\n \n     fn ty_nil_ast_builder() -> @ast::ty {\n         @{id: self.next_id(),\n           node: ast::ty_nil,\n-          span: empty_span()}\n+          span: self.empty_span()}\n     }\n \n     fn item_ty_poly(name: ident,\n@@ -301,6 +303,7 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n     }\n \n     fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::ty] {\n-        ty_params.map(|p| self.ty_path_ast_builder(path(p.ident)))\n+        ty_params.map(|p| self.ty_path_ast_builder(\n+            path(p.ident, self.empty_span())))\n     }\n }"}, {"sha": "2988b8eaeb195911c1992f6cd5585785fb4e0a93", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=1dde5e7fc2ed6c1530919a0298bd3691feca3e2f", "patch": "@@ -35,14 +35,14 @@ impl proto_check of proto::visitor<(), (), ()>  for ext_ctxt {\n     fn visit_state(state: state, _m: &[()]) {\n         if state.messages.len() == 0 {\n             self.span_warn(\n-                empty_span(), // use a real span!\n+                state.span, // use a real span!\n                 #fmt(\"state %s contains no messages, \\\n                       consider stepping to a terminal state instead\",\n                      *state.name))\n         }\n     }\n \n-    fn visit_message(name: ident, _tys: &[@ast::ty],\n+    fn visit_message(name: ident, _span: span, _tys: &[@ast::ty],\n                      this: state, next: next_state) {\n         alt next {\n           some({state: next, tys: next_tys}) {\n@@ -51,7 +51,7 @@ impl proto_check of proto::visitor<(), (), ()>  for ext_ctxt {\n                 // This should be a span fatal, but then we need to\n                 // track span information.\n                 self.span_err(\n-                    empty_span(),\n+                    proto.get_state(next).span,\n                     #fmt(\"message %s steps to undefined state, %s\",\n                          *name, *next));\n             }\n@@ -60,7 +60,7 @@ impl proto_check of proto::visitor<(), (), ()>  for ext_ctxt {\n \n                 if next.ty_params.len() != next_tys.len() {\n                     self.span_err(\n-                        empty_span(), // use a real span\n+                        next.span, // use a real span\n                         #fmt(\"message %s target (%s) \\\n                               needs %u type parameters, but got %u\",\n                              *name, *next.name,"}, {"sha": "0375f742b4bd3015231d701fffdff04aeedd5721", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=1dde5e7fc2ed6c1530919a0298bd3691feca3e2f", "patch": "@@ -13,7 +13,7 @@ trait proto_parser {\n \n impl proto_parser of proto_parser for parser {\n     fn parse_proto(id: ident) -> protocol {\n-        let proto = protocol(id);\n+        let proto = protocol(id, self.span);\n \n         self.parse_seq_to_before_end(token::EOF,\n                                      {sep: none, trailing_sep_allowed: false},\n@@ -87,7 +87,7 @@ impl proto_parser of proto_parser for parser {\n           _ { self.fatal(~\"invalid next state\") }\n         };\n \n-        state.add_message(mname, args, next);\n+        state.add_message(mname, copy self.span, args, next);\n \n     }\n }"}, {"sha": "a322409e857dcbec7d3460feeee84afeef8a5c78", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=1dde5e7fc2ed6c1530919a0298bd3691feca3e2f", "patch": "@@ -49,7 +49,7 @@ impl compile of gen_send for message {\n     fn gen_send(cx: ext_ctxt) -> @ast::item {\n         #debug(\"pipec: gen_send\");\n         alt self {\n-          message(id, tys, this, some({state: next, tys: next_tys})) {\n+          message(id, span, tys, this, some({state: next, tys: next_tys})) {\n             #debug(\"pipec: next state exists\");\n             let next = this.proto.get_state(next);\n             assert next_tys.len() == next.ty_params.len();\n@@ -60,7 +60,7 @@ impl compile of gen_send for message {\n             );\n \n             let pipe_ty = cx.ty_path_ast_builder(\n-                path(this.data_name())\n+                path(this.data_name(), span)\n                 .add_tys(cx.ty_vars(this.ty_params)));\n             let args_ast = vec::append(\n                 ~[cx.arg_mode(@~\"pipe\",\n@@ -110,13 +110,13 @@ impl compile of gen_send for message {\n \n             cx.item_fn_poly(self.name(),\n                             args_ast,\n-                            cx.ty_path_ast_builder(path(next.data_name())\n+                            cx.ty_path_ast_builder(path(next.data_name(), span)\n                                       .add_tys(next_tys)),\n                             self.get_params(),\n                             cx.expr_block(body))\n           }\n \n-          message(id, tys, this, none) {\n+          message(id, span, tys, this, none) {\n             #debug(\"pipec: no next state\");\n             let arg_names = tys.mapi(|i, _ty| @(~\"x_\" + i.to_str()));\n \n@@ -126,7 +126,8 @@ impl compile of gen_send for message {\n \n             let args_ast = vec::append(\n                 ~[cx.arg_mode(@~\"pipe\",\n-                              cx.ty_path_ast_builder(path(this.data_name())\n+                              cx.ty_path_ast_builder(path(this.data_name(),\n+                                                          span)\n                                         .add_tys(cx.ty_vars(this.ty_params))),\n                               ast::by_copy)],\n                 args_ast);\n@@ -158,7 +159,7 @@ impl compile of gen_send for message {\n     }\n \n     fn to_ty(cx: ext_ctxt) -> @ast::ty {\n-        cx.ty_path_ast_builder(path(self.name())\n+        cx.ty_path_ast_builder(path(self.name(), self.span())\n           .add_tys(cx.ty_vars(self.get_params())))\n     }\n }\n@@ -177,7 +178,7 @@ impl compile of to_type_decls for state {\n         let mut items_msg = ~[];\n \n         for self.messages.each |m| {\n-            let message(name, tys, this, next) = m;\n+            let message(name, _span, tys, this, next) = m;\n \n             let tys = alt next {\n               some({state: next, tys: next_tys}) {\n@@ -287,7 +288,7 @@ impl compile of gen_init for protocol {\n \n     fn gen_buffer_init(ext_cx: ext_ctxt) -> @ast::expr {\n         ext_cx.rec(self.states.map_to_vec(|s| {\n-            let fty = ext_cx.ty_path_ast_builder(path(s.name));\n+            let fty = ext_cx.ty_path_ast_builder(path(s.name, s.span));\n             ext_cx.field_imm(s.name, #ast { pipes::mk_packet::<$(fty)>() })\n         }))\n     }\n@@ -324,7 +325,7 @@ impl compile of gen_init for protocol {\n             cx.ty_rec(\n                 (copy self.states).map_to_vec(\n                     |s| {\n-                        let ty = cx.ty_path_ast_builder(path(s.name));\n+                        let ty = cx.ty_path_ast_builder(path(s.name, s.span));\n                         let fty = #ast[ty] {\n                             pipes::packet<$(ty)>\n                         };"}, {"sha": "8fe995de09150a24fdbb023ef5655833f16a60e7", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dde5e7fc2ed6c1530919a0298bd3691feca3e2f/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=1dde5e7fc2ed6c1530919a0298bd3691feca3e2f", "patch": "@@ -30,23 +30,31 @@ impl methods for direction {\n type next_state = option<{state: ident, tys: ~[@ast::ty]}>;\n \n enum message {\n-    // name, data, current state, next state\n-    message(ident, ~[@ast::ty], state, next_state)\n+    // name, span, data, current state, next state\n+    message(ident, span, ~[@ast::ty], state, next_state)\n }\n \n impl methods for message {\n     fn name() -> ident {\n         alt self {\n-          message(id, _, _, _) {\n+          message(id, _, _, _, _) {\n             id\n           }\n         }\n     }\n \n+    fn span() -> span {\n+        alt self {\n+          message(_, span, _, _, _) {\n+            span\n+          }\n+        }\n+    }\n+\n     /// Return the type parameters actually used by this message\n     fn get_params() -> ~[ast::ty_param] {\n         alt self {\n-          message(_, _, this, _) {\n+          message(_, _, _, this, _) {\n             this.ty_params\n           }\n         }\n@@ -57,6 +65,7 @@ enum state {\n     state_(@{\n         id: uint,\n         name: ident,\n+        span: span,\n         dir: direction,\n         ty_params: ~[ast::ty_param],\n         messages: dvec<message>,\n@@ -65,8 +74,9 @@ enum state {\n }\n \n impl methods for state {\n-    fn add_message(name: ident, +data: ~[@ast::ty], next: next_state) {\n-        self.messages.push(message(name, data, self,\n+    fn add_message(name: ident, span: span, \n+                   +data: ~[@ast::ty], next: next_state) {\n+        self.messages.push(message(name, span, data, self,\n                                    next));\n     }\n \n@@ -80,15 +90,15 @@ impl methods for state {\n \n     fn to_ty(cx: ext_ctxt) -> @ast::ty {\n         cx.ty_path_ast_builder\n-            (path(self.name).add_tys(cx.ty_vars(self.ty_params)))\n+            (path(self.name, self.span).add_tys(cx.ty_vars(self.ty_params)))\n     }\n \n     /// Iterate over the states that can be reached in one message\n     /// from this state.\n     fn reachable(f: fn(state) -> bool) {\n         for self.messages.each |m| {\n             alt m {\n-              message(_, _, _, some({state: id, _})) {\n+              message(_, _, _, _, some({state: id, _})) {\n                 let state = self.proto.get_state(id);\n                 if !f(state) { break }\n               }\n@@ -100,16 +110,20 @@ impl methods for state {\n \n type protocol = @protocol_;\n \n-fn protocol(name: ident) -> protocol { @protocol_(name) }\n+fn protocol(name: ident, +span: span) -> protocol {\n+    @protocol_(name, span)\n+}\n \n class protocol_ {\n     let name: ident;\n+    let span: span;\n     let states: dvec<state>;\n \n     let mut bounded: option<bool>;\n \n-    new(name: ident) {\n+    new(name: ident, span: span) {\n         self.name = name;\n+        self.span = span;\n         self.states = dvec();\n         self.bounded = none;\n     }\n@@ -141,13 +155,14 @@ class protocol_ {\n     }\n     fn is_bounded() -> bool {\n         let bounded = self.bounded.get();\n-        if bounded && self.has_ty_params() {\n-            #debug(\"protocol %s has is bounded, but type parameters\\\n-                    are not yet supported.\",\n-                   *self.name);\n-            false\n-        }\n-        else { bounded }\n+        bounded\n+        //if bounded && self.has_ty_params() {\n+        //    #debug(\"protocol %s has is bounded, but type parameters\\\n+        //            are not yet supported.\",\n+        //           *self.name);\n+        //    false\n+        //}\n+        //else { bounded }\n     }\n }\n \n@@ -163,6 +178,7 @@ impl methods for protocol {\n         let state = state_(@{\n             id: self.states.len(),\n             name: name,\n+            span: self.span,\n             dir: dir,\n             ty_params: ty_params,\n             messages: messages,\n@@ -177,7 +193,7 @@ impl methods for protocol {\n trait visitor<Tproto, Tstate, Tmessage> {\n     fn visit_proto(proto: protocol, st: &[Tstate]) -> Tproto;\n     fn visit_state(state: state, m: &[Tmessage]) -> Tstate;\n-    fn visit_message(name: ident, tys: &[@ast::ty],\n+    fn visit_message(name: ident, spane: span, tys: &[@ast::ty],\n                      this: state, next: next_state) -> Tmessage;\n }\n \n@@ -187,8 +203,8 @@ fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n     // the copy keywords prevent recursive use of dvec\n     let states = do (copy proto.states).map_to_vec |s| {\n         let messages = do (copy s.messages).map_to_vec |m| {\n-            let message(name, tys, this, next) = m;\n-            visitor.visit_message(name, tys, this, next)\n+            let message(name, span, tys, this, next) = m;\n+            visitor.visit_message(name, span, tys, this, next)\n         };\n         visitor.visit_state(s, messages)\n     };"}]}