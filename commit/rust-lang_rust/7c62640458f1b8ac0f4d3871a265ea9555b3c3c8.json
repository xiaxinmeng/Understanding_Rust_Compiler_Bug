{"sha": "7c62640458f1b8ac0f4d3871a265ea9555b3c3c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNjI2NDA0NThmMWI4YWMwZjRkMzg3MWEyNjVlYTk1NTViM2MzYzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-15T20:16:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-31T13:51:17Z"}, "message": "Refactor unification interface by moving the methods off of inferctxt and onto the\n`UnificationTable`, and renaming/collapsing some methods.", "tree": {"sha": "588a52d76a41243daa0c5b1b8efeebc4203b5b76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/588a52d76a41243daa0c5b1b8efeebc4203b5b76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c62640458f1b8ac0f4d3871a265ea9555b3c3c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c62640458f1b8ac0f4d3871a265ea9555b3c3c8", "html_url": "https://github.com/rust-lang/rust/commit/7c62640458f1b8ac0f4d3871a265ea9555b3c3c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c62640458f1b8ac0f4d3871a265ea9555b3c3c8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b0edb96d080fadccc542dad50e6576c8e11bd85", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b0edb96d080fadccc542dad50e6576c8e11bd85", "html_url": "https://github.com/rust-lang/rust/commit/4b0edb96d080fadccc542dad50e6576c8e11bd85"}], "stats": {"total": 239, "additions": 99, "deletions": 140}, "files": [{"sha": "b3f4537f4728b583227c91970a35abf22a9ba3ad", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7c62640458f1b8ac0f4d3871a265ea9555b3c3c8/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c62640458f1b8ac0f4d3871a265ea9555b3c3c8/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=7c62640458f1b8ac0f4d3871a265ea9555b3c3c8", "patch": "@@ -37,7 +37,6 @@ use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n-use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n use super::{InferCtxt, CombineResult};\n use super::{MiscVariable, TypeTrace};\n use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n@@ -468,30 +467,29 @@ pub fn super_tys<'tcx, C>(this: &C,\n \n         // Relate integral variables to other types\n         (&ty::ty_infer(IntVar(a_id)), &ty::ty_infer(IntVar(b_id))) => {\n-            try!(this.infcx().simple_vars(this.a_is_expected(),\n-                                            a_id, b_id));\n+            try!(this.infcx().int_unification_table\n+                             .borrow_mut()\n+                             .unify_var_var(this.a_is_expected(), a_id, b_id));\n             Ok(a)\n         }\n         (&ty::ty_infer(IntVar(v_id)), &ty::ty_int(v)) => {\n-            unify_integral_variable(this, this.a_is_expected(),\n-                                    v_id, IntType(v))\n+            unify_integral_variable(this, this.a_is_expected(), v_id, IntType(v))\n         }\n         (&ty::ty_int(v), &ty::ty_infer(IntVar(v_id))) => {\n-            unify_integral_variable(this, !this.a_is_expected(),\n-                                    v_id, IntType(v))\n+            unify_integral_variable(this, !this.a_is_expected(), v_id, IntType(v))\n         }\n         (&ty::ty_infer(IntVar(v_id)), &ty::ty_uint(v)) => {\n-            unify_integral_variable(this, this.a_is_expected(),\n-                                    v_id, UintType(v))\n+            unify_integral_variable(this, this.a_is_expected(), v_id, UintType(v))\n         }\n         (&ty::ty_uint(v), &ty::ty_infer(IntVar(v_id))) => {\n-            unify_integral_variable(this, !this.a_is_expected(),\n-                                    v_id, UintType(v))\n+            unify_integral_variable(this, !this.a_is_expected(), v_id, UintType(v))\n         }\n \n         // Relate floating-point variables to other types\n         (&ty::ty_infer(FloatVar(a_id)), &ty::ty_infer(FloatVar(b_id))) => {\n-            try!(this.infcx().simple_vars(this.a_is_expected(), a_id, b_id));\n+            try!(this.infcx().float_unification_table\n+                             .borrow_mut()\n+                             .unify_var_var(this.a_is_expected(), a_id, b_id));\n             Ok(a)\n         }\n         (&ty::ty_infer(FloatVar(v_id)), &ty::ty_float(v)) => {\n@@ -617,8 +615,11 @@ pub fn super_tys<'tcx, C>(this: &C,\n                                         vid: ty::IntVid,\n                                         val: ty::IntVarValue)\n                                         -> CombineResult<'tcx, Ty<'tcx>>\n-                                        where C: Combine<'tcx> {\n-        try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n+        where C: Combine<'tcx>\n+    {\n+        try!(this.infcx().int_unification_table\n+                         .borrow_mut()\n+                         .unify_var_value(vid_is_expected, vid, val));\n         match val {\n             IntType(v) => Ok(ty::mk_mach_int(this.tcx(), v)),\n             UintType(v) => Ok(ty::mk_mach_uint(this.tcx(), v)),\n@@ -630,8 +631,11 @@ pub fn super_tys<'tcx, C>(this: &C,\n                                      vid: ty::FloatVid,\n                                      val: ast::FloatTy)\n                                      -> CombineResult<'tcx, Ty<'tcx>>\n-                                     where C: Combine<'tcx> {\n-        try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n+        where C: Combine<'tcx>\n+    {\n+        try!(this.infcx().float_unification_table\n+                         .borrow_mut()\n+                         .unify_var_value(vid_is_expected, vid, val));\n         Ok(ty::mk_mach_float(this.tcx(), val))\n     }\n }"}, {"sha": "39a0a276b282e0dbefcbd3f62abc85b135a3796f", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7c62640458f1b8ac0f4d3871a265ea9555b3c3c8/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c62640458f1b8ac0f4d3871a265ea9555b3c3c8/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=7c62640458f1b8ac0f4d3871a265ea9555b3c3c8", "patch": "@@ -37,7 +37,6 @@ use middle::ty_fold::TypeFolder;\n use std::collections::hash_map::{self, Entry};\n \n use super::InferCtxt;\n-use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n \n pub struct TypeFreshener<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -104,29 +103,34 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        let tcx = self.infcx.tcx;\n+\n         match t.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n-                self.freshen(self.infcx.type_variables.borrow().probe(v),\n-                               ty::TyVar(v),\n-                               ty::FreshTy)\n+                self.freshen(\n+                    self.infcx.type_variables.borrow().probe(v),\n+                    ty::TyVar(v),\n+                    ty::FreshTy)\n             }\n \n             ty::ty_infer(ty::IntVar(v)) => {\n-                self.freshen(self.infcx.probe_var(v),\n-                             ty::IntVar(v),\n-                             ty::FreshIntTy)\n+                self.freshen(\n+                    self.infcx.int_unification_table.borrow_mut().probe(tcx, v),\n+                    ty::IntVar(v),\n+                    ty::FreshIntTy)\n             }\n \n             ty::ty_infer(ty::FloatVar(v)) => {\n-                self.freshen(self.infcx.probe_var(v),\n-                             ty::FloatVar(v),\n-                             ty::FreshIntTy)\n+                self.freshen(\n+                    self.infcx.float_unification_table.borrow_mut().probe(tcx, v),\n+                    ty::FloatVar(v),\n+                    ty::FreshIntTy)\n             }\n \n             ty::ty_infer(ty::FreshTy(c)) |\n             ty::ty_infer(ty::FreshIntTy(c)) => {\n                 if c >= self.freshen_count {\n-                    self.tcx().sess.bug(\n+                    tcx.sess.bug(\n                         &format!(\"Encountered a freshend type with id {} \\\n                                   but our counter is only at {}\",\n                                  c,"}, {"sha": "faca486e66985ee239c65fac4a94c7301d6eff63", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7c62640458f1b8ac0f4d3871a265ea9555b3c3c8/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c62640458f1b8ac0f4d3871a265ea9555b3c3c8/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=7c62640458f1b8ac0f4d3871a265ea9555b3c3c8", "patch": "@@ -43,7 +43,7 @@ use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::equate::Equate;\n use self::sub::Sub;\n use self::lub::Lub;\n-use self::unify::{UnificationTable, InferCtxtMethodsForSimplyUnifiableTypes};\n+use self::unify::UnificationTable;\n use self::error_reporting::ErrorReporting;\n \n pub mod bivariate;\n@@ -456,14 +456,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         use middle::ty::UnconstrainedNumeric::{Neither, UnconstrainedInt, UnconstrainedFloat};\n         match ty.sty {\n             ty::ty_infer(ty::IntVar(vid)) => {\n-                match self.int_unification_table.borrow_mut().get(self.tcx, vid).value {\n+                match self.int_unification_table.borrow_mut().get(vid).value {\n                     None => UnconstrainedInt,\n                     _ => Neither,\n                 }\n             },\n             ty::ty_infer(ty::FloatVar(vid)) => {\n-                match self.float_unification_table.borrow_mut().get(self.tcx, vid).value {\n-                    None => return UnconstrainedFloat,\n+                match self.float_unification_table.borrow_mut().get(vid).value {\n+                    None => UnconstrainedFloat,\n                     _ => Neither,\n                 }\n             },\n@@ -881,12 +881,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n \n             ty::ty_infer(ty::IntVar(v)) => {\n-                self.probe_var(v)\n+                self.int_unification_table\n+                    .borrow_mut()\n+                    .probe(self.tcx, v)\n                     .unwrap_or(typ)\n             }\n \n             ty::ty_infer(ty::FloatVar(v)) => {\n-                self.probe_var(v)\n+                self.float_unification_table\n+                    .borrow_mut()\n+                    .probe(self.tcx, v)\n                     .unwrap_or(typ)\n             }\n "}, {"sha": "e38d0bb5953ac40af336e67c1cda901782b51df9", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 54, "deletions": 107, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/7c62640458f1b8ac0f4d3871a265ea9555b3c3c8/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c62640458f1b8ac0f4d3871a265ea9555b3c3c8/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=7c62640458f1b8ac0f4d3871a265ea9555b3c3c8", "patch": "@@ -14,9 +14,7 @@ use std::marker;\n \n use middle::ty::{expected_found, IntVarValue};\n use middle::ty::{self, Ty};\n-use middle::infer::UnitResult;\n-use middle::infer::InferCtxt;\n-use std::cell::RefCell;\n+use middle::infer::{UnitResult};\n use std::fmt::Debug;\n use std::marker::PhantomData;\n use syntax::ast;\n@@ -39,11 +37,6 @@ pub trait UnifyKey : Clone + Debug + PartialEq {\n \n     fn from_index(u: usize) -> Self;\n \n-    // Given an inference context, returns the unification table\n-    // appropriate to this key type.\n-    fn unification_table<'v>(infcx: &'v InferCtxt)\n-                             -> &'v RefCell<UnificationTable<Self>>;\n-\n     fn tag(k: Option<Self>) -> &'static str;\n }\n \n@@ -137,14 +130,18 @@ impl<K:UnifyKey> UnificationTable<K> {\n         k\n     }\n \n-    /// Find the root node for `vid`. This uses the standard union-find algorithm with path\n-    /// compression: http://en.wikipedia.org/wiki/Disjoint-set_data_structure\n-    pub fn get(&mut self, tcx: &ty::ctxt, vid: K) -> Node<K> {\n+    /// Find the root node for `vid`. This uses the standard\n+    /// union-find algorithm with path compression:\n+    /// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n+    ///\n+    /// NB. This is a building-block operation and you would probably\n+    /// prefer to call `probe` below.\n+    pub fn get(&mut self, vid: K) -> Node<K> {\n         let index = vid.index();\n         let value = (*self.values.get(index)).clone();\n         match value {\n             Redirect(redirect) => {\n-                let node: Node<K> = self.get(tcx, redirect.clone());\n+                let node: Node<K> = self.get(redirect.clone());\n                 if node.key != redirect {\n                     // Path compression\n                     self.values.set(index, Redirect(node.key.clone()));\n@@ -164,13 +161,9 @@ impl<K:UnifyKey> UnificationTable<K> {\n         }\n     }\n \n-    /// Sets the value for `vid` to `new_value`. `vid` MUST be a root node! Also, we must be in the\n-    /// middle of a snapshot.\n-    pub fn set<'tcx>(&mut self,\n-                     _tcx: &ty::ctxt<'tcx>,\n-                     key: K,\n-                     new_value: VarValue<K>)\n-    {\n+    /// Sets the value for `vid` to `new_value`. `vid` MUST be a root\n+    /// node! This is an internal operation used to impl other things.\n+    fn set(&mut self, key: K, new_value: VarValue<K>) {\n         assert!(self.is_root(&key));\n \n         debug!(\"Updating variable {:?} to {:?}\",\n@@ -179,37 +172,39 @@ impl<K:UnifyKey> UnificationTable<K> {\n         self.values.set(key.index(), new_value);\n     }\n \n-    /// Either redirects node_a to node_b or vice versa, depending on the relative rank. Returns\n-    /// the new root and rank. You should then update the value of the new root to something\n-    /// suitable.\n-    pub fn unify<'tcx>(&mut self,\n-                       tcx: &ty::ctxt<'tcx>,\n-                       node_a: &Node<K>,\n-                       node_b: &Node<K>)\n-                       -> (K, usize)\n-    {\n+    /// Either redirects `node_a` to `node_b` or vice versa, depending\n+    /// on the relative rank. The value associated with the new root\n+    /// will be `new_value`.\n+    ///\n+    /// NB: This is the \"union\" operation of \"union-find\". It is\n+    /// really more of a building block. If the values associated with\n+    /// your key are non-trivial, you would probably prefer to call\n+    /// `unify_var_var` below.\n+    pub fn unify(&mut self, node_a: &Node<K>, node_b: &Node<K>, new_value: K::Value) {\n         debug!(\"unify(node_a(id={:?}, rank={:?}), node_b(id={:?}, rank={:?}))\",\n                node_a.key,\n                node_a.rank,\n                node_b.key,\n                node_b.rank);\n \n-        if node_a.rank > node_b.rank {\n+        let (new_root, new_rank) = if node_a.rank > node_b.rank {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n-            self.set(tcx, node_b.key.clone(), Redirect(node_a.key.clone()));\n+            self.set(node_b.key.clone(), Redirect(node_a.key.clone()));\n             (node_a.key.clone(), node_a.rank)\n         } else if node_a.rank < node_b.rank {\n             // b has greater rank, so a should redirect to b.\n-            self.set(tcx, node_a.key.clone(), Redirect(node_b.key.clone()));\n+            self.set(node_a.key.clone(), Redirect(node_b.key.clone()));\n             (node_b.key.clone(), node_b.rank)\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n             assert_eq!(node_a.rank, node_b.rank);\n-            self.set(tcx, node_b.key.clone(), Redirect(node_a.key.clone()));\n+            self.set(node_b.key.clone(), Redirect(node_a.key.clone()));\n             (node_a.key.clone(), node_a.rank + 1)\n-        }\n+        };\n+\n+        self.set(new_root, Root(new_value, new_rank));\n     }\n }\n \n@@ -223,8 +218,9 @@ impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Code to handle simple keys like ints, floats---anything that\n-// doesn't have a subtyping relationship we need to worry about.\n+// Code to handle keys which carry a value, like ints,\n+// floats---anything that doesn't have a subtyping relationship we\n+// need to worry about.\n \n /// Indicates a type that does not have any kind of subtyping\n /// relationship.\n@@ -246,42 +242,19 @@ pub fn err<'tcx, V:SimplyUnifiable<'tcx>>(a_is_expected: bool,\n     }\n }\n \n-pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V>\n-    where K : UnifyKey<Value=Option<V>>,\n-          V : SimplyUnifiable<'tcx>,\n-          Option<V> : UnifyValue,\n-{\n-    fn simple_vars(&self,\n-                   a_is_expected: bool,\n-                   a_id: K,\n-                   b_id: K)\n-                   -> UnitResult<'tcx>;\n-    fn simple_var_t(&self,\n-                    a_is_expected: bool,\n-                    a_id: K,\n-                    b: V)\n-                    -> UnitResult<'tcx>;\n-    fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>>;\n-}\n-\n-impl<'a,'tcx,V,K> InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V> for InferCtxt<'a,'tcx>\n+impl<'tcx,K,V> UnificationTable<K>\n     where K : UnifyKey<Value=Option<V>>,\n           V : SimplyUnifiable<'tcx>,\n           Option<V> : UnifyValue,\n {\n-    /// Unifies two simple keys. Because simple keys do not have any subtyping relationships, if\n-    /// both keys have already been associated with a value, then those two values must be the\n-    /// same.\n-    fn simple_vars(&self,\n-                   a_is_expected: bool,\n-                   a_id: K,\n-                   b_id: K)\n-                   -> UnitResult<'tcx>\n+    pub fn unify_var_var(&mut self,\n+                         a_is_expected: bool,\n+                         a_id: K,\n+                         b_id: K)\n+                         -> UnitResult<'tcx>\n     {\n-        let tcx = self.tcx;\n-        let table = UnifyKey::unification_table(self);\n-        let node_a: Node<K> = table.borrow_mut().get(tcx, a_id);\n-        let node_b: Node<K> = table.borrow_mut().get(tcx, b_id);\n+        let node_a = self.get(a_id);\n+        let node_b = self.get(b_id);\n         let a_id = node_a.key.clone();\n         let b_id = node_b.key.clone();\n \n@@ -304,46 +277,38 @@ impl<'a,'tcx,V,K> InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V> for InferCtx\n             }\n         };\n \n-        let (new_root, new_rank) = table.borrow_mut().unify(tcx,\n-                                                            &node_a,\n-                                                            &node_b);\n-        table.borrow_mut().set(tcx, new_root, Root(combined, new_rank));\n-        return Ok(())\n+        Ok(self.unify(&node_a, &node_b, combined))\n     }\n \n     /// Sets the value of the key `a_id` to `b`. Because simple keys do not have any subtyping\n     /// relationships, if `a_id` already has a value, it must be the same as `b`.\n-    fn simple_var_t(&self,\n-                    a_is_expected: bool,\n-                    a_id: K,\n-                    b: V)\n-                    -> UnitResult<'tcx>\n+    pub fn unify_var_value(&mut self,\n+                           a_is_expected: bool,\n+                           a_id: K,\n+                           b: V)\n+                           -> UnitResult<'tcx>\n     {\n-        let tcx = self.tcx;\n-        let table = UnifyKey::unification_table(self);\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n+        let node_a = self.get(a_id);\n         let a_id = node_a.key.clone();\n \n         match node_a.value {\n             None => {\n-                table.borrow_mut().set(tcx, a_id, Root(Some(b), node_a.rank));\n-                return Ok(());\n+                self.set(a_id, Root(Some(b), node_a.rank));\n+                Ok(())\n             }\n \n             Some(ref a_t) => {\n                 if *a_t == b {\n-                    return Ok(());\n+                    Ok(())\n                 } else {\n-                    return err(a_is_expected, (*a_t).clone(), b);\n+                    err(a_is_expected, (*a_t).clone(), b)\n                 }\n             }\n         }\n     }\n \n-    fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>> {\n-        let tcx = self.tcx;\n-        let table = UnifyKey::unification_table(self);\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n+    pub fn probe(&mut self, tcx: &ty::ctxt<'tcx>, a_id: K) -> Option<Ty<'tcx>> {\n+        let node_a = self.get(a_id);\n         match node_a.value {\n             None => None,\n             Some(ref a_t) => Some(a_t.to_type(tcx))\n@@ -357,18 +322,9 @@ impl<'a,'tcx,V,K> InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V> for InferCtx\n \n impl UnifyKey for ty::IntVid {\n     type Value = Option<IntVarValue>;\n-\n     fn index(&self) -> usize { self.index as usize }\n-\n     fn from_index(i: usize) -> ty::IntVid { ty::IntVid { index: i as u32 } }\n-\n-    fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::IntVid>> {\n-        return &infcx.int_unification_table;\n-    }\n-\n-    fn tag(_: Option<ty::IntVid>) -> &'static str {\n-        \"IntVid\"\n-    }\n+    fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n }\n \n impl<'tcx> SimplyUnifiable<'tcx> for IntVarValue {\n@@ -390,18 +346,9 @@ impl UnifyValue for Option<IntVarValue> { }\n \n impl UnifyKey for ty::FloatVid {\n     type Value = Option<ast::FloatTy>;\n-\n     fn index(&self) -> usize { self.index as usize }\n-\n     fn from_index(i: usize) -> ty::FloatVid { ty::FloatVid { index: i as u32 } }\n-\n-    fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::FloatVid>> {\n-        return &infcx.float_unification_table;\n-    }\n-\n-    fn tag(_: Option<ty::FloatVid>) -> &'static str {\n-        \"FloatVid\"\n-    }\n+    fn tag(_: Option<ty::FloatVid>) -> &'static str { \"FloatVid\" }\n }\n \n impl UnifyValue for Option<ast::FloatTy> {"}]}