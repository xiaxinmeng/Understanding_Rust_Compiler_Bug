{"sha": "af1b19555ce636788c19dba979b57536792d90e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMWIxOTU1NWNlNjM2Nzg4YzE5ZGJhOTc5YjU3NTM2NzkyZDkwZTk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-11-10T21:00:33Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-11-22T23:50:39Z"}, "message": "Rebasing and review changes", "tree": {"sha": "f9059918dedbaf3e22c775e1ba96c3f8188c9115", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9059918dedbaf3e22c775e1ba96c3f8188c9115"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af1b19555ce636788c19dba979b57536792d90e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af1b19555ce636788c19dba979b57536792d90e9", "html_url": "https://github.com/rust-lang/rust/commit/af1b19555ce636788c19dba979b57536792d90e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af1b19555ce636788c19dba979b57536792d90e9/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baedc3b70ff8ac14a1411b5780112eadd1d63413", "url": "https://api.github.com/repos/rust-lang/rust/commits/baedc3b70ff8ac14a1411b5780112eadd1d63413", "html_url": "https://github.com/rust-lang/rust/commit/baedc3b70ff8ac14a1411b5780112eadd1d63413"}], "stats": {"total": 170, "additions": 126, "deletions": 44}, "files": [{"sha": "653f9852e66da440a5d81542971d213338fb4817", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=af1b19555ce636788c19dba979b57536792d90e9", "patch": "@@ -65,6 +65,18 @@ pub struct CrateSource {\n     pub rmeta: Option<(PathBuf, PathKind)>,\n }\n \n+#[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n+pub enum DepKind {\n+    /// A dependency that is only used for its macros.\n+    MacrosOnly,\n+    /// A dependency that is always injected into the dependency list and so\n+    /// doesn't need to be linked to an rlib, e.g. the injected allocator.\n+    Implicit,\n+    /// A dependency that is required by an rlib version of this crate.\n+    /// Ordinary `extern crate`s result in `Explicit` dependencies.\n+    Explicit,\n+}\n+\n #[derive(PartialEq, Clone, Debug)]\n pub enum LibSource {\n     Some(PathBuf),"}, {"sha": "3dc533d61f0bd801d1673471975659c7cd71e12e", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=af1b19555ce636788c19dba979b57536792d90e9", "patch": "@@ -1634,7 +1634,7 @@ impl fmt::Display for CrateType {\n             CrateTypeStaticlib => \"staticlib\".fmt(f),\n             CrateTypeCdylib => \"cdylib\".fmt(f),\n             CrateTypeProcMacro => \"proc-macro\".fmt(f),\n-            CrateTypeMetadata => \"rmeta\".fmt(f),\n+            CrateTypeMetadata => \"metadata\".fmt(f),\n         }\n     }\n }"}, {"sha": "12a70da636de77fde456e2172b46b1d823ee3102", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=af1b19555ce636788c19dba979b57536792d90e9", "patch": "@@ -67,8 +67,7 @@ fn dump_crates(cstore: &CStore) {\n         dylib.map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n         rlib.map(|rl|  info!(\"   rlib: {}\", rl.0.display()));\n         rmeta.map(|rl| info!(\"   rmeta: {}\", rl.0.display()));\n-        });\n-    })\n+    });\n }\n \n #[derive(Debug)]"}, {"sha": "c2ed7ca7ce047644fb6f1fe5fc5a6fdd3a9f9444", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=af1b19555ce636788c19dba979b57536792d90e9", "patch": "@@ -43,6 +43,7 @@ pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n pub enum MetadataBlob {\n     Inflated(Bytes),\n     Archive(locator::ArchiveMetadata),\n+    Raw(Vec<u8>),\n }\n \n /// Holds information about a syntax_pos::FileMap imported from another crate.\n@@ -203,7 +204,7 @@ impl CStore {\n                 let path = match path {\n                     Some(p) => LibSource::Some(p),\n                     None => {\n-                        if data.rmeta.is_some() {\n+                        if data.source.rmeta.is_some() {\n                             LibSource::MetadataOnly\n                         } else {\n                             LibSource::None"}, {"sha": "3ba899f41d8c4360f558181a7fbf4dbe7ea38693", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=af1b19555ce636788c19dba979b57536792d90e9", "patch": "@@ -88,8 +88,9 @@ pub trait Metadata<'a, 'tcx>: Copy {\n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n     fn raw_bytes(self) -> &'a [u8] {\n         match *self {\n-            MetadataBlob::Inflated(ref vec) => &vec[..],\n+            MetadataBlob::Inflated(ref vec) => vec,\n             MetadataBlob::Archive(ref ar) => ar.as_slice(),\n+            MetadataBlob::Raw(ref vec) => vec,\n         }\n     }\n }"}, {"sha": "2b06851cb8bdb1626def4dbc6bb1bf8234ee9168", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=af1b19555ce636788c19dba979b57536792d90e9", "patch": "@@ -53,8 +53,8 @@\n //! is a platform-defined dynamic library. Each library has a metadata somewhere\n //! inside of it.\n //!\n-//! A third kind of dependency is an rmeta file. These are rlibs, which contain\n-//! metadata, but no code. To a first approximation, these are treated in the\n+//! A third kind of dependency is an rmeta file. These are metadata files and do\n+//! not contain any code, etc. To a first approximation, these are treated in the\n //! same way as rlibs. Where there is both an rlib and an rmeta file, the rlib\n //! gets priority (even if the rmeta file is newer). An rmeta file is only\n //! useful for checking a downstream crate, attempting to link one will cause an\n@@ -239,8 +239,8 @@ use rustc_back::target::Target;\n \n use std::cmp;\n use std::fmt;\n-use std::fs;\n-use std::io;\n+use std::fs::{self, File};\n+use std::io::{self, Read};\n use std::path::{Path, PathBuf};\n use std::ptr;\n use std::slice;\n@@ -462,22 +462,23 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, found_kind) = if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rlib\") {\n-                (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], CrateFlavor::Rlib)\n-            } else if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rmeta\") {\n-                (&file[(rlib_prefix.len())..(file.len() - \".rmeta\".len())], CrateFlavor::Rmeta)\n-            } else if file.starts_with(&dylib_prefix) &&\n-                                         file.ends_with(&dypair.1) {\n-                (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], CrateFlavor::Dylib)\n-            } else {\n-                if file.starts_with(&staticlib_prefix[..]) && file.ends_with(&staticpair.1) {\n-                    staticlibs.push(CrateMismatch {\n-                        path: path.to_path_buf(),\n-                        got: \"static\".to_string(),\n-                    });\n-                }\n-                return FileDoesntMatch;\n-            };\n+            let (hash, found_kind) =\n+                if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rlib\") {\n+                    (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], CrateFlavor::Rlib)\n+                } else if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rmeta\") {\n+                    (&file[(rlib_prefix.len())..(file.len() - \".rmeta\".len())], CrateFlavor::Rmeta)\n+                } else if file.starts_with(&dylib_prefix) &&\n+                                             file.ends_with(&dypair.1) {\n+                    (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], CrateFlavor::Dylib)\n+                } else {\n+                    if file.starts_with(&staticlib_prefix[..]) && file.ends_with(&staticpair.1) {\n+                        staticlibs.push(CrateMismatch {\n+                            path: path.to_path_buf(),\n+                            got: \"static\".to_string(),\n+                        });\n+                    }\n+                    return FileDoesntMatch;\n+                };\n             info!(\"lib candidate: {}\", path.display());\n \n             let hash_str = hash.to_string();\n@@ -731,7 +732,8 @@ impl<'a> Context<'a> {\n                         return false;\n                     }\n                 };\n-                if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n+                if file.starts_with(\"lib\") &&\n+                   (file.ends_with(\".rlib\") || file.ends_with(\".rmeta\")) {\n                     return true;\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n@@ -846,7 +848,7 @@ fn get_metadata_section_imp(target: &Target,\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n     }\n-    if flavor == CrateFlavor::Rlib || flavor == CrateFlavor::Rmeta {\n+    if flavor == CrateFlavor::Rlib {\n         // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n         // internally to read the file. We also avoid even using a memcpy by\n         // just keeping the archive along while the metadata is in use.\n@@ -864,6 +866,15 @@ fn get_metadata_section_imp(target: &Target,\n                 Ok(blob)\n             }\n         };\n+    } else if flavor == CrateFlavor::Rmeta {\n+        let mut file = File::open(filename).map_err(|_|\n+            format!(\"could not open file: '{}'\", filename.display()))?;\n+        let mut buf = vec![];\n+        file.read_to_end(&mut buf).map_err(|_|\n+            format!(\"failed to read rlib metadata: '{}'\", filename.display()))?;\n+        let blob = MetadataBlob::Raw(buf);\n+        verify_decompressed_encoding_version(&blob, filename)?;\n+        return Ok(blob);\n     }\n     unsafe {\n         let buf = common::path2cstr(filename);"}, {"sha": "40c2de7b88974022e038945be64526fdd9083d78", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=af1b19555ce636788c19dba979b57536792d90e9", "patch": "@@ -190,7 +190,6 @@ pub fn link_binary(sess: &Session,\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n         // Ignore executable crates if we have -Z no-trans, as they will error.\n-        // TODO do we need to check for CrateTypeMetadata here?\n         if sess.opts.debugging_opts.no_trans &&\n            crate_type == config::CrateTypeExecutable {\n             continue;\n@@ -312,7 +311,8 @@ pub fn each_linked_rlib(sess: &Session,\n         let path = match path {\n             LibSource::Some(p) => p,\n             LibSource::MetadataOnly => {\n-                sess.fatal(&format!(\"could not find rlib for: `{}`, found rmeta (metadata) file\", name));\n+                sess.fatal(&format!(\"could not find rlib for: `{}`, found rmeta (metadata) file\",\n+                                    name));\n             }\n             LibSource::None => {\n                 sess.fatal(&format!(\"could not find rlib for: `{}`\", name));\n@@ -351,13 +351,16 @@ fn link_binary_output(sess: &Session,\n     };\n \n     match crate_type {\n-        config::CrateTypeRlib | config::CrateTypeMetadata => {\n+        config::CrateTypeRlib => {\n             link_rlib(sess, Some(trans), &objects, &out_filename,\n                       tmpdir.path()).build();\n         }\n         config::CrateTypeStaticlib => {\n             link_staticlib(sess, &objects, &out_filename, tmpdir.path());\n         }\n+        config::CrateTypeMetadata => {\n+            emit_metadata(sess, trans, &out_filename);\n+        }\n         _ => {\n             link_natively(sess, crate_type, &objects, &out_filename, trans,\n                           outputs, tmpdir.path());\n@@ -396,6 +399,13 @@ fn archive_config<'a>(sess: &'a Session,\n     }\n }\n \n+fn emit_metadata<'a>(sess: &'a Session, trans: &CrateTranslation, out_filename: &Path) {\n+    let result = fs::File::create(out_filename).and_then(|mut f| f.write_all(&trans.metadata));\n+    if let Err(e) = result {\n+        sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+    }\n+}\n+\n // Create an 'rlib'\n //\n // An rlib in its current incarnation is essentially a renamed .a file. The\n@@ -471,15 +481,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // here so concurrent builds in the same directory don't try to use\n             // the same filename for metadata (stomping over one another)\n             let metadata = tmpdir.join(sess.cstore.metadata_filename());\n-            match fs::File::create(&metadata).and_then(|mut f| {\n-                f.write_all(&trans.metadata)\n-            }) {\n-                Ok(..) => {}\n-                Err(e) => {\n-                    sess.fatal(&format!(\"failed to write {}: {}\",\n-                                        metadata.display(), e));\n-                }\n-            }\n+            emit_metadata(sess, trans, &metadata);\n             ab.add_file(&metadata);\n \n             // For LTO purposes, the bytecode of this library is also inserted"}, {"sha": "01eea08c50bc589dab4d36dba16eefc5e715c08e", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1b19555ce636788c19dba979b57536792d90e9/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=af1b19555ce636788c19dba979b57536792d90e9", "patch": "@@ -691,12 +691,10 @@ pub fn run_passes(sess: &Session,\n     // Whenever an rlib is created, the bitcode is inserted into the\n     // archive in order to allow LTO against it.\n     let needs_crate_bitcode =\n-            (sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n-             sess.opts.output_types.contains_key(&OutputType::Exe)) ||\n-            sess.crate_types.borrow().contains(&config::CrateTypeMetadata);\n+            sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n+            sess.opts.output_types.contains_key(&OutputType::Exe);\n     let needs_crate_object =\n-            sess.opts.output_types.contains_key(&OutputType::Exe) ||\n-            sess.crate_types.borrow().contains(&config::CrateTypeMetadata);\n+            sess.opts.output_types.contains_key(&OutputType::Exe);\n     if needs_crate_bitcode {\n         modules_config.emit_bc = true;\n     }"}, {"sha": "28c11315fa1cd2f247350109e8695ddefdf82b27", "filename": "src/test/run-pass/auxiliary/rmeta_rlib.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af1b19555ce636788c19dba979b57536792d90e9/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1b19555ce636788c19dba979b57536792d90e9/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rlib.rs?ref=af1b19555ce636788c19dba979b57536792d90e9", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type=\"rlib\"]\n+#![crate_name=\"rmeta_aux\"]\n+\n+pub struct Foo {\n+    pub field: i32,\n+}"}, {"sha": "394845b66f3d3a105694589464d879349d60096a", "filename": "src/test/run-pass/auxiliary/rmeta_rmeta.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af1b19555ce636788c19dba979b57536792d90e9/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rmeta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1b19555ce636788c19dba979b57536792d90e9/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rmeta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rmeta.rs?ref=af1b19555ce636788c19dba979b57536792d90e9", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type=\"metadata\"]\n+#![crate_name=\"rmeta_aux\"]\n+\n+pub struct Foo {\n+    pub field2: i32,\n+}"}, {"sha": "11684d8663af8ee9c75f3e21081c50b665ed5a16", "filename": "src/test/run-pass/rmeta.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af1b19555ce636788c19dba979b57536792d90e9/src%2Ftest%2Frun-pass%2Frmeta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af1b19555ce636788c19dba979b57536792d90e9/src%2Ftest%2Frun-pass%2Frmeta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frmeta.rs?ref=af1b19555ce636788c19dba979b57536792d90e9", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that using rlibs and rmeta dep crates work together. Specifically, that\n+// there can be both an rmeta and an rlib file and rustc will prefer the rlib.\n+\n+// aux-build:rmeta_rmeta.rs\n+// aux-build:rmeta_rlib.rs\n+\n+extern crate rmeta_aux;\n+use rmeta_aux::Foo;\n+\n+pub fn main() {\n+    let _ = Foo { field: 42 };\n+}"}]}