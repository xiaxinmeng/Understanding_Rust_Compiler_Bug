{"sha": "2111aed0a38c819acb140c7153e9366964a37f2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMTFhZWQwYTM4YzgxOWFjYjE0MGM3MTUzZTkzNjY5NjRhMzdmMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-17T17:53:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-17T17:53:31Z"}, "message": "Auto merge of #63658 - RalfJung:miri-op, r=oli-obk\n\nRefactor Miri ops (unary, binary) to have more types\n\nThis is the part of https://github.com/rust-lang/rust/pull/63448 that is just a refactoring. It helps that PR by making it easier to perform machine arithmetic.\n\nr? @oli-obk @eddyb", "tree": {"sha": "a28b93149e7d78f7b903a4f2bc98b9d2cad7fef7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a28b93149e7d78f7b903a4f2bc98b9d2cad7fef7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2111aed0a38c819acb140c7153e9366964a37f2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2111aed0a38c819acb140c7153e9366964a37f2f", "html_url": "https://github.com/rust-lang/rust/commit/2111aed0a38c819acb140c7153e9366964a37f2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2111aed0a38c819acb140c7153e9366964a37f2f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d65e272a9fe3e61aa5f229c5358e35a909435575", "url": "https://api.github.com/repos/rust-lang/rust/commits/d65e272a9fe3e61aa5f229c5358e35a909435575", "html_url": "https://github.com/rust-lang/rust/commit/d65e272a9fe3e61aa5f229c5358e35a909435575"}, {"sha": "5ac2045d1eb3f32157928ade47fbed5ea10c8e91", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ac2045d1eb3f32157928ade47fbed5ea10c8e91", "html_url": "https://github.com/rust-lang/rust/commit/5ac2045d1eb3f32157928ade47fbed5ea10c8e91"}], "stats": {"total": 204, "additions": 112, "deletions": 92}, "files": [{"sha": "76ee76a74562bf6e6efd19a84892108bd8d098e5", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=2111aed0a38c819acb140c7153e9366964a37f2f", "patch": "@@ -11,9 +11,8 @@ use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, subst::Subst};\n use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n-use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc_data_structures::fx::FxHashMap;\n \n@@ -415,7 +414,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _bin_op: mir::BinOp,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n         Err(\n             ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),\n         )"}, {"sha": "4c86c53256e9b67ca7a3d41fc9040a3d9cf84a35", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=2111aed0a38c819acb140c7153e9366964a37f2f", "patch": "@@ -137,7 +137,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let l = self.read_immediate(args[0])?;\n                 let r = self.read_immediate(args[1])?;\n                 let is_add = intrinsic_name == \"saturating_add\";\n-                let (val, overflowed) = self.binary_op(if is_add {\n+                let (val, overflowed, _ty) = self.overflowing_binary_op(if is_add {\n                     BinOp::Add\n                 } else {\n                     BinOp::Sub\n@@ -184,7 +184,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     \"unchecked_shr\" => BinOp::Shr,\n                     _ => bug!(\"Already checked for int ops\")\n                 };\n-                let (val, overflowed) = self.binary_op(bin_op, l, r)?;\n+                let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, l, r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val = r.to_scalar()?.to_bits(layout.size)?;"}, {"sha": "bb74a50156e564f6c4470aab31412ffa0437adba", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=2111aed0a38c819acb140c7153e9366964a37f2f", "patch": "@@ -7,7 +7,7 @@ use std::hash::Hash;\n \n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt};\n \n use super::{\n     Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n@@ -176,7 +176,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Self::PointerTag>,\n         right: ImmTy<'tcx, Self::PointerTag>,\n-    ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n+    ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool, Ty<'tcx>)>;\n \n     /// Heap allocations via the `box` keyword.\n     fn box_alloc("}, {"sha": "726ae6fab100918158c55acf22be556c41b44bac", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=2111aed0a38c819acb140c7153e9366964a37f2f", "patch": "@@ -108,7 +108,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag=()> {\n-    pub imm: Immediate<Tag>,\n+    pub(crate) imm: Immediate<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -155,7 +155,7 @@ impl<Tag> Operand<Tag> {\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct OpTy<'tcx, Tag=()> {\n-    op: Operand<Tag>,\n+    op: Operand<Tag>, // Keep this private, it helps enforce invariants\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -187,13 +187,22 @@ impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     }\n }\n \n-impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n-{\n+impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n     #[inline]\n     pub fn from_scalar(val: Scalar<Tag>, layout: TyLayout<'tcx>) -> Self {\n         ImmTy { imm: val.into(), layout }\n     }\n \n+    #[inline]\n+    pub fn from_uint(i: impl Into<u128>, layout: TyLayout<'tcx>) -> Self {\n+        Self::from_scalar(Scalar::from_uint(i, layout.size), layout)\n+    }\n+\n+    #[inline]\n+    pub fn from_int(i: impl Into<i128>, layout: TyLayout<'tcx>) -> Self {\n+        Self::from_scalar(Scalar::from_int(i, layout.size), layout)\n+    }\n+\n     #[inline]\n     pub fn to_bits(self) -> InterpResult<'tcx, u128> {\n         self.to_scalar()?.to_bits(self.layout.size)"}, {"sha": "470cc9346ee21407593440891d21eecdbef0a108", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 74, "deletions": 49, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=2111aed0a38c819acb140c7153e9366964a37f2f", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir;\n-use rustc::ty::{self, layout::TyLayout};\n+use rustc::ty::{self, Ty, layout::{TyLayout, LayoutOf}};\n use syntax::ast::FloatTy;\n use rustc_apfloat::Float;\n use rustc::mir::interpret::{InterpResult, Scalar};\n@@ -17,7 +17,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        let (val, overflowed) = self.binary_op(op, left, right)?;\n+        let (val, overflowed, ty) = self.overflowing_binary_op(op, left, right)?;\n+        debug_assert_eq!(\n+            self.tcx.intern_tup(&[ty, self.tcx.types.bool]),\n+            dest.layout.ty,\n+            \"type mismatch for result of {:?}\", op,\n+        );\n         let val = Immediate::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n         self.write_immediate(val, dest)\n     }\n@@ -31,7 +36,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        let (val, _overflowed) = self.binary_op(op, left, right)?;\n+        let (val, _overflowed, ty) = self.overflowing_binary_op(op, left, right)?;\n+        assert_eq!(ty, dest.layout.ty, \"type mismatch for result of {:?}\", op);\n         self.write_scalar(val, dest)\n     }\n }\n@@ -42,7 +48,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         bin_op: mir::BinOp,\n         l: char,\n         r: char,\n-    ) -> (Scalar<M::PointerTag>, bool) {\n+    ) -> (Scalar<M::PointerTag>, bool, Ty<'tcx>) {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -54,15 +60,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Ge => l >= r,\n             _ => bug!(\"Invalid operation on char: {:?}\", bin_op),\n         };\n-        return (Scalar::from_bool(res), false);\n+        return (Scalar::from_bool(res), false, self.tcx.types.bool);\n     }\n \n     fn binary_bool_op(\n         &self,\n         bin_op: mir::BinOp,\n         l: bool,\n         r: bool,\n-    ) -> (Scalar<M::PointerTag>, bool) {\n+    ) -> (Scalar<M::PointerTag>, bool, Ty<'tcx>) {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -77,32 +83,33 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             BitXor => l ^ r,\n             _ => bug!(\"Invalid operation on bool: {:?}\", bin_op),\n         };\n-        return (Scalar::from_bool(res), false);\n+        return (Scalar::from_bool(res), false, self.tcx.types.bool);\n     }\n \n     fn binary_float_op<F: Float + Into<Scalar<M::PointerTag>>>(\n         &self,\n         bin_op: mir::BinOp,\n+        ty: Ty<'tcx>,\n         l: F,\n         r: F,\n-    ) -> (Scalar<M::PointerTag>, bool) {\n+    ) -> (Scalar<M::PointerTag>, bool, Ty<'tcx>) {\n         use rustc::mir::BinOp::*;\n \n-        let val = match bin_op {\n-            Eq => Scalar::from_bool(l == r),\n-            Ne => Scalar::from_bool(l != r),\n-            Lt => Scalar::from_bool(l < r),\n-            Le => Scalar::from_bool(l <= r),\n-            Gt => Scalar::from_bool(l > r),\n-            Ge => Scalar::from_bool(l >= r),\n-            Add => (l + r).value.into(),\n-            Sub => (l - r).value.into(),\n-            Mul => (l * r).value.into(),\n-            Div => (l / r).value.into(),\n-            Rem => (l % r).value.into(),\n+        let (val, ty) = match bin_op {\n+            Eq => (Scalar::from_bool(l == r), self.tcx.types.bool),\n+            Ne => (Scalar::from_bool(l != r), self.tcx.types.bool),\n+            Lt => (Scalar::from_bool(l < r), self.tcx.types.bool),\n+            Le => (Scalar::from_bool(l <= r), self.tcx.types.bool),\n+            Gt => (Scalar::from_bool(l > r), self.tcx.types.bool),\n+            Ge => (Scalar::from_bool(l >= r), self.tcx.types.bool),\n+            Add => ((l + r).value.into(), ty),\n+            Sub => ((l - r).value.into(), ty),\n+            Mul => ((l * r).value.into(), ty),\n+            Div => ((l / r).value.into(), ty),\n+            Rem => ((l % r).value.into(), ty),\n             _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n         };\n-        return (val, false);\n+        return (val, false, ty);\n     }\n \n     fn binary_int_op(\n@@ -113,7 +120,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         left_layout: TyLayout<'tcx>,\n         r: u128,\n         right_layout: TyLayout<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n         use rustc::mir::BinOp::*;\n \n         // Shift ops can have an RHS with a different numeric type.\n@@ -142,7 +149,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             };\n             let truncated = self.truncate(result, left_layout);\n-            return Ok((Scalar::from_uint(truncated, size), oflo));\n+            return Ok((Scalar::from_uint(truncated, size), oflo, left_layout.ty));\n         }\n \n         // For the remaining ops, the types must be the same on both sides\n@@ -167,7 +174,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             if let Some(op) = op {\n                 let l = self.sign_extend(l, left_layout) as i128;\n                 let r = self.sign_extend(r, right_layout) as i128;\n-                return Ok((Scalar::from_bool(op(&l, &r)), false));\n+                return Ok((Scalar::from_bool(op(&l, &r)), false, self.tcx.types.bool));\n             }\n             let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n                 Div if r == 0 => throw_panic!(DivisionByZero),\n@@ -187,7 +194,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Rem | Div => {\n                         // int_min / -1\n                         if r == -1 && l == (1 << (size.bits() - 1)) {\n-                            return Ok((Scalar::from_uint(l, size), true));\n+                            return Ok((Scalar::from_uint(l, size), true, left_layout.ty));\n                         }\n                     },\n                     _ => {},\n@@ -202,25 +209,24 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // this may be out-of-bounds for the result type, so we have to truncate ourselves\n                 let result = result as u128;\n                 let truncated = self.truncate(result, left_layout);\n-                return Ok((Scalar::from_uint(truncated, size), oflo));\n+                return Ok((Scalar::from_uint(truncated, size), oflo, left_layout.ty));\n             }\n         }\n \n         let size = left_layout.size;\n \n-        // only ints left\n-        let val = match bin_op {\n-            Eq => Scalar::from_bool(l == r),\n-            Ne => Scalar::from_bool(l != r),\n+        let (val, ty) = match bin_op {\n+            Eq => (Scalar::from_bool(l == r), self.tcx.types.bool),\n+            Ne => (Scalar::from_bool(l != r), self.tcx.types.bool),\n \n-            Lt => Scalar::from_bool(l < r),\n-            Le => Scalar::from_bool(l <= r),\n-            Gt => Scalar::from_bool(l > r),\n-            Ge => Scalar::from_bool(l >= r),\n+            Lt => (Scalar::from_bool(l < r), self.tcx.types.bool),\n+            Le => (Scalar::from_bool(l <= r), self.tcx.types.bool),\n+            Gt => (Scalar::from_bool(l > r), self.tcx.types.bool),\n+            Ge => (Scalar::from_bool(l >= r), self.tcx.types.bool),\n \n-            BitOr => Scalar::from_uint(l | r, size),\n-            BitAnd => Scalar::from_uint(l & r, size),\n-            BitXor => Scalar::from_uint(l ^ r, size),\n+            BitOr => (Scalar::from_uint(l | r, size), left_layout.ty),\n+            BitAnd => (Scalar::from_uint(l & r, size), left_layout.ty),\n+            BitXor => (Scalar::from_uint(l ^ r, size), left_layout.ty),\n \n             Add | Sub | Mul | Rem | Div => {\n                 debug_assert!(!left_layout.abi.is_signed());\n@@ -236,7 +242,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let (result, oflo) = op(l, r);\n                 let truncated = self.truncate(result, left_layout);\n-                return Ok((Scalar::from_uint(truncated, size), oflo || truncated != result));\n+                return Ok((\n+                    Scalar::from_uint(truncated, size),\n+                    oflo || truncated != result,\n+                    left_layout.ty,\n+                ));\n             }\n \n             _ => {\n@@ -250,17 +260,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         };\n \n-        Ok((val, false))\n+        Ok((val, false, ty))\n     }\n \n-    /// Returns the result of the specified operation and whether it overflowed.\n-    #[inline]\n-    pub fn binary_op(\n+    /// Returns the result of the specified operation, whether it overflowed, and\n+    /// the result type.\n+    pub fn overflowing_binary_op(\n         &self,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, M::PointerTag>,\n         right: ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n             bin_op, *left, left.layout.ty, *right, right.layout.ty);\n \n@@ -279,11 +289,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             ty::Float(fty) => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n+                let ty = left.layout.ty;\n                 let left = left.to_scalar()?;\n                 let right = right.to_scalar()?;\n                 Ok(match fty {\n-                    FloatTy::F32 => self.binary_float_op(bin_op, left.to_f32()?, right.to_f32()?),\n-                    FloatTy::F64 => self.binary_float_op(bin_op, left.to_f64()?, right.to_f64()?),\n+                    FloatTy::F32 =>\n+                        self.binary_float_op(bin_op, ty, left.to_f32()?, right.to_f32()?),\n+                    FloatTy::F64 =>\n+                        self.binary_float_op(bin_op, ty, left.to_f64()?, right.to_f64()?),\n                 })\n             }\n             _ if left.layout.ty.is_integral() => {\n@@ -312,11 +325,23 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// Typed version of `checked_binary_op`, returning an `ImmTy`. Also ignores overflows.\n+    #[inline]\n+    pub fn binary_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: ImmTy<'tcx, M::PointerTag>,\n+        right: ImmTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n+        let (val, _overflow, ty) = self.overflowing_binary_op(bin_op, left, right)?;\n+        Ok(ImmTy::from_scalar(val, self.layout_of(ty)?))\n+    }\n+\n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n         val: ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         use rustc::mir::UnOp::*;\n \n         let layout = val.layout;\n@@ -330,15 +355,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Not => !val,\n                     _ => bug!(\"Invalid bool op {:?}\", un_op)\n                 };\n-                Ok(Scalar::from_bool(res))\n+                Ok(ImmTy::from_scalar(Scalar::from_bool(res), self.layout_of(self.tcx.types.bool)?))\n             }\n             ty::Float(fty) => {\n                 let res = match (un_op, fty) {\n                     (Neg, FloatTy::F32) => Scalar::from_f32(-val.to_f32()?),\n                     (Neg, FloatTy::F64) => Scalar::from_f64(-val.to_f64()?),\n                     _ => bug!(\"Invalid float op {:?}\", un_op)\n                 };\n-                Ok(res)\n+                Ok(ImmTy::from_scalar(res, layout))\n             }\n             _ => {\n                 assert!(layout.ty.is_integral());\n@@ -351,7 +376,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 };\n                 // res needs tuncating\n-                Ok(Scalar::from_uint(self.truncate(res, layout), layout.size))\n+                Ok(ImmTy::from_uint(self.truncate(res, layout), layout))\n             }\n         }\n     }"}, {"sha": "ef9f20d5c9724ac84e8d958285745d6e833d9e4b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=2111aed0a38c819acb140c7153e9366964a37f2f", "patch": "@@ -45,7 +45,7 @@ pub enum Place<Tag=(), Id=AllocId> {\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx, Tag=()> {\n-    place: Place<Tag>,\n+    place: Place<Tag>, // Keep this private, it helps enforce invariants\n     pub layout: TyLayout<'tcx>,\n }\n "}, {"sha": "b010bf049dd244d93ed53b6dd7bf666a9a8f688a", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=2111aed0a38c819acb140c7153e9366964a37f2f", "patch": "@@ -177,7 +177,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The operand always has the same type as the result.\n                 let val = self.read_immediate(self.eval_operand(operand, Some(dest.layout))?)?;\n                 let val = self.unary_op(un_op, val)?;\n-                self.write_scalar(val, dest)?;\n+                assert_eq!(val.layout, dest.layout, \"layout mismatch for result of {:?}\", un_op);\n+                self.write_immediate(*val, dest)?;\n             }\n \n             Aggregate(ref kind, ref operands) => {"}, {"sha": "5de297923ce7bfa4e7060328939acd040d3123c6", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=2111aed0a38c819acb140c7153e9366964a37f2f", "patch": "@@ -7,7 +7,7 @@ use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n use super::{\n-    InterpResult, PointerArithmetic, Scalar,\n+    InterpResult, PointerArithmetic,\n     InterpCx, Machine, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n };\n \n@@ -50,11 +50,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 for (index, &const_int) in values.iter().enumerate() {\n                     // Compare using binary_op, to also support pointer values\n-                    let const_int = Scalar::from_uint(const_int, discr.layout.size);\n-                    let (res, _) = self.binary_op(mir::BinOp::Eq,\n+                    let res = self.overflowing_binary_op(mir::BinOp::Eq,\n                         discr,\n-                        ImmTy::from_scalar(const_int, discr.layout),\n-                    )?;\n+                        ImmTy::from_uint(const_int, discr.layout),\n+                    )?.0;\n                     if res.to_bool()? {\n                         target_block = targets[index];\n                         break;"}, {"sha": "98d8ca58ee1647d671f0baf1305f71cf17153167", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2111aed0a38c819acb140c7153e9366964a37f2f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=2111aed0a38c819acb140c7153e9366964a37f2f", "patch": "@@ -19,7 +19,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use rustc::ty::subst::InternalSubsts;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::ty::layout::{\n-    LayoutOf, TyLayout, LayoutError, HasTyCtxt, TargetDataLayout, HasDataLayout, Size,\n+    LayoutOf, TyLayout, LayoutError, HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n use crate::interpret::{\n@@ -396,30 +396,21 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 if let ty::Slice(_) = mplace.layout.ty.sty {\n                     let len = mplace.meta.unwrap().to_usize(&self.ecx).unwrap();\n \n-                    Some(ImmTy {\n-                        imm: Immediate::Scalar(\n-                            Scalar::from_uint(\n-                                len,\n-                                Size::from_bits(\n-                                    self.tcx.sess.target.usize_ty.bit_width().unwrap() as u64\n-                                )\n-                            ).into(),\n-                        ),\n-                        layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    }.into())\n+                    Some(ImmTy::from_uint(\n+                        len,\n+                        self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n+                    ).into())\n                 } else {\n                     trace!(\"not slice: {:?}\", mplace.layout.ty.sty);\n                     None\n                 }\n             },\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some(\n-                    ImmTy {\n-                        imm: Immediate::Scalar(\n-                            Scalar::from_uint(n, self.tcx.data_layout.pointer_size).into()\n-                        ),\n-                        layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    }.into()\n+                    ImmTy::from_uint(\n+                        n,\n+                        self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n+                    ).into()\n                 ))\n             }\n             Rvalue::UnaryOp(op, ref arg) => {\n@@ -452,11 +443,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     // Now run the actual operation.\n                     this.ecx.unary_op(op, prim)\n                 })?;\n-                let res = ImmTy {\n-                    imm: Immediate::Scalar(val.into()),\n-                    layout: place_layout,\n-                };\n-                Some(res.into())\n+                Some(val.into())\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -510,8 +497,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     this.ecx.read_immediate(left)\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n-                let (val, overflow) = self.use_ecx(source_info, |this| {\n-                    this.ecx.binary_op(op, l, r)\n+                let (val, overflow, _ty) = self.use_ecx(source_info, |this| {\n+                    this.ecx.overflowing_binary_op(op, l, r)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Immediate::ScalarPair("}]}