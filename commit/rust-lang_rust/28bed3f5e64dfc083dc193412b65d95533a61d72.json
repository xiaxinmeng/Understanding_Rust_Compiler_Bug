{"sha": "28bed3f5e64dfc083dc193412b65d95533a61d72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YmVkM2Y1ZTY0ZGZjMDgzZGMxOTM0MTJiNjVkOTU1MzNhNjFkNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-01T14:26:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-01T14:26:48Z"}, "message": "Auto merge of #31317 - jseyfried:remove_external_module_children, r=nrc\n\nThis PR refactors away `Module`'s `external_module_children` and instead puts `extern crate` declarations in `children` like other items, simplifying duplicate checking and name resolution.\n\nThis PR also allows values to share a name with extern crates, which are only defined in the type namespace. Other than that, it is a pure refactoring.\n\nr? @nrc", "tree": {"sha": "3760ff72438cb69773b00e53b4b82033c9b71300", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3760ff72438cb69773b00e53b4b82033c9b71300"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28bed3f5e64dfc083dc193412b65d95533a61d72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28bed3f5e64dfc083dc193412b65d95533a61d72", "html_url": "https://github.com/rust-lang/rust/commit/28bed3f5e64dfc083dc193412b65d95533a61d72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28bed3f5e64dfc083dc193412b65d95533a61d72/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91e804409b7481677901345d9abcb6e8bd3152ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/91e804409b7481677901345d9abcb6e8bd3152ad", "html_url": "https://github.com/rust-lang/rust/commit/91e804409b7481677901345d9abcb6e8bd3152ad"}, {"sha": "e768fa729fb21549a39744bd3bfad03643cc10da", "url": "https://api.github.com/repos/rust-lang/rust/commits/e768fa729fb21549a39744bd3bfad03643cc10da", "html_url": "https://github.com/rust-lang/rust/commit/e768fa729fb21549a39744bd3bfad03643cc10da"}], "stats": {"total": 191, "additions": 76, "deletions": 115}, "files": [{"sha": "8f4913f04205e7310a45eeb47de33f03990a7f47", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/28bed3f5e64dfc083dc193412b65d95533a61d72/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bed3f5e64dfc083dc193412b65d95533a61d72/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=28bed3f5e64dfc083dc193412b65d95533a61d72", "patch": "@@ -107,20 +107,37 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n     fn define<T: ToNameBinding<'b>>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T) {\n-        let name_binding = def.to_name_binding();\n-        let span = name_binding.span.unwrap_or(DUMMY_SP);\n-        self.check_for_conflicts_between_external_crates_and_items(&parent, name, span);\n-        if !parent.try_define_child(name, ns, name_binding) {\n+        let binding = def.to_name_binding();\n+        let old_binding = match parent.try_define_child(name, ns, binding.clone()) {\n+            Some(old_binding) => old_binding,\n+            None => return,\n+        };\n+\n+        let span = binding.span.unwrap_or(DUMMY_SP);\n+        if !old_binding.is_extern_crate() && !binding.is_extern_crate() {\n             // Record an error here by looking up the namespace that had the duplicate\n             let ns_str = match ns { TypeNS => \"type or module\", ValueNS => \"value\" };\n             let resolution_error = ResolutionError::DuplicateDefinition(ns_str, name);\n             let mut err = resolve_struct_error(self, span, resolution_error);\n \n-            if let Some(sp) = parent.children.borrow().get(&(name, ns)).unwrap().span {\n+            if let Some(sp) = old_binding.span {\n                 let note = format!(\"first definition of {} `{}` here\", ns_str, name);\n                 err.span_note(sp, &note);\n             }\n             err.emit();\n+        } else if old_binding.is_extern_crate() && binding.is_extern_crate() {\n+            span_err!(self.session,\n+                      span,\n+                      E0259,\n+                      \"an external crate named `{}` has already been imported into this module\",\n+                      name);\n+        } else {\n+            span_err!(self.session,\n+                      span,\n+                      E0260,\n+                      \"the name `{}` conflicts with an external crate \\\n+                      that has been imported into this module\",\n+                      name);\n         }\n     }\n \n@@ -289,14 +306,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(parent, name);\n                     let def = Def::Mod(def_id);\n-                    let external_module = self.new_module(parent_link, Some(def), false, true);\n-\n-                    debug!(\"(build reduced graph for item) found extern `{}`\",\n-                           module_to_string(&*external_module));\n-                    self.check_for_conflicts_for_external_crate(parent, name, sp);\n-                    parent.external_module_children\n-                          .borrow_mut()\n-                          .insert(name, external_module);\n+                    let external_module = self.new_extern_crate_module(parent_link, def);\n+                    self.define(parent, name, TypeNS, (external_module, sp));\n+\n                     self.build_reduced_graph_for_external_crate(&external_module);\n                 }\n                 parent"}, {"sha": "6f35d10c994204969e3dbf70cae1edb65d881aa2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 32, "deletions": 72, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/28bed3f5e64dfc083dc193412b65d95533a61d72/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bed3f5e64dfc083dc193412b65d95533a61d72/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=28bed3f5e64dfc083dc193412b65d95533a61d72", "patch": "@@ -120,8 +120,6 @@ enum SuggestionType {\n }\n \n pub enum ResolutionError<'a> {\n-    /// error E0260: name conflicts with an extern crate\n-    NameConflictsWithExternCrate(Name),\n     /// error E0401: can't use type parameters from outer function\n     TypeParametersFromOuterFunction,\n     /// error E0402: cannot use an outer type parameter in this context\n@@ -228,14 +226,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n     }\n \n     match resolution_error {\n-        ResolutionError::NameConflictsWithExternCrate(name) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0260,\n-                             \"the name `{}` conflicts with an external crate \\\n-                             that has been imported into this module\",\n-                             name)\n-        }\n         ResolutionError::TypeParametersFromOuterFunction => {\n             struct_span_err!(resolver.session,\n                              span,\n@@ -801,14 +791,11 @@ pub struct ModuleS<'a> {\n     parent_link: ParentLink<'a>,\n     def: Cell<Option<Def>>,\n     is_public: bool,\n+    is_extern_crate: bool,\n \n     children: RefCell<HashMap<(Name, Namespace), NameBinding<'a>>>,\n     imports: RefCell<Vec<ImportDirective>>,\n \n-    // The external module children of this node that were declared with\n-    // `extern crate`.\n-    external_module_children: RefCell<HashMap<Name, Module<'a>>>,\n-\n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n     // blocks.\n@@ -854,9 +841,9 @@ impl<'a> ModuleS<'a> {\n             parent_link: parent_link,\n             def: Cell::new(def),\n             is_public: is_public,\n+            is_extern_crate: false,\n             children: RefCell::new(HashMap::new()),\n             imports: RefCell::new(Vec::new()),\n-            external_module_children: RefCell::new(HashMap::new()),\n             anonymous_children: RefCell::new(NodeMap()),\n             import_resolutions: RefCell::new(HashMap::new()),\n             glob_count: Cell::new(0),\n@@ -871,10 +858,21 @@ impl<'a> ModuleS<'a> {\n         self.children.borrow().get(&(name, ns)).cloned()\n     }\n \n-    fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>) -> bool {\n+    // If the name is not yet defined, define the name and return None.\n+    // Otherwise, return the existing definition.\n+    fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>)\n+                        -> Option<NameBinding<'a>> {\n         match self.children.borrow_mut().entry((name, ns)) {\n-            hash_map::Entry::Vacant(entry) => { entry.insert(binding); true }\n-            hash_map::Entry::Occupied(_) => false,\n+            hash_map::Entry::Vacant(entry) => { entry.insert(binding); None }\n+            hash_map::Entry::Occupied(entry) => { Some(entry.get().clone()) },\n+        }\n+    }\n+\n+    fn for_each_local_child<F: FnMut(Name, Namespace, &NameBinding<'a>)>(&self, mut f: F) {\n+        for (&(name, ns), name_binding) in self.children.borrow().iter() {\n+            if !name_binding.is_extern_crate() {\n+                f(name, ns, name_binding)\n+            }\n         }\n     }\n \n@@ -1005,6 +1003,10 @@ impl<'a> NameBinding<'a> {\n         let def = self.def().unwrap();\n         (def, LastMod(if self.is_public() { AllPublic } else { DependsOn(def.def_id()) }))\n     }\n+\n+    fn is_extern_crate(&self) -> bool {\n+        self.module().map(|module| module.is_extern_crate).unwrap_or(false)\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -1184,6 +1186,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.arenas.modules.alloc(ModuleS::new(parent_link, def, external, is_public))\n     }\n \n+    fn new_extern_crate_module(&self, parent_link: ParentLink<'a>, def: Def) -> Module<'a> {\n+        let mut module = ModuleS::new(parent_link, Some(def), false, true);\n+        module.is_extern_crate = true;\n+        self.arenas.modules.alloc(module)\n+    }\n+\n     fn get_ribs<'b>(&'b mut self, ns: Namespace) -> &'b mut Vec<Rib<'a>> {\n         match ns { ValueNS => &mut self.value_ribs, TypeNS => &mut self.type_ribs }\n     }\n@@ -1211,32 +1219,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    /// Check that an external crate doesn't collide with items or other external crates.\n-    fn check_for_conflicts_for_external_crate(&self, module: Module<'a>, name: Name, span: Span) {\n-        if module.external_module_children.borrow().contains_key(&name) {\n-            span_err!(self.session,\n-                      span,\n-                      E0259,\n-                      \"an external crate named `{}` has already been imported into this module\",\n-                      name);\n-        }\n-        if let Some(name_binding) = module.get_child(name, TypeNS) {\n-            resolve_error(self,\n-                          name_binding.span.unwrap_or(codemap::DUMMY_SP),\n-                          ResolutionError::NameConflictsWithExternCrate(name));\n-        }\n-    }\n-\n-    /// Checks that the names of items don't collide with external crates.\n-    fn check_for_conflicts_between_external_crates_and_items(&self,\n-                                                             module: Module<'a>,\n-                                                             name: Name,\n-                                                             span: Span) {\n-        if module.external_module_children.borrow().contains_key(&name) {\n-            resolve_error(self, span, ResolutionError::NameConflictsWithExternCrate(name));\n-        }\n-    }\n-\n     /// Resolves the given module path from the given root `module_`.\n     fn resolve_module_path_from_root(&mut self,\n                                      module_: Module<'a>,\n@@ -1245,11 +1227,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      span: Span,\n                                      lp: LastPrivate)\n                                      -> ResolveResult<(Module<'a>, LastPrivate)> {\n-        fn search_parent_externals<'a>(needle: Name, module: Module<'a>)\n-                                       -> Option<Module<'a>> {\n-            match module.external_module_children.borrow().get(&needle) {\n-                Some(_) => Some(module),\n-                None => match module.parent_link {\n+        fn search_parent_externals<'a>(needle: Name, module: Module<'a>) -> Option<Module<'a>> {\n+            match module.get_child(needle, TypeNS) {\n+                Some(ref binding) if binding.is_extern_crate() => Some(module),\n+                _ => match module.parent_link {\n                     ModuleParentLink(ref parent, _) => {\n                         search_parent_externals(needle, parent)\n                     }\n@@ -1480,17 +1461,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        // Search for external modules.\n-        if namespace == TypeNS {\n-            let children = module_.external_module_children.borrow();\n-            if let Some(module) = children.get(&name) {\n-                let name_binding = NameBinding::create_from_module(module, None);\n-                debug!(\"lower name bindings succeeded\");\n-                return Success((Target::new(module_, name_binding, Shadowable::Never),\n-                                false));\n-            }\n-        }\n-\n         // Finally, proceed up the scope chain looking for parent modules.\n         let mut search_module = module_;\n         loop {\n@@ -1684,16 +1654,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some(..) | None => {} // Continue.\n         }\n \n-        // Finally, search through external children.\n-        if namespace == TypeNS {\n-            let children = module_.external_module_children.borrow();\n-            if let Some(module) = children.get(&name) {\n-                let name_binding = NameBinding::create_from_module(module, None);\n-                return Success((Target::new(module_, name_binding, Shadowable::Never),\n-                                false));\n-            }\n-        }\n-\n         // We're out of luck.\n         debug!(\"(resolving name in module) failed to resolve `{}`\", name);\n         return Failed(None);\n@@ -1712,7 +1672,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Descend into children and anonymous children.\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n-        for (_, child_node) in module_.children.borrow().iter() {\n+        module_.for_each_local_child(|_, _, child_node| {\n             match child_node.module() {\n                 None => {\n                     // Continue.\n@@ -1721,7 +1681,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     self.report_unresolved_imports(child_module);\n                 }\n             }\n-        }\n+        });\n \n         for (_, module_) in module_.anonymous_children.borrow().iter() {\n             self.report_unresolved_imports(module_);"}, {"sha": "47b91ccb9d6f9497c8ec0e87f37914211f350dd3", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/28bed3f5e64dfc083dc193412b65d95533a61d72/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bed3f5e64dfc083dc193412b65d95533a61d72/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=28bed3f5e64dfc083dc193412b65d95533a61d72", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         self.resolver.current_module = orig_module;\n \n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n-        for (_, child_node) in module_.children.borrow().iter() {\n+        module_.for_each_local_child(|_, _, child_node| {\n             match child_node.module() {\n                 None => {\n                     // Nothing to do.\n@@ -222,7 +222,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     errors.extend(self.resolve_imports_for_module_subtree(child_module));\n                 }\n             }\n-        }\n+        });\n \n         for (_, child_module) in module_.anonymous_children.borrow().iter() {\n             errors.extend(self.resolve_imports_for_module_subtree(child_module));\n@@ -386,18 +386,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                               -> (ResolveResult<(Module<'b>, NameBinding<'b>)>, bool) {\n         build_reduced_graph::populate_module_if_necessary(self.resolver, module);\n         if let Some(name_binding) = module.get_child(name, ns) {\n-            return (Success((module, name_binding)), false);\n-        }\n-\n-        if ns == TypeNS {\n-            if let Some(extern_crate) = module.external_module_children.borrow().get(&name) {\n+            if name_binding.is_extern_crate() {\n                 // track the extern crate as used.\n-                if let Some(DefId{ krate: kid, .. }) = extern_crate.def_id() {\n-                    self.resolver.used_crates.insert(kid);\n+                if let Some(DefId { krate, .. }) = name_binding.module().unwrap().def_id() {\n+                    self.resolver.used_crates.insert(krate);\n                 }\n-                let name_binding = NameBinding::create_from_module(extern_crate, None);\n-                return (Success((module, name_binding)), false);\n             }\n+            return (Success((module, name_binding)), false)\n         }\n \n         // If there is an unresolved glob at this point in the containing module, bail out.\n@@ -725,13 +720,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // Add all children from the containing module.\n         build_reduced_graph::populate_module_if_necessary(self.resolver, &target_module);\n \n-        for (&name, name_binding) in target_module.children.borrow().iter() {\n+        target_module.for_each_local_child(|name, ns, name_binding| {\n             self.merge_import_resolution(module_,\n                                          target_module,\n                                          import_directive,\n-                                         name,\n+                                         (name, ns),\n                                          name_binding.clone());\n-        }\n+        });\n \n         // Record the destination of this import\n         if let Some(did) = target_module.def_id() {\n@@ -878,21 +873,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                      import: &ImportResolution<'b>,\n                                                      import_span: Span,\n                                                      (name, ns): (Name, Namespace)) {\n-        // First, check for conflicts between imports and `extern crate`s.\n-        if ns == TypeNS {\n-            if module.external_module_children.borrow().contains_key(&name) {\n-                match import.target {\n-                    Some(ref target) if target.shadowable != Shadowable::Always => {\n-                        let msg = format!(\"import `{0}` conflicts with imported crate \\\n-                                           in this module (maybe you meant `use {0}::*`?)\",\n-                                          name);\n-                        span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n-                    }\n-                    Some(_) | None => {}\n-                }\n-            }\n-        }\n-\n         // Check for item conflicts.\n         let name_binding = match module.get_child(name, ns) {\n             None => {\n@@ -921,6 +901,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         } else {\n             match import.target {\n                 Some(ref target) if target.shadowable != Shadowable::Always => {\n+                    if name_binding.is_extern_crate() {\n+                        let msg = format!(\"import `{0}` conflicts with imported crate \\\n+                                           in this module (maybe you meant `use {0}::*`?)\",\n+                                          name);\n+                        span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n+                        return;\n+                    }\n+\n                     let (what, note) = match name_binding.module() {\n                         Some(ref module) if module.is_normal() =>\n                             (\"existing submodule\", \"note conflicting module here\"),"}, {"sha": "07f80cf03d1dadf086ce798de5ba756d336bd5bf", "filename": "src/test/compile-fail/resolve-conflict-item-vs-extern-crate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28bed3f5e64dfc083dc193412b65d95533a61d72/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28bed3f5e64dfc083dc193412b65d95533a61d72/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-extern-crate.rs?ref=28bed3f5e64dfc083dc193412b65d95533a61d72", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn std() {}    //~ ERROR the name `std` conflicts with an external crate\n+fn std() {}\n+mod std {}    //~ ERROR the name `std` conflicts with an external crate\n \n fn main() {\n }"}]}