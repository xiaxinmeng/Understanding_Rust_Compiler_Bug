{"sha": "66787e05242d86e0bcfa227265559330c45cdc42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2Nzg3ZTA1MjQyZDg2ZTBiY2ZhMjI3MjY1NTU5MzMwYzQ1Y2RjNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-11T14:15:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-11T14:15:01Z"}, "message": "Auto merge of #51553 - jD91mZM2:uds, r=sfackler\n\nUnix sockets on redox\n\nThis is done using the ipcd daemon. It's not exactly like unix sockets because there is not actually a physical file for the path, but it's close enough for a basic implementation :)\nThis allows mio-uds and tokio-uds to work with a few modifications as well, which is exciting!", "tree": {"sha": "a08fb5bb53af23aca329a51ebd38f0a850225c76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a08fb5bb53af23aca329a51ebd38f0a850225c76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66787e05242d86e0bcfa227265559330c45cdc42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66787e05242d86e0bcfa227265559330c45cdc42", "html_url": "https://github.com/rust-lang/rust/commit/66787e05242d86e0bcfa227265559330c45cdc42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66787e05242d86e0bcfa227265559330c45cdc42/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11432ba98043ee0ade961bdedb4b785bf06c086e", "url": "https://api.github.com/repos/rust-lang/rust/commits/11432ba98043ee0ade961bdedb4b785bf06c086e", "html_url": "https://github.com/rust-lang/rust/commit/11432ba98043ee0ade961bdedb4b785bf06c086e"}, {"sha": "0b56e7f1a911f1157cd46cedbb1a0544e3ee3c3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b56e7f1a911f1157cd46cedbb1a0544e3ee3c3c", "html_url": "https://github.com/rust-lang/rust/commit/0b56e7f1a911f1157cd46cedbb1a0544e3ee3c3c"}], "stats": {"total": 741, "additions": 740, "deletions": 1}, "files": [{"sha": "cb2c75ae0bfa8e1824bd936178ba45aa05cf7884", "filename": "src/libstd/sys/redox/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66787e05242d86e0bcfa227265559330c45cdc42/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66787e05242d86e0bcfa227265559330c45cdc42/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs?ref=66787e05242d86e0bcfa227265559330c45cdc42", "patch": "@@ -33,6 +33,7 @@\n pub mod ffi;\n pub mod fs;\n pub mod io;\n+pub mod net;\n pub mod process;\n pub mod thread;\n "}, {"sha": "4c5f857462193ddf51dc2eb630eb4c882358e0af", "filename": "src/libstd/sys/redox/ext/net.rs", "status": "added", "additions": 729, "deletions": 0, "changes": 729, "blob_url": "https://github.com/rust-lang/rust/blob/66787e05242d86e0bcfa227265559330c45cdc42/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66787e05242d86e0bcfa227265559330c45cdc42/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs?ref=66787e05242d86e0bcfa227265559330c45cdc42", "patch": "@@ -0,0 +1,729 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"unix_socket_redox\", reason = \"new feature\", issue=\"51553\")]\n+\n+//! Unix-specific networking functionality\n+\n+use fmt;\n+use io::{self, Error, ErrorKind, Initializer};\n+use net::Shutdown;\n+use os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n+use path::Path;\n+use time::Duration;\n+use sys::{cvt, fd::FileDesc, syscall};\n+\n+/// An address associated with a Unix socket.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::os::unix::net::UnixListener;\n+///\n+/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n+///     Ok(sock) => sock,\n+///     Err(e) => {\n+///         println!(\"Couldn't bind: {:?}\", e);\n+///         return\n+///     }\n+/// };\n+/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+/// ```\n+#[derive(Clone)]\n+pub struct SocketAddr(());\n+\n+impl SocketAddr {\n+    /// Returns the contents of this address if it is a `pathname` address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// With a pathname:\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    /// use std::path::Path;\n+    ///\n+    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n+    /// ```\n+    ///\n+    /// Without a pathname:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.as_pathname(), None);\n+    /// ```\n+    pub fn as_pathname(&self) -> Option<&Path> {\n+        None\n+    }\n+\n+    /// Returns true if and only if the address is unnamed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A named address:\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.is_unnamed(), false);\n+    /// ```\n+    ///\n+    /// An unnamed address:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.is_unnamed(), true);\n+    /// ```\n+    pub fn is_unnamed(&self) -> bool {\n+        false\n+    }\n+}\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"SocketAddr\")\n+    }\n+}\n+\n+/// A Unix stream socket.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::os::unix::net::UnixStream;\n+/// use std::io::prelude::*;\n+///\n+/// let mut stream = UnixStream::connect(\"/path/to/my/socket\").unwrap();\n+/// stream.write_all(b\"hello world\").unwrap();\n+/// let mut response = String::new();\n+/// stream.read_to_string(&mut response).unwrap();\n+/// println!(\"{}\", response);\n+/// ```\n+pub struct UnixStream(FileDesc);\n+\n+impl fmt::Debug for UnixStream {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixStream\");\n+        builder.field(\"fd\", &self.0.raw());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        if let Ok(addr) = self.peer_addr() {\n+            builder.field(\"peer\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixStream {\n+    /// Connects to the socket named by `path`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n+        if let Some(s) = path.as_ref().to_str() {\n+            cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CLOEXEC))\n+                .map(FileDesc::new)\n+                .map(UnixStream)\n+        } else {\n+            Err(Error::new(\n+                ErrorKind::Other,\n+                \"UnixStream::connect: non-utf8 paths not supported on redox\"\n+            ))\n+        }\n+    }\n+\n+    /// Creates an unnamed pair of connected sockets.\n+    ///\n+    /// Returns two `UnixStream`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let (sock1, sock2) = match UnixStream::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n+        let server = cvt(syscall::open(\"chan:\", syscall::O_CREAT | syscall::O_CLOEXEC))\n+            .map(FileDesc::new)?;\n+        let client = server.duplicate_path(b\"connect\")?;\n+        let stream = server.duplicate_path(b\"listen\")?;\n+        Ok((UnixStream(client), UnixStream(stream)))\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixStream` is a reference to the same stream that this\n+    /// object references. Both handles will read and write the same stream of\n+    /// data, and options set on one stream will be propagated to the other\n+    /// stream.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n+    /// ```\n+    pub fn try_clone(&self) -> io::Result<UnixStream> {\n+        self.0.duplicate().map(UnixStream)\n+    }\n+\n+    /// Returns the socket address of the local half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::local_addr unimplemented on redox\"))\n+    }\n+\n+    /// Returns the socket address of the remote half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n+    /// ```\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::peer_addr unimplemented on redox\"))\n+    }\n+\n+    /// Sets the read timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`read`] calls will block\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n+    /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n+    pub fn set_read_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::set_read_timeout unimplemented on redox\"))\n+    }\n+\n+    /// Sets the write timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`write`] calls will block\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n+    /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::UdpSocket;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n+    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n+    pub fn set_write_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::set_write_timeout unimplemented on redox\"))\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::read_timeout unimplemented on redox\"))\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n+    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::write_timeout unimplemented on redox\"))\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n+    /// ```\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// if let Ok(Some(err)) = socket.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Platform specific\n+    /// On Redox this always returns None.\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        Ok(None)\n+    }\n+\n+    /// Shuts down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O calls on the\n+    /// specified portions to immediately return with an appropriate value\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    /// ```\n+    pub fn shutdown(&self, _how: Shutdown) -> io::Result<()> {\n+        Err(Error::new(ErrorKind::Other, \"UnixStream::shutdown unimplemented on redox\"))\n+    }\n+}\n+\n+impl io::Read for UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        io::Read::read(&mut &*self, buf)\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        Initializer::nop()\n+    }\n+}\n+\n+impl<'a> io::Read for &'a UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        Initializer::nop()\n+    }\n+}\n+\n+impl io::Write for UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        io::Write::write(&mut &*self, buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        io::Write::flush(&mut &*self)\n+    }\n+}\n+\n+impl<'a> io::Write for &'a UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl AsRawFd for UnixStream {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.raw()\n+    }\n+}\n+\n+impl FromRawFd for UnixStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n+        UnixStream(FileDesc::new(fd))\n+    }\n+}\n+\n+impl IntoRawFd for UnixStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_raw()\n+    }\n+}\n+\n+/// A structure representing a Unix domain socket server.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+///\n+/// // accept connections and process them, spawning a new thread for each one\n+/// for stream in listener.incoming() {\n+///     match stream {\n+///         Ok(stream) => {\n+///             /* connection succeeded */\n+///             thread::spawn(|| handle_client(stream));\n+///         }\n+///         Err(err) => {\n+///             /* connection failed */\n+///             break;\n+///         }\n+///     }\n+/// }\n+/// ```\n+pub struct UnixListener(FileDesc);\n+\n+impl fmt::Debug for UnixListener {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixListener\");\n+        builder.field(\"fd\", &self.0.raw());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixListener {\n+    /// Creates a new `UnixListener` bound to the specified socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n+        if let Some(s) = path.as_ref().to_str() {\n+            cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CREAT | syscall::O_CLOEXEC))\n+                .map(FileDesc::new)\n+                .map(UnixListener)\n+        } else {\n+            Err(Error::new(\n+                ErrorKind::Other,\n+                \"UnixListener::bind: non-utf8 paths not supported on redox\"\n+            ))\n+        }\n+    }\n+\n+    /// Accepts a new incoming connection to this listener.\n+    ///\n+    /// This function will block the calling thread until a new Unix connection\n+    /// is established. When established, the corresponding [`UnixStream`] and\n+    /// the remote peer's address will be returned.\n+    ///\n+    /// [`UnixStream`]: ../../../../std/os/unix/net/struct.UnixStream.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// match listener.accept() {\n+    ///     Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n+    ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n+    /// }\n+    /// ```\n+    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n+        self.0.duplicate_path(b\"listen\").map(|fd| (UnixStream(fd), SocketAddr(())))\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixListener` is a reference to the same socket that this\n+    /// object references. Both handles can be used to accept incoming\n+    /// connections and options set on one listener will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n+    /// ```\n+    pub fn try_clone(&self) -> io::Result<UnixListener> {\n+        self.0.duplicate().map(UnixListener)\n+    }\n+\n+    /// Returns the local socket address of this listener.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        Err(Error::new(ErrorKind::Other, \"UnixListener::local_addr unimplemented on redox\"))\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n+    /// ```\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    ///\n+    /// if let Ok(Some(err)) = listener.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Platform specific\n+    /// On Redox this always returns None.\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        Ok(None)\n+    }\n+\n+    /// Returns an iterator over incoming connections.\n+    ///\n+    /// The iterator will never return [`None`] and will also not yield the\n+    /// peer's [`SocketAddr`] structure.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`SocketAddr`]: struct.SocketAddr.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::thread;\n+    /// use std::os::unix::net::{UnixStream, UnixListener};\n+    ///\n+    /// fn handle_client(stream: UnixStream) {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// for stream in listener.incoming() {\n+    ///     match stream {\n+    ///         Ok(stream) => {\n+    ///             thread::spawn(|| handle_client(stream));\n+    ///         }\n+    ///         Err(err) => {\n+    ///             break;\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n+        Incoming { listener: self }\n+    }\n+}\n+\n+impl AsRawFd for UnixListener {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.raw()\n+    }\n+}\n+\n+impl FromRawFd for UnixListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n+        UnixListener(FileDesc::new(fd))\n+    }\n+}\n+\n+impl IntoRawFd for UnixListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_raw()\n+    }\n+}\n+\n+impl<'a> IntoIterator for &'a UnixListener {\n+    type Item = io::Result<UnixStream>;\n+    type IntoIter = Incoming<'a>;\n+\n+    fn into_iter(self) -> Incoming<'a> {\n+        self.incoming()\n+    }\n+}\n+\n+/// An iterator over incoming connections to a [`UnixListener`].\n+///\n+/// It will never return [`None`].\n+///\n+/// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+/// [`UnixListener`]: struct.UnixListener.html\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+///\n+/// for stream in listener.incoming() {\n+///     match stream {\n+///         Ok(stream) => {\n+///             thread::spawn(|| handle_client(stream));\n+///         }\n+///         Err(err) => {\n+///             break;\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[derive(Debug)]\n+pub struct Incoming<'a> {\n+    listener: &'a UnixListener,\n+}\n+\n+impl<'a> Iterator for Incoming<'a> {\n+    type Item = io::Result<UnixStream>;\n+\n+    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n+        Some(self.listener.accept().map(|s| s.0))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::max_value(), None)\n+    }\n+}"}, {"sha": "e04e2791b23a1a496694af26b6f134d7a566ba27", "filename": "src/libstd/sys/redox/fd.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66787e05242d86e0bcfa227265559330c45cdc42/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66787e05242d86e0bcfa227265559330c45cdc42/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs?ref=66787e05242d86e0bcfa227265559330c45cdc42", "patch": "@@ -47,7 +47,10 @@ impl FileDesc {\n     }\n \n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n-        let new_fd = cvt(syscall::dup(self.fd, &[]))?;\n+        self.duplicate_path(&[])\n+    }\n+    pub fn duplicate_path(&self, path: &[u8]) -> io::Result<FileDesc> {\n+        let new_fd = cvt(syscall::dup(self.fd, path))?;\n         Ok(FileDesc::new(new_fd))\n     }\n "}, {"sha": "55f43ccd7db4d7542e548343e4d4fcf77eb67275", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66787e05242d86e0bcfa227265559330c45cdc42/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66787e05242d86e0bcfa227265559330c45cdc42/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=66787e05242d86e0bcfa227265559330c45cdc42", "patch": "@@ -524,6 +524,9 @@ impl UnixStream {\n     ///     println!(\"Got error: {:?}\", err);\n     /// }\n     /// ```\n+    ///\n+    /// # Platform specific\n+    /// On Redox this always returns None.\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -846,6 +849,9 @@ impl UnixListener {\n     ///     println!(\"Got error: {:?}\", err);\n     /// }\n     /// ```\n+    ///\n+    /// # Platform specific\n+    /// On Redox this always returns None.\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()"}]}