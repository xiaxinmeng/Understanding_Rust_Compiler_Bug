{"sha": "15ea2276ff451a37dcbeb43c9943934ee80332e3", "node_id": "C_kwDOAAsO6NoAKDE1ZWEyMjc2ZmY0NTFhMzdkY2JlYjQzYzk5NDM5MzRlZTgwMzMyZTM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-25T02:37:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-25T02:37:11Z"}, "message": "Rollup merge of #109539 - cjgillot:find-stability, r=b-naber\n\nRefactor `find_*_stability` functions\n\nThe idea is to split the monolithic function into the 3 cases: stability, const stability, and body stability.", "tree": {"sha": "24e94932650350b50ec76654c3607b1e5b34abbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24e94932650350b50ec76654c3607b1e5b34abbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15ea2276ff451a37dcbeb43c9943934ee80332e3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkHl5XCRBK7hj4Ov3rIwAA1egIAGhRFS5adGsqLyNBHeNUcRxc\nGT8+J5X/pMA/dSMyF7zYVgIGQO3ixw+/JyLvUTeUZDBYjxrtGc+adJXtZlFFw9y7\nxo04Dc7K4I2HK+/JSXfGeYNDxyzxO25MgKbC1v+HtvOFZRFWg+qVuLmlUaOc4FWi\np0tWfjywVuBUuAtKP1aeWyOVTbcZ5H+ZhDA6HzGX2lUuOGNCTaIo4isaSFx06Nmz\n9YtetsSaes8K0J8F12MJxG3X6NCoeSD/Hyos8OOma7D5Uait423TczU6G7/FnmR6\nieWPtQ6g+hxNElBzkHiJK1sAaTPbpZZiHLZZpvsyecleqAEGQeifwlevgn/K6Uo=\n=AxF3\n-----END PGP SIGNATURE-----\n", "payload": "tree 24e94932650350b50ec76654c3607b1e5b34abbc\nparent 65220b5ba9a055d7dbf66859f862a8fa6b274d64\nparent 3e9ea5da6345d3f5fe88cbaaaa16637a8c59ec49\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1679711831 +0100\ncommitter GitHub <noreply@github.com> 1679711831 +0100\n\nRollup merge of #109539 - cjgillot:find-stability, r=b-naber\n\nRefactor `find_*_stability` functions\n\nThe idea is to split the monolithic function into the 3 cases: stability, const stability, and body stability.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15ea2276ff451a37dcbeb43c9943934ee80332e3", "html_url": "https://github.com/rust-lang/rust/commit/15ea2276ff451a37dcbeb43c9943934ee80332e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15ea2276ff451a37dcbeb43c9943934ee80332e3/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65220b5ba9a055d7dbf66859f862a8fa6b274d64", "url": "https://api.github.com/repos/rust-lang/rust/commits/65220b5ba9a055d7dbf66859f862a8fa6b274d64", "html_url": "https://github.com/rust-lang/rust/commit/65220b5ba9a055d7dbf66859f862a8fa6b274d64"}, {"sha": "3e9ea5da6345d3f5fe88cbaaaa16637a8c59ec49", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e9ea5da6345d3f5fe88cbaaaa16637a8c59ec49", "html_url": "https://github.com/rust-lang/rust/commit/3e9ea5da6345d3f5fe88cbaaaa16637a8c59ec49"}], "stats": {"total": 603, "additions": 305, "deletions": 298}, "files": [{"sha": "a29e389953eb35aaa470ff87e4d35c87a81e3193", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 297, "deletions": 294, "changes": 591, "blob_url": "https://github.com/rust-lang/rust/blob/15ea2276ff451a37dcbeb43c9943934ee80332e3/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea2276ff451a37dcbeb43c9943934ee80332e3/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=15ea2276ff451a37dcbeb43c9943934ee80332e3", "patch": "@@ -226,307 +226,95 @@ impl UnstableReason {\n     }\n }\n \n-/// Collects stability info from all stability attributes in `attrs`.\n-/// Returns `None` if no stability attributes are found.\n+/// Collects stability info from `stable`/`unstable`/`rustc_allowed_through_unstable_modules`\n+/// attributes in `attrs`.  Returns `None` if no stability attributes are found.\n pub fn find_stability(\n     sess: &Session,\n     attrs: &[Attribute],\n     item_sp: Span,\n-) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>, Option<(DefaultBodyStability, Span)>)\n-{\n-    find_stability_generic(sess, attrs.iter(), item_sp)\n-}\n-\n-fn find_stability_generic<'a, I>(\n-    sess: &Session,\n-    attrs_iter: I,\n-    item_sp: Span,\n-) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>, Option<(DefaultBodyStability, Span)>)\n-where\n-    I: Iterator<Item = &'a Attribute>,\n-{\n-    use StabilityLevel::*;\n-\n+) -> Option<(Stability, Span)> {\n     let mut stab: Option<(Stability, Span)> = None;\n-    let mut const_stab: Option<(ConstStability, Span)> = None;\n-    let mut body_stab: Option<(DefaultBodyStability, Span)> = None;\n-    let mut promotable = false;\n     let mut allowed_through_unstable_modules = false;\n \n-    'outer: for attr in attrs_iter {\n-        if ![\n-            sym::rustc_const_unstable,\n-            sym::rustc_const_stable,\n-            sym::unstable,\n-            sym::stable,\n-            sym::rustc_promotable,\n-            sym::rustc_allowed_through_unstable_modules,\n-            sym::rustc_default_body_unstable,\n-        ]\n-        .iter()\n-        .any(|&s| attr.has_name(s))\n-        {\n-            continue; // not a stability level\n-        }\n-\n-        let meta = attr.meta();\n+    for attr in attrs {\n+        match attr.name_or_empty() {\n+            sym::rustc_allowed_through_unstable_modules => allowed_through_unstable_modules = true,\n+            sym::unstable => {\n+                if stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n+                }\n \n-        if attr.has_name(sym::rustc_promotable) {\n-            promotable = true;\n-        } else if attr.has_name(sym::rustc_allowed_through_unstable_modules) {\n-            allowed_through_unstable_modules = true;\n-        }\n-        // attributes with data\n-        else if let Some(meta @ MetaItem { kind: MetaItemKind::List(metas), .. }) = &meta {\n-            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n-                if item.is_some() {\n-                    handle_errors(\n-                        &sess.parse_sess,\n-                        meta.span,\n-                        AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n-                    );\n-                    return false;\n+                if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                    stab = Some((Stability { level, feature }, attr.span));\n                 }\n-                if let Some(v) = meta.value_str() {\n-                    *item = Some(v);\n-                    true\n-                } else {\n-                    sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n-                    false\n+            }\n+            sym::stable => {\n+                if stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n                 }\n-            };\n+                if let Some((feature, level)) = parse_stability(sess, attr) {\n+                    stab = Some((Stability { level, feature }, attr.span));\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n \n-            let meta_name = meta.name_or_empty();\n-            match meta_name {\n-                sym::rustc_const_unstable | sym::rustc_default_body_unstable | sym::unstable => {\n-                    if meta_name == sym::unstable && stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_const_unstable && const_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_default_body_unstable && body_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    }\n+    if allowed_through_unstable_modules {\n+        match &mut stab {\n+            Some((\n+                Stability {\n+                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n+                    ..\n+                },\n+                _,\n+            )) => *allowed_through_unstable_modules = true,\n+            _ => {\n+                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+            }\n+        }\n+    }\n \n-                    let mut feature = None;\n-                    let mut reason = None;\n-                    let mut issue = None;\n-                    let mut issue_num = None;\n-                    let mut is_soft = false;\n-                    let mut implied_by = None;\n-                    for meta in metas {\n-                        let Some(mi) = meta.meta_item() else {\n-                            handle_errors(\n-                                &sess.parse_sess,\n-                                meta.span(),\n-                                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n-                            );\n-                            continue 'outer;\n-                        };\n-                        match mi.name_or_empty() {\n-                            sym::feature => {\n-                                if !get(mi, &mut feature) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            sym::reason => {\n-                                if !get(mi, &mut reason) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            sym::issue => {\n-                                if !get(mi, &mut issue) {\n-                                    continue 'outer;\n-                                }\n+    stab\n+}\n \n-                                // These unwraps are safe because `get` ensures the meta item\n-                                // is a name/value pair string literal.\n-                                issue_num = match issue.unwrap().as_str() {\n-                                    \"none\" => None,\n-                                    issue => match issue.parse::<NonZeroU32>() {\n-                                        Ok(num) => Some(num),\n-                                        Err(err) => {\n-                                            sess.emit_err(\n-                                                session_diagnostics::InvalidIssueString {\n-                                                    span: mi.span,\n-                                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n-                                                        mi.name_value_literal_span().unwrap(),\n-                                                        err.kind(),\n-                                                    ),\n-                                                },\n-                                            );\n-                                            continue 'outer;\n-                                        }\n-                                    },\n-                                };\n-                            }\n-                            sym::soft => {\n-                                if !mi.is_word() {\n-                                    sess.emit_err(session_diagnostics::SoftNoArgs {\n-                                        span: mi.span,\n-                                    });\n-                                }\n-                                is_soft = true;\n-                            }\n-                            sym::implied_by => {\n-                                if !get(mi, &mut implied_by) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            _ => {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    meta.span(),\n-                                    AttrError::UnknownMetaItem(\n-                                        pprust::path_to_string(&mi.path),\n-                                        &[\"feature\", \"reason\", \"issue\", \"soft\"],\n-                                    ),\n-                                );\n-                                continue 'outer;\n-                            }\n-                        }\n-                    }\n+/// Collects stability info from `rustc_const_stable`/`rustc_const_unstable`/`rustc_promotable`\n+/// attributes in `attrs`.  Returns `None` if no stability attributes are found.\n+pub fn find_const_stability(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+    item_sp: Span,\n+) -> Option<(ConstStability, Span)> {\n+    let mut const_stab: Option<(ConstStability, Span)> = None;\n+    let mut promotable = false;\n \n-                    match (feature, reason, issue) {\n-                        (Some(feature), reason, Some(_)) => {\n-                            if !rustc_lexer::is_ident(feature.as_str()) {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    attr.span,\n-                                    AttrError::NonIdentFeature,\n-                                );\n-                                continue;\n-                            }\n-                            let level = Unstable {\n-                                reason: UnstableReason::from_opt_reason(reason),\n-                                issue: issue_num,\n-                                is_soft,\n-                                implied_by,\n-                            };\n-                            if sym::unstable == meta_name {\n-                                stab = Some((Stability { level, feature }, attr.span));\n-                            } else if sym::rustc_const_unstable == meta_name {\n-                                const_stab = Some((\n-                                    ConstStability { level, feature, promotable: false },\n-                                    attr.span,\n-                                ));\n-                            } else if sym::rustc_default_body_unstable == meta_name {\n-                                body_stab =\n-                                    Some((DefaultBodyStability { level, feature }, attr.span));\n-                            } else {\n-                                unreachable!(\"Unknown stability attribute {meta_name}\");\n-                            }\n-                        }\n-                        (None, _, _) => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n-                            continue;\n-                        }\n-                        _ => {\n-                            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n-                            continue;\n-                        }\n-                    }\n+    for attr in attrs {\n+        match attr.name_or_empty() {\n+            sym::rustc_promotable => promotable = true,\n+            sym::rustc_const_unstable => {\n+                if const_stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n                 }\n-                sym::rustc_const_stable | sym::stable => {\n-                    if meta_name == sym::stable && stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_const_stable && const_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    }\n-\n-                    let mut feature = None;\n-                    let mut since = None;\n-                    for meta in metas {\n-                        match meta {\n-                            NestedMetaItem::MetaItem(mi) => match mi.name_or_empty() {\n-                                sym::feature => {\n-                                    if !get(mi, &mut feature) {\n-                                        continue 'outer;\n-                                    }\n-                                }\n-                                sym::since => {\n-                                    if !get(mi, &mut since) {\n-                                        continue 'outer;\n-                                    }\n-                                }\n-                                _ => {\n-                                    handle_errors(\n-                                        &sess.parse_sess,\n-                                        meta.span(),\n-                                        AttrError::UnknownMetaItem(\n-                                            pprust::path_to_string(&mi.path),\n-                                            &[\"feature\", \"since\"],\n-                                        ),\n-                                    );\n-                                    continue 'outer;\n-                                }\n-                            },\n-                            NestedMetaItem::Lit(lit) => {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    lit.span,\n-                                    AttrError::UnsupportedLiteral(\n-                                        UnsupportedLiteralReason::Generic,\n-                                        false,\n-                                    ),\n-                                );\n-                                continue 'outer;\n-                            }\n-                        }\n-                    }\n-\n-                    if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n-                        since = Some(rust_version_symbol());\n-                    }\n \n-                    match (feature, since) {\n-                        (Some(feature), Some(since)) => {\n-                            let level = Stable { since, allowed_through_unstable_modules: false };\n-                            if sym::stable == meta_name {\n-                                stab = Some((Stability { level, feature }, attr.span));\n-                            } else {\n-                                const_stab = Some((\n-                                    ConstStability { level, feature, promotable: false },\n-                                    attr.span,\n-                                ));\n-                            }\n-                        }\n-                        (None, _) => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n-                            continue;\n-                        }\n-                        _ => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n-                            continue;\n-                        }\n-                    }\n+                if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                    const_stab =\n+                        Some((ConstStability { level, feature, promotable: false }, attr.span));\n+                }\n+            }\n+            sym::rustc_const_stable => {\n+                if const_stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n+                }\n+                if let Some((feature, level)) = parse_stability(sess, attr) {\n+                    const_stab =\n+                        Some((ConstStability { level, feature, promotable: false }, attr.span));\n                 }\n-                _ => unreachable!(),\n             }\n+            _ => {}\n         }\n     }\n \n@@ -538,22 +326,237 @@ where\n         }\n     }\n \n-    if allowed_through_unstable_modules {\n-        match &mut stab {\n-            Some((\n-                Stability {\n-                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n-                    ..\n-                },\n-                _,\n-            )) => *allowed_through_unstable_modules = true,\n+    const_stab\n+}\n+\n+/// Collects stability info from `rustc_default_body_unstable` attributes in `attrs`.\n+/// Returns `None` if no stability attributes are found.\n+pub fn find_body_stability(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+) -> Option<(DefaultBodyStability, Span)> {\n+    let mut body_stab: Option<(DefaultBodyStability, Span)> = None;\n+\n+    for attr in attrs {\n+        if attr.has_name(sym::rustc_default_body_unstable) {\n+            if body_stab.is_some() {\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                break;\n+            }\n+\n+            if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                body_stab = Some((DefaultBodyStability { level, feature }, attr.span));\n+            }\n+        }\n+    }\n+\n+    body_stab\n+}\n+\n+/// Read the content of a `stable`/`rustc_const_stable` attribute, and return the feature name and\n+/// its stability information.\n+fn parse_stability(sess: &Session, attr: &Attribute) -> Option<(Symbol, StabilityLevel)> {\n+    let meta = attr.meta()?;\n+    let MetaItem { kind: MetaItemKind::List(ref metas), .. } = meta else { return None };\n+    let insert_or_error = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+        if item.is_some() {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span,\n+                AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+            );\n+            return false;\n+        }\n+        if let Some(v) = meta.value_str() {\n+            *item = Some(v);\n+            true\n+        } else {\n+            sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n+            false\n+        }\n+    };\n+\n+    let mut feature = None;\n+    let mut since = None;\n+    for meta in metas {\n+        let Some(mi) = meta.meta_item() else {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span(),\n+                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n+            );\n+            return None;\n+        };\n+\n+        match mi.name_or_empty() {\n+            sym::feature => {\n+                if !insert_or_error(mi, &mut feature) {\n+                    return None;\n+                }\n+            }\n+            sym::since => {\n+                if !insert_or_error(mi, &mut since) {\n+                    return None;\n+                }\n+            }\n             _ => {\n-                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+                handle_errors(\n+                    &sess.parse_sess,\n+                    meta.span(),\n+                    AttrError::UnknownMetaItem(\n+                        pprust::path_to_string(&mi.path),\n+                        &[\"feature\", \"since\"],\n+                    ),\n+                );\n+                return None;\n             }\n         }\n     }\n \n-    (stab, const_stab, body_stab)\n+    if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n+        since = Some(rust_version_symbol());\n+    }\n+\n+    match (feature, since) {\n+        (Some(feature), Some(since)) => {\n+            let level = StabilityLevel::Stable { since, allowed_through_unstable_modules: false };\n+            Some((feature, level))\n+        }\n+        (None, _) => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n+            None\n+        }\n+        _ => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n+            None\n+        }\n+    }\n+}\n+\n+/// Read the content of a `unstable`/`rustc_const_unstable`/`rustc_default_body_unstable`\n+/// attribute, and return the feature name and its stability information.\n+fn parse_unstability(sess: &Session, attr: &Attribute) -> Option<(Symbol, StabilityLevel)> {\n+    let meta = attr.meta()?;\n+    let MetaItem { kind: MetaItemKind::List(ref metas), .. } = meta else { return None };\n+    let insert_or_error = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+        if item.is_some() {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span,\n+                AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+            );\n+            return false;\n+        }\n+        if let Some(v) = meta.value_str() {\n+            *item = Some(v);\n+            true\n+        } else {\n+            sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n+            false\n+        }\n+    };\n+\n+    let mut feature = None;\n+    let mut reason = None;\n+    let mut issue = None;\n+    let mut issue_num = None;\n+    let mut is_soft = false;\n+    let mut implied_by = None;\n+    for meta in metas {\n+        let Some(mi) = meta.meta_item() else {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span(),\n+                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n+            );\n+            return None;\n+        };\n+\n+        match mi.name_or_empty() {\n+            sym::feature => {\n+                if !insert_or_error(mi, &mut feature) {\n+                    return None;\n+                }\n+            }\n+            sym::reason => {\n+                if !insert_or_error(mi, &mut reason) {\n+                    return None;\n+                }\n+            }\n+            sym::issue => {\n+                if !insert_or_error(mi, &mut issue) {\n+                    return None;\n+                }\n+\n+                // These unwraps are safe because `insert_or_error` ensures the meta item\n+                // is a name/value pair string literal.\n+                issue_num = match issue.unwrap().as_str() {\n+                    \"none\" => None,\n+                    issue => match issue.parse::<NonZeroU32>() {\n+                        Ok(num) => Some(num),\n+                        Err(err) => {\n+                            sess.emit_err(\n+                                session_diagnostics::InvalidIssueString {\n+                                    span: mi.span,\n+                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n+                                        mi.name_value_literal_span().unwrap(),\n+                                        err.kind(),\n+                                    ),\n+                                },\n+                            );\n+                            return None;\n+                        }\n+                    },\n+                };\n+            }\n+            sym::soft => {\n+                if !mi.is_word() {\n+                    sess.emit_err(session_diagnostics::SoftNoArgs { span: mi.span });\n+                }\n+                is_soft = true;\n+            }\n+            sym::implied_by => {\n+                if !insert_or_error(mi, &mut implied_by) {\n+                    return None;\n+                }\n+            }\n+            _ => {\n+                handle_errors(\n+                    &sess.parse_sess,\n+                    meta.span(),\n+                    AttrError::UnknownMetaItem(\n+                        pprust::path_to_string(&mi.path),\n+                        &[\"feature\", \"reason\", \"issue\", \"soft\", \"implied_by\"],\n+                    ),\n+                );\n+                return None;\n+            }\n+        }\n+    }\n+\n+    match (feature, reason, issue) {\n+        (Some(feature), reason, Some(_)) => {\n+            if !rustc_lexer::is_ident(feature.as_str()) {\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::NonIdentFeature);\n+                return None;\n+            }\n+            let level = StabilityLevel::Unstable {\n+                reason: UnstableReason::from_opt_reason(reason),\n+                issue: issue_num,\n+                is_soft,\n+                implied_by,\n+            };\n+            Some((feature, level))\n+        }\n+        (None, _, _) => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n+            return None;\n+        }\n+        _ => {\n+            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n+            return None;\n+        }\n+    }\n }\n \n pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {"}, {"sha": "caa2a201c758dbfae4dd1a6398ea05e264670b14", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15ea2276ff451a37dcbeb43c9943934ee80332e3/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea2276ff451a37dcbeb43c9943934ee80332e3/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=15ea2276ff451a37dcbeb43c9943934ee80332e3", "patch": "@@ -793,7 +793,9 @@ impl SyntaxExtension {\n                 )\n             })\n             .unwrap_or_else(|| (None, helper_attrs));\n-        let (stability, const_stability, body_stability) = attr::find_stability(&sess, attrs, span);\n+        let stability = attr::find_stability(&sess, attrs, span);\n+        let const_stability = attr::find_const_stability(&sess, attrs, span);\n+        let body_stability = attr::find_body_stability(&sess, attrs);\n         if let Some((_, sp)) = const_stability {\n             sess.emit_err(errors::MacroConstStability {\n                 span: sp,"}, {"sha": "4a1ba19c92064c714bfd5c3ca00cc4a0b3bfc101", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15ea2276ff451a37dcbeb43c9943934ee80332e3/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ea2276ff451a37dcbeb43c9943934ee80332e3/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=15ea2276ff451a37dcbeb43c9943934ee80332e3", "patch": "@@ -159,7 +159,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             return;\n         }\n \n-        let (stab, const_stab, body_stab) = attr::find_stability(&self.tcx.sess, attrs, item_sp);\n+        let stab = attr::find_stability(&self.tcx.sess, attrs, item_sp);\n+        let const_stab = attr::find_const_stability(&self.tcx.sess, attrs, item_sp);\n+        let body_stab = attr::find_body_stability(&self.tcx.sess, attrs);\n         let mut const_span = None;\n \n         let const_stab = const_stab.map(|(const_stab, const_span_node)| {\n@@ -742,8 +744,8 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                 let features = self.tcx.features();\n                 if features.staged_api {\n                     let attrs = self.tcx.hir().attrs(item.hir_id());\n-                    let (stab, const_stab, _) =\n-                        attr::find_stability(&self.tcx.sess, attrs, item.span);\n+                    let stab = attr::find_stability(&self.tcx.sess, attrs, item.span);\n+                    let const_stab = attr::find_const_stability(&self.tcx.sess, attrs, item.span);\n \n                     // If this impl block has an #[unstable] attribute, give an\n                     // error if all involved types and traits are stable, because"}]}