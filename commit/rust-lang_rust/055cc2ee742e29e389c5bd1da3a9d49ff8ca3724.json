{"sha": "055cc2ee742e29e389c5bd1da3a9d49ff8ca3724", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NWNjMmVlNzQyZTI5ZTM4OWM1YmQxZGEzYTlkNDlmZjhjYTM3MjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-12T15:10:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-12T15:10:38Z"}, "message": "auto merge of #20789 : nikomatsakis/rust/issue-20765-normalize-where-clause, r=nrc\n\nNormalize bounds that we extract from where clauses. Fixes #20765.\r\n\r\nr? @nick29581 \r\ncc @jroesch", "tree": {"sha": "d2cd5d6a51efe35df1daf694c0f9e6ed3bdf3a43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2cd5d6a51efe35df1daf694c0f9e6ed3bdf3a43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724", "html_url": "https://github.com/rust-lang/rust/commit/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6408fa1d80191032bebfa0047bc597b746886a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6408fa1d80191032bebfa0047bc597b746886a5", "html_url": "https://github.com/rust-lang/rust/commit/a6408fa1d80191032bebfa0047bc597b746886a5"}, {"sha": "47424cda1e05f5bb75e04346836f003fecb7f775", "url": "https://api.github.com/repos/rust-lang/rust/commits/47424cda1e05f5bb75e04346836f003fecb7f775", "html_url": "https://github.com/rust-lang/rust/commit/47424cda1e05f5bb75e04346836f003fecb7f775"}], "stats": {"total": 159, "additions": 129, "deletions": 30}, "files": [{"sha": "3502909251790d3566fa76ae73862e00d0e550d5", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=055cc2ee742e29e389c5bd1da3a9d49ff8ca3724", "patch": "@@ -218,8 +218,10 @@ pub enum Vtable<'tcx, N> {\n     VtableImpl(VtableImplData<'tcx, N>),\n \n     /// Successful resolution to an obligation provided by the caller\n-    /// for some type parameter.\n-    VtableParam,\n+    /// for some type parameter. The `Vec<N>` represents the\n+    /// obligations incurred from normalizing the where-clause (if\n+    /// any).\n+    VtableParam(Vec<N>),\n \n     /// Virtual calls through an object\n     VtableObject(VtableObjectData<'tcx>),\n@@ -443,7 +445,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableImpl(ref i) => i.iter_nested(),\n             VtableFnPointer(..) => (&[]).iter(),\n             VtableUnboxedClosure(..) => (&[]).iter(),\n-            VtableParam => (&[]).iter(),\n+            VtableParam(ref n) => n.iter(),\n             VtableObject(_) => (&[]).iter(),\n             VtableBuiltin(ref i) => i.iter_nested(),\n         }\n@@ -454,7 +456,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n             VtableFnPointer(ref sig) => VtableFnPointer((*sig).clone()),\n             VtableUnboxedClosure(d, ref s) => VtableUnboxedClosure(d, s.clone()),\n-            VtableParam => VtableParam,\n+            VtableParam(ref n) => VtableParam(n.iter().map(op).collect()),\n             VtableObject(ref p) => VtableObject(p.clone()),\n             VtableBuiltin(ref b) => VtableBuiltin(b.map_nested(op)),\n         }\n@@ -467,7 +469,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n             VtableFnPointer(sig) => VtableFnPointer(sig),\n             VtableUnboxedClosure(d, s) => VtableUnboxedClosure(d, s),\n-            VtableParam => VtableParam,\n+            VtableParam(n) => VtableParam(n.into_iter().map(op).collect()),\n             VtableObject(p) => VtableObject(p),\n             VtableBuiltin(no) => VtableBuiltin(no.map_move_nested(op)),\n         }"}, {"sha": "2520434f68f26335b22f272fe1496bfab4c407ee", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 83, "deletions": 21, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=055cc2ee742e29e389c5bd1da3a9d49ff8ca3724", "patch": "@@ -747,7 +747,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n-        try!(self.assemble_candidates_from_caller_bounds(obligation, &mut candidates));\n+        try!(self.assemble_candidates_from_caller_bounds(stack, &mut candidates));\n         debug!(\"candidate list size: {}\", candidates.vec.len());\n         Ok(candidates)\n     }\n@@ -884,13 +884,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// supplied to find out whether it is listed among them.\n     ///\n     /// Never affects inference environment.\n-    fn assemble_candidates_from_caller_bounds(&mut self,\n-                                              obligation: &TraitObligation<'tcx>,\n-                                              candidates: &mut SelectionCandidateSet<'tcx>)\n-                                              -> Result<(),SelectionError<'tcx>>\n+    fn assemble_candidates_from_caller_bounds<'o>(&mut self,\n+                                                  stack: &TraitObligationStack<'o, 'tcx>,\n+                                                  candidates: &mut SelectionCandidateSet<'tcx>)\n+                                                  -> Result<(),SelectionError<'tcx>>\n     {\n         debug!(\"assemble_candidates_from_caller_bounds({})\",\n-               obligation.repr(self.tcx()));\n+               stack.obligation.repr(self.tcx()));\n \n         let caller_trait_refs: Vec<_> =\n             self.param_env().caller_bounds.predicates.iter()\n@@ -903,8 +903,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let matching_bounds =\n             all_bounds.filter(\n-                |bound| self.infcx.probe(\n-                    |_| self.match_poly_trait_ref(obligation, bound.clone())).is_ok());\n+                |bound| self.evaluate_where_clause(stack, bound.clone()).may_apply());\n \n         let param_candidates =\n             matching_bounds.map(|bound| ParamCandidate(bound));\n@@ -914,6 +913,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(())\n     }\n \n+    fn evaluate_where_clause<'o>(&mut self,\n+                                 stack: &TraitObligationStack<'o, 'tcx>,\n+                                 where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n+                                 -> EvaluationResult<'tcx>\n+    {\n+        self.infcx().probe(move |_| {\n+            match self.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n+                Ok(obligations) => {\n+                    self.evaluate_predicates_recursively(Some(stack), obligations.iter())\n+                }\n+                Err(()) => {\n+                    EvaluatedToErr(Unimplemented)\n+                }\n+            }\n+        })\n+    }\n+\n     /// Check for the artificial impl that the compiler will create for an obligation like `X :\n     /// FnMut<..>` where `X` is an unboxed closure type.\n     ///\n@@ -1140,6 +1156,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                    candidate_j: &SelectionCandidate<'tcx>)\n                                                    -> bool\n     {\n+        if candidate_i == candidate_j {\n+            return true;\n+        }\n+\n         match (candidate_i, candidate_j) {\n             (&ImplCandidate(impl_def_id), &ParamCandidate(ref bound)) => {\n                 debug!(\"Considering whether to drop param {} in favor of impl {}\",\n@@ -1179,8 +1199,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // the where clauses are in scope.\n                 true\n             }\n+            (&ParamCandidate(ref bound1), &ParamCandidate(ref bound2)) => {\n+                self.infcx.probe(|_| {\n+                    let bound1 =\n+                        project::normalize_with_depth(self,\n+                                                      stack.obligation.cause.clone(),\n+                                                      stack.obligation.recursion_depth+1,\n+                                                      bound1);\n+                    let bound2 =\n+                        project::normalize_with_depth(self,\n+                                                      stack.obligation.cause.clone(),\n+                                                      stack.obligation.recursion_depth+1,\n+                                                      bound2);\n+                    let origin =\n+                        infer::RelateOutputImplTypes(stack.obligation.cause.span);\n+                    self.infcx\n+                        .sub_poly_trait_refs(false, origin, bound1.value, bound2.value)\n+                        .is_ok()\n+                })\n+            }\n             _ => {\n-                *candidate_i == *candidate_j\n+                false\n             }\n         }\n     }\n@@ -1548,8 +1587,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ParamCandidate(param) => {\n-                self.confirm_param_candidate(obligation, param);\n-                Ok(VtableParam)\n+                let obligations = self.confirm_param_candidate(obligation, param);\n+                Ok(VtableParam(obligations))\n             }\n \n             ImplCandidate(impl_def_id) => {\n@@ -1576,7 +1615,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ProjectionCandidate => {\n                 self.confirm_projection_candidate(obligation);\n-                Ok(VtableParam)\n+                Ok(VtableParam(Vec::new()))\n             }\n         }\n     }\n@@ -1597,6 +1636,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_param_candidate(&mut self,\n                                obligation: &TraitObligation<'tcx>,\n                                param: ty::PolyTraitRef<'tcx>)\n+                               -> Vec<PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_param_candidate({},{})\",\n                obligation.repr(self.tcx()),\n@@ -1606,11 +1646,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // where-clause trait-ref could be unified with the obligation\n         // trait-ref. Repeat that unification now without any\n         // transactional boundary; it should not fail.\n-        match self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                           obligation.predicate.to_poly_trait_ref(),\n-                                           param.clone()) {\n-            Ok(()) => { }\n-            Err(_) => {\n+        match self.match_where_clause_trait_ref(obligation, param.clone()) {\n+            Ok(obligations) => obligations,\n+            Err(()) => {\n                 self.tcx().sess.bug(\n                     format!(\"Where clause `{}` was applicable to `{}` but now is not\",\n                             param.repr(self.tcx()),\n@@ -2037,19 +2075,43 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n     }\n \n+    /// Normalize `where_clause_trait_ref` and try to match it against\n+    /// `obligation`.  If successful, return any predicates that\n+    /// result from the normalization. Normalization is necessary\n+    /// because where-clauses are stored in the parameter environment\n+    /// unnormalized.\n+    fn match_where_clause_trait_ref(&mut self,\n+                                    obligation: &TraitObligation<'tcx>,\n+                                    where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n+                                    -> Result<Vec<PredicateObligation<'tcx>>,()>\n+    {\n+        let where_clause_trait_ref =\n+            project::normalize_with_depth(self,\n+                                          obligation.cause.clone(),\n+                                          obligation.recursion_depth+1,\n+                                          &where_clause_trait_ref);\n+\n+        let () =\n+            try!(self.match_poly_trait_ref(obligation, where_clause_trait_ref.value.clone()));\n+\n+        Ok(where_clause_trait_ref.obligations)\n+    }\n+\n+    /// Returns `Ok` if `poly_trait_ref` being true implies that the\n+    /// obligation is satisfied.\n     fn match_poly_trait_ref(&mut self,\n                             obligation: &TraitObligation<'tcx>,\n-                            where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n+                            poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                             -> Result<(),()>\n     {\n-        debug!(\"match_poly_trait_ref: obligation={} where_clause_trait_ref={}\",\n+        debug!(\"match_poly_trait_ref: obligation={} poly_trait_ref={}\",\n                obligation.repr(self.tcx()),\n-               where_clause_trait_ref.repr(self.tcx()));\n+               poly_trait_ref.repr(self.tcx()));\n \n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n         match self.infcx.sub_poly_trait_refs(false,\n                                              origin,\n-                                             where_clause_trait_ref,\n+                                             poly_trait_ref,\n                                              obligation.predicate.to_poly_trait_ref()) {\n             Ok(()) => Ok(()),\n             Err(_) => Err(()),"}, {"sha": "fe8362223e3cd7393b333f4df5cf97af56ec1017", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=055cc2ee742e29e389c5bd1da3a9d49ff8ca3724", "patch": "@@ -380,8 +380,9 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n                 format!(\"VtableObject({})\",\n                         d.repr(tcx)),\n \n-            super::VtableParam =>\n-                format!(\"VtableParam\"),\n+            super::VtableParam(ref n) =>\n+                format!(\"VtableParam({})\",\n+                        n.repr(tcx)),\n \n             super::VtableBuiltin(ref d) =>\n                 d.repr(tcx)"}, {"sha": "cab41d665297879ace454b0d88fa5f5a0ab72e1c", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=055cc2ee742e29e389c5bd1da3a9d49ff8ca3724", "patch": "@@ -514,7 +514,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n             traits::VtableFnPointer(ref d) => {\n                 traits::VtableFnPointer(d.fold_with(folder))\n             }\n-            traits::VtableParam => traits::VtableParam,\n+            traits::VtableParam(ref n) => traits::VtableParam(n.fold_with(folder)),\n             traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n             traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n         }"}, {"sha": "493df366d2ae69c6e82a27e2892566b7f60bb3de", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=055cc2ee742e29e389c5bd1da3a9d49ff8ca3724", "patch": "@@ -736,7 +736,7 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     format!(\"cannot get vtable for an object type: {}\",\n                             data.repr(bcx.tcx())).as_slice());\n             }\n-            traits::VtableParam => {\n+            traits::VtableParam(..) => {\n                 bcx.sess().bug(\n                     &format!(\"resolved vtable for {} to bad vtable {} in trans\",\n                             trait_ref.repr(bcx.tcx()),"}, {"sha": "10a459f3c366268ba6dad0a4be210524b93c5495", "filename": "src/test/run-pass/associated-types-projection-in-where-clause.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/055cc2ee742e29e389c5bd1da3a9d49ff8ca3724/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-where-clause.rs?ref=055cc2ee742e29e389c5bd1da3a9d49ff8ca3724", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a where clause that uses a non-normalized projection type.\n+\n+trait Int\n+{\n+    type T;\n+}\n+\n+trait NonZero\n+{\n+    fn non_zero(self) -> bool;\n+}\n+\n+fn foo<I:Int<T=J>,J>(t: I) -> bool\n+    where <I as Int>::T : NonZero\n+    //    ^~~~~~~~~~~~~ canonical form is just J\n+{\n+    bar::<J>()\n+}\n+\n+fn bar<NZ:NonZero>() -> bool { true }\n+\n+fn main ()\n+{\n+}"}]}