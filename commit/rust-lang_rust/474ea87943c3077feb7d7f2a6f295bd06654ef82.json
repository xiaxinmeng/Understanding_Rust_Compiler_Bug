{"sha": "474ea87943c3077feb7d7f2a6f295bd06654ef82", "node_id": "C_kwDOAAsO6NoAKDQ3NGVhODc5NDNjMzA3N2ZlYjdkN2YyYTZmMjk1YmQwNjY1NGVmODI", "commit": {"author": {"name": "Michal Rostecki", "email": "vadorovsky@gmail.com", "date": "2023-01-16T11:40:38Z"}, "committer": {"name": "Michal Rostecki", "email": "vadorovsky@gmail.com", "date": "2023-01-25T02:44:03Z"}, "message": "core: Support variety of atomic widths in width-agnostic functions\n\nBefore this change, the following functions and macros were annotated\nwith `#[cfg(target_has_atomic = \"8\")]` or\n`#[cfg(target_has_atomic_load_store = \"8\")]`:\n\n* `atomic_int`\n* `strongest_failure_ordering`\n* `atomic_swap`\n* `atomic_add`\n* `atomic_sub`\n* `atomic_compare_exchange`\n* `atomic_compare_exchange_weak`\n* `atomic_and`\n* `atomic_nand`\n* `atomic_or`\n* `atomic_xor`\n* `atomic_max`\n* `atomic_min`\n* `atomic_umax`\n* `atomic_umin`\n\nHowever, none of those functions and macros actually depend on 8-bit\nwidth and they are needed for all atomic widths (16-bit, 32-bit, 64-bit\netc.). Some targets might not support 8-bit atomics (i.e. BPF, if we\nwould enable atomic CAS for it).\n\nThis change fixes that by removing the `\"8\"` argument from annotations,\nwhich results in accepting the whole variety of widths.\n\nFixes #106845\nFixes #106795\n\nSigned-off-by: Michal Rostecki <vadorovsky@gmail.com>", "tree": {"sha": "51073529a883beada14fe3803549e40d17f93e59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51073529a883beada14fe3803549e40d17f93e59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/474ea87943c3077feb7d7f2a6f295bd06654ef82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/474ea87943c3077feb7d7f2a6f295bd06654ef82", "html_url": "https://github.com/rust-lang/rust/commit/474ea87943c3077feb7d7f2a6f295bd06654ef82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/474ea87943c3077feb7d7f2a6f295bd06654ef82/comments", "author": {"login": "vadorovsky", "id": 34685103, "node_id": "MDQ6VXNlcjM0Njg1MTAz", "avatar_url": "https://avatars.githubusercontent.com/u/34685103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadorovsky", "html_url": "https://github.com/vadorovsky", "followers_url": "https://api.github.com/users/vadorovsky/followers", "following_url": "https://api.github.com/users/vadorovsky/following{/other_user}", "gists_url": "https://api.github.com/users/vadorovsky/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadorovsky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadorovsky/subscriptions", "organizations_url": "https://api.github.com/users/vadorovsky/orgs", "repos_url": "https://api.github.com/users/vadorovsky/repos", "events_url": "https://api.github.com/users/vadorovsky/events{/privacy}", "received_events_url": "https://api.github.com/users/vadorovsky/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vadorovsky", "id": 34685103, "node_id": "MDQ6VXNlcjM0Njg1MTAz", "avatar_url": "https://avatars.githubusercontent.com/u/34685103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadorovsky", "html_url": "https://github.com/vadorovsky", "followers_url": "https://api.github.com/users/vadorovsky/followers", "following_url": "https://api.github.com/users/vadorovsky/following{/other_user}", "gists_url": "https://api.github.com/users/vadorovsky/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadorovsky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadorovsky/subscriptions", "organizations_url": "https://api.github.com/users/vadorovsky/orgs", "repos_url": "https://api.github.com/users/vadorovsky/repos", "events_url": "https://api.github.com/users/vadorovsky/events{/privacy}", "received_events_url": "https://api.github.com/users/vadorovsky/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cd7dbfbf85599d764c403cb5fee555da16c003a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cd7dbfbf85599d764c403cb5fee555da16c003a", "html_url": "https://github.com/rust-lang/rust/commit/1cd7dbfbf85599d764c403cb5fee555da16c003a"}], "stats": {"total": 45, "additions": 30, "deletions": 15}, "files": [{"sha": "818721062d7f702aeba8df4096d55fbc6456427e", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/474ea87943c3077feb7d7f2a6f295bd06654ef82/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/474ea87943c3077feb7d7f2a6f295bd06654ef82/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=474ea87943c3077feb7d7f2a6f295bd06654ef82", "patch": "@@ -1861,7 +1861,8 @@ macro_rules! if_not_8_bit {\n     ($_:ident, $($tt:tt)*) => { $($tt)* };\n }\n \n-#[cfg(target_has_atomic_load_store = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic_load_store))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic_load_store = \"8\"))]\n macro_rules! atomic_int {\n     ($cfg_cas:meta,\n      $cfg_align:meta,\n@@ -2988,7 +2989,8 @@ atomic_int_ptr_sized! {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n         Release => Relaxed,\n@@ -3030,7 +3032,8 @@ unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_swap`.\n@@ -3047,7 +3050,8 @@ unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_add`.\n@@ -3064,7 +3068,8 @@ unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_sub`.\n@@ -3080,7 +3085,8 @@ unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_compare_exchange<T: Copy>(\n     dst: *mut T,\n@@ -3115,7 +3121,8 @@ unsafe fn atomic_compare_exchange<T: Copy>(\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_compare_exchange_weak<T: Copy>(\n     dst: *mut T,\n@@ -3150,7 +3157,8 @@ unsafe fn atomic_compare_exchange_weak<T: Copy>(\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_and`\n@@ -3166,7 +3174,8 @@ unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_nand`\n@@ -3182,7 +3191,8 @@ unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_or`\n@@ -3198,7 +3208,8 @@ unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_xor`\n@@ -3215,7 +3226,8 @@ unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_max`\n@@ -3232,7 +3244,8 @@ unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_min`\n@@ -3249,7 +3262,8 @@ unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (unsigned comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umax`\n@@ -3266,7 +3280,8 @@ unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (unsigned comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umin`"}]}