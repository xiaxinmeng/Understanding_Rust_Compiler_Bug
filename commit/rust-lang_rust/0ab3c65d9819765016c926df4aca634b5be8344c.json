{"sha": "0ab3c65d9819765016c926df4aca634b5be8344c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYjNjNjVkOTgxOTc2NTAxNmM5MjZkZjRhY2E2MzRiNWJlODM0NGM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-20T13:40:15Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-20T13:40:15Z"}, "message": "Use OO API in crate_for", "tree": {"sha": "5ab3d7e01d43f9325096ffd96668d4e67ca3fc05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ab3d7e01d43f9325096ffd96668d4e67ca3fc05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ab3c65d9819765016c926df4aca634b5be8344c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ab3c65d9819765016c926df4aca634b5be8344c", "html_url": "https://github.com/rust-lang/rust/commit/0ab3c65d9819765016c926df4aca634b5be8344c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ab3c65d9819765016c926df4aca634b5be8344c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d475e3b29f1783682b2ac78459e38668bb9f8c14", "url": "https://api.github.com/repos/rust-lang/rust/commits/d475e3b29f1783682b2ac78459e38668bb9f8c14", "html_url": "https://github.com/rust-lang/rust/commit/d475e3b29f1783682b2ac78459e38668bb9f8c14"}], "stats": {"total": 62, "additions": 50, "deletions": 12}, "files": [{"sha": "16faea94e99e648603a190c15e8be1c4508b04f3", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0ab3c65d9819765016c926df4aca634b5be8344c/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab3c65d9819765016c926df4aca634b5be8344c/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=0ab3c65d9819765016c926df4aca634b5be8344c", "patch": "@@ -6,6 +6,7 @@ use std::sync::Arc;\n use ra_editor::find_node_at_offset;\n \n use ra_syntax::{\n+    algo::generate,\n     ast::{self, AstNode, NameOwner},\n     SmolStr, SyntaxNode, SyntaxNodeRef,\n };\n@@ -27,21 +28,40 @@ pub(crate) struct ModuleDescriptor {\n }\n \n impl ModuleDescriptor {\n+    /// Lookup `ModuleDescriptor` by `FileId`. Note that this is inherently\n+    /// lossy transformation: in general, a single source might correspond to\n+    /// several modules.\n+    pub fn guess_from_file_id(\n+        db: &impl DescriptorDatabase,\n+        file_id: FileId,\n+    ) -> Cancelable<Option<ModuleDescriptor>> {\n+        ModuleDescriptor::guess_from_source(db, file_id, ModuleSource::SourceFile(file_id))\n+    }\n+\n     /// Lookup `ModuleDescriptor` by position in the source code. Note that this\n     /// is inherently lossy transformation: in general, a single source might\n     /// correspond to several modules.\n     pub fn guess_from_position(\n         db: &impl DescriptorDatabase,\n         position: FilePosition,\n     ) -> Cancelable<Option<ModuleDescriptor>> {\n-        let source_root = db.file_source_root(position.file_id);\n-        let module_tree = db.module_tree(source_root)?;\n         let file = db.file_syntax(position.file_id);\n         let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset)\n         {\n             Some(m) if !m.has_semi() => ModuleSource::new_inline(position.file_id, m),\n             _ => ModuleSource::SourceFile(position.file_id),\n         };\n+        ModuleDescriptor::guess_from_source(db, position.file_id, module_source)\n+    }\n+\n+    fn guess_from_source(\n+        db: &impl DescriptorDatabase,\n+        file_id: FileId,\n+        module_source: ModuleSource,\n+    ) -> Cancelable<Option<ModuleDescriptor>> {\n+        let source_root = db.file_source_root(file_id);\n+        let module_tree = db.module_tree(source_root)?;\n+\n         let res = match module_tree.any_module_for_source(module_source) {\n             None => None,\n             Some(module_id) => Some(ModuleDescriptor {\n@@ -64,13 +84,26 @@ impl ModuleDescriptor {\n         Some((file_id, src))\n     }\n \n+    pub fn source(&self) -> ModuleSource {\n+        self.module_id.source(&self.tree)\n+    }\n+\n+    /// Parent module. Returns `None` if this is a root module.\n     pub fn parent(&self) -> Option<ModuleDescriptor> {\n         let parent_id = self.module_id.parent(&self.tree)?;\n         Some(ModuleDescriptor {\n             tree: Arc::clone(&self.tree),\n             module_id: parent_id,\n         })\n     }\n+\n+    /// The root of the tree this module is part of\n+    pub fn crate_root(&self) -> ModuleDescriptor {\n+        generate(Some(self.clone()), |it| it.parent())\n+            .last()\n+            .unwrap()\n+    }\n+\n     /// `name` is `None` for the crate's root module\n     pub fn name(&self) -> Option<SmolStr> {\n         let link = self.module_id.parent_link(&self.tree)?;"}, {"sha": "49b86375641772b9c17b4352c858797c3f44802c", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0ab3c65d9819765016c926df4aca634b5be8344c/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ab3c65d9819765016c926df4aca634b5be8344c/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=0ab3c65d9819765016c926df4aca634b5be8344c", "patch": "@@ -220,6 +220,8 @@ impl AnalysisImpl {\n         let source_root = self.db.file_source_root(file_id);\n         self.db.module_tree(source_root)\n     }\n+    /// This return `Vec`: a module may be inclucded from several places.\n+    /// We don't handle this case yet though, so the Vec has length at most one.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n         let descr = match ModuleDescriptor::guess_from_position(&*self.db, position)? {\n             None => return Ok(Vec::new()),\n@@ -238,18 +240,21 @@ impl AnalysisImpl {\n         };\n         Ok(vec![(file_id, sym)])\n     }\n+    /// Returns `Vec` for the same reason as `parent_module`\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        let module_tree = self.module_tree(file_id)?;\n-        let crate_graph = self.db.crate_graph();\n-        let res = module_tree\n-            .modules_for_source(ModuleSource::SourceFile(file_id))\n-            .into_iter()\n-            .map(|it| it.root(&module_tree))\n-            .filter_map(|it| it.source(&module_tree).as_file())\n-            .filter_map(|it| crate_graph.crate_id_for_crate_root(it))\n-            .collect();\n+        let descr = match ModuleDescriptor::guess_from_file_id(&*self.db, file_id)? {\n+            None => return Ok(Vec::new()),\n+            Some(it) => it,\n+        };\n+        let root = descr.crate_root();\n+        let file_id = root\n+            .source()\n+            .as_file()\n+            .expect(\"root module always has a file as a source\");\n \n-        Ok(res)\n+        let crate_graph = self.db.crate_graph();\n+        let crate_id = crate_graph.crate_id_for_crate_root(file_id);\n+        Ok(crate_id.into_iter().collect())\n     }\n     pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n         self.db.crate_graph().crate_roots[&crate_id]"}]}