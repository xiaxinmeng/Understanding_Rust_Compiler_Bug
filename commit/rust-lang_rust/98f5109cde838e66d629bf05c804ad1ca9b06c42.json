{"sha": "98f5109cde838e66d629bf05c804ad1ca9b06c42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZjUxMDljZGU4MzhlNjZkNjI5YmYwNWM4MDRhZDFjYTliMDZjNDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-31T04:46:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-07T06:40:31Z"}, "message": "simplify task impl", "tree": {"sha": "097edb4079a90bd4db126927e15494e686b25fd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/097edb4079a90bd4db126927e15494e686b25fd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98f5109cde838e66d629bf05c804ad1ca9b06c42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98f5109cde838e66d629bf05c804ad1ca9b06c42", "html_url": "https://github.com/rust-lang/rust/commit/98f5109cde838e66d629bf05c804ad1ca9b06c42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98f5109cde838e66d629bf05c804ad1ca9b06c42/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e88905cd2882919f95084f41539ca9601ebf5cfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e88905cd2882919f95084f41539ca9601ebf5cfc", "html_url": "https://github.com/rust-lang/rust/commit/e88905cd2882919f95084f41539ca9601ebf5cfc"}], "stats": {"total": 263, "additions": 86, "deletions": 177}, "files": [{"sha": "81cb4a7f25c13bfdd192c17015613e5ac65b7967", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=98f5109cde838e66d629bf05c804ad1ca9b06c42", "patch": "@@ -33,7 +33,7 @@ import trans::{\n // struct closure_box {\n //    unsigned ref_count; // only used for sharid environments\n //    struct closure {\n-//      type_desc *tydesc;         // descriptor for the env type\n+//      type_desc *tydesc;         // descriptor for the \"struct closure\" type\n //      type_desc *bound_tdescs[]; // bound descriptors\n //      struct {\n //          upvar1_t upvar1;"}, {"sha": "07a859ad2f3d0778fa0c016acfcd56b8314b3bf4", "filename": "src/libcore/task.rs", "status": "modified", "additions": 53, "deletions": 127, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=98f5109cde838e66d629bf05c804ad1ca9b06c42", "patch": "@@ -31,6 +31,7 @@ import comm;\n import option::{some, none};\n import option = option::t;\n import ptr;\n+import c = ctypes;\n \n export task;\n export joinable_task;\n@@ -46,7 +47,6 @@ export tr_success;\n export tr_failure;\n export get_task;\n export spawn;\n-export spawn_notify;\n export spawn_joinable;\n \n #[abi = \"rust-intrinsic\"]\n@@ -55,6 +55,10 @@ native mod rusti {\n     fn task_sleep(task: *rust_task, time_in_us: uint, &killed: bool);\n }\n \n+type rust_closure = {\n+    fnptr: c::intptr_t, envptr: c::intptr_t\n+};\n+\n #[link_name = \"rustrt\"]\n #[abi = \"cdecl\"]\n native mod rustrt {\n@@ -70,8 +74,7 @@ native mod rustrt {\n \n     fn migrate_alloc(alloc: *u8, target: task_id);\n \n-    fn start_task(id: task, closure: *u8);\n-\n+    fn start_task(id: task, closure: *rust_closure);\n }\n \n /* Section: Types */\n@@ -93,13 +96,60 @@ A handle to a task\n */\n type task = task_id;\n \n+/*\n+Function: spawn\n+\n+Creates and executes a new child task\n+\n+Sets up a new task with its own call stack and schedules it to be\n+executed.  Upon execution, the closure `f()` will be invoked.\n+\n+Parameters:\n+\n+f - A function to execute in the new task\n+\n+Returns:\n+\n+A handle to the new task\n+*/\n+fn spawn(-f: sendfn()) -> task unsafe {\n+    let closure: *rust_closure = unsafe::reinterpret_cast(ptr::addr_of(f));\n+    #debug(\"spawn: closure={%x,%x}\", (*closure).fnptr, (*closure).envptr);\n+    let id = rustrt::new_task();\n+    rustrt::start_task(id, closure);\n+    unsafe::leak(f);\n+    ret id;\n+}\n+\n /*\n Type: joinable_task\n \n A task that sends notification upon termination\n */\n type joinable_task = (task, comm::port<task_notification>);\n \n+fn spawn_joinable(-f: sendfn()) -> joinable_task {\n+    resource notify_rsrc(data: (comm::chan<task_notification>,\n+                                task,\n+                                @mutable task_result)) {\n+        let (chan, task, tr) = data;\n+        let msg = exit(task, *tr);\n+        comm::send(chan, msg);\n+    }\n+\n+    let notify_port = comm::port();\n+    let notify_chan = comm::chan(notify_port);\n+    let g = sendfn[copy notify_chan; move f]() {\n+        let this_task = rustrt::get_task_id();\n+        let result = @mutable tr_failure;\n+        let _rsrc = notify_rsrc((notify_chan, this_task, result));\n+        f();\n+        *result = tr_success; // rsrc will fire msg when fn returns\n+    };\n+    let task = spawn(g);\n+    ret (task, notify_port);\n+}\n+\n /*\n Tag: task_result\n \n@@ -213,130 +263,6 @@ Unpin the current task and future child tasks\n */\n fn unpin() { rustrt::unpin_task(); }\n \n-/*\n-Function: spawn\n-\n-Creates and executes a new child task\n-\n-Sets up a new task with its own call stack and schedules it to be executed.\n-Upon execution the new task will call function `f` with the provided\n-argument `data`.\n-\n-Function `f` is a bare function, meaning it may not close over any data, as do\n-shared functions (fn@) and lambda blocks. `data` must be a uniquely owned\n-type; it is moved into the new task and thus can no longer be accessed\n-locally.\n-\n-Parameters:\n-\n-data - A unique-type value to pass to the new task\n-f - A function to execute in the new task\n-\n-Returns:\n-\n-A handle to the new task\n-*/\n-fn spawn<T: send>(-data: T, f: fn(T)) -> task {\n-    spawn_inner(data, f, none)\n-}\n-\n-/*\n-Function: spawn_notify\n-\n-Create and execute a new child task, requesting notification upon its\n-termination\n-\n-Immediately before termination, either on success or failure, the spawned\n-task will send a <task_notification> message on the provided channel.\n-*/\n-fn spawn_notify<T: send>(-data: T, f: fn(T),\n-                         notify: comm::chan<task_notification>) -> task {\n-    spawn_inner(data, f, some(notify))\n-}\n-\n-/*\n-Function: spawn_joinable\n-\n-Create and execute a task which can later be joined with the <join> function\n-\n-This is a convenience wrapper around spawn_notify which, when paired\n-with <join> can be easily used to spawn a task then wait for it to\n-complete.\n-*/\n-fn spawn_joinable<T: send>(-data: T, f: fn(T)) -> joinable_task {\n-    let p = comm::port::<task_notification>();\n-    let id = spawn_notify(data, f, comm::chan::<task_notification>(p));\n-    ret (id, p);\n-}\n-\n-// FIXME: To transition from the unsafe spawn that spawns a shared closure to\n-// the safe spawn that spawns a bare function we're going to write\n-// barefunc-spawn on top of unsafe-spawn.  Sadly, bind does not work reliably\n-// enough to suite our needs (#1034, probably others yet to be discovered), so\n-// we're going to copy the bootstrap data into a unique pointer, cast it to an\n-// unsafe pointer then wrap up the bare function and the unsafe pointer in a\n-// shared closure to spawn.\n-//\n-// After the transition this should all be rewritten.\n-\n-fn spawn_inner<T: send>(-data: T, f: fn(T),\n-                          notify: option<comm::chan<task_notification>>)\n-    -> task unsafe {\n-\n-    fn wrapper<T: send>(data: *u8, f: fn(T)) unsafe {\n-        let data: ~T = unsafe::reinterpret_cast(data);\n-        f(*data);\n-    }\n-\n-    let data = ~data;\n-    let dataptr: *u8 = unsafe::reinterpret_cast(data);\n-    unsafe::leak(data);\n-    let wrapped = bind wrapper(dataptr, f);\n-    ret unsafe_spawn_inner(wrapped, notify);\n-}\n-\n-// FIXME: This is the old spawn function that spawns a shared closure.\n-// It is a hack and needs to be rewritten.\n-fn unsafe_spawn_inner(-thunk: fn@(),\n-                      notify: option<comm::chan<task_notification>>) ->\n-   task unsafe {\n-    let id = rustrt::new_task();\n-\n-    let raw_thunk: {code: uint, env: uint} = cast(thunk);\n-\n-    // set up the task pointer\n-    let task_ptr <- rust_task_ptr(rustrt::get_task_pointer(id));\n-\n-    assert (ptr::null() != (**task_ptr).stack_ptr);\n-\n-    // copy the thunk from our stack to the new stack\n-    let sp: uint = cast((**task_ptr).stack_ptr);\n-    let ptrsize = sys::size_of::<*u8>();\n-    let thunkfn: *mutable uint = cast(sp - ptrsize * 2u);\n-    let thunkenv: *mutable uint = cast(sp - ptrsize);\n-    *thunkfn = cast(raw_thunk.code);;\n-    *thunkenv = cast(raw_thunk.env);;\n-    // Advance the stack pointer. No need to align because\n-    // the native code will do that for us\n-    (**task_ptr).stack_ptr = cast(sp - ptrsize * 2u);\n-\n-    // set up notifications if they are enabled.\n-    alt notify {\n-      some(c) {\n-        (**task_ptr).notify_enabled = 1;\n-        (**task_ptr).notify_chan = c;\n-      }\n-      none { }\n-    }\n-\n-    // give the thunk environment's allocation to the new task\n-    rustrt::migrate_alloc(cast(raw_thunk.env), id);\n-    rustrt::start_task(id, cast(thunkfn));\n-    // don't cleanup the thunk in this task\n-    unsafe::leak(thunk);\n-    ret id;\n-}\n-\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "f17029d3fcd8a2949efa79d406c5d1ee0f6e3f86", "filename": "src/libstd/test.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=98f5109cde838e66d629bf05c804ad1ca9b06c42", "patch": "@@ -49,7 +49,7 @@ type test_name = str;\n // to support isolation of tests into tasks.\n type test_fn<T> = T;\n \n-type default_test_fn = test_fn<fn()>;\n+type default_test_fn = test_fn<sendfn()>;\n \n // The definition of a single test. A test runner will run a list of\n // these.\n@@ -336,11 +336,10 @@ fn run_test<T: copy>(test: test_desc<T>,\n // We need to run our tests in another task in order to trap test failures.\n // This function only works with functions that don't contain closures.\n fn default_test_to_task(&&f: default_test_fn) -> joinable {\n-    fn run_task(f: default_test_fn) {\n+    ret task::spawn_joinable(sendfn[copy f]() {\n         configure_test_task();\n         f();\n-    }\n-    ret task::spawn_joinable(copy f, run_task);\n+    });\n }\n \n // Call from within a test task to make sure it's set up correctly"}, {"sha": "a3b30c26e5b128cfaecebf76a2ada664f611f0d8", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=98f5109cde838e66d629bf05c804ad1ca9b06c42", "patch": "@@ -98,7 +98,7 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n         DLOG(sched, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n     }\n \n-    root_task->start(main_fn, (uintptr_t)args->args);\n+    root_task->start((spawn_fn)main_fn, (uintptr_t)args->args);\n     root_task->deref();\n     root_task = NULL;\n \n@@ -119,6 +119,5 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n //"}, {"sha": "b387078a75ab5e3829ff263e3b682f3cd87dc5fa", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=98f5109cde838e66d629bf05c804ad1ca9b06c42", "patch": "@@ -2,6 +2,7 @@\n \n #include \"rust_internal.h\"\n #include \"rust_scheduler.h\"\n+#include \"rust_task.h\"\n \n #if !defined(__WIN32__)\n #include <sys/time.h>\n@@ -424,18 +425,11 @@ struct fn_env_pair {\n     intptr_t env;\n };\n \n-// FIXME This is probably not needed at all anymore. Have to rearrange some\n-// argument passing to remove it.\n-void rust_spawn_wrapper(void* retptr, void* envptr,\n-                        void(*func)(void*, void*)) {\n-    func(retptr, envptr);\n-}\n-\n extern \"C\" CDECL void\n start_task(rust_task_id id, fn_env_pair *f) {\n     rust_task *task = rust_scheduler::get_task();\n     rust_task *target = task->kernel->get_task_by_id(id);\n-    target->start((uintptr_t)rust_spawn_wrapper, f->f, f->env);\n+    target->start((spawn_fn)f->f, f->env);\n     target->deref();\n }\n \n@@ -578,6 +572,5 @@ port_recv(uintptr_t *dptr, rust_port *port,\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n //"}, {"sha": "f63e8d8d4c0178fc20edd5fd4360cfac01fc884c", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=98f5109cde838e66d629bf05c804ad1ca9b06c42", "patch": "@@ -292,14 +292,18 @@ rust_task::~rust_task()\n \n struct spawn_args {\n     rust_task *task;\n-    uintptr_t a3;\n-    uintptr_t a4;\n-    void (*CDECL f)(int *, uintptr_t, uintptr_t);\n+    uintptr_t envptr;\n+    spawn_fn f;\n };\n \n-struct rust_closure_env {\n+struct rust_closure {\n+    const type_desc *td;\n+    // ... see trans_closure.rs for full description ...\n+};\n+\n+struct rust_boxed_closure {\n     intptr_t ref_count;\n-    type_desc *td;\n+    rust_closure closure;\n };\n \n struct cleanup_args {\n@@ -315,13 +319,12 @@ cleanup_task(cleanup_args *args) {\n \n     cc::do_cc(task);\n \n-    rust_closure_env* env = (rust_closure_env*)a->a3;\n-    if(env) {\n+    rust_boxed_closure* boxed_env = (rust_boxed_closure*)a->envptr;\n+    if(boxed_env) {\n         // free the environment.\n-        I(task->sched, 1 == env->ref_count); // the ref count better be 1\n-        //env->td->drop_glue(NULL, task, NULL, env->td->first_param, env);\n-        //env->td->free_glue(NULL, task, NULL, env->td->first_param, env);\n-        task->free(env);\n+        rust_closure *env = &boxed_env->closure;\n+        env->td->drop_glue(NULL, NULL, &env->td, env);\n+        env->td->free_glue(NULL, NULL, &env->td, env);\n     }\n \n     task->die();\n@@ -347,11 +350,12 @@ extern \"C\" CDECL\n void task_start_wrapper(spawn_args *a)\n {\n     rust_task *task = a->task;\n-    int rval = 42;\n \n     bool failed = false;\n     try {\n-        a->f(&rval, a->a3, a->a4);\n+        // The first argument is the return pointer; as the task fn \n+        // must have void return type, we can safely pass 0.\n+        a->f(0, a->envptr);\n     } catch (rust_task *ex) {\n         A(task->sched, ex == task,\n           \"Expected this task to be thrown for unwinding\");\n@@ -367,12 +371,11 @@ void task_start_wrapper(spawn_args *a)\n }\n \n void\n-rust_task::start(uintptr_t spawnee_fn,\n-                 uintptr_t args,\n+rust_task::start(spawn_fn spawnee_fn,\n                  uintptr_t env)\n {\n     LOG(this, task, \"starting task from fn 0x%\" PRIxPTR\n-        \" with args 0x%\" PRIxPTR, spawnee_fn, args);\n+        \" with env 0x%\" PRIxPTR, spawnee_fn, env);\n \n     I(sched, stk->data != NULL);\n \n@@ -383,23 +386,14 @@ rust_task::start(uintptr_t spawnee_fn,\n     spawn_args *a = (spawn_args *)sp;\n \n     a->task = this;\n-    a->a3 = env;\n-    a->a4 = args;\n-    void **f = (void **)&a->f;\n-    *f = (void *)spawnee_fn;\n+    a->envptr = env;\n+    a->f = spawnee_fn;\n \n     ctx.call((void *)task_start_wrapper, a, sp);\n \n     this->start();\n }\n \n-void\n-rust_task::start(uintptr_t spawnee_fn,\n-                 uintptr_t args)\n-{\n-    start(spawnee_fn, args, 0);\n-}\n-\n void rust_task::start()\n {\n     yield_timer.reset_us(0);"}, {"sha": "2c8e9809c7abd68ec256c786e31f27392fffae53", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=98f5109cde838e66d629bf05c804ad1ca9b06c42", "patch": "@@ -21,6 +21,8 @@ struct chan_handle {\n     rust_port_id port;\n };\n \n+typedef void (*CDECL spawn_fn)(uintptr_t, uintptr_t);\n+\n struct rust_box;\n \n struct stk_seg {\n@@ -132,10 +134,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n \n     ~rust_task();\n \n-    void start(uintptr_t spawnee_fn,\n-               uintptr_t args,\n-               uintptr_t env);\n-    void start(uintptr_t spawnee_fn,\n+    void start(spawn_fn spawnee_fn,\n                uintptr_t args);\n     void start();\n     bool running();\n@@ -212,7 +211,6 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n //\n "}, {"sha": "644a23f28b1b92b2913a7d1b2e272d42360f81b5", "filename": "src/rt/test/rust_test_runtime.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Frt%2Ftest%2Frust_test_runtime.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/98f5109cde838e66d629bf05c804ad1ca9b06c42/src%2Frt%2Ftest%2Frust_test_runtime.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Ftest%2Frust_test_runtime.cpp?ref=98f5109cde838e66d629bf05c804ad1ca9b06c42", "patch": "@@ -39,15 +39,15 @@ rust_domain_test::run() {\n     return true;\n }\n \n-void task_entry() {\n+void task_entry(uintptr_t retptr, uintptr_t env) {\n     printf(\"task entry\\n\");\n }\n \n void\n rust_task_test::worker::run() {\n     rust_task_id root_id = kernel->create_task(NULL, \"main\");\n     rust_task *root_task = kernel->get_task_by_id(root_id);\n-    root_task->start((uintptr_t)&task_entry, (uintptr_t)NULL);\n+    root_task->start(&task_entry, (uintptr_t)NULL);\n     root_task->sched->start_main_loop();\n }\n "}]}