{"sha": "c5483822520e9c754f3ec8b9eb8e68bd5ef7c373", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NDgzODIyNTIwZTljNzU0ZjNlYzhiOWViOGU2OGJkNWVmN2MzNzM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-04T13:58:22Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-04T13:58:22Z"}, "message": "move atoms to a separate file", "tree": {"sha": "5c1b0cd74781a4289c3b6269d5e77e9fc69eadd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c1b0cd74781a4289c3b6269d5e77e9fc69eadd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5483822520e9c754f3ec8b9eb8e68bd5ef7c373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5483822520e9c754f3ec8b9eb8e68bd5ef7c373", "html_url": "https://github.com/rust-lang/rust/commit/c5483822520e9c754f3ec8b9eb8e68bd5ef7c373", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5483822520e9c754f3ec8b9eb8e68bd5ef7c373/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23cbe7fd4a048ba44aee647b3b7d5a7f3aa575da", "url": "https://api.github.com/repos/rust-lang/rust/commits/23cbe7fd4a048ba44aee647b3b7d5a7f3aa575da", "html_url": "https://github.com/rust-lang/rust/commit/23cbe7fd4a048ba44aee647b3b7d5a7f3aa575da"}], "stats": {"total": 985, "additions": 494, "deletions": 491}, "files": [{"sha": "ecca2a3f9d814bd173752d11c44e6d433c101d76", "filename": "src/grammar/expressions.rs", "status": "removed", "additions": 0, "deletions": 491, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/23cbe7fd4a048ba44aee647b3b7d5a7f3aa575da/src%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23cbe7fd4a048ba44aee647b3b7d5a7f3aa575da/src%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fexpressions.rs?ref=23cbe7fd4a048ba44aee647b3b7d5a7f3aa575da", "patch": "@@ -1,491 +0,0 @@\n-use super::*;\n-\n-// test expr_literals\n-// fn foo() {\n-//     let _ = true;\n-//     let _ = false;\n-//     let _ = 1;\n-//     let _ = 2.0;\n-//     let _ = b'a';\n-//     let _ = 'b';\n-//     let _ = \"c\";\n-//     let _ = r\"d\";\n-//     let _ = b\"e\";\n-//     let _ = br\"f\";\n-// }\n-const LITERAL_FIRST: TokenSet =\n-    token_set![TRUE_KW, FALSE_KW, INT_NUMBER, FLOAT_NUMBER, BYTE, CHAR,\n-               STRING, RAW_STRING, BYTE_STRING, RAW_BYTE_STRING];\n-\n-pub(super) fn literal(p: &mut Parser) -> Option<CompletedMarker> {\n-    if !LITERAL_FIRST.contains(p.current()) {\n-        return None;\n-    }\n-    let m = p.start();\n-    p.bump();\n-    Some(m.complete(p, LITERAL))\n-}\n-\n-const EXPR_FIRST: TokenSet = PREFIX_EXPR_FIRST;\n-\n-pub(super) fn expr(p: &mut Parser) {\n-    expr_bp(p, 1)\n-}\n-\n-fn bp_of(op: SyntaxKind) -> u8 {\n-    match op {\n-        EQEQ | NEQ => 1,\n-        MINUS | PLUS => 2,\n-        STAR | SLASH => 3,\n-        _ => 0\n-    }\n-}\n-\n-\n-// test expr_binding_power\n-// fn foo() {\n-//     1 + 2 * 3 == 1 * 2 + 3\n-// }\n-\n-// Parses expression with binding power of at least bp.\n-fn expr_bp(p: &mut Parser, bp: u8) {\n-    let mut lhs = match unary_expr(p) {\n-        Some(lhs) => lhs,\n-        None => return,\n-    };\n-\n-    loop {\n-        let op_bp = bp_of(p.current());\n-        if op_bp < bp {\n-            break;\n-        }\n-        lhs = bin_expr(p, lhs, op_bp);\n-    }\n-}\n-\n-fn unary_expr(p: &mut Parser) -> Option<CompletedMarker> {\n-    let done = match p.current() {\n-        AMPERSAND => ref_expr(p),\n-        STAR => deref_expr(p),\n-        EXCL => not_expr(p),\n-        _ => {\n-            let lhs = atom_expr(p)?;\n-            postfix_expr(p, lhs)\n-        }\n-    };\n-    Some(done)\n-}\n-\n-fn postfix_expr(p: &mut Parser, mut lhs: CompletedMarker) -> CompletedMarker {\n-    loop {\n-        lhs = match p.current() {\n-            L_PAREN => call_expr(p, lhs),\n-            DOT if p.nth(1) == IDENT => if p.nth(2) == L_PAREN {\n-                method_call_expr(p, lhs)\n-            } else {\n-                field_expr(p, lhs)\n-            },\n-            DOT if p.nth(1) == INT_NUMBER => field_expr(p, lhs),\n-            QUESTION => try_expr(p, lhs),\n-            _ => break,\n-        }\n-    }\n-    lhs\n-}\n-\n-// test block\n-// fn a() {}\n-// fn b() { let _ = 1; }\n-// fn c() { 1; 2; }\n-// fn d() { 1; 2 }\n-pub(super) fn block(p: &mut Parser) {\n-    if !p.at(L_CURLY) {\n-        p.error(\"expected block\");\n-        return;\n-    }\n-    block_expr(p);\n-}\n-\n-// test let_stmt;\n-// fn foo() {\n-//     let a;\n-//     let b: i32;\n-//     let c = 92;\n-//     let d: i32 = 92;\n-// }\n-fn let_stmt(p: &mut Parser) {\n-    assert!(p.at(LET_KW));\n-    let m = p.start();\n-    p.bump();\n-    patterns::pattern(p);\n-    if p.at(COLON) {\n-        types::ascription(p);\n-    }\n-    if p.eat(EQ) {\n-        expressions::expr(p);\n-    }\n-    p.expect(SEMI);\n-    m.complete(p, LET_STMT);\n-}\n-\n-const PREFIX_EXPR_FIRST: TokenSet =\n-    token_set_union![\n-        token_set![AMPERSAND, STAR, EXCL],\n-        ATOM_EXPR_FIRST,\n-    ];\n-\n-// test ref_expr\n-// fn foo() {\n-//     let _ = &1;\n-//     let _ = &mut &f();\n-// }\n-fn ref_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(AMPERSAND));\n-    let m = p.start();\n-    p.bump();\n-    p.eat(MUT_KW);\n-    expr(p);\n-    m.complete(p, REF_EXPR)\n-}\n-\n-// test deref_expr\n-// fn foo() {\n-//     **&1;\n-// }\n-fn deref_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(STAR));\n-    let m = p.start();\n-    p.bump();\n-    expr(p);\n-    m.complete(p, DEREF_EXPR)\n-}\n-\n-// test not_expr\n-// fn foo() {\n-//     !!true;\n-// }\n-fn not_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(EXCL));\n-    let m = p.start();\n-    p.bump();\n-    expr(p);\n-    m.complete(p, NOT_EXPR)\n-}\n-\n-const ATOM_EXPR_FIRST: TokenSet =\n-    token_set_union![\n-        LITERAL_FIRST,\n-        token_set![L_PAREN, PIPE, MOVE_KW, IF_KW, UNSAFE_KW, L_CURLY, RETURN_KW],\n-    ];\n-\n-fn atom_expr(p: &mut Parser) -> Option<CompletedMarker> {\n-    match literal(p) {\n-        Some(m) => return Some(m),\n-        None => (),\n-    }\n-    if paths::is_path_start(p) {\n-        return Some(path_expr(p));\n-    }\n-    let la = p.nth(1);\n-    let done = match p.current() {\n-        L_PAREN => tuple_expr(p),\n-        PIPE => lambda_expr(p),\n-        MOVE_KW if la == PIPE => lambda_expr(p),\n-        IF_KW => if_expr(p),\n-        MATCH_KW => match_expr(p),\n-        UNSAFE_KW if la == L_CURLY => block_expr(p),\n-        L_CURLY => block_expr(p),\n-        RETURN_KW => return_expr(p),\n-        _ => {\n-            p.err_and_bump(\"expected expression\");\n-            return None;\n-        }\n-    };\n-    Some(done)\n-}\n-\n-fn tuple_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(L_PAREN));\n-    let m = p.start();\n-    p.expect(L_PAREN);\n-    p.expect(R_PAREN);\n-    m.complete(p, TUPLE_EXPR)\n-}\n-\n-// test lambda_expr\n-// fn foo() {\n-//     || ();\n-//     || -> i32 { 92 };\n-//     |x| x;\n-//     move |x: i32,| x;\n-// }\n-fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(PIPE) || (p.at(MOVE_KW) && p.nth(1) == PIPE));\n-    let m = p.start();\n-    p.eat(MOVE_KW);\n-    params::param_list_opt_types(p);\n-    if fn_ret_type(p) {\n-        block(p);\n-    } else {\n-        expr(p)\n-    }\n-    m.complete(p, LAMBDA_EXPR)\n-}\n-\n-// test if_expr\n-// fn foo() {\n-//     if true {};\n-//     if true {} else {};\n-//     if true {} else if false {} else {}\n-// }\n-fn if_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(IF_KW));\n-    let m = p.start();\n-    if_head(p);\n-    block(p);\n-    if p.at(ELSE_KW) {\n-        p.bump();\n-        if p.at(IF_KW) {\n-            if_expr(p);\n-        } else {\n-            block(p);\n-        }\n-    }\n-    m.complete(p, IF_EXPR)\n-}\n-\n-fn if_head(p: &mut Parser) {\n-    assert!(p.at(IF_KW));\n-    p.bump();\n-    expr(p);\n-}\n-\n-// test match_expr\n-// fn foo() {\n-//     match () { };\n-// }\n-fn match_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(MATCH_KW));\n-    let m = p.start();\n-    p.bump();\n-    expr(p);\n-    p.eat(L_CURLY);\n-    while !p.at(EOF) && !p.at(R_CURLY) {\n-        match_arm(p);\n-        if !p.at(R_CURLY) {\n-            p.expect(COMMA);\n-        }\n-    }\n-    p.expect(R_CURLY);\n-    m.complete(p, MATCH_EXPR)\n-}\n-\n-// test match_arm\n-// fn foo() {\n-//     match () {\n-//         _ => (),\n-//         X | Y if Z => (),\n-//     };\n-// }\n-fn match_arm(p: &mut Parser) {\n-    let m = p.start();\n-    loop {\n-        patterns::pattern(p);\n-        if !p.eat(PIPE) {\n-            break;\n-        }\n-    }\n-    if p.at(IF_KW) {\n-        if_head(p)\n-    }\n-    p.expect(FAT_ARROW);\n-    expr(p);\n-    m.complete(p, MATCH_ARM);\n-}\n-\n-// test block_expr\n-// fn foo() {\n-//     {};\n-//     unsafe {};\n-// }\n-fn block_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(L_CURLY) || p.at(UNSAFE_KW) && p.nth(1) == L_CURLY);\n-    let m = p.start();\n-    p.eat(UNSAFE_KW);\n-    p.bump();\n-    while !p.at(EOF) && !p.at(R_CURLY) {\n-        match p.current() {\n-            LET_KW => let_stmt(p),\n-            _ => {\n-                // test block_items\n-                // fn a() { fn b() {} }\n-                let m = p.start();\n-                match items::maybe_item(p) {\n-                    items::MaybeItem::Item(kind) => {\n-                        m.complete(p, kind);\n-                    }\n-                    items::MaybeItem::Modifiers => {\n-                        m.abandon(p);\n-                        p.error(\"expected an item\");\n-                    }\n-                    // test pub_expr\n-                    // fn foo() { pub 92; } //FIXME\n-                    items::MaybeItem::None => {\n-                        expressions::expr(p);\n-                        if p.eat(SEMI) {\n-                            m.complete(p, EXPR_STMT);\n-                        } else {\n-                            m.abandon(p);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    p.expect(R_CURLY);\n-    m.complete(p, BLOCK_EXPR)\n-}\n-\n-// test return_expr\n-// fn foo() {\n-//     return;\n-//     return 92;\n-// }\n-fn return_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(RETURN_KW));\n-    let m = p.start();\n-    p.bump();\n-    if EXPR_FIRST.contains(p.current()) {\n-        expr(p);\n-    }\n-    m.complete(p, RETURN_EXPR)\n-}\n-\n-// test call_expr\n-// fn foo() {\n-//     let _ = f();\n-//     let _ = f()(1)(1, 2,);\n-// }\n-fn call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(L_PAREN));\n-    let m = lhs.precede(p);\n-    arg_list(p);\n-    m.complete(p, CALL_EXPR)\n-}\n-\n-// test method_call_expr\n-// fn foo() {\n-//     x.foo();\n-//     y.bar(1, 2,);\n-// }\n-fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(DOT) && p.nth(1) == IDENT && p.nth(2) == L_PAREN);\n-    let m = lhs.precede(p);\n-    p.bump();\n-    name_ref(p);\n-    arg_list(p);\n-    m.complete(p, METHOD_CALL_EXPR)\n-}\n-\n-// test field_expr\n-// fn foo() {\n-//     x.foo;\n-//     x.0.bar;\n-// }\n-fn field_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(DOT) && (p.nth(1) == IDENT || p.nth(1) == INT_NUMBER));\n-    let m = lhs.precede(p);\n-    p.bump();\n-    if p.at(IDENT) {\n-        name_ref(p)\n-    } else {\n-        p.bump()\n-    }\n-    m.complete(p, FIELD_EXPR)\n-}\n-\n-// test try_expr\n-// fn foo() {\n-//     x?;\n-// }\n-fn try_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(QUESTION));\n-    let m = lhs.precede(p);\n-    p.bump();\n-    m.complete(p, TRY_EXPR)\n-}\n-\n-fn arg_list(p: &mut Parser) {\n-    assert!(p.at(L_PAREN));\n-    let m = p.start();\n-    p.bump();\n-    while !p.at(R_PAREN) && !p.at(EOF) {\n-        expr(p);\n-        if !p.at(R_PAREN) && !p.expect(COMMA) {\n-            break;\n-        }\n-    }\n-    p.eat(R_PAREN);\n-    m.complete(p, ARG_LIST);\n-}\n-\n-// test path_expr\n-// fn foo() {\n-//     let _ = a;\n-//     let _ = a::b;\n-//     let _ = ::a::<b>;\n-// }\n-fn path_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(paths::is_path_start(p));\n-    let m = p.start();\n-    paths::expr_path(p);\n-    if p.at(L_CURLY) {\n-        struct_lit(p);\n-        m.complete(p, STRUCT_LIT)\n-    } else {\n-        m.complete(p, PATH_EXPR)\n-    }\n-}\n-\n-// test struct_lit\n-// fn foo() {\n-//     S {};\n-//     S { x, y: 32, };\n-//     S { x, y: 32, ..Default::default() };\n-// }\n-fn struct_lit(p: &mut Parser) {\n-    assert!(p.at(L_CURLY));\n-    p.bump();\n-    while !p.at(EOF) && !p.at(R_CURLY) {\n-        match p.current() {\n-            IDENT => {\n-                let m = p.start();\n-                name_ref(p);\n-                if p.eat(COLON) {\n-                    expr(p);\n-                }\n-                m.complete(p, STRUCT_LIT_FIELD);\n-            }\n-            DOTDOT => {\n-                p.bump();\n-                expr(p);\n-            }\n-            _ => p.err_and_bump(\"expected identifier\"),\n-        }\n-        if !p.at(R_CURLY) {\n-            p.expect(COMMA);\n-        }\n-    }\n-    p.expect(R_CURLY);\n-}\n-\n-fn bin_expr(p: &mut Parser, lhs: CompletedMarker, bp: u8) -> CompletedMarker {\n-    assert!(match p.current() {\n-        MINUS | PLUS | STAR | SLASH | EQEQ | NEQ => true,\n-        _ => false,\n-    });\n-    let m = lhs.precede(p);\n-    p.bump();\n-    expr_bp(p, bp);\n-    m.complete(p, BIN_EXPR)\n-}"}, {"sha": "95c81173076169934cf898392171094a1592571d", "filename": "src/grammar/expressions/atom.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/c5483822520e9c754f3ec8b9eb8e68bd5ef7c373/src%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5483822520e9c754f3ec8b9eb8e68bd5ef7c373/src%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fexpressions%2Fatom.rs?ref=c5483822520e9c754f3ec8b9eb8e68bd5ef7c373", "patch": "@@ -0,0 +1,239 @@\n+use super::*;\n+\n+// test expr_literals\n+// fn foo() {\n+//     let _ = true;\n+//     let _ = false;\n+//     let _ = 1;\n+//     let _ = 2.0;\n+//     let _ = b'a';\n+//     let _ = 'b';\n+//     let _ = \"c\";\n+//     let _ = r\"d\";\n+//     let _ = b\"e\";\n+//     let _ = br\"f\";\n+// }\n+const LITERAL_FIRST: TokenSet =\n+    token_set![TRUE_KW, FALSE_KW, INT_NUMBER, FLOAT_NUMBER, BYTE, CHAR,\n+               STRING, RAW_STRING, BYTE_STRING, RAW_BYTE_STRING];\n+\n+pub(crate) fn literal(p: &mut Parser) -> Option<CompletedMarker> {\n+    if !LITERAL_FIRST.contains(p.current()) {\n+        return None;\n+    }\n+    let m = p.start();\n+    p.bump();\n+    Some(m.complete(p, LITERAL))\n+}\n+\n+pub(super) const ATOM_EXPR_FIRST: TokenSet =\n+    token_set_union![\n+        LITERAL_FIRST,\n+        token_set![L_PAREN, PIPE, MOVE_KW, IF_KW, MATCH_KW, UNSAFE_KW, L_CURLY, RETURN_KW,\n+                   IDENT, SELF_KW, SUPER_KW, COLONCOLON ],\n+    ];\n+\n+pub(super) fn atom_expr(p: &mut Parser) -> Option<CompletedMarker> {\n+    match literal(p) {\n+        Some(m) => return Some(m),\n+        None => (),\n+    }\n+    if paths::is_path_start(p) {\n+        return Some(path_expr(p));\n+    }\n+    let la = p.nth(1);\n+    let done = match p.current() {\n+        L_PAREN => tuple_expr(p),\n+        PIPE => lambda_expr(p),\n+        MOVE_KW if la == PIPE => lambda_expr(p),\n+        IF_KW => if_expr(p),\n+        MATCH_KW => match_expr(p),\n+        UNSAFE_KW if la == L_CURLY => block_expr(p),\n+        L_CURLY => block_expr(p),\n+        RETURN_KW => return_expr(p),\n+        _ => {\n+            p.err_and_bump(\"expected expression\");\n+            return None;\n+        }\n+    };\n+    Some(done)\n+}\n+\n+fn tuple_expr(p: &mut Parser) -> CompletedMarker {\n+    assert!(p.at(L_PAREN));\n+    let m = p.start();\n+    p.expect(L_PAREN);\n+    p.expect(R_PAREN);\n+    m.complete(p, TUPLE_EXPR)\n+}\n+\n+// test lambda_expr\n+// fn foo() {\n+//     || ();\n+//     || -> i32 { 92 };\n+//     |x| x;\n+//     move |x: i32,| x;\n+// }\n+fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n+    assert!(p.at(PIPE) || (p.at(MOVE_KW) && p.nth(1) == PIPE));\n+    let m = p.start();\n+    p.eat(MOVE_KW);\n+    params::param_list_opt_types(p);\n+    if fn_ret_type(p) {\n+        block(p);\n+    } else {\n+        expr(p)\n+    }\n+    m.complete(p, LAMBDA_EXPR)\n+}\n+\n+// test if_expr\n+// fn foo() {\n+//     if true {};\n+//     if true {} else {};\n+//     if true {} else if false {} else {}\n+// }\n+fn if_expr(p: &mut Parser) -> CompletedMarker {\n+    assert!(p.at(IF_KW));\n+    let m = p.start();\n+    if_head(p);\n+    block(p);\n+    if p.at(ELSE_KW) {\n+        p.bump();\n+        if p.at(IF_KW) {\n+            if_expr(p);\n+        } else {\n+            block(p);\n+        }\n+    }\n+    m.complete(p, IF_EXPR)\n+}\n+\n+fn if_head(p: &mut Parser) {\n+    assert!(p.at(IF_KW));\n+    p.bump();\n+    expr(p);\n+}\n+\n+// test match_expr\n+// fn foo() {\n+//     match () { };\n+// }\n+fn match_expr(p: &mut Parser) -> CompletedMarker {\n+    assert!(p.at(MATCH_KW));\n+    let m = p.start();\n+    p.bump();\n+    expr(p);\n+    p.eat(L_CURLY);\n+    while !p.at(EOF) && !p.at(R_CURLY) {\n+        match_arm(p);\n+        if !p.at(R_CURLY) {\n+            p.expect(COMMA);\n+        }\n+    }\n+    p.expect(R_CURLY);\n+    m.complete(p, MATCH_EXPR)\n+}\n+\n+// test match_arm\n+// fn foo() {\n+//     match () {\n+//         _ => (),\n+//         X | Y if Z => (),\n+//     };\n+// }\n+fn match_arm(p: &mut Parser) {\n+    let m = p.start();\n+    loop {\n+        patterns::pattern(p);\n+        if !p.eat(PIPE) {\n+            break;\n+        }\n+    }\n+    if p.at(IF_KW) {\n+        if_head(p)\n+    }\n+    p.expect(FAT_ARROW);\n+    expr(p);\n+    m.complete(p, MATCH_ARM);\n+}\n+\n+// test block_expr\n+// fn foo() {\n+//     {};\n+//     unsafe {};\n+// }\n+pub(super) fn block_expr(p: &mut Parser) -> CompletedMarker {\n+    assert!(p.at(L_CURLY) || p.at(UNSAFE_KW) && p.nth(1) == L_CURLY);\n+    let m = p.start();\n+    p.eat(UNSAFE_KW);\n+    p.bump();\n+    while !p.at(EOF) && !p.at(R_CURLY) {\n+        match p.current() {\n+            LET_KW => let_stmt(p),\n+            _ => {\n+                // test block_items\n+                // fn a() { fn b() {} }\n+                let m = p.start();\n+                match items::maybe_item(p) {\n+                    items::MaybeItem::Item(kind) => {\n+                        m.complete(p, kind);\n+                    }\n+                    items::MaybeItem::Modifiers => {\n+                        m.abandon(p);\n+                        p.error(\"expected an item\");\n+                    }\n+                    // test pub_expr\n+                    // fn foo() { pub 92; } //FIXME\n+                    items::MaybeItem::None => {\n+                        expressions::expr(p);\n+                        if p.eat(SEMI) {\n+                            m.complete(p, EXPR_STMT);\n+                        } else {\n+                            m.abandon(p);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    p.expect(R_CURLY);\n+    m.complete(p, BLOCK_EXPR)\n+}\n+\n+// test let_stmt;\n+// fn foo() {\n+//     let a;\n+//     let b: i32;\n+//     let c = 92;\n+//     let d: i32 = 92;\n+// }\n+fn let_stmt(p: &mut Parser) {\n+    assert!(p.at(LET_KW));\n+    let m = p.start();\n+    p.bump();\n+    patterns::pattern(p);\n+    if p.at(COLON) {\n+        types::ascription(p);\n+    }\n+    if p.eat(EQ) {\n+        expressions::expr(p);\n+    }\n+    p.expect(SEMI);\n+    m.complete(p, LET_STMT);\n+}\n+\n+// test return_expr\n+// fn foo() {\n+//     return;\n+//     return 92;\n+// }\n+fn return_expr(p: &mut Parser) -> CompletedMarker {\n+    assert!(p.at(RETURN_KW));\n+    let m = p.start();\n+    p.bump();\n+    if EXPR_FIRST.contains(p.current()) {\n+        expr(p);\n+    }\n+    m.complete(p, RETURN_EXPR)\n+}"}, {"sha": "f2b0c36f5fd71ad4af19884282970b257f0597b7", "filename": "src/grammar/expressions/mod.rs", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/c5483822520e9c754f3ec8b9eb8e68bd5ef7c373/src%2Fgrammar%2Fexpressions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5483822520e9c754f3ec8b9eb8e68bd5ef7c373/src%2Fgrammar%2Fexpressions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fexpressions%2Fmod.rs?ref=c5483822520e9c754f3ec8b9eb8e68bd5ef7c373", "patch": "@@ -0,0 +1,255 @@\n+mod atom;\n+\n+use super::*;\n+pub(super) use self::atom::literal;\n+\n+const EXPR_FIRST: TokenSet = UNARY_EXPR_FIRST;\n+\n+pub(super) fn expr(p: &mut Parser) {\n+    expr_bp(p, 1)\n+}\n+\n+// test block\n+// fn a() {}\n+// fn b() { let _ = 1; }\n+// fn c() { 1; 2; }\n+// fn d() { 1; 2 }\n+pub(super) fn block(p: &mut Parser) {\n+    if !p.at(L_CURLY) {\n+        p.error(\"expected block\");\n+        return;\n+    }\n+    atom::block_expr(p);\n+}\n+\n+// test expr_binding_power\n+// fn foo() {\n+//     1 + 2 * 3 == 1 * 2 + 3\n+// }\n+fn bp_of(op: SyntaxKind) -> u8 {\n+    match op {\n+        EQEQ | NEQ => 1,\n+        MINUS | PLUS => 2,\n+        STAR | SLASH => 3,\n+        _ => 0\n+    }\n+}\n+\n+// Parses expression with binding power of at least bp.\n+fn expr_bp(p: &mut Parser, bp: u8) {\n+    let mut lhs = match unary_expr(p) {\n+        Some(lhs) => lhs,\n+        None => return,\n+    };\n+\n+    loop {\n+        let op_bp = bp_of(p.current());\n+        if op_bp < bp {\n+            break;\n+        }\n+        lhs = bin_expr(p, lhs, op_bp);\n+    }\n+}\n+\n+const UNARY_EXPR_FIRST: TokenSet =\n+    token_set_union![\n+        token_set![AMPERSAND, STAR, EXCL],\n+        atom::ATOM_EXPR_FIRST,\n+    ];\n+\n+fn unary_expr(p: &mut Parser) -> Option<CompletedMarker> {\n+    let done = match p.current() {\n+        AMPERSAND => ref_expr(p),\n+        STAR => deref_expr(p),\n+        EXCL => not_expr(p),\n+        _ => {\n+            let lhs = atom::atom_expr(p)?;\n+            postfix_expr(p, lhs)\n+        }\n+    };\n+    Some(done)\n+}\n+\n+fn postfix_expr(p: &mut Parser, mut lhs: CompletedMarker) -> CompletedMarker {\n+    loop {\n+        lhs = match p.current() {\n+            L_PAREN => call_expr(p, lhs),\n+            DOT if p.nth(1) == IDENT => if p.nth(2) == L_PAREN {\n+                method_call_expr(p, lhs)\n+            } else {\n+                field_expr(p, lhs)\n+            },\n+            DOT if p.nth(1) == INT_NUMBER => field_expr(p, lhs),\n+            QUESTION => try_expr(p, lhs),\n+            _ => break,\n+        }\n+    }\n+    lhs\n+}\n+\n+// test ref_expr\n+// fn foo() {\n+//     let _ = &1;\n+//     let _ = &mut &f();\n+// }\n+fn ref_expr(p: &mut Parser) -> CompletedMarker {\n+    assert!(p.at(AMPERSAND));\n+    let m = p.start();\n+    p.bump();\n+    p.eat(MUT_KW);\n+    expr(p);\n+    m.complete(p, REF_EXPR)\n+}\n+\n+// test deref_expr\n+// fn foo() {\n+//     **&1;\n+// }\n+fn deref_expr(p: &mut Parser) -> CompletedMarker {\n+    assert!(p.at(STAR));\n+    let m = p.start();\n+    p.bump();\n+    expr(p);\n+    m.complete(p, DEREF_EXPR)\n+}\n+\n+// test not_expr\n+// fn foo() {\n+//     !!true;\n+// }\n+fn not_expr(p: &mut Parser) -> CompletedMarker {\n+    assert!(p.at(EXCL));\n+    let m = p.start();\n+    p.bump();\n+    expr(p);\n+    m.complete(p, NOT_EXPR)\n+}\n+\n+// test call_expr\n+// fn foo() {\n+//     let _ = f();\n+//     let _ = f()(1)(1, 2,);\n+// }\n+fn call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n+    assert!(p.at(L_PAREN));\n+    let m = lhs.precede(p);\n+    arg_list(p);\n+    m.complete(p, CALL_EXPR)\n+}\n+\n+// test method_call_expr\n+// fn foo() {\n+//     x.foo();\n+//     y.bar(1, 2,);\n+// }\n+fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n+    assert!(p.at(DOT) && p.nth(1) == IDENT && p.nth(2) == L_PAREN);\n+    let m = lhs.precede(p);\n+    p.bump();\n+    name_ref(p);\n+    arg_list(p);\n+    m.complete(p, METHOD_CALL_EXPR)\n+}\n+\n+// test field_expr\n+// fn foo() {\n+//     x.foo;\n+//     x.0.bar;\n+// }\n+fn field_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n+    assert!(p.at(DOT) && (p.nth(1) == IDENT || p.nth(1) == INT_NUMBER));\n+    let m = lhs.precede(p);\n+    p.bump();\n+    if p.at(IDENT) {\n+        name_ref(p)\n+    } else {\n+        p.bump()\n+    }\n+    m.complete(p, FIELD_EXPR)\n+}\n+\n+// test try_expr\n+// fn foo() {\n+//     x?;\n+// }\n+fn try_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n+    assert!(p.at(QUESTION));\n+    let m = lhs.precede(p);\n+    p.bump();\n+    m.complete(p, TRY_EXPR)\n+}\n+\n+fn arg_list(p: &mut Parser) {\n+    assert!(p.at(L_PAREN));\n+    let m = p.start();\n+    p.bump();\n+    while !p.at(R_PAREN) && !p.at(EOF) {\n+        expr(p);\n+        if !p.at(R_PAREN) && !p.expect(COMMA) {\n+            break;\n+        }\n+    }\n+    p.eat(R_PAREN);\n+    m.complete(p, ARG_LIST);\n+}\n+\n+// test path_expr\n+// fn foo() {\n+//     let _ = a;\n+//     let _ = a::b;\n+//     let _ = ::a::<b>;\n+// }\n+fn path_expr(p: &mut Parser) -> CompletedMarker {\n+    assert!(paths::is_path_start(p));\n+    let m = p.start();\n+    paths::expr_path(p);\n+    if p.at(L_CURLY) {\n+        struct_lit(p);\n+        m.complete(p, STRUCT_LIT)\n+    } else {\n+        m.complete(p, PATH_EXPR)\n+    }\n+}\n+\n+// test struct_lit\n+// fn foo() {\n+//     S {};\n+//     S { x, y: 32, };\n+//     S { x, y: 32, ..Default::default() };\n+// }\n+fn struct_lit(p: &mut Parser) {\n+    assert!(p.at(L_CURLY));\n+    p.bump();\n+    while !p.at(EOF) && !p.at(R_CURLY) {\n+        match p.current() {\n+            IDENT => {\n+                let m = p.start();\n+                name_ref(p);\n+                if p.eat(COLON) {\n+                    expr(p);\n+                }\n+                m.complete(p, STRUCT_LIT_FIELD);\n+            }\n+            DOTDOT => {\n+                p.bump();\n+                expr(p);\n+            }\n+            _ => p.err_and_bump(\"expected identifier\"),\n+        }\n+        if !p.at(R_CURLY) {\n+            p.expect(COMMA);\n+        }\n+    }\n+    p.expect(R_CURLY);\n+}\n+\n+fn bin_expr(p: &mut Parser, lhs: CompletedMarker, bp: u8) -> CompletedMarker {\n+    assert!(match p.current() {\n+        MINUS | PLUS | STAR | SLASH | EQEQ | NEQ => true,\n+        _ => false,\n+    });\n+    let m = lhs.precede(p);\n+    p.bump();\n+    expr_bp(p, bp);\n+    m.complete(p, BIN_EXPR)\n+}"}]}