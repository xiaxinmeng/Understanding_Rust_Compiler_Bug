{"sha": "89a0060997479de770be0a63731423e2a305beda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YTAwNjA5OTc0NzlkZTc3MGJlMGE2MzczMTQyM2UyYTMwNWJlZGE=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-08-15T06:06:30Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-08-15T06:14:56Z"}, "message": "std::io::util cleanup + fixes\n\n* Fix `LimitReader`'s `Buffer::consume` impl to avoid limit underflow\n* Make `MultiWriter` fail fast instead of always running through each\n    `Writer`. This may or may not be what we want, but it at least\n    doesn't throw any errors encountered in later `Writer`s into oblivion.\n* Prevent `IterReader`'s `Reader::read` impl from returning EOF if given\n    an empty buffer.\n\n[breaking-change]", "tree": {"sha": "c5a6b095ef85bc0004d069c82b9a35bdcf01d700", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5a6b095ef85bc0004d069c82b9a35bdcf01d700"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89a0060997479de770be0a63731423e2a305beda", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89a0060997479de770be0a63731423e2a305beda", "html_url": "https://github.com/rust-lang/rust/commit/89a0060997479de770be0a63731423e2a305beda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89a0060997479de770be0a63731423e2a305beda/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf0a925dcde7a2c66df4e05661a9b1d1472435ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf0a925dcde7a2c66df4e05661a9b1d1472435ab", "html_url": "https://github.com/rust-lang/rust/commit/bf0a925dcde7a2c66df4e05661a9b1d1472435ab"}], "stats": {"total": 56, "additions": 38, "deletions": 18}, "files": [{"sha": "c3cd2faf773b58930bd624086880bf559c13e520", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/89a0060997479de770be0a63731423e2a305beda/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a0060997479de770be0a63731423e2a305beda/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=89a0060997479de770be0a63731423e2a305beda", "patch": "@@ -48,10 +48,12 @@ impl<R: Reader> Reader for LimitReader<R> {\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n-        self.inner.read(buf.mut_slice_to(len)).map(|len| {\n-            self.limit -= len;\n-            len\n-        })\n+        let res = self.inner.read(buf.mut_slice_to(len));\n+        match res {\n+            Ok(len) => self.limit -= len,\n+            _ => {}\n+        }\n+        res\n     }\n }\n \n@@ -67,6 +69,8 @@ impl<R: Buffer> Buffer for LimitReader<R> {\n     }\n \n     fn consume(&mut self, amt: uint) {\n+        // Don't let callers reset the limit by passing an overlarge value\n+        let amt = cmp::min(amt, self.limit);\n         self.limit -= amt;\n         self.inner.consume(amt);\n     }\n@@ -97,6 +101,7 @@ impl Buffer for ZeroReader {\n         static DATA: [u8, ..64] = [0, ..64];\n         Ok(DATA.as_slice())\n     }\n+\n     fn consume(&mut self, _amt: uint) {}\n }\n \n@@ -117,7 +122,10 @@ impl Buffer for NullReader {\n     fn consume(&mut self, _amt: uint) {}\n }\n \n-/// A `Writer` which multiplexes writes to a set of `Writers`.\n+/// A `Writer` which multiplexes writes to a set of `Writer`s.\n+///\n+/// The `Writer`s are delegated to in order. If any `Writer` returns an error,\n+/// that error is returned immediately and remaining `Writer`s are not called.\n pub struct MultiWriter {\n     writers: Vec<Box<Writer>>\n }\n@@ -132,24 +140,22 @@ impl MultiWriter {\n impl Writer for MultiWriter {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n-        let mut ret = Ok(());\n         for writer in self.writers.mut_iter() {\n-            ret = ret.and(writer.write(buf));\n+            try!(writer.write(buf));\n         }\n-        return ret;\n+        Ok(())\n     }\n \n     #[inline]\n     fn flush(&mut self) -> io::IoResult<()> {\n-        let mut ret = Ok(());\n         for writer in self.writers.mut_iter() {\n-            ret = ret.and(writer.flush());\n+            try!(writer.flush());\n         }\n-        return ret;\n+        Ok(())\n     }\n }\n \n-/// A `Reader` which chains input from multiple `Readers`, reading each to\n+/// A `Reader` which chains input from multiple `Reader`s, reading each to\n /// completion before moving onto the next.\n pub struct ChainedReader<I, R> {\n     readers: I,\n@@ -229,17 +235,16 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n     }\n }\n \n-/// A `Reader` which converts an `Iterator<u8>` into a `Reader`.\n+/// An adaptor converting an `Iterator<u8>` to a `Reader`.\n pub struct IterReader<T> {\n     iter: T,\n }\n \n impl<T: Iterator<u8>> IterReader<T> {\n-    /// Create a new `IterReader` which will read from the specified `Iterator`.\n+    /// Creates a new `IterReader` which will read from the specified\n+    /// `Iterator`.\n     pub fn new(iter: T) -> IterReader<T> {\n-        IterReader {\n-            iter: iter,\n-        }\n+        IterReader { iter: iter }\n     }\n }\n \n@@ -251,7 +256,7 @@ impl<T: Iterator<u8>> Reader for IterReader<T> {\n             *slot = elt;\n             len += 1;\n         }\n-        if len == 0 {\n+        if len == 0 && buf.len() != 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n             Ok(len)\n@@ -297,6 +302,14 @@ mod test {\n         assert_eq!(0, r.limit());\n     }\n \n+    #[test]\n+    fn test_limit_reader_overlong_consume() {\n+        let mut r = MemReader::new(vec![0, 1, 2, 3, 4, 5]);\n+        let mut r = LimitReader::new(r.by_ref(), 1);\n+        r.consume(2);\n+        assert_eq!(vec![], r.read_to_end().unwrap());\n+    }\n+\n     #[test]\n     fn test_null_writer() {\n         let mut s = NullWriter;\n@@ -415,4 +428,11 @@ mod test {\n \n         assert_eq!(r.read(buf).unwrap_err().kind, io::EndOfFile);\n     }\n+\n+    #[test]\n+    fn iter_reader_zero_length() {\n+        let mut r = IterReader::new(range(0u8, 8));\n+        let mut buf = [];\n+        assert_eq!(Ok(0), r.read(buf));\n+    }\n }"}]}