{"sha": "c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYjI4ODVlZTEyYjc5Yzk5YWM4MjQ1ZWRiNmVlYmFhYThlN2ZlZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-18T06:41:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-18T06:41:59Z"}, "message": "auto merge of #19769 : nick29581/rust/coerce-if, r=nikomatsakis\n\nr? @nikomatsakis \r\n\r\nWe discussed coercions for `if` and `match` expressions. `if` seems to work already, was there some specific behaviour which wasn't working?", "tree": {"sha": "2414bf7d92d33f3d287844bb98b34af363dbe44d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2414bf7d92d33f3d287844bb98b34af363dbe44d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1", "html_url": "https://github.com/rust-lang/rust/commit/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22a9f250b5e2de64c13c0f056aec13eb086ef79d", "url": "https://api.github.com/repos/rust-lang/rust/commits/22a9f250b5e2de64c13c0f056aec13eb086ef79d", "html_url": "https://github.com/rust-lang/rust/commit/22a9f250b5e2de64c13c0f056aec13eb086ef79d"}, {"sha": "46eb72453f69a2c38a9268425c3c52029d3febbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/46eb72453f69a2c38a9268425c3c52029d3febbb", "html_url": "https://github.com/rust-lang/rust/commit/46eb72453f69a2c38a9268425c3c52029d3febbb"}], "stats": {"total": 119, "additions": 81, "deletions": 38}, "files": [{"sha": "b88da5d9387d3b30b23127fb5825a66804de688a", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1", "patch": "@@ -13,7 +13,8 @@ use middle::infer::{mod, resolve};\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n use middle::subst::{Subst, Substs};\n use middle::ty::{mod, Ty};\n-use check::{check_expr, check_expr_has_type, demand, FnCtxt};\n+use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n+use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n use check::{instantiate_path, structurally_resolved_type, valid_range_bounds};\n use require_same_types;\n use util::nodemap::FnvHashMap;\n@@ -233,10 +234,11 @@ pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     }\n }\n \n-pub fn check_match(fcx: &FnCtxt,\n-                   expr: &ast::Expr,\n-                   discrim: &ast::Expr,\n-                   arms: &[ast::Arm]) {\n+pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                             expr: &ast::Expr,\n+                             discrim: &ast::Expr,\n+                             arms: &[ast::Arm],\n+                             expected: Expectation<'tcx>) {\n     let tcx = fcx.ccx.tcx;\n \n     let discrim_ty = fcx.infcx().next_ty_var();\n@@ -263,9 +265,23 @@ pub fn check_match(fcx: &FnCtxt,\n     // on any empty type and is therefore unreachable; should the flow\n     // of execution reach it, we will panic, so bottom is an appropriate\n     // type in that case)\n+    let expected = expected.adjust_for_branches(fcx);\n     let result_ty = arms.iter().fold(fcx.infcx().next_diverging_ty_var(), |result_ty, arm| {\n-        check_expr(fcx, &*arm.body);\n-        let bty = fcx.node_ty(arm.body.id);\n+        let bty = match expected {\n+            // We don't coerce to `()` so that if the match expression is a\n+            // statement it's branches can have any consistent type. That allows\n+            // us to give better error messages (pointing to a usually better\n+            // arm for inconsistent arms or to the whole match when a `()` type\n+            // is required).\n+            Expectation::ExpectHasType(ety) if ety != ty::mk_nil(fcx.tcx()) => {\n+                check_expr_coercable_to_type(fcx, &*arm.body, ety);\n+                ety\n+            }\n+            _ => {\n+                check_expr_with_expectation(fcx, &*arm.body, expected);\n+                fcx.node_ty(arm.body.id)\n+            }\n+        };\n \n         if let Some(ref e) = arm.guard {\n             check_expr_has_type(fcx, &**e, ty::mk_bool());"}, {"sha": "ad63806df6696d1798feb275c3b20314abee5f15", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1", "patch": "@@ -179,6 +179,38 @@ enum Expectation<'tcx> {\n \n impl<'tcx> Copy for Expectation<'tcx> {}\n \n+impl<'tcx> Expectation<'tcx> {\n+    // Disregard \"castable to\" expectations because they\n+    // can lead us astray. Consider for example `if cond\n+    // {22} else {c} as u8` -- if we propagate the\n+    // \"castable to u8\" constraint to 22, it will pick the\n+    // type 22u8, which is overly constrained (c might not\n+    // be a u8). In effect, the problem is that the\n+    // \"castable to\" expectation is not the tightest thing\n+    // we can say, so we want to drop it in this case.\n+    // The tightest thing we can say is \"must unify with\n+    // else branch\". Note that in the case of a \"has type\"\n+    // constraint, this limitation does not hold.\n+\n+    // If the expected type is just a type variable, then don't use\n+    // an expected type. Otherwise, we might write parts of the type\n+    // when checking the 'then' block which are incompatible with the\n+    // 'else' branch.\n+    fn adjust_for_branches<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n+        match self.only_has_type() {\n+            ExpectHasType(ety) => {\n+                let ety = fcx.infcx().shallow_resolve(ety);\n+                if !ty::type_is_ty_var(ety) {\n+                    ExpectHasType(ety)\n+                } else {\n+                    NoExpectation\n+                }\n+            }\n+            _ => NoExpectation\n+        }\n+    }\n+}\n+\n #[deriving(Copy, Clone)]\n pub struct UnsafetyState {\n     pub def: ast::NodeId,\n@@ -3047,7 +3079,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     // A generic function for checking the then and else in an if\n-    // or if-check\n+    // or if-else.\n     fn check_then_else<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  cond_expr: &ast::Expr,\n                                  then_blk: &ast::Block,\n@@ -3057,33 +3089,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  expected: Expectation<'tcx>) {\n         check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n \n-        // Disregard \"castable to\" expectations because they\n-        // can lead us astray. Consider for example `if cond\n-        // {22} else {c} as u8` -- if we propagate the\n-        // \"castable to u8\" constraint to 22, it will pick the\n-        // type 22u8, which is overly constrained (c might not\n-        // be a u8). In effect, the problem is that the\n-        // \"castable to\" expectation is not the tightest thing\n-        // we can say, so we want to drop it in this case.\n-        // The tightest thing we can say is \"must unify with\n-        // else branch\". Note that in the case of a \"has type\"\n-        // constraint, this limitation does not hold.\n-\n-        // If the expected type is just a type variable, then don't use\n-        // an expected type. Otherwise, we might write parts of the type\n-        // when checking the 'then' block which are incompatible with the\n-        // 'else' branch.\n-        let expected = match expected.only_has_type() {\n-            ExpectHasType(ety) => {\n-                let ety = fcx.infcx().shallow_resolve(ety);\n-                if !ty::type_is_ty_var(ety) {\n-                    ExpectHasType(ety)\n-                } else {\n-                    NoExpectation\n-                }\n-            }\n-            _ => NoExpectation\n-        };\n+        let expected = expected.adjust_for_branches(fcx);\n         check_block_with_expected(fcx, then_blk, expected);\n         let then_ty = fcx.node_ty(then_blk.id);\n \n@@ -3989,7 +3995,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       ast::ExprMatch(ref discrim, ref arms, _) => {\n-        _match::check_match(fcx, expr, &**discrim, arms.as_slice());\n+        _match::check_match(fcx, expr, &**discrim, arms.as_slice(), expected);\n       }\n       ast::ExprClosure(_, opt_kind, ref decl, ref body) => {\n           closure::check_expr_closure(fcx, expr, opt_kind, &**decl, &**body, expected);"}, {"sha": "1939df2877b82da4e20b754d739a593d3a6d42bc", "filename": "src/test/compile-fail/lub-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-match.rs?ref=c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1", "patch": "@@ -34,21 +34,21 @@ pub fn opt_str1<'a>(maybestr: &'a Option<String>) -> &'a str {\n \n pub fn opt_str2<'a>(maybestr: &'a Option<String>) -> &'static str {\n     match *maybestr {\n-    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n         None => \"(none)\",\n         Some(ref s) => {\n             let s: &'a str = s.as_slice();\n             s\n+            //~^ ERROR cannot infer an appropriate lifetime\n         }\n     }\n }\n \n pub fn opt_str3<'a>(maybestr: &'a Option<String>) -> &'static str {\n     match *maybestr {\n-    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n         Some(ref s) => {\n             let s: &'a str = s.as_slice();\n             s\n+            //~^ ERROR cannot infer an appropriate lifetime\n         }\n         None => \"(none)\",\n     }"}, {"sha": "d67664bb1be4724e3644c6d569c5115668cd12ac", "filename": "src/test/run-pass/coerce-match.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1/src%2Ftest%2Frun-pass%2Fcoerce-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1/src%2Ftest%2Frun-pass%2Fcoerce-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-match.rs?ref=c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that coercions are propagated through match and if expressions.\n+\n+pub fn main() {\n+    let _: Box<[int]> = if true { box [1i, 2, 3] } else { box [1i] };\n+\n+    let _: Box<[int]> = match true { true => box [1i, 2, 3], false => box [1i] };\n+\n+    // Check we don't get over-keen at propagating coercions in the case of casts.\n+    let x = if true { 42 } else { 42u8 } as u16;\n+    let x = match true { true => 42, false => 42u8 } as u16;\n+}"}]}