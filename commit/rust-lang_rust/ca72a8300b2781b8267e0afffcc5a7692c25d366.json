{"sha": "ca72a8300b2781b8267e0afffcc5a7692c25d366", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNzJhODMwMGIyNzgxYjgyNjdlMGFmZmZjYzVhNzY5MmMyNWQzNjY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-12T13:24:36Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-12T13:24:36Z"}, "message": "Add tutorial chapter on interfaces", "tree": {"sha": "819756af77247abbe20aad3609712e5f19093a7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/819756af77247abbe20aad3609712e5f19093a7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca72a8300b2781b8267e0afffcc5a7692c25d366", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca72a8300b2781b8267e0afffcc5a7692c25d366", "html_url": "https://github.com/rust-lang/rust/commit/ca72a8300b2781b8267e0afffcc5a7692c25d366", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca72a8300b2781b8267e0afffcc5a7692c25d366/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f72c53fdfb912319260aa8462ae20f07599631d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f72c53fdfb912319260aa8462ae20f07599631d", "html_url": "https://github.com/rust-lang/rust/commit/0f72c53fdfb912319260aa8462ae20f07599631d"}], "stats": {"total": 184, "additions": 184, "deletions": 0}, "files": [{"sha": "c047cf06da540a41b0ea3e775ca2fd3b27a43d92", "filename": "doc/tutorial/iface.md", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/ca72a8300b2781b8267e0afffcc5a7692c25d366/doc%2Ftutorial%2Fiface.md", "raw_url": "https://github.com/rust-lang/rust/raw/ca72a8300b2781b8267e0afffcc5a7692c25d366/doc%2Ftutorial%2Fiface.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fiface.md?ref=ca72a8300b2781b8267e0afffcc5a7692c25d366", "patch": "@@ -0,0 +1,183 @@\n+# Interfaces\n+\n+Interfaces are Rust's take on value polymorphism\u2014the thing that\n+object-oriented languages tend to solve with methods and inheritance.\n+For example, writing a function that can operate on multiple types of\n+collections.\n+\n+NOTE: This feature is very new, and will need a few extensions to be\n+applicable to more advanced use cases.\n+\n+## Declaration\n+\n+An interface consists of a set of methods. A method is a function that\n+can be applied to a `self` value and a number of arguments, using the\n+dot notation: `self.foo(arg1, arg2)`.\n+\n+For example, we could declare the interface `to_str` for things that\n+can be converted to a string, with a single method of the same name:\n+\n+    iface to_str {\n+        fn to_str() -> str;\n+    }\n+\n+## Implementation\n+\n+To actually implement an interface for a given type, the `impl` form\n+is used. This defines implementations of `to_str` for the `int` and\n+`str` types.\n+\n+    # iface to_str { fn to_str() -> str; }\n+    impl of to_str for int {\n+        fn to_str() -> str { int::to_str(self, 10u) }\n+    }\n+    impl of to_str for str {\n+        fn to_str() -> str { self }\n+    }\n+\n+Given these, we may call `1.to_str()` to get `\"1\"`, or\n+`\"foo\".to_str()` to get `\"foo\"` again. This is basically a form of\n+static overloading\u2014when the Rust compiler sees the `to_str` method\n+call, it looks for an implementation that matches the type with a\n+method that matches the name, and simply calls that.\n+\n+## Scoping\n+\n+Implementations are not globally visible. Resolving a method to an\n+implementation requires that implementation to be in scope. You can\n+import and export implementations using the name of the interface they\n+implement (multiple implementations with the same name can be in scope\n+without problems). Or you can give them an explicit name if you\n+prefer, using this syntax:\n+\n+    # iface to_str { fn to_str() -> str; }\n+    impl nil_to_str of to_str for () {\n+        fn to_str() -> str { \"()\" }\n+    }\n+\n+## Bounded type parameters\n+\n+The useful thing about value polymorphism is that it does not have to\n+be static. If object-oriented languages only let you call a method on\n+an object when they knew exactly which sub-type it had, that would not\n+get you very far. To be able to call methods on types that aren't\n+known at compile time, it is possible to specify 'bounds' for type\n+parameters.\n+\n+    # iface to_str { fn to_str() -> str; }\n+    fn comma_sep<T: to_str>(elts: [T]) -> str {\n+        let result = \"\", first = true;\n+        for elt in elts {\n+            if first { first = false; }\n+            else { result += \", \"; }\n+            result += elt.to_str();\n+        }\n+        ret result;\n+    }\n+\n+The syntax for this is similar to the syntax for specifying that a\n+parameter type has to be copyable (which is, in principle, another\n+kind of bound). By declaring `T` as conforming to the `to_str`\n+interface, it becomes possible to call methods from that interface on\n+values of that type inside the function. It will also cause a\n+compile-time error when anyone tries to call `comma_sep` on an array\n+whose element type does not have a `to_str` implementation in scope.\n+\n+## Polymorphic interfaces\n+\n+Interfaces may contain type parameters. This defines an interface for\n+generalized sequence types:\n+\n+    iface seq<T> {\n+        fn len() -> uint;\n+        fn iter(block(T));\n+    }\n+    impl <T> of seq<T> for [T] {\n+        fn len() -> uint { vec::len(self) }\n+        fn iter(b: block(T)) {\n+            for elt in self { b(elt); }\n+        }\n+    }\n+\n+Note that the implementation has to explicitly declare the its\n+parameter `T` before using it to specify its interface type. This is\n+needed because it could also, for example, specify an implementation\n+of `seq<int>`\u2014the `of` clause *refers* to a type, rather than defining\n+one.\n+\n+## Casting to an interface type\n+\n+The above allows us to define functions that polymorphically act on\n+values of *an* unknown type that conforms to a given interface.\n+However, consider this function:\n+\n+    # iface drawable { fn draw(); }\n+    fn draw_all<T: drawable>(shapes: [T]) {\n+        for shape in shapes { shape.draw(); }\n+    }\n+\n+You can call that on an array of circles, or an array of squares\n+(assuming those have suitable `drawable` interfaces defined), but not\n+on an array containing both circles and squares.\n+\n+When this is needed, an interface name can be used as a type, causing\n+the function to be written simply like this:\n+\n+    # iface drawable { fn draw(); }\n+    fn draw_all(shapes: [drawable]) {\n+        for shape in shapes { shape.draw(); }\n+    }\n+\n+There is no type parameter anymore (since there isn't a single type\n+that we're calling the function on). Instead, the `drawable` type is\n+used to refer to a type that is a reference-counted box containing a\n+value for which a `drawable` implementation exists, combined with\n+information on where to find the methods for this implementation. This\n+is very similar to the 'vtables' used in most object-oriented\n+languages.\n+\n+To construct such a value, you use the `as` operator to cast a value\n+to an interface type:\n+\n+    # type circle = int; type rectangle = int;\n+    # iface drawable { fn draw(); }\n+    # impl of drawable for int { fn draw() {} }\n+    # fn new_circle() -> int { 1 }\n+    # fn new_rectangle() -> int { 2 }\n+    # fn draw_all(shapes: [drawable]) {}\n+    let c: circle = new_circle();\n+    let r: rectangle = new_rectangle();\n+    draw_all([c as drawable, r as drawable]);\n+\n+This will store the value into a box, along with information about the\n+implementation (which is looked up in the scope of the cast). The\n+`drawable` type simply refers to such boxes, and calling methods on it\n+always works, no matter what implementations are in scope.\n+\n+Note that the allocation of a box is somewhat more expensive than\n+simply using a type parameter and passing in the value as-is, and much\n+more expensive than statically resolved method calls.\n+\n+## Interface-less implementations\n+\n+If you only intend to use an implementation for static overloading,\n+and there is no interface available that it conforms to, you are free\n+to leave off the `of` clause.\n+\n+    # type currency = ();\n+    # fn mk_currency(x: int, s: str) {}\n+    impl int_util for int {\n+        fn times(b: block(int)) {\n+            let i = 0;\n+            while i < self { b(i); i += 1; }\n+        }\n+        fn dollars() -> currency {\n+            mk_currency(self, \"USD\")\n+        }\n+    }\n+\n+This allows cutesy things like `send_payment(10.dollars())`. And the\n+nice thing is that it's fully scoped, so the uneasy feeling that\n+anybody with experience in object-oriented languages (with the\n+possible exception of Rubyists) gets at the sight of such things is\n+not justified. It's harmless!"}, {"sha": "9f751663901b94dbd4318c506a946d660469aa15", "filename": "doc/tutorial/order", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca72a8300b2781b8267e0afffcc5a7692c25d366/doc%2Ftutorial%2Forder", "raw_url": "https://github.com/rust-lang/rust/raw/ca72a8300b2781b8267e0afffcc5a7692c25d366/doc%2Ftutorial%2Forder", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Forder?ref=ca72a8300b2781b8267e0afffcc5a7692c25d366", "patch": "@@ -7,6 +7,7 @@ data\n args\n generic\n mod\n+iface\n ffi\n task\n test"}]}