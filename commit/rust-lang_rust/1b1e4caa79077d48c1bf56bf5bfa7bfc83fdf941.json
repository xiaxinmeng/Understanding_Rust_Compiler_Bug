{"sha": "1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMWU0Y2FhNzkwNzdkNDhjMWJmNTZiZjViZmE3YmZjODNmZGY5NDE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-19T12:03:11Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-20T22:35:18Z"}, "message": "std::vec: add a sugary .sort() method for plain Ord sorting.\n\nThis moves the custom sorting to `.sort_by`.", "tree": {"sha": "932fade0a40ca5fe22eca4c302adadae3df91b4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/932fade0a40ca5fe22eca4c302adadae3df91b4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "html_url": "https://github.com/rust-lang/rust/commit/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "url": "https://api.github.com/repos/rust-lang/rust/commits/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68", "html_url": "https://github.com/rust-lang/rust/commit/48fedcb36ffdb4248c238a1bfa7a846e6e27cb68"}], "stats": {"total": 118, "additions": 91, "deletions": 27}, "files": [{"sha": "78651b818fa55d44a44935f7afa85967c1658f75", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -148,7 +148,7 @@ impl Iterator<Path> for GlobIterator {\n fn list_dir_sorted(path: &Path) -> ~[Path] {\n     match io::result(|| fs::readdir(path)) {\n         Ok(mut children) => {\n-            children.sort(|p1, p2| p2.filename() <= p1.filename());\n+            children.sort_by(|p1, p2| p2.filename() <= p1.filename());\n             children\n         }\n         Err(..) => ~[]"}, {"sha": "3c1743cfe34c9f0260674c246cbb5e23a1862290", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -231,7 +231,11 @@ mod tests {\n     fn test_top_and_pop() {\n         let data = ~[2u, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n         let mut sorted = data.clone();\n+<<<<<<< HEAD\n         sorted.sort(|x, y| x.le(y));\n+=======\n+        sorted.sort();\n+>>>>>>> 9ceda35... std::vec: add a sugary .sort() method for plain Ord sorting.\n         let mut heap = PriorityQueue::from_vec(data);\n         while !heap.is_empty() {\n             assert_eq!(heap.top(), sorted.last());\n@@ -314,8 +318,8 @@ mod tests {\n     fn check_to_vec(mut data: ~[int]) {\n         let heap = PriorityQueue::from_vec(data.clone());\n         let mut v = heap.clone().to_vec();\n-        v.sort(|x, y| x.le(y));\n-        data.sort(|x, y| x.le(y));\n+        v.sort();\n+        data.sort();\n \n         assert_eq!(v, data);\n         assert_eq!(heap.to_sorted_vec(), data);"}, {"sha": "ba8f7d4f23f1143a98c89294b2df13570ee039d9", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -239,13 +239,13 @@ impl<'a> Stats for &'a [f64] {\n \n     fn percentile(self, pct: f64) -> f64 {\n         let mut tmp = self.to_owned();\n-        tmp.sort(|a,b| a <= b);\n+        tmp.sort();\n         percentile_of_sorted(tmp, pct)\n     }\n \n     fn quartiles(self) -> (f64,f64,f64) {\n         let mut tmp = self.to_owned();\n-        tmp.sort(|a,b| a <= b);\n+        tmp.sort();\n         let a = percentile_of_sorted(tmp, 25.0);\n         let b = percentile_of_sorted(tmp, 50.0);\n         let c = percentile_of_sorted(tmp, 75.0);\n@@ -290,7 +290,7 @@ fn percentile_of_sorted(sorted_samples: &[f64],\n /// See: http://en.wikipedia.org/wiki/Winsorising\n pub fn winsorize(samples: &mut [f64], pct: f64) {\n     let mut tmp = samples.to_owned();\n-    tmp.sort(|a,b| a <= b);\n+    tmp.sort();\n     let lo = percentile_of_sorted(tmp, pct);\n     let hi = percentile_of_sorted(tmp, 100.0-pct);\n     for samp in samples.mut_iter() {"}, {"sha": "dd29a4d8d4796bc90fc66bc5d8756e8e277b7bf0", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -37,7 +37,6 @@ use std::to_str::ToStr;\n use std::f64;\n use std::os;\n \n-\n // The name of a test. By convention this follows the rules for rust\n // paths; i.e. it should be a series of identifiers separated by double\n // colons. This way if some test runner wants to arrange the tests\n@@ -487,7 +486,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         for f in self.failures.iter() {\n             failures.push(f.name.to_str());\n         }\n-        failures.sort(|a,b| a <= b);\n+        failures.sort();\n         for name in failures.iter() {\n             self.write_plain(format!(\"    {}\\n\", name.to_str()));\n         }\n@@ -841,7 +840,7 @@ pub fn filter_tests(\n     fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n         t1.desc.name.to_str() <= t2.desc.name.to_str()\n     }\n-    filtered.sort(lteq);\n+    filtered.sort_by(lteq);\n \n     // Shard the remaining tests, if sharding requested.\n     match opts.test_shard {"}, {"sha": "a74497208c0139728bb4bf88ace1b63c44c8c3a8", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -162,7 +162,7 @@ Available lint options:\n     let mut lint_dict = lint_dict.move_iter()\n                                  .map(|(k, v)| (v, k))\n                                  .collect::<~[(lint::LintSpec, &'static str)]>();\n-    lint_dict.sort(|a,b| a <= b);\n+    lint_dict.sort();\n \n     let mut max_key = 0;\n     for &(_, name) in lint_dict.iter() {"}, {"sha": "6eb280df8ee5babd0d379a982e1bbd907106d506", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -191,7 +191,7 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n         });\n     }\n \n-    result.sort(|a, b| (a.name, a.vers, a.hash) <= (b.name, b.vers, b.hash));\n+    result.sort();\n \n     debug!(\"sorted:\");\n     for x in result.iter() {"}, {"sha": "5e709f0296cc58613b0f7142881c5acd014cced8", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -1531,7 +1531,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n         });\n \n         // Sort by cnum\n-        deps.sort(|kv1, kv2| kv1.cnum <= kv2.cnum);\n+        deps.sort_by(|kv1, kv2| kv1.cnum <= kv2.cnum);\n \n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;"}, {"sha": "4d4cda82055b8e325ed3da36cd836d1b2017ea65", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -464,7 +464,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n \n         // Sort them by length such that for patterns of the same length,\n         // those with a destructured slice come first.\n-        vec_pat_lens.sort(|&(len1, slice1), &(len2, slice2)| {\n+        vec_pat_lens.sort_by(|&(len1, slice1), &(len2, slice2)| {\n                     if len1 == len2 {\n                         slice1 > slice2\n                     } else {"}, {"sha": "831c3ccce9d41603bf6122d017023967bed4c91b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -3163,7 +3163,7 @@ pub fn trans_crate(sess: session::Session,\n         println!(\"n_closures: {}\", ccx.stats.n_closures);\n         println(\"fn stats:\");\n \n-        ccx.stats.fn_stats.sort(|&(_, _, insns_a), &(_, _, insns_b)| insns_a >= insns_b);\n+        ccx.stats.fn_stats.sort_by(|&(_, _, insns_a), &(_, _, insns_b)| insns_a >= insns_b);\n \n         for tuple in ccx.stats.fn_stats.iter() {\n             match *tuple {"}, {"sha": "b474bbca865b42b6b74d7e439e5aaf37c13e7966", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -935,7 +935,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n     }\n \n     debug!(\"{:?}\", indices);\n-    indices.sort(|&i1, &i2| le(&items[i1], &items[i2], i1, i2));\n+    indices.sort_by(|&i1, &i2| le(&items[i1], &items[i2], i1, i2));\n \n     debug!(\"{:?}\", indices);\n     let mut curty = \"\";"}, {"sha": "91aa3470ff47516ebdf985197a27bc81de9d3356", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -79,7 +79,7 @@ pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n pub use vec::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCopyableVector};\n-pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector, MutableVector};\n+pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector, MutableVector, MutableOrdVector};\n pub use vec::{Vector, VectorVector, CopyableVector, ImmutableVector};\n \n // Reexported runtime types"}, {"sha": "58392774fa01d4ab6ca49ba8271885431a7514d8", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 63, "deletions": 6, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -2181,7 +2181,7 @@ pub trait MutableVector<'a, T> {\n     /// v.sort(|a, b| *b <= *a);\n     /// assert_eq!(v, [5, 4, 3, 2, 1]);\n     /// ```\n-    fn sort(self, less_eq: |&T, &T| -> bool);\n+    fn sort_by(self, less_eq: |&T, &T| -> bool);\n \n     /**\n      * Consumes `src` and moves as many elements as it can into `self`\n@@ -2328,7 +2328,11 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n+<<<<<<< HEAD\n     fn sort(self, less_eq: |&T, &T| -> bool) {\n+=======\n+    fn sort_by<Sort: SortComparator<T>>(self, less_eq: Sort) {\n+>>>>>>> 9ceda35... std::vec: add a sugary .sort() method for plain Ord sorting.\n         merge_sort(self, less_eq)\n     }\n \n@@ -2385,6 +2389,32 @@ impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n     }\n }\n \n+/// Methods for mutable vectors with orderable elements, such as\n+/// in-place sorting.\n+pub trait MutableOrdVector<T> {\n+    /// Sort the vector, in place.\n+    ///\n+    /// This is equivalent to `self.sort_by(std::vec::SortForward)`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::vec;\n+    ///\n+    /// let mut v = [-5, 4, 1, -3, 2];\n+    ///\n+    /// v.sort();\n+    /// assert_eq!(v, [-5, -3, 1, 2, 4]);\n+    /// ```\n+    fn sort(self);\n+}\n+impl<'a, T: Ord> MutableOrdVector<T> for &'a mut [T] {\n+    #[inline]\n+    fn sort(self) {\n+        self.sort_by(SortForward)\n+    }\n+}\n+\n /**\n * Constructs a vector from an unsafe pointer to a buffer\n *\n@@ -3474,16 +3504,39 @@ mod tests {\n                 let mut v = task_rng().gen_vec::<uint>(len);\n                 v.sort(|a,b| a <= b);\n \n+<<<<<<< HEAD\n                 assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+=======\n+                let mut v1 = v.clone();\n+                let mut v2 = v.clone();\n+                v.sort();\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+                v1.sort_by(vec::SortForward);\n+                assert!(v1.windows(2).all(|w| w[0] <= w[1]));\n+\n+                v1.sort_by(vec::SortReverse);\n+                assert!(v1.windows(2).all(|w| w[0] >= w[1]));\n+\n+                v2.sort_by(|a: &uint, b: &uint| a <= b);\n+                assert!(v2.windows(2).all(|w| w[0] <= w[1]));\n+>>>>>>> 9ceda35... std::vec: add a sugary .sort() method for plain Ord sorting.\n             }\n         }\n \n         // shouldn't fail/crash\n         let mut v: [uint, .. 0] = [];\n+<<<<<<< HEAD\n         v.sort(|a,b| a <= b);\n \n         let mut v = [0xDEADBEEF];\n         v.sort(|a,b| a <= b);\n+=======\n+        v.sort_by(SortForward);\n+\n+        let mut v = [0xDEADBEEF];\n+        v.sort_by(SortForward);\n+>>>>>>> 9ceda35... std::vec: add a sugary .sort() method for plain Ord sorting.\n         assert_eq!(v, [0xDEADBEEF]);\n     }\n \n@@ -3506,7 +3559,11 @@ mod tests {\n \n                 // only sort on the first element, so an unstable sort\n                 // may mix up the counts.\n+<<<<<<< HEAD\n                 v.sort(|&(a,_), &(b,_)| a <= b);\n+=======\n+                v.sort_by(|&(a,_): &(uint, uint), &(b,_): &(uint, uint)| a <= b);\n+>>>>>>> 9ceda35... std::vec: add a sugary .sort() method for plain Ord sorting.\n \n                 // this comparison includes the count (the second item\n                 // of the tuple), so elements with equal first items\n@@ -4341,7 +4398,7 @@ mod bench {\n     use extra::test::BenchHarness;\n     use iter::range;\n     use vec;\n-    use vec::VectorVector;\n+    use vec::{VectorVector, MutableOrdVector};\n     use option::*;\n     use ptr;\n     use rand::{weak_rng, task_rng, Rng};\n@@ -4551,7 +4608,7 @@ mod bench {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n             let mut v: ~[f64] = rng.gen_vec(5);\n-            v.sort(|a,b| *a <= *b);\n+            v.sort();\n         });\n         bh.bytes = 5 * mem::size_of::<f64>() as u64;\n     }\n@@ -4561,7 +4618,7 @@ mod bench {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n             let mut v: ~[f64] = rng.gen_vec(100);\n-            v.sort(|a,b| *a <= *b);\n+            v.sort();\n         });\n         bh.bytes = 100 * mem::size_of::<f64>() as u64;\n     }\n@@ -4571,7 +4628,7 @@ mod bench {\n         let mut rng = weak_rng();\n         bh.iter(|| {\n             let mut v: ~[f64] = rng.gen_vec(10000);\n-            v.sort(|a,b| *a <= *b);\n+            v.sort();\n         });\n         bh.bytes = 10000 * mem::size_of::<f64>() as u64;\n     }\n@@ -4580,7 +4637,7 @@ mod bench {\n     fn sort_sorted(bh: &mut BenchHarness) {\n         let mut v = vec::from_fn(10000, |i| i);\n         bh.iter(|| {\n-            v.sort(|a,b| *a <= *b);\n+            v.sort();\n         });\n         bh.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n     }"}, {"sha": "4564542f92937d45d5cdbf9220d3267f3048a0ef", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -203,7 +203,11 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n         .map(|&mi| (mi.name(), mi))\n         .collect::<~[(@str, @MetaItem)]>();\n \n+<<<<<<< HEAD\n     v.sort(|&(a, _), &(b, _)| a <= b);\n+=======\n+    v.sort_by(|&(a, _): &(@str, @MetaItem), &(b, _): &(@str, @MetaItem)| a <= b);\n+>>>>>>> 9ceda35... std::vec: add a sugary .sort() method for plain Ord sorting.\n \n     // There doesn't seem to be a more optimal way to do this\n     v.move_iter().map(|(_, m)| {"}, {"sha": "ca04f3d970481851c5f34118da72998375de75c1", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -54,8 +54,8 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n \n    // sort by key, then by value\n    fn sortKV<TT:Clone + Ord, UU:Clone + Ord>(mut orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n-        orig.sort(le_by_key);\n-        orig.sort(le_by_val);\n+        orig.sort_by(le_by_key);\n+        orig.sort_by(le_by_val);\n         origin\n    }\n "}, {"sha": "067ef873fd3d2e4d019c4d5457262f7521f6a45b", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -266,7 +266,7 @@ fn print_frequencies(frequencies: &Table, frame: i32) {\n     for frequencies.each |entry| {\n         vector.push((entry.code, entry.count));\n     }\n-    vector.sort(|a,b| a <= b);\n+    vector.sort();\n \n     let mut total_count = 0;\n     for vector.each |&(_, count)| {"}, {"sha": "ca82fb0422e74fa2b66dca59c6061a8a9942bdbf", "filename": "src/test/run-pass/vector-sort-failure-safe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-failure-safe.rs?ref=1b1e4caa79077d48c1bf56bf5bfa7bfc83fdf941", "patch": "@@ -48,7 +48,7 @@ pub fn main() {\n             // work out the total number of comparisons required to sort\n             // this array...\n             let mut count = 0;\n-            main.clone().sort(|a, b| { count += 1; a <= b });\n+            main.clone().sort_by(|a, b| { count += 1; a <= b });\n \n             // ... and then fail on each and every single one.\n             for fail_countdown in range(0, count) {\n@@ -63,7 +63,7 @@ pub fn main() {\n                 std::task::try(proc() {\n                         let mut v = v;\n                         let mut fail_countdown = fail_countdown;\n-                        v.sort(|a, b| {\n+                        v.sort_by(|a, b| {\n                                 if fail_countdown == 0 {\n                                     fail!()\n                                 }"}]}