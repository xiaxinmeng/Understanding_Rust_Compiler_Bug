{"sha": "3e6943d8201215e60b74df7d3be8f48a52b3c2b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNjk0M2Q4MjAxMjE1ZTYwYjc0ZGY3ZDNiZThmNDhhNTJiM2MyYjc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-11T20:10:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-12T00:21:53Z"}, "message": "refactor fixup_self", "tree": {"sha": "a21b74a717a8865fe75ee683a2b871f8e201714b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a21b74a717a8865fe75ee683a2b871f8e201714b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e6943d8201215e60b74df7d3be8f48a52b3c2b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e6943d8201215e60b74df7d3be8f48a52b3c2b7", "html_url": "https://github.com/rust-lang/rust/commit/3e6943d8201215e60b74df7d3be8f48a52b3c2b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e6943d8201215e60b74df7d3be8f48a52b3c2b7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00", "html_url": "https://github.com/rust-lang/rust/commit/c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00"}], "stats": {"total": 149, "additions": 90, "deletions": 59}, "files": [{"sha": "a6fd7ca60825ff4788b00dd13836b9edc459bfb0", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 88, "deletions": 59, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/3e6943d8201215e60b74df7d3be8f48a52b3c2b7/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6943d8201215e60b74df7d3be8f48a52b3c2b7/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=3e6943d8201215e60b74df7d3be8f48a52b3c2b7", "patch": "@@ -934,10 +934,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n         });\n         let mut if_fty = ty::mk_fn(tcx, if_m.fty);\n         if_fty = ty::substitute_type_params(tcx, substs, if_fty);\n-        if ty::type_has_vars(if_fty) {\n-            if_fty = fixup_self_in_method_ty(tcx, if_fty, substs,\n-                                             self_full(self_ty, impl_tps));\n-        }\n+        if_fty = fixup_self_full(tcx, if_fty, substs, self_ty, impl_tps);\n         require_same_types(\n             tcx, sp, impl_fty, if_fty,\n             {|| \"method `\" + if_m.ident +\n@@ -946,61 +943,84 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n     }\n }\n \n-enum self_subst { self_param(ty::t, @fn_ctxt, span), self_full(ty::t, uint) }\n+// Mangles an iface method ty to make its self type conform to the self type\n+// of a specific impl or bounded type parameter. This is rather involved\n+// because the type parameters of ifaces and impls are not required to line up\n+// (an impl can have less or more parameters than the iface it implements), so\n+// some mangling of the substituted types is required.\n+fn fixup_self_full(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n+                   selfty: ty::t, impl_n_tps: uint) -> ty::t {\n+\n+    if !ty::type_has_vars(mty) { ret mty; }\n+\n+    ty::fold_ty(cx, mty) {|t|\n+        alt ty::get(t).struct {\n+          ty::ty_self(tps) if vec::len(tps) == 0u {\n+            selfty\n+          }\n+          ty::ty_self(tps) {\n+            // Move the substs into the type param system of the\n+            // context.\n+            let mut substs = vec::map(tps) {|t|\n+                let f = fixup_self_full(cx, t, m_substs, selfty, impl_n_tps);\n+                ty::substitute_type_params(cx, m_substs, f)\n+            };\n+\n+            // Add extra substs for impl type parameters.\n+            while vec::len(substs) < impl_n_tps {\n+                substs += [ty::mk_param(cx, vec::len(substs),\n+                                        {crate: 0, node: 0})];\n+            }\n+\n+            // And for method type parameters.\n+            let method_n_tps =\n+                (vec::len(m_substs) - vec::len(tps)) as int;\n+            if method_n_tps > 0 {\n+                substs += vec::tailn(m_substs, vec::len(m_substs)\n+                                     - (method_n_tps as uint));\n+            }\n+\n+            // And then instantiate the self type using all those.\n+            ty::substitute_type_params(cx, substs, selfty)\n+          }\n+          _ {\n+              t\n+          }\n+        }\n+    }\n+}\n \n // Mangles an iface method ty to make its self type conform to the self type\n // of a specific impl or bounded type parameter. This is rather involved\n // because the type parameters of ifaces and impls are not required to line up\n // (an impl can have less or more parameters than the iface it implements), so\n // some mangling of the substituted types is required.\n-fn fixup_self_in_method_ty(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n-                           self: self_subst) -> ty::t {\n-    if ty::type_has_vars(mty) {\n-        ty::fold_ty(cx, mty) {|t|\n-            alt ty::get(t).struct {\n-              ty::ty_self(tps) {\n-                if vec::len(tps) > 0u {\n-                    // Move the substs into the type param system of the\n-                    // context.\n-                    let mut substs = vec::map(tps, {|t|\n-                        let f = fixup_self_in_method_ty(cx, t, m_substs,\n-                                                        self);\n-                        ty::substitute_type_params(cx, m_substs, f)\n-                    });\n-                    alt self {\n-                      self_param(t, fcx, sp) {\n-                        // Simply ensure that the type parameters for the self\n-                        // type match the context.\n-                        vec::iter2(substs, m_substs) {|s, ms|\n-                            demand::simple(fcx, sp, s, ms);\n-                        }\n-                        t\n-                      }\n-                      self_full(selfty, impl_n_tps) {\n-                        // Add extra substs for impl type parameters.\n-                        while vec::len(substs) < impl_n_tps {\n-                            substs += [ty::mk_param(cx, vec::len(substs),\n-                                                    {crate: 0, node: 0})];\n-                        }\n-                        // And for method type parameters.\n-                        let method_n_tps =\n-                            (vec::len(m_substs) - vec::len(tps)) as int;\n-                        if method_n_tps > 0 {\n-                            substs += vec::tailn(m_substs, vec::len(m_substs)\n-                                                  - (method_n_tps as uint));\n-                        }\n-                        // And then instantiate the self type using all those.\n-                        ty::substitute_type_params(cx, substs, selfty)\n-                      }\n-                    }\n-                } else {\n-                    alt self { self_param(t, _, _) | self_full(t, _) { t } }\n-                }\n-              }\n-              _ { t }\n+fn fixup_self_param(fcx: @fn_ctxt, mty: ty::t, m_substs: [ty::t],\n+                    selfty: ty::t, sp: span) -> ty::t {\n+    if !ty::type_has_vars(mty) { ret mty; }\n+\n+    let tcx = fcx.ccx.tcx;\n+    ty::fold_ty(tcx, mty) {|t|\n+        alt ty::get(t).struct {\n+          ty::ty_self(tps) if vec::len(tps) == 0u { selfty }\n+          ty::ty_self(tps) {\n+            // Move the substs into the type param system of the\n+            // context.\n+            let mut substs = vec::map(tps) {|t|\n+                let f = fixup_self_param(fcx, t, m_substs, selfty, sp);\n+                ty::substitute_type_params(tcx, m_substs, f)\n+            };\n+\n+            // Simply ensure that the type parameters for the self\n+            // type match the context.\n+            vec::iter2(substs, m_substs) {|s, ms|\n+                demand::simple(fcx, sp, s, ms);\n             }\n+            selfty\n+          }\n+          _ { t }\n         }\n-    } else { mty }\n+    }\n }\n \n // Replaces all occurrences of the `self` region with `with_region`.  Note\n@@ -2190,6 +2210,10 @@ fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n     }\n }\n \n+type self_subst = {selfty: ty::t,\n+                   fcx: @fn_ctxt,\n+                   sp: span};\n+\n /*\n   Takes arguments describing a method, and returns either its origin,\n   or <none> if it's unbound.\n@@ -2249,8 +2273,8 @@ fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n         }\n         if has_self && !option::is_none(self_sub) {\n             let fty = fcx.node_ty(node_id);\n-            let fty = fixup_self_in_method_ty(\n-                tcx, fty, substs, option::get(self_sub));\n+            let fty = fixup_self_param(\n+                fcx, fty, substs, option::get(self_sub), expr.span);\n             fcx.write_ty(node_id, fty);\n         }\n         if ty::type_has_rptrs(ty::ty_fn_ret(fty)) {\n@@ -2273,8 +2297,11 @@ enum method_kind {\n fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n      tps: [ty::t], parent: method_kind, name: ast::ident, sp: span,\n                         include_private: bool)\n-    -> option<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n-        origin: method_origin, self_sub: option<self_subst>}> {\n+    -> option<{method_ty: ty::t,\n+               n_tps: uint,\n+               substs: [ty::t],\n+               origin: method_origin,\n+               self_sub: option<ty::t>}> {\n     let mut i = 0u;\n     for ms.each {|m|\n        if m.ident == name {\n@@ -2318,9 +2345,11 @@ fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n                        name: ast::ident, ty: ty::t,\n                        include_private: bool)\n-    -> option<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n-                  origin: method_origin,\n-                  self_sub: option<self_subst>}> {\n+    -> option<{method_ty: ty::t,\n+               n_tps: uint,\n+               substs: [ty::t],\n+               origin: method_origin,\n+               self_sub: option<ty::t>}> {\n     let tcx = fcx.ccx.tcx;\n \n     #debug[\"lookup_method_inner: expr=%s name=%s ty=%s\",\n@@ -2345,7 +2374,7 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n                               n_tps: vec::len(*m.tps),\n                               substs: tps,\n                               origin: method_param(iid, pos, n, bound_n),\n-                              self_sub: some(self_param(ty, fcx, expr.span))\n+                              self_sub: some(ty)\n                              });\n                   }\n                   _ {}"}, {"sha": "10ce4aaac5fdf8789d64ce17dad617427e261e36", "filename": "src/test/run-pass/regions-borrow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e6943d8201215e60b74df7d3be8f48a52b3c2b7/src%2Ftest%2Frun-pass%2Fregions-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6943d8201215e60b74df7d3be8f48a52b3c2b7/src%2Ftest%2Frun-pass%2Fregions-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-borrow.rs?ref=3e6943d8201215e60b74df7d3be8f48a52b3c2b7", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n fn foo(x: &uint) -> &uint { x }\n \n fn main() {"}]}