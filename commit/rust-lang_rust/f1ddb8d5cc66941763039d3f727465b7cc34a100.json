{"sha": "f1ddb8d5cc66941763039d3f727465b7cc34a100", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZGRiOGQ1Y2M2Njk0MTc2MzAzOWQzZjcyNzQ2NWI3Y2MzNGExMDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-29T21:33:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-29T21:33:37Z"}, "message": "auto merge of #6080 : pcwalton/rust/demode-everything, r=pcwalton\n\nr? @brson", "tree": {"sha": "66132a53979403297cbe192ce936cfa7c5b3cb1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66132a53979403297cbe192ce936cfa7c5b3cb1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1ddb8d5cc66941763039d3f727465b7cc34a100", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ddb8d5cc66941763039d3f727465b7cc34a100", "html_url": "https://github.com/rust-lang/rust/commit/f1ddb8d5cc66941763039d3f727465b7cc34a100", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1ddb8d5cc66941763039d3f727465b7cc34a100/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "html_url": "https://github.com/rust-lang/rust/commit/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a"}, {"sha": "78f33437b66793b10eb2a72d0d20cbf2bf0eacb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/78f33437b66793b10eb2a72d0d20cbf2bf0eacb5", "html_url": "https://github.com/rust-lang/rust/commit/78f33437b66793b10eb2a72d0d20cbf2bf0eacb5"}], "stats": {"total": 3533, "additions": 1567, "deletions": 1966}, "files": [{"sha": "136c7ee9da3f2ce71db227dec097d43905dac459", "filename": "doc/rust.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -2187,7 +2187,7 @@ A loop expression denotes an infinite loop;\n see [Continue expressions](#continue-expressions) for continue expressions.\n \n ~~~~~~~~{.ebnf .gram}\n-loop_expr : \"loop\" [ ident ':' ] '{' block '}';\n+loop_expr : [ lifetime ':' ] \"loop\" '{' block '}';\n ~~~~~~~~\n \n A `loop` expression may optionally have a _label_.\n@@ -2198,7 +2198,7 @@ See [Break expressions](#break-expressions).\n ### Break expressions\n \n ~~~~~~~~{.ebnf .gram}\n-break_expr : \"break\" [ ident ];\n+break_expr : \"break\" [ lifetime ];\n ~~~~~~~~\n \n A `break` expression has an optional `label`.\n@@ -2211,7 +2211,7 @@ but must enclose it.\n ### Continue expressions\n \n ~~~~~~~~{.ebnf .gram}\n-continue_expr : \"loop\" [ ident ];\n+continue_expr : \"loop\" [ lifetime ];\n ~~~~~~~~\n \n A continue expression, written `loop`, also has an optional `label`.\n@@ -2393,7 +2393,7 @@ variables in the arm's block, and control enters the block.\n An example of an `match` expression:\n \n \n-~~~~\n+~~~~ {.xfail-test}\n # fn process_pair(a: int, b: int) { }\n # fn process_ten() { }\n "}, {"sha": "9f59f1d8fe48db839ddcaf37696ee1ab78daf51e", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -14,7 +14,6 @@ use cast::transmute;\n use kinds::Copy;\n use old_iter;\n use option::Option;\n-use ptr::addr_of;\n use sys;\n use uint;\n use vec;\n@@ -40,8 +39,7 @@ pub mod rustrt {\n #[inline(always)]\n pub fn capacity<T>(v: @[T]) -> uint {\n     unsafe {\n-        let repr: **raw::VecRepr =\n-            ::cast::transmute(addr_of(&v));\n+        let repr: **raw::VecRepr = transmute(&v);\n         (**repr).unboxed.alloc / sys::size_of::<T>()\n     }\n }\n@@ -187,13 +185,12 @@ pub mod traits {}\n \n pub mod raw {\n     use at_vec::{capacity, rustrt};\n-    use cast::transmute;\n+    use cast::{transmute, transmute_copy};\n     use libc;\n-    use unstable::intrinsics::{move_val_init};\n-    use ptr::addr_of;\n     use ptr;\n     use sys;\n     use uint;\n+    use unstable::intrinsics::{move_val_init};\n     use vec;\n \n     pub type VecRepr = vec::raw::VecRepr;\n@@ -208,18 +205,17 @@ pub mod raw {\n      */\n     #[inline(always)]\n     pub unsafe fn set_len<T>(v: @[T], new_len: uint) {\n-        let repr: **mut VecRepr = ::cast::transmute(addr_of(&v));\n+        let repr: **mut VecRepr = transmute(&v);\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n     #[inline(always)]\n     pub unsafe fn push<T>(v: &mut @[T], initval: T) {\n-        let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n+        let repr: **VecRepr = transmute_copy(&v);\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n             push_fast(v, initval);\n-        }\n-        else {\n+        } else {\n             push_slow(v, initval);\n         }\n     }\n@@ -229,7 +225,7 @@ pub mod raw {\n         let repr: **mut VecRepr = ::cast::transmute(v);\n         let fill = (**repr).unboxed.fill;\n         (**repr).unboxed.fill += sys::size_of::<T>();\n-        let p = addr_of(&((**repr).unboxed.data));\n+        let p = &((**repr).unboxed.data);\n         let p = ptr::offset(p, fill) as *mut T;\n         move_val_init(&mut(*p), initval);\n     }"}, {"sha": "6fb737d37709f302a5f39936a86812d71b1b1f6b", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 57, "deletions": 4, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -10,21 +10,56 @@\n \n //! Unsafe casting functions\n \n+use sys;\n+use unstable;\n+\n pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n     #[link_name = \"rusti\"]\n     pub extern \"rust-intrinsic\" {\n         fn forget<T>(+x: T);\n+\n+        #[cfg(stage0)]\n         fn reinterpret_cast<T, U>(&&e: T) -> U;\n+\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        #[cfg(stage3)]\n+        fn transmute<T,U>(e: T) -> U;\n     }\n }\n \n /// Casts the value at `src` to U. The two types must have the same length.\n #[inline(always)]\n+#[cfg(stage0)]\n pub unsafe fn reinterpret_cast<T, U>(src: &T) -> U {\n     rusti::reinterpret_cast(*src)\n }\n \n+/// Unsafely copies and casts the value at `src` to U, even if the value is\n+/// noncopyable. The two types must have the same length.\n+#[inline(always)]\n+#[cfg(stage0)]\n+pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n+    rusti::reinterpret_cast(*src)\n+}\n+\n+#[inline(always)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n+    let mut dest: U = unstable::intrinsics::init();\n+    {\n+        let dest_ptr: *mut u8 = rusti::transmute(&mut dest);\n+        let src_ptr: *u8 = rusti::transmute(src);\n+        unstable::intrinsics::memmove64(dest_ptr,\n+                                        src_ptr,\n+                                        sys::size_of::<U>() as u64);\n+    }\n+    dest\n+}\n+\n /**\n  * Move a thing into the void\n  *\n@@ -53,12 +88,21 @@ pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n  *     assert!(transmute(\"L\") == ~[76u8, 0u8]);\n  */\n #[inline(always)]\n+#[cfg(stage0)]\n pub unsafe fn transmute<L, G>(thing: L) -> G {\n     let newthing: G = reinterpret_cast(&thing);\n     forget(thing);\n     newthing\n }\n \n+#[inline(always)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub unsafe fn transmute<L, G>(thing: L) -> G {\n+    rusti::transmute(thing)\n+}\n+\n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n pub unsafe fn transmute_mut<'a,T>(ptr: &'a T) -> &'a mut T { transmute(ptr) }\n@@ -112,11 +156,20 @@ pub unsafe fn copy_lifetime_vec<'a,S,T>(_ptr: &'a [S], ptr: &T) -> &'a T {\n \n #[cfg(test)]\n mod tests {\n-    use cast::{bump_box_refcount, reinterpret_cast, transmute};\n+    use cast::{bump_box_refcount, transmute};\n \n     #[test]\n+    #[cfg(stage0)]\n     fn test_reinterpret_cast() {\n-        assert!(1u == unsafe { reinterpret_cast(&1) });\n+        assert!(1u == unsafe { ::cast::reinterpret_cast(&1) });\n+    }\n+\n+    #[test]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn test_transmute_copy() {\n+        assert!(1u == unsafe { ::cast::transmute_copy(&1) });\n     }\n \n     #[test]\n@@ -125,8 +178,8 @@ mod tests {\n             let box = @~\"box box box\";       // refcount 1\n             bump_box_refcount(box);         // refcount 2\n             let ptr: *int = transmute(box); // refcount 2\n-            let _box1: @~str = reinterpret_cast(&ptr);\n-            let _box2: @~str = reinterpret_cast(&ptr);\n+            let _box1: @~str = ::cast::transmute_copy(&ptr);\n+            let _box2: @~str = ::cast::transmute_copy(&ptr);\n             assert!(*_box1 == ~\"box box box\");\n             assert!(*_box2 == ~\"box box box\");\n             // Will destroy _box1 and _box2. Without the bump, this would"}, {"sha": "50a3bba049bbb44253c1c8d56946288757d56a57", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 65, "deletions": 19, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -327,6 +327,7 @@ impl<T: Owned> ::clone::Clone for SharedChan<T> {\n #[allow(non_camel_case_types)]\n pub mod oneshot {\n     priv use core::kinds::Owned;\n+    use ptr::to_unsafe_ptr;\n \n     pub fn init<T: Owned>() -> (client::Oneshot<T>, server::Oneshot<T>) {\n         pub use core::pipes::HasBuffer;\n@@ -341,7 +342,7 @@ pub mod oneshot {\n         do ::core::pipes::entangle_buffer(buffer) |buffer, data| {\n             {\n                 data.Oneshot.set_buffer(buffer);\n-                ::ptr::addr_of(&(data.Oneshot))\n+                to_unsafe_ptr(&data.Oneshot)\n             }\n         }\n     }\n@@ -394,58 +395,103 @@ pub mod oneshot {\n }\n \n /// The send end of a oneshot pipe.\n-pub type ChanOne<T> = oneshot::client::Oneshot<T>;\n+pub struct ChanOne<T> {\n+    contents: oneshot::client::Oneshot<T>\n+}\n+\n+impl<T> ChanOne<T> {\n+    pub fn new(contents: oneshot::client::Oneshot<T>) -> ChanOne<T> {\n+        ChanOne {\n+            contents: contents\n+        }\n+    }\n+}\n+\n /// The receive end of a oneshot pipe.\n-pub type PortOne<T> = oneshot::server::Oneshot<T>;\n+pub struct PortOne<T> {\n+    contents: oneshot::server::Oneshot<T>\n+}\n+\n+impl<T> PortOne<T> {\n+    pub fn new(contents: oneshot::server::Oneshot<T>) -> PortOne<T> {\n+        PortOne {\n+            contents: contents\n+        }\n+    }\n+}\n \n /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n     let (chan, port) = oneshot::init();\n-    (port, chan)\n+    (PortOne::new(port), ChanOne::new(chan))\n }\n \n pub impl<T: Owned> PortOne<T> {\n     fn recv(self) -> T { recv_one(self) }\n     fn try_recv(self) -> Option<T> { try_recv_one(self) }\n+    fn unwrap(self) -> oneshot::server::Oneshot<T> {\n+        match self {\n+            PortOne { contents: s } => s\n+        }\n+    }\n }\n \n pub impl<T: Owned> ChanOne<T> {\n     fn send(self, data: T) { send_one(self, data) }\n     fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n+    fn unwrap(self) -> oneshot::client::Oneshot<T> {\n+        match self {\n+            ChanOne { contents: s } => s\n+        }\n+    }\n }\n \n /**\n  * Receive a message from a oneshot pipe, failing if the connection was\n  * closed.\n  */\n pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n-    let oneshot::send(message) = recv(port);\n-    message\n+    match port {\n+        PortOne { contents: port } => {\n+            let oneshot::send(message) = recv(port);\n+            message\n+        }\n+    }\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n-    let message = try_recv(port);\n-\n-    if message.is_none() { None }\n-    else {\n-        let oneshot::send(message) = message.unwrap();\n-        Some(message)\n+    match port {\n+        PortOne { contents: port } => {\n+            let message = try_recv(port);\n+\n+            if message.is_none() {\n+                None\n+            } else {\n+                let oneshot::send(message) = message.unwrap();\n+                Some(message)\n+            }\n+        }\n     }\n }\n \n /// Send a message on a oneshot pipe, failing if the connection was closed.\n pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n-    oneshot::client::send(chan, data);\n+    match chan {\n+        ChanOne { contents: chan } => oneshot::client::send(chan, data),\n+    }\n }\n \n /**\n  * Send a message on a oneshot pipe, or return false if the connection was\n  * closed.\n  */\n-pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T)\n-        -> bool {\n-    oneshot::client::try_send(chan, data).is_some()\n+pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n+    match chan {\n+        ChanOne { contents: chan } => {\n+            oneshot::client::try_send(chan, data).is_some()\n+        }\n+    }\n }\n \n \n@@ -519,11 +565,11 @@ mod test {\n \n     #[test]\n     fn test_oneshot() {\n-        let (c, p) = oneshot::init();\n+        let (p, c) = oneshot();\n \n-        oneshot::client::send(c, ());\n+        c.send(());\n \n-        recv_one(p)\n+        p.recv()\n     }\n \n     #[test]"}, {"sha": "c3518cc8b6ee25c9175cf06c3e62a57bf8a2e26e", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -53,7 +53,7 @@ pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n             let res =\n                 rustrt::tdefl_compress_mem_to_heap(b as *c_void,\n                                                    len as size_t,\n-                                                   ptr::addr_of(&outsz),\n+                                                   &outsz,\n                                                    lz_norm);\n             assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n@@ -71,7 +71,7 @@ pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n             let res =\n                 rustrt::tinfl_decompress_mem_to_heap(b as *c_void,\n                                                      len as size_t,\n-                                                     ptr::addr_of(&outsz),\n+                                                     &outsz,\n                                                      0);\n             assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,"}, {"sha": "0d0a98359d14c54818c52410c97f08f2d94c1e72", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -338,7 +338,7 @@ pub fn cleanup_stack_for_failure() {\n         // own stack roots on the stack anyway.\n         let sentinel_box = ~0;\n         let sentinel: **Word = if expect_sentinel() {\n-            cast::transmute(ptr::addr_of(&sentinel_box))\n+            cast::transmute(&sentinel_box)\n         } else {\n             ptr::null()\n         };"}, {"sha": "debca1ead82f88a69104325dce6463bf9f8066b2", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations on managed box types\n \n-use ptr;\n+use ptr::to_unsafe_ptr;\n \n #[cfg(notest)] use cmp::{Eq, Ord};\n \n@@ -38,13 +38,15 @@ pub mod raw {\n #[inline(always)]\n pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     //! Determine if two shared boxes point to the same object\n-    ptr::addr_of(&(*a)) == ptr::addr_of(&(*b))\n+    let a_ptr: *T = to_unsafe_ptr(&*a), b_ptr: *T = to_unsafe_ptr(&*b);\n+    a_ptr == b_ptr\n }\n \n #[inline(always)]\n pub fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n     //! Determine if two mutable shared boxes point to the same object\n-    ptr::addr_of(&(*a)) == ptr::addr_of(&(*b))\n+    let a_ptr: *T = to_unsafe_ptr(&*a), b_ptr: *T = to_unsafe_ptr(&*b);\n+    a_ptr == b_ptr\n }\n \n #[cfg(notest)]"}, {"sha": "17192b4257b16a6b9b5a0dc11c65a7c38a375ec9", "filename": "src/libcore/option.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -49,7 +49,6 @@ use num::Zero;\n use old_iter::{BaseIter, MutableIter, ExtendedIter};\n use old_iter;\n \n-#[cfg(test)] use ptr;\n #[cfg(test)] use str;\n \n /// The option type\n@@ -481,12 +480,14 @@ pub impl<T:Copy + Zero> Option<T> {\n \n #[test]\n fn test_unwrap_ptr() {\n-    let x = ~0;\n-    let addr_x = ptr::addr_of(&(*x));\n-    let opt = Some(x);\n-    let y = opt.unwrap();\n-    let addr_y = ptr::addr_of(&(*y));\n-    assert!(addr_x == addr_y);\n+    unsafe {\n+        let x = ~0;\n+        let addr_x: *int = ::cast::transmute(&*x);\n+        let opt = Some(x);\n+        let y = opt.unwrap();\n+        let addr_y: *int = ::cast::transmute(&*y);\n+        assert!(addr_x == addr_y);\n+    }\n }\n \n #[test]"}, {"sha": "462c5be3bcf751b49a7eddc5cbe9e097f04aaee7", "filename": "src/libcore/path.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -21,6 +21,11 @@ use str;\n use to_str::ToStr;\n use ascii::{AsciiCast, AsciiStr};\n \n+#[cfg(windows)]\n+pub use Path = self::WindowsPath;\n+#[cfg(unix)]\n+pub use Path = self::PosixPath;\n+\n #[deriving(Clone, Eq)]\n pub struct WindowsPath {\n     host: Option<~str>,\n@@ -72,22 +77,6 @@ pub trait GenericPath {\n     fn is_absolute(&self) -> bool;\n }\n \n-#[cfg(windows)]\n-pub type Path = WindowsPath;\n-\n-#[cfg(windows)]\n-pub fn Path(s: &str) -> Path {\n-    WindowsPath(s)\n-}\n-\n-#[cfg(unix)]\n-pub type Path = PosixPath;\n-\n-#[cfg(unix)]\n-pub fn Path(s: &str) -> Path {\n-    PosixPath(s)\n-}\n-\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n mod stat {"}, {"sha": "95b24d20a4bc20a113795627962fd9005cea8a59", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -82,7 +82,7 @@ bounded and unbounded protocols allows for less code duplication.\n \n */\n \n-use cast::{forget, reinterpret_cast, transmute};\n+use cast::{forget, transmute, transmute_copy};\n use either::{Either, Left, Right};\n use kinds::Owned;\n use libc;\n@@ -95,7 +95,7 @@ use vec;\n static SPIN_COUNT: uint = 0;\n \n macro_rules! move_it (\n-    { $x:expr } => ( unsafe { let y = *ptr::addr_of(&($x)); y } )\n+    { $x:expr } => ( unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } )\n )\n \n #[deriving(Eq)]\n@@ -131,7 +131,7 @@ pub struct PacketHeader {\n     mut state: State,\n     mut blocked_task: *rust_task,\n \n-    // This is a reinterpret_cast of a ~buffer, that can also be cast\n+    // This is a transmute_copy of a ~buffer, that can also be cast\n     // to a buffer_header if need be.\n     mut buffer: *libc::c_void,\n }\n@@ -170,12 +170,12 @@ pub impl PacketHeader {\n     // thing. You'll proobably want to forget them when you're done.\n     unsafe fn buf_header(&self) -> ~BufferHeader {\n         assert!(self.buffer.is_not_null());\n-        reinterpret_cast(&self.buffer)\n+        transmute_copy(&self.buffer)\n     }\n \n     fn set_buffer<T:Owned>(&self, b: ~Buffer<T>) {\n         unsafe {\n-            self.buffer = reinterpret_cast(&b);\n+            self.buffer = transmute_copy(&b);\n         }\n     }\n }\n@@ -211,14 +211,14 @@ fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n     };\n \n     unsafe {\n-        b.data.header.buffer = reinterpret_cast(&b);\n+        b.data.header.buffer = transmute_copy(&b);\n     }\n     b\n }\n \n pub fn packet<T>() -> *Packet<T> {\n     let b = unibuffer();\n-    let p = ptr::addr_of(&(b.data));\n+    let p = ptr::to_unsafe_ptr(&(b.data));\n     // We'll take over memory management from here.\n     unsafe { forget(b) }\n     p\n@@ -229,7 +229,7 @@ pub fn entangle_buffer<T:Owned,Tstart:Owned>(\n     init: &fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n     -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n {\n-    let p = init(unsafe { reinterpret_cast(&buffer) }, &buffer.data);\n+    let p = init(unsafe { transmute_copy(&buffer) }, &buffer.data);\n     unsafe { forget(buffer) }\n     (SendPacketBuffered(p), RecvPacketBuffered(p))\n }\n@@ -305,7 +305,7 @@ impl<T> ::ops::Drop for BufferResource<T> {\n     fn finalize(&self) {\n         unsafe {\n             let b = move_it!(self.buffer);\n-            //let p = ptr::addr_of(*b);\n+            //let p = ptr::to_unsafe_ptr(*b);\n             //error!(\"drop %?\", p);\n             let old_count = intrinsics::atomic_xsub_rel(&mut b.header.ref_count, 1);\n             //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n@@ -322,7 +322,7 @@ impl<T> ::ops::Drop for BufferResource<T> {\n }\n \n fn BufferResource<T>(b: ~Buffer<T>) -> BufferResource<T> {\n-    //let p = ptr::addr_of(*b);\n+    //let p = ptr::to_unsafe_ptr(*b);\n     //error!(\"take %?\", p);\n     unsafe { intrinsics::atomic_xadd_acq(&mut b.header.ref_count, 1) };\n \n@@ -336,7 +336,7 @@ pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n-    assert!(ptr::addr_of(&(p.header)) == header);\n+    assert!(ptr::to_unsafe_ptr(&(p.header)) == header);\n     assert!(p.payload.is_none());\n     p.payload = Some(payload);\n     let old_state = swap_state_rel(&mut p.header.state, Full);\n@@ -356,7 +356,7 @@ pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n                 unsafe {\n                     rustrt::task_signal_event(\n                         old_task,\n-                        ptr::addr_of(&(p.header)) as *libc::c_void);\n+                        ptr::to_unsafe_ptr(&(p.header)) as *libc::c_void);\n                     rustrt::rust_task_deref(old_task);\n                 }\n             }\n@@ -521,7 +521,7 @@ fn sender_terminate<T:Owned>(p: *Packet<T>) {\n             unsafe {\n                 rustrt::task_signal_event(\n                     old_task,\n-                    ptr::addr_of(&(p.header)) as *libc::c_void);\n+                    ptr::to_unsafe_ptr(&(p.header)) as *libc::c_void);\n                 rustrt::rust_task_deref(old_task);\n             }\n         }\n@@ -665,7 +665,7 @@ pub fn SendPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n         p: Some(p),\n         buffer: unsafe {\n             Some(BufferResource(\n-                get_buffer(ptr::addr_of(&((*p).header)))))\n+                get_buffer(ptr::to_unsafe_ptr(&((*p).header)))))\n         }\n     }\n }\n@@ -681,7 +681,7 @@ pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;\n-            let header = ptr::addr_of(&(packet.header));\n+            let header = ptr::to_unsafe_ptr(&(packet.header));\n             //forget(packet);\n             header\n           },\n@@ -747,7 +747,7 @@ impl<T:Owned,Tbuffer:Owned> Selectable for RecvPacketBuffered<T, Tbuffer> {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;\n-            let header = ptr::addr_of(&(packet.header));\n+            let header = ptr::to_unsafe_ptr(&(packet.header));\n             //forget(packet);\n             header\n           },\n@@ -763,7 +763,7 @@ pub fn RecvPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n         p: Some(p),\n         buffer: unsafe {\n             Some(BufferResource(\n-                get_buffer(ptr::addr_of(&((*p).header)))))\n+                get_buffer(ptr::to_unsafe_ptr(&((*p).header)))))\n         }\n     }\n }\n@@ -885,9 +885,9 @@ mod test {\n \n     #[test]\n     fn test_oneshot() {\n-        let (c, p) = oneshot::init();\n+        let (p, c) = oneshot();\n \n-        oneshot::client::send(c, ());\n+        c.send(());\n \n         recv_one(p)\n     }"}, {"sha": "86b36834bbd6e6c51f689523c7eee76ed20145aa", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -39,17 +39,6 @@ pub mod libc_ {\n     }\n }\n \n-pub mod rusti {\n-    #[abi = \"rust-intrinsic\"]\n-    pub extern \"rust-intrinsic\" {\n-        fn addr_of<T>(&&val: T) -> *T;\n-    }\n-}\n-\n-/// Get an unsafe pointer to a value\n-#[inline(always)]\n-pub fn addr_of<T>(val: &T) -> *T { unsafe { rusti::addr_of(*val) } }\n-\n /// Calculate the offset from a pointer\n #[inline(always)]\n pub fn offset<T>(ptr: *T, count: uint) -> *T {\n@@ -130,7 +119,7 @@ pub unsafe fn set_memory<T>(dst: *mut T, c: int, count: uint) {\n /**\n   Transform a region pointer - &T - to an unsafe pointer - *T.\n   This is safe, but is implemented with an unsafe block due to\n-  reinterpret_cast.\n+  transmute.\n */\n #[inline(always)]\n pub fn to_unsafe_ptr<T>(thing: &T) -> *T {\n@@ -140,7 +129,7 @@ pub fn to_unsafe_ptr<T>(thing: &T) -> *T {\n /**\n   Transform a const region pointer - &const T - to a const unsafe pointer -\n   *const T. This is safe, but is implemented with an unsafe block due to\n-  reinterpret_cast.\n+  transmute.\n */\n #[inline(always)]\n pub fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n@@ -150,7 +139,7 @@ pub fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n /**\n   Transform a mutable region pointer - &mut T - to a mutable unsafe pointer -\n   *mut T. This is safe, but is implemented with an unsafe block due to\n-  reinterpret_cast.\n+  transmute.\n */\n #[inline(always)]\n pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n@@ -160,7 +149,7 @@ pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n /**\n   Cast a region pointer - &T - to a uint.\n   This is safe, but is implemented with an unsafe block due to\n-  reinterpret_cast.\n+  transmute.\n \n   (I couldn't think of a cutesy name for this one.)\n */"}, {"sha": "967a8cdf49bf3947037ad2d130471a2bfcb44a74", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -698,7 +698,7 @@ impl<R: Rng> Rng for @R {\n  * generator.\n  */\n pub fn random<T: Rand>() -> T {\n-    task_rng().gen()\n+    (*task_rng()).gen()\n }\n \n #[cfg(test)]"}, {"sha": "0f1ae09bd944ba104e7e17dcae2c0a957202bcee", "filename": "src/libcore/rt/thread.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -21,10 +21,10 @@ pub struct Thread {\n \n pub impl Thread {\n     fn start(main: ~fn()) -> Thread {\n-        fn substart(main: &fn()) -> *raw_thread {\n-            unsafe { rust_raw_thread_start(&main) }\n+        fn substart(main: &~fn()) -> *raw_thread {\n+            unsafe { rust_raw_thread_start(main) }\n         }\n-        let raw = substart(main);\n+        let raw = substart(&main);\n         Thread {\n             main: main,\n             raw_thread: raw\n@@ -39,6 +39,6 @@ impl Drop for Thread {\n }\n \n extern {\n-    pub unsafe fn rust_raw_thread_start(f: &(&fn())) -> *raw_thread;\n+    pub unsafe fn rust_raw_thread_start(f: &(~fn())) -> *raw_thread;\n     pub unsafe fn rust_raw_thread_join_delete(thread: *raw_thread);\n }"}, {"sha": "cb7925abdcdf78530fc642555ed7a41349001986", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -366,14 +366,15 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n \n /// Transmute an owned vector to a Buf\n pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n-    let data = unsafe { malloc(v.len() as size_t) } as *u8;\n-    assert!(data.is_not_null());\n-    do vec::as_imm_buf(v) |b, l| {\n-        let data = data as *mut u8;\n-        unsafe { ptr::copy_memory(data, b, l) }\n+    unsafe {\n+        let data = malloc(v.len() as size_t) as *u8;\n+        assert!(data.is_not_null());\n+        do vec::as_imm_buf(v) |b, l| {\n+            let data = data as *mut u8;\n+            ptr::copy_memory(data, b, l)\n+        }\n+        uvll::buf_init(data, v.len())\n     }\n-    let buf = unsafe { uvll::buf_init(data, v.len()) };\n-    return buf;\n }\n \n /// Transmute a Buf that was once a ~[u8] back to ~[u8]\n@@ -384,6 +385,7 @@ pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n         return Some(v);\n     } else {\n         // No buffer\n+        rtdebug!(\"No buffer!\");\n         return None;\n     }\n }"}, {"sha": "c9a696fcd15ca6e169da18957d650dd2e504e4b6", "filename": "src/libcore/rt/uvll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -252,7 +252,7 @@ pub unsafe fn async_send(async_handle: *uv_async_t) {\n }\n pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n     let out_buf = uv_buf_t { base: ptr::null(), len: 0 as size_t };\n-    let out_buf_ptr = ptr::addr_of(&out_buf);\n+    let out_buf_ptr = ptr::to_unsafe_ptr(&out_buf);\n     rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n     return out_buf;\n }\n@@ -330,7 +330,7 @@ pub unsafe fn free_base_of_buf(buf: uv_buf_t) {\n \n pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n     let err = last_error(uv_loop);\n-    let err_ptr = ptr::addr_of(&err);\n+    let err_ptr = ptr::to_unsafe_ptr(&err);\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n     let err_msg = str::raw::from_c_str(strerror(err_ptr));\n     return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n@@ -339,7 +339,7 @@ pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n \n pub unsafe fn get_last_err_data(uv_loop: *c_void) -> uv_err_data {\n     let err = last_error(uv_loop);\n-    let err_ptr = ptr::addr_of(&err);\n+    let err_ptr = ptr::to_unsafe_ptr(&err);\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n     let err_msg = str::raw::from_c_str(strerror(err_ptr));\n     uv_err_data { err_name: err_name, err_msg: err_msg }"}, {"sha": "ebf36e4e09ab4efbb730160eb04bb08d65fc90a9", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -93,7 +93,10 @@ pub mod rustrt {\n pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n     pub extern \"rust-intrinsic\" {\n+        #[cfg(stage0)]\n         pub fn frame_address(f: &once fn(x: *u8));\n+        #[cfg(not(stage0))]\n+        pub fn frame_address(+f: &once fn(x: *u8));\n     }\n }\n "}, {"sha": "064bffa00561f80924354ffcca070f40f5d712ea", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -18,6 +18,7 @@\n  */\n \n use at_vec;\n+use cast::transmute;\n use cast;\n use char;\n use clone::Clone;\n@@ -2045,7 +2046,7 @@ pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n #[inline(always)]\n pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n     unsafe {\n-        let v : *(*u8,uint) = ::cast::transmute(ptr::addr_of(&s));\n+        let v : *(*u8,uint) = transmute(&s);\n         let (buf,len) = *v;\n         f(buf, len)\n     }"}, {"sha": "8cad0a22886424be926e7f213d0474e12e691b41", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -154,7 +154,7 @@ pub fn pref_align_of_val<T>(_val: &T) -> uint {\n #[inline(always)]\n pub fn refcount<T>(t: @T) -> uint {\n     unsafe {\n-        let ref_ptr: *uint = cast::reinterpret_cast(&t);\n+        let ref_ptr: *uint = cast::transmute_copy(&t);\n         *ref_ptr - 1\n     }\n }"}, {"sha": "67bc3adeb41c0c61f5055c9d3bc4e153d7b799a4", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -59,9 +59,7 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     let map_ptr = rt::rust_get_task_local_data(task);\n     if map_ptr.is_null() {\n         let map: TaskLocalMap = @mut ~[];\n-        // Use reinterpret_cast -- transmute would take map away from us also.\n-        rt::rust_set_task_local_data(\n-            task, cast::transmute(map));\n+        rt::rust_set_task_local_data(task, cast::transmute(map));\n         rt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n         // Also need to reference it an extra time to keep it for now.\n         let nonmut = cast::transmute::<TaskLocalMap,\n@@ -77,12 +75,10 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     }\n }\n \n-unsafe fn key_to_key_value<T:Durable>(\n-    key: LocalDataKey<T>) -> *libc::c_void {\n-\n+unsafe fn key_to_key_value<T:Durable>(key: LocalDataKey<T>) -> *libc::c_void {\n     // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n     // Use reintepret_cast -- transmute would leak (forget) the closure.\n-    let pair: (*libc::c_void, *libc::c_void) = cast::reinterpret_cast(&key);\n+    let pair: (*libc::c_void, *libc::c_void) = cast::transmute_copy(&key);\n     pair.first()\n }\n "}, {"sha": "96429932b184ad8b9cec7917b1d99ffc55e324fb", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -1028,10 +1028,10 @@ fn avoid_copying_the_body(spawnfn: &fn(v: ~fn())) {\n     let (p, ch) = stream::<uint>();\n \n     let x = ~1;\n-    let x_in_parent = ptr::addr_of(&(*x)) as uint;\n+    let x_in_parent = ptr::to_unsafe_ptr(&*x) as uint;\n \n     do spawnfn || {\n-        let x_in_child = ptr::addr_of(&(*x)) as uint;\n+        let x_in_child = ptr::to_unsafe_ptr(&*x) as uint;\n         ch.send(x_in_child);\n     }\n "}, {"sha": "507643ea5ec30c714283679595fb68d45d1d722b", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -93,7 +93,7 @@ use util;\n #[cfg(test)] use task::default_task_opts;\n \n macro_rules! move_it (\n-    { $x:expr } => ( unsafe { let y = *ptr::addr_of(&($x)); y } )\n+    { $x:expr } => ( unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } )\n )\n \n type TaskSet = HashSet<*rust_task>;"}, {"sha": "b58429a10aad58fbe15e449332b145810589368d", "filename": "src/libcore/unstable/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fintrinsics.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -47,9 +47,8 @@ pub extern \"rust-intrinsic\" {\n     pub fn forget<T>(_: T) -> ();\n \n     // XXX: intrinsic uses legacy modes\n+    #[cfg(stage0)]\n     fn reinterpret_cast<T,U>(&&src: T) -> U;\n-    // XXX: intrinsic uses legacy modes\n-    fn addr_of<T>(&&scr: T) -> *T;\n \n     pub fn needs_drop<T>() -> bool;\n "}, {"sha": "86767dc5bad859003205af2e16c20f53349023e4", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -26,11 +26,11 @@ use iterator::Iterator;\n use kinds::Copy;\n use libc;\n use option::{None, Option, Some};\n-use unstable::intrinsics;\n+use ptr::to_unsafe_ptr;\n use ptr;\n-use ptr::addr_of;\n use sys;\n use uint;\n+use unstable::intrinsics;\n use vec;\n \n #[cfg(notest)] use cmp::Equiv;\n@@ -117,7 +117,7 @@ pub fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n #[inline(always)]\n pub fn capacity<T>(v: &const ~[T]) -> uint {\n     unsafe {\n-        let repr: **raw::VecRepr = ::cast::transmute(v);\n+        let repr: **raw::VecRepr = transmute(v);\n         (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n     }\n }\n@@ -131,7 +131,7 @@ pub fn len<T>(v: &const [T]) -> uint {\n // A botch to tide us over until core and std are fully demuted.\n pub fn uniq_len<T>(v: &const ~[T]) -> uint {\n     unsafe {\n-        let v: &~[T] = ::cast::transmute(v);\n+        let v: &~[T] = transmute(v);\n         as_const_buf(*v, |_p, len| len)\n     }\n }\n@@ -280,9 +280,8 @@ pub fn slice<'r,T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n     assert!(end <= len(v));\n     do as_imm_buf(v) |p, _len| {\n         unsafe {\n-            ::cast::transmute(\n-                (ptr::offset(p, start),\n-                  (end - start) * sys::nonzero_size_of::<T>()))\n+            transmute((ptr::offset(p, start),\n+                       (end - start) * sys::nonzero_size_of::<T>()))\n         }\n     }\n }\n@@ -295,9 +294,8 @@ pub fn mut_slice<'r,T>(v: &'r mut [T], start: uint, end: uint)\n     assert!(end <= v.len());\n     do as_mut_buf(v) |p, _len| {\n         unsafe {\n-            ::cast::transmute(\n-                (ptr::mut_offset(p, start),\n-                  (end - start) * sys::nonzero_size_of::<T>()))\n+            transmute((ptr::mut_offset(p, start),\n+                       (end - start) * sys::nonzero_size_of::<T>()))\n         }\n     }\n }\n@@ -310,9 +308,8 @@ pub fn const_slice<'r,T>(v: &'r const [T], start: uint, end: uint)\n     assert!(end <= len(v));\n     do as_const_buf(v) |p, _len| {\n         unsafe {\n-            ::cast::transmute(\n-                (ptr::const_offset(p, start),\n-                  (end - start) * sys::nonzero_size_of::<T>()))\n+            transmute((ptr::const_offset(p, start),\n+                       (end - start) * sys::nonzero_size_of::<T>()))\n         }\n     }\n }\n@@ -489,14 +486,14 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n         {\n             let first_slice = slice(*v, 0, 1);\n             let last_slice = slice(*v, next_ln, ln);\n-            raw::copy_memory(::cast::transmute(last_slice), first_slice, 1);\n+            raw::copy_memory(transmute(last_slice), first_slice, 1);\n         }\n \n         // Memcopy everything to the left one element\n         {\n             let init_slice = slice(*v, 0, next_ln);\n             let tail_slice = slice(*v, 1, ln);\n-            raw::copy_memory(::cast::transmute(init_slice),\n+            raw::copy_memory(transmute(init_slice),\n                              tail_slice,\n                              next_ln);\n         }\n@@ -626,7 +623,7 @@ pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n #[inline(always)]\n pub fn push<T>(v: &mut ~[T], initval: T) {\n     unsafe {\n-        let repr: **raw::VecRepr = ::cast::transmute(&mut *v);\n+        let repr: **raw::VecRepr = transmute(&mut *v);\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n             push_fast(v, initval);\n@@ -640,10 +637,10 @@ pub fn push<T>(v: &mut ~[T], initval: T) {\n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n-    let repr: **mut raw::VecRepr = ::cast::transmute(v);\n+    let repr: **mut raw::VecRepr = transmute(v);\n     let fill = (**repr).unboxed.fill;\n     (**repr).unboxed.fill += sys::nonzero_size_of::<T>();\n-    let p = addr_of(&((**repr).unboxed.data));\n+    let p = to_unsafe_ptr(&((**repr).unboxed.data));\n     let p = ptr::offset(p, fill) as *mut T;\n     intrinsics::move_val_init(&mut(*p), initval);\n }\n@@ -1622,8 +1619,7 @@ pub fn as_imm_buf<T,U>(s: &[T],\n     // instead!\n \n     unsafe {\n-        let v : *(*T,uint) =\n-            ::cast::transmute(addr_of(&s));\n+        let v : *(*T,uint) = transmute(&s);\n         let (buf,len) = *v;\n         f(buf, len / sys::nonzero_size_of::<T>())\n     }\n@@ -1633,8 +1629,7 @@ pub fn as_imm_buf<T,U>(s: &[T],\n #[inline(always)]\n pub fn as_const_buf<T,U>(s: &const [T], f: &fn(*const T, uint) -> U) -> U {\n     unsafe {\n-        let v : *(*const T,uint) =\n-            ::cast::transmute(addr_of(&s));\n+        let v : *(*const T,uint) = transmute(&s);\n         let (buf,len) = *v;\n         f(buf, len / sys::nonzero_size_of::<T>())\n     }\n@@ -1644,8 +1639,7 @@ pub fn as_const_buf<T,U>(s: &const [T], f: &fn(*const T, uint) -> U) -> U {\n #[inline(always)]\n pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n     unsafe {\n-        let v : *(*mut T,uint) =\n-            ::cast::transmute(addr_of(&s));\n+        let v : *(*mut T,uint) = transmute(&s);\n         let (buf,len) = *v;\n         f(buf, len / sys::nonzero_size_of::<T>())\n     }\n@@ -2429,13 +2423,13 @@ pub struct UnboxedVecRepr {\n \n /// Unsafe operations\n pub mod raw {\n+    use cast::transmute;\n     use kinds::Copy;\n     use managed;\n     use option::{None, Some};\n-    use unstable::intrinsics;\n-    use ptr::addr_of;\n     use ptr;\n     use sys;\n+    use unstable::intrinsics;\n     use vec::{UnboxedVecRepr, as_const_buf, as_mut_buf, len, with_capacity};\n \n     /// The internal representation of a (boxed) vector\n@@ -2458,7 +2452,7 @@ pub mod raw {\n      */\n     #[inline(always)]\n     pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n-        let repr: **mut VecRepr = ::cast::transmute(v);\n+        let repr: **mut VecRepr = transmute(v);\n         (**repr).unboxed.fill = new_len * sys::nonzero_size_of::<T>();\n     }\n \n@@ -2473,22 +2467,22 @@ pub mod raw {\n      */\n     #[inline(always)]\n     pub unsafe fn to_ptr<T>(v: &[T]) -> *T {\n-        let repr: **SliceRepr = ::cast::transmute(&v);\n-        ::cast::transmute(addr_of(&((**repr).data)))\n+        let repr: **SliceRepr = transmute(&v);\n+        transmute(&((**repr).data))\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n     pub unsafe fn to_const_ptr<T>(v: &const [T]) -> *const T {\n-        let repr: **SliceRepr = ::cast::transmute(&v);\n-        ::cast::transmute(addr_of(&((**repr).data)))\n+        let repr: **SliceRepr = transmute(&v);\n+        transmute(&((**repr).data))\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n     pub unsafe fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n-        let repr: **SliceRepr = ::cast::transmute(&v);\n-        ::cast::transmute(addr_of(&((**repr).data)))\n+        let repr: **SliceRepr = transmute(&v);\n+        transmute(&((**repr).data))\n     }\n \n     /**\n@@ -2500,8 +2494,7 @@ pub mod raw {\n                                     len: uint,\n                                     f: &fn(v: &[T]) -> U) -> U {\n         let pair = (p, len * sys::nonzero_size_of::<T>());\n-        let v : *(&'blk [T]) =\n-            ::cast::transmute(addr_of(&pair));\n+        let v : *(&'blk [T]) = transmute(&pair);\n         f(*v)\n     }\n \n@@ -2514,8 +2507,7 @@ pub mod raw {\n                                         len: uint,\n                                         f: &fn(v: &mut [T]) -> U) -> U {\n         let pair = (p, len * sys::nonzero_size_of::<T>());\n-        let v : *(&'blk mut [T]) =\n-            ::cast::transmute(addr_of(&pair));\n+        let v : *(&'blk mut [T]) = transmute(&pair);\n         f(*v)\n     }\n "}, {"sha": "fc1efd3313cbc2857b5335dcb8cd7c577d4d5781", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 170, "deletions": 131, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -18,42 +18,38 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[legacy_modes];\n-\n-#[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n-#[allow(deprecated_mode)];\n-#[allow(deprecated_pattern)];\n \n extern mod std(vers = \"0.7-pre\");\n extern mod syntax(vers = \"0.7-pre\");\n \n use core::run;\n \n-use syntax::{ast, fold, visit, codemap};\n+use syntax::diagnostic;\n+use syntax::parse::token::ident_interner;\n+use syntax::parse::token;\n use syntax::parse;\n use syntax::print::pprust;\n-use syntax::diagnostic;\n+use syntax::{ast, fold, visit, codemap};\n \n #[deriving(Eq)]\n pub enum test_mode { tm_converge, tm_run, }\n \n pub struct Context { mode: test_mode } // + rng\n \n-pub fn write_file(filename: &Path, content: ~str) {\n-    result::get(\n-        &io::file_writer(filename, ~[io::Create, io::Truncate]))\n-        .write_str(content);\n+pub fn write_file(filename: &Path, content: &str) {\n+    result::get(&io::file_writer(filename, ~[io::Create, io::Truncate]))\n+                    .write_str(content);\n }\n \n-pub fn contains(haystack: ~str, needle: ~str) -> bool {\n+pub fn contains(haystack: &str, needle: &str) -> bool {\n     str::contains(haystack, needle)\n }\n \n pub fn find_rust_files(files: &mut ~[Path], path: &Path) {\n     if path.filetype() == Some(~\".rs\") && !contains(path.to_str(), ~\"utf8\") {\n         // ignoring \"utf8\" tests because something is broken\n-        files.push(*path);\n+        files.push(path.clone());\n     } else if os::path_is_dir(path)\n         && !contains(path.to_str(), ~\"compile-fail\")\n         && !contains(path.to_str(), ~\"build\") {\n@@ -64,9 +60,9 @@ pub fn find_rust_files(files: &mut ~[Path], path: &Path) {\n }\n \n \n-pub fn common_exprs() -> ~[ast::expr] {\n-    fn dse(e: ast::expr_) -> ast::expr {\n-        ast::expr {\n+pub fn common_exprs() -> ~[@ast::expr] {\n+    fn dse(e: ast::expr_) -> @ast::expr {\n+        @ast::expr {\n             id: 0,\n             callee_id: -1,\n             node: e,\n@@ -85,17 +81,17 @@ pub fn common_exprs() -> ~[ast::expr] {\n      dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n      dse(ast::expr_unary(ast::box(ast::m_imm),\n-                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n+                         dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n      dse(ast::expr_unary(ast::uniq(ast::m_imm),\n-                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n+                         dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n     ]\n }\n \n pub fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n-    safe_to_use_expr(*e, tm)\n+    safe_to_use_expr(e, tm)\n }\n \n-pub fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n+pub fn safe_to_use_expr(e: @ast::expr, tm: test_mode) -> bool {\n     match tm {\n       tm_converge => {\n         match e.node {\n@@ -134,28 +130,31 @@ pub fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n \n // Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n pub fn stash_expr_if(c: @fn(@ast::expr, test_mode)->bool,\n-                     es: @mut ~[ast::expr],\n+                     es: @mut ~[@ast::expr],\n                      e: @ast::expr,\n                      tm: test_mode) {\n     if c(e, tm) {\n-        *es += ~[*e];\n+        *es += ~[e];\n     } else {\n         /* now my indices are wrong :( */\n     }\n }\n \n-pub fn stash_ty_if(c: @fn(@ast::Ty, test_mode)->bool,\n-                   es: @mut ~[ast::Ty],\n+pub fn stash_ty_if(c: @fn(@ast::Ty, test_mode) -> bool,\n+                   es: @mut ~[@ast::Ty],\n                    e: @ast::Ty,\n                    tm: test_mode) {\n     if c(e, tm) {\n-        es.push(*e);\n+        es.push(e);\n     } else {\n         /* now my indices are wrong :( */\n     }\n }\n \n-pub struct StolenStuff {exprs: ~[ast::expr], tys: ~[ast::Ty]}\n+pub struct StolenStuff {\n+    exprs: ~[@ast::expr],\n+    tys: ~[@ast::Ty]\n+}\n \n pub fn steal(crate: @ast::crate, tm: test_mode) -> StolenStuff {\n     let exprs = @mut ~[];\n@@ -166,20 +165,23 @@ pub fn steal(crate: @ast::crate, tm: test_mode) -> StolenStuff {\n         .. *visit::default_simple_visitor()\n     });\n     visit::visit_crate(crate, (), v);\n-    StolenStuff {exprs: *exprs, tys: *tys}\n+    StolenStuff {\n+        exprs: (*exprs).clone(),\n+        tys: (*tys).clone(),\n+    }\n }\n \n \n pub fn safe_to_replace_expr(e: &ast::expr_, _tm: test_mode) -> bool {\n     match *e {\n-      // https://github.com/mozilla/rust/issues/652\n-      ast::expr_if(*) => { false }\n-      ast::expr_block(_) => { false }\n+        // https://github.com/mozilla/rust/issues/652\n+        ast::expr_if(*) => false,\n+        ast::expr_block(_) => false,\n \n-      // expr_call is also missing a constraint\n-      ast::expr_fn_block(*) => { false }\n+        // expr_call is also missing a constraint\n+        ast::expr_fn_block(*) => false,\n \n-      _ => { true }\n+        _ => true,\n     }\n }\n \n@@ -194,59 +196,66 @@ pub fn safe_to_replace_ty(t: &ast::ty_, _tm: test_mode) -> bool {\n }\n \n // Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n-pub fn replace_expr_in_crate(crate: @ast::crate, i: uint,\n-                             newexpr: ast::expr, tm: test_mode) ->\n-   ast::crate {\n+pub fn replace_expr_in_crate(crate: @ast::crate,\n+                             i: uint,\n+                             newexpr: @ast::expr,\n+                             tm: test_mode)\n+                             -> @ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_expr_rep(j_: @mut uint,\n                      i_: uint,\n-                     newexpr_: ast::expr_,\n+                     newexpr_: &ast::expr_,\n                      original: &ast::expr_,\n                      fld: @fold::ast_fold,\n                      tm_: test_mode)\n-                  -> ast::expr_ {\n-        *j_ += 1u;\n-        if i_ + 1u == *j_ && safe_to_replace_expr(original, tm_) {\n-            newexpr_\n+                     -> ast::expr_ {\n+        *j_ += 1;\n+        if i_ + 1 == *j_ && safe_to_replace_expr(original, tm_) {\n+            copy *newexpr_\n         } else {\n             fold::noop_fold_expr(original, fld)\n         }\n     }\n     let afp = @fold::AstFoldFns {\n         fold_expr: fold::wrap(|a,b| {\n-            fold_expr_rep(j, i, newexpr.node, a, b, tm)\n+            fold_expr_rep(j, i, &newexpr.node, a, b, tm)\n         }),\n         .. *fold::default_ast_fold()\n     };\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n-    *crate2\n+    crate2\n }\n \n \n // Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-pub fn replace_ty_in_crate(crate: @ast::crate, i: uint, newty: ast::Ty,\n-                           tm: test_mode) -> ast::crate {\n+pub fn replace_ty_in_crate(crate: @ast::crate,\n+                           i: uint,\n+                           newty: @ast::Ty,\n+                           tm: test_mode)\n+                           -> @ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_ty_rep(j_: @mut uint,\n                    i_: uint,\n-                   newty_: ast::ty_,\n+                   newty_: &ast::ty_,\n                    original: &ast::ty_,\n                    fld: @fold::ast_fold,\n                    tm_: test_mode)\n-                -> ast::ty_ {\n-        *j_ += 1u;\n-        if i_ + 1u == *j_ && safe_to_replace_ty(original, tm_) {\n-            newty_\n-        } else { fold::noop_fold_ty(original, fld) }\n+                   -> ast::ty_ {\n+        *j_ += 1;\n+        if i_ + 1 == *j_ && safe_to_replace_ty(original, tm_) {\n+            copy *newty_\n+        } else {\n+            fold::noop_fold_ty(original, fld)\n+        }\n     }\n     let afp = @fold::AstFoldFns {\n-        fold_ty: fold::wrap(|a,b| fold_ty_rep(j, i, newty.node, a, b, tm) ),\n+        fold_ty: fold::wrap(|a,b| fold_ty_rep(j, i, &newty.node, a, b, tm)),\n         .. *fold::default_ast_fold()\n     };\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n-    *crate2\n+    crate2\n }\n \n pub fn under(n: uint, it: &fn(uint)) {\n@@ -258,29 +267,44 @@ pub fn as_str(f: @fn(+x: @io::Writer)) -> ~str {\n     io::with_str_writer(f)\n }\n \n-pub fn check_variants_of_ast(crate: @ast::crate, codemap: @codemap::CodeMap,\n-                             filename: &Path, cx: Context) {\n+pub fn check_variants_of_ast(crate: @ast::crate,\n+                             codemap: @codemap::CodeMap,\n+                             filename: &Path,\n+                             cx: Context) {\n     let stolen = steal(crate, cx.mode);\n-    let extra_exprs = do common_exprs().filtered |a| {\n-        safe_to_use_expr(*a, cx.mode)\n+    let extra_exprs = do common_exprs().filtered |&a| {\n+        safe_to_use_expr(a, cx.mode)\n     };\n-    check_variants_T(crate, codemap, filename, ~\"expr\",\n-                     extra_exprs + stolen.exprs, pprust::expr_to_str,\n-                     replace_expr_in_crate, cx);\n-    check_variants_T(crate, codemap, filename, ~\"ty\", stolen.tys,\n-                     pprust::ty_to_str, replace_ty_in_crate, cx);\n-}\n-\n-pub fn check_variants_T<T: Copy>(\n-  crate: @ast::crate,\n-  codemap: @codemap::CodeMap,\n-  filename: &Path,\n-  thing_label: ~str,\n-  things: ~[T],\n-  stringifier: @fn(@T, @syntax::parse::token::ident_interner) -> ~str,\n-  replacer: @fn(@ast::crate, uint, T, test_mode) -> ast::crate,\n-  cx: Context\n-  ) {\n+    check_variants_T(crate,\n+                     codemap,\n+                     filename,\n+                     ~\"expr\",\n+                     extra_exprs + stolen.exprs,\n+                     pprust::expr_to_str,\n+                     replace_expr_in_crate,\n+                     cx);\n+    check_variants_T(crate,\n+                     codemap,\n+                     filename,\n+                     ~\"ty\",\n+                     stolen.tys,\n+                     pprust::ty_to_str,\n+                     replace_ty_in_crate,\n+                     cx);\n+}\n+\n+pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n+                                codemap: @codemap::CodeMap,\n+                                filename: &Path,\n+                                thing_label: ~str,\n+                                things: &[T],\n+                                stringifier: @fn(T, @ident_interner) -> ~str,\n+                                replacer: @fn(@ast::crate,\n+                                              uint,\n+                                              T,\n+                                              test_mode)\n+                                              -> @ast::crate,\n+                                cx: Context) {\n     error!(\"%s contains %u %s objects\", filename.to_str(),\n            things.len(), thing_label);\n \n@@ -294,36 +318,43 @@ pub fn check_variants_T<T: Copy>(\n             error!(\"Replacing... #%?\", uint::to_str(i));\n             let fname = str::from_slice(filename.to_str());\n             do under(uint::min(L, 30)) |j| {\n-                error!(\"With... %?\", stringifier(@things[j], intr));\n-                let crate2 = @replacer(crate, i, things[j], cx.mode);\n+                let fname = fname.to_str();\n+                error!(\"With... %?\", stringifier(things[j], intr));\n+                let crate2 = replacer(crate, i, things[j], cx.mode);\n                 // It would be best to test the *crate* for stability, but\n                 // testing the string for stability is easier and ok for now.\n                 let handler = diagnostic::mk_handler(None);\n                 let str3 = do io::with_str_reader(\"\") |rdr| {\n-                    @as_str(|a|pprust::print_crate(\n-                        codemap,\n-                        intr,\n-                        diagnostic::mk_span_handler(handler, codemap),\n-                        crate2,\n-                        fname,\n-                        rdr,\n-                        a,\n-                        pprust::no_ann(),\n-                        false))\n+                    let fname = fname.to_str();\n+                    let string = do as_str |a| {\n+                        let span_handler =\n+                            diagnostic::mk_span_handler(handler, codemap);\n+                        pprust::print_crate(codemap,\n+                                            intr,\n+                                            span_handler,\n+                                            crate2,\n+                                            fname.to_str(),\n+                                            rdr,\n+                                            a,\n+                                            pprust::no_ann(),\n+                                            false)\n+                    };\n+                    @string\n                 };\n                 match cx.mode {\n-                  tm_converge => {\n-                    check_roundtrip_convergence(str3, 1u);\n-                  }\n-                  tm_run => {\n-                    let file_label = fmt!(\"rusttmp/%s_%s_%u_%u\",\n-                                          last_part(filename.to_str()),\n-                                          thing_label, i, j);\n-                    let safe_to_run = !(content_is_dangerous_to_run(*str3)\n-                                        || has_raw_pointers(crate2));\n-                    check_whole_compiler(*str3, &Path(file_label),\n-                                         safe_to_run);\n-                  }\n+                    tm_converge => check_roundtrip_convergence(str3, 1),\n+                    tm_run => {\n+                        let file_label = fmt!(\"rusttmp/%s_%s_%u_%u\",\n+                                              last_part(filename.to_str()),\n+                                              thing_label,\n+                                              i,\n+                                              j);\n+                        let safe_to_run = !(content_is_dangerous_to_run(*str3)\n+                                            || has_raw_pointers(crate2));\n+                        check_whole_compiler(*str3,\n+                                             &Path(file_label),\n+                                             safe_to_run);\n+                    }\n                 }\n             }\n         }\n@@ -347,7 +378,8 @@ pub enum happiness {\n // - that would be tricky, requiring use of tasks or serialization\n //   or randomness.\n // This seems to find plenty of bugs as it is :)\n-pub fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n+pub fn check_whole_compiler(code: &str,\n+                            suggested_filename_prefix: &Path,\n                             allow_running: bool) {\n     let filename = &suggested_filename_prefix.with_filetype(\"rs\");\n     write_file(filename, code);\n@@ -460,20 +492,24 @@ pub fn parse_and_print(code: @~str) -> ~str {\n     let filename = Path(\"tmp.rs\");\n     let sess = parse::new_parse_sess(option::None);\n     write_file(&filename, *code);\n-    let crate = parse::parse_crate_from_source_str(\n-        filename.to_str(), code, ~[], sess);\n+    let crate = parse::parse_crate_from_source_str(filename.to_str(),\n+                                                   code,\n+                                                   ~[],\n+                                                   sess);\n     do io::with_str_reader(*code) |rdr| {\n-        as_str(|a|\n-               pprust::print_crate(\n-                   sess.cm,\n-                   // Assuming there are no token_trees\n-                   syntax::parse::token::mk_fake_ident_interner(),\n-                   copy sess.span_diagnostic,\n-                   crate,\n-                   filename.to_str(),\n-                   rdr, a,\n-                   pprust::no_ann(),\n-                   false) )\n+        let filename = filename.to_str();\n+        do as_str |a| {\n+            pprust::print_crate(sess.cm,\n+                                // Assuming there are no token_trees\n+                                token::mk_fake_ident_interner(),\n+                                copy sess.span_diagnostic,\n+                                crate,\n+                                filename.to_str(),\n+                                rdr,\n+                                a,\n+                                pprust::no_ann(),\n+                                false)\n+        }\n     }\n }\n \n@@ -493,7 +529,7 @@ pub fn has_raw_pointers(c: @ast::crate) -> bool {\n     return *has_rp;\n }\n \n-pub fn content_is_dangerous_to_run(code: ~str) -> bool {\n+pub fn content_is_dangerous_to_run(code: &str) -> bool {\n     let dangerous_patterns =\n         ~[~\"xfail-test\",\n          ~\"import\",  // espeically fs, run\n@@ -505,15 +541,15 @@ pub fn content_is_dangerous_to_run(code: ~str) -> bool {\n     return false;\n }\n \n-pub fn content_is_dangerous_to_compile(code: ~str) -> bool {\n+pub fn content_is_dangerous_to_compile(code: &str) -> bool {\n     let dangerous_patterns =\n         ~[~\"xfail-test\"];\n \n     for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n     return false;\n }\n \n-pub fn content_might_not_converge(code: ~str) -> bool {\n+pub fn content_might_not_converge(code: &str) -> bool {\n     let confusing_patterns =\n         ~[~\"xfail-test\",\n          ~\"xfail-pretty\",\n@@ -549,7 +585,6 @@ pub fn file_might_not_converge(filename: &Path) -> bool {\n }\n \n pub fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n-\n     let mut i = 0u;\n     let mut newv = code;\n     let mut oldv = code;\n@@ -613,23 +648,27 @@ pub fn check_variants(files: &[Path], cx: Context) {\n         let file_str = file.to_str();\n \n         error!(\"check_variants: %?\", file_str);\n-        let sess = parse::new_parse_sess(option::None);\n-        let crate =\n-            parse::parse_crate_from_source_str(\n-                file_str,\n-                s, ~[], sess);\n+        let sess = parse::new_parse_sess(None);\n+        let crate = parse::parse_crate_from_source_str(file_str.to_str(),\n+                                                       s,\n+                                                       ~[],\n+                                                       sess);\n         io::with_str_reader(*s, |rdr| {\n+            let file_str = file_str.to_str();\n             error!(\"%s\",\n-                   as_str(|a| pprust::print_crate(\n-                       sess.cm,\n-                       // Assuming no token_trees\n-                       syntax::parse::token::mk_fake_ident_interner(),\n-                       copy sess.span_diagnostic,\n-                       crate,\n-                       file_str,\n-                       rdr, a,\n-                       pprust::no_ann(),\n-                       false)))\n+                   as_str(|a| {\n+                    pprust::print_crate(\n+                        sess.cm,\n+                        // Assuming no token_trees\n+                        token::mk_fake_ident_interner(),\n+                        copy sess.span_diagnostic,\n+                        crate,\n+                        file_str.to_str(),\n+                        rdr,\n+                        a,\n+                        pprust::no_ann(),\n+                        false)\n+                    }))\n         });\n         check_variants_of_ast(crate, sess.cm, file, cx);\n     }"}, {"sha": "452623c2742b91bd2f30de77c96733d7fe741fbf", "filename": "src/librustc/front/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -132,7 +132,7 @@ pub mod intrinsic {\n         #[abi = \"rust-intrinsic\"]\n         pub extern \"rust-intrinsic\" {\n             pub fn get_tydesc<T>() -> *();\n-            pub fn visit_tydesc(++td: *TyDesc, &&tv: @TyVisitor);\n+            pub fn visit_tydesc(++td: *TyDesc, ++tv: @TyVisitor);\n         }\n     }\n }"}, {"sha": "8e689f3147b6b5f6ff7cad29a779b63604ece76e", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -128,7 +128,6 @@ pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_freevars = 0x59,\n     tag_table_tcache = 0x5a,\n     tag_table_param_defs = 0x5b,\n-    tag_table_inferred_modes = 0x5c,\n     tag_table_mutbl = 0x5d,\n     tag_table_last_use = 0x5e,\n     tag_table_spill = 0x5f,"}, {"sha": "cfe31360d321b20a141d4cee4d0392ca0f29211e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -244,8 +244,8 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n     }\n }\n \n-pub fn item_type(_item_id: ast::def_id, item: ebml::Doc,\n-                 tcx: ty::ctxt, cdata: cmd) -> ty::t {\n+pub fn item_type(_: ast::def_id, item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n+                 -> ty::t {\n     doc_type(item, tcx, cdata)\n }\n "}, {"sha": "011ee115e8c1521f3f6d5eb1804723dc45e155dd", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -469,16 +469,9 @@ fn parse_onceness(c: char) -> ast::Onceness {\n }\n \n fn parse_arg(st: @mut PState, conv: conv_did) -> ty::arg {\n-    ty::arg { mode: parse_mode(st), ty: parse_ty(st, conv) }\n-}\n-\n-fn parse_mode(st: @mut PState) -> ast::mode {\n-    let m = ast::expl(match next(st) {\n-        '+' => ast::by_copy,\n-        '=' => ast::by_ref,\n-        _ => fail!(~\"bad mode\")\n-    });\n-    return m;\n+    ty::arg {\n+        ty: parse_ty(st, conv)\n+    }\n }\n \n fn parse_closure_ty(st: @mut PState, conv: conv_did) -> ty::ClosureTy {\n@@ -511,8 +504,7 @@ fn parse_sig(st: @mut PState, conv: conv_did) -> ty::FnSig {\n     assert!((next(st) == '['));\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n-        let mode = parse_mode(st);\n-        inputs.push(ty::arg { mode: mode, ty: parse_ty(st, conv) });\n+        inputs.push(ty::arg { ty: parse_ty(st, conv) });\n     }\n     st.pos += 1u; // eat the ']'\n     let ret_ty = parse_ty(st, conv);"}, {"sha": "763b1984b81c86dbfdfcb5e46f21782b1cfa3872", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -344,17 +344,9 @@ fn enc_sigil(w: @io::Writer, sigil: Sigil) {\n }\n \n pub fn enc_arg(w: @io::Writer, cx: @ctxt, arg: ty::arg) {\n-    enc_mode(w, cx, arg.mode);\n     enc_ty(w, cx, arg.ty);\n }\n \n-pub fn enc_mode(w: @io::Writer, cx: @ctxt, m: mode) {\n-    match ty::resolved_mode(cx.tcx, m) {\n-      by_copy => w.write_char('+'),\n-      by_ref => w.write_char('='),\n-    }\n-}\n-\n fn enc_purity(w: @io::Writer, p: purity) {\n     match p {\n       pure_fn => w.write_char('p'),"}, {"sha": "c7c9c110586c7dadc950242a08d7e46f145a9ae7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -410,7 +410,7 @@ impl tr for ast::def {\n           ast::def_mod(did) => { ast::def_mod(did.tr(xcx)) }\n           ast::def_foreign_mod(did) => { ast::def_foreign_mod(did.tr(xcx)) }\n           ast::def_const(did) => { ast::def_const(did.tr(xcx)) }\n-          ast::def_arg(nid, m, b) => { ast::def_arg(xcx.tr_id(nid), m, b) }\n+          ast::def_arg(nid, b) => { ast::def_arg(xcx.tr_id(nid), b) }\n           ast::def_local(nid, b) => { ast::def_local(xcx.tr_id(nid), b) }\n           ast::def_variant(e_did, v_did) => {\n             ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n@@ -571,6 +571,9 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n         do ebml_w.emit_field(~\"origin\", 1u) {\n             mme.origin.encode(ebml_w);\n         }\n+        do ebml_w.emit_field(~\"self_mode\", 3) {\n+            mme.self_mode.encode(ebml_w);\n+        }\n     }\n }\n \n@@ -590,6 +593,9 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n         do ebml_w.emit_struct_field(\"origin\", 1u) {\n             mme.origin.encode(ebml_w);\n         }\n+        do ebml_w.emit_struct_field(\"self_mode\", 3) {\n+            mme.self_mode.encode(ebml_w);\n+        }\n     }\n }\n \n@@ -611,6 +617,10 @@ impl read_method_map_entry_helper for reader::Decoder {\n                         Decodable::decode(self);\n                     method_origin.tr(xcx)\n                 }),\n+                self_mode: self.read_field(~\"self_mode\", 3, || {\n+                    let self_mode: ty::SelfMode = Decodable::decode(self);\n+                    self_mode\n+                }),\n             }\n         }\n     }\n@@ -625,7 +635,7 @@ impl read_method_map_entry_helper for reader::Decoder {\n                 self_arg: self.read_struct_field(\"self_arg\", 0u, || {\n                     self.read_arg(xcx)\n                 }),\n-                explicit_self: self.read_struct_field(\"explicit_self\", 2u, || {\n+                explicit_self: self.read_struct_field(\"explicit_self\", 2, || {\n                     let self_type: ast::self_ty_ = Decodable::decode(self);\n                     self_type\n                 }),\n@@ -634,6 +644,10 @@ impl read_method_map_entry_helper for reader::Decoder {\n                         Decodable::decode(self);\n                     method_origin.tr(xcx)\n                 }),\n+                self_mode: self.read_struct_field(\"self_mode\", 3, || {\n+                    let self_mode: ty::SelfMode = Decodable::decode(self);\n+                    self_mode\n+                }),\n             }\n         }\n     }\n@@ -978,20 +992,6 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    // I believe it is not necessary to encode this information.  The\n-    // ids will appear in the AST but in the *type* information, which\n-    // is what we actually use in trans, all modes will have been\n-    // resolved.\n-    //\n-    //for tcx.inferred_modes.find(&id).each |m| {\n-    //    ebml_w.tag(c::tag_table_inferred_modes) {||\n-    //        ebml_w.id(id);\n-    //        ebml_w.tag(c::tag_table_val) {||\n-    //            tyencode::enc_mode(ebml_w.writer, ty_str_ctxt(), m);\n-    //        }\n-    //    }\n-    //}\n-\n     if maps.mutbl_map.contains(&id) {\n         do ebml_w.tag(c::tag_table_mutbl) {\n             ebml_w.id(id);"}, {"sha": "e40d0e63eb38eab0bd03d5fb44af06f48ae698ec", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -147,38 +147,6 @@ fn req_loans_in_expr(ex: @ast::expr,\n         visit::visit_expr(ex, self, vt);\n       }\n \n-      ast::expr_call(f, ref args, _) => {\n-        let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n-        let scope_r = ty::re_scope(ex.id);\n-        for vec::each2(*args, arg_tys) |arg, arg_ty| {\n-            match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-                ast::by_ref => {\n-                    let arg_cmt = self.bccx.cat_expr(*arg);\n-                    self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n-                }\n-                ast::by_copy => {}\n-            }\n-        }\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n-      ast::expr_method_call(_, _, _, ref args, _) => {\n-        let arg_tys = ty::ty_fn_args(ty::node_id_to_type(self.tcx(),\n-                                                         ex.callee_id));\n-        let scope_r = ty::re_scope(ex.id);\n-        for vec::each2(*args, arg_tys) |arg, arg_ty| {\n-            match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-                ast::by_ref => {\n-                    let arg_cmt = self.bccx.cat_expr(*arg);\n-                    self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n-                }\n-                ast::by_copy => {}\n-            }\n-        }\n-\n-        visit::visit_expr(ex, self, vt);\n-      }\n-\n       ast::expr_match(ex_v, ref arms) => {\n         let cmt = self.bccx.cat_expr(ex_v);\n         for (*arms).each |arm| {"}, {"sha": "2de12b9eb9746ec7e9c0213cf12f54d304fb34dd", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -28,8 +28,8 @@ use syntax::ast_util::local_def;\n use syntax::visit::{default_simple_visitor, mk_simple_visitor, SimpleVisitor};\n use syntax::visit::visit_crate;\n \n+use core::cast::transmute;\n use core::hashmap::HashMap;\n-use core::ptr;\n \n pub enum LangItem {\n     ConstTraitLangItem,         // 0\n@@ -366,20 +366,22 @@ pub impl<'self> LanguageItemCollector<'self> {\n     }\n \n     fn collect_local_language_items(&self) {\n-        let this = ptr::addr_of(&self);\n-        visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n-            visit_item: |item| {\n-                for item.attrs.each |attribute| {\n-                    unsafe {\n-                        (*this).match_and_collect_meta_item(\n-                            local_def(item.id),\n-                            attribute.node.value\n-                        );\n+        unsafe {\n+            let this: *LanguageItemCollector<'self> = transmute(self);\n+            visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n+                visit_item: |item| {\n+                    for item.attrs.each |attribute| {\n+                        unsafe {\n+                            (*this).match_and_collect_meta_item(\n+                                local_def(item.id),\n+                                attribute.node.value\n+                            );\n+                        }\n                     }\n-                }\n-            },\n-            .. *default_simple_visitor()\n-        }));\n+                },\n+                .. *default_simple_visitor()\n+            }));\n+        }\n     }\n \n     fn collect_external_language_items(&self) {"}, {"sha": "faf4b1c31061b72616de4c45f83ce43d31253032", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 6, "deletions": 153, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -19,7 +19,6 @@ use std::smallintmap::SmallIntMap;\n use syntax::attr;\n use syntax::codemap::span;\n use syntax::codemap;\n-use syntax::print::pprust::mode_to_str;\n use syntax::{ast, visit};\n \n /**\n@@ -53,22 +52,18 @@ pub enum lint {\n     unrecognized_lint,\n     non_implicitly_copyable_typarams,\n     vecs_implicitly_copyable,\n-    deprecated_mode,\n     deprecated_pattern,\n     non_camel_case_types,\n     type_limits,\n     default_methods,\n     deprecated_mutable_fields,\n     deprecated_drop,\n     unused_unsafe,\n-    foreign_mode,\n \n     managed_heap_memory,\n     owned_heap_memory,\n     heap_memory,\n \n-    legacy_modes,\n-\n     unused_variable,\n     dead_assignment,\n     unused_mut,\n@@ -159,20 +154,6 @@ pub fn get_lint_dict() -> LintDict {\n             default: warn\n          }),\n \n-        (~\"deprecated_mode\",\n-         LintSpec {\n-            lint: deprecated_mode,\n-            desc: \"warn about deprecated uses of modes\",\n-            default: warn\n-         }),\n-\n-        (~\"foreign_mode\",\n-         LintSpec {\n-            lint: foreign_mode,\n-            desc: \"warn about deprecated uses of modes in foreign fns\",\n-            default: warn\n-         }),\n-\n         (~\"deprecated_pattern\",\n          LintSpec {\n             lint: deprecated_pattern,\n@@ -208,13 +189,6 @@ pub fn get_lint_dict() -> LintDict {\n             default: allow\n          }),\n \n-        (~\"legacy modes\",\n-         LintSpec {\n-            lint: legacy_modes,\n-            desc: \"allow legacy modes\",\n-            default: forbid\n-         }),\n-\n         (~\"type_limits\",\n          LintSpec {\n             lint: type_limits,\n@@ -486,7 +460,6 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_path_statement(cx, i);\n     check_item_non_camel_case_types(cx, i);\n     check_item_heap(cx, i);\n-    check_item_deprecated_modes(cx, i);\n     check_item_type_limits(cx, i);\n     check_item_default_methods(cx, i);\n     check_item_deprecated_mutable_fields(cx, i);\n@@ -719,20 +692,6 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n                         decl: &ast::fn_decl) {\n-        // warn about `&&` mode on foreign functions, both because it is\n-        // deprecated and because its semantics have changed recently:\n-        for decl.inputs.eachi |i, arg| {\n-            match ty::resolved_mode(cx, arg.mode) {\n-                ast::by_copy => {}\n-                ast::by_ref => {\n-                    cx.sess.span_lint(\n-                        foreign_mode, fn_id, fn_id, arg.ty.span,\n-                        fmt!(\"foreign function uses `&&` mode \\\n-                              on argument %u\", i));\n-                }\n-            }\n-        }\n-\n         let tys = vec::map(decl.inputs, |a| a.ty );\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n@@ -995,119 +954,13 @@ fn check_item_unused_mut(tcx: ty::ctxt, it: @ast::item) {\n     visit::visit_item(it, (), visit);\n }\n \n-fn check_fn(tcx: ty::ctxt, fk: &visit::fn_kind, decl: &ast::fn_decl,\n-            _body: &ast::blk, span: span, id: ast::node_id) {\n+fn check_fn(_: ty::ctxt,\n+            fk: &visit::fn_kind,\n+            _: &ast::fn_decl,\n+            _: &ast::blk,\n+            _: span,\n+            id: ast::node_id) {\n     debug!(\"lint check_fn fk=%? id=%?\", fk, id);\n-\n-    // Check for deprecated modes\n-    match *fk {\n-        // don't complain about blocks, since they tend to get their modes\n-        // specified from the outside\n-        visit::fk_fn_block(*) => {}\n-\n-        _ => {\n-            let fn_ty = ty::node_id_to_type(tcx, id);\n-            check_fn_deprecated_modes(tcx, fn_ty, decl, span, id);\n-        }\n-    }\n-\n-}\n-\n-fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: &ast::fn_decl,\n-                             span: span, id: ast::node_id) {\n-    match ty::get(fn_ty).sty {\n-        ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) |\n-        ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) => {\n-            let mut counter = 0;\n-            for vec::each2(sig.inputs, decl.inputs) |arg_ty, arg_ast| {\n-                counter += 1;\n-                debug!(\"arg %d, ty=%s, mode=%s\",\n-                       counter,\n-                       ty_to_str(tcx, arg_ty.ty),\n-                       mode_to_str(arg_ast.mode));\n-                match arg_ast.mode {\n-                    ast::expl(ast::by_copy) => {\n-                        if !tcx.legacy_modes {\n-                            tcx.sess.span_lint(\n-                                deprecated_mode, id, id, span,\n-                                fmt!(\"argument %d uses by-copy mode\",\n-                                     counter));\n-                        }\n-                    }\n-\n-                    ast::expl(_) => {\n-                        tcx.sess.span_lint(\n-                            deprecated_mode, id, id,\n-                            span,\n-                         fmt!(\"argument %d uses an explicit mode\", counter));\n-                    }\n-\n-                    ast::infer(_) => {\n-                        if tcx.legacy_modes {\n-                            let kind = ty::type_contents(tcx, arg_ty.ty);\n-                            if !kind.is_safe_for_default_mode(tcx) {\n-                                tcx.sess.span_lint(\n-                                    deprecated_mode, id, id,\n-                                    span,\n-                                    fmt!(\"argument %d uses the default mode \\\n-                                          but shouldn't\",\n-                                         counter));\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                match ty::get(arg_ty.ty).sty {\n-                    ty::ty_closure(*) | ty::ty_bare_fn(*) => {\n-                        let span = arg_ast.ty.span;\n-                        // Recurse to check fn-type argument\n-                        match arg_ast.ty.node {\n-                            ast::ty_closure(@ast::TyClosure{decl: ref d, _}) |\n-                            ast::ty_bare_fn(@ast::TyBareFn{decl: ref d, _})=>{\n-                                check_fn_deprecated_modes(tcx, arg_ty.ty,\n-                                                          d, span, id);\n-                            }\n-                            ast::ty_path(*) => {\n-                                // This is probably a typedef, so we can't\n-                                // see the actual fn decl\n-                                // e.g. fn foo(f: InitOp<T>)\n-                            }\n-                            _ => {\n-                                tcx.sess.span_warn(span, ~\"what\");\n-                                error!(\"arg %d, ty=%s, mode=%s\",\n-                                       counter,\n-                                       ty_to_str(tcx, arg_ty.ty),\n-                                       mode_to_str(arg_ast.mode));\n-                                error!(\"%?\",arg_ast.ty.node);\n-                                fail!()\n-                            }\n-                        };\n-                    }\n-                    _ => ()\n-                }\n-            }\n-        }\n-\n-        _ => tcx.sess.impossible_case(span, ~\"check_fn: function has \\\n-                                              non-fn type\")\n-    }\n-}\n-\n-fn check_item_deprecated_modes(tcx: ty::ctxt, it: @ast::item) {\n-    match it.node {\n-        ast::item_ty(ty, _) => {\n-            match ty.node {\n-                ast::ty_closure(@ast::TyClosure {decl: ref decl, _}) |\n-                ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n-                    let fn_ty = ty::node_id_to_type(tcx, it.id);\n-                    check_fn_deprecated_modes(\n-                        tcx, fn_ty, decl, ty.span, it.id)\n-                }\n-                _ => ()\n-            }\n-        }\n-        _ => ()\n-    }\n }\n \n pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {"}, {"sha": "94d82d0acb8e4eaf5c90d65cafb1dc06edecb378", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 36, "deletions": 62, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -110,6 +110,7 @@ use middle::typeck;\n use middle::moves;\n use util::ppaux::ty_to_str;\n \n+use core::cast::transmute;\n use core::hashmap::HashMap;\n use core::util::with;\n use syntax::ast::*;\n@@ -235,19 +236,19 @@ struct LocalInfo {\n }\n \n enum VarKind {\n-    Arg(node_id, ident, rmode),\n+    Arg(node_id, ident),\n     Local(LocalInfo),\n     ImplicitRet\n }\n \n fn relevant_def(def: def) -> Option<node_id> {\n     match def {\n-      def_binding(nid, _) |\n-      def_arg(nid, _, _) |\n-      def_local(nid, _) |\n-      def_self(nid, _) => Some(nid),\n+        def_binding(nid, _) |\n+        def_arg(nid, _) |\n+        def_local(nid, _) |\n+        def_self(nid, _) => Some(nid),\n \n-      _ => None\n+        _ => None\n     }\n }\n \n@@ -320,10 +321,9 @@ pub impl IrMaps {\n         self.num_vars += 1;\n \n         match vk {\n-            Local(LocalInfo {id:node_id, _}) |\n-            Arg(node_id, _, _) => {\n+            Local(LocalInfo { id: node_id, _ }) | Arg(node_id, _) => {\n                 self.variable_map.insert(node_id, v);\n-            }\n+            },\n             ImplicitRet => {}\n         }\n \n@@ -344,8 +344,9 @@ pub impl IrMaps {\n \n     fn variable_name(&mut self, var: Variable) -> @~str {\n         match self.var_kinds[*var] {\n-            Local(LocalInfo {ident: nm, _}) |\n-            Arg(_, nm, _) => self.tcx.sess.str_of(nm),\n+            Local(LocalInfo { ident: nm, _ }) | Arg(_, nm) => {\n+                self.tcx.sess.str_of(nm)\n+            },\n             ImplicitRet => @~\"<implicit-ret>\"\n         }\n     }\n@@ -371,25 +372,22 @@ pub impl IrMaps {\n         let vk = self.var_kinds[*var];\n         debug!(\"Node %d is a last use of variable %?\", expr_id, vk);\n         match vk {\n-          Arg(id, _, by_copy) |\n-          Local(LocalInfo {id: id, kind: FromLetNoInitializer, _}) |\n-          Local(LocalInfo {id: id, kind: FromLetWithInitializer, _}) |\n-          Local(LocalInfo {id: id, kind: FromMatch(_), _}) => {\n-            let v = match self.last_use_map.find(&expr_id) {\n-              Some(&v) => v,\n-              None => {\n-                let v = @mut ~[];\n-                self.last_use_map.insert(expr_id, v);\n-                v\n-              }\n-            };\n+            Arg(id, _) |\n+            Local(LocalInfo { id: id, kind: FromLetNoInitializer, _ }) |\n+            Local(LocalInfo { id: id, kind: FromLetWithInitializer, _ }) |\n+            Local(LocalInfo { id: id, kind: FromMatch(_), _ }) => {\n+                let v = match self.last_use_map.find(&expr_id) {\n+                    Some(&v) => v,\n+                    None => {\n+                        let v = @mut ~[];\n+                        self.last_use_map.insert(expr_id, v);\n+                        v\n+                    }\n+                };\n \n-            v.push(id);\n-          }\n-          Arg(_, _, by_ref) |\n-          ImplicitRet => {\n-            debug!(\"--but it is not owned\");\n-          }\n+                v.push(id);\n+            }\n+            ImplicitRet => debug!(\"--but it is not owned\"),\n         }\n     }\n }\n@@ -418,15 +416,16 @@ fn visit_fn(fk: &visit::fn_kind,\n                               self.last_use_map,\n                               self.cur_item);\n \n-    debug!(\"creating fn_maps: %x\", ptr::addr_of(&(*fn_maps)) as uint);\n+    unsafe {\n+        debug!(\"creating fn_maps: %x\", transmute(&*fn_maps));\n+    }\n \n     for decl.inputs.each |arg| {\n-        let mode = ty::resolved_mode(self.tcx, arg.mode);\n         do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                 |_bm, arg_id, _x, path| {\n             debug!(\"adding argument %d\", arg_id);\n             let ident = ast_util::path_to_ident(path);\n-            fn_maps.add_variable(Arg(arg_id, ident, mode));\n+            fn_maps.add_variable(Arg(arg_id, ident));\n         }\n     };\n \n@@ -436,16 +435,13 @@ fn visit_fn(fk: &visit::fn_kind,\n             match method.self_ty.node {\n                 sty_value | sty_region(*) | sty_box(_) | sty_uniq(_) => {\n                     fn_maps.add_variable(Arg(method.self_id,\n-                                             special_idents::self_,\n-                                             by_copy));\n+                                             special_idents::self_));\n                 }\n                 sty_static => {}\n             }\n         }\n         fk_dtor(_, _, self_id, _) => {\n-            fn_maps.add_variable(Arg(self_id,\n-                                     special_idents::self_,\n-                                     by_copy));\n+            fn_maps.add_variable(Arg(self_id, special_idents::self_));\n         }\n         fk_item_fn(*) | fk_anon(*) | fk_fn_block(*) => {}\n     }\n@@ -970,30 +966,8 @@ pub impl Liveness {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(&self, decl: &fn_decl, blk: &blk)\n-                                 -> LiveNode {\n-        // inputs passed by & mode should be considered live on exit:\n-        for decl.inputs.each |arg| {\n-            match ty::resolved_mode(self.tcx, arg.mode) {\n-                by_ref => {\n-                    // By val and by ref do not own, so register a\n-                    // read at the end.  This will prevent us from\n-                    // moving out of such variables but also prevent\n-                    // us from registering last uses and so forth.\n-                    do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n-                        |_bm, arg_id, _sp, _path|\n-                    {\n-                        let var = self.variable(arg_id, blk.span);\n-                        self.acc(self.s.exit_ln, var, ACC_READ);\n-                    }\n-                }\n-                by_copy => {\n-                    // By copy is an owned mode.  If we don't use the\n-                    // variable, nobody will.\n-                }\n-            }\n-        }\n-\n+    fn propagate_through_fn_block(&self, _: &fn_decl, blk: &blk)\n+                                  -> LiveNode {\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n         self.init_from_succ(self.s.fallthrough_ln, self.s.exit_ln);\n@@ -1768,7 +1742,7 @@ pub impl Liveness {\n             // borrow checker\n             let vk = self.ir.var_kinds[*var];\n             match vk {\n-              Arg(_, name, _) => {\n+              Arg(_, name) => {\n                 self.tcx.sess.span_err(\n                     move_expr.span,\n                     fmt!(\"illegal move from argument `%s`, which is not \\"}, {"sha": "31cb39bc231b94a2d040e6c184691f9db48f184e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -482,17 +482,14 @@ pub impl mem_categorization_ctxt {\n             }\n           }\n \n-          ast::def_arg(vid, mode, mutbl) => {\n+          ast::def_arg(vid, mutbl) => {\n             // Idea: make this could be rewritten to model by-ref\n             // stuff as `&const` and `&mut`?\n \n             // m: mutability of the argument\n             // lp: loan path, must be none for aliasable things\n             let m = if mutbl {McDeclared} else {McImmutable};\n-            let lp = match ty::resolved_mode(self.tcx, mode) {\n-                ast::by_copy => Some(@lp_arg(vid)),\n-                ast::by_ref => None,\n-            };\n+            let lp = Some(@lp_arg(vid));\n             @cmt_ {\n                 id:id,\n                 span:span,"}, {"sha": "fe1466bf808a372d99f985943eee75c6ba581b82", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -718,41 +718,22 @@ pub impl VisitContext {\n                     receiver_expr: @expr,\n                     visitor: vt<VisitContext>)\n     {\n-        self.use_fn_arg(by_copy, receiver_expr, visitor);\n+        self.use_fn_arg(receiver_expr, visitor);\n     }\n \n     fn use_fn_args(&self,\n-                   callee_id: node_id,\n+                   _: node_id,\n                    arg_exprs: &[@expr],\n-                   visitor: vt<VisitContext>)\n-    {\n-        /*!\n-         *\n-         * Uses the argument expressions according to the function modes.\n-         */\n-\n-        let arg_tys =\n-            ty::ty_fn_args(ty::node_id_to_type(self.tcx, callee_id));\n-        for vec::each2(arg_exprs, arg_tys) |arg_expr, arg_ty| {\n-            let arg_mode = ty::resolved_mode(self.tcx, arg_ty.mode);\n-            self.use_fn_arg(arg_mode, *arg_expr, visitor);\n+                   visitor: vt<VisitContext>) {\n+        //! Uses the argument expressions.\n+        for arg_exprs.each |arg_expr| {\n+            self.use_fn_arg(*arg_expr, visitor);\n         }\n     }\n \n-    fn use_fn_arg(&self,\n-                  arg_mode: rmode,\n-                  arg_expr: @expr,\n-                  visitor: vt<VisitContext>)\n-    {\n-        /*!\n-         *\n-         * Uses the argument according to the given argument mode.\n-         */\n-\n-        match arg_mode {\n-            by_ref => self.use_expr(arg_expr, Read, visitor),\n-            by_copy => self.consume_expr(arg_expr, visitor)\n-        }\n+    fn use_fn_arg(&self, arg_expr: @expr, visitor: vt<VisitContext>) {\n+        //! Uses the argument.\n+        self.consume_expr(arg_expr, visitor)\n     }\n \n     fn arms_have_by_move_bindings(&self,"}, {"sha": "681c38633273c2286cfdd1bfc856007d4072bf9d", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -42,7 +42,7 @@ use syntax::ast::Generics;\n use syntax::ast::{gt, ident, inherited, item, item_struct};\n use syntax::ast::{item_const, item_enum, item_fn, item_foreign_mod};\n use syntax::ast::{item_impl, item_mac, item_mod, item_trait, item_ty, le};\n-use syntax::ast::{local, local_crate, lt, method, mode, mul};\n+use syntax::ast::{local, local_crate, lt, method, mul};\n use syntax::ast::{named_field, ne, neg, node_id, pat, pat_enum, pat_ident};\n use syntax::ast::{Path, pat_lit, pat_range, pat_struct};\n use syntax::ast::{prim_ty, private, provided};\n@@ -123,7 +123,7 @@ pub struct Export2 {\n pub enum PatternBindingMode {\n     RefutableMode,\n     LocalIrrefutableMode,\n-    ArgumentIrrefutableMode(mode)\n+    ArgumentIrrefutableMode,\n }\n \n #[deriving(Eq)]\n@@ -3708,8 +3708,7 @@ pub impl Resolver {\n                 }\n                 Some(declaration) => {\n                     for declaration.inputs.each |argument| {\n-                        let binding_mode =\n-                            ArgumentIrrefutableMode(argument.mode);\n+                        let binding_mode = ArgumentIrrefutableMode;\n                         let mutability =\n                             if argument.is_mutbl {Mutable} else {Immutable};\n                         self.resolve_pattern(argument.pat,\n@@ -4184,10 +4183,9 @@ pub impl Resolver {\n                                     // But for locals, we use `def_local`.\n                                     def_local(pattern.id, is_mutable)\n                                 }\n-                                ArgumentIrrefutableMode(argument_mode) => {\n+                                ArgumentIrrefutableMode => {\n                                     // And for function arguments, `def_arg`.\n-                                    def_arg(pattern.id, argument_mode,\n-                                            is_mutable)\n+                                    def_arg(pattern.id, is_mutable)\n                                 }\n                             };\n "}, {"sha": "9c84b2a418232a8f0a46a7890c9cad0f2cbfd773", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -33,11 +33,16 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n         constraints.push(copy *c);\n \n         let aoutty = ty::arg {\n-            mode: ast::expl(ast::by_copy),\n             ty: expr_ty(bcx, out)\n         };\n         aoutputs.push(unpack_result!(bcx, {\n-            callee::trans_arg_expr(bcx, aoutty, out, &mut cleanups, None, callee::DontAutorefArg)\n+            callee::trans_arg_expr(bcx,\n+                                   aoutty,\n+                                   ty::ByCopy,\n+                                   out,\n+                                   &mut cleanups,\n+                                   None,\n+                                   callee::DontAutorefArg)\n         }));\n \n         let e = match out.node {\n@@ -46,12 +51,17 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n         };\n \n         let outty = ty::arg {\n-            mode: ast::expl(ast::by_copy),\n             ty: expr_ty(bcx, e)\n         };\n \n         unpack_result!(bcx, {\n-            callee::trans_arg_expr(bcx, outty, e, &mut cleanups, None, callee::DontAutorefArg)\n+            callee::trans_arg_expr(bcx,\n+                                   outty,\n+                                   ty::ByCopy,\n+                                   e,\n+                                   &mut cleanups,\n+                                   None,\n+                                   callee::DontAutorefArg)\n         })\n \n     };\n@@ -66,12 +76,17 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n         constraints.push(copy *c);\n \n         let inty = ty::arg {\n-            mode: ast::expl(ast::by_copy),\n             ty: expr_ty(bcx, in)\n         };\n \n         unpack_result!(bcx, {\n-            callee::trans_arg_expr(bcx, inty, in, &mut cleanups, None, callee::DontAutorefArg)\n+            callee::trans_arg_expr(bcx,\n+                                   inty,\n+                                   ty::ByCopy,\n+                                   in,\n+                                   &mut cleanups,\n+                                   None,\n+                                   callee::DontAutorefArg)\n         })\n \n     };"}, {"sha": "efa10dfc2aa34db55b5e887c09e5eed3d03767db", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -1728,7 +1728,6 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n                             raw_llargs: &[ValueRef],\n                             arg_tys: &[ty::arg]) -> block {\n     let _icx = fcx.insn_ctxt(\"copy_args_to_allocas\");\n-    let tcx = bcx.tcx();\n     let mut bcx = bcx;\n \n     match fcx.llself {\n@@ -1757,24 +1756,16 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n         // the argument would be passed by value, we store it into an alloca.\n         // This alloca should be optimized away by LLVM's mem-to-reg pass in\n         // the event it's not truly needed.\n-        let llarg;\n-        match ty::resolved_mode(tcx, arg_ty.mode) {\n-            ast::by_ref => {\n-                llarg = raw_llarg;\n-            }\n-            ast::by_copy => {\n-                // only by value if immediate:\n-                if datum::appropriate_mode(arg_ty.ty).is_by_value() {\n-                    let alloc = alloc_ty(bcx, arg_ty.ty);\n-                    Store(bcx, raw_llarg, alloc);\n-                    llarg = alloc;\n-                } else {\n-                    llarg = raw_llarg;\n-                }\n+        // only by value if immediate:\n+        let llarg = if datum::appropriate_mode(arg_ty.ty).is_by_value() {\n+            let alloc = alloc_ty(bcx, arg_ty.ty);\n+            Store(bcx, raw_llarg, alloc);\n+            alloc\n+        } else {\n+            raw_llarg\n+        };\n \n-                add_clean(bcx, llarg, arg_ty.ty);\n-            }\n-        }\n+        add_clean(bcx, llarg, arg_ty.ty);\n \n         bcx = _match::bind_irrefutable_pat(bcx,\n                                           args[arg_n].pat,\n@@ -1966,7 +1957,6 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n     // Translate variant arguments to function arguments.\n     let fn_args = do args.map |varg| {\n         ast::arg {\n-            mode: ast::expl(ast::by_copy),\n             is_mutbl: false,\n             ty: varg.ty,\n             pat: ast_util::ident_to_pat(\n@@ -2041,7 +2031,6 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n     // Translate struct fields to function arguments.\n     let fn_args = do fields.map |field| {\n         ast::arg {\n-            mode: ast::expl(ast::by_copy),\n             is_mutbl: false,\n             ty: field.node.ty,\n             pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),\n@@ -2408,8 +2397,8 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n             } else {\n                 let start_fn_type = csearch::get_type(ccx.tcx,\n                                                       start_def_id).ty;\n-                trans_external_path(ccx, start_def_id, start_fn_type)\n-            };\n+                trans_external_path(ccx, start_def_id, start_fn_type);\n+            }\n \n             let retptr = llvm::LLVMBuildAlloca(bld, T_i8(), noname());\n "}, {"sha": "f5c496484a03767b3ee9c797a580e4748daaf033", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -170,7 +170,7 @@ pub fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n pub fn noname() -> *c_char {\n     unsafe {\n         static cnull: uint = 0u;\n-        return cast::transmute(ptr::addr_of(&cnull));\n+        return cast::transmute(&cnull);\n     }\n }\n \n@@ -827,8 +827,8 @@ pub fn Phi(cx: block, Ty: TypeRef, vals: &[ValueRef], bbs: &[BasicBlockRef])\n pub fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     unsafe {\n         if llvm::LLVMIsUndef(phi) == lib::llvm::True { return; }\n-        let valptr = cast::transmute(ptr::addr_of(&val));\n-        let bbptr = cast::transmute(ptr::addr_of(&bb));\n+        let valptr = cast::transmute(&val);\n+        let bbptr = cast::transmute(&bb);\n         llvm::LLVMAddIncoming(phi, valptr, bbptr, 1 as c_uint);\n     }\n }"}, {"sha": "ad0fea3b4b4aff0405c2db7c0411bd0d21f08f08", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 42, "deletions": 26, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -57,7 +57,7 @@ pub struct MethodData {\n     llfn: ValueRef,\n     llself: ValueRef,\n     self_ty: ty::t,\n-    self_mode: ast::rmode\n+    self_mode: ty::SelfMode,\n }\n \n pub enum CalleeData {\n@@ -378,10 +378,20 @@ pub fn trans_lang_call(bcx: block,\n         csearch::get_type(bcx.ccx().tcx, did).ty\n     };\n     let rty = ty::ty_fn_ret(fty);\n-    return callee::trans_call_inner(\n-        bcx, None, fty, rty,\n-        |bcx| trans_fn_ref_with_vtables_to_callee(bcx, did, 0, ~[], None),\n-        ArgVals(args), dest, DontAutorefArg);\n+    callee::trans_call_inner(bcx,\n+                             None,\n+                             fty,\n+                             rty,\n+                             |bcx| {\n+                                trans_fn_ref_with_vtables_to_callee(bcx,\n+                                                                    did,\n+                                                                    0,\n+                                                                    ~[],\n+                                                                    None)\n+                             },\n+                             ArgVals(args),\n+                             dest,\n+                             DontAutorefArg)\n }\n \n pub fn trans_lang_call_with_type_params(bcx: block,\n@@ -483,7 +493,8 @@ pub fn trans_call_inner(in_cx: block,\n                 }\n                 Method(d) => {\n                     // Weird but true: we pass self in the *environment* slot!\n-                    let llself = PointerCast(bcx, d.llself,\n+                    let llself = PointerCast(bcx,\n+                                             d.llself,\n                                              T_opaque_box_ptr(ccx));\n                     (d.llfn, llself)\n                 }\n@@ -520,7 +531,7 @@ pub fn trans_call_inner(in_cx: block,\n         // Now that the arguments have finished evaluating, we need to revoke\n         // the cleanup for the self argument, if it exists\n         match callee.data {\n-            Method(d) if d.self_mode == ast::by_copy => {\n+            Method(d) if d.self_mode == ty::ByCopy => {\n                 revoke_clean(bcx, d.llself);\n             }\n             _ => {}\n@@ -629,7 +640,11 @@ pub fn trans_args(cx: block,\n         let last = arg_exprs.len() - 1u;\n         for vec::eachi(arg_exprs) |i, arg_expr| {\n             let arg_val = unpack_result!(bcx, {\n-                trans_arg_expr(bcx, arg_tys[i], *arg_expr, &mut temp_cleanups,\n+                trans_arg_expr(bcx,\n+                               arg_tys[i],\n+                               ty::ByCopy,\n+                               *arg_expr,\n+                               &mut temp_cleanups,\n                                if i == last { ret_flag } else { None },\n                                autoref_arg)\n             });\n@@ -660,17 +675,18 @@ pub enum AutorefArg {\n // call takes place:\n pub fn trans_arg_expr(bcx: block,\n                       formal_ty: ty::arg,\n+                      self_mode: ty::SelfMode,\n                       arg_expr: @ast::expr,\n                       temp_cleanups: &mut ~[ValueRef],\n                       ret_flag: Option<ValueRef>,\n                       autoref_arg: AutorefArg) -> Result {\n     let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_expr(formal_ty=(%?,%s), arg_expr=%s, \\\n+    debug!(\"trans_arg_expr(formal_ty=(%s), self_mode=%?, arg_expr=%s, \\\n             ret_flag=%?)\",\n-           formal_ty.mode,\n            formal_ty.ty.repr(bcx.tcx()),\n+           self_mode,\n            arg_expr.repr(bcx.tcx()),\n            ret_flag.map(|v| bcx.val_str(*v)));\n     let _indenter = indenter();\n@@ -686,8 +702,7 @@ pub fn trans_arg_expr(bcx: block,\n                     blk @ @ast::expr {\n                         node: ast::expr_fn_block(ref decl, ref body),\n                         _\n-                    }) =>\n-                {\n+                    }) => {\n                     let scratch_ty = expr_ty(bcx, arg_expr);\n                     let scratch = alloc_ty(bcx, scratch_ty);\n                     let arg_ty = expr_ty(bcx, arg_expr);\n@@ -714,8 +729,6 @@ pub fn trans_arg_expr(bcx: block,\n \n     debug!(\"   arg datum: %s\", arg_datum.to_str(bcx.ccx()));\n \n-    // finally, deal with the various modes\n-    let arg_mode = ty::resolved_mode(ccx.tcx, formal_ty.mode);\n     let mut val;\n     if ty::type_is_bot(arg_datum.ty) {\n         // For values of type _|_, we generate an\n@@ -735,24 +748,27 @@ pub fn trans_arg_expr(bcx: block,\n                 val = arg_datum.to_ref_llval(bcx);\n             }\n             DontAutorefArg => {\n-                match arg_mode {\n-                    ast::by_ref => {\n+                match self_mode {\n+                    ty::ByRef => {\n                         // This assertion should really be valid, but because\n                         // the explicit self code currently passes by-ref, it\n                         // does not hold.\n                         //\n                         //assert !bcx.ccx().maps.moves_map.contains_key(\n                         //    &arg_expr.id);\n+                        debug!(\"by ref arg with type %s\",\n+                               bcx.ty_to_str(arg_datum.ty));\n                         val = arg_datum.to_ref_llval(bcx);\n                     }\n-\n-                    ast::by_copy => {\n+                    ty::ByCopy => {\n                         debug!(\"by copy arg with type %s, storing to scratch\",\n                                bcx.ty_to_str(arg_datum.ty));\n                         let scratch = scratch_datum(bcx, arg_datum.ty, false);\n \n-                        arg_datum.store_to_datum(bcx, arg_expr.id,\n-                                                 INIT, scratch);\n+                        arg_datum.store_to_datum(bcx,\n+                                                 arg_expr.id,\n+                                                 INIT,\n+                                                 scratch);\n \n                         // Technically, ownership of val passes to the callee.\n                         // However, we must cleanup should we fail before the\n@@ -761,12 +777,8 @@ pub fn trans_arg_expr(bcx: block,\n                         temp_cleanups.push(scratch.val);\n \n                         match arg_datum.appropriate_mode() {\n-                            ByValue => {\n-                                val = Load(bcx, scratch.val);\n-                            }\n-                            ByRef => {\n-                                val = scratch.val;\n-                            }\n+                            ByValue => val = Load(bcx, scratch.val),\n+                            ByRef => val = scratch.val,\n                         }\n                     }\n                 }\n@@ -776,6 +788,10 @@ pub fn trans_arg_expr(bcx: block,\n         if formal_ty.ty != arg_datum.ty {\n             // this could happen due to e.g. subtyping\n             let llformal_ty = type_of::type_of_explicit_arg(ccx, &formal_ty);\n+            let llformal_ty = match self_mode {\n+                ty::ByRef => T_ptr(llformal_ty),\n+                ty::ByCopy => llformal_ty,\n+            };\n             debug!(\"casting actual type (%s) to match formal (%s)\",\n                    bcx.val_str(val), bcx.llty_str(llformal_ty));\n             val = PointerCast(bcx, val, llformal_ty);"}, {"sha": "f8fb0f4b7cf318f6b2194637873789b1eaeacc09", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -41,6 +41,7 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux::{Repr};\n \n+use core::cast::transmute;\n use core::hash;\n use core::hashmap::{HashMap, HashSet};\n use core::libc::{c_uint, c_longlong, c_ulonglong};\n@@ -750,13 +751,11 @@ pub impl block_ {\n         t.repr(self.tcx())\n     }\n     fn to_str(@mut self) -> ~str {\n-        match self.node_info {\n-          Some(node_info) => {\n-            fmt!(\"[block %d]\", node_info.id)\n-          }\n-          None => {\n-            fmt!(\"[block %x]\", ptr::addr_of(&(*self)) as uint)\n-          }\n+        unsafe {\n+            match self.node_info {\n+                Some(node_info) => fmt!(\"[block %d]\", node_info.id),\n+                None => fmt!(\"[block %x]\", transmute(&*self)),\n+            }\n         }\n     }\n }"}, {"sha": "f83562add31691bd413e6a3253ef4078af56a625", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -1072,7 +1072,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n                 }\n             }\n         }\n-        ast::def_arg(nid, _, _) => {\n+        ast::def_arg(nid, _) => {\n             take_local(bcx, bcx.fcx.llargs, nid)\n         }\n         ast::def_local(nid, _) | ast::def_binding(nid, _) => {"}, {"sha": "c45ba64c5847043b175b738f51634d54d46a7054", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 57, "deletions": 37, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -716,37 +716,51 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             }\n         }\n         ~\"forget\" => {}\n-        ~\"reinterpret_cast\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let llout_ty = type_of::type_of(ccx, substs.tys[1]);\n-            let tp_sz = machine::llbitsize_of_real(ccx, lltp_ty),\n-            out_sz = machine::llbitsize_of_real(ccx, llout_ty);\n-          if tp_sz != out_sz {\n-              let sp = match *ccx.tcx.items.get(&ref_id.get()) {\n-                  ast_map::node_expr(e) => e.span,\n-                  _ => fail!(~\"reinterpret_cast or forget has non-expr arg\")\n-              };\n-              ccx.sess.span_fatal(\n-                  sp, fmt!(\"reinterpret_cast called on types \\\n-                            with different size: %s (%u bit(s)) to %s \\\n-                            (%u bit(s))\",\n-                           ty_to_str(ccx.tcx, tp_ty), tp_sz,\n-                           ty_to_str(ccx.tcx, substs.tys[1]), out_sz));\n-          }\n-          if !ty::type_is_nil(substs.tys[1]) {\n-              // NB: Do not use a Load and Store here. This causes\n-              // massive code bloat when reinterpret_cast is used on\n-              // large structural types.\n-              let llretptr = fcx.llretptr.get();\n-              let llretptr = PointerCast(bcx, llretptr, T_ptr(T_i8()));\n-              let llcast = get_param(decl, first_real_arg);\n-              let llcast = PointerCast(bcx, llcast, T_ptr(T_i8()));\n-              call_memcpy(bcx, llretptr, llcast, llsize_of(ccx, lltp_ty));\n-          }\n-        }\n-        ~\"addr_of\" => {\n-            Store(bcx, get_param(decl, first_real_arg), fcx.llretptr.get());\n+        ~\"transmute\" => {\n+            let (in_type, out_type) = (substs.tys[0], substs.tys[1]);\n+            let llintype = type_of::type_of(ccx, in_type);\n+            let llouttype = type_of::type_of(ccx, out_type);\n+\n+            let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n+            let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n+            if in_type_size != out_type_size {\n+                let sp = match *ccx.tcx.items.get(&ref_id.get()) {\n+                    ast_map::node_expr(e) => e.span,\n+                    _ => fail!(~\"transmute has non-expr arg\"),\n+                };\n+                let pluralize = |n| if 1u == n { \"\" } else { \"s\" };\n+                ccx.sess.span_fatal(sp,\n+                                    fmt!(\"transmute called on types with \\\n+                                          different sizes: %s (%u bit%s) to \\\n+                                          %s (%u bit%s)\",\n+                                         ty_to_str(ccx.tcx, in_type),\n+                                         in_type_size,\n+                                         pluralize(in_type_size),\n+                                         ty_to_str(ccx.tcx, out_type),\n+                                         out_type_size,\n+                                         pluralize(out_type_size)));\n+            }\n+\n+            if !ty::type_is_nil(out_type) {\n+                // NB: Do not use a Load and Store here. This causes massive\n+                // code bloat when `transmute` is used on large structural\n+                // types.\n+                let lldestptr = fcx.llretptr.get();\n+                let lldestptr = PointerCast(bcx, lldestptr, T_ptr(T_i8()));\n+\n+                let llsrcval = get_param(decl, first_real_arg);\n+                let llsrcptr = if ty::type_is_immediate(in_type) {\n+                    let llsrcptr = alloca(bcx, llintype);\n+                    Store(bcx, llsrcval, llsrcptr);\n+                    llsrcptr\n+                } else {\n+                    llsrcval\n+                };\n+                let llsrcptr = PointerCast(bcx, llsrcptr, T_ptr(T_i8()));\n+\n+                let llsize = llsize_of(ccx, llintype);\n+                call_memcpy(bcx, lldestptr, llsrcptr, llsize);\n+            }\n         }\n         ~\"needs_drop\" => {\n             let tp_ty = substs.tys[0];\n@@ -757,9 +771,14 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         ~\"visit_tydesc\" => {\n             let td = get_param(decl, first_real_arg);\n             let visitor = get_param(decl, first_real_arg + 1u);\n+            //let llvisitorptr = alloca(bcx, val_ty(visitor));\n+            //Store(bcx, visitor, llvisitorptr);\n             let td = PointerCast(bcx, td, T_ptr(ccx.tydesc_type));\n-            glue::call_tydesc_glue_full(bcx, visitor, td,\n-                                        abi::tydesc_field_visit_glue, None);\n+            glue::call_tydesc_glue_full(bcx,\n+                                        visitor,\n+                                        td,\n+                                        abi::tydesc_field_visit_glue,\n+                                        None);\n         }\n         ~\"frame_address\" => {\n             let frameaddress = *ccx.intrinsics.get(&~\"llvm.frameaddress\");\n@@ -772,10 +791,11 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 sigil: ast::BorrowedSigil,\n                 onceness: ast::Many,\n                 region: ty::re_bound(ty::br_anon(0)),\n-                sig: FnSig {bound_lifetime_names: opt_vec::Empty,\n-                            inputs: ~[arg {mode: ast::expl(ast::by_copy),\n-                                           ty: star_u8}],\n-                            output: ty::mk_nil()}\n+                sig: FnSig {\n+                    bound_lifetime_names: opt_vec::Empty,\n+                    inputs: ~[ arg { ty: star_u8 } ],\n+                    output: ty::mk_nil()\n+                }\n             });\n             let datum = Datum {val: get_param(decl, first_real_arg),\n                                mode: ByRef, ty: fty, source: ZeroMem};"}, {"sha": "90f9f93be2b48f1763e20c0d5d0c1fcef65c24a2", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -145,14 +145,18 @@ pub fn trans_self_arg(bcx: block,\n     let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n     let mut temp_cleanups = ~[];\n \n-    // Compute the mode and type of self.\n+    // Compute the type of self.\n     let self_arg = arg {\n-        mode: mentry.self_arg.mode,\n         ty: monomorphize_type(bcx, mentry.self_arg.ty)\n     };\n \n-    let result = trans_arg_expr(bcx, self_arg, base,\n-                                &mut temp_cleanups, None, DontAutorefArg);\n+    let result = trans_arg_expr(bcx,\n+                                self_arg,\n+                                mentry.self_mode,\n+                                base,\n+                                &mut temp_cleanups,\n+                                None,\n+                                DontAutorefArg);\n \n     // FIXME(#3446)---this is wrong, actually.  The temp_cleanups\n     // should be revoked only after all arguments have been passed.\n@@ -224,14 +228,13 @@ pub fn trans_method_callee(bcx: block,\n         typeck::method_static(did) => {\n             let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n             let Result {bcx, val} = trans_self_arg(bcx, self, mentry);\n-            let tcx = bcx.tcx();\n             Callee {\n                 bcx: bcx,\n                 data: Method(MethodData {\n                     llfn: callee_fn.llfn,\n                     llself: val,\n                     self_ty: node_id_type(bcx, self.id),\n-                    self_mode: ty::resolved_mode(tcx, mentry.self_arg.mode)\n+                    self_mode: mentry.self_mode,\n                 })\n             }\n         }\n@@ -442,7 +445,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n                                   trait_id: ast::def_id,\n                                   n_method: uint,\n                                   vtbl: typeck::vtable_origin)\n-                               -> Callee {\n+                                  -> Callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n     return match vtbl {\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n@@ -463,23 +466,25 @@ pub fn trans_monomorphized_callee(bcx: block,\n               bcx, mth_id, impl_did, callee_id, rcvr_origins);\n \n           // translate the function\n-          let callee = trans_fn_ref_with_vtables(\n-              bcx, mth_id, callee_id, callee_substs, Some(callee_origins));\n+          let callee = trans_fn_ref_with_vtables(bcx,\n+                                                 mth_id,\n+                                                 callee_id,\n+                                                 callee_substs,\n+                                                 Some(callee_origins));\n \n           // create a llvalue that represents the fn ptr\n           let fn_ty = node_id_type(bcx, callee_id);\n           let llfn_ty = T_ptr(type_of_fn_from_ty(ccx, fn_ty));\n           let llfn_val = PointerCast(bcx, callee.llfn, llfn_ty);\n \n           // combine the self environment with the rest\n-          let tcx = bcx.tcx();\n           Callee {\n               bcx: bcx,\n               data: Method(MethodData {\n                   llfn: llfn_val,\n                   llself: llself_val,\n                   self_ty: node_id_type(bcx, base.id),\n-                  self_mode: ty::resolved_mode(tcx, mentry.self_arg.mode)\n+                  self_mode: mentry.self_mode,\n               })\n           }\n       }\n@@ -496,7 +501,7 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n                                     impl_did: ast::def_id,\n                                     callee_id: ast::node_id,\n                                     rcvr_substs: &[ty::t])\n-                                 -> ~[ty::t] {\n+                                    -> ~[ty::t] {\n     /*!\n     *\n     * Creates a concatenated set of substitutions which includes\n@@ -668,7 +673,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n             Store(bcx, llself, llscratch);\n             llself = llscratch;\n \n-            self_mode = ast::by_ref;\n+            self_mode = ty::ByRef;\n         }\n         ast::sty_box(_) => {\n             // Bump the reference count on the box.\n@@ -686,7 +691,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n             Store(bcx, llself, llscratch);\n             llself = llscratch;\n \n-            self_mode = ast::by_ref;\n+            self_mode = ty::ByRef;\n         }\n         ast::sty_uniq(_) => {\n             // Pass the unique pointer.\n@@ -699,7 +704,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n             Store(bcx, llself, llscratch);\n             llself = llscratch;\n \n-            self_mode = ast::by_ref;\n+            self_mode = ty::ByRef;\n         }\n     }\n "}, {"sha": "7e59f580a2c3ca612dfab2a6cf41362c20f7cab8", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -280,9 +280,15 @@ pub impl Reflector {\n \n             let make_get_disr = || {\n                 let sub_path = bcx.fcx.path + ~[path_name(special_idents::anon)];\n-                let sym = mangle_internal_name_by_path_and_seq(ccx, sub_path, ~\"get_disr\");\n-                let args = [ty::arg { mode: ast::expl(ast::by_copy),\n-                                      ty: opaqueptrty }];\n+                let sym = mangle_internal_name_by_path_and_seq(ccx,\n+                                                               sub_path,\n+                                                               ~\"get_disr\");\n+                let args = [\n+                    ty::arg {\n+                        ty: opaqueptrty\n+                    }\n+                ];\n+\n                 let llfty = type_of_fn(ccx, args, ty::mk_int());\n                 let llfdecl = decl_internal_cdecl_fn(ccx.llmod, sym, llfty);\n                 let arg = unsafe {\n@@ -347,13 +353,7 @@ pub impl Reflector {\n \n     fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig) {\n         for sig.inputs.eachi |i, arg| {\n-            let modeval = match arg.mode {\n-                ast::infer(_) => 0u,\n-                ast::expl(e) => match e {\n-                    ast::by_ref => 1u,\n-                    ast::by_copy => 5u\n-                }\n-            };\n+            let modeval = 5u;   // \"by copy\"\n             let extra = ~[self.c_uint(i),\n                          self.c_uint(modeval),\n                          self.c_tydesc(arg.ty)];"}, {"sha": "a842f91f0ed6e7fa951fcbfdd0a5b38261bbe31e", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -19,11 +19,8 @@ use util::ppaux;\n \n use syntax::ast;\n \n-pub fn arg_is_indirect(ccx: @CrateContext, arg: &ty::arg) -> bool {\n-    match ty::resolved_mode(ccx.tcx, arg.mode) {\n-        ast::by_copy => !ty::type_is_immediate(arg.ty),\n-        ast::by_ref => true\n-    }\n+pub fn arg_is_indirect(_: @CrateContext, arg: &ty::arg) -> bool {\n+    !ty::type_is_immediate(arg.ty)\n }\n \n pub fn type_of_explicit_arg(ccx: @CrateContext, arg: &ty::arg) -> TypeRef {"}, {"sha": "33145dd4334a5deed6eb5348dec95a9df2964fd9", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -78,12 +78,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n         ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n         ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n             for vec::each(sig.inputs) |arg| {\n-                match ty::resolved_mode(ccx.tcx, arg.mode) {\n-                    by_copy => {\n-                        type_needs(cx, use_repr, arg.ty);\n-                    }\n-                    by_ref => {}\n-                }\n+                type_needs(cx, use_repr, arg.ty);\n             }\n         }\n         _ => ()\n@@ -122,9 +117,9 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                                  _) => {\n         if abi.is_intrinsic() {\n             let flags = match *cx.ccx.sess.str_of(i.ident) {\n-                ~\"size_of\"  | ~\"pref_align_of\"    | ~\"min_align_of\" |\n-                ~\"init\"     | ~\"reinterpret_cast\" |\n-                ~\"move_val\" | ~\"move_val_init\" => use_repr,\n+                ~\"size_of\"  | ~\"pref_align_of\" | ~\"min_align_of\" |\n+                ~\"init\"     | ~\"transmute\"     | ~\"move_val\"     |\n+                ~\"move_val_init\" => use_repr,\n \n                 ~\"get_tydesc\" | ~\"needs_drop\" => use_tydesc,\n \n@@ -135,8 +130,8 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                 ~\"atomic_xsub_acq\" | ~\"atomic_xchg_rel\" |\n                 ~\"atomic_xadd_rel\" | ~\"atomic_xsub_rel\" => 0,\n \n-                ~\"visit_tydesc\"  | ~\"forget\" | ~\"addr_of\" |\n-                ~\"frame_address\" | ~\"morestack_addr\" => 0,\n+                ~\"visit_tydesc\"  | ~\"forget\" | ~\"frame_address\" |\n+                ~\"morestack_addr\" => 0,\n \n                 ~\"memmove32\" | ~\"memmove64\" => 0,\n \n@@ -332,15 +327,9 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n         node_type_needs(cx, use_tydesc, val.id);\n       }\n       expr_call(f, _, _) => {\n-          for vec::each(\n-              ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id))\n-          ) |a| {\n-              match a.mode {\n-                  expl(by_copy) => {\n-                      type_needs(cx, use_repr, a.ty);\n-                  }\n-                  _ => ()\n-              }\n+          for vec::each(ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx,\n+                                                           f.id))) |a| {\n+              type_needs(cx, use_repr, a.ty);\n           }\n       }\n       expr_method_call(rcvr, _, _, _, _) => {\n@@ -349,12 +338,7 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n \n         for ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx,\n                                                e.callee_id)).each |a| {\n-          match a.mode {\n-              expl(by_copy) => {\n-                  type_needs(cx, use_repr, a.ty);\n-              }\n-              _ => ()\n-          }\n+            type_needs(cx, use_repr, a.ty);\n         }\n         mark_for_method_call(cx, e.id, e.callee_id);\n       }"}, {"sha": "c7fb1e94adf4cea2f010d754d12ea81c35bc441a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 24, "deletions": 135, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -38,7 +38,6 @@ use syntax::ast_util;\n use syntax::attr;\n use syntax::codemap::span;\n use syntax::codemap;\n-use syntax::print::pprust;\n use syntax::parse::token::special_idents;\n use syntax::{ast, ast_map};\n use syntax::opt_vec::OptVec;\n@@ -48,11 +47,8 @@ use syntax;\n \n // Data types\n \n-// Note: after typeck, you should use resolved_mode() to convert this mode\n-// into an rmode, which will take into account the results of mode inference.\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub struct arg {\n-    mode: ast::mode,\n     ty: t\n }\n \n@@ -99,6 +95,16 @@ pub enum TraitStore {\n     RegionTraitStore(Region),   // &Trait\n }\n \n+// XXX: This should probably go away at some point. Maybe after destructors\n+// do?\n+#[auto_encode]\n+#[auto_decode]\n+#[deriving(Eq)]\n+pub enum SelfMode {\n+    ByCopy,\n+    ByRef,\n+}\n+\n pub struct field_ty {\n   ident: ident,\n   id: def_id,\n@@ -270,7 +276,6 @@ struct ctxt_ {\n     ast_ty_to_ty_cache: @mut HashMap<node_id, ast_ty_to_ty_cache_entry>,\n     enum_var_cache: @mut HashMap<def_id, @~[VariantInfo]>,\n     ty_param_defs: @mut HashMap<ast::node_id, TypeParameterDef>,\n-    inferred_modes: @mut HashMap<ast::node_id, ast::mode>,\n     adjustments: @mut HashMap<ast::node_id, @AutoAdjustment>,\n     normalized_cache: @mut HashMap<t, t>,\n     lang_items: middle::lang_items::LanguageItems,\n@@ -630,7 +635,6 @@ pub enum type_err {\n     terr_record_mutability,\n     terr_record_fields(expected_found<ident>),\n     terr_arg_count,\n-    terr_mode_mismatch(expected_found<mode>),\n     terr_regions_does_not_outlive(Region, Region),\n     terr_regions_not_same(Region, Region),\n     terr_regions_no_overlap(Region, Region),\n@@ -919,7 +923,6 @@ pub fn mk_ctxt(s: session::Session,\n         trait_method_def_ids: @mut HashMap::new(),\n         trait_methods_cache: @mut HashMap::new(),\n         ty_param_defs: @mut HashMap::new(),\n-        inferred_modes: @mut HashMap::new(),\n         adjustments: @mut HashMap::new(),\n         normalized_cache: new_ty_hash(),\n         lang_items: lang_items,\n@@ -1199,15 +1202,17 @@ pub fn mk_bare_fn(cx: ctxt, fty: BareFnTy) -> t {\n }\n \n pub fn mk_ctor_fn(cx: ctxt, input_tys: &[ty::t], output: ty::t) -> t {\n-    let input_args = input_tys.map(|t| arg {mode: ast::expl(ast::by_copy),\n-                                            ty: *t});\n+    let input_args = input_tys.map(|t| arg { ty: *t });\n     mk_bare_fn(cx,\n                BareFnTy {\n                    purity: ast::pure_fn,\n                    abis: AbiSet::Rust(),\n-                   sig: FnSig {bound_lifetime_names: opt_vec::Empty,\n-                               inputs: input_args,\n-                               output: output}})\n+                   sig: FnSig {\n+                    bound_lifetime_names: opt_vec::Empty,\n+                    inputs: input_args,\n+                    output: output\n+                   }\n+                })\n }\n \n \n@@ -1258,48 +1263,14 @@ pub fn mach_sty(cfg: @session::config, t: t) -> sty {\n     }\n }\n \n-pub fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n-    // FIXME(#2202) --- We retain by-ref for &fn things to workaround a\n-    // memory leak that otherwise results when @fn is upcast to &fn.\n-    match ty::get(ty).sty {\n-        ty::ty_closure(ClosureTy {sigil: ast::BorrowedSigil, _}) => {\n-            return ast::by_ref;\n-        }\n-        _ => {}\n-    }\n-    return if tcx.legacy_modes {\n-        if type_is_borrowed(ty) {\n-            // the old mode default was ++ for things like &ptr, but to be\n-            // forward-compatible with non-legacy, we should use +\n-            ast::by_copy\n-        } else if ty::type_is_immediate(ty) {\n-            ast::by_copy\n-        } else {\n-            ast::by_ref\n-        }\n-    } else {\n-        ast::by_copy\n-    };\n-\n-    fn type_is_borrowed(ty: t) -> bool {\n-        match ty::get(ty).sty {\n-            ty::ty_rptr(*) => true,\n-            ty_evec(_, vstore_slice(_)) => true,\n-            ty_estr(vstore_slice(_)) => true,\n-\n-            // technically, we prob ought to include\n-            // &fn(), but that is treated specially due to #2202\n-            _ => false\n-        }\n-    }\n-}\n-\n pub fn walk_ty(ty: t, f: &fn(t)) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n \n pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n-    if !f(ty) { return; }\n+    if !f(ty) {\n+        return;\n+    }\n     match get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_estr(_) | ty_type | ty_opaque_box | ty_self(_) |\n@@ -1331,7 +1302,9 @@ pub fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: &fn(t) -> t) -> t {\n \n pub fn fold_sig(sig: &FnSig, fldop: &fn(t) -> t) -> FnSig {\n     let args = do sig.inputs.map |arg| {\n-        arg { mode: arg.mode, ty: fldop(arg.ty) }\n+        arg {\n+            ty: fldop(arg.ty)\n+        }\n     };\n \n     FnSig {\n@@ -2704,13 +2677,6 @@ impl to_bytes::IterBytes for field {\n     }\n }\n \n-impl to_bytes::IterBytes for arg {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.mode,\n-                               &self.ty, lsb0, f)\n-    }\n-}\n-\n impl to_bytes::IterBytes for FnSig {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.inputs,\n@@ -3376,78 +3342,6 @@ pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n     }\n }\n \n-// Maintains a little union-set tree for inferred modes.  `canon()` returns\n-// the current head value for `m0`.\n-fn canon<T:Copy + cmp::Eq>(tbl: &mut HashMap<ast::node_id, ast::inferable<T>>,\n-                           m0: ast::inferable<T>) -> ast::inferable<T> {\n-    match m0 {\n-        ast::infer(id) => {\n-            let m1 = match tbl.find(&id) {\n-                None => return m0,\n-                Some(&m1) => m1\n-            };\n-            let cm1 = canon(tbl, m1);\n-            // path compression:\n-            if cm1 != m1 { tbl.insert(id, cm1); }\n-            cm1\n-        },\n-        _ => m0\n-    }\n-}\n-\n-// Maintains a little union-set tree for inferred modes.  `resolve_mode()`\n-// returns the current head value for `m0`.\n-pub fn canon_mode(cx: ctxt, m0: ast::mode) -> ast::mode {\n-    canon(cx.inferred_modes, m0)\n-}\n-\n-// Returns the head value for mode, failing if `m` was a infer(_) that\n-// was never inferred.  This should be safe for use after typeck.\n-pub fn resolved_mode(cx: ctxt, m: ast::mode) -> ast::rmode {\n-    match canon_mode(cx, m) {\n-      ast::infer(_) => {\n-        cx.sess.bug(fmt!(\"mode %? was never resolved\", m));\n-      }\n-      ast::expl(m0) => m0\n-    }\n-}\n-\n-pub fn arg_mode(cx: ctxt, a: arg) -> ast::rmode { resolved_mode(cx, a.mode) }\n-\n-// Unifies `m1` and `m2`.  Returns unified value or failure code.\n-pub fn unify_mode(cx: ctxt, modes: expected_found<ast::mode>)\n-               -> Result<ast::mode, type_err> {\n-    let m1 = modes.expected;\n-    let m2 = modes.found;\n-    match (canon_mode(cx, m1), canon_mode(cx, m2)) {\n-      (m1, m2) if (m1 == m2) => {\n-        result::Ok(m1)\n-      }\n-      (ast::infer(_), ast::infer(id2)) => {\n-        cx.inferred_modes.insert(id2, m1);\n-        result::Ok(m1)\n-      }\n-      (ast::infer(id), m) | (m, ast::infer(id)) => {\n-        cx.inferred_modes.insert(id, m);\n-        result::Ok(m1)\n-      }\n-      (_, _) => {\n-        result::Err(terr_mode_mismatch(modes))\n-      }\n-    }\n-}\n-\n-// If `m` was never unified, unifies it with `m_def`.  Returns the final value\n-// for `m`.\n-pub fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n-    match canon_mode(cx, m) {\n-      ast::infer(id) => {\n-        cx.inferred_modes.insert(id, ast::expl(m_def));\n-      }\n-      ast::expl(_) => ()\n-    }\n-}\n-\n pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     match get(t).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) |\n@@ -3545,11 +3439,6 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                  *cx.sess.str_of(values.found))\n         }\n         terr_arg_count => ~\"incorrect number of function parameters\",\n-        terr_mode_mismatch(values) => {\n-            fmt!(\"expected argument mode %s, but found %s\",\n-                 pprust::mode_to_str(values.expected),\n-                 pprust::mode_to_str(values.found))\n-        }\n         terr_regions_does_not_outlive(*) => {\n             fmt!(\"lifetime mismatch\")\n         }"}, {"sha": "ffaa6d46d3379de181ca6aea3ec6c054f735b403", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 43, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -501,52 +501,22 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n     return typ;\n }\n \n-pub fn ty_of_arg<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: &AC,\n-        rscope: &RS,\n-        a: ast::arg,\n-        expected_ty: Option<ty::arg>)\n-     -> ty::arg {\n+pub fn ty_of_arg<AC:AstConv,\n+                 RS:region_scope + Copy + Durable>(\n+                 self: &AC,\n+                 rscope: &RS,\n+                 a: ast::arg,\n+                 expected_ty: Option<ty::arg>)\n+                 -> ty::arg {\n     let ty = match a.ty.node {\n-      ast::ty_infer if expected_ty.is_some() => expected_ty.get().ty,\n-      ast::ty_infer => self.ty_infer(a.ty.span),\n-      _ => ast_ty_to_ty(self, rscope, a.ty)\n-    };\n-\n-    let mode = {\n-        match a.mode {\n-          ast::infer(_) if expected_ty.is_some() => {\n-            result::get(&ty::unify_mode(\n-                self.tcx(),\n-                ty::expected_found {expected: expected_ty.get().mode,\n-                                    found: a.mode}))\n-          }\n-          ast::infer(_) => {\n-            match ty::get(ty).sty {\n-              // If the type is not specified, then this must be a fn expr.\n-              // Leave the mode as infer(_), it will get inferred based\n-              // on constraints elsewhere.\n-              ty::ty_infer(_) => a.mode,\n-\n-              // If the type is known, then use the default for that type.\n-              // Here we unify m and the default.  This should update the\n-              // tables in tcx but should never fail, because nothing else\n-              // will have been unified with m yet:\n-              _ => {\n-                let m1 = ast::expl(ty::default_arg_mode_for_ty(self.tcx(),\n-                                                               ty));\n-                result::get(&ty::unify_mode(\n-                    self.tcx(),\n-                    ty::expected_found {expected: m1,\n-                                        found: a.mode}))\n-              }\n-            }\n-          }\n-          ast::expl(_) => a.mode\n-        }\n+        ast::ty_infer if expected_ty.is_some() => expected_ty.get().ty,\n+        ast::ty_infer => self.ty_infer(a.ty.span),\n+        _ => ast_ty_to_ty(self, rscope, a.ty),\n     };\n \n-    arg {mode: mode, ty: ty}\n+    arg {\n+        ty: ty\n+    }\n }\n \n pub fn bound_lifetimes<AC:AstConv>("}, {"sha": "fb5b53d9400fb9816504f80ef390723181d590b7", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -96,7 +96,7 @@ use util::common::indenter;\n use core::hashmap::HashSet;\n use std::list::Nil;\n use syntax::ast::{def_id, sty_value, sty_region, sty_box};\n-use syntax::ast::{sty_uniq, sty_static, node_id, by_copy, by_ref};\n+use syntax::ast::{sty_uniq, sty_static, node_id};\n use syntax::ast::{m_const, m_mutbl, m_imm};\n use syntax::ast;\n use syntax::ast_map;\n@@ -1051,9 +1051,9 @@ pub impl<'self> LookupContext<'self> {\n         self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n             self_arg: arg {\n-                mode: ast::expl(self_mode),\n                 ty: candidate.rcvr_ty,\n             },\n+            self_mode: self_mode,\n             explicit_self: candidate.method_ty.self_ty,\n             origin: candidate.origin,\n         }\n@@ -1298,6 +1298,9 @@ pub impl<'self> LookupContext<'self> {\n     }\n }\n \n-pub fn get_mode_from_self_type(self_type: ast::self_ty_) -> ast::rmode {\n-    match self_type { sty_value => by_copy, _ => by_ref }\n+pub fn get_mode_from_self_type(self_type: ast::self_ty_) -> SelfMode {\n+    match self_type {\n+        sty_value => ty::ByCopy,\n+        _ => ty::ByRef,\n+    }\n }"}, {"sha": "b9f3de873cf070dc5ab3de8bbc5057c2275e3940", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 185, "deletions": 272, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -107,6 +107,7 @@ use util::common::{block_query, indenter, loop_query};\n use util::ppaux::{bound_region_to_str};\n use util::ppaux;\n \n+use core::cast::transmute;\n use core::hashmap::HashMap;\n use core::util::replace;\n use std::list::Nil;\n@@ -706,7 +707,11 @@ impl region_scope for FnCtxt {\n }\n \n pub impl FnCtxt {\n-    fn tag(&self) -> ~str { fmt!(\"%x\", ptr::addr_of(&(*self)) as uint) }\n+    fn tag(&self) -> ~str {\n+        unsafe {\n+            fmt!(\"%x\", transmute(self))\n+        }\n+    }\n \n     fn local_ty(&self, span: span, nid: ast::node_id) -> ty::t {\n         match self.inh.locals.find(&nid) {\n@@ -1287,8 +1292,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn err_args(len: uint) -> ~[ty::arg] {\n-        vec::from_fn(len, |_| ty::arg {mode: ast::expl(ast::by_copy),\n-                                       ty: ty::mk_err()})\n+        vec::from_fn(len, |_| ty::arg { ty: ty::mk_err() })\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1689,10 +1693,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let fty = if error_happened {\n             fty_sig = FnSig {\n                 bound_lifetime_names: opt_vec::Empty,\n-                inputs: fn_ty.sig.inputs.map(|an_arg| {\n-                    arg { mode: an_arg.mode,\n-                         ty: ty::mk_err()\n-                        }}),\n+                inputs: fn_ty.sig.inputs.map(|_| {\n+                    arg {\n+                        ty: ty::mk_err()\n+                    }\n+                }),\n                 output: ty::mk_err()\n             };\n             ty::mk_err()\n@@ -2757,11 +2762,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         };\n         if bot_field {\n             fcx.write_bot(id);\n-        }\n-        else if err_field {\n+        } else if err_field {\n             fcx.write_error(id);\n-        }\n-        else {\n+        } else {\n             let typ = ty::mk_tup(tcx, elt_ts);\n             fcx.write_ty(id, typ);\n         }\n@@ -2791,15 +2794,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n           check_expr(fcx, idx);\n           let raw_base_t = fcx.expr_ty(base);\n           let idx_t = fcx.expr_ty(idx);\n-          if ty::type_is_error(raw_base_t)\n-              || ty::type_is_bot(raw_base_t) {\n+          if ty::type_is_error(raw_base_t) || ty::type_is_bot(raw_base_t) {\n               fcx.write_ty(id, raw_base_t);\n-          }\n-          else if ty::type_is_error(idx_t)\n-              || ty::type_is_bot(idx_t) {\n+          } else if ty::type_is_error(idx_t) || ty::type_is_bot(idx_t) {\n               fcx.write_ty(id, idx_t);\n-          }\n-          else {\n+          } else {\n               let (base_t, derefs) = do_autoderef(fcx, expr.span, raw_base_t);\n               let base_sty = structure_of(fcx, expr.span, base_t);\n               match ty::index_sty(&base_sty) {\n@@ -2810,15 +2809,29 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                   }\n                   None => {\n                       let resolved = structurally_resolved_type(fcx,\n-                          expr.span, raw_base_t);\n-                      let ret_ty = lookup_op_method(fcx, expr, base, resolved,\n-                                             tcx.sess.ident_of(~\"index\"),\n-                                             ~[idx], DoDerefArgs, AutoderefReceiver,\n-                        || {\n-                            fcx.type_error_message(expr.span, |actual|\n-                                fmt!(\"cannot index a value \\\n-                                      of type `%s`\", actual), base_t, None);\n-                        }, expected);\n+                                                                expr.span,\n+                                                                raw_base_t);\n+                      let index_ident = tcx.sess.ident_of(~\"index\");\n+                      let error_message = || {\n+                        fcx.type_error_message(expr.span,\n+                                               |actual| {\n+                                                fmt!(\"cannot index a value \\\n+                                                      of type `%s`\",\n+                                                     actual)\n+                                               },\n+                                               base_t,\n+                                               None);\n+                      };\n+                      let ret_ty = lookup_op_method(fcx,\n+                                                    expr,\n+                                                    base,\n+                                                    resolved,\n+                                                    index_ident,\n+                                                    ~[idx],\n+                                                    DoDerefArgs,\n+                                                    AutoderefReceiver,\n+                                                    error_message,\n+                                                    expected);\n                       fcx.write_ty(id, ret_ty);\n                   }\n               }\n@@ -3175,8 +3188,8 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n                                    -> ty_param_bounds_and_ty {\n \n     match defn {\n-      ast::def_arg(nid, _, _) | ast::def_local(nid, _) |\n-      ast::def_self(nid, _) | ast::def_binding(nid, _) => {\n+      ast::def_arg(nid, _) | ast::def_local(nid, _) | ast::def_self(nid, _) |\n+      ast::def_binding(nid, _) => {\n           let typ = fcx.local_ty(sp, nid);\n           return no_params(typ);\n       }\n@@ -3424,44 +3437,52 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     fn param(ccx: @mut CrateCtxt, n: uint) -> ty::t {\n         ty::mk_param(ccx.tcx, n, local_def(0))\n     }\n-    fn arg(m: ast::rmode, ty: ty::t) -> ty::arg {\n-        arg {mode: ast::expl(m), ty: ty}\n+    fn arg(ty: ty::t) -> ty::arg {\n+        arg {\n+            ty: ty\n+        }\n     }\n+\n     let tcx = ccx.tcx;\n     let (n_tps, inputs, output) = match *ccx.tcx.sess.str_of(it.ident) {\n       ~\"size_of\" |\n       ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint()),\n       ~\"init\" => (1u, ~[], param(ccx, 0u)),\n-      ~\"forget\" => (1u, ~[arg(ast::by_copy, param(ccx, 0u))],\n-                    ty::mk_nil()),\n-      ~\"reinterpret_cast\" => (2u, ~[arg(ast::by_ref, param(ccx, 0u))],\n-                              param(ccx, 1u)),\n-      ~\"addr_of\" => (1u, ~[arg(ast::by_ref, param(ccx, 0u))],\n-                      ty::mk_imm_ptr(tcx, param(ccx, 0u))),\n+      ~\"forget\" => (1u, ~[arg(param(ccx, 0u))], ty::mk_nil()),\n+      ~\"transmute\" => (2, ~[ arg(param(ccx, 0)) ], param(ccx, 1)),\n       ~\"move_val\" | ~\"move_val_init\" => {\n-          (1u, ~[arg(ast::by_copy,\n-                     ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),\n-                                     param(ccx, 0u))),\n-               arg(ast::by_copy, param(ccx, 0u))],\n+          (1u,\n+           ~[\n+            arg(ty::mk_mut_rptr(tcx,\n+                                ty::re_bound(ty::br_anon(0)),\n+                                param(ccx, 0))),\n+               arg(param(ccx, 0u))\n+            ],\n          ty::mk_nil())\n       }\n       ~\"needs_drop\" => (1u, ~[], ty::mk_bool()),\n \n       ~\"atomic_cxchg\"    | ~\"atomic_cxchg_acq\"| ~\"atomic_cxchg_rel\" => {\n-        (0u, ~[arg(ast::by_copy,\n-                   ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),\n-                                   ty::mk_int())),\n-               arg(ast::by_copy, ty::mk_int()),\n-               arg(ast::by_copy, ty::mk_int())],\n+        (0,\n+         ~[\n+            arg(ty::mk_mut_rptr(tcx,\n+                                ty::re_bound(ty::br_anon(0)),\n+                                ty::mk_int())),\n+               arg(ty::mk_int()),\n+               arg(ty::mk_int())\n+         ],\n          ty::mk_int())\n       }\n       ~\"atomic_xchg\"     | ~\"atomic_xadd\"     | ~\"atomic_xsub\"     |\n       ~\"atomic_xchg_acq\" | ~\"atomic_xadd_acq\" | ~\"atomic_xsub_acq\" |\n       ~\"atomic_xchg_rel\" | ~\"atomic_xadd_rel\" | ~\"atomic_xsub_rel\" => {\n-        (0u, ~[arg(ast::by_copy,\n-                   ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),\n-                                   ty::mk_int())),\n-               arg(ast::by_copy, ty::mk_int())],\n+        (0,\n+         ~[\n+            arg(ty::mk_mut_rptr(tcx,\n+                                ty::re_bound(ty::br_anon(0)),\n+                                ty::mk_int())),\n+            arg(ty::mk_int())\n+         ],\n          ty::mk_int())\n       }\n \n@@ -3470,14 +3491,15 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n         (1u, ~[], ty::mk_nil_ptr(ccx.tcx))\n       }\n       ~\"visit_tydesc\" => {\n-          let tydesc_name = special_idents::tydesc;\n-          assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n-          let (_, tydesc_ty) = *tcx.intrinsic_defs.get(&tydesc_name);\n-          let (_, visitor_object_ty) = ty::visitor_object_ty(ccx.tcx);\n-          let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,\n-                                                   mutbl: ast::m_imm});\n-          (0u, ~[arg(ast::by_copy, td_ptr),\n-                 arg(ast::by_ref, visitor_object_ty)], ty::mk_nil())\n+        let tydesc_name = special_idents::tydesc;\n+        assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n+        let (_, tydesc_ty) = *tcx.intrinsic_defs.get(&tydesc_name);\n+        let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n+        let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n+            ty: tydesc_ty,\n+            mutbl: ast::m_imm\n+        });\n+        (0, ~[ arg(td_ptr), arg(visitor_object_ty) ], ty::mk_nil())\n       }\n       ~\"frame_address\" => {\n         let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n@@ -3487,233 +3509,124 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             region: ty::re_bound(ty::br_anon(0)),\n             sig: ty::FnSig {\n                 bound_lifetime_names: opt_vec::Empty,\n-                inputs: ~[arg {mode: ast::expl(ast::by_copy),\n-                               ty: ty::mk_imm_ptr(\n-                                   ccx.tcx,\n-                                   ty::mk_mach_uint(ast::ty_u8))}],\n+                inputs: ~[\n+                    arg {\n+                        ty: ty::mk_imm_ptr(ccx.tcx,\n+                                           ty::mk_mach_uint(ast::ty_u8))\n+                    }\n+                ],\n                 output: ty::mk_nil()\n             }\n         });\n-        (0u, ~[arg(ast::by_ref, fty)], ty::mk_nil())\n+        (0u, ~[ arg(fty) ], ty::mk_nil())\n       }\n       ~\"morestack_addr\" => {\n         (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n       }\n       ~\"memmove32\" => {\n-        (0, ~[arg(ast::by_copy,\n-                  ty::mk_ptr(tcx,\n-                    ty::mt { ty: ty::mk_u8(), mutbl: ast::m_mutbl })),\n-              arg(ast::by_copy,\n-                  ty::mk_ptr(tcx,\n-                    ty::mt { ty: ty::mk_u8(), mutbl: ast::m_imm })),\n-              arg(ast::by_copy,\n-                  ty::mk_u32())],\n+        (0,\n+         ~[\n+            arg(ty::mk_ptr(tcx, ty::mt {\n+                ty: ty::mk_u8(),\n+                mutbl: ast::m_mutbl\n+            })),\n+            arg(ty::mk_ptr(tcx, ty::mt {\n+                ty: ty::mk_u8(),\n+                mutbl: ast::m_imm\n+            })),\n+            arg(ty::mk_u32())\n+         ],\n          ty::mk_nil())\n       }\n       ~\"memmove64\" => {\n-        (0, ~[arg(ast::by_copy,\n-                  ty::mk_ptr(tcx,\n-                    ty::mt { ty: ty::mk_u8(), mutbl: ast::m_mutbl })),\n-              arg(ast::by_copy,\n-                  ty::mk_ptr(tcx,\n-                    ty::mt { ty: ty::mk_u8(), mutbl: ast::m_imm })),\n-              arg(ast::by_copy,\n-                  ty::mk_u64())],\n+        (0,\n+         ~[arg(ty::mk_ptr(tcx, ty::mt {\n+            ty: ty::mk_u8(),\n+            mutbl: ast::m_mutbl\n+           })),\n+           arg(ty::mk_ptr(tcx, ty::mt {\n+            ty: ty::mk_u8(),\n+            mutbl: ast::m_imm\n+           })),\n+           arg(ty::mk_u64())\n+         ],\n          ty::mk_nil())\n       }\n-     ~\"sqrtf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"sqrtf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"powif32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32()),\n-               arg(ast::by_copy, ty::mk_i32())],\n-         ty::mk_f32())\n-     }\n-     ~\"powif64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64()),\n-               arg(ast::by_copy, ty::mk_i32())],\n-         ty::mk_f64())\n-     }\n-     ~\"sinf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"sinf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"cosf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"cosf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"powf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32()),\n-               arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"powf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64()),\n-               arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"expf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"expf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"exp2f32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"exp2f64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"logf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"logf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"log10f32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"log10f64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"log2f32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"log2f64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"fmaf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32()),\n-               arg(ast::by_copy, ty::mk_f32()),\n-               arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"fmaf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64()),\n-               arg(ast::by_copy, ty::mk_f64()),\n-               arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"fabsf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"fabsf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"floorf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"floorf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"ceilf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"ceilf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"truncf32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f32())],\n-         ty::mk_f32())\n-     }\n-     ~\"truncf64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_f64())],\n-         ty::mk_f64())\n-     }\n-     ~\"ctpop8\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_i8())],\n-         ty::mk_i8())\n-     }\n-     ~\"ctpop16\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_i16())],\n-         ty::mk_i16())\n-     }\n-     ~\"ctpop32\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_i32())],\n-         ty::mk_i32())\n-     }\n-     ~\"ctpop64\" => {\n-        (0u, ~[arg(ast::by_copy, ty::mk_i64())],\n-         ty::mk_i64())\n-     }\n-     ~\"ctlz8\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i8())],\n-         ty::mk_i8())\n-     }\n-     ~\"ctlz16\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i16())],\n-         ty::mk_i16())\n-     }\n-     ~\"ctlz32\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i32())],\n-         ty::mk_i32())\n-     }\n-     ~\"ctlz64\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i64())],\n-         ty::mk_i64())\n-     }\n-     ~\"cttz8\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i8())],\n-         ty::mk_i8())\n-     }\n-     ~\"cttz16\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i16())],\n-         ty::mk_i16())\n-     }\n-     ~\"cttz32\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i32())],\n-         ty::mk_i32())\n-     }\n-     ~\"cttz64\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i64())],\n-         ty::mk_i64())\n-     }\n-     ~\"bswap16\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i16())],\n-         ty::mk_i16())\n-     }\n-     ~\"bswap32\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i32())],\n-         ty::mk_i32())\n-     }\n-     ~\"bswap64\" => {\n-         (0u, ~[arg(ast::by_copy, ty::mk_i64())],\n-         ty::mk_i64())\n-     }\n-     ref other => {\n-        tcx.sess.span_err(it.span, ~\"unrecognized intrinsic function: `\" +\n-                          (*other) + ~\"`\");\n-        return;\n-      }\n+        ~\"sqrtf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"sqrtf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"powif32\" => {\n+           (0,\n+            ~[ arg(ty::mk_f32()), arg(ty::mk_i32()) ],\n+            ty::mk_f32())\n+        }\n+        ~\"powif64\" => {\n+           (0,\n+            ~[ arg(ty::mk_f64()), arg(ty::mk_i32()) ],\n+            ty::mk_f64())\n+        }\n+        ~\"sinf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"sinf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"cosf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"cosf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"powf32\" => {\n+           (0,\n+            ~[ arg(ty::mk_f32()), arg(ty::mk_f32()) ],\n+            ty::mk_f32())\n+        }\n+        ~\"powf64\" => {\n+           (0,\n+            ~[ arg(ty::mk_f64()), arg(ty::mk_f64()) ],\n+            ty::mk_f64())\n+        }\n+        ~\"expf32\"   => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"expf64\"   => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"exp2f32\"  => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"exp2f64\"  => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"logf32\"   => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"logf64\"   => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"log10f32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"log10f64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"log2f32\"  => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"log2f64\"  => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"fmaf32\" => {\n+            (0,\n+             ~[ arg(ty::mk_f32()), arg(ty::mk_f32()), arg(ty::mk_f32()) ],\n+             ty::mk_f32())\n+        }\n+        ~\"fmaf64\" => {\n+            (0,\n+             ~[ arg(ty::mk_f64()), arg(ty::mk_f64()), arg(ty::mk_f64()) ],\n+             ty::mk_f64())\n+        }\n+        ~\"fabsf32\"  => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"fabsf64\"  => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"floorf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"floorf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"ceilf32\"  => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"ceilf64\"  => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"truncf32\" => (0, ~[ arg(ty::mk_f32()) ], ty::mk_f32()),\n+        ~\"truncf64\" => (0, ~[ arg(ty::mk_f64()) ], ty::mk_f64()),\n+        ~\"ctpop8\"   => (0, ~[ arg(ty::mk_i8())  ], ty::mk_i8()),\n+        ~\"ctpop16\"  => (0, ~[ arg(ty::mk_i16()) ], ty::mk_i16()),\n+        ~\"ctpop32\"  => (0, ~[ arg(ty::mk_i32()) ], ty::mk_i32()),\n+        ~\"ctpop64\"  => (0, ~[ arg(ty::mk_i64()) ], ty::mk_i64()),\n+        ~\"ctlz8\"    => (0, ~[ arg(ty::mk_i8())  ], ty::mk_i8()),\n+        ~\"ctlz16\"   => (0, ~[ arg(ty::mk_i16()) ], ty::mk_i16()),\n+        ~\"ctlz32\"   => (0, ~[ arg(ty::mk_i32()) ], ty::mk_i32()),\n+        ~\"ctlz64\"   => (0, ~[ arg(ty::mk_i64()) ], ty::mk_i64()),\n+        ~\"cttz8\"    => (0, ~[ arg(ty::mk_i8())  ], ty::mk_i8()),\n+        ~\"cttz16\"   => (0, ~[ arg(ty::mk_i16()) ], ty::mk_i16()),\n+        ~\"cttz32\"   => (0, ~[ arg(ty::mk_i32()) ], ty::mk_i32()),\n+        ~\"cttz64\"   => (0, ~[ arg(ty::mk_i64()) ], ty::mk_i64()),\n+        ~\"bswap16\"  => (0, ~[ arg(ty::mk_i16()) ], ty::mk_i16()),\n+        ~\"bswap32\"  => (0, ~[ arg(ty::mk_i32()) ], ty::mk_i32()),\n+        ~\"bswap64\"  => (0, ~[ arg(ty::mk_i64()) ], ty::mk_i64()),\n+        ref other => {\n+            tcx.sess.span_err(it.span,\n+                              ~\"unrecognized intrinsic function: `\" +\n+                              (*other) + ~\"`\");\n+            return;\n+        }\n     };\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n         purity: ast::unsafe_fn,"}, {"sha": "cb2b854276d6fef91a17a48e4862eb43873407bb", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -55,7 +55,7 @@ pub type rvt = visit::vt<@mut Rcx>;\n fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n-        def_local(node_id, _) | def_arg(node_id, _, _) |\n+        def_local(node_id, _) | def_arg(node_id, _) |\n         def_self(node_id, _) | def_binding(node_id, _) => {\n             tcx.region_maps.encl_region(node_id)\n         }"}, {"sha": "d6b09d1e7f4537c7b37c9a5fec28068bfc245b5a", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -66,7 +66,9 @@ fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n             for resolve_type_vars_in_type(fcx, sp, mme.self_arg.ty).each |t| {\n                 let method_map = fcx.ccx.method_map;\n                 let new_entry = method_map_entry {\n-                    self_arg: arg {mode: mme.self_arg.mode, ty: *t },\n+                    self_arg: arg {\n+                        ty: *t\n+                    },\n                     ..*mme\n                 };\n                 debug!(\"writeback::resolve_method_map_entry(id=%?, \\\n@@ -213,52 +215,55 @@ fn visit_stmt(s: @ast::stmt, wbcx: @mut WbCtxt, v: wb_vt) {\n     resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n     visit::visit_stmt(s, wbcx, v);\n }\n+\n fn visit_expr(e: @ast::expr, wbcx: @mut WbCtxt, v: wb_vt) {\n-    if !wbcx.success { return; }\n+    if !wbcx.success {\n+        return;\n+    }\n+\n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.callee_id);\n     resolve_vtable_map_entry(wbcx.fcx, e.span, e.id);\n     resolve_vtable_map_entry(wbcx.fcx, e.span, e.callee_id);\n+\n     match e.node {\n-      ast::expr_fn_block(ref decl, _) => {\n-          for vec::each(decl.inputs) |input| {\n-              let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n-\n-              // Just in case we never constrained the mode to anything,\n-              // constrain it to the default for the type in question.\n-              match (r_ty, input.mode) {\n-                  (Some(t), ast::infer(_)) => {\n-                      let tcx = wbcx.fcx.ccx.tcx;\n-                      let m_def = ty::default_arg_mode_for_ty(tcx, t);\n-                      ty::set_default_mode(tcx, input.mode, m_def);\n-                  }\n-                  _ => ()\n-              }\n-          }\n-      }\n+        ast::expr_fn_block(ref decl, _) => {\n+            for vec::each(decl.inputs) |input| {\n+                let _ = resolve_type_vars_for_node(wbcx, e.span, input.id);\n+            }\n+        }\n \n-      ast::expr_binary(*) | ast::expr_unary(*) | ast::expr_assign_op(*)\n-        | ast::expr_index(*) => {\n-        maybe_resolve_type_vars_for_node(wbcx, e.span, e.callee_id);\n-      }\n+        ast::expr_binary(*) | ast::expr_unary(*) | ast::expr_assign_op(*) |\n+        ast::expr_index(*) => {\n+            maybe_resolve_type_vars_for_node(wbcx, e.span, e.callee_id);\n+        }\n \n-      ast::expr_method_call(*) => {\n-        // We must always have written in a callee ID type for these.\n-        resolve_type_vars_for_node(wbcx, e.span, e.callee_id);\n-      }\n+        ast::expr_method_call(*) => {\n+            // We must always have written in a callee ID type for these.\n+            resolve_type_vars_for_node(wbcx, e.span, e.callee_id);\n+        }\n \n-      _ => ()\n+        _ => ()\n     }\n+\n     visit::visit_expr(e, wbcx, v);\n }\n+\n fn visit_block(b: &ast::blk, wbcx: @mut WbCtxt, v: wb_vt) {\n-    if !wbcx.success { return; }\n+    if !wbcx.success {\n+        return;\n+    }\n+\n     resolve_type_vars_for_node(wbcx, b.span, b.node.id);\n     visit::visit_block(b, wbcx, v);\n }\n+\n fn visit_pat(p: @ast::pat, wbcx: @mut WbCtxt, v: wb_vt) {\n-    if !wbcx.success { return; }\n+    if !wbcx.success {\n+        return;\n+    }\n+\n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n     debug!(\"Type for pattern binding %s (id %d) resolved to %s\",\n            pat_to_str(p, wbcx.fcx.ccx.tcx.sess.intr()), p.id,\n@@ -267,6 +272,7 @@ fn visit_pat(p: @ast::pat, wbcx: @mut WbCtxt, v: wb_vt) {\n                                    p.id)));\n     visit::visit_pat(p, wbcx, v);\n }\n+\n fn visit_local(l: @ast::local, wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     let var_ty = wbcx.fcx.local_ty(l.span, l.node.id);"}, {"sha": "05b2f6f577b8278f28320a7b3ab7c55d6ac6ca24", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 65, "deletions": 36, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -38,8 +38,9 @@ use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar};\n use middle::typeck::infer::{resolve_nested_tvar, resolve_type};\n-use syntax::ast::{crate, def_id, def_mod, def_trait};\n-use syntax::ast::{item, item_impl, item_mod, local_crate, method, trait_ref};\n+use syntax::ast::{crate, def_id, def_mod, def_struct, def_trait, def_ty};\n+use syntax::ast::{item, item_enum, item_impl, item_mod, item_struct};\n+use syntax::ast::{local_crate, method, trait_ref, ty_path};\n use syntax::ast;\n use syntax::ast_map::node_item;\n use syntax::ast_map;\n@@ -661,7 +662,19 @@ pub impl CoherenceChecker {\n                         // Then visit the module items.\n                         visit_mod(module_, item.span, item.id, (), visitor);\n                     }\n-                    item_impl(_, opt_trait, _, _) => {\n+                    item_impl(_, None, ast_ty, _) => {\n+                        if !self.ast_type_is_defined_in_local_crate(ast_ty) {\n+                            // This is an error.\n+                            let session = self.crate_context.tcx.sess;\n+                            session.span_err(item.span,\n+                                             ~\"cannot associate methods with \\\n+                                               a type outside the crate the \\\n+                                               type is defined in; define \\\n+                                               and implement a trait or new \\\n+                                               type instead\");\n+                        }\n+                    }\n+                    item_impl(_, Some(trait_ref), _, _) => {\n                         // `for_ty` is `Type` in `impl Trait for Type`\n                         let for_ty =\n                             ty::node_id_to_type(self.crate_context.tcx,\n@@ -671,40 +684,16 @@ pub impl CoherenceChecker {\n                             // type. This still might be OK if the trait is\n                             // defined in the same crate.\n \n-                            match opt_trait {\n-                                None => {\n-                                    // There is no trait to implement, so\n-                                    // this is an error.\n-\n-                                    let session = self.crate_context.tcx.sess;\n-                                    session.span_err(item.span,\n-                                                     ~\"cannot implement \\\n-                                                      inherent methods for a \\\n-                                                      type outside the crate \\\n-                                                      the type was defined \\\n-                                                      in; define and \\\n-                                                      implement a trait or \\\n-                                                      new type instead\");\n-                                }\n+                            let trait_def_id =\n+                                self.trait_ref_to_trait_def_id(trait_ref);\n \n-                                Some(trait_ref) => {\n-                                    // This is OK if and only if the trait was\n-                                    // defined in this crate.\n-\n-                                    let trait_def_id =\n-                                        self.trait_ref_to_trait_def_id(\n-                                            trait_ref);\n-\n-                                    if trait_def_id.crate != local_crate {\n-                                        let session = self.crate_context.tcx.sess;\n-                                        session.span_err(item.span,\n-                                                         ~\"cannot provide an \\\n-                                                           extension \\\n-                                                           implementation for a \\\n-                                                           trait not defined in \\\n-                                                           this crate\");\n-                                    }\n-                                }\n+                            if trait_def_id.crate != local_crate {\n+                                let session = self.crate_context.tcx.sess;\n+                                session.span_err(item.span,\n+                                                 ~\"cannot provide an \\\n+                                                   extension implementation \\\n+                                                   for a trait not defined \\\n+                                                   in this crate\");\n                             }\n                         }\n \n@@ -754,6 +743,46 @@ pub impl CoherenceChecker {\n         }\n     }\n \n+    /// For coherence, when we have `impl Type`, we need to guarantee that\n+    /// `Type` is \"local\" to the crate. For our purposes, this means that it\n+    /// must precisely name some nominal type defined in this crate.\n+    pub fn ast_type_is_defined_in_local_crate(&self, original_type: @ast::Ty)\n+                                              -> bool {\n+        match original_type.node {\n+            ty_path(_, path_id) => {\n+                match *self.crate_context.tcx.def_map.get(&path_id) {\n+                    def_ty(def_id) | def_struct(def_id) => {\n+                        if def_id.crate != local_crate {\n+                            return false;\n+                        }\n+\n+                        // Make sure that this type precisely names a nominal\n+                        // type.\n+                        match self.crate_context\n+                                  .tcx\n+                                  .items\n+                                  .find(&def_id.node) {\n+                            None => {\n+                                self.crate_context.tcx.sess.span_bug(\n+                                    original_type.span,\n+                                    ~\"resolve didn't resolve this type?!\");\n+                            }\n+                            Some(&node_item(item, _)) => {\n+                                match item.node {\n+                                    item_struct(*) | item_enum(*) => true,\n+                                    _ => false,\n+                                }\n+                            }\n+                            Some(_) => false,\n+                        }\n+                    }\n+                    _ => false\n+                }\n+            }\n+            _ => false\n+        }\n+    }\n+\n     // Converts an implementation in the AST to an Impl structure.\n     fn create_impl_from_item(&self, item: @item) -> @Impl {\n         fn add_provided_methods(all_methods: &mut ~[@MethodInfo],"}, {"sha": "0ffd398d03c194caef5fec5abfa33b4752436330", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -552,10 +552,14 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // represent the self argument (unless this is a static method).\n     // This argument will have the *transformed* self type.\n     for trait_m.transformed_self_ty.each |&t| {\n-        trait_fn_args.push(ty::arg {mode: ast::expl(ast::by_copy), ty: t});\n+        trait_fn_args.push(ty::arg {\n+            ty: t\n+        });\n     }\n     for impl_m.transformed_self_ty.each |&t| {\n-        impl_fn_args.push(ty::arg {mode: ast::expl(ast::by_copy), ty: t});\n+        impl_fn_args.push(ty::arg {\n+            ty: t\n+        });\n     }\n \n     // Add in the normal arguments."}, {"sha": "e4db423c2e35c14597adbc1d58620cd108a92312", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -95,7 +95,6 @@ pub trait Combine {\n                    b: &ty::ClosureTy) -> cres<ty::ClosureTy>;\n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n     fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field>;\n-    fn modes(&self, a: ast::mode, b: ast::mode) -> cres<ast::mode>;\n     fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n     fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil>;\n     fn purities(&self, a: purity, b: purity) -> cres<purity>;\n@@ -312,28 +311,20 @@ pub fn super_flds<C:Combine>(\n     }\n }\n \n-pub fn super_modes<C:Combine>(\n-    self: &C, a: ast::mode, b: ast::mode)\n-    -> cres<ast::mode> {\n-\n-    let tcx = self.infcx().tcx;\n-    ty::unify_mode(tcx, expected_found(self, a, b))\n-}\n-\n-pub fn super_args<C:Combine>(\n-    self: &C, a: ty::arg, b: ty::arg)\n-    -> cres<ty::arg> {\n-\n-    do self.modes(a.mode, b.mode).chain |m| {\n-        do self.contratys(a.ty, b.ty).chain |t| {\n-            Ok(arg {mode: m, ty: t})\n-        }\n+pub fn super_args<C:Combine>(self: &C, a: ty::arg, b: ty::arg)\n+                             -> cres<ty::arg> {\n+    do self.contratys(a.ty, b.ty).chain |t| {\n+        Ok(arg {\n+            ty: t\n+        })\n     }\n }\n \n-pub fn super_vstores<C:Combine>(\n-    self: &C, vk: ty::terr_vstore_kind,\n-    a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n+pub fn super_vstores<C:Combine>(self: &C,\n+                                vk: ty::terr_vstore_kind,\n+                                a: ty::vstore,\n+                                b: ty::vstore)\n+                                -> cres<ty::vstore> {\n     debug!(\"%s.super_vstores(a=%?, b=%?)\", self.tag(), a, b);\n \n     match (a, b) {"}, {"sha": "2bbcd24595cba86aa6b59dc33bb1c01a59d91b98", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -152,10 +152,6 @@ impl Combine for Glb {\n         super_trait_stores(self, vk, a, b)\n     }\n \n-    fn modes(&self, a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(self, a, b)\n-    }\n-\n     fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n         super_args(self, a, b)\n     }"}, {"sha": "85914338017964731185eb017620dd8854435991", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -234,10 +234,6 @@ impl Combine for Lub {\n         super_trait_stores(self, vk, a, b)\n     }\n \n-    fn modes(&self, a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(self, a, b)\n-    }\n-\n     fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n         super_args(self, a, b)\n     }"}, {"sha": "266d157c4d040353b0b4c9de384f64aedb6e620f", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -241,14 +241,10 @@ impl Combine for Sub {\n                     vk: ty::terr_vstore_kind,\n                     a: ty::TraitStore,\n                     b: ty::TraitStore)\n-                 -> cres<ty::TraitStore> {\n+                    -> cres<ty::TraitStore> {\n         super_trait_stores(self, vk, a, b)\n     }\n \n-    fn modes(&self, a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(self, a, b)\n-    }\n-\n     fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n         super_args(self, a, b)\n     }"}, {"sha": "646b6412f5507c824d212ce340f2de0a1c6dcc1f", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -116,10 +116,13 @@ pub struct method_param {\n }\n \n pub struct method_map_entry {\n-    // the type and mode of the self parameter, which is not reflected\n-    // in the fn type (FIXME #3446)\n+    // the type of the self parameter, which is not reflected in the fn type\n+    // (FIXME #3446)\n     self_arg: ty::arg,\n \n+    // the mode of `self`\n+    self_mode: ty::SelfMode,\n+\n     // the type of explicit self on the method\n     explicit_self: ast::self_ty_,\n \n@@ -329,7 +332,6 @@ fn check_main_fn_ty(ccx: @mut CrateCtxt,\n fn check_start_fn_ty(ccx: @mut CrateCtxt,\n                      start_id: ast::node_id,\n                      start_span: span) {\n-\n     let tcx = ccx.tcx;\n     let start_t = ty::node_id_to_type(tcx, start_id);\n     match ty::get(start_t).sty {\n@@ -351,19 +353,25 @@ fn check_start_fn_ty(ccx: @mut CrateCtxt,\n                 _ => ()\n             }\n \n-            fn arg(m: ast::rmode, ty: ty::t) -> ty::arg {\n-                ty::arg {mode: ast::expl(m), ty: ty}\n+            fn arg(ty: ty::t) -> ty::arg {\n+                ty::arg {\n+                    ty: ty\n+                }\n             }\n \n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n                 purity: ast::impure_fn,\n                 abis: abi::AbiSet::Rust(),\n-                sig: ty::FnSig {bound_lifetime_names: opt_vec::Empty,\n-                            inputs: ~[arg(ast::by_copy, ty::mk_int()),\n-                                      arg(ast::by_copy, ty::mk_imm_ptr(tcx,\n-                                                            ty::mk_imm_ptr(tcx, ty::mk_u8()))),\n-                                      arg(ast::by_copy, ty::mk_imm_ptr(tcx, ty::mk_u8()))],\n-                            output: ty::mk_int()}\n+                sig: ty::FnSig {\n+                    bound_lifetime_names: opt_vec::Empty,\n+                    inputs: ~[\n+                        arg(ty::mk_int()),\n+                        arg(ty::mk_imm_ptr(tcx,\n+                                           ty::mk_imm_ptr(tcx, ty::mk_u8()))),\n+                        arg(ty::mk_imm_ptr(tcx, ty::mk_u8()))\n+                    ],\n+                    output: ty::mk_int()\n+                }\n             });\n \n             require_same_types(tcx, None, false, start_span, start_t, se_ty,"}, {"sha": "aa8c3f8fd1b7eb1e2b7a7b77a0a2e172105cd582", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -8,28 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::ty;\n-use middle::typeck;\n-use middle::ty::canon_mode;\n-use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid,\n-                 br_fresh};\n-use middle::ty::{ctxt, field, method};\n+use metadata::encoder;\n+use middle::ty::{ReSkolemized, ReVar};\n+use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n+use middle::ty::{br_fresh, ctxt, field, method};\n use middle::ty::{mt, t, param_bound, param_ty};\n use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region};\n-use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{ty_bool, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_trait, ty_int};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n use middle::ty::{ty_ptr, ty_rptr, ty_self, ty_tup, ty_type, ty_uniq};\n+use middle::ty::{ty_trait, ty_int};\n use middle::ty::{ty_uint, ty_unboxed_vec, ty_infer};\n-use metadata::encoder;\n+use middle::ty;\n+use middle::typeck;\n+use syntax::abi::AbiSet;\n+use syntax::ast_map;\n use syntax::codemap::span;\n use syntax::print::pprust;\n-use syntax::print::pprust::mode_to_str;\n use syntax::{ast, ast_util};\n-use syntax::ast_map;\n-use syntax::abi::AbiSet;\n \n pub trait Repr {\n     fn repr(&self, tcx: ctxt) -> ~str;\n@@ -293,26 +290,14 @@ pub fn trait_ref_to_str(cx: ctxt, trait_ref: &ty::TraitRef) -> ~str {\n \n pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     fn fn_input_to_str(cx: ctxt, input: ty::arg) -> ~str {\n-        let ty::arg {mode: mode, ty: ty} = input;\n-        let modestr = match canon_mode(cx, mode) {\n-          ast::infer(_) => ~\"\",\n-          ast::expl(m) => {\n-            if !ty::type_needs_infer(ty) &&\n-                m == ty::default_arg_mode_for_ty(cx, ty) {\n-                ~\"\"\n-            } else {\n-                mode_to_str(ast::expl(m)) + ~\":\"\n-            }\n-          }\n-        };\n-        fmt!(\"%s%s\", modestr, ty_to_str(cx, ty))\n+        ty_to_str(cx, input.ty)\n     }\n     fn bare_fn_to_str(cx: ctxt,\n                       purity: ast::purity,\n                       abis: AbiSet,\n                       ident: Option<ast::ident>,\n-                      sig: &ty::FnSig) -> ~str\n-    {\n+                      sig: &ty::FnSig)\n+                      -> ~str {\n         let mut s = ~\"extern \";\n \n         s.push_str(abis.to_str());\n@@ -701,7 +686,7 @@ impl Repr for typeck::method_map_entry {\n \n impl Repr for ty::arg {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        fmt!(\"%?(%s)\", self.mode, self.ty.repr(tcx))\n+        fmt!(\"(%s)\", self.ty.repr(tcx))\n     }\n }\n "}, {"sha": "34dd6390ecc12f98c11edb8d49aa4c11a986e375", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -11,7 +11,6 @@\n //! Unsafe debugging functions for inspecting values.\n \n use core::cast::transmute;\n-use core::ptr;\n use core::sys;\n \n pub mod rustrt {\n@@ -37,36 +36,31 @@ pub fn debug_tydesc<T>() {\n \n pub fn debug_opaque<T>(x: T) {\n     unsafe {\n-        rustrt::debug_opaque(sys::get_type_desc::<T>(),\n-                             ptr::addr_of(&x) as *());\n+        rustrt::debug_opaque(sys::get_type_desc::<T>(), transmute(&x));\n     }\n }\n \n pub fn debug_box<T>(x: @T) {\n     unsafe {\n-        rustrt::debug_box(sys::get_type_desc::<T>(),\n-                          ptr::addr_of(&x) as *());\n+        rustrt::debug_box(sys::get_type_desc::<T>(), transmute(&x));\n     }\n }\n \n pub fn debug_tag<T>(x: T) {\n     unsafe {\n-        rustrt::debug_tag(sys::get_type_desc::<T>(),\n-                          ptr::addr_of(&x) as *());\n+        rustrt::debug_tag(sys::get_type_desc::<T>(), transmute(&x));\n     }\n }\n \n pub fn debug_fn<T>(x: T) {\n     unsafe {\n-        rustrt::debug_fn(sys::get_type_desc::<T>(),\n-                         ptr::addr_of(&x) as *());\n+        rustrt::debug_fn(sys::get_type_desc::<T>(), transmute(&x));\n     }\n }\n \n pub unsafe fn ptr_cast<T, U>(x: @T) -> @U {\n     transmute(\n-        rustrt::debug_ptrcast(sys::get_type_desc::<T>(),\n-                              transmute(x)))\n+        rustrt::debug_ptrcast(sys::get_type_desc::<T>(), transmute(x)))\n }\n \n /// Triggers a debugger breakpoint"}, {"sha": "f59abfa81ca10778e5f235a45ca6afe8331a1f42", "filename": "src/libstd/future.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -23,7 +23,7 @@\n \n use core::cast;\n use core::cell::Cell;\n-use core::comm::{oneshot, PortOne, send_one};\n+use core::comm::{ChanOne, PortOne, oneshot, send_one};\n use core::pipes::recv;\n use core::task;\n \n@@ -120,8 +120,7 @@ pub fn from_value<A>(val: A) -> Future<A> {\n     Future {state: Forced(val)}\n }\n \n-pub fn from_port<A:Owned>(port: PortOne<A>) ->\n-        Future<A> {\n+pub fn from_port<A:Owned>(port: PortOne<A>) -> Future<A> {\n     /*!\n      * Create a future from a port\n      *\n@@ -131,7 +130,7 @@ pub fn from_port<A:Owned>(port: PortOne<A>) ->\n \n     let port = Cell(port);\n     do from_fn || {\n-        let port = port.take();\n+        let port = port.take().unwrap();\n         match recv(port) {\n             oneshot::send(data) => data\n         }\n@@ -158,10 +157,10 @@ pub fn spawn<A:Owned>(blk: ~fn() -> A) -> Future<A> {\n      * value of the future.\n      */\n \n-    let (chan, port) = oneshot::init();\n+    let (port, chan) = oneshot();\n \n     let chan = Cell(chan);\n-    do task::spawn || {\n+    do task::spawn {\n         let chan = chan.take();\n         send_one(chan, blk());\n     }\n@@ -186,7 +185,7 @@ mod test {\n \n     #[test]\n     fn test_from_port() {\n-        let (ch, po) = oneshot::init();\n+        let (po, ch) = oneshot();\n         send_one(ch, ~\"whale\");\n         let f = from_port(po);\n         assert!(f.get() == ~\"whale\");"}, {"sha": "800144c0ca7bedf5f9477ea4431dbb69713504e1", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -110,18 +110,18 @@ enum IpGetAddrErr {\n  * object in the case of failure\n */\n pub fn get_addr(node: &str, iotask: &iotask)\n-    -> result::Result<~[IpAddr], IpGetAddrErr> {\n+                -> result::Result<~[IpAddr], IpGetAddrErr> {\n     let (output_po, output_ch) = stream();\n     let mut output_ch = Some(SharedChan::new(output_ch));\n     do str::as_buf(node) |node_ptr, len| {\n         let output_ch = output_ch.swap_unwrap();\n         debug!(\"slice len %?\", len);\n         let handle = create_uv_getaddrinfo_t();\n-        let handle_ptr = ptr::addr_of(&handle);\n+        let handle_ptr: *uv_getaddrinfo_t = &handle;\n         let handle_data = GetAddrData {\n             output_ch: output_ch.clone()\n         };\n-        let handle_data_ptr = ptr::addr_of(&handle_data);\n+        let handle_data_ptr: *GetAddrData = &handle_data;\n         do interact(iotask) |loop_ptr| {\n             unsafe {\n                 let result = uv_getaddrinfo(\n@@ -151,7 +151,7 @@ pub mod v4 {\n     use uv_ip4_addr = uv::ll::ip4_addr;\n     use uv_ip4_name = uv::ll::ip4_name;\n \n-    use core::ptr;\n+    use core::cast::transmute;\n     use core::result;\n     use core::str;\n     use core::uint;\n@@ -189,7 +189,8 @@ pub mod v4 {\n     impl AsUnsafeU32 for Ipv4Rep {\n         // this is pretty dastardly, i know\n         unsafe fn as_u32(&self) -> u32 {\n-            *((ptr::addr_of(self)) as *u32)\n+            let this: &mut u32 = transmute(self);\n+            *this\n         }\n     }\n     pub fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {\n@@ -297,7 +298,8 @@ struct GetAddrData {\n     output_ch: SharedChan<result::Result<~[IpAddr],IpGetAddrErr>>\n }\n \n-extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n+extern fn get_addr_cb(handle: *uv_getaddrinfo_t,\n+                      status: libc::c_int,\n                       res: *addrinfo) {\n     unsafe {\n         debug!(\"in get_addr_cb\");"}, {"sha": "764152d6812c50c1fda60ea94a3edec25ef3db26", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -156,7 +156,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n             result_ch: result_ch,\n             closed_signal_ch: closed_signal_ch\n         };\n-        let conn_data_ptr = ptr::addr_of(&conn_data);\n+        let conn_data_ptr: *ConnectReqData = &conn_data;\n         let (reader_po, reader_ch) = stream::<Result<~[u8], TcpErrData>>();\n         let reader_ch = SharedChan::new(reader_ch);\n         let stream_handle_ptr = malloc_uv_tcp_t();\n@@ -173,7 +173,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n             },\n             iotask: iotask.clone()\n         };\n-        let socket_data_ptr = ptr::addr_of(&(*socket_data));\n+        let socket_data_ptr: *TcpSocketData = &*socket_data;\n         // get an unsafe representation of our stream_handle_ptr that\n         // we can send into the interact cb to be handled in libuv..\n         debug!(\"stream_handle_ptr outside interact %?\",\n@@ -187,8 +187,8 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                     0i32 => {\n                         debug!(\"tcp_init successful\");\n                         debug!(\"dealing w/ ipv4 connection..\");\n-                        let connect_req_ptr =\n-                            ptr::addr_of(&((*socket_data_ptr).connect_req));\n+                        let connect_req_ptr: *uv::ll::uv_connect_t =\n+                            &(*socket_data_ptr).connect_req;\n                         let addr_str = ip::format_addr(&input_ip);\n                         let connect_result = match input_ip {\n                             ip::Ipv4(ref addr) => {\n@@ -205,7 +205,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                                 uv::ll::tcp_connect(\n                                     connect_req_ptr,\n                                     stream_handle_ptr,\n-                                    ptr::addr_of(&in_addr),\n+                                    &in_addr,\n                                     tcp_connect_on_connect_cb)\n                             }\n                             ip::Ipv6(ref addr) => {\n@@ -215,7 +215,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                                 uv::ll::tcp_connect6(\n                                     connect_req_ptr,\n                                     stream_handle_ptr,\n-                                    ptr::addr_of(&in_addr),\n+                                    &in_addr,\n                                     tcp_connect_on_connect_cb)\n                             }\n                         };\n@@ -303,9 +303,8 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n  * `TcpErrData` value as the `Err` variant\n  */\n pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n-    -> result::Result<(), TcpErrData>\n-{\n-    let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n+             -> result::Result<(), TcpErrData> {\n+    let socket_data_ptr: *TcpSocketData = &*sock.socket_data;\n     write_common_impl(socket_data_ptr, raw_write_data)\n }\n \n@@ -343,7 +342,7 @@ pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n     -> future::Future<result::Result<(), TcpErrData>>\n {\n-    let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n+    let socket_data_ptr: *TcpSocketData = &*sock.socket_data;\n     do future_spawn {\n         let data_copy = copy(raw_write_data);\n         write_common_impl(socket_data_ptr, data_copy)\n@@ -366,9 +365,10 @@ pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n  * `TcpErrData` record\n  */\n pub fn read_start(sock: &TcpSocket)\n-    -> result::Result<@Port<\n-        result::Result<~[u8], TcpErrData>>, TcpErrData> {\n-    let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n+                  -> result::Result<@Port<result::Result<~[u8],\n+                                                         TcpErrData>>,\n+                                    TcpErrData> {\n+    let socket_data: *TcpSocketData = &*sock.socket_data;\n     read_start_common_impl(socket_data)\n }\n \n@@ -380,7 +380,7 @@ pub fn read_start(sock: &TcpSocket)\n  * * `sock` - a `net::tcp::TcpSocket` that you wish to stop reading on\n  */\n pub fn read_stop(sock: &TcpSocket) -> result::Result<(), TcpErrData> {\n-    let socket_data = ptr::addr_of(&(*sock.socket_data));\n+    let socket_data: *TcpSocketData = &*sock.socket_data;\n     read_stop_common_impl(socket_data)\n }\n \n@@ -400,8 +400,8 @@ pub fn read_stop(sock: &TcpSocket) -> result::Result<(), TcpErrData> {\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n pub fn read(sock: &TcpSocket, timeout_msecs: uint)\n-    -> result::Result<~[u8],TcpErrData> {\n-    let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n+            -> result::Result<~[u8],TcpErrData> {\n+    let socket_data: *TcpSocketData = &*sock.socket_data;\n     read_common_impl(socket_data, timeout_msecs)\n }\n \n@@ -435,8 +435,8 @@ pub fn read(sock: &TcpSocket, timeout_msecs: uint)\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n-    -> future::Future<result::Result<~[u8],TcpErrData>> {\n-    let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n+               -> future::Future<result::Result<~[u8],TcpErrData>> {\n+    let socket_data: *TcpSocketData = &*sock.socket_data;\n     do future_spawn {\n         read_common_impl(socket_data, timeout_msecs)\n     }\n@@ -534,8 +534,8 @@ pub fn accept(new_conn: TcpNewConnection)\n                     ipv6: (*server_data_ptr).ipv6,\n                     iotask : iotask.clone()\n                 };\n-                let client_socket_data_ptr = ptr::addr_of(\n-                    &(*client_socket_data));\n+                let client_socket_data_ptr: *TcpSocketData =\n+                    &*client_socket_data;\n                 let client_stream_handle_ptr =\n                     (*client_socket_data_ptr).stream_handle_ptr;\n \n@@ -661,7 +661,7 @@ fn listen_common(host_ip: ip::IpAddr,\n     let (kill_po, kill_ch) = stream::<Option<TcpErrData>>();\n     let kill_ch = SharedChan::new(kill_ch);\n     let server_stream = uv::ll::tcp_t();\n-    let server_stream_ptr = ptr::addr_of(&server_stream);\n+    let server_stream_ptr: *uv::ll::uv_tcp_t = &server_stream;\n     let server_data: TcpListenFcData = TcpListenFcData {\n         server_stream_ptr: server_stream_ptr,\n         stream_closed_ch: stream_closed_ch,\n@@ -674,7 +674,7 @@ fn listen_common(host_ip: ip::IpAddr,\n         },\n         mut active: true\n     };\n-    let server_data_ptr = ptr::addr_of(&server_data);\n+    let server_data_ptr: *TcpListenFcData = &server_data;\n \n     let (setup_po, setup_ch) = stream();\n \n@@ -699,16 +699,14 @@ fn listen_common(host_ip: ip::IpAddr,\n                             let in_addr = uv::ll::ip4_addr(\n                                 addr_str,\n                                 port as int);\n-                            uv::ll::tcp_bind(server_stream_ptr,\n-                                             ptr::addr_of(&in_addr))\n+                            uv::ll::tcp_bind(server_stream_ptr, &in_addr)\n                         }\n                         ip::Ipv6(ref addr) => {\n                             debug!(\"addr: %?\", addr);\n                             let in_addr = uv::ll::ip6_addr(\n                                 addr_str,\n                                 port as int);\n-                            uv::ll::tcp_bind6(server_stream_ptr,\n-                                              ptr::addr_of(&in_addr))\n+                            uv::ll::tcp_bind6(server_stream_ptr, &in_addr)\n                         }\n                     };\n                     match bind_result {\n@@ -856,12 +854,12 @@ pub impl TcpSocket {\n             if self.socket_data.ipv6 {\n                 let addr = uv::ll::ip6_addr(\"\", 0);\n                 uv::ll::tcp_getpeername6(self.socket_data.stream_handle_ptr,\n-                                         ptr::addr_of(&addr));\n+                                         &addr);\n                 ip::Ipv6(addr)\n             } else {\n                 let addr = uv::ll::ip4_addr(\"\", 0);\n                 uv::ll::tcp_getpeername(self.socket_data.stream_handle_ptr,\n-                                        ptr::addr_of(&addr));\n+                                        &addr);\n                 ip::Ipv4(addr)\n             }\n         }\n@@ -973,13 +971,12 @@ impl io::Reader for TcpSocketBuf {\n impl io::Writer for TcpSocketBuf {\n     pub fn write(&self, data: &const [u8]) {\n         unsafe {\n-            let socket_data_ptr =\n-                ptr::addr_of(&(*((*(self.data)).sock).socket_data));\n+            let socket_data_ptr: *TcpSocketData =\n+                &(*((*(self.data)).sock).socket_data);\n             let w_result = write_common_impl(socket_data_ptr,\n-                                            vec::slice(data,\n-                                                       0,\n-                                                       vec::len(data)\n-                                                      ).to_vec());\n+                                             vec::slice(data,\n+                                                        0,\n+                                                        data.len()).to_vec());\n             if w_result.is_err() {\n                 let err_data = w_result.get_err();\n                 debug!(\n@@ -1012,7 +1009,7 @@ fn tear_down_socket_data(socket_data: @TcpSocketData) {\n         let close_data = TcpSocketCloseData {\n             closed_ch: closed_ch\n         };\n-        let close_data_ptr = ptr::addr_of(&close_data);\n+        let close_data_ptr: *TcpSocketCloseData = &close_data;\n         let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n         do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n             unsafe {\n@@ -1150,19 +1147,21 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n                      raw_write_data: ~[u8])\n     -> result::Result<(), TcpErrData> {\n     unsafe {\n-        let write_req_ptr = ptr::addr_of(&((*socket_data_ptr).write_req));\n+        let write_req_ptr: *uv::ll::uv_write_t =\n+            &(*socket_data_ptr).write_req;\n         let stream_handle_ptr =\n             (*socket_data_ptr).stream_handle_ptr;\n-        let write_buf_vec =  ~[ uv::ll::buf_init(\n-            vec::raw::to_ptr(raw_write_data),\n-            vec::len(raw_write_data)) ];\n-        let write_buf_vec_ptr = ptr::addr_of(&write_buf_vec);\n+        let write_buf_vec = ~[\n+            uv::ll::buf_init(vec::raw::to_ptr(raw_write_data),\n+                             raw_write_data.len())\n+        ];\n+        let write_buf_vec_ptr: *~[uv::ll::uv_buf_t] = &write_buf_vec;\n         let (result_po, result_ch) = stream::<TcpWriteResult>();\n         let result_ch = SharedChan::new(result_ch);\n         let write_data = WriteReqData {\n             result_ch: result_ch\n         };\n-        let write_data_ptr = ptr::addr_of(&write_data);\n+        let write_data_ptr: *WriteReqData = &write_data;\n         do iotask::interact(&(*socket_data_ptr).iotask) |loop_ptr| {\n             unsafe {\n                 debug!(\"in interact cb for tcp::write %?\","}, {"sha": "47af3576c906210c5bafb57c215d1077ad5617fa", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -11,7 +11,6 @@\n //! A priority queue implemented with a binary heap\n \n use core::old_iter::BaseIter;\n-use core::ptr::addr_of;\n \n #[abi = \"rust-intrinsic\"]\n extern \"rust-intrinsic\" mod rusti {\n@@ -151,7 +150,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n \n     priv fn siftup(&mut self, start: uint, mut pos: uint) {\n         unsafe {\n-            let new = *addr_of(&self.data[pos]);\n+            let new = *ptr::to_unsafe_ptr(&self.data[pos]);\n \n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n@@ -171,7 +170,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n     priv fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n         unsafe {\n             let start = pos;\n-            let new = *addr_of(&self.data[pos]);\n+            let new = *ptr::to_unsafe_ptr(&self.data[pos]);\n \n             let mut child = 2 * pos + 1;\n             while child < end {"}, {"sha": "e86ec79318880e6841abbf4b7ba9f7ac03e2ef9f", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -828,18 +828,22 @@ mod tests {\n         let m = ~Mutex();\n         let m2 = m.clone();\n         let mut sharedstate = ~0;\n-        let ptr = ptr::addr_of(&(*sharedstate));\n-        do task::spawn || {\n-            let sharedstate: &mut int =\n-                unsafe { cast::transmute(ptr) };\n-            access_shared(sharedstate, m2, 10);\n-            c.send(());\n+        {\n+            let ptr: *int = &*sharedstate;\n+            do task::spawn || {\n+                let sharedstate: &mut int =\n+                    unsafe { cast::transmute(ptr) };\n+                access_shared(sharedstate, m2, 10);\n+                c.send(());\n \n+            }\n         }\n-        access_shared(sharedstate, m, 10);\n-        let _ = p.recv();\n+        {\n+            access_shared(sharedstate, m, 10);\n+            let _ = p.recv();\n \n-        assert!(*sharedstate == 20);\n+            assert!(*sharedstate == 20);\n+        }\n \n         fn access_shared(sharedstate: &mut int, m: &Mutex, n: uint) {\n             for n.times {\n@@ -1106,17 +1110,21 @@ mod tests {\n         let (p,c) = comm::stream();\n         let x2 = (*x).clone();\n         let mut sharedstate = ~0;\n-        let ptr = ptr::addr_of(&(*sharedstate));\n-        do task::spawn || {\n-            let sharedstate: &mut int =\n-                unsafe { cast::transmute(ptr) };\n-            access_shared(sharedstate, &x2, mode1, 10);\n-            c.send(());\n+        {\n+            let ptr: *int = &*sharedstate;\n+            do task::spawn || {\n+                let sharedstate: &mut int =\n+                    unsafe { cast::transmute(ptr) };\n+                access_shared(sharedstate, &x2, mode1, 10);\n+                c.send(());\n+            }\n         }\n-        access_shared(sharedstate, x, mode2, 10);\n-        let _ = p.recv();\n+        {\n+            access_shared(sharedstate, x, mode2, 10);\n+            let _ = p.recv();\n \n-        assert!(*sharedstate == 20);\n+            assert!(*sharedstate == 20);\n+        }\n \n         fn access_shared(sharedstate: &mut int, x: &RWlock, mode: RWlockMode,\n                          n: uint) {"}, {"sha": "b19b2f2889e718b5a53f71266191af055947275e", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -42,7 +42,7 @@ pub fn delayed_send<T:Owned>(iotask: &IoTask,\n     let (timer_done_po, timer_done_ch) = stream::<()>();\n     let timer_done_ch = SharedChan::new(timer_done_ch);\n     let timer = uv::ll::timer_t();\n-    let timer_ptr = ptr::addr_of(&timer);\n+    let timer_ptr: *uv::ll::uv_timer_t = &timer;\n     do iotask::interact(iotask) |loop_ptr| {\n         unsafe {\n             let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);"}, {"sha": "e49cee434f81f9e443f91454f32f169254263f74", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -162,7 +162,7 @@ mod test {\n             debug!(\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n                             exit_ch_ptr);\n             let timer_handle = ll::timer_t();\n-            let timer_ptr = ptr::addr_of(&timer_handle);\n+            let timer_ptr: *ll::uv_timer_t = &timer_handle;\n             do iotask::interact(iotask) |loop_ptr| {\n                 unsafe {\n                     debug!(~\"user code inside interact loop!!!\");"}, {"sha": "e19010e8552a280c8b971c468d9719d6b47b0644", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -17,10 +17,9 @@\n \n use ll = uv_ll;\n \n+use core::comm::{stream, Port, Chan, SharedChan};\n use core::libc::c_void;\n use core::libc;\n-use core::comm::{stream, Port, Chan, SharedChan};\n-use core::ptr::addr_of;\n \n /// Used to abstract-away direct interaction with a libuv loop.\n pub struct IoTask {\n@@ -106,7 +105,7 @@ fn run_loop(iotask_ch: &Chan<IoTask>) {\n         // set up the special async handle we'll use to allow multi-task\n         // communication with this loop\n         let async = ll::async_t();\n-        let async_handle = addr_of(&async);\n+        let async_handle: *ll::uv_async_t = &async;\n \n         // associate the async handle with the loop\n         ll::async_init(loop_ptr, async_handle, wake_up_cb);\n@@ -118,11 +117,11 @@ fn run_loop(iotask_ch: &Chan<IoTask>) {\n             async_handle: async_handle,\n             msg_po: msg_po\n         };\n-        ll::set_data_for_uv_handle(async_handle, addr_of(&data));\n+        ll::set_data_for_uv_handle(async_handle, &data);\n \n         // Send out a handle through which folks can talk to us\n         // while we dwell in the I/O loop\n-        let iotask = IoTask{\n+        let iotask = IoTask {\n             async_handle: async_handle,\n             op_chan: SharedChan::new(msg_ch)\n         };\n@@ -223,7 +222,7 @@ struct AhData {\n #[cfg(test)]\n fn impl_uv_iotask_async(iotask: &IoTask) {\n     let async_handle = ll::async_t();\n-    let ah_ptr = ptr::addr_of(&async_handle);\n+    let ah_ptr: *ll::uv_async_t = &async_handle;\n     let (exit_po, exit_ch) = stream::<()>();\n     let ah_data = AhData {\n         iotask: iotask.clone(),"}, {"sha": "8d7a97e2e483ca47d06b9d07faf46b29be0bf0c0", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -1021,19 +1021,17 @@ pub unsafe fn async_send(async_handle: *uv_async_t) {\n }\n pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n     let out_buf = uv_buf_t { base: ptr::null(), len: 0 as libc::size_t };\n-    let out_buf_ptr = ptr::addr_of(&out_buf);\n+    let out_buf_ptr: *uv_buf_t = &out_buf;\n     rustrt::rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n     return out_buf;\n }\n-pub unsafe fn ip4_addr(ip: &str, port: int)\n--> sockaddr_in {\n+pub unsafe fn ip4_addr(ip: &str, port: int) -> sockaddr_in {\n     do str::as_c_str(ip) |ip_buf| {\n         rustrt::rust_uv_ip4_addr(ip_buf as *u8,\n                                  port as libc::c_int)\n     }\n }\n-pub unsafe fn ip6_addr(ip: &str, port: int)\n--> sockaddr_in6 {\n+pub unsafe fn ip6_addr(ip: &str, port: int) -> sockaddr_in6 {\n     do str::as_c_str(ip) |ip_buf| {\n         rustrt::rust_uv_ip6_addr(ip_buf as *u8,\n                                  port as libc::c_int)\n@@ -1183,7 +1181,7 @@ pub unsafe fn free_base_of_buf(buf: uv_buf_t) {\n \n pub unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n     let err = last_error(uv_loop);\n-    let err_ptr = ptr::addr_of(&err);\n+    let err_ptr: *uv_err_t = &err;\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n     let err_msg = str::raw::from_c_str(strerror(err_ptr));\n     return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n@@ -1192,7 +1190,7 @@ pub unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n \n pub unsafe fn get_last_err_data(uv_loop: *libc::c_void) -> uv_err_data {\n     let err = last_error(uv_loop);\n-    let err_ptr = ptr::addr_of(&err);\n+    let err_ptr: *uv_err_t = &err;\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n     let err_msg = str::raw::from_c_str(strerror(err_ptr));\n     uv_err_data { err_name: err_name, err_msg: err_msg }\n@@ -1347,9 +1345,9 @@ mod test {\n         unsafe {\n             let test_loop = loop_new();\n             let tcp_handle = tcp_t();\n-            let tcp_handle_ptr = ptr::addr_of(&tcp_handle);\n+            let tcp_handle_ptr: *uv_tcp_t = &tcp_handle;\n             let connect_handle = connect_t();\n-            let connect_req_ptr = ptr::addr_of(&connect_handle);\n+            let connect_req_ptr: *uv_connect_t = &connect_handle;\n \n             // this is the persistent payload of data that we\n             // need to pass around to get this example to work.\n@@ -1365,43 +1363,42 @@ mod test {\n             // this is the enclosing record, we'll pass a ptr to\n             // this to C..\n             let write_handle = write_t();\n-            let write_handle_ptr = ptr::addr_of(&write_handle);\n+            let write_handle_ptr: *uv_write_t = &write_handle;\n             debug!(\"tcp req: tcp stream: %d write_handle: %d\",\n                              tcp_handle_ptr as int,\n                              write_handle_ptr as int);\n             let client_data = request_wrapper {\n                 write_req: write_handle_ptr,\n-                req_buf: ptr::addr_of(&req_msg),\n+                req_buf: &req_msg,\n                 read_chan: client_chan\n             };\n \n-            let tcp_init_result = tcp_init(\n-                test_loop as *libc::c_void, tcp_handle_ptr);\n-            if (tcp_init_result == 0i32) {\n+            let tcp_init_result = tcp_init(test_loop as *libc::c_void,\n+                                           tcp_handle_ptr);\n+            if (tcp_init_result == 0) {\n                 debug!(~\"sucessful tcp_init_result\");\n \n                 debug!(~\"building addr...\");\n                 let addr = ip4_addr(ip, port);\n                 // FIXME ref #2064\n-                let addr_ptr = ptr::addr_of(&addr);\n+                let addr_ptr: *sockaddr_in = &addr;\n                 debug!(\"after build addr in rust. port: %u\",\n-                                 addr.sin_port as uint);\n+                       addr.sin_port as uint);\n \n                 // this should set up the connection request..\n                 debug!(\"b4 call tcp_connect connect cb: %u \",\n-                                on_connect_cb as uint);\n-                let tcp_connect_result = tcp_connect(\n-                    connect_req_ptr, tcp_handle_ptr,\n-                    addr_ptr, on_connect_cb);\n-                if (tcp_connect_result == 0i32) {\n+                       on_connect_cb as uint);\n+                let tcp_connect_result = tcp_connect(connect_req_ptr,\n+                                                     tcp_handle_ptr,\n+                                                     addr_ptr,\n+                                                     on_connect_cb);\n+                if (tcp_connect_result == 0) {\n                     // not set the data on the connect_req\n                     // until its initialized\n-                    set_data_for_req(\n-                        connect_req_ptr as *libc::c_void,\n-                        ptr::addr_of(&client_data) as *libc::c_void);\n-                    set_data_for_uv_handle(\n-                        tcp_handle_ptr as *libc::c_void,\n-                        ptr::addr_of(&client_data) as *libc::c_void);\n+                    set_data_for_req(connect_req_ptr as *libc::c_void,\n+                                     &client_data);\n+                    set_data_for_uv_handle(tcp_handle_ptr as *libc::c_void,\n+                                           &client_data);\n                     debug!(~\"before run tcp req loop\");\n                     run(test_loop);\n                     debug!(~\"after run tcp req loop\");\n@@ -1607,37 +1604,37 @@ mod test {\n         unsafe {\n             let test_loop = loop_new();\n             let tcp_server = tcp_t();\n-            let tcp_server_ptr = ptr::addr_of(&tcp_server);\n+            let tcp_server_ptr: *uv_tcp_t = &tcp_server;\n \n             let tcp_client = tcp_t();\n-            let tcp_client_ptr = ptr::addr_of(&tcp_client);\n+            let tcp_client_ptr: *uv_tcp_t = &tcp_client;\n \n             let server_write_req = write_t();\n-            let server_write_req_ptr = ptr::addr_of(&server_write_req);\n+            let server_write_req_ptr: *uv_write_t = &server_write_req;\n \n             let resp_str_bytes = str::to_bytes(server_resp_msg);\n             let resp_msg_ptr: *u8 = vec::raw::to_ptr(resp_str_bytes);\n             debug!(\"resp_msg ptr: %u\", resp_msg_ptr as uint);\n             let resp_msg = ~[\n-                buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n+                buf_init(resp_msg_ptr, resp_str_bytes.len())\n             ];\n \n             let continue_async_handle = async_t();\n-            let continue_async_handle_ptr =\n-                ptr::addr_of(&continue_async_handle);\n+            let continue_async_handle_ptr: *uv_async_t =\n+                &continue_async_handle;\n             let async_data =\n                 async_handle_data { continue_chan: continue_chan };\n-            let async_data_ptr = ptr::addr_of(&async_data);\n+            let async_data_ptr: *async_handle_data = &async_data;\n \n             let server_data = tcp_server_data {\n                 client: tcp_client_ptr,\n                 server: tcp_server_ptr,\n                 server_kill_msg: kill_server_msg,\n-                server_resp_buf: ptr::addr_of(&resp_msg),\n+                server_resp_buf: &resp_msg,\n                 server_chan: server_chan,\n                 server_write_req: server_write_req_ptr\n             };\n-            let server_data_ptr = ptr::addr_of(&server_data);\n+            let server_data_ptr: *tcp_server_data = &server_data;\n             set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n                                            server_data_ptr as *libc::c_void);\n \n@@ -1647,11 +1644,10 @@ mod test {\n             if (tcp_init_result == 0i32) {\n                 let server_addr = ip4_addr(server_ip, server_port);\n                 // FIXME ref #2064\n-                let server_addr_ptr = ptr::addr_of(&server_addr);\n+                let server_addr_ptr: *sockaddr_in = &server_addr;\n \n                 // uv_tcp_bind()\n-                let bind_result = tcp_bind(tcp_server_ptr,\n-                                                   server_addr_ptr);\n+                let bind_result = tcp_bind(tcp_server_ptr, server_addr_ptr);\n                 if (bind_result == 0i32) {\n                     debug!(~\"successful uv_tcp_bind, listening\");\n "}, {"sha": "bb4a9e97ea1f4adb43727e013e01deea95f58518", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -16,10 +16,13 @@ use serialize::{Encoder, Encodable, Decoder, Decodable};\n use sort;\n \n use core::cell::Cell;\n-use core::comm::{oneshot, PortOne, send_one};\n+use core::cmp;\n+use core::comm::{ChanOne, PortOne, oneshot, send_one};\n+use core::either::{Either, Left, Right};\n+use core::hashmap::HashMap;\n+use core::io;\n use core::pipes::recv;\n use core::run;\n-use core::hashmap::HashMap;\n use core::to_bytes;\n \n /**\n@@ -340,13 +343,13 @@ impl TPrep for Prep {\n             }\n \n             _ => {\n-                let (chan, port) = oneshot::init();\n+                let (port, chan) = oneshot();\n                 let mut blk = None;\n                 blk <-> bo;\n                 let blk = blk.unwrap();\n                 let chan = Cell(chan);\n \n-                do task::spawn || {\n+                do task::spawn {\n                     let exe = Exec {\n                         discovered_inputs: WorkMap::new(),\n                         discovered_outputs: WorkMap::new(),\n@@ -383,7 +386,7 @@ fn unwrap<T:Owned +\n         None => fail!(),\n         Some(Left(v)) => v,\n         Some(Right(port)) => {\n-            let (exe, v) = match recv(port) {\n+            let (exe, v) = match recv(port.unwrap()) {\n                 oneshot::send(data) => data\n             };\n "}, {"sha": "ba6fe1cda4f31b83eba478a36d0d186ab7f1d44c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -198,7 +198,7 @@ pub enum def {\n     def_mod(def_id),\n     def_foreign_mod(def_id),\n     def_const(def_id),\n-    def_arg(node_id, mode, bool /* is_mutbl */),\n+    def_arg(node_id, bool /* is_mutbl */),\n     def_local(node_id, bool /* is_mutbl */),\n     def_variant(def_id /* enum */, def_id /* variant */),\n     def_ty(def_id),\n@@ -417,43 +417,6 @@ pub enum unop {\n     neg\n }\n \n-// Generally, after typeck you can get the inferred value\n-// using ty::resolved_T(...).\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n-pub enum inferable<T> {\n-    expl(T),\n-    infer(node_id)\n-}\n-\n-impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          expl(ref t) =>\n-          to_bytes::iter_bytes_2(&0u8, t, lsb0, f),\n-\n-          infer(ref n) =>\n-          to_bytes::iter_bytes_2(&1u8, n, lsb0, f),\n-        }\n-    }\n-}\n-\n-// \"resolved\" mode: the real modes.\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n-pub enum rmode { by_ref, by_copy }\n-\n-impl to_bytes::IterBytes for rmode {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-// inferable mode.\n-pub type mode = inferable<rmode>;\n-\n pub type stmt = spanned<stmt_>;\n \n #[auto_encode]\n@@ -941,7 +904,6 @@ pub struct inline_asm {\n #[auto_decode]\n #[deriving(Eq)]\n pub struct arg {\n-    mode: mode,\n     is_mutbl: bool,\n     ty: @Ty,\n     pat: @pat,"}, {"sha": "148b713a4f58f388adc0dcbb8aa34d0d66828372", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -58,7 +58,7 @@ pub fn def_id_of_def(d: def) -> def_id {\n       def_use(id) | def_struct(id) | def_trait(id) => {\n         id\n       }\n-      def_arg(id, _, _) | def_local(id, _) | def_self(id, _) | def_self_ty(id)\n+      def_arg(id, _) | def_local(id, _) | def_self(id, _) | def_self_ty(id)\n       | def_upvar(id, _, _, _) | def_binding(id, _) | def_region(id)\n       | def_typaram_binder(id) | def_label(id) => {\n         local_def(id)"}, {"sha": "dfebf6f786a28d028e139659edc1cfe011ee348e", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -52,7 +52,10 @@ pub fn expand_asm(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     let mut dialect = ast::asm_att;\n \n     let mut state = Asm;\n-    loop outer: {\n+\n+    // Not using labeled break to get us through one round of bootstrapping.\n+    let mut continue = true;\n+    while continue {\n         match state {\n             Asm => {\n                 asm = expr_to_str(cx, p.parse_expr(),\n@@ -139,20 +142,30 @@ pub fn expand_asm(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n                 p.bump();\n                 match next_state(state) {\n                     Some(x) => x,\n-                    None    => break outer\n+                    None    => {\n+                        continue = false;\n+                        break\n+                    }\n                 }\n             } else if *p.token == token::MOD_SEP {\n                 p.bump();\n                 let s = match next_state(state) {\n                     Some(x) => x,\n-                    None    => break outer\n+                    None    => {\n+                        continue = false;\n+                        break\n+                    }\n                 };\n                 match next_state(s) {\n                     Some(x) => x,\n-                    None    => break outer\n+                    None    => {\n+                        continue = false;\n+                        break\n+                    }\n                 }\n             } else if *p.token == token::EOF {\n-                break outer;\n+                continue = false;\n+                break;\n             } else {\n                state\n             };"}, {"sha": "2ceb6f0c4bb759e5976346f460eba201cfba841b", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -215,7 +215,50 @@ pub fn expand_auto_decode(\n     }\n }\n \n-priv impl @ext_ctxt {\n+trait ExtCtxtMethods {\n+    fn bind_path(&self,\n+                 span: span,\n+                 ident: ast::ident,\n+                 path: @ast::Path,\n+                 bounds: @OptVec<ast::TyParamBound>)\n+                 -> ast::TyParam;\n+    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n+    fn path_tps(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n+                -> @ast::Path;\n+    fn path_tps_global(&self,\n+                       span: span,\n+                       strs: ~[ast::ident],\n+                       tps: ~[@ast::Ty])\n+                       -> @ast::Path;\n+    fn ty_path(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n+               -> @ast::Ty;\n+    fn binder_pat(&self, span: span, nm: ast::ident) -> @ast::pat;\n+    fn stmt(&self, expr: @ast::expr) -> @ast::stmt;\n+    fn lit_str(&self, span: span, s: @~str) -> @ast::expr;\n+    fn lit_uint(&self, span: span, i: uint) -> @ast::expr;\n+    fn lambda(&self, blk: ast::blk) -> @ast::expr;\n+    fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk;\n+    fn expr_blk(&self, expr: @ast::expr) -> ast::blk;\n+    fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n+    fn expr_path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n+    fn expr_var(&self, span: span, var: ~str) -> @ast::expr;\n+    fn expr_field(&self, span: span, expr: @ast::expr, ident: ast::ident)\n+                  -> @ast::expr;\n+    fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr])\n+                 -> @ast::expr;\n+    fn expr_method_call(&self,\n+                        span: span,\n+                        expr: @ast::expr,\n+                        ident: ast::ident,\n+                        args: ~[@ast::expr])\n+                        -> @ast::expr;\n+    fn lambda_expr(&self, expr: @ast::expr) -> @ast::expr;\n+    fn lambda_stmts(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n+}\n+\n+impl ExtCtxtMethods for @ext_ctxt {\n     fn bind_path(\n         &self,\n         _span: span,\n@@ -608,7 +651,6 @@ fn mk_ser_method(\n     };\n \n     let ser_inputs = ~[ast::arg {\n-        mode: ast::infer(cx.next_id()),\n         is_mutbl: false,\n         ty: ty_s,\n         pat: @ast::pat {\n@@ -670,20 +712,22 @@ fn mk_deser_method(\n         span: span,\n     };\n \n-    let deser_inputs = ~[ast::arg {\n-        mode: ast::infer(cx.next_id()),\n-        is_mutbl: false,\n-        ty: ty_d,\n-        pat: @ast::pat {\n+    let deser_inputs = ~[\n+        ast::arg {\n+            is_mutbl: false,\n+            ty: ty_d,\n+            pat: @ast::pat {\n+                id: cx.next_id(),\n+                node: ast::pat_ident(ast::bind_by_copy,\n+                                     ast_util::ident_to_path(span,\n+                                                             cx.ident_of(\n+                                                                ~\"__d\")),\n+                                     None),\n+                span: span,\n+            },\n             id: cx.next_id(),\n-            node: ast::pat_ident(\n-                ast::bind_by_copy,\n-                ast_util::ident_to_path(span, cx.ident_of(~\"__d\")),\n-                None),\n-            span: span,\n-        },\n-        id: cx.next_id(),\n-    }];\n+        }\n+    ];\n \n     let deser_decl = ast::fn_decl {\n         inputs: deser_inputs,\n@@ -1120,7 +1164,6 @@ fn mk_enum_deser_body(\n         ast::expr_fn_block(\n             ast::fn_decl {\n                 inputs: ~[ast::arg {\n-                    mode: ast::infer(ext_cx.next_id()),\n                     is_mutbl: false,\n                     ty: @ast::Ty {\n                         id: ext_cx.next_id(),"}, {"sha": "4c876669f471d9e1c79ad714d35215a2b340a995", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -419,7 +419,6 @@ pub fn mk_arg(cx: @ext_ctxt,\n            -> ast::arg {\n     let arg_pat = mk_pat_ident(cx, span, ident);\n     ast::arg {\n-        mode: ast::infer(cx.next_id()),\n         is_mutbl: false,\n         ty: ty,\n         pat: arg_pat,"}, {"sha": "deaf1b1c754a0f88bf203d6cc38b1b23a1b61d25", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -196,7 +196,6 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n \n     fn arg(&self, name: ident, ty: @ast::Ty) -> ast::arg {\n         ast::arg {\n-            mode: ast::infer(self.next_id()),\n             is_mutbl: false,\n             ty: ty,\n             pat: @ast::pat {"}, {"sha": "3311c61de8b64fbc630769f96f322eb2c3aec526", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -75,10 +75,10 @@ impl gen_send for message {\n \n                 body += ~\"let b = pipe.reuse_buffer();\\n\";\n                 body += fmt!(\"let %s = ::core::pipes::SendPacketBuffered(\\\n-                              ::ptr::addr_of(&(b.buffer.data.%s)));\\n\",\n+                              &(b.buffer.data.%s));\\n\",\n                              sp, next.name);\n                 body += fmt!(\"let %s = ::core::pipes::RecvPacketBuffered(\\\n-                              ::ptr::addr_of(&(b.buffer.data.%s)));\\n\",\n+                              &(b.buffer.data.%s));\\n\",\n                              rp, next.name);\n             }\n             else {\n@@ -365,9 +365,9 @@ impl gen_init for protocol {\n                     |s| ext_cx.parse_stmt(\n                         fmt!(\"data.%s.set_buffer(buffer)\",\n                              s.name))),\n-                ext_cx.parse_expr(\n-                    fmt!(\"::ptr::addr_of(&(data.%s))\",\n-                         self.states[0].name))));\n+                ext_cx.parse_expr(fmt!(\n+                    \"::core::ptr::to_unsafe_ptr(&(data.%s))\",\n+                    self.states[0].name))));\n \n         quote_expr!({\n             let buffer = $buffer;"}, {"sha": "d82608846ab98519eb6e781fe3acda4f6d0dc72a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -105,7 +105,6 @@ fn fold_attribute_(at: attribute, fld: @ast_fold) -> attribute {\n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n     ast::arg {\n-        mode: a.mode,\n         is_mutbl: a.is_mutbl,\n         ty: fld.fold_ty(a.ty),\n         pat: fld.fold_pat(a.pat),\n@@ -868,7 +867,11 @@ impl ast_fold for AstFoldFns {\n     }\n }\n \n-pub impl @ast_fold {\n+pub trait AstFoldExtensions {\n+    fn fold_attributes(&self, attrs: ~[attribute]) -> ~[attribute];\n+}\n+\n+impl AstFoldExtensions for @ast_fold {\n     fn fold_attributes(&self, attrs: ~[attribute]) -> ~[attribute] {\n         attrs.map(|x| fold_attribute_(*x, *self))\n     }"}, {"sha": "7e7931bbb606bcc554b4c76713cef7f730cee6f2", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -569,19 +569,18 @@ mod test {\n         let parser = string_to_parser(@~\"b : int\");\n         assert_eq!(parser.parse_arg_general(true),\n                    ast::arg{\n-                       mode: ast::infer(1),\n                        is_mutbl: false,\n-                       ty: @ast::Ty{id:4, // fixme\n+                       ty: @ast::Ty{id:3, // fixme\n                                     node: ast::ty_path(@ast::Path{\n                                         span:sp(4,4), // this is bizarre...\n                                         // check this in the original parser?\n                                         global:false,\n                                         idents:~[mk_ident(105)],\n                                         rp: None,\n                                         types: ~[]},\n-                                                       3),\n+                                                       2),\n                                     span:sp(4,7)},\n-                       pat: @ast::pat{id:2,\n+                       pat: @ast::pat{id:1,\n                                       node: ast::pat_ident(ast::bind_by_copy,\n                                                            @ast::Path{\n                                                                span:sp(0,1),\n@@ -592,7 +591,7 @@ mod test {\n                                                            None // no idea\n                                                           ),\n                                       span: sp(0,3)}, // really?\n-                       id: 5 // fixme\n+                       id: 4 // fixme\n                    })\n     }\n \n@@ -604,21 +603,20 @@ mod test {\n                   Some(\n                       @ast::item{ident:mk_ident(100),\n                             attrs:~[],\n-                            id: 11, // fixme\n+                            id: 10, // fixme\n                             node: ast::item_fn(ast::fn_decl{\n                                 inputs: ~[ast::arg{\n-                                    mode: ast::infer(1),\n                                     is_mutbl: false,\n-                                    ty: @ast::Ty{id:4, // fixme\n+                                    ty: @ast::Ty{id:3, // fixme\n                                                 node: ast::ty_path(@ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n                                         idents:~[mk_ident(106)],\n                                         rp: None,\n                                         types: ~[]},\n-                                                       3),\n+                                                       2),\n                                                 span:sp(10,13)},\n-                                    pat: @ast::pat{id:2, // fixme\n+                                    pat: @ast::pat{id:1, // fixme\n                                                    node: ast::pat_ident(\n                                                        ast::bind_by_copy,\n                                                        @ast::Path{\n@@ -630,9 +628,9 @@ mod test {\n                                                        None // no idea\n                                                    ),\n                                                   span: sp(6,9)}, // bleah.\n-                                    id: 5 // fixme\n+                                    id: 4 // fixme\n                                 }],\n-                                output: @ast::Ty{id:6, // fixme\n+                                output: @ast::Ty{id:5, // fixme\n                                                  node: ast::ty_nil,\n                                                  span:sp(15,15)}, // not sure\n                                 cf: ast::return_val\n@@ -649,8 +647,8 @@ mod test {\n                                             view_items: ~[],\n                                             stmts: ~[@spanned{\n                                                 node: ast::stmt_semi(@ast::expr{\n-                                                    id: 7,\n-                                                    callee_id: 8,\n+                                                    id: 6,\n+                                                    callee_id: 7,\n                                                     node: ast::expr_path(\n                                                         @ast::Path{\n                                                             span:sp(17,18),\n@@ -659,10 +657,10 @@ mod test {\n                                                             rp:None,\n                                                             types: ~[]}),\n                                                     span: sp(17,18)},\n-                                                                     9), // fixme\n+                                                                     8), // fixme\n                                                 span: sp(17,18)}],\n                                             expr: None,\n-                                            id: 10, // fixme\n+                                            id: 9, // fixme\n                                             rules: ast::default_blk // no idea\n                                         }}),\n                             vis: ast::inherited,"}, {"sha": "50bdfb2f557263baba00cf0339e364be1ee5e841", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 72, "deletions": 47, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -17,10 +17,10 @@ use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{provided, public, purity};\n use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n-use ast::{blk_check_mode, box, by_copy, by_ref};\n+use ast::{blk_check_mode, box};\n use ast::{crate, crate_cfg, decl, decl_item};\n use ast::{decl_local, default_blk, deref, quot, enum_def};\n-use ast::{expl, expr, expr_, expr_addr_of, expr_match, expr_again};\n+use ast::{expr, expr_, expr_addr_of, expr_match, expr_again};\n use ast::{expr_assign, expr_assign_op, expr_binary, expr_block};\n use ast::{expr_break, expr_call, expr_cast, expr_copy, expr_do_body};\n use ast::{expr_field, expr_fn_block, expr_if, expr_index};\n@@ -32,13 +32,13 @@ use ast::{expr_vstore_slice, expr_vstore_box};\n use ast::{expr_vstore_mut_slice, expr_while, extern_fn, field, fn_decl};\n use ast::{expr_vstore_uniq, TyClosure, TyBareFn, Onceness, Once, Many};\n use ast::{foreign_item, foreign_item_const, foreign_item_fn, foreign_mod};\n-use ast::{ident, impure_fn, infer, inherited, item, item_, item_const};\n+use ast::{ident, impure_fn, inherited, item, item_, item_const};\n use ast::{item_const, item_enum, item_fn, item_foreign_mod, item_impl};\n use ast::{item_mac, item_mod, item_struct, item_trait, item_ty, lit, lit_};\n use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int};\n use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, local, m_const};\n use ast::{m_imm, m_mutbl, mac_, mac_invoc_tt, matcher, match_nonterminal};\n-use ast::{match_seq, match_tok, method, mode, mt, mul, mutability};\n+use ast::{match_seq, match_tok, method, mt, mul, mutability};\n use ast::{named_field, neg, node_id, noreturn, not, pat, pat_box, pat_enum};\n use ast::{pat_ident, pat_lit, pat_range, pat_region, pat_struct};\n use ast::{pat_tup, pat_uniq, pat_wild, private};\n@@ -348,6 +348,20 @@ pub impl Parser {\n             self.token_is_keyword(&~\"fn\", tok)\n     }\n \n+    fn token_is_lifetime(&self, tok: &token::Token) -> bool {\n+        match *tok {\n+            token::LIFETIME(*) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn get_lifetime(&self, tok: &token::Token) -> ast::ident {\n+        match *tok {\n+            token::LIFETIME(ref ident) => copy *ident,\n+            _ => self.bug(~\"not a lifetime\"),\n+        }\n+    }\n+\n     // parse a ty_bare_fun type:\n     fn parse_ty_bare_fn(&self) -> ty_\n     {\n@@ -765,22 +779,22 @@ pub impl Parser {\n     }\n \n     // parse an optional mode.\n-    fn parse_arg_mode(&self) -> mode {\n+    // XXX: Remove after snapshot.\n+    fn parse_arg_mode(&self) {\n         if self.eat(&token::BINOP(token::MINUS)) {\n             self.obsolete(*self.span, ObsoleteMode);\n-            expl(by_copy)\n         } else if self.eat(&token::ANDAND) {\n-            expl(by_ref)\n+            // Ignore.\n         } else if self.eat(&token::BINOP(token::PLUS)) {\n             if self.eat(&token::BINOP(token::PLUS)) {\n                 // ++ mode is obsolete, but we need a snapshot\n                 // to stop parsing it.\n-                expl(by_copy)\n+                // Ignore.\n             } else {\n-                expl(by_copy)\n+                // Ignore.\n             }\n         } else {\n-            infer(self.get_id())\n+            // Ignore.\n         }\n     }\n \n@@ -810,25 +824,27 @@ pub impl Parser {\n     // This version of parse arg doesn't necessarily require\n     // identifier names.\n     fn parse_arg_general(&self, require_name: bool) -> arg {\n-        let m;\n         let mut is_mutbl = false;\n         let pat = if require_name || self.is_named_argument() {\n-            m = self.parse_arg_mode();\n+            self.parse_arg_mode();\n             is_mutbl = self.eat_keyword(&~\"mut\");\n             let pat = self.parse_pat(false);\n             self.expect(&token::COLON);\n             pat\n         } else {\n-            m = infer(self.get_id());\n             ast_util::ident_to_pat(self.get_id(),\n                                    *self.last_span,\n                                    special_idents::invalid)\n         };\n \n         let t = self.parse_ty(false);\n \n-        ast::arg { mode: m, is_mutbl: is_mutbl,\n-                  ty: t, pat: pat, id: self.get_id() }\n+        ast::arg {\n+            is_mutbl: is_mutbl,\n+            ty: t,\n+            pat: pat,\n+            id: self.get_id(),\n+        }\n     }\n \n     // parse a single function argument\n@@ -838,7 +854,7 @@ pub impl Parser {\n \n     // parse an argument in a lambda header e.g. |arg, arg|\n     fn parse_fn_block_arg(&self) -> arg_or_capture_item {\n-        let m = self.parse_arg_mode();\n+        self.parse_arg_mode();\n         let is_mutbl = self.eat_keyword(&~\"mut\");\n         let pat = self.parse_pat(false);\n         let t = if self.eat(&token::COLON) {\n@@ -851,7 +867,6 @@ pub impl Parser {\n             }\n         };\n         either::Left(ast::arg {\n-            mode: m,\n             is_mutbl: is_mutbl,\n             ty: t,\n             pat: pat,\n@@ -1227,8 +1242,14 @@ pub impl Parser {\n                                                expr_do_body);\n         } else if self.eat_keyword(&~\"while\") {\n             return self.parse_while_expr();\n+        } else if self.token_is_lifetime(&*self.token) {\n+            let lifetime = self.get_lifetime(&*self.token);\n+            self.bump();\n+            self.expect(&token::COLON);\n+            self.expect_keyword(&~\"loop\");\n+            return self.parse_loop_expr(Some(lifetime));\n         } else if self.eat_keyword(&~\"loop\") {\n-            return self.parse_loop_expr();\n+            return self.parse_loop_expr(None);\n         } else if self.eat_keyword(&~\"match\") {\n             return self.parse_match_expr();\n         } else if self.eat_keyword(&~\"unsafe\") {\n@@ -1289,8 +1310,10 @@ pub impl Parser {\n             } else { ex = expr_ret(None); }\n         } else if self.eat_keyword(&~\"break\") {\n             // BREAK expression\n-            if is_ident(&*self.token) {\n-                ex = expr_break(Some(self.parse_ident()));\n+            if self.token_is_lifetime(&*self.token) {\n+                let lifetime = self.get_lifetime(&*self.token);\n+                self.bump();\n+                ex = expr_break(Some(lifetime));\n             } else {\n                 ex = expr_break(None);\n             }\n@@ -1994,37 +2017,32 @@ pub impl Parser {\n         return self.mk_expr(lo, hi, expr_while(cond, body));\n     }\n \n-    fn parse_loop_expr(&self) -> @expr {\n+    fn parse_loop_expr(&self, opt_ident: Option<ast::ident>) -> @expr {\n         // loop headers look like 'loop {' or 'loop unsafe {'\n         let is_loop_header =\n             *self.token == token::LBRACE\n             || (is_ident(&*self.token)\n                 && self.look_ahead(1) == token::LBRACE);\n-        // labeled loop headers look like 'loop foo: {'\n-        let is_labeled_loop_header =\n-            is_ident(&*self.token)\n-            && !self.is_any_keyword(&copy *self.token)\n-            && self.look_ahead(1) == token::COLON;\n \n-        if is_loop_header || is_labeled_loop_header {\n+        if is_loop_header {\n             // This is a loop body\n-            let opt_ident;\n-            if is_labeled_loop_header {\n-                opt_ident = Some(self.parse_ident());\n-                self.expect(&token::COLON);\n-            } else {\n-                opt_ident = None;\n-            }\n-\n             let lo = self.last_span.lo;\n             let body = self.parse_block();\n             let hi = body.span.hi;\n             return self.mk_expr(lo, hi, expr_loop(body, opt_ident));\n         } else {\n             // This is a 'continue' expression\n+            if opt_ident.is_some() {\n+                self.span_err(*self.last_span,\n+                              ~\"a label may not be used with a `loop` \\\n+                                expression\");\n+            }\n+\n             let lo = self.span.lo;\n-            let ex = if is_ident(&*self.token) {\n-                expr_again(Some(self.parse_ident()))\n+            let ex = if self.token_is_lifetime(&*self.token) {\n+                let lifetime = self.get_lifetime(&*self.token);\n+                self.bump();\n+                expr_again(Some(lifetime))\n             } else {\n                 expr_again(None)\n             };\n@@ -2440,18 +2458,21 @@ pub impl Parser {\n \n     // used by the copy foo and ref foo patterns to give a good\n     // error message when parsing mistakes like ref foo(a,b)\n-    fn parse_pat_ident(&self, refutable: bool,\n-                       binding_mode: ast::binding_mode) -> ast::pat_ {\n+    fn parse_pat_ident(&self,\n+                       refutable: bool,\n+                       binding_mode: ast::binding_mode)\n+                       -> ast::pat_ {\n         if !is_plain_ident(&*self.token) {\n-            self.span_fatal(\n-                *self.last_span,\n-                ~\"expected identifier, found path\");\n+            self.span_fatal(*self.last_span,\n+                            ~\"expected identifier, found path\");\n         }\n         // why a path here, and not just an identifier?\n         let name = self.parse_path_without_tps();\n         let sub = if self.eat(&token::AT) {\n             Some(self.parse_pat(refutable))\n-        } else { None };\n+        } else {\n+            None\n+        };\n \n         // just to be friendly, if they write something like\n         //   ref Some(i)\n@@ -4406,10 +4427,11 @@ pub impl Parser {\n     // text that can't be parsed as an item\n     // - mod_items uses extern_mod_allowed = true\n     // - block_tail_ uses extern_mod_allowed = false\n-    fn parse_items_and_view_items(&self, first_item_attrs: ~[attribute],\n+    fn parse_items_and_view_items(&self,\n+                                  first_item_attrs: ~[attribute],\n                                   mut extern_mod_allowed: bool,\n                                   macros_allowed: bool)\n-                                -> ParsedItemsAndViewItems {\n+                                  -> ParsedItemsAndViewItems {\n         let mut attrs = vec::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n         // First, parse view items.\n@@ -4539,8 +4561,11 @@ pub impl Parser {\n \n     fn parse_str(&self) -> @~str {\n         match *self.token {\n-          token::LIT_STR(s) => { self.bump(); self.id_to_str(s) }\n-          _ =>  self.fatal(~\"expected string literal\")\n+            token::LIT_STR(s) => {\n+                self.bump();\n+                self.id_to_str(s)\n+            }\n+            _ =>  self.fatal(~\"expected string literal\")\n         }\n     }\n }"}, {"sha": "d5645ada9294a3e20c7d115e26ca0f357ffe8a9b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -1210,12 +1210,13 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_block(s, blk);\n       }\n       ast::expr_loop(ref blk, opt_ident) => {\n-        head(s, ~\"loop\");\n-        space(s.s);\n         for opt_ident.each |ident| {\n+            word(s.s, ~\"'\");\n             print_ident(s, *ident);\n             word_space(s, ~\":\");\n         }\n+        head(s, ~\"loop\");\n+        space(s.s);\n         print_block(s, blk);\n       }\n       ast::expr_match(expr, ref arms) => {\n@@ -1363,12 +1364,20 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n       ast::expr_break(opt_ident) => {\n         word(s.s, ~\"break\");\n         space(s.s);\n-        for opt_ident.each |ident| { print_ident(s, *ident); space(s.s) }\n+        for opt_ident.each |ident| {\n+            word(s.s, ~\"'\");\n+            print_ident(s, *ident);\n+            space(s.s);\n+        }\n       }\n       ast::expr_again(opt_ident) => {\n         word(s.s, ~\"loop\");\n         space(s.s);\n-        for opt_ident.each |ident| { print_ident(s, *ident); space(s.s) }\n+        for opt_ident.each |ident| {\n+            word(s.s, ~\"'\");\n+            print_ident(s, *ident);\n+            space(s.s)\n+        }\n       }\n       ast::expr_ret(result) => {\n         word(s.s, ~\"return\");\n@@ -1718,19 +1727,6 @@ pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n-pub fn mode_to_str(m: ast::mode) -> ~str {\n-    match m {\n-      ast::expl(ast::by_ref) => ~\"&&\",\n-      ast::expl(ast::by_copy) => ~\"+\",\n-      ast::infer(_) => ~\"\"\n-    }\n-}\n-\n-pub fn print_arg_mode(s: @ps, m: ast::mode) {\n-    let ms = mode_to_str(m);\n-    if ms != ~\"\" { word(s.s, ms); }\n-}\n-\n pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n     if !bounds.is_empty() {\n         word(s.s, ~\":\");\n@@ -1879,7 +1875,6 @@ pub fn print_mt(s: @ps, mt: &ast::mt) {\n \n pub fn print_arg(s: @ps, input: ast::arg) {\n     ibox(s, indent_unit);\n-    print_arg_mode(s, input.mode);\n     if input.is_mutbl {\n         word_space(s, ~\"mut\");\n     }"}, {"sha": "56dd407f4f97a01b8df6554c569170d2fc276fcb", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -1 +1 @@\n-Subproject commit 2e9f0d21fe321849a4759a01fc28eae82ef196d6\n+Subproject commit 56dd407f4f97a01b8df6554c569170d2fc276fcb"}, {"sha": "e44267373efbf8c075a676a0ab7ca76dbb1c8409", "filename": "src/test/auxiliary/cci_iter_lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -9,14 +9,13 @@\n // except according to those terms.\n \n #[link(name=\"cci_iter_lib\", vers=\"0.0\")];\n-#[legacy_modes];\n \n #[inline]\n-pub fn iter<T>(v: ~[T], f: &fn(T)) {\n+pub fn iter<T>(v: &[T], f: &fn(&T)) {\n     let mut i = 0u;\n     let n = vec::len(v);\n     while i < n {\n-        f(v[i]);\n+        f(&v[i]);\n         i += 1u;\n     }\n }"}, {"sha": "5701912b5f6fd7fffe16cb6513f07be82fdc77c1", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -8,17 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[legacy_modes];\n-\n-pub struct Entry<A,B> {key: A, value: B}\n+pub struct Entry<A,B> {\n+    key: A,\n+    value: B\n+}\n \n-pub struct alist<A,B> { eq_fn: @fn(A,A) -> bool, data: @mut ~[Entry<A,B>] }\n+pub struct alist<A,B> {\n+    eq_fn: @fn(A,A) -> bool,\n+    data: @mut ~[Entry<A,B>]\n+}\n \n-pub fn alist_add<A:Copy,B:Copy>(lst: alist<A,B>, k: A, v: B) {\n+pub fn alist_add<A:Copy,B:Copy>(lst: &alist<A,B>, k: A, v: B) {\n     lst.data.push(Entry{key:k, value:v});\n }\n \n-pub fn alist_get<A:Copy,B:Copy>(lst: alist<A,B>, k: A) -> B {\n+pub fn alist_get<A:Copy,B:Copy>(lst: &alist<A,B>, k: A) -> B {\n     let eq_fn = lst.eq_fn;\n     for lst.data.each |entry| {\n         if eq_fn(entry.key, k) { return entry.value; }\n@@ -28,13 +32,13 @@ pub fn alist_get<A:Copy,B:Copy>(lst: alist<A,B>, k: A) -> B {\n \n #[inline]\n pub fn new_int_alist<B:Copy>() -> alist<int, B> {\n-    fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n+    fn eq_int(a: int, b: int) -> bool { a == b }\n     return alist {eq_fn: eq_int, data: @mut ~[]};\n }\n \n #[inline]\n pub fn new_int_alist_2<B:Copy>() -> alist<int, B> {\n     #[inline]\n-    fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n+    fn eq_int(a: int, b: int) -> bool { a == b }\n     return alist {eq_fn: eq_int, data: @mut ~[]};\n }"}, {"sha": "fa32b9603a5da42f57730d7af294e7fc8f08935c", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -56,6 +56,3 @@ fn context_res() -> context_res {\n \n pub type context = arc_destruct<context_res>;\n \n-pub impl context {\n-    fn socket(&self) { }\n-}"}, {"sha": "c8555ab1286b1f819389f6d9a9aadcbc976182a4", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -10,7 +10,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[legacy_modes];\n #[allow(deprecated_mode)];\n \n /*!\n@@ -226,7 +225,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n }\n \n /// A parallel version of the bfs function.\n-fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n+fn pbfs(graph: &arc::ARC<graph>, key: node_id) -> bfs_result {\n     // This works by doing functional updates of a color vector.\n \n     enum color {\n@@ -237,7 +236,7 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n         black(node_id)\n     };\n \n-    let graph_vec = arc::get(&graph); // FIXME #3387 requires this temp\n+    let graph_vec = arc::get(graph); // FIXME #3387 requires this temp\n     let mut colors = do vec::from_fn(graph_vec.len()) |i| {\n         if i as node_id == key {\n             gray(key)\n@@ -272,7 +271,7 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n         let color_vec = arc::get(&color); // FIXME #3387 requires this temp\n         colors = do par::mapi(*color_vec) {\n             let colors = arc::clone(&color);\n-            let graph = arc::clone(&graph);\n+            let graph = arc::clone(graph);\n             let result: ~fn(+x: uint, +y: &color) -> color = |i, c| {\n                 let colors = arc::get(&colors);\n                 let graph = arc::get(&graph);\n@@ -497,7 +496,7 @@ fn main() {\n         }\n \n         let start = time::precise_time_s();\n-        let bfs_tree = pbfs(graph_arc, *root);\n+        let bfs_tree = pbfs(&graph_arc, *root);\n         let stop = time::precise_time_s();\n \n         total_par += stop - start;"}, {"sha": "3833c884652540ace6c6a1827af05b791b6232f7", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -18,16 +18,14 @@\n // different scalability characteristics compared to the select\n // version.\n \n-#[legacy_modes];\n-\n extern mod std;\n use core::io::Writer;\n use core::io::WriterUtil;\n \n use core::comm::{Port, Chan, SharedChan};\n \n macro_rules! move_out (\n-    { $x:expr } => { unsafe { let y = *ptr::addr_of(&($x)); y } }\n+    { $x:expr } => { unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } }\n )\n \n enum request {\n@@ -36,7 +34,7 @@ enum request {\n     stop\n }\n \n-fn server(requests: Port<request>, responses: comm::Chan<uint>) {\n+fn server(requests: &Port<request>, responses: &comm::Chan<uint>) {\n     let mut count = 0u;\n     let mut done = false;\n     while !done {\n@@ -78,7 +76,7 @@ fn run(args: &[~str]) {\n         };\n     }\n     do task::spawn || {\n-        server(from_parent, to_parent);\n+        server(&from_parent, &to_parent);\n     }\n \n     for vec::each(worker_results) |r| {"}, {"sha": "c4044d45f36c8e4f76455fb543672c1fd538a3e5", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -14,16 +14,14 @@\n //\n // I *think* it's the same, more or less.\n \n-#[legacy_modes];\n-\n extern mod std;\n use core::io::Writer;\n use core::io::WriterUtil;\n \n use core::comm::{Port, PortSet, Chan, stream};\n \n macro_rules! move_out (\n-    { $x:expr } => { unsafe { let y = *ptr::addr_of(&($x)); y } }\n+    { $x:expr } => { unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } }\n )\n \n enum request {\n@@ -32,7 +30,7 @@ enum request {\n     stop\n }\n \n-fn server(requests: PortSet<request>, responses: Chan<uint>) {\n+fn server(requests: &PortSet<request>, responses: &Chan<uint>) {\n     let mut count = 0;\n     let mut done = false;\n     while !done {\n@@ -75,7 +73,7 @@ fn run(args: &[~str]) {\n         };\n     }\n     do task::spawn || {\n-        server(from_parent, to_parent);\n+        server(&from_parent, &to_parent);\n     }\n \n     for vec::each(worker_results) |r| {"}, {"sha": "14e955dd7bdae71fd1a823c13a5cdec7d8cb7c95", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -30,7 +30,7 @@ proto! ring (\n )\n \n macro_rules! move_out (\n-    ($x:expr) => { unsafe { let y = *ptr::addr_of(&$x); y } }\n+    ($x:expr) => { unsafe { let y = *ptr::to_unsafe_ptr(&$x); y } }\n )\n \n fn thread_ring(i: uint,"}, {"sha": "4a6e90f411686876d7ad1ce8fc436de50fbb61a6", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -44,7 +44,7 @@ proto! pingpong_unbounded (\n \n // This stuff should go in libcore::pipes\n macro_rules! move_it (\n-    { $x:expr } => { let t = *ptr::addr_of(&($x)); t }\n+    { $x:expr } => { let t = *ptr::to_unsafe_ptr(&($x)); t }\n )\n \n macro_rules! follow ("}, {"sha": "4cd7b58ce12a0009200a7d4c6b47a4dd19a9a8e5", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -11,8 +11,6 @@\n // xfail-pretty (extra blank line is inserted in vec::mapi call)\n // multi tasking k-nucleotide\n \n-#[legacy_modes];\n-\n extern mod std;\n use std::sort;\n use core::hashmap::HashMap;\n@@ -105,9 +103,9 @@ fn windows_with_carry(bb: &[u8], nn: uint,\n    return vec::slice(bb, len - (nn - 1u), len).to_vec();\n }\n \n-fn make_sequence_processor(sz: uint, from_parent: comm::Port<~[u8]>,\n-                           to_parent: comm::Chan<~str>) {\n-\n+fn make_sequence_processor(sz: uint,\n+                           from_parent: &comm::Port<~[u8]>,\n+                           to_parent: &comm::Chan<~str>) {\n    let mut freqs: HashMap<~[u8], uint> = HashMap::new();\n    let mut carry: ~[u8] = ~[];\n    let mut total: uint = 0u;\n@@ -142,7 +140,7 @@ fn make_sequence_processor(sz: uint, from_parent: comm::Port<~[u8]>,\n // given a FASTA file on stdin, process sequence THREE\n fn main() {\n     let args = os::args();\n-   let rdr = if os::getenv(~\"RUST_BENCH\").is_some() {\n+    let rdr = if os::getenv(~\"RUST_BENCH\").is_some() {\n        // FIXME: Using this compile-time env variable is a crummy way to\n        // get to this massive data set, but include_bin! chokes on it (#2598)\n        let path = Path(env!(\"CFG_SRC_DIR\"))\n@@ -170,7 +168,7 @@ fn main() {\n         let (from_parent, to_child) = comm::stream();\n \n         do task::spawn_with(from_parent) |from_parent| {\n-            make_sequence_processor(sz, from_parent, to_parent_);\n+            make_sequence_processor(sz, &from_parent, &to_parent_);\n         };\n \n         to_child"}, {"sha": "acb8a6bcbeed644b6c0b13ee8d5089c21f6eb25a", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -19,8 +19,6 @@\n \n */\n \n-#[legacy_modes];\n-\n extern mod std;\n \n use std::{time, getopts};\n@@ -32,23 +30,23 @@ use core::result;\n use core::result::{Ok, Err};\n \n fn fib(n: int) -> int {\n-    fn pfib(c: Chan<int>, n: int) {\n+    fn pfib(c: &Chan<int>, n: int) {\n         if n == 0 {\n             c.send(0);\n         } else if n <= 2 {\n             c.send(1);\n         } else {\n             let p = PortSet::new();\n             let ch = p.chan();\n-            task::spawn(|| pfib(ch, n - 1) );\n+            task::spawn(|| pfib(&ch, n - 1) );\n             let ch = p.chan();\n-            task::spawn(|| pfib(ch, n - 2) );\n+            task::spawn(|| pfib(&ch, n - 2) );\n             c.send(p.recv() + p.recv());\n         }\n     }\n \n     let (p, ch) = stream();\n-    let _t = task::spawn(|| pfib(ch, n) );\n+    let _t = task::spawn(|| pfib(&ch, n) );\n     p.recv()\n }\n "}, {"sha": "2efc16de8307fbcd5819e3d8421878f14f014e3b", "filename": "src/test/compile-fail/arg-style-mismatch.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Ftest%2Fcompile-fail%2Farg-style-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Ftest%2Fcompile-fail%2Farg-style-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farg-style-mismatch.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: mismatched types\n-\n-fn f(&&_x: int) {}\n-fn g(_a: &fn(+v: int)) {}\n-fn main() { g(f); }"}, {"sha": "3e9e306ed2bfc9fc2ea180f6824cf58fa53cc962", "filename": "src/test/compile-fail/fn-variance-1.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[legacy_modes];\n-\n-fn takes_mut(&&x: @mut int) { }\n-fn takes_imm(&&x: @int) { }\n+fn takes_mut(x: @mut int) { }\n+fn takes_imm(x: @int) { }\n \n fn apply<T>(t: T, f: &fn(T)) {\n     f(t)"}, {"sha": "da13d450273ba380192764f5fb4420b2691fbe64", "filename": "src/test/compile-fail/issue-3096-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -11,6 +11,6 @@\n enum bottom { } \n \n fn main() {\n-    let x = ptr::addr_of(&()) as *bottom;\n+    let x = ptr::to_unsafe_ptr(&()) as *bottom;\n     match x { } //~ ERROR non-exhaustive patterns\n }"}, {"sha": "c60848e5cc6c5ab443cacac7c067e420bd1d8e88", "filename": "src/test/compile-fail/liveness-move-from-args.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn take(_x: ~int) { }\n-\n-fn from_by_ref_arg(&&x: ~int) {\n-    take(x);  //~ ERROR illegal move from argument `x`, which is not copy or move mode\n-}\n-\n-fn from_copy_arg(+x: ~int) {\n-    take(x);\n-}\n-\n-fn main() {\n-}"}, {"sha": "4994bb323d9c5460d9beae29d0a7eb8e6543d5ad", "filename": "src/test/compile-fail/mode-inference-fail.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[legacy_modes];\n-\n-// In this test, the mode gets inferred to ++ due to the apply_int(),\n-// but then we get a failure in the generic apply().\n-\n-fn apply<A>(f: &fn(A) -> A, a: A) -> A { f(a) }\n-fn apply_int(f: &fn(int) -> int, a: int) -> int { f(a) }\n-\n-fn main() {\n-    let f = {|i| i};\n-    assert!(apply_int(f, 2) == 2);\n-    assert!(apply(f, 2) == 2); //~ ERROR expected argument mode &&\n-}"}, {"sha": "39e47fb1aabdbff59193d2fe17cce0705035a3d5", "filename": "src/test/compile-fail/mutable-arguments.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Ftest%2Fcompile-fail%2Fmutable-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a/src%2Ftest%2Fcompile-fail%2Fmutable-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-arguments.rs?ref=dbcc3fe63a71d92d194d99dfd5e73fb62d09e79a", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Note: it would be nice to give fewer warnings in these cases.\n-\n-fn mutate_by_mut_ref(x: &mut uint) {\n-    *x = 0;\n-}\n-\n-fn mutate_by_ref(&&x: uint) {\n-    //~^ WARNING unused variable: `x`\n-    x = 0; //~ ERROR assigning to argument\n-}\n-\n-fn mutate_by_copy(+x: uint) {\n-    //~^ WARNING unused variable: `x`\n-    x = 0; //~ ERROR assigning to argument\n-    //~^ WARNING value assigned to `x` is never read\n-}\n-\n-fn mutate_by_move(+x: uint) {\n-    //~^ WARNING unused variable: `x`\n-    x = 0; //~ ERROR assigning to argument\n-    //~^ WARNING value assigned to `x` is never read\n-}\n-\n-fn main() {\n-}"}, {"sha": "b89e22582bb3acfe27b7624cf1eedd52860758e8", "filename": "src/test/compile-fail/non-copyable-void.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let x : *~[int] = ptr::addr_of(&~[1,2,3]);\n+    let x : *~[int] = &~[1,2,3];\n     let y : *libc::c_void = x as *libc::c_void;\n     unsafe {\n         let _z = copy *y;"}, {"sha": "c03261816ef31fe279566662b07bdba18e49e389", "filename": "src/test/compile-fail/packed-struct-generic-transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -13,7 +13,7 @@\n // the error points to the start of the file, not the line with the\n // transmute\n \n-// error-pattern: reinterpret_cast called on types with different size\n+// error-pattern: transmute called on types with different size\n \n #[packed]\n struct Foo<T,S> {"}, {"sha": "cad78f9e5d1f580292afb14960ea166e88890da4", "filename": "src/test/compile-fail/packed-struct-transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -13,7 +13,7 @@\n // the error points to the start of the file, not the line with the\n // transmute\n \n-// error-pattern: reinterpret_cast called on types with different size\n+// error-pattern: transmute called on types with different size\n \n #[packed]\n struct Foo {"}, {"sha": "120428e02f4cbef8bef880d7ccd784c468a79c30", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[legacy_modes];\n-\n enum ast<'self> {\n     num(uint),\n     add(&'self ast<'self>, &'self ast<'self>)"}, {"sha": "d5d54ade4443a991819b1d4b97ce358ef0a58b8b", "filename": "src/test/run-fail/unwind-box-res.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-res.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -21,7 +21,7 @@ struct r {\n impl Drop for r {\n     fn finalize(&self) {\n         unsafe {\n-            let _v2: ~int = cast::reinterpret_cast(&self.v);\n+            let _v2: ~int = cast::transmute(self.v);\n         }\n     }\n }\n@@ -35,7 +35,7 @@ fn r(v: *int) -> r {\n fn main() {\n     unsafe {\n         let i1 = ~0;\n-        let i1p = cast::reinterpret_cast(&i1);\n+        let i1p = cast::transmute_copy(&i1);\n         cast::forget(i1);\n         let x = @r(i1p);\n         failfn();"}, {"sha": "9bfe29a5e8e4c0f6f64796da9d177f42b11c1e2e", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -10,8 +10,6 @@\n \n // xfail-pretty\n \n-#[legacy_modes];\n-\n extern mod std;\n extern mod syntax;\n "}, {"sha": "d9f3f10a11b035febad203c943bb9afbb1758083", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -25,7 +25,7 @@ fn foo(s: @int) {\n       _ => { debug!(\"?\"); fail!(); }\n     }\n     debug!(::core::sys::refcount(s));\n-    assert!((::core::sys::refcount(s) == count + 1u));\n+    assert_eq!(::core::sys::refcount(s), count + 1u);\n     let _ = ::core::sys::refcount(s); // don't get bitten by last-use.\n }\n \n@@ -39,5 +39,5 @@ pub fn main() {\n     debug!(\"%u\", ::core::sys::refcount(s));\n     let count2 = ::core::sys::refcount(s);\n     let _ = ::core::sys::refcount(s); // don't get bitten by last-use.\n-    assert!(count == count2);\n+    assert_eq!(count, count2);\n }"}, {"sha": "e7624c9e3b939f33f3100ad7e9127de816ed01ac", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -64,9 +64,9 @@ fn test_box() {\n \n fn test_ptr() {\n     unsafe {\n-        let p1: *u8 = ::core::cast::reinterpret_cast(&0);\n-        let p2: *u8 = ::core::cast::reinterpret_cast(&0);\n-        let p3: *u8 = ::core::cast::reinterpret_cast(&1);\n+        let p1: *u8 = ::core::cast::transmute(0);\n+        let p2: *u8 = ::core::cast::transmute(0);\n+        let p3: *u8 = ::core::cast::transmute(1);\n \n         assert!(p1 == p2);\n         assert!(p1 != p3);\n@@ -107,8 +107,8 @@ fn test_class() {\n   \n   unsafe {\n   error!(\"q = %x, r = %x\",\n-         (::core::cast::reinterpret_cast::<*p, uint>(&ptr::addr_of(&q))),\n-         (::core::cast::reinterpret_cast::<*p, uint>(&ptr::addr_of(&r))));\n+         (::core::cast::transmute::<*p, uint>(&q)),\n+         (::core::cast::transmute::<*p, uint>(&r)));\n   }\n   assert!((q == r));\n   r.y = 17;"}, {"sha": "d65a043bf47e943f7c97aa539a778a75bff0cd22", "filename": "src/test/run-pass/borrowck-borrow-from-expr-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -14,7 +14,7 @@ fn borrow(x: &int, f: &fn(x: &int)) {\n \n fn test1(x: @~int) {\n     do borrow(&*(*x).clone()) |p| {\n-        let x_a = ptr::addr_of(&(**x));\n+        let x_a = ptr::to_unsafe_ptr(&**x);\n         assert!((x_a as uint) != ptr::to_uint(p));\n         assert!(unsafe{*x_a} == *p);\n     }"}, {"sha": "db88646631357485c420ca01153ee484e9559416", "filename": "src/test/run-pass/borrowck-preserve-box-in-discr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -17,13 +17,14 @@ pub fn main() {\n     match x {\n       @F {f: ref b_x} => {\n         assert!(**b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) == ptr::addr_of(&(**b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) == ptr::to_unsafe_ptr(&(**b_x)));\n \n         x = @F {f: ~4};\n \n-        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(&(**b_x)) as uint);\n+        debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n+               ptr::to_unsafe_ptr(&(**b_x)) as uint);\n         assert!(**b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) != ptr::addr_of(&(**b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(**b_x)));\n       }\n     }\n }"}, {"sha": "3c95054d10c9358f65ea0aca7653a3f616214383", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -23,11 +23,12 @@ pub fn main() {\n     let mut x = @F {f: ~3};\n     do borrow(x.f) |b_x| {\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) == ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) == ptr::to_unsafe_ptr(&(*b_x)));\n         x = @F {f: ~4};\n \n-        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(&(*b_x)) as uint);\n+        debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n+               ptr::to_unsafe_ptr(&(*b_x)) as uint);\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) != ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(*b_x)));\n     }\n }"}, {"sha": "ad0c5b69ba849b3669cdbaf25d8b8a3fba3b32fd", "filename": "src/test/run-pass/borrowck-preserve-box-in-pat.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -17,13 +17,14 @@ pub fn main() {\n     match x {\n       @@F{f: ref b_x} => {\n         assert!(**b_x == 3);\n-        assert!(ptr::addr_of(&(x.f)) == ptr::addr_of(b_x));\n+        assert!(ptr::to_unsafe_ptr(&(x.f)) == ptr::to_unsafe_ptr(b_x));\n \n         *x = @F {f: ~4};\n \n-        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(&(**b_x)) as uint);\n+        debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n+               ptr::to_unsafe_ptr(&(**b_x)) as uint);\n         assert!(**b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) != ptr::addr_of(&(**b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(**b_x)));\n       }\n     }\n }"}, {"sha": "cce08ab235613fc014e7180375c3955879867329", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -23,11 +23,12 @@ pub fn main() {\n     let mut x = ~@F{f: ~3};\n     do borrow(x.f) |b_x| {\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) == ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) == ptr::to_unsafe_ptr(&(*b_x)));\n         *x = @F{f: ~4};\n \n-        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(&(*b_x)) as uint);\n+        debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n+               ptr::to_unsafe_ptr(&(*b_x)) as uint);\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) != ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(*b_x)));\n     }\n }"}, {"sha": "104b0ae6bc551103311de1638cbf1a5db3efb9d0", "filename": "src/test/run-pass/borrowck-preserve-box.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -21,11 +21,12 @@ pub fn main() {\n     let mut x = @3;\n     do borrow(x) |b_x| {\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x)) == ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x)) == ptr::to_unsafe_ptr(&(*b_x)));\n         x = @22;\n \n-        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(&(*b_x)) as uint);\n+        debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n+               ptr::to_unsafe_ptr(&(*b_x)) as uint);\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x)) != ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x)) != ptr::to_unsafe_ptr(&(*b_x)));\n     }\n }"}, {"sha": "4c5b9f9bf1f82f8481eb70c657642e7e96eef7d6", "filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -23,11 +23,12 @@ pub fn main() {\n     let mut x = @F {f: ~3};\n     do borrow((*x).f) |b_x| {\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) == ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) == ptr::to_unsafe_ptr(&(*b_x)));\n         x = @F {f: ~4};\n \n-        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(&(*b_x)) as uint);\n+        debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n+               ptr::to_unsafe_ptr(&(*b_x)) as uint);\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) != ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(*b_x)));\n     }\n }"}, {"sha": "5d20990a5a93b3b1f0ddc2e1fb6555bf61a86e5f", "filename": "src/test/run-pass/cap-clause-move.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -10,22 +10,22 @@\n \n pub fn main() {\n     let x = ~1;\n-    let y = ptr::addr_of(&(*x)) as uint;\n-    let lam_move: @fn() -> uint = || ptr::addr_of(&(*x)) as uint;\n+    let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n+    let lam_move: @fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n     assert!(lam_move() == y);\n \n     let x = ~2;\n-    let y = ptr::addr_of(&(*x)) as uint;\n-    let lam_move: @fn() -> uint = || ptr::addr_of(&(*x)) as uint;\n+    let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n+    let lam_move: @fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n     assert!(lam_move() == y);\n \n     let x = ~3;\n-    let y = ptr::addr_of(&(*x)) as uint;\n-    let snd_move: ~fn() -> uint = || ptr::addr_of(&(*x)) as uint;\n+    let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n+    let snd_move: ~fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n     assert!(snd_move() == y);\n \n     let x = ~4;\n-    let y = ptr::addr_of(&(*x)) as uint;\n-    let lam_move: ~fn() -> uint = || ptr::addr_of(&(*x)) as uint;\n+    let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n+    let lam_move: ~fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n     assert!(lam_move() == y);\n }"}, {"sha": "cb713adcb28fccd6bdb180bc6db12895a2bb35a2", "filename": "src/test/run-pass/cci_iter_exe.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -11,15 +11,13 @@\n // xfail-fast - check-fast doesn't understand aux-build\n // aux-build:cci_iter_lib.rs\n \n-#[legacy_modes];\n-\n extern mod cci_iter_lib;\n \n pub fn main() {\n     //let bt0 = sys::rusti::frame_address(1u32);\n     //debug!(\"%?\", bt0);\n     do cci_iter_lib::iter(~[1, 2, 3]) |i| {\n-        io::print(fmt!(\"%d\", i));\n+        io::print(fmt!(\"%d\", *i));\n         //assert!(bt0 == sys::rusti::frame_address(2u32));\n     }\n }"}, {"sha": "847d8a4d1f90e40c5cbd0d902b6db4534991f8bf", "filename": "src/test/run-pass/cci_nested_exe.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -16,14 +16,14 @@ use cci_nested_lib::*;\n \n pub fn main() {\n     let lst = new_int_alist();\n-    alist_add(lst, 22, ~\"hi\");\n-    alist_add(lst, 44, ~\"ho\");\n-    assert!(alist_get(lst, 22) == ~\"hi\");\n-    assert!(alist_get(lst, 44) == ~\"ho\");\n+    alist_add(&lst, 22, ~\"hi\");\n+    alist_add(&lst, 44, ~\"ho\");\n+    assert!(alist_get(&lst, 22) == ~\"hi\");\n+    assert!(alist_get(&lst, 44) == ~\"ho\");\n \n     let lst = new_int_alist_2();\n-    alist_add(lst, 22, ~\"hi\");\n-    alist_add(lst, 44, ~\"ho\");\n-    assert!(alist_get(lst, 22) == ~\"hi\");\n-    assert!(alist_get(lst, 44) == ~\"ho\");\n+    alist_add(&lst, 22, ~\"hi\");\n+    alist_add(&lst, 44, ~\"ho\");\n+    assert!(alist_get(&lst, 22) == ~\"hi\");\n+    assert!(alist_get(&lst, 44) == ~\"ho\");\n }"}, {"sha": "1c0a09d52cfc81c75d74c524c92b9116ad554b1e", "filename": "src/test/run-pass/class-implement-traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // xfail-fast\n-#[legacy_modes];\n \n trait noisy {\n   fn speak(&mut self);\n@@ -66,6 +65,7 @@ pub fn main() {\n   let mut nyan = cat(0u, 2, ~\"nyan\");\n   nyan.eat();\n   assert!((!nyan.eat()));\n-  for uint::range(1u, 10u) |_i| { make_speak(nyan); };\n-  assert!((nyan.eat()));\n+  for uint::range(1u, 10u) |_i| {\n+    make_speak(copy nyan);\n+  }\n }"}, {"sha": "b8812649fd1c1884bd9dd5dd6d387dc4c34bca35", "filename": "src/test/run-pass/const-region-ptrs-noncopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -14,5 +14,5 @@ static x: &'static Big = &([13, 14, 10, 13, 11, 14, 14, 15]);\n static y: &'static Pair<'static> = &Pair {a: 15, b: x};\n \n pub fn main() {\n-    assert!(ptr::addr_of(x) == ptr::addr_of(y.b));\n+    assert!(ptr::to_unsafe_ptr(x) == ptr::to_unsafe_ptr(y.b));\n }"}, {"sha": "cf92515e01028f455fa1bdf9f3062eaac976ce2a", "filename": "src/test/run-pass/enum-alignment.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-alignment.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -9,12 +9,15 @@\n // except according to those terms.\n \n fn addr_of<T>(ptr: &T) -> uint {\n-    let ptr = ptr::addr_of(ptr);\n+    let ptr = ptr::to_unsafe_ptr(ptr);\n     unsafe { ptr as uint }\n }\n \n fn is_aligned<T>(ptr: &T) -> bool {\n-    (addr_of(ptr) % sys::min_align_of::<T>()) == 0\n+    unsafe {\n+        let addr: uint = ::cast::transmute(ptr);\n+        (addr % sys::min_align_of::<T>()) == 0\n+    }\n }\n \n pub fn main() {"}, {"sha": "5d26fbdd78933109a446183c5e5bed2017318c18", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -10,7 +10,6 @@\n // except according to those terms.\n \n // xfail-fast\n-#[legacy_modes];\n \n type compare<T> = @fn(T, T) -> bool;\n \n@@ -20,7 +19,7 @@ fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n }\n \n fn test_vec() {\n-    fn compare_vec(&&v1: @int, &&v2: @int) -> bool { return v1 == v2; }\n+    fn compare_vec(v1: @int, v2: @int) -> bool { return v1 == v2; }\n     test_generic::<@int>(@1, compare_vec);\n }\n "}, {"sha": "0d70bff3649730fa75703e60da46c53ce13eeaa4", "filename": "src/test/run-pass/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -10,7 +10,6 @@\n \n // xfail-fast\n // -*- rust -*-\n-#[legacy_modes];\n \n type compare<T> = @fn(T, T) -> bool;\n \n@@ -20,7 +19,7 @@ fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n }\n \n fn test_vec() {\n-    fn compare_vec(&&v1: ~int, &&v2: ~int) -> bool { return v1 == v2; }\n+    fn compare_vec(v1: ~int, v2: ~int) -> bool { return v1 == v2; }\n     test_generic::<~int>(~1, compare_vec);\n }\n "}, {"sha": "12193037e119252818df3938eb484ea4c1f76e78", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -10,7 +10,6 @@\n \n // xfail-fast\n // -*- rust -*-\n-#[legacy_modes];\n \n type compare<T> = @fn(T, T) -> bool;\n \n@@ -20,7 +19,7 @@ fn test_generic<T:Copy>(expected: T, not_expected: T, eq: compare<T>) {\n }\n \n fn test_vec() {\n-    fn compare_box(&&v1: @int, &&v2: @int) -> bool { return v1 == v2; }\n+    fn compare_box(v1: @int, v2: @int) -> bool { return v1 == v2; }\n     test_generic::<@int>(@1, @2, compare_box);\n }\n "}, {"sha": "70898d2db9375e184de692e0f645236a24d4e531", "filename": "src/test/run-pass/intrinsic-frame-address.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // xfail-fast\n-#[legacy_modes];\n \n mod rusti {\n     #[abi = \"rust-intrinsic\"]"}, {"sha": "d63e01ec396078af040907e635377206ea8f8d4b", "filename": "src/test/run-pass/issue-2214.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2214.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -16,7 +16,7 @@ use core::f64::*;\n \n fn to_c_int(v: &mut int) -> &mut c_int {\n     unsafe {\n-        cast::reinterpret_cast(&v)\n+        cast::transmute_copy(&v)\n     }\n }\n "}, {"sha": "98965cb6d9102437a9e666cad3c035e78866f4bf", "filename": "src/test/run-pass/issue-2216.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fissue-2216.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fissue-2216.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2216.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -11,17 +11,17 @@\n pub fn main() {\n     let mut x = 0;\n     \n-    loop foo: {\n-        loop bar: {\n-            loop quux: {\n+    'foo: loop {\n+        'bar: loop {\n+            'quux: loop {\n                 if 1 == 2 {\n-                    break foo;\n+                    break 'foo;\n                 }\n                 else {\n-                    break bar;\n+                    break 'bar;\n                 }\n             }\n-            loop foo;\n+            loop 'foo;\n         }\n         x = 42;\n         break;"}, {"sha": "f54d3d39831f4e797c3549c6f7c88b2de789768c", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -232,7 +232,7 @@ pub mod pingpong {\n     pub fn liberate_ping(+p: ping) -> ::pipes::send_packet<pong> {\n         unsafe {\n             let addr : *::pipes::send_packet<pong> = match &p {\n-              &ping(ref x) => { cast::transmute(ptr::addr_of(x)) }\n+              &ping(ref x) => { cast::transmute(x) }\n             };\n             let liberated_value = *addr;\n             cast::forget(p);\n@@ -243,7 +243,7 @@ pub mod pingpong {\n     pub fn liberate_pong(+p: pong) -> ::pipes::send_packet<ping> {\n         unsafe {\n             let addr : *::pipes::send_packet<ping> = match &p {\n-              &pong(ref x) => { cast::transmute(ptr::addr_of(x)) }\n+              &pong(ref x) => { cast::transmute(x) }\n             };\n             let liberated_value = *addr;\n             cast::forget(p);"}, {"sha": "06ca401a136e7477d3ef564a7a279dbe49a944d8", "filename": "src/test/run-pass/labeled-break.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Flabeled-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Flabeled-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flabeled-break.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -12,9 +12,9 @@\n // xfail-test\n \n pub fn main() {\n-    loop foo: {\n+    'foo: loop {\n         loop {\n-            break foo;\n+            break 'foo;\n         }\n     }\n }"}, {"sha": "c4ce1434165e36b098f68e15d1c4e00754c3329f", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -45,7 +45,7 @@ proto! bank (\n )\n \n macro_rules! move_it (\n-    { $x:expr } => { unsafe { let y = *ptr::addr_of(&($x)); y } }\n+    { $x:expr } => { unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } }\n )\n \n fn switch<T:Owned,U>(+endp: pipes::RecvPacket<T>,"}, {"sha": "6d82663d19560942d206957abc5522224216339c", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -40,7 +40,7 @@ mod pingpong {\n         do pipes::entangle_buffer(buffer) |buffer, data| {\n             data.ping.set_buffer(buffer);\n             data.pong.set_buffer(buffer);\n-            ptr::addr_of(&(data.ping))\n+            ptr::to_unsafe_ptr(&(data.ping))\n         }\n     }\n     pub struct ping(server::pong);\n@@ -53,8 +53,8 @@ mod pingpong {\n         pub fn ping(+pipe: ping) -> pong {\n             {\n                 let b = pipe.reuse_buffer();\n-                let s = SendPacketBuffered(ptr::addr_of(&(b.buffer.data.pong)));\n-                let c = RecvPacketBuffered(ptr::addr_of(&(b.buffer.data.pong)));\n+                let s = SendPacketBuffered(&b.buffer.data.pong);\n+                let c = RecvPacketBuffered(&b.buffer.data.pong);\n                 let message = ::pingpong::ping(s);\n                 send(pipe, message);\n                 c\n@@ -75,8 +75,8 @@ mod pingpong {\n         pub fn pong(+pipe: pong) -> ping {\n             {\n                 let b = pipe.reuse_buffer();\n-                let s = SendPacketBuffered(ptr::addr_of(&(b.buffer.data.ping)));\n-                let c = RecvPacketBuffered(ptr::addr_of(&(b.buffer.data.ping)));\n+                let s = SendPacketBuffered(&b.buffer.data.ping);\n+                let c = RecvPacketBuffered(&b.buffer.data.ping);\n                 let message = ::pingpong::pong(s);\n                 send(pipe, message);\n                 c"}, {"sha": "e520d221c9935888053ed2a912f86ba4f6846444", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -642,7 +642,7 @@ struct Triple { x: int, y: int, z: int }\n pub fn main() {\n     unsafe {\n         let r = (1,2,3,true,false, Triple {x:5,y:4,z:3}, (12,));\n-        let p = ptr::addr_of(&r) as *c_void;\n+        let p = ptr::to_unsafe_ptr(&r) as *c_void;\n         let u = my_visitor(@mut Stuff {ptr1: p,\n                                        ptr2: p,\n                                        vals: ~[]});"}, {"sha": "c46e41ab0eb1c9e96747550252217daecf716cee", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -25,8 +25,8 @@ struct Ccx {\n \n fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n-        return cast::reinterpret_cast(\n-            &libc::malloc(sys::size_of::<Bcx<'blk>>() as libc::size_t));\n+        cast::transmute(libc::malloc(sys::size_of::<Bcx<'blk>>()\n+            as libc::size_t))\n     }\n }\n \n@@ -38,7 +38,7 @@ fn g(fcx : &Fcx) {\n     let bcx = Bcx { fcx: fcx };\n     let bcx2 = h(&bcx);\n     unsafe {\n-        libc::free(cast::reinterpret_cast(&bcx2));\n+        libc::free(cast::transmute(bcx2));\n     }\n }\n "}, {"sha": "fdb8c2a496c6b6be368602372cb716b9cde16d37", "filename": "src/test/run-pass/resource-cycle.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -18,10 +18,10 @@ impl Drop for r {\n     fn finalize(&self) {\n         unsafe {\n             debug!(\"r's dtor: self = %x, self.v = %x, self.v's value = %x\",\n-              cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(self)),\n-              cast::reinterpret_cast::<**int, uint>(&ptr::addr_of(&(self.v))),\n-              cast::reinterpret_cast::<*int, uint>(&self.v));\n-            let v2: ~int = cast::reinterpret_cast(&self.v);\n+              cast::transmute::<*r, uint>(self),\n+              cast::transmute::<**int, uint>(&(self.v)),\n+              cast::transmute::<*int, uint>(self.v));\n+            let v2: ~int = cast::transmute(self.v);\n         }\n     }\n }\n@@ -44,38 +44,36 @@ struct Node {\n pub fn main() {\n     unsafe {\n         let i1 = ~0;\n-        let i1p = cast::reinterpret_cast(&i1);\n+        let i1p = cast::transmute_copy(&i1);\n         cast::forget(i1);\n         let i2 = ~0;\n-        let i2p = cast::reinterpret_cast(&i2);\n+        let i2p = cast::transmute_copy(&i2);\n         cast::forget(i2);\n \n         let mut x1 = @mut t(Node{\n             next: None,\n               r: {\n               let rs = r(i1p);\n-              debug!(\"r = %x\",\n-                     cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&rs)));\n+              debug!(\"r = %x\", cast::transmute::<*r, uint>(&rs));\n               rs }\n         });\n         \n         debug!(\"x1 = %x, x1.r = %x\",\n-            cast::reinterpret_cast::<@mut t, uint>(&x1),\n-            cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&(x1.r))));\n+               cast::transmute::<@mut t, uint>(x1),\n+               cast::transmute::<*r, uint>(&x1.r));\n \n         let mut x2 = @mut t(Node{\n             next: None,\n               r: {\n               let rs = r(i2p);\n-              debug!(\"r2 = %x\",\n-                     cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&rs)));\n+              debug!(\"r2 = %x\", cast::transmute::<*r, uint>(&rs));\n               rs\n                 }\n         });\n         \n         debug!(\"x2 = %x, x2.r = %x\",\n-               cast::reinterpret_cast::<@mut t, uint>(&x2),\n-               cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&(x2.r))));\n+               cast::transmute::<@mut t, uint>(x2),\n+               cast::transmute::<*r, uint>(&(x2.r)));\n \n         x1.next = Some(x2);\n         x2.next = Some(x1);"}, {"sha": "2a59d4d2190d18d27d88c87fe110a2995a41dbda", "filename": "src/test/run-pass/resource-cycle2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -23,7 +23,7 @@ struct r {\n impl Drop for r {\n     fn finalize(&self) {\n         unsafe {\n-            let v2: ~int = cast::reinterpret_cast(&self.v.c);\n+            let v2: ~int = cast::transmute(self.v.c);\n         }\n     }\n }\n@@ -44,10 +44,10 @@ struct Node {\n pub fn main() {\n     unsafe {\n         let i1 = ~0xA;\n-        let i1p = cast::reinterpret_cast(&i1);\n+        let i1p = cast::transmute_copy(&i1);\n         cast::forget(i1);\n         let i2 = ~0xA;\n-        let i2p = cast::reinterpret_cast(&i2);\n+        let i2p = cast::transmute_copy(&i2);\n         cast::forget(i2);\n \n         let u1 = U {a: 0xB, b: 0xC, c: i1p};"}, {"sha": "0d699a6e49b6c284b1036dca494c44169700e50b", "filename": "src/test/run-pass/resource-cycle3.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -27,8 +27,8 @@ struct R {\n impl Drop for R {\n     fn finalize(&self) {\n         unsafe {\n-            let _v2: ~int = cast::reinterpret_cast(&self.v.c);\n-            // let _v3: ~int = unsafe::reinterpret_cast(self.x);\n+            let _v2: ~int = cast::transmute(self.v.c);\n+            // let _v3: ~int = cast::transmute_copy(self.x);\n         }\n     }\n }\n@@ -38,7 +38,7 @@ fn r(v: U, w: int, _x: *int) -> R {\n         R {\n             v: v,\n             w: w,\n-            x: cast::reinterpret_cast(&0)\n+            x: cast::transmute(0)\n         }\n     }\n }\n@@ -53,10 +53,10 @@ struct Node {\n pub fn main() { \n     unsafe {\n         let i1 = ~0xA;\n-        let i1p = cast::reinterpret_cast(&i1);\n+        let i1p = cast::transmute_copy(&i1);\n         cast::forget(i1);\n         let i2 = ~0xA;\n-        let i2p = cast::reinterpret_cast(&i2);\n+        let i2p = cast::transmute_copy(&i2);\n         cast::forget(i2);\n \n         let u1 = U {a: 0xB, b: 0xC, c: i1p};"}, {"sha": "e7dd240eb184ce70efee03daa0a7abf113b00ce4", "filename": "src/test/run-pass/rt-sched-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-sched-1.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -48,7 +48,7 @@ pub fn main() {\n                 ch.send(());\n             }\n         };\n-        let fptr = cast::reinterpret_cast(&ptr::addr_of(&f));\n+        let fptr = cast::transmute(&f);\n         rustrt::start_task(new_task_id, fptr);\n         cast::forget(f);\n         po.recv();"}, {"sha": "afed0bd9ac3f809f50ce72130722d78ae1dec31d", "filename": "src/test/run-pass/sendfn-spawn-with-fn-arg.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::cell::Cell;\n+\n pub fn main() { test05(); }\n \n fn test05_start(&&f: ~fn(int)) {\n@@ -20,7 +22,8 @@ fn test05() {\n         error!(*three + n); // will copy x into the closure\n         assert!((*three == 3));\n     };\n+    let fn_to_send = Cell(fn_to_send);\n     task::spawn(|| {\n-        test05_start(fn_to_send);\n+        test05_start(fn_to_send.take());\n     });\n }"}, {"sha": "3731f41f8f81cba22ea42858d13ebf2d5abe09bd", "filename": "src/test/run-pass/stable-addr-of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -12,5 +12,5 @@\n \n pub fn main() {\n     let foo = 1;\n-    assert!(ptr::addr_of(&foo) == ptr::addr_of(&foo));\n+    assert!(ptr::to_unsafe_ptr(&foo) == ptr::to_unsafe_ptr(&foo));\n }"}, {"sha": "973897cd1452126aad3e613cb31c94f659301923", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // xfail-fast\n-#[legacy_modes];\n \n // A trait for objects that can be used to do an if-then-else\n // (No actual need for this to be static, but it is a simple test.)\n@@ -59,10 +58,10 @@ fn build<A, B: buildable<A>>(builder: &fn(push: &fn(+v: A))) -> B {\n \n /// Apply a function to each element of an iterable and return the results\n fn map<T, IT: BaseIter<T>, U, BU: buildable<U>>\n-    (v: IT, f: &fn(T) -> U) -> BU {\n+    (v: IT, f: &fn(&T) -> U) -> BU {\n     do build |push| {\n         for v.each() |elem| {\n-            push(f(*elem));\n+            push(f(elem));\n         }\n     }\n }\n@@ -79,9 +78,9 @@ pub fn main() {\n     let v: @[int] = seq_range(0, 10);\n     assert!(v == @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n \n-    let v: @[int] = map(&[1,2,3], |x| 1+x);\n+    let v: @[int] = map(&[1,2,3], |&x| 1+x);\n     assert!(v == @[2, 3, 4]);\n-    let v: ~[int] = map(&[1,2,3], |x| 1+x);\n+    let v: ~[int] = map(&[1,2,3], |&x| 1+x);\n     assert!(v == ~[2, 3, 4]);\n \n     assert!(bool_like::select(true, 9, 14) == 9);"}, {"sha": "a9c59de49eeaa8c7b947ff39f663223b447b3bf9", "filename": "src/test/run-pass/tag-align-dyn-u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -24,7 +24,7 @@ fn mk_rec() -> t_rec {\n }\n \n fn is_8_byte_aligned(&&u: a_tag<u64>) -> bool {\n-    let p = ptr::addr_of(u) as uint;\n+    let p = ptr::to_unsafe_ptr(u) as uint;\n     return (p & 7u) == 0u;\n }\n "}, {"sha": "4fc6410f8f3d04553d6f8f75d120624d69958c02", "filename": "src/test/run-pass/tag-align-dyn-variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftag-align-dyn-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftag-align-dyn-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-dyn-variants.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -27,7 +27,7 @@ fn mk_rec<A:copy,B:copy>(a: A, b: B) -> t_rec<A,B> {\n }\n \n fn is_aligned<A>(amnt: uint, &&u: A) -> bool {\n-    let p = ptr::addr_of(u) as uint;\n+    let p = ptr::to_unsafe_ptr(u) as uint;\n     return (p & (amnt-1u)) == 0u;\n }\n "}, {"sha": "fd96d7d0242c3c92343fa9afc62d87f67c2fc36c", "filename": "src/test/run-pass/tag-align-u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -24,7 +24,7 @@ fn mk_rec() -> t_rec {\n }\n \n fn is_8_byte_aligned(&&u: a_tag) -> bool {\n-    let p = ptr::addr_of(u) as u64;\n+    let p = ptr::to_unsafe_ptr(u) as u64;\n     return (p & 7u64) == 0u64;\n }\n "}, {"sha": "0806f1ea92aecd0c930406a43f21519ca8caefcc", "filename": "src/test/run-pass/tag-variant-disr-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -38,7 +38,7 @@ pub fn main() {\n }\n \n fn test_color(color: color, val: int, name: ~str) {\n-    //assert!(unsafe::reinterpret_cast(color) == val);\n+    //assert!(unsafe::transmute(color) == val);\n     assert!(color as int == val);\n     assert!(color as float == val as float);\n     assert!(get_color_alt(color) == name);"}, {"sha": "6fc29fa32db32a333250079e4d686cc76fabf6a4", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // xfail-fast\n-#[legacy_modes];\n \n extern mod std;\n \n@@ -18,7 +17,7 @@ use core::comm::Port;\n \n pub fn main() { test05(); }\n \n-fn test05_start(ch : Chan<int>) {\n+fn test05_start(ch : &Chan<int>) {\n     ch.send(10);\n     error!(\"sent 10\");\n     ch.send(20);\n@@ -29,8 +28,8 @@ fn test05_start(ch : Chan<int>) {\n \n fn test05() {\n     let (po, ch) = comm::stream();\n-    task::spawn(|| test05_start(ch) );\n-    let mut value = po.recv();\n+    task::spawn(|| test05_start(&ch) );\n+    let mut value: int = po.recv();\n     error!(value);\n     value = po.recv();\n     error!(value);"}, {"sha": "f22328a3e1b32fb469d78ecab7ead9c84ca4ac7d", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -9,18 +9,17 @@\n // except according to those terms.\n \n // xfail-fast\n-#[legacy_modes];\n \n extern mod std;\n \n-fn start(c: comm::Chan<int>, start: int, number_of_messages: int) {\n+fn start(c: &comm::Chan<int>, start: int, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(start + i); i += 1; }\n }\n \n pub fn main() {\n     debug!(\"Check that we don't deadlock.\");\n     let (p, ch) = comm::stream();\n-    task::try(|| start(ch, 0, 10) );\n+    task::try(|| start(&ch, 0, 10) );\n     debug!(\"Joined task\");\n }"}, {"sha": "12f9a113dfc3ec0832cd9c1e58ea53543d60961e", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -9,13 +9,12 @@\n // except according to those terms.\n \n // xfail-fast\n-#[legacy_modes];\n \n extern mod std;\n \n pub fn main() { test00(); }\n \n-fn test00_start(c: comm::Chan<int>, start: int, number_of_messages: int) {\n+fn test00_start(c: &comm::Chan<int>, start: int, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(start + i); i += 1; }\n }\n@@ -28,19 +27,19 @@ fn test00() {\n \n     let c = p.chan();\n     do task::spawn || {\n-        test00_start(c, number_of_messages * 0, number_of_messages);\n+        test00_start(&c, number_of_messages * 0, number_of_messages);\n     }\n     let c = p.chan();\n     do task::spawn || {\n-        test00_start(c, number_of_messages * 1, number_of_messages);\n+        test00_start(&c, number_of_messages * 1, number_of_messages);\n     }\n     let c = p.chan();\n     do task::spawn || {\n-        test00_start(c, number_of_messages * 2, number_of_messages);\n+        test00_start(&c, number_of_messages * 2, number_of_messages);\n     }\n     let c = p.chan();\n     do task::spawn || {\n-        test00_start(c, number_of_messages * 3, number_of_messages);\n+        test00_start(&c, number_of_messages * 3, number_of_messages);\n     }\n \n     let mut i: int = 0;"}, {"sha": "7cd08695da0f04ba082e4359f7604f6993470881", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -26,7 +26,7 @@ impl Drop for notify {\n         unsafe {\n             error!(\"notify: task=%? v=%x unwinding=%b b=%b\",\n                    task::get_task(),\n-                   ptr::addr_of(&(*(self.v))) as uint,\n+                   ptr::to_unsafe_ptr(&(*(self.v))) as uint,\n                    task::failing(),\n                    *(self.v));\n             let b = *(self.v);\n@@ -47,7 +47,7 @@ fn joinable(f: ~fn()) -> Port<bool> {\n         let b = @mut false;\n         error!(\"wrapper: task=%? allocated v=%x\",\n                task::get_task(),\n-               ptr::addr_of(&(*b)) as uint);\n+               ptr::to_unsafe_ptr(&(*b)) as uint);\n         let _r = notify(c, b);\n         f();\n         *b = true;"}, {"sha": "ba10bfb670452c5aa8f6c39829c6410393d843b9", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -14,10 +14,10 @@ pub fn main() {\n     let (p, ch) = stream::<uint>();\n \n     let x = ~1;\n-    let x_in_parent = ptr::addr_of(&(*x)) as uint;\n+    let x_in_parent = ptr::to_unsafe_ptr(&(*x)) as uint;\n \n     task::spawn(|| {\n-        let x_in_child = ptr::addr_of(&(*x)) as uint;\n+        let x_in_child = ptr::to_unsafe_ptr(&(*x)) as uint;\n         ch.send(x_in_child);\n     });\n "}, {"sha": "820d42ab14d572783c860e788dcd343b04065e19", "filename": "src/test/run-pass/unify-return-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funify-return-ty.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -15,7 +15,7 @@ extern mod std;\n \n fn null<T>() -> *T {\n     unsafe {\n-        cast::reinterpret_cast(&0)\n+        cast::transmute(0)\n     }\n }\n "}, {"sha": "7327f4a3498e0c17be8fe8f73ff9f492ba8a0f4a", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb8d5cc66941763039d3f727465b7cc34a100/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=f1ddb8d5cc66941763039d3f727465b7cc34a100", "patch": "@@ -19,7 +19,7 @@ struct Pointy {\n }\n \n fn make_uniq_closure<A:Owned + Copy>(a: A) -> ~fn() -> uint {\n-    let result: ~fn() -> uint = || ptr::addr_of(&a) as uint;\n+    let result: ~fn() -> uint = || ptr::to_unsafe_ptr(&a) as uint;\n     result\n }\n "}]}