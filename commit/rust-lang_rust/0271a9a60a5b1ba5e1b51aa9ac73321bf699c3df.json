{"sha": "0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNzFhOWE2MGE1YjFiYTVlMWI1MWFhOWFjNzMzMjFiZjY5OWMzZGY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-10-17T14:14:25Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-10-17T14:14:25Z"}, "message": "Fix Subst construction: use subst from adt_def rather than Drop impl's subst.\n\nThis addresses issue pointed out by niko that prior code would break\nif the declaration order for generics does not match how they are fed\ninto the instantiation of the type itself. (Added some tests\nexercising this scenario.)", "tree": {"sha": "d830d1b814319ef8cecd56770332379e672a8dc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d830d1b814319ef8cecd56770332379e672a8dc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df", "html_url": "https://github.com/rust-lang/rust/commit/0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c239fee2b60c756f88e5dd7abdb945de5b699bea", "url": "https://api.github.com/repos/rust-lang/rust/commits/c239fee2b60c756f88e5dd7abdb945de5b699bea", "html_url": "https://github.com/rust-lang/rust/commit/c239fee2b60c756f88e5dd7abdb945de5b699bea"}], "stats": {"total": 260, "additions": 247, "deletions": 13}, "files": [{"sha": "7a22ef3c81edcc3803ed19acfd23bd8b809a25cb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df", "patch": "@@ -742,6 +742,14 @@ impl<'tcx> Generics<'tcx> {\n     pub fn count(&self) -> usize {\n         self.parent_count() + self.own_count()\n     }\n+\n+    pub fn region_param(&self, param: &EarlyBoundRegion) -> &RegionParameterDef<'tcx> {\n+        &self.regions[param.index as usize - self.has_self as usize]\n+    }\n+\n+    pub fn type_param(&self, param: &ParamTy) -> &TypeParameterDef<'tcx> {\n+        &self.types[param.idx as usize - self.has_self as usize - self.regions.len()]\n+    }\n }\n \n /// Bounds on generics."}, {"sha": "607b32fd14021ce34ae24f936953e0bc8055d2e8", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 77, "deletions": 13, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df", "patch": "@@ -556,20 +556,10 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             } else {\n                 return DropckKind::BorrowedDataMustStrictlyOutliveSelf;\n             };\n+\n             let method = tcx.impl_or_trait_item(dtor_method);\n-            let substs = Substs::for_item(tcx,\n-                                          method.container().id(),\n-                                          |def, _| if def.pure_wrt_drop {\n-                                              tcx.mk_region(ty::ReStatic)\n-                                          } else {\n-                                              substs.region_for_def(def)\n-                                          },\n-                                          |def, _| if def.pure_wrt_drop {\n-                                              tcx.mk_nil()\n-                                          } else {\n-                                              substs.type_for_def(def)\n-                                          });\n-            let revised_ty = tcx.mk_adt(adt_def, &substs);\n+            let impl_id: DefId = method.container().id();\n+            let revised_ty = revise_self_ty(tcx, adt_def, impl_id, substs);\n             return DropckKind::RevisedSelf(revised_ty);\n         }\n         ty::TyTrait(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n@@ -581,3 +571,77 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         }\n     }\n }\n+\n+// Constructs new Ty just like the type defined by `adt_def` coupled\n+// with `substs`, except each type and lifetime parameter marked as\n+// `#[may_dangle]` in the Drop impl (identified by `impl_id`) is\n+// respectively mapped to `()` or `'static`.\n+//\n+// For example: If the `adt_def` maps to:\n+//\n+//   enum Foo<'a, X, Y> { ... }\n+//\n+// and the `impl_id` maps to:\n+//\n+//   impl<#[may_dangle] 'a, X, #[may_dangle] Y> Drop for Foo<'a, X, Y> { ... }\n+//\n+// then revises input: `Foo<'r,i64,&'r i64>` to: `Foo<'static,i64,()>`\n+fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                  adt_def: ty::AdtDef<'tcx>,\n+                                  impl_id: DefId,\n+                                  substs: &Substs<'tcx>) -> Ty<'tcx> {\n+    // Get generics for `impl Drop` to query for `#[may_dangle]` attr.\n+    let impl_bindings = tcx.lookup_generics(impl_id);\n+\n+    // Get Substs attached to Self on `impl Drop`; process in parallel\n+    // with `substs`, replacing dangling entries as appropriate.\n+    let self_substs = {\n+        let impl_self_ty: Ty<'tcx> = tcx.lookup_item_type(impl_id).ty;\n+        if let ty::TyAdt(self_adt_def, self_substs) = impl_self_ty.sty {\n+            assert_eq!(adt_def, self_adt_def);\n+            self_substs\n+        } else {\n+            bug!(\"Self in `impl Drop for _` must be an Adt.\");\n+        }\n+    };\n+\n+    // Walk `substs` + `self_substs`, build new substs appropriate for\n+    // `adt_def`; each non-dangling param reuses entry from `substs`.\n+    let substs = Substs::for_item(\n+        tcx,\n+        adt_def.did,\n+        |def, _| {\n+            let r_orig = substs.region_for_def(def);\n+            let impl_self_orig = self_substs.region_for_def(def);\n+            let r = if let ty::Region::ReEarlyBound(ref ebr) = *impl_self_orig {\n+                if impl_bindings.region_param(ebr).pure_wrt_drop {\n+                    tcx.mk_region(ty::ReStatic)\n+                } else {\n+                    r_orig\n+                }\n+            } else {\n+                bug!(\"substs for an impl must map regions to ReEarlyBound\");\n+            };\n+            debug!(\"has_dtor_of_interest mapping def {:?} orig {:?} to {:?}\",\n+                   def, r_orig, r);\n+            r\n+        },\n+        |def, _| {\n+            let t_orig = substs.type_for_def(def);\n+            let impl_self_orig = self_substs.type_for_def(def);\n+            let t = if let ty::TypeVariants::TyParam(ref pt) = impl_self_orig.sty {\n+                if impl_bindings.type_param(pt).pure_wrt_drop {\n+                    tcx.mk_nil()\n+                } else {\n+                    t_orig\n+                }\n+            } else {\n+                bug!(\"substs for an impl must map types to TyParam\");\n+            };\n+            debug!(\"has_dtor_of_interest mapping def {:?} orig {:?} {:?} to {:?} {:?}\",\n+                   def, t_orig, t_orig.sty, t, t.sty);\n+            t\n+        });\n+\n+    return tcx.mk_adt(adt_def, &substs);\n+}"}, {"sha": "68b0ff3b5f096f76672d3f57e439a56732f73cbc", "filename": "src/test/compile-fail/dropck-eyepatch-reorder.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df/src%2Ftest%2Fcompile-fail%2Fdropck-eyepatch-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df/src%2Ftest%2Fcompile-fail%2Fdropck-eyepatch-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck-eyepatch-reorder.rs?ref=0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to test uses of `#[may_dangle]` attribute\n+// where the formal declaration order (in the impl generics) does not\n+// match the actual usage order (in the type instantiation).\n+//\n+// See also dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+use std::fmt;\n+\n+struct Dt<A: fmt::Debug>(&'static str, A);\n+struct Dr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+struct Pt<A: fmt::Debug, B: fmt::Debug>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+fmt::Debug>(&'static str, &'a B, &'b B);\n+struct St<A: fmt::Debug>(&'static str, A);\n+struct Sr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+\n+impl<A: fmt::Debug> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<'a, B: fmt::Debug> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+unsafe impl<B: fmt::Debug, #[may_dangle] A: fmt::Debug> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+unsafe impl<'b, #[may_dangle] 'a, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+\n+fn main() {\n+    use std::cell::Cell;\n+    let c_long;\n+    let (c, mut dt, mut dr, mut pt, mut pr, st, sr)\n+        : (Cell<_>, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = Cell::new(1);\n+    c = Cell::new(1);\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long);\n+    dr = Dr(\"dr\", &c_long);\n+    // Error: destructor order imprecisely modelled\n+    dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+    dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c, &c_long);\n+    pr = Pr(\"pr\", &c, &c_long);\n+\n+    // Error: Drop impl's assertion does not apply to `B` nor `&'b _`\n+    pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+    pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c);\n+    sr = Sr(\"sr\", &c);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+}"}, {"sha": "bbf8bb8c352389f2c246b5ea44b3c0f7c5930645", "filename": "src/test/run-pass/dropck-eyepatch-reorder.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-reorder.rs?ref=0271a9a60a5b1ba5e1b51aa9ac73321bf699c3df", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to test uses of `#[may_dangle]` attribute\n+// where the formal declaration order (in the impl generics) does not\n+// match the actual usage order (in the type instantiation).\n+//\n+// See also dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+trait Foo { fn foo(&self, _: &str); }\n+\n+struct Dt<A: Foo>(&'static str, A);\n+struct Dr<'a, B:'a+Foo>(&'static str, &'a B);\n+struct Pt<A: Foo, B: Foo>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+Foo>(&'static str, &'a B, &'b B);\n+struct St<A: Foo>(&'static str, A);\n+struct Sr<'a, B:'a+Foo>(&'static str, &'a B);\n+\n+impl<A: Foo> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+impl<'a, B: Foo> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+unsafe impl<B: Foo, #[may_dangle] A: Foo> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+unsafe impl<'b, #[may_dangle] 'a, B: Foo> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+\n+fn main() {\n+    use std::cell::RefCell;\n+\n+    impl Foo for RefCell<String> {\n+        fn foo(&self, s: &str) {\n+            let s2 = format!(\"{}|{}\", *self.borrow(), s);\n+            *self.borrow_mut() = s2;\n+        }\n+    }\n+\n+    impl<'a, T:Foo> Foo for &'a T {\n+        fn foo(&self, s: &str) {\n+            (*self).foo(s);\n+        }\n+    }\n+\n+    struct CheckOnDrop(RefCell<String>, &'static str);\n+    impl Drop for CheckOnDrop {\n+        fn drop(&mut self) { assert_eq!(*self.0.borrow(), self.1); }\n+    }\n+\n+    let c_long;\n+    let (c, dt, dr, pt, pr, st, sr)\n+        : (CheckOnDrop, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = CheckOnDrop(RefCell::new(\"c_long\".to_string()),\n+                         \"c_long|pr|pt|dr|dt\");\n+    c = CheckOnDrop(RefCell::new(\"c\".to_string()),\n+                    \"c\");\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long.0);\n+    dr = Dr(\"dr\", &c_long.0);\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c.0, &c_long.0);\n+    pr = Pr(\"pr\", &c.0, &c_long.0);\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c.0);\n+    sr = Sr(\"sr\", &c.0);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+    assert_eq!(*c_long.0.borrow(), \"c_long\");\n+    assert_eq!(*c.0.borrow(), \"c\");\n+}"}]}