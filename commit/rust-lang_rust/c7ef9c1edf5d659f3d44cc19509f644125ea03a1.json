{"sha": "c7ef9c1edf5d659f3d44cc19509f644125ea03a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZWY5YzFlZGY1ZDY1OWYzZDQ0Y2MxOTUwOWY2NDQxMjVlYTAzYTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-11T02:44:14Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-27T14:40:45Z"}, "message": "Fix two type inference failures uncovered by japaric corresponding to\nUFCS form. In both cases the problems came about because we were\nfailing to process pending trait obligations. So change code to\nprocess pending trait obligations before coercions to ensure maximum\ntype information is available (and also adjust shift to do something\nsimilar).\n\nFixes #21245.", "tree": {"sha": "6abd51ae137be261b407d528a60203790f12de1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6abd51ae137be261b407d528a60203790f12de1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7ef9c1edf5d659f3d44cc19509f644125ea03a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ef9c1edf5d659f3d44cc19509f644125ea03a1", "html_url": "https://github.com/rust-lang/rust/commit/c7ef9c1edf5d659f3d44cc19509f644125ea03a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7ef9c1edf5d659f3d44cc19509f644125ea03a1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60db57e7eccf292064c1fc47b426e9df1a7332aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/60db57e7eccf292064c1fc47b426e9df1a7332aa", "html_url": "https://github.com/rust-lang/rust/commit/60db57e7eccf292064c1fc47b426e9df1a7332aa"}], "stats": {"total": 165, "additions": 145, "deletions": 20}, "files": [{"sha": "8188835718cd61456f7db35c5148b43dc8b7fc81", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7ef9c1edf5d659f3d44cc19509f644125ea03a1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ef9c1edf5d659f3d44cc19509f644125ea03a1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c7ef9c1edf5d659f3d44cc19509f644125ea03a1", "patch": "@@ -60,7 +60,8 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n     debug!(\"demand::coerce(expected = {}, expr_ty = {})\",\n            expected.repr(fcx.ccx.tcx),\n            expr_ty.repr(fcx.ccx.tcx));\n-    let expected = fcx.infcx().resolve_type_vars_if_possible(&expected);\n+    let expr_ty = fcx.resolve_type_vars_if_possible(expr_ty);\n+    let expected = fcx.resolve_type_vars_if_possible(expected);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       Ok(()) => { /* ok */ }\n       Err(ref err) => {"}, {"sha": "4e23106c1c50595d9235430eae0fb7d2ab668408", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c7ef9c1edf5d659f3d44cc19509f644125ea03a1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ef9c1edf5d659f3d44cc19509f644125ea03a1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c7ef9c1edf5d659f3d44cc19509f644125ea03a1", "patch": "@@ -1231,6 +1231,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n+    /// Resolves type variables in `ty` if possible. Unlike the infcx\n+    /// version, this version will also select obligations if it seems\n+    /// useful, in an effort to get more type information.\n+    fn resolve_type_vars_if_possible(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+        // No ty::infer()? Nothing needs doing.\n+        if !ty::type_has_ty_infer(ty) {\n+            return ty;\n+        }\n+\n+        // If `ty` is a type variable, see whether we already know what it is.\n+        ty = self.infcx().resolve_type_vars_if_possible(&ty);\n+        if !ty::type_has_ty_infer(ty) {\n+            return ty;\n+        }\n+\n+        // If not, try resolving any new fcx obligations that have cropped up.\n+        vtable::select_new_fcx_obligations(self);\n+        ty = self.infcx().resolve_type_vars_if_possible(&ty);\n+        if !ty::type_has_ty_infer(ty) {\n+            return ty;\n+        }\n+\n+        // If not, try resolving *all* pending obligations as much as\n+        // possible. This can help substantially when there are\n+        // indirect dependencies that don't seem worth tracking\n+        // precisely.\n+        vtable::select_fcx_obligations_where_possible(self);\n+        self.infcx().resolve_type_vars_if_possible(&ty)\n+    }\n+\n     /// Resolves all type variables in `t` and then, if any were left\n     /// unresolved, substitutes an error type. This is used after the\n     /// main checking when doing a second pass before writeback. The\n@@ -2321,9 +2351,9 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let check_blocks = *check_blocks;\n         debug!(\"check_blocks={}\", check_blocks);\n \n-        // More awful hacks: before we check the blocks, try to do\n-        // an \"opportunistic\" vtable resolution of any trait\n-        // bounds on the call.\n+        // More awful hacks: before we check argument types, try to do\n+        // an \"opportunistic\" vtable resolution of any trait bounds on\n+        // the call. This helps coercions.\n         if check_blocks {\n             vtable::select_new_fcx_obligations(fcx);\n         }\n@@ -2863,7 +2893,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n             check_expr(fcx, &**rhs);\n             let rhs_ty = fcx.expr_ty(&**rhs);\n-            let rhs_ty = fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n+            let rhs_ty = structurally_resolved_type(fcx, rhs.span, rhs_ty);\n             if ty::type_is_integral(rhs_ty) {\n                 fcx.write_ty(expr.id, lhs_t);\n             } else {\n@@ -5115,21 +5145,12 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                                            mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-    // If `ty` is a type variable, see whether we already know what it is.\n-    ty = fcx.infcx().shallow_resolve(ty);\n-\n-    // If not, try resolve pending fcx obligations. Those can shed light.\n-    //\n-    // FIXME(#18391) -- This current strategy can lead to bad performance in\n-    // extreme cases.  We probably ought to smarter in general about\n-    // only resolving when we need help and only resolving obligations\n-    // will actually help.\n-    if ty::type_is_ty_var(ty) {\n-        vtable::select_fcx_obligations_where_possible(fcx);\n-        ty = fcx.infcx().shallow_resolve(ty);\n-    }\n+pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                            sp: Span,\n+                                            ty: Ty<'tcx>)\n+                                            -> Ty<'tcx>\n+{\n+    let mut ty = fcx.resolve_type_vars_if_possible(ty);\n \n     // If not, error.\n     if ty::type_is_ty_var(ty) {"}, {"sha": "26a0abc76aee2a668fa4d38e4a801e2fdcc2adf2", "filename": "src/test/run-pass/into-iterator-type-inference-shift.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c7ef9c1edf5d659f3d44cc19509f644125ea03a1/src%2Ftest%2Frun-pass%2Finto-iterator-type-inference-shift.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ef9c1edf5d659f3d44cc19509f644125ea03a1/src%2Ftest%2Frun-pass%2Finto-iterator-type-inference-shift.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finto-iterator-type-inference-shift.rs?ref=c7ef9c1edf5d659f3d44cc19509f644125ea03a1", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for type inference failure around shifting. In this\n+// case, the iteration yields an int, but we hadn't run the full type\n+// propagation yet, and so we just saw a type variable, yielding an\n+// error.\n+\n+use std::u8;\n+\n+trait IntoIterator {\n+    type Iter: Iterator;\n+\n+    fn into_iter(self) -> Self::Iter;\n+}\n+\n+impl<I> IntoIterator for I where I: Iterator {\n+    type Iter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n+fn desugared_for_loop_bad(byte: u8) -> u8 {\n+    let mut result = 0;\n+    let mut x = IntoIterator::into_iter(range(0, u8::BITS));\n+    let mut y = Iterator::next(&mut x);\n+    let mut z = y.unwrap();\n+    byte >> z;\n+    1\n+}\n+\n+fn main() {}"}, {"sha": "1ed939cbacafb6e9189920813cf6d8662746054d", "filename": "src/test/run-pass/issue-21245.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c7ef9c1edf5d659f3d44cc19509f644125ea03a1/src%2Ftest%2Frun-pass%2Fissue-21245.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ef9c1edf5d659f3d44cc19509f644125ea03a1/src%2Ftest%2Frun-pass%2Fissue-21245.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21245.rs?ref=c7ef9c1edf5d659f3d44cc19509f644125ea03a1", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #21245. Check that we are able to infer\n+// the types in these examples correctly. It used to be that\n+// insufficient type propagation caused the type of the iterator to be\n+// incorrectly unified with the `*const` type to which it is coerced.\n+\n+use std::ptr;\n+\n+trait IntoIterator {\n+    type Iter: Iterator;\n+\n+    fn into_iter(self) -> Self::Iter;\n+}\n+\n+impl<I> IntoIterator for I where I: Iterator {\n+    type Iter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n+fn desugared_for_loop_bad<T>(v: Vec<T>) {\n+    match IntoIterator::into_iter(v.iter()) {\n+        mut iter => {\n+            loop {\n+                match ::std::iter::Iterator::next(&mut iter) {\n+                    ::std::option::Option::Some(x) => {\n+                        unsafe { ptr::read(x); }\n+                    },\n+                    ::std::option::Option::None => break\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn desugared_for_loop_good<T>(v: Vec<T>) {\n+    match v.iter().into_iter() {  // NB method call instead of UFCS\n+        mut iter => {\n+            loop {\n+                match ::std::iter::Iterator::next(&mut iter) {\n+                    ::std::option::Option::Some(x) => {\n+                        unsafe { ptr::read(x); }\n+                    },\n+                    ::std::option::Option::None => break\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn main() {}"}]}