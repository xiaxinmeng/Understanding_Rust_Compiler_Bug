{"sha": "f6090909d3e7654b9244fff937d78e3e17b5f3e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MDkwOTA5ZDNlNzY1NGI5MjQ0ZmZmOTM3ZDc4ZTNlMTdiNWYzZTI=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-12T19:56:27Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-13T04:34:08Z"}, "message": "new lint: using `for i in 0..x { .. vec[i] .. }` instead of iterator (fixes #3)", "tree": {"sha": "084a732525cc179c2cbb57856a4bd625116a6c0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/084a732525cc179c2cbb57856a4bd625116a6c0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6090909d3e7654b9244fff937d78e3e17b5f3e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6090909d3e7654b9244fff937d78e3e17b5f3e2", "html_url": "https://github.com/rust-lang/rust/commit/f6090909d3e7654b9244fff937d78e3e17b5f3e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6090909d3e7654b9244fff937d78e3e17b5f3e2/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4400aaed4363e7955f4d45770c4add7b147c1022", "url": "https://api.github.com/repos/rust-lang/rust/commits/4400aaed4363e7955f4d45770c4add7b147c1022", "html_url": "https://github.com/rust-lang/rust/commit/4400aaed4363e7955f4d45770c4add7b147c1022"}], "stats": {"total": 125, "additions": 125, "deletions": 0}, "files": [{"sha": "33ce163a32674c8aa314bb4fdb7f03d5d8433bc2", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6090909d3e7654b9244fff937d78e3e17b5f3e2/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6090909d3e7654b9244fff937d78e3e17b5f3e2/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f6090909d3e7654b9244fff937d78e3e17b5f3e2", "patch": "@@ -32,6 +32,7 @@ pub mod unicode;\n pub mod strings;\n pub mod methods;\n pub mod returns;\n+pub mod loops;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n@@ -59,6 +60,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box returns::ReturnPass as LintPassObject);\n     reg.register_lint_pass(box methods::MethodsPass as LintPassObject);\n     reg.register_lint_pass(box types::LetPass as LintPassObject);\n+    reg.register_lint_pass(box loops::LoopsPass as LintPassObject);\n \n     reg.register_lint_group(\"clippy\", vec![types::BOX_VEC, types::LINKEDLIST,\n                                            misc::SINGLE_MATCH,\n@@ -87,5 +89,6 @@ pub fn plugin_registrar(reg: &mut Registry) {\n                                            methods::STR_TO_STRING,\n                                            methods::STRING_TO_STRING,\n                                            types::LET_UNIT_VALUE,\n+                                           loops::NEEDLESS_RANGE_LOOP,\n                                            ]);\n }"}, {"sha": "83d7ca4eccb33dc31a8669622eb0a1487aa48dea", "filename": "src/loops.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f6090909d3e7654b9244fff937d78e3e17b5f3e2/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6090909d3e7654b9244fff937d78e3e17b5f3e2/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=f6090909d3e7654b9244fff937d78e3e17b5f3e2", "patch": "@@ -0,0 +1,105 @@\n+use rustc::lint::*;\n+use syntax::ast::*;\n+use syntax::visit::{Visitor, walk_expr};\n+use std::collections::HashSet;\n+\n+use utils::{span_lint, get_parent_expr};\n+\n+declare_lint!{ pub NEEDLESS_RANGE_LOOP, Warn,\n+               \"Warn about looping over a range of indices if a normal iterator would do\" }\n+\n+#[derive(Copy, Clone)]\n+pub struct LoopsPass;\n+\n+impl LintPass for LoopsPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NEEDLESS_RANGE_LOOP)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n+        if let Some((pat, arg, body)) = recover_for_loop(expr) {\n+            // the var must be a single name\n+            if let PatIdent(_, ref ident, _) = pat.node {\n+                // the iteratee must be a range literal\n+                if let ExprRange(_, _) = arg.node {\n+                    let mut visitor = VarVisitor { cx: cx, var: ident.node.name,\n+                                                   indexed: HashSet::new(), nonindex: false };\n+                    walk_expr(&mut visitor, body);\n+                    // linting condition: we only indexed one variable\n+                    if visitor.indexed.len() == 1 {\n+                        let indexed = visitor.indexed.into_iter().next().unwrap();\n+                        if visitor.nonindex {\n+                            span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n+                                \"the loop variable `{}` is used to index `{}`. Consider using \\\n+                                 `for ({}, item) in {}.iter().enumerate()` or similar iterators.\",\n+                                ident.node.name.as_str(), indexed.as_str(),\n+                                ident.node.name.as_str(), indexed.as_str()));\n+                        } else {\n+                            span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n+                                \"the loop variable `{}` is only used to index `{}`. \\\n+                                 Consider using `for item in &{}` or similar iterators.\",\n+                                ident.node.name.as_str(), indexed.as_str(), indexed.as_str()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Recover the essential nodes of a desugared for loop:\n+/// `for pat in arg { body }` becomes `(pat, arg, body)`.\n+fn recover_for_loop<'a>(expr: &'a Expr) -> Option<(&'a Pat, &'a Expr, &'a Expr)> {\n+    if_let_chain! {\n+        [\n+            let ExprMatch(ref iterexpr, ref arms, _) = expr.node,\n+            let ExprCall(_, ref iterargs) = iterexpr.node,\n+            iterargs.len() == 1,\n+            arms.len() == 1 && arms[0].guard.is_none(),\n+            let ExprLoop(ref block, _) = arms[0].body.node,\n+            block.stmts.is_empty(),\n+            let Some(ref loopexpr) = block.expr,\n+            let ExprMatch(_, ref innerarms, MatchSource::ForLoopDesugar) = loopexpr.node,\n+            innerarms.len() == 2 && innerarms[0].pats.len() == 1,\n+            let PatEnum(_, Some(ref somepats)) = innerarms[0].pats[0].node,\n+            somepats.len() == 1\n+        ], {\n+            return Some((&*somepats[0],\n+                         &*iterargs[0],\n+                         &*innerarms[0].body));\n+        }\n+    }\n+    None\n+}\n+\n+struct VarVisitor<'v, 't: 'v> {\n+    cx: &'v Context<'v, 't>, // context reference\n+    var: Name,               // var name to look for as index\n+    indexed: HashSet<Name>,  // indexed variables\n+    nonindex: bool,          // has the var been used otherwise?\n+}\n+\n+impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n+    fn visit_expr(&mut self, expr: &'v Expr) {\n+        if let ExprPath(None, ref path) = expr.node {\n+            if path.segments.len() == 1 && path.segments[0].identifier.name == self.var {\n+                // we are referencing our variable! now check if it's as an index\n+                if_let_chain! {\n+                    [\n+                        let Some(parexpr) = get_parent_expr(self.cx, expr),\n+                        let ExprIndex(ref seqexpr, _) = parexpr.node,\n+                        let ExprPath(None, ref seqvar) = seqexpr.node,\n+                        seqvar.segments.len() == 1\n+                    ], {\n+                        self.indexed.insert(seqvar.segments[0].identifier.name);\n+                        return;  // no need to walk further\n+                    }\n+                }\n+                // we are not indexing anything, record that\n+                self.nonindex = true;\n+                return;\n+            }\n+        }\n+        walk_expr(self, expr);\n+    }\n+}"}, {"sha": "318e6fc85887f2b4f10ade9ee36eaf73808a91e4", "filename": "tests/compile-fail/for_loop.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f6090909d3e7654b9244fff937d78e3e17b5f3e2/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6090909d3e7654b9244fff937d78e3e17b5f3e2/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=f6090909d3e7654b9244fff937d78e3e17b5f3e2", "patch": "@@ -0,0 +1,17 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#[deny(needless_range_loop)]\n+fn main() {\n+    let vec = vec![1, 2, 3, 4];\n+    let vec2 = vec![1, 2, 3, 4];\n+    for i in 0..vec.len() {      //~ERROR the loop variable `i` is only used to index `vec`.\n+        println!(\"{}\", vec[i]);\n+    }\n+    for i in 0..vec.len() {      //~ERROR the loop variable `i` is used to index `vec`.\n+        println!(\"{} {}\", vec[i], i);\n+    }\n+    for i in 0..vec.len() {      // not an error, indexing more than one variable\n+        println!(\"{} {}\", vec[i], vec2[i]);\n+    }\n+}"}]}