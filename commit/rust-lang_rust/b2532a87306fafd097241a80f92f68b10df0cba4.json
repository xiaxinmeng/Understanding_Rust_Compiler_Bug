{"sha": "b2532a87306fafd097241a80f92f68b10df0cba4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNTMyYTg3MzA2ZmFmZDA5NzI0MWE4MGY5MmY2OGIxMGRmMGNiYTQ=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-07-01T13:10:51Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-09-20T11:28:18Z"}, "message": "Implement destructuring for all aggregates and for references", "tree": {"sha": "b21ca24c3adb20104af88245bf2c155ea143072e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b21ca24c3adb20104af88245bf2c155ea143072e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2532a87306fafd097241a80f92f68b10df0cba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2532a87306fafd097241a80f92f68b10df0cba4", "html_url": "https://github.com/rust-lang/rust/commit/b2532a87306fafd097241a80f92f68b10df0cba4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2532a87306fafd097241a80f92f68b10df0cba4/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34c62e0abc82b7302a3b0ee16dfe445e1330ce4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/34c62e0abc82b7302a3b0ee16dfe445e1330ce4c", "html_url": "https://github.com/rust-lang/rust/commit/34c62e0abc82b7302a3b0ee16dfe445e1330ce4c"}], "stats": {"total": 427, "additions": 312, "deletions": 115}, "files": [{"sha": "978d2fe000468bc81535b66543a42eb1a3b50da2", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -93,8 +93,7 @@ pub(crate) fn deref_const<'tcx>(\n         MemPlaceMeta::None => mplace.layout.ty,\n         MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_const`: {:#?}\", mplace),\n         // In case of unsized types, figure out the real type behind.\n-        MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind {\n-            ty::Dynamic(..) => ecx.read_drop_type_from_vtable(scalar).unwrap().1,\n+        MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n             ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n             ty::Slice(elem_ty) => tcx.mk_array(elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n             _ => bug!("}, {"sha": "796815cf2168c9f98d5398f7768f7a288c604445", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -409,7 +409,40 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let deref_ty = match *ty.kind() {\n             ty::Ref(_, deref_ty, _) => deref_ty,\n-            _ => bug!(\"non_scalar_compare called on non-reference type: {}\", ty),\n+            _ => {\n+                trace!(\"non_scalar_compare called on non-reference type: {}\", ty);\n+                // Backcompat hack: due to non-structural matches not being a hard error, we can\n+                // reach this for types that have manual `Eq` or `PartialEq` impls.\n+                assert!(!ty.is_structural_eq_shallow(self.hir.tcx()));\n+                let ref_ty = self.hir.tcx().mk_imm_ref(self.hir.tcx().lifetimes.re_erased, ty);\n+                // let y = &place;\n+                let y = self.temp(ref_ty, source_info.span);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    y,\n+                    Rvalue::Ref(self.hir.tcx().lifetimes.re_erased, BorrowKind::Shared, place),\n+                );\n+                val = Operand::Move(y);\n+                // let temp = expect;\n+                let temp = self.temp(ty, source_info.span);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    temp,\n+                    Rvalue::Use(expect),\n+                );\n+                // reftemp = &temp;\n+                let reftemp = self.temp(ref_ty, source_info.span);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    reftemp,\n+                    Rvalue::Ref(self.hir.tcx().lifetimes.re_erased, BorrowKind::Shared, temp),\n+                );\n+                expect = Operand::Move(reftemp);\n+                ty\n+            },\n         };\n \n         let eq_def_id = self.hir.tcx().require_lang_item(LangItem::PartialEq, None);"}, {"sha": "d47c3e7e3aba1c1534d46dd1269f00db0e3e239c", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 84, "deletions": 26, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -28,10 +28,13 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n         debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n \n-        self.tcx.infer_ctxt().enter(|infcx| {\n+        let pat = self.tcx.infer_ctxt().enter(|infcx| {\n             let mut convert = ConstToPat::new(self, id, span, infcx);\n             convert.to_pat(cv, mir_structural_match_violation)\n-        })\n+        });\n+\n+        debug!(\"const_to_pat: pat={:?}\", pat);\n+        pat\n     }\n }\n \n@@ -45,6 +48,10 @@ struct ConstToPat<'a, 'tcx> {\n     // value.\n     saw_const_match_error: Cell<bool>,\n \n+    // For backcompat we need to keep allowing non-structurally-eq types behind references.\n+    // See also all the `cant-hide-behind` tests.\n+    behind_reference: Cell<bool>,\n+\n     // inference context used for checking `T: Structural` bounds.\n     infcx: InferCtxt<'a, 'tcx>,\n \n@@ -65,6 +72,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             param_env: pat_ctxt.param_env,\n             include_lint_checks: pat_ctxt.include_lint_checks,\n             saw_const_match_error: Cell::new(false),\n+            behind_reference: Cell::new(false),\n         }\n     }\n \n@@ -233,7 +241,18 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n                 PatKind::Wild\n             }\n-            // keep old code until future-compat upgraded to errors.\n+            // If the type is not structurally comparable, just emit the constant directly,\n+            // causing the pattern match code to treat it opaquely.\n+            // FIXME: This code doesn't emit errors itself, the caller emits the errors.\n+            // So instead of specific errors, you just get blanket errors about the whole\n+            // const type. See\n+            // https://github.com/rust-lang/rust/pull/70743#discussion_r404701963 for\n+            // details.\n+            // Backwards compatibility hack because we can't cause hard errors on these\n+            // types, so we compare them via `PartialEq::eq` at runtime.\n+            ty::Adt(..) if !self.type_marked_structural(cv.ty) && self.behind_reference.get() => {\n+                PatKind::Constant { value: cv }\n+            }\n             ty::Adt(adt_def, _) if !self.type_marked_structural(cv.ty) => {\n                 debug!(\"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\", adt_def, cv.ty);\n                 let path = tcx.def_path_str(adt_def.did);\n@@ -246,28 +265,6 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 tcx.sess.span_err(span, &msg);\n                 PatKind::Wild\n             }\n-            // keep old code until future-compat upgraded to errors.\n-            ty::Ref(_, adt_ty, _) if adt_ty.is_adt() && !self.type_marked_structural(adt_ty) => {\n-                let adt_def =\n-                    if let ty::Adt(adt_def, _) = adt_ty.kind() { adt_def } else { unreachable!() };\n-\n-                debug!(\n-                    \"adt_def {:?} has !type_marked_structural for adt_ty: {:?}\",\n-                    adt_def, adt_ty\n-                );\n-\n-                // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n-                // would be wrong. Returnging `PatKind::Wild` is not technically correct.\n-                let path = tcx.def_path_str(adt_def.did);\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path, path,\n-                );\n-                self.saw_const_match_error.set(true);\n-                tcx.sess.span_err(span, &msg);\n-                PatKind::Wild\n-            }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                 let destructured = tcx.destructure_const(param_env.and(cv));\n                 PatKind::Variant {\n@@ -293,7 +290,68 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 slice: None,\n                 suffix: Vec::new(),\n             },\n-            _ => PatKind::Constant { value: cv },\n+            ty::Ref(_, pointee_ty, ..) => match *pointee_ty.kind() {\n+                // These are not allowed and will error elsewhere anyway.\n+                ty::Dynamic(..) => PatKind::Constant { value: cv },\n+                // `&str` and `&[u8]` are represented as `ConstValue::Slice`, let's keep using this\n+                // optimization for now.\n+                ty::Str => PatKind::Constant { value: cv },\n+                ty::Slice(elem_ty) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n+                // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n+                // matching against references, you can only use byte string literals.\n+                // FIXME: clean this up, likely by permitting array patterns when matching on slices\n+                ty::Array(elem_ty, _) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n+                // Cannot merge this with the catch all branch below, because the `const_deref`\n+                // changes the type from slice to array, and slice patterns behave differently from\n+                // array patterns.\n+                ty::Slice(..) => {\n+                    let old = self.behind_reference.replace(true);\n+                    let array = tcx.deref_const(self.param_env.and(cv));\n+                    let val = PatKind::Deref {\n+                        subpattern: Pat {\n+                            kind: Box::new(PatKind::Slice {\n+                                prefix: tcx\n+                                    .destructure_const(param_env.and(array))\n+                                    .fields\n+                                    .iter()\n+                                    .map(|val| self.recur(val))\n+                                    .collect(),\n+                                slice: None,\n+                                suffix: vec![],\n+                            }),\n+                            span,\n+                            ty: pointee_ty,\n+                        },\n+                    };\n+                    self.behind_reference.set(old);\n+                    val\n+                }\n+                // Backwards compatibility hack. Don't take away the reference, since\n+                // `PartialEq::eq` takes a reference, this makes the rest of the matching logic\n+                // simpler.\n+                ty::Adt(..) if !self.type_marked_structural(pointee_ty) => {\n+                    PatKind::Constant { value: cv }\n+                }\n+                _ => {\n+                    let old = self.behind_reference.replace(true);\n+                    let val = PatKind::Deref {\n+                        subpattern: self.recur(tcx.deref_const(self.param_env.and(cv))),\n+                    };\n+                    self.behind_reference.set(old);\n+                    val\n+                }\n+            },\n+            ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::FnDef(..) => {\n+                PatKind::Constant { value: cv }\n+            }\n+            // FIXME: these can have very suprising behaviour where optimization levels or other\n+            // compilation choices change the runtime behaviour of the match.\n+            // See https://github.com/rust-lang/rust/issues/70861 for examples.\n+            ty::FnPtr(..) | ty::RawPtr(..) => PatKind::Constant { value: cv },\n+            _ => {\n+                tcx.sess.delay_span_bug(span, &format!(\"cannot make a pattern out of {}\", cv.ty));\n+                PatKind::Wild\n+            }\n         };\n \n         Pat { span, ty: cv.ty, kind: Box::new(kind) }"}, {"sha": "2663f682a1de82ab490e61e70bedf21c5ced597d", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -94,7 +94,7 @@ pub struct OsString {\n // `OsStr::from_inner` current implementation relies\n // on `OsStr` being layout-compatible with `Slice`.\n // When attribute privacy is implemented, `OsStr` should be annotated as `#[repr(transparent)]`.\n-// Anyway, `OsStr` representation and layout are considered implementation detail, are\n+// Anyway, `OsStr` representation and layout are considered implementation details, are\n // not documented and must not be relied upon.\n pub struct OsStr {\n     inner: Slice,"}, {"sha": "0295204c879ca8d12c1863b8c94c3140c8264e97", "filename": "src/test/ui/consts/consts-in-patterns.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fconsts%2Fconsts-in-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fconsts%2Fconsts-in-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconsts-in-patterns.rs?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -19,8 +19,6 @@ pub fn main() {\n     assert_eq!(y, 2);\n     let z = match &() {\n         ZST => 9,\n-        // FIXME: this should not be required\n-        _ => 42,\n     };\n     assert_eq!(z, 9);\n     let z = match b\"\" {"}, {"sha": "008c03ecddcc6f775e73377d13a12086188d10cd", "filename": "src/test/ui/consts/match_ice.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.rs?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -10,10 +10,9 @@ fn main() {\n     match C {\n         C => {}\n         //~^ ERROR to use a constant of type `S` in a pattern, `S` must be annotated with\n-        //~| ERROR to use a constant of type `S` in a pattern, `S` must be annotated with\n     }\n     const K: &T = &T;\n-    match K { //~ ERROR non-exhaustive patterns: `&T` not covered\n+    match K {\n         K => {}\n     }\n }"}, {"sha": "699b4a5e200e41311cfaabfdde075b812b89098e", "filename": "src/test/ui/consts/match_ice.stderr", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -4,24 +4,5 @@ error: to use a constant of type `S` in a pattern, `S` must be annotated with `#\n LL |         C => {}\n    |         ^\n \n-error[E0004]: non-exhaustive patterns: `&T` not covered\n-  --> $DIR/match_ice.rs:16:11\n-   |\n-LL | struct T;\n-   | --------- `T` defined here\n-...\n-LL |     match K {\n-   |           ^ pattern `&T` not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `&T`\n-\n-error: to use a constant of type `S` in a pattern, `S` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/match_ice.rs:11:9\n-   |\n-LL |         C => {}\n-   |         ^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0004`."}, {"sha": "caa6d184a92ddc2aeff326180a93585798bce045", "filename": "src/test/ui/match/pattern-deref-miscompile.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fmatch%2Fpattern-deref-miscompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fmatch%2Fpattern-deref-miscompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fpattern-deref-miscompile.rs?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -0,0 +1,46 @@\n+// run-pass\n+\n+fn main() {\n+    match b\".\" as &[u8] {\n+        b\".\" if true => {},\n+        b\".\" => panic!(),\n+        b\"..\" => panic!(),\n+        b\"\" => panic!(),\n+        _ => panic!(),\n+    }\n+    match b\".\" as &[u8] {\n+        b\".\" if false => panic!(),\n+        b\".\" => {},\n+        b\"..\" => panic!(),\n+        b\"\" => panic!(),\n+        _ => panic!(),\n+    }\n+    match b\"..\" as &[u8] {\n+        b\".\" if true => panic!(), // the miscompile caused this arm to be reached\n+        b\".\" => panic!(),\n+        b\"..\" => {},\n+        b\"\" => panic!(),\n+        _ => panic!(),\n+    }\n+    match b\"..\" as &[u8] {\n+        b\".\" if false => panic!(),\n+        b\".\" => panic!(),\n+        b\"..\" => {},\n+        b\"\" => panic!(),\n+        _ => panic!(),\n+    }\n+    match b\"\" as &[u8] {\n+        b\".\" if true => panic!(),\n+        b\".\" => panic!(),\n+        b\"..\" => panic!(),\n+        b\"\" => {},\n+        _ => panic!(),\n+    }\n+    match b\"\" as &[u8] {\n+        b\".\" if false => panic!(),\n+        b\".\" => panic!(),\n+        b\"..\" => panic!(),\n+        b\"\" => {},\n+        _ => panic!(),\n+    }\n+}"}, {"sha": "abfacf3936b6dd61d00415f37fcaa0d74a456769", "filename": "src/test/ui/pattern/const-pat-ice.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.rs?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -1,10 +1,4 @@\n-// failure-status: 101\n-// rustc-env:RUST_BACKTRACE=0\n-// normalize-stderr-test \"note: rustc 1.* running on .*\" -> \"note: rustc VERSION running on TARGET\"\n-// normalize-stderr-test \"note: compiler flags: .*\" -> \"note: compiler flags: FLAGS\"\n-// normalize-stderr-test \"/_match.rs:[0-9]+:[0-9]+\" -> \"/_match.rs:LL:CC\"\n-\n-// This is a repro test for an ICE in our pattern handling of constants.\n+// check-pass\n \n const FOO: &&&u32 = &&&42;\n "}, {"sha": "6b42c0e0848e9538a5efa0992504c96833e003a5", "filename": "src/test/ui/pattern/const-pat-ice.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/34c62e0abc82b7302a3b0ee16dfe445e1330ce4c/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34c62e0abc82b7302a3b0ee16dfe445e1330ce4c/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr?ref=34c62e0abc82b7302a3b0ee16dfe445e1330ce4c", "patch": "@@ -1,13 +0,0 @@\n-thread 'rustc' panicked at 'assertion failed: rows.iter().all(|r| r.len() == v.len())', compiler/rustc_mir_build/src/thir/pattern/_match.rs:LL:CC\n-note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n-\n-error: internal compiler error: unexpected panic\n-\n-note: the compiler unexpectedly panicked. this is a bug.\n-\n-note: we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new?labels=C-bug%2C+I-ICE%2C+T-compiler&template=ice.md\n-\n-note: rustc VERSION running on TARGET\n-\n-note: compiler flags: FLAGS\n-"}, {"sha": "78cc0d28fb0375b56f314e9079ef3815eabde3eb", "filename": "src/test/ui/pattern/usefulness/exhaustive_integer_patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.rs?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -160,7 +160,7 @@ fn main() {\n     match &0 {\n         &42 => {}\n         &FOO => {} //~ ERROR unreachable pattern\n-        BAR => {} // Not detected as unreachable because `try_eval_bits` fails on `BAR`.\n+        BAR => {} //~ ERROR unreachable pattern\n         _ => {}\n     }\n "}, {"sha": "9f076c50a8f09999c167d3aaf5ea37918c39d397", "filename": "src/test/ui/pattern/usefulness/exhaustive_integer_patterns.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -135,6 +135,12 @@ error: unreachable pattern\n LL |         &FOO => {}\n    |         ^^^^\n \n-error: aborting due to 15 previous errors\n+error: unreachable pattern\n+  --> $DIR/exhaustive_integer_patterns.rs:163:9\n+   |\n+LL |         BAR => {}\n+   |         ^^^\n+\n+error: aborting due to 16 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "4bf8d0fd2d306064ca283b6dc13e36c9e800d22a", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.rs?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -6,19 +6,19 @@ fn main() {\n     match s {\n         MAGIC_TEST => (),\n         [0x00, 0x00, 0x00, 0x00] => (),\n-        [4, 5, 6, 7] => (), // FIXME(oli-obk): this should warn, but currently does not\n+        [4, 5, 6, 7] => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     match s {\n         [0x00, 0x00, 0x00, 0x00] => (),\n         MAGIC_TEST => (),\n-        [4, 5, 6, 7] => (), // FIXME(oli-obk): this should warn, but currently does not\n+        [4, 5, 6, 7] => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     match s {\n         [0x00, 0x00, 0x00, 0x00] => (),\n         [4, 5, 6, 7] => (),\n-        MAGIC_TEST => (), // FIXME(oli-obk): this should warn, but currently does not\n+        MAGIC_TEST => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     const FOO: [u32; 1] = [4];"}, {"sha": "dcad11a38a7ebadd8bc0b6350afd8f355a450b1c", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const-2.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.stderr?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -1,14 +1,32 @@\n error: unreachable pattern\n-  --> $DIR/slice-pattern-const-2.rs:28:9\n+  --> $DIR/slice-pattern-const-2.rs:9:9\n    |\n-LL |         FOO => (),\n-   |         ^^^\n+LL |         [4, 5, 6, 7] => (),\n+   |         ^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/slice-pattern-const-2.rs:1:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-2.rs:15:9\n+   |\n+LL |         [4, 5, 6, 7] => (),\n+   |         ^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-2.rs:21:9\n+   |\n+LL |         MAGIC_TEST => (),\n+   |         ^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-2.rs:28:9\n+   |\n+LL |         FOO => (),\n+   |         ^^^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "2ca8323f00295dfb780efa71683b002a5c7c24e8", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.rs?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -6,19 +6,19 @@ fn main() {\n     match s {\n         MAGIC_TEST => (),\n         [\"0x00\", \"0x00\", \"0x00\", \"0x00\"] => (),\n-        [\"4\", \"5\", \"6\", \"7\"] => (), // FIXME(oli-obk): this should warn, but currently does not\n+        [\"4\", \"5\", \"6\", \"7\"] => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     match s {\n         [\"0x00\", \"0x00\", \"0x00\", \"0x00\"] => (),\n         MAGIC_TEST => (),\n-        [\"4\", \"5\", \"6\", \"7\"] => (), // FIXME(oli-obk): this should warn, but currently does not\n+        [\"4\", \"5\", \"6\", \"7\"] => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     match s {\n         [\"0x00\", \"0x00\", \"0x00\", \"0x00\"] => (),\n         [\"4\", \"5\", \"6\", \"7\"] => (),\n-        MAGIC_TEST => (), // FIXME(oli-obk): this should warn, but currently does not\n+        MAGIC_TEST => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     const FOO: [&str; 1] = [\"boo\"];"}, {"sha": "b90b3a88a18602cb72bed06fa7dc92c6fa9f57a1", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const-3.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.stderr?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -1,14 +1,32 @@\n error: unreachable pattern\n-  --> $DIR/slice-pattern-const-3.rs:28:9\n+  --> $DIR/slice-pattern-const-3.rs:9:9\n    |\n-LL |         FOO => (),\n-   |         ^^^\n+LL |         [\"4\", \"5\", \"6\", \"7\"] => (),\n+   |         ^^^^^^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/slice-pattern-const-3.rs:1:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-3.rs:15:9\n+   |\n+LL |         [\"4\", \"5\", \"6\", \"7\"] => (),\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-3.rs:21:9\n+   |\n+LL |         MAGIC_TEST => (),\n+   |         ^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-3.rs:28:9\n+   |\n+LL |         FOO => (),\n+   |         ^^^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "46e0da5be9b4fdf126f3c7041fb16c28b6245568", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.rs", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -6,15 +6,15 @@ fn main() {\n     let s10: &[bool; 10] = &[false; 10];\n \n     match s2 {\n-    //~^ ERROR `&[false, _]` not covered\n+        //~^ ERROR `&[false, _]` not covered\n         [true, .., true] => {}\n     }\n     match s3 {\n-    //~^ ERROR `&[false, ..]` not covered\n+        //~^ ERROR `&[false, ..]` not covered\n         [true, .., true] => {}\n     }\n     match s10 {\n-    //~^ ERROR `&[false, ..]` not covered\n+        //~^ ERROR `&[false, ..]` not covered\n         [true, .., true] => {}\n     }\n \n@@ -23,58 +23,58 @@ fn main() {\n         [.., false] => {}\n     }\n     match s2 {\n-    //~^ ERROR `&[false, true]` not covered\n+        //~^ ERROR `&[false, true]` not covered\n         [true, ..] => {}\n         [.., false] => {}\n     }\n     match s3 {\n-    //~^ ERROR `&[false, .., true]` not covered\n+        //~^ ERROR `&[false, .., true]` not covered\n         [true, ..] => {}\n         [.., false] => {}\n     }\n     match s {\n-    //~^ ERROR `&[false, .., true]` not covered\n+        //~^ ERROR `&[false, .., true]` not covered\n         [] => {}\n         [true, ..] => {}\n         [.., false] => {}\n     }\n \n     match s {\n-    //~^ ERROR `&[_, ..]` not covered\n+        //~^ ERROR `&[_, ..]` not covered\n         [] => {}\n     }\n     match s {\n-    //~^ ERROR `&[_, _, ..]` not covered\n+        //~^ ERROR `&[_, _, ..]` not covered\n         [] => {}\n         [_] => {}\n     }\n     match s {\n-    //~^ ERROR `&[false, ..]` not covered\n+        //~^ ERROR `&[false, ..]` not covered\n         [] => {}\n         [true, ..] => {}\n     }\n     match s {\n-    //~^ ERROR `&[false, _, ..]` not covered\n+        //~^ ERROR `&[false, _, ..]` not covered\n         [] => {}\n         [_] => {}\n         [true, ..] => {}\n     }\n     match s {\n-    //~^ ERROR `&[_, .., false]` not covered\n+        //~^ ERROR `&[_, .., false]` not covered\n         [] => {}\n         [_] => {}\n         [.., true] => {}\n     }\n \n     match s {\n-    //~^ ERROR `&[_, _, .., true]` not covered\n+        //~^ ERROR `&[_, _, .., true]` not covered\n         [] => {}\n         [_] => {}\n         [_, _] => {}\n         [.., false] => {}\n     }\n     match s {\n-    //~^ ERROR `&[true, _, .., _]` not covered\n+        //~^ ERROR `&[true, _, .., _]` not covered\n         [] => {}\n         [_] => {}\n         [_, _] => {}\n@@ -83,19 +83,43 @@ fn main() {\n \n     const CONST: &[bool] = &[true];\n     match s {\n-    //~^ ERROR `&[..]` not covered\n+        //~^ ERROR `&[]` and `&[_, _, ..]` not covered\n+        &[true] => {}\n+    }\n+    match s {\n+        //~^ ERROR `&[]` and `&[_, _, ..]` not covered\n+        CONST => {}\n+    }\n+    match s {\n+        //~^ ERROR `&[]` and `&[_, _, ..]` not covered\n         CONST => {}\n+        &[false] => {}\n     }\n     match s {\n-    //~^ ERROR `&[true]` not covered\n-        [] => {},\n-        [false] => {},\n-        CONST => {},\n+        //~^ ERROR `&[]` and `&[_, _, ..]` not covered\n+        &[false] => {}\n+        CONST => {}\n+    }\n+    match s {\n+        //~^ ERROR `&[_, _, ..]` not covered\n+        &[] => {}\n+        CONST => {}\n+    }\n+    match s {\n+        //~^ ERROR `&[false]` not covered\n+        &[] => {}\n+        CONST => {}\n+        &[_, _, ..] => {}\n+    }\n+    match s {\n+        [] => {}\n+        [false] => {}\n+        CONST => {}\n         [_, _, ..] => {}\n     }\n     const CONST1: &[bool; 1] = &[true];\n     match s1 {\n-    //~^ ERROR `&[false]` not covered\n+        //~^ ERROR `&[false]` not covered\n         CONST1 => {}\n     }\n     match s1 {"}, {"sha": "e34770fb912e79437a0b98a901590bc3eaecacb8", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.stderr", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2532a87306fafd097241a80f92f68b10df0cba4/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr?ref=b2532a87306fafd097241a80f92f68b10df0cba4", "patch": "@@ -115,33 +115,69 @@ LL |     match s {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n \n-error[E0004]: non-exhaustive patterns: `&[..]` not covered\n+error[E0004]: non-exhaustive patterns: `&[]` and `&[_, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:85:11\n    |\n LL |     match s {\n-   |           ^ pattern `&[..]` not covered\n+   |           ^ patterns `&[]` and `&[_, _, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n \n-error[E0004]: non-exhaustive patterns: `&[true]` not covered\n+error[E0004]: non-exhaustive patterns: `&[]` and `&[_, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:89:11\n    |\n LL |     match s {\n-   |           ^ pattern `&[true]` not covered\n+   |           ^ patterns `&[]` and `&[_, _, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n+\n+error[E0004]: non-exhaustive patterns: `&[]` and `&[_, _, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:93:11\n+   |\n+LL |     match s {\n+   |           ^ patterns `&[]` and `&[_, _, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n+\n+error[E0004]: non-exhaustive patterns: `&[]` and `&[_, _, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:98:11\n+   |\n+LL |     match s {\n+   |           ^ patterns `&[]` and `&[_, _, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n+\n+error[E0004]: non-exhaustive patterns: `&[_, _, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:103:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[_, _, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n+\n+error[E0004]: non-exhaustive patterns: `&[false]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:108:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[false]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n \n error[E0004]: non-exhaustive patterns: `&[false]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:97:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:121:11\n    |\n LL |     match s1 {\n    |           ^^ pattern `&[false]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool; 1]`\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 20 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}]}