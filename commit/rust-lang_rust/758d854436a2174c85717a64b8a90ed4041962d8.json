{"sha": "758d854436a2174c85717a64b8a90ed4041962d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1OGQ4NTQ0MzZhMjE3NGM4NTcxN2E2NGI4YTkwZWQ0MDQxOTYyZDg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-30T23:09:41Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-02T22:16:07Z"}, "message": "libsyntax: De-`@mut` `token` in the parser", "tree": {"sha": "9da32c878ac86a17fe537d1402076fe6f1a9da72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9da32c878ac86a17fe537d1402076fe6f1a9da72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/758d854436a2174c85717a64b8a90ed4041962d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/758d854436a2174c85717a64b8a90ed4041962d8", "html_url": "https://github.com/rust-lang/rust/commit/758d854436a2174c85717a64b8a90ed4041962d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/758d854436a2174c85717a64b8a90ed4041962d8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "425a140485dc3ba70c4e30e10cd8d5fd92a458c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/425a140485dc3ba70c4e30e10cd8d5fd92a458c5", "html_url": "https://github.com/rust-lang/rust/commit/425a140485dc3ba70c4e30e10cd8d5fd92a458c5"}], "stats": {"total": 502, "additions": 251, "deletions": 251}, "files": [{"sha": "c4a2f6d48bfe44d50977a54807200fe206ac5e42", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=758d854436a2174c85717a64b8a90ed4041962d8", "patch": "@@ -66,9 +66,9 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                 asm_str_style = Some(style);\n             }\n             Outputs => {\n-                while *p.token != token::EOF &&\n-                      *p.token != token::COLON &&\n-                      *p.token != token::MOD_SEP {\n+                while p.token != token::EOF &&\n+                      p.token != token::COLON &&\n+                      p.token != token::MOD_SEP {\n \n                     if outputs.len() != 0 {\n                         p.eat(&token::COMMA);\n@@ -91,9 +91,9 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                 }\n             }\n             Inputs => {\n-                while *p.token != token::EOF &&\n-                      *p.token != token::COLON &&\n-                      *p.token != token::MOD_SEP {\n+                while p.token != token::EOF &&\n+                      p.token != token::COLON &&\n+                      p.token != token::MOD_SEP {\n \n                     if inputs.len() != 0 {\n                         p.eat(&token::COMMA);\n@@ -116,9 +116,9 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n             }\n             Clobbers => {\n                 let mut clobs = ~[];\n-                while *p.token != token::EOF &&\n-                      *p.token != token::COLON &&\n-                      *p.token != token::MOD_SEP {\n+                while p.token != token::EOF &&\n+                      p.token != token::COLON &&\n+                      p.token != token::MOD_SEP {\n \n                     if clobs.len() != 0 {\n                         p.eat(&token::COMMA);\n@@ -142,16 +142,16 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                     dialect = ast::asm_intel;\n                 }\n \n-                if *p.token == token::COMMA {\n+                if p.token == token::COMMA {\n                     p.eat(&token::COMMA);\n                 }\n             }\n         }\n \n-        while *p.token == token::COLON   ||\n-              *p.token == token::MOD_SEP ||\n-              *p.token == token::EOF {\n-            state = if *p.token == token::COLON {\n+        while p.token == token::COLON   ||\n+              p.token == token::MOD_SEP ||\n+              p.token == token::EOF {\n+            state = if p.token == token::COLON {\n                 p.bump();\n                 match next_state(state) {\n                     Some(x) => x,\n@@ -160,7 +160,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                         break\n                     }\n                 }\n-            } else if *p.token == token::MOD_SEP {\n+            } else if p.token == token::MOD_SEP {\n                 p.bump();\n                 let s = match next_state(state) {\n                     Some(x) => x,\n@@ -176,7 +176,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                         break\n                     }\n                 }\n-            } else if *p.token == token::EOF {\n+            } else if p.token == token::EOF {\n                 continue_ = false;\n                 break;\n             } else {"}, {"sha": "a7a4e6416f9eb57a7e53687ccf1920e05675bc05", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=758d854436a2174c85717a64b8a90ed4041962d8", "patch": "@@ -446,7 +446,7 @@ pub fn get_exprs_from_tts(cx: &ExtCtxt,\n                                            cx.cfg(),\n                                            tts.to_owned());\n     let mut es = ~[];\n-    while *p.token != token::EOF {\n+    while p.token != token::EOF {\n         if es.len() != 0 && !p.eat(&token::COMMA) {\n             cx.span_fatal(sp, \"expected token: `,`\");\n         }"}, {"sha": "f3f44f4fa3f64e78ddedced0a78e6e6ca9525f17", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=758d854436a2174c85717a64b8a90ed4041962d8", "patch": "@@ -32,7 +32,7 @@ pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::\n \n     let mut cfgs = ~[];\n     // parse `cfg!(meta_item, meta_item(x,y), meta_item=\"foo\", ...)`\n-    while *p.token != token::EOF {\n+    while p.token != token::EOF {\n         cfgs.push(p.parse_meta_item());\n         if p.eat(&token::EOF) { break } // trailing comma is optional,.\n         p.expect(&token::COMMA);"}, {"sha": "82f9e138074258e0ae4789e5a9196dd88a4ffc75", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=758d854436a2174c85717a64b8a90ed4041962d8", "patch": "@@ -65,22 +65,22 @@ impl<'a> Context<'a> {\n             return (extra, None);\n         }\n \n-        if *p.token == token::EOF {\n+        if p.token == token::EOF {\n             self.ecx.span_err(sp, \"requires at least a format string argument\");\n             return (extra, None);\n         }\n         let fmtstr = p.parse_expr();\n         let mut named = false;\n-        while *p.token != token::EOF {\n+        while p.token != token::EOF {\n             if !p.eat(&token::COMMA) {\n                 self.ecx.span_err(sp, \"expected token: `,`\");\n                 return (extra, None);\n             }\n-            if *p.token == token::EOF { break } // accept trailing commas\n-            if named || (token::is_ident(p.token) &&\n+            if p.token == token::EOF { break } // accept trailing commas\n+            if named || (token::is_ident(&p.token) &&\n                          p.look_ahead(1, |t| *t == token::EQ)) {\n                 named = true;\n-                let ident = match *p.token {\n+                let ident = match p.token {\n                     token::IDENT(i, _) => {\n                         p.bump();\n                         i"}, {"sha": "4d2923f391e454196b4f28cf04dd64eaa08b1666", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=758d854436a2174c85717a64b8a90ed4041962d8", "patch": "@@ -438,10 +438,12 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> nonterminal {\n       \"expr\" => token::nt_expr(p.parse_expr()),\n       \"ty\" => token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)),\n       // this could be handled like a token, since it is one\n-      \"ident\" => match *p.token {\n+      \"ident\" => match p.token {\n         token::IDENT(sn,b) => { p.bump(); token::nt_ident(~sn,b) }\n-        _ => p.fatal(~\"expected ident, found \"\n-                     + token::to_str(get_ident_interner(), p.token))\n+        _ => {\n+            let token_str = token::to_str(get_ident_interner(), &p.token);\n+            p.fatal(~\"expected ident, found \" + token_str)\n+        }\n       },\n       \"path\" => {\n         token::nt_path(~p.parse_path(LifetimeAndTypesWithoutColons).path)"}, {"sha": "e5910678a8eb465c582d5d90e2f6678ddefcd943", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=758d854436a2174c85717a64b8a90ed4041962d8", "patch": "@@ -40,10 +40,10 @@ impl ParserAnyMacro {\n     /// allowed to be there.\n     fn ensure_complete_parse(&self, allow_semi: bool) {\n         let mut parser = self.parser.borrow_mut();\n-        if allow_semi && *parser.get().token == SEMI {\n+        if allow_semi && parser.get().token == SEMI {\n             parser.get().bump()\n         }\n-        if *parser.get().token != EOF {\n+        if parser.get().token != EOF {\n             let token_str = parser.get().this_token_to_str();\n             let msg = format!(\"macro expansion ignores token `{}` and any \\\n                                following\","}, {"sha": "c8ebc8036049875a59b265e026abd3a370e33ea9", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=758d854436a2174c85717a64b8a90ed4041962d8", "patch": "@@ -33,7 +33,7 @@ impl parser_attr for Parser {\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\",\n                    self.token);\n-            match *self.token {\n+            match self.token {\n               token::INTERPOLATED(token::nt_attr(..)) => {\n                 attrs.push(self.parse_attribute(false));\n               }\n@@ -68,7 +68,7 @@ impl parser_attr for Parser {\n     fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute {\n         debug!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n                permit_inner, self.token);\n-        let (span, value) = match *self.token {\n+        let (span, value) = match self.token {\n             INTERPOLATED(token::nt_attr(attr)) => {\n                 assert!(attr.node.style == ast::AttrOuter);\n                 self.bump();\n@@ -89,7 +89,7 @@ impl parser_attr for Parser {\n                                    token_str));\n             }\n         };\n-        let style = if permit_inner && *self.token == token::SEMI {\n+        let style = if permit_inner && self.token == token::SEMI {\n             self.bump();\n             ast::AttrInner\n         } else {\n@@ -120,7 +120,7 @@ impl parser_attr for Parser {\n         let mut inner_attrs: ~[ast::Attribute] = ~[];\n         let mut next_outer_attrs: ~[ast::Attribute] = ~[];\n         loop {\n-            let attr = match *self.token {\n+            let attr = match self.token {\n                 token::INTERPOLATED(token::nt_attr(..)) => {\n                     self.parse_attribute(true)\n                 }\n@@ -158,7 +158,7 @@ impl parser_attr for Parser {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n         let name = self.id_to_str(ident);\n-        match *self.token {\n+        match self.token {\n             token::EQ => {\n                 self.bump();\n                 let lit = self.parse_lit();\n@@ -196,7 +196,7 @@ impl parser_attr for Parser {\n     }\n \n     fn parse_optional_meta(&mut self) -> ~[@ast::MetaItem] {\n-        match *self.token {\n+        match self.token {\n             token::LPAREN => self.parse_meta_seq(),\n             _ => ~[]\n         }"}, {"sha": "746e3279f19bf04e8e46dc58cf5a403306d52908", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=758d854436a2174c85717a64b8a90ed4041962d8", "patch": "@@ -631,7 +631,7 @@ mod test {\n     }\n \n     fn parser_done(p: Parser){\n-        assert_eq!((*p.token).clone(), token::EOF);\n+        assert_eq!(p.token.clone(), token::EOF);\n     }\n \n     #[test] fn parse_ident_pat () {"}, {"sha": "824420e996620ecb41df48725534f304e547b290", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=758d854436a2174c85717a64b8a90ed4041962d8", "patch": "@@ -20,7 +20,6 @@ removed.\n use ast::{Expr, ExprLit, lit_nil};\n use codemap::{Span, respan};\n use parse::parser::Parser;\n-use parse::token::Token;\n use parse::token;\n \n use std::str;\n@@ -66,7 +65,6 @@ pub trait ParserObsoleteMethods {\n               kind: ObsoleteSyntax,\n               kind_str: &str,\n               desc: &str);\n-    fn token_is_obsolete_ident(&mut self, ident: &str, token: &Token) -> bool;\n     fn is_obsolete_ident(&mut self, ident: &str) -> bool;\n     fn eat_obsolete_ident(&mut self, ident: &str) -> bool;\n }\n@@ -176,20 +174,15 @@ impl ParserObsoleteMethods for Parser {\n         }\n     }\n \n-    fn token_is_obsolete_ident(&mut self, ident: &str, token: &Token)\n-                               -> bool {\n-        match *token {\n+    fn is_obsolete_ident(&mut self, ident: &str) -> bool {\n+        match self.token {\n             token::IDENT(sid, _) => {\n                 str::eq_slice(self.id_to_str(sid), ident)\n             }\n             _ => false\n         }\n     }\n \n-    fn is_obsolete_ident(&mut self, ident: &str) -> bool {\n-        self.token_is_obsolete_ident(ident, self.token)\n-    }\n-\n     fn eat_obsolete_ident(&mut self, ident: &str) -> bool {\n         if self.is_obsolete_ident(ident) {\n             self.bump();"}, {"sha": "55dcddd62c4833f55fcd1279a9671512e2784b75", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 212, "deletions": 207, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758d854436a2174c85717a64b8a90ed4041962d8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=758d854436a2174c85717a64b8a90ed4041962d8", "patch": "@@ -143,15 +143,17 @@ macro_rules! maybe_whole_expr (\n         {\n             // This horrible convolution is brought to you by\n             // @mut, have a terrible day\n-            let ret = match *($p).token {\n+            let mut maybe_path = match ($p).token {\n+                INTERPOLATED(token::nt_path(ref pt)) => Some((**pt).clone()),\n+                _ => None,\n+            };\n+            let ret = match ($p).token {\n                 INTERPOLATED(token::nt_expr(e)) => {\n                     Some(e)\n                 }\n-                INTERPOLATED(token::nt_path(ref pt)) => {\n-                    Some($p.mk_expr(\n-                        ($p).span.lo,\n-                        ($p).span.hi,\n-                        ExprPath(/* bad */ (**pt).clone())))\n+                INTERPOLATED(token::nt_path(_)) => {\n+                    let pt = maybe_path.take_unwrap();\n+                    Some($p.mk_expr(($p).span.lo, ($p).span.hi, ExprPath(pt)))\n                 }\n                 _ => None\n             };\n@@ -169,7 +171,7 @@ macro_rules! maybe_whole_expr (\n macro_rules! maybe_whole (\n     ($p:expr, $constructor:ident) => (\n         {\n-            let __found__ = match *($p).token {\n+            let __found__ = match ($p).token {\n                 INTERPOLATED(token::$constructor(_)) => {\n                     Some(($p).bump_and_get())\n                 }\n@@ -185,7 +187,7 @@ macro_rules! maybe_whole (\n     );\n     (no_clone $p:expr, $constructor:ident) => (\n         {\n-            let __found__ = match *($p).token {\n+            let __found__ = match ($p).token {\n                 INTERPOLATED(token::$constructor(_)) => {\n                     Some(($p).bump_and_get())\n                 }\n@@ -201,7 +203,7 @@ macro_rules! maybe_whole (\n     );\n     (deref $p:expr, $constructor:ident) => (\n         {\n-            let __found__ = match *($p).token {\n+            let __found__ = match ($p).token {\n                 INTERPOLATED(token::$constructor(_)) => {\n                     Some(($p).bump_and_get())\n                 }\n@@ -217,7 +219,7 @@ macro_rules! maybe_whole (\n     );\n     (Some $p:expr, $constructor:ident) => (\n         {\n-            let __found__ = match *($p).token {\n+            let __found__ = match ($p).token {\n                 INTERPOLATED(token::$constructor(_)) => {\n                     Some(($p).bump_and_get())\n                 }\n@@ -233,7 +235,7 @@ macro_rules! maybe_whole (\n     );\n     (iovi $p:expr, $constructor:ident) => (\n         {\n-            let __found__ = match *($p).token {\n+            let __found__ = match ($p).token {\n                 INTERPOLATED(token::$constructor(_)) => {\n                     Some(($p).bump_and_get())\n                 }\n@@ -249,7 +251,7 @@ macro_rules! maybe_whole (\n     );\n     (pair_empty $p:expr, $constructor:ident) => (\n         {\n-            let __found__ = match *($p).token {\n+            let __found__ = match ($p).token {\n                 INTERPOLATED(token::$constructor(_)) => {\n                     Some(($p).bump_and_get())\n                 }\n@@ -301,7 +303,7 @@ pub fn Parser(sess: @mut ParseSess,\n         interner: interner,\n         sess: sess,\n         cfg: cfg,\n-        token: @mut tok0.tok,\n+        token: tok0.tok,\n         span: @mut span,\n         last_span: @mut span,\n         last_token: @mut None,\n@@ -328,7 +330,7 @@ pub struct Parser {\n     sess: @mut ParseSess,\n     cfg: CrateConfig,\n     // the current token:\n-    token: @mut token::Token,\n+    token: token::Token,\n     // the span of the current token:\n     span: @mut Span,\n     // the span of the prior token:\n@@ -360,17 +362,17 @@ fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n \n impl Parser {\n     // convert a token to a string using self's reader\n-    pub fn token_to_str(&mut self, token: &token::Token) -> ~str {\n+    pub fn token_to_str(token: &token::Token) -> ~str {\n         token::to_str(get_ident_interner(), token)\n     }\n \n     // convert the current token to a string using self's reader\n     pub fn this_token_to_str(&mut self) -> ~str {\n-        self.token_to_str(self.token)\n+        Parser::token_to_str(&self.token)\n     }\n \n     pub fn unexpected_last(&mut self, t: &token::Token) -> ! {\n-        let token_str = self.token_to_str(t);\n+        let token_str = Parser::token_to_str(t);\n         self.span_fatal(*self.last_span, format!(\"unexpected token: `{}`\",\n                                                  token_str));\n     }\n@@ -383,10 +385,10 @@ impl Parser {\n     // expect and consume the token t. Signal an error if\n     // the next token is not t.\n     pub fn expect(&mut self, t: &token::Token) {\n-        if *self.token == *t {\n+        if self.token == *t {\n             self.bump();\n         } else {\n-            let token_str = self.token_to_str(t);\n+            let token_str = Parser::token_to_str(t);\n             let this_token_str = self.this_token_to_str();\n             self.fatal(format!(\"expected `{}` but found `{}`\",\n                                token_str,\n@@ -400,19 +402,19 @@ impl Parser {\n     pub fn expect_one_of(&mut self,\n                          edible: &[token::Token],\n                          inedible: &[token::Token]) {\n-        fn tokens_to_str(p: &mut Parser, tokens: &[token::Token]) -> ~str {\n+        fn tokens_to_str(tokens: &[token::Token]) -> ~str {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n-            let b = i.next().map_default(~\"\", |t| p.token_to_str(t));\n-            i.fold(b, |b,a| b + \"`, `\" + p.token_to_str(a))\n+            let b = i.next().map_default(~\"\", |t| Parser::token_to_str(t));\n+            i.fold(b, |b,a| b + \"`, `\" + Parser::token_to_str(a))\n         }\n-        if edible.contains(self.token) {\n+        if edible.contains(&self.token) {\n             self.bump();\n-        } else if inedible.contains(self.token) {\n+        } else if inedible.contains(&self.token) {\n             // leave it in the input\n         } else {\n             let expected = vec::append(edible.to_owned(), inedible);\n-            let expect = tokens_to_str(self, expected);\n+            let expect = tokens_to_str(expected);\n             let actual = self.this_token_to_str();\n             self.fatal(\n                 if expected.len() != 1 {\n@@ -428,7 +430,7 @@ impl Parser {\n     // recover (without consuming any expected input token).  Returns\n     // true if and only if input was consumed for recovery.\n     pub fn check_for_erroneous_unit_struct_expecting(&mut self, expected: &[token::Token]) -> bool {\n-        if *self.token == token::LBRACE\n+        if self.token == token::LBRACE\n             && expected.iter().all(|t| *t != token::LBRACE)\n             && self.look_ahead(1, |t| *t == token::RBRACE) {\n             // matched; signal non-fatal error and recover.\n@@ -482,7 +484,7 @@ impl Parser {\n     pub fn parse_ident(&mut self) -> ast::Ident {\n         self.check_strict_keywords();\n         self.check_reserved_keywords();\n-        match *self.token {\n+        match self.token {\n             token::IDENT(i, _) => {\n                 self.bump();\n                 i\n@@ -508,19 +510,19 @@ impl Parser {\n     // consume token 'tok' if it exists. Returns true if the given\n     // token was present, false otherwise.\n     pub fn eat(&mut self, tok: &token::Token) -> bool {\n-        let is_present = *self.token == *tok;\n+        let is_present = self.token == *tok;\n         if is_present { self.bump() }\n         is_present\n     }\n \n     pub fn is_keyword(&mut self, kw: keywords::Keyword) -> bool {\n-        token::is_keyword(kw, self.token)\n+        token::is_keyword(kw, &self.token)\n     }\n \n     // if the next token is the given keyword, eat it and return\n     // true. Otherwise, return false.\n     pub fn eat_keyword(&mut self, kw: keywords::Keyword) -> bool {\n-        let is_kw = match *self.token {\n+        let is_kw = match self.token {\n             token::IDENT(sid, false) => kw.to_ident().name == sid.name,\n             _ => false\n         };\n@@ -543,7 +545,7 @@ impl Parser {\n \n     // signal an error if the given string is a strict keyword\n     pub fn check_strict_keywords(&mut self) {\n-        if token::is_strict_keyword(self.token) {\n+        if token::is_strict_keyword(&self.token) {\n             let token_str = self.this_token_to_str();\n             self.span_err(*self.span,\n                           format!(\"found `{}` in ident position\", token_str));\n@@ -552,7 +554,7 @@ impl Parser {\n \n     // signal an error if the current token is a reserved keyword\n     pub fn check_reserved_keywords(&mut self) {\n-        if token::is_reserved_keyword(self.token) {\n+        if token::is_reserved_keyword(&self.token) {\n             let token_str = self.this_token_to_str();\n             self.fatal(format!(\"`{}` is a reserved keyword\", token_str))\n         }\n@@ -561,7 +563,7 @@ impl Parser {\n     // Expect and consume a `|`. If `||` is seen, replace it with a single\n     // `|` and continue. If a `|` is not seen, signal an error.\n     fn expect_or(&mut self) {\n-        match *self.token {\n+        match self.token {\n             token::BINOP(token::OR) => self.bump(),\n             token::OROR => {\n                 self.replace_token(token::BINOP(token::OR),\n@@ -570,7 +572,8 @@ impl Parser {\n             }\n             _ => {\n                 let token_str = self.this_token_to_str();\n-                let found_token = self.token_to_str(&token::BINOP(token::OR));\n+                let found_token =\n+                    Parser::token_to_str(&token::BINOP(token::OR));\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    found_token,\n                                    token_str))\n@@ -586,8 +589,8 @@ impl Parser {\n                               -> ~[T] {\n         let mut first = true;\n         let mut vector = ~[];\n-        while *self.token != token::BINOP(token::OR) &&\n-                *self.token != token::OROR {\n+        while self.token != token::BINOP(token::OR) &&\n+                self.token != token::OROR {\n             if first {\n                 first = false\n             } else {\n@@ -603,15 +606,15 @@ impl Parser {\n     // with a single > and continue. If a GT is not seen,\n     // signal an error.\n     pub fn expect_gt(&mut self) {\n-        match *self.token {\n+        match self.token {\n             token::GT => self.bump(),\n             token::BINOP(token::SHR) => self.replace_token(\n                 token::GT,\n                 self.span.lo + BytePos(1),\n                 self.span.hi\n             ),\n             _ => {\n-                let gt_str = self.token_to_str(&token::GT);\n+                let gt_str = Parser::token_to_str(&token::GT);\n                 let this_token_str = self.this_token_to_str();\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    gt_str,\n@@ -629,8 +632,8 @@ impl Parser {\n                                   -> OptVec<T> {\n         let mut first = true;\n         let mut v = opt_vec::Empty;\n-        while *self.token != token::GT\n-            && *self.token != token::BINOP(token::SHR) {\n+        while self.token != token::GT\n+            && self.token != token::BINOP(token::SHR) {\n             match sep {\n               Some(ref t) => {\n                 if first { first = false; }\n@@ -678,15 +681,15 @@ impl Parser {\n                                    -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n-        while *self.token != *ket {\n+        while self.token != *ket {\n             match sep.sep {\n               Some(ref t) => {\n                 if first { first = false; }\n                 else { self.expect(t); }\n               }\n               _ => ()\n             }\n-            if sep.trailing_sep_allowed && *self.token == *ket { break; }\n+            if sep.trailing_sep_allowed && self.token == *ket { break; }\n             v.push(f(self));\n         }\n         return v;\n@@ -729,8 +732,8 @@ impl Parser {\n     pub fn bump(&mut self) {\n         *self.last_span = *self.span;\n         // Stash token for error recovery (sometimes; clone is not necessarily cheap).\n-        *self.last_token = if is_ident_or_path(self.token) {\n-            Some(~(*self.token).clone())\n+        *self.last_token = if is_ident_or_path(&self.token) {\n+            Some(~self.token.clone())\n         } else {\n             None\n         };\n@@ -749,13 +752,13 @@ impl Parser {\n             util::replace(&mut self.buffer[buffer_start], placeholder)\n         };\n         *self.span = next.sp;\n-        *self.token = next.tok;\n+        self.token = next.tok;\n         *self.tokens_consumed += 1u;\n     }\n \n     // Advance the parser by one token and return the bumped token.\n     pub fn bump_and_get(&mut self) -> token::Token {\n-        let old_token = util::replace(self.token, token::UNDERSCORE);\n+        let old_token = util::replace(&mut self.token, token::UNDERSCORE);\n         self.bump();\n         old_token\n     }\n@@ -765,7 +768,7 @@ impl Parser {\n                          next: token::Token,\n                          lo: BytePos,\n                          hi: BytePos) {\n-        *self.token = next;\n+        self.token = next;\n         *self.span = mk_sp(lo, hi);\n     }\n     pub fn buffer_length(&mut self) -> int {\n@@ -812,12 +815,12 @@ impl Parser {\n     // Is the current token one of the keywords that signals a bare function\n     // type?\n     pub fn token_is_bare_fn_keyword(&mut self) -> bool {\n-        if token::is_keyword(keywords::Fn, self.token) {\n+        if token::is_keyword(keywords::Fn, &self.token) {\n             return true\n         }\n \n-        if token::is_keyword(keywords::Unsafe, self.token) ||\n-            token::is_keyword(keywords::Once, self.token) {\n+        if token::is_keyword(keywords::Unsafe, &self.token) ||\n+            token::is_keyword(keywords::Once, &self.token) {\n             return self.look_ahead(1, |t| token::is_keyword(keywords::Fn, t))\n         }\n \n@@ -826,16 +829,16 @@ impl Parser {\n \n     // Is the current token one of the keywords that signals a closure type?\n     pub fn token_is_closure_keyword(&mut self) -> bool {\n-        token::is_keyword(keywords::Unsafe, self.token) ||\n-            token::is_keyword(keywords::Once, self.token)\n+        token::is_keyword(keywords::Unsafe, &self.token) ||\n+            token::is_keyword(keywords::Once, &self.token)\n     }\n \n     // Is the current token one of the keywords that signals an old-style\n     // closure type (with explicit sigil)?\n     pub fn token_is_old_style_closure_keyword(&mut self) -> bool {\n-        token::is_keyword(keywords::Unsafe, self.token) ||\n-            token::is_keyword(keywords::Once, self.token) ||\n-            token::is_keyword(keywords::Fn, self.token)\n+        token::is_keyword(keywords::Unsafe, &self.token) ||\n+            token::is_keyword(keywords::Once, &self.token) ||\n+            token::is_keyword(keywords::Fn, &self.token)\n     }\n \n     pub fn token_is_lifetime(tok: &token::Token) -> bool {\n@@ -845,8 +848,8 @@ impl Parser {\n         }\n     }\n \n-    pub fn get_lifetime(&mut self, tok: &token::Token) -> ast::Ident {\n-        match *tok {\n+    pub fn get_lifetime(&mut self) -> ast::Ident {\n+        match self.token {\n             token::LIFETIME(ref ident) => *ident,\n             _ => self.bug(\"not a lifetime\"),\n         }\n@@ -1060,7 +1063,7 @@ impl Parser {\n             });\n \n             let hi = p.last_span.hi;\n-            match *p.token {\n+            match p.token {\n               token::SEMI => {\n                 p.bump();\n                 debug!(\"parse_trait_methods(): parsing required method\");\n@@ -1169,9 +1172,9 @@ impl Parser {\n \n         let lo = self.span.lo;\n \n-        let t = if *self.token == token::LPAREN {\n+        let t = if self.token == token::LPAREN {\n             self.bump();\n-            if *self.token == token::RPAREN {\n+            if self.token == token::RPAREN {\n                 self.bump();\n                 ty_nil\n             } else {\n@@ -1180,9 +1183,9 @@ impl Parser {\n                 // of type t\n                 let mut ts = ~[self.parse_ty(false)];\n                 let mut one_tuple = false;\n-                while *self.token == token::COMMA {\n+                while self.token == token::COMMA {\n                     self.bump();\n-                    if *self.token != token::RPAREN {\n+                    if self.token != token::RPAREN {\n                         ts.push(self.parse_ty(false));\n                     }\n                     else {\n@@ -1199,19 +1202,19 @@ impl Parser {\n                 self.expect(&token::RPAREN);\n                 t\n             }\n-        } else if *self.token == token::AT {\n+        } else if self.token == token::AT {\n             // MANAGED POINTER\n             self.bump();\n             self.parse_box_or_uniq_pointee(ManagedSigil)\n-        } else if *self.token == token::TILDE {\n+        } else if self.token == token::TILDE {\n             // OWNED POINTER\n             self.bump();\n             self.parse_box_or_uniq_pointee(OwnedSigil)\n-        } else if *self.token == token::BINOP(token::STAR) {\n+        } else if self.token == token::BINOP(token::STAR) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n             ty_ptr(self.parse_mt())\n-        } else if *self.token == token::LBRACKET {\n+        } else if self.token == token::LBRACKET {\n             // VECTOR\n             self.expect(&token::LBRACKET);\n             let t = self.parse_ty(false);\n@@ -1224,7 +1227,7 @@ impl Parser {\n             };\n             self.expect(&token::RBRACKET);\n             t\n-        } else if *self.token == token::BINOP(token::AND) {\n+        } else if self.token == token::BINOP(token::AND) {\n             // BORROWED POINTER\n             self.bump();\n             self.parse_borrowed_pointee()\n@@ -1233,10 +1236,10 @@ impl Parser {\n             // BARE FUNCTION\n             self.parse_ty_bare_fn()\n         } else if self.token_is_closure_keyword() ||\n-                *self.token == token::BINOP(token::OR) ||\n-                *self.token == token::OROR ||\n-                *self.token == token::LT ||\n-                Parser::token_is_lifetime(self.token) {\n+                self.token == token::BINOP(token::OR) ||\n+                self.token == token::OROR ||\n+                self.token == token::LT ||\n+                Parser::token_is_lifetime(&self.token) {\n             // CLOSURE\n             //\n             // XXX(pcwalton): Eventually `token::LT` will not unambiguously\n@@ -1255,16 +1258,17 @@ impl Parser {\n             ty_typeof(e)\n         } else if self.eat_keyword(keywords::Proc) {\n             self.parse_proc_type()\n-        } else if *self.token == token::MOD_SEP\n-            || is_ident_or_path(self.token) {\n+        } else if self.token == token::MOD_SEP\n+            || is_ident_or_path(&self.token) {\n             // NAMED TYPE\n             let PathAndBounds {\n                 path,\n                 bounds\n             } = self.parse_path(LifetimeAndTypesAndBounds);\n             ty_path(path, bounds, ast::DUMMY_NODE_ID)\n         } else {\n-            self.fatal(format!(\"expected type, found token {:?}\", *self.token));\n+            let msg = format!(\"expected type, found token {:?}\", self.token);\n+            self.fatal(msg);\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n@@ -1276,7 +1280,7 @@ impl Parser {\n                                      sigil: ast::Sigil)\n                                      -> ty_ {\n         // ~'foo fn() or ~fn() are parsed directly as obsolete fn types:\n-        match *self.token {\n+        match self.token {\n             token::LIFETIME(..) => {\n                 let lifetime = self.parse_lifetime();\n                 self.obsolete(*self.last_span, ObsoleteBoxedClosure);\n@@ -1317,17 +1321,17 @@ impl Parser {\n     }\n \n     pub fn is_named_argument(&mut self) -> bool {\n-        let offset = match *self.token {\n+        let offset = match self.token {\n             token::BINOP(token::AND) => 1,\n             token::ANDAND => 1,\n-            _ if token::is_keyword(keywords::Mut, self.token) => 1,\n+            _ if token::is_keyword(keywords::Mut, &self.token) => 1,\n             _ => 0\n         };\n \n         debug!(\"parser is_named_argument offset:{}\", offset);\n \n         if offset == 0 {\n-            is_plain_ident_or_underscore(&*self.token)\n+            is_plain_ident_or_underscore(&self.token)\n                 && self.look_ahead(1, |t| *t == token::COLON)\n         } else {\n             self.look_ahead(offset, |t| is_plain_ident_or_underscore(t))\n@@ -1386,7 +1390,7 @@ impl Parser {\n     }\n \n     pub fn maybe_parse_fixed_vstore(&mut self) -> Option<@ast::Expr> {\n-        if *self.token == token::COMMA &&\n+        if self.token == token::COMMA &&\n                 self.look_ahead(1, |t| *t == token::DOTDOT) {\n             self.bump();\n             self.bump();\n@@ -1453,7 +1457,7 @@ impl Parser {\n     /// groups.\n     pub fn parse_path(&mut self, mode: PathParsingMode) -> PathAndBounds {\n         // Check for a whole path...\n-        let found = match *self.token {\n+        let found = match self.token {\n             INTERPOLATED(token::nt_path(_)) => Some(self.bump_and_get()),\n             _ => None,\n         };\n@@ -1571,7 +1575,7 @@ impl Parser {\n \n     /// parses 0 or 1 lifetime\n     pub fn parse_opt_lifetime(&mut self) -> Option<ast::Lifetime> {\n-        match *self.token {\n+        match self.token {\n             token::LIFETIME(..) => {\n                 Some(self.parse_lifetime())\n             }\n@@ -1584,7 +1588,7 @@ impl Parser {\n     /// Parses a single lifetime\n     // matches lifetime = LIFETIME\n     pub fn parse_lifetime(&mut self) -> ast::Lifetime {\n-        match *self.token {\n+        match self.token {\n             token::LIFETIME(i) => {\n                 let span = *self.span;\n                 self.bump();\n@@ -1614,7 +1618,7 @@ impl Parser {\n \n         let mut res = opt_vec::Empty;\n         loop {\n-            match *self.token {\n+            match self.token {\n                 token::LIFETIME(_) => {\n                     res.push(self.parse_lifetime());\n                 }\n@@ -1623,13 +1627,15 @@ impl Parser {\n                 }\n             }\n \n-            match *self.token {\n+            match self.token {\n                 token::COMMA => { self.bump();}\n                 token::GT => { return res; }\n                 token::BINOP(token::SHR) => { return res; }\n                 _ => {\n-                    self.fatal(format!(\"expected `,` or `>` after lifetime name, got: {:?}\",\n-                                    *self.token));\n+                    let msg = format!(\"expected `,` or `>` after lifetime \\\n+                                      name, got: {:?}\",\n+                                      self.token);\n+                    self.fatal(msg);\n                 }\n             }\n         }\n@@ -1740,22 +1746,22 @@ impl Parser {\n \n         let ex: Expr_;\n \n-        if *self.token == token::LPAREN {\n+        if self.token == token::LPAREN {\n             self.bump();\n             // (e) is parenthesized e\n             // (e,) is a tuple with only one field, e\n             let mut trailing_comma = false;\n-            if *self.token == token::RPAREN {\n+            if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n                 let lit = @spanned(lo, hi, lit_nil);\n                 return self.mk_expr(lo, hi, ExprLit(lit));\n             }\n             let mut es = ~[self.parse_expr()];\n             self.commit_expr(*es.last(), &[], &[token::COMMA, token::RPAREN]);\n-            while *self.token == token::COMMA {\n+            while self.token == token::COMMA {\n                 self.bump();\n-                if *self.token != token::RPAREN {\n+                if self.token != token::RPAREN {\n                     es.push(self.parse_expr());\n                     self.commit_expr(*es.last(), &[], &[token::COMMA, token::RPAREN]);\n                 }\n@@ -1772,12 +1778,12 @@ impl Parser {\n             else {\n                 self.mk_expr(lo, hi, ExprTup(es))\n             }\n-        } else if *self.token == token::LBRACE {\n+        } else if self.token == token::LBRACE {\n             self.bump();\n             let blk = self.parse_block_tail(lo, DefaultBlock);\n             return self.mk_expr(blk.span.lo, blk.span.hi,\n                                  ExprBlock(blk));\n-        } else if token::is_bar(&*self.token) {\n+        } else if token::is_bar(&self.token) {\n             return self.parse_lambda_expr();\n         } else if self.eat_keyword(keywords::Proc) {\n             let decl = self.parse_proc_decl();\n@@ -1804,8 +1810,8 @@ impl Parser {\n                                                ExprDoBody);\n         } else if self.eat_keyword(keywords::While) {\n             return self.parse_while_expr();\n-        } else if Parser::token_is_lifetime(&*self.token) {\n-            let lifetime = self.get_lifetime(&*self.token);\n+        } else if Parser::token_is_lifetime(&self.token) {\n+            let lifetime = self.get_lifetime();\n             self.bump();\n             self.expect(&token::COLON);\n             if self.eat_keyword(keywords::For) {\n@@ -1819,8 +1825,8 @@ impl Parser {\n             return self.parse_loop_expr(None);\n         } else if self.eat_keyword(keywords::Continue) {\n             let lo = self.span.lo;\n-            let ex = if Parser::token_is_lifetime(&*self.token) {\n-                let lifetime = self.get_lifetime(&*self.token);\n+            let ex = if Parser::token_is_lifetime(&self.token) {\n+                let lifetime = self.get_lifetime();\n                 self.bump();\n                 ExprAgain(Some(lifetime.name))\n             } else {\n@@ -1832,26 +1838,26 @@ impl Parser {\n             return self.parse_match_expr();\n         } else if self.eat_keyword(keywords::Unsafe) {\n             return self.parse_block_expr(lo, UnsafeBlock(ast::UserProvided));\n-        } else if *self.token == token::LBRACKET {\n+        } else if self.token == token::LBRACKET {\n             self.bump();\n             let mutbl = MutImmutable;\n \n-            if *self.token == token::RBRACKET {\n+            if self.token == token::RBRACKET {\n                 // Empty vector.\n                 self.bump();\n                 ex = ExprVec(~[], mutbl);\n             } else {\n                 // Nonempty vector.\n                 let first_expr = self.parse_expr();\n-                if *self.token == token::COMMA &&\n+                if self.token == token::COMMA &&\n                         self.look_ahead(1, |t| *t == token::DOTDOT) {\n                     // Repeating vector syntax: [ 0, ..512 ]\n                     self.bump();\n                     self.bump();\n                     let count = self.parse_expr();\n                     self.expect(&token::RBRACKET);\n                     ex = ExprRepeat(first_expr, count, mutbl);\n-                } else if *self.token == token::COMMA {\n+                } else if self.token == token::COMMA {\n                     // Vector with two or more elements.\n                     self.bump();\n                     let remaining_exprs = self.parse_seq_to_end(\n@@ -1875,36 +1881,36 @@ impl Parser {\n             self.expect(&token::RPAREN);\n         } else if self.eat_keyword(keywords::Return) {\n             // RETURN expression\n-            if can_begin_expr(&*self.token) {\n+            if can_begin_expr(&self.token) {\n                 let e = self.parse_expr();\n                 hi = e.span.hi;\n                 ex = ExprRet(Some(e));\n             } else { ex = ExprRet(None); }\n         } else if self.eat_keyword(keywords::Break) {\n             // BREAK expression\n-            if Parser::token_is_lifetime(&*self.token) {\n-                let lifetime = self.get_lifetime(&*self.token);\n+            if Parser::token_is_lifetime(&self.token) {\n+                let lifetime = self.get_lifetime();\n                 self.bump();\n                 ex = ExprBreak(Some(lifetime.name));\n             } else {\n                 ex = ExprBreak(None);\n             }\n             hi = self.span.hi;\n-        } else if *self.token == token::MOD_SEP ||\n-                is_ident(&*self.token) && !self.is_keyword(keywords::True) &&\n+        } else if self.token == token::MOD_SEP ||\n+                is_ident(&self.token) && !self.is_keyword(keywords::True) &&\n                 !self.is_keyword(keywords::False) {\n             let pth = self.parse_path(LifetimeAndTypesWithColons).path;\n \n             // `!`, as an operator, is prefix, so we know this isn't that\n-            if *self.token == token::NOT {\n+            if self.token == token::NOT {\n                 // MACRO INVOCATION expression\n                 self.bump();\n-                match *self.token {\n+                match self.token {\n                     token::LPAREN | token::LBRACE => {}\n                     _ => self.fatal(\"expected open delimiter\")\n                 };\n \n-                let ket = token::flip_delimiter(&*self.token);\n+                let ket = token::flip_delimiter(&self.token);\n                 self.bump();\n \n                 let tts = self.parse_seq_to_end(&ket,\n@@ -1913,7 +1919,7 @@ impl Parser {\n                 let hi = self.span.hi;\n \n                 return self.mk_mac_expr(lo, hi, mac_invoc_tt(pth, tts, EMPTY_CTXT));\n-            } else if *self.token == token::LBRACE {\n+            } else if self.token == token::LBRACE {\n                 // This might be a struct literal.\n                 if self.looking_at_struct_literal() {\n                     // It's a struct literal.\n@@ -1922,15 +1928,15 @@ impl Parser {\n                     let mut base = None;\n \n                     fields.push(self.parse_field());\n-                    while *self.token != token::RBRACE {\n+                    while self.token != token::RBRACE {\n                         self.commit_expr(fields.last().expr, &[token::COMMA], &[token::RBRACE]);\n \n                         if self.eat(&token::DOTDOT) {\n                             base = Some(self.parse_expr());\n                             break;\n                         }\n \n-                        if *self.token == token::RBRACE {\n+                        if self.token == token::RBRACE {\n                             // Accept an optional trailing comma.\n                             break;\n                         }\n@@ -1977,7 +1983,7 @@ impl Parser {\n         loop {\n             // expr.f\n             if self.eat(&token::DOT) {\n-                match *self.token {\n+                match self.token {\n                   token::IDENT(i, _) => {\n                     hi = self.span.hi;\n                     self.bump();\n@@ -1989,7 +1995,7 @@ impl Parser {\n                     };\n \n                     // expr.f() method call\n-                    match *self.token {\n+                    match self.token {\n                         token::LPAREN => {\n                             let es = self.parse_unspanned_seq(\n                                 &token::LPAREN,\n@@ -2013,7 +2019,7 @@ impl Parser {\n                 continue;\n             }\n             if self.expr_is_complete(e) { break; }\n-            match *self.token {\n+            match self.token {\n               // expr(...)\n               token::LPAREN => {\n                 let es = self.parse_unspanned_seq(\n@@ -2048,9 +2054,9 @@ impl Parser {\n     // repetition token (+ or *).\n     pub fn parse_sep_and_zerok(&mut self) -> (Option<token::Token>, bool) {\n         fn parse_zerok(parser: &mut Parser) -> Option<bool> {\n-            match *parser.token {\n+            match parser.token {\n                 token::BINOP(token::STAR) | token::BINOP(token::PLUS) => {\n-                    let zerok = *parser.token == token::BINOP(token::STAR);\n+                    let zerok = parser.token == token::BINOP(token::STAR);\n                     parser.bump();\n                     Some(zerok)\n                 },\n@@ -2086,7 +2092,7 @@ impl Parser {\n         // reaching this point.\n         fn parse_non_delim_tt_tok(p: &mut Parser) -> token_tree {\n             maybe_whole!(deref p, nt_tt);\n-            match *p.token {\n+            match p.token {\n               token::RPAREN | token::RBRACE | token::RBRACKET => {\n                   // This is a conservative error: only report the last unclosed delimiter. The\n                   // previous unclosed delimiters could actually be closed! The parser just hasn't\n@@ -2101,7 +2107,7 @@ impl Parser {\n                 p.bump();\n                 let sp = *p.span;\n \n-                if *p.token == token::LPAREN {\n+                if p.token == token::LPAREN {\n                     let seq = p.parse_seq(\n                         &token::LPAREN,\n                         &token::RPAREN,\n@@ -2133,7 +2139,7 @@ impl Parser {\n             tt_tok(*p.span, p.bump_and_get())\n         }\n \n-        match *self.token {\n+        match self.token {\n             token::EOF => {\n                 for sp in self.open_braces.iter() {\n                     self.span_note(*sp, \"Did you mean to close this delimiter?\");\n@@ -2143,7 +2149,7 @@ impl Parser {\n                 self.fatal(\"This file contains an un-closed delimiter \");\n             }\n             token::LPAREN | token::LBRACE | token::LBRACKET => {\n-                let close_delim = token::flip_delimiter(&*self.token);\n+                let close_delim = token::flip_delimiter(&self.token);\n \n                 // Parse the open delimiter.\n                 (*self.open_braces).push(*self.span);\n@@ -2169,7 +2175,7 @@ impl Parser {\n     // up to EOF.\n     pub fn parse_all_token_trees(&mut self) -> ~[token_tree] {\n         let mut tts = ~[];\n-        while *self.token != token::EOF {\n+        while self.token != token::EOF {\n             tts.push(self.parse_token_tree());\n         }\n         tts\n@@ -2180,9 +2186,9 @@ impl Parser {\n         // the interpolation of matchers\n         maybe_whole!(self, nt_matchers);\n         let name_idx = @mut 0u;\n-        match *self.token {\n+        match self.token {\n             token::LBRACE | token::LPAREN | token::LBRACKET => {\n-                let other_delimiter = token::flip_delimiter(self.token);\n+                let other_delimiter = token::flip_delimiter(&self.token);\n                 self.bump();\n                 self.parse_matcher_subseq_upto(name_idx, &other_delimiter)\n             }\n@@ -2200,9 +2206,9 @@ impl Parser {\n         let mut ret_val = ~[];\n         let mut lparens = 0u;\n \n-        while *self.token != *ket || lparens > 0u {\n-            if *self.token == token::LPAREN { lparens += 1u; }\n-            if *self.token == token::RPAREN { lparens -= 1u; }\n+        while self.token != *ket || lparens > 0u {\n+            if self.token == token::LPAREN { lparens += 1u; }\n+            if self.token == token::RPAREN { lparens -= 1u; }\n             ret_val.push(self.parse_matcher(name_idx));\n         }\n \n@@ -2214,9 +2220,9 @@ impl Parser {\n     pub fn parse_matcher(&mut self, name_idx: @mut uint) -> matcher {\n         let lo = self.span.lo;\n \n-        let m = if *self.token == token::DOLLAR {\n+        let m = if self.token == token::DOLLAR {\n             self.bump();\n-            if *self.token == token::LPAREN {\n+            if self.token == token::LPAREN {\n                 let name_idx_lo = *name_idx;\n                 self.bump();\n                 let ms = self.parse_matcher_subseq_upto(name_idx,\n@@ -2247,7 +2253,7 @@ impl Parser {\n         let hi;\n \n         let ex;\n-        match *self.token {\n+        match self.token {\n           token::NOT => {\n             self.bump();\n             let e = self.parse_prefix_expr();\n@@ -2353,7 +2359,7 @@ impl Parser {\n         // Prevent dynamic borrow errors later on by limiting the\n         // scope of the borrows.\n         {\n-            let token: &token::Token = self.token;\n+            let token: &token::Token = &self.token;\n             let restriction: &restriction = self.restriction;\n             match (token, restriction) {\n                 (&token::BINOP(token::OR), &RESTRICT_NO_BAR_OP) => return lhs,\n@@ -2364,7 +2370,7 @@ impl Parser {\n             }\n         }\n \n-        let cur_opt = token_to_binop(self.token);\n+        let cur_opt = token_to_binop(&self.token);\n         match cur_opt {\n             Some(cur_op) => {\n                 let cur_prec = operator_prec(cur_op);\n@@ -2399,7 +2405,7 @@ impl Parser {\n     pub fn parse_assign_expr(&mut self) -> @Expr {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n-        match *self.token {\n+        match self.token {\n           token::EQ => {\n               self.bump();\n               let rhs = self.parse_expr();\n@@ -2455,7 +2461,7 @@ impl Parser {\n     pub fn parse_lambda_block_expr(&mut self) -> @Expr {\n         self.parse_lambda_expr_(\n             |p| {\n-                match *p.token {\n+                match p.token {\n                   token::BINOP(token::OR) | token::OROR => {\n                     p.parse_fn_block_decl()\n                   }\n@@ -2613,8 +2619,8 @@ impl Parser {\n     pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>) -> @Expr {\n         // loop headers look like 'loop {' or 'loop unsafe {'\n         let is_loop_header =\n-            *self.token == token::LBRACE\n-            || (is_ident(&*self.token)\n+            self.token == token::LBRACE\n+            || (is_ident(&self.token)\n                 && self.look_ahead(1, |t| *t == token::LBRACE));\n \n         if is_loop_header {\n@@ -2632,8 +2638,8 @@ impl Parser {\n \n             self.obsolete(*self.last_span, ObsoleteLoopAsContinue);\n             let lo = self.span.lo;\n-            let ex = if Parser::token_is_lifetime(&*self.token) {\n-                let lifetime = self.get_lifetime(&*self.token);\n+            let ex = if Parser::token_is_lifetime(&self.token) {\n+                let lifetime = self.get_lifetime();\n                 self.bump();\n                 ExprAgain(Some(lifetime.name))\n             } else {\n@@ -2646,7 +2652,7 @@ impl Parser {\n \n     // For distingishing between struct literals and blocks\n     fn looking_at_struct_literal(&mut self) -> bool {\n-        *self.token == token::LBRACE &&\n+        self.token == token::LBRACE &&\n         (self.look_ahead(1, |t| token::is_plain_ident(t)) &&\n          self.look_ahead(2, |t| *t == token::COLON))\n     }\n@@ -2656,7 +2662,7 @@ impl Parser {\n         let discriminant = self.parse_expr();\n         self.commit_expr_expecting(discriminant, token::LBRACE);\n         let mut arms: ~[Arm] = ~[];\n-        while *self.token != token::RBRACE {\n+        while self.token != token::RBRACE {\n             let pats = self.parse_pats();\n             let mut guard = None;\n             if self.eat_keyword(keywords::If) {\n@@ -2667,7 +2673,7 @@ impl Parser {\n \n             let require_comma =\n                 !classify::expr_is_simple_block(expr)\n-                && *self.token != token::RBRACE;\n+                && self.token != token::RBRACE;\n \n             if require_comma {\n                 self.commit_expr(expr, &[token::COMMA], &[token::RBRACE]);\n@@ -2707,7 +2713,7 @@ impl Parser {\n \n     // parse the RHS of a local variable declaration (e.g. '= 14;')\n     fn parse_initializer(&mut self) -> Option<@Expr> {\n-        if *self.token == token::EQ {\n+        if self.token == token::EQ {\n             self.bump();\n             Some(self.parse_expr())\n         } else {\n@@ -2720,7 +2726,7 @@ impl Parser {\n         let mut pats = ~[];\n         loop {\n             pats.push(self.parse_pat());\n-            if *self.token == token::BINOP(token::OR) { self.bump(); }\n+            if self.token == token::BINOP(token::OR) { self.bump(); }\n             else { return pats; }\n         };\n     }\n@@ -2734,21 +2740,21 @@ impl Parser {\n         let mut first = true;\n         let mut before_slice = true;\n \n-        while *self.token != token::RBRACKET {\n+        while self.token != token::RBRACKET {\n             if first { first = false; }\n             else { self.expect(&token::COMMA); }\n \n             let mut is_slice = false;\n             if before_slice {\n-                if *self.token == token::DOTDOT {\n+                if self.token == token::DOTDOT {\n                     self.bump();\n                     is_slice = true;\n                     before_slice = false;\n                 }\n             }\n \n             if is_slice {\n-                if *self.token == token::COMMA || *self.token == token::RBRACKET {\n+                if self.token == token::COMMA || self.token == token::RBRACKET {\n                     slice = Some(@ast::Pat {\n                         id: ast::DUMMY_NODE_ID,\n                         node: PatWildMulti,\n@@ -2791,22 +2797,22 @@ impl Parser {\n         let mut fields = ~[];\n         let mut etc = false;\n         let mut first = true;\n-        while *self.token != token::RBRACE {\n+        while self.token != token::RBRACE {\n             if first {\n                 first = false;\n             } else {\n                 self.expect(&token::COMMA);\n                 // accept trailing commas\n-                if *self.token == token::RBRACE { break }\n+                if self.token == token::RBRACE { break }\n             }\n \n-            etc = *self.token == token::UNDERSCORE || *self.token == token::DOTDOT;\n-            if *self.token == token::UNDERSCORE {\n+            etc = self.token == token::UNDERSCORE || self.token == token::DOTDOT;\n+            if self.token == token::UNDERSCORE {\n                 self.obsolete(*self.span, ObsoleteStructWildcard);\n             }\n             if etc {\n                 self.bump();\n-                if *self.token != token::RBRACE {\n+                if self.token != token::RBRACE {\n                     let token_str = self.this_token_to_str();\n                     self.fatal(format!(\"expected `\\\\}`, found `{}`\",\n                                        token_str))\n@@ -2829,7 +2835,7 @@ impl Parser {\n             let fieldpath = ast_util::ident_to_path(mk_sp(lo1, hi1),\n                                                     fieldname);\n             let subpat;\n-            if *self.token == token::COLON {\n+            if self.token == token::COLON {\n                 match bind_type {\n                     BindByRef(..) | BindByValue(MutMutable) => {\n                         let token_str = self.this_token_to_str();\n@@ -2859,7 +2865,7 @@ impl Parser {\n         let lo = self.span.lo;\n         let mut hi;\n         let pat;\n-        match *self.token {\n+        match self.token {\n             // parse _\n           token::UNDERSCORE => {\n             self.bump();\n@@ -2958,7 +2964,7 @@ impl Parser {\n           token::LPAREN => {\n             // parse (pat,pat,pat,...) as tuple\n             self.bump();\n-            if *self.token == token::RPAREN {\n+            if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n                 let lit = @codemap::Spanned {\n@@ -2969,7 +2975,7 @@ impl Parser {\n             } else {\n                 let mut fields = ~[self.parse_pat()];\n                 if self.look_ahead(1, |t| *t != token::RPAREN) {\n-                    while *self.token == token::COMMA {\n+                    while self.token == token::COMMA {\n                         self.bump();\n                         fields.push(self.parse_pat());\n                     }\n@@ -3003,8 +3009,7 @@ impl Parser {\n           _ => {}\n         }\n \n-        let tok = self.token;\n-        if !is_ident_or_path(tok)\n+        if !is_ident_or_path(&self.token)\n                 || self.is_keyword(keywords::True)\n                 || self.is_keyword(keywords::False) {\n             // Parse an expression pattern or exp .. exp.\n@@ -3013,7 +3018,7 @@ impl Parser {\n             // preceded by unary-minus) or identifiers.\n             let val = self.parse_literal_maybe_minus();\n             if self.eat(&token::DOTDOT) {\n-                let end = if is_ident_or_path(tok) {\n+                let end = if is_ident_or_path(&self.token) {\n                     let path = self.parse_path(LifetimeAndTypesWithColons)\n                                    .path;\n                     let hi = self.span.hi;\n@@ -3045,7 +3050,7 @@ impl Parser {\n                 self.eat(&token::DOTDOT);\n                 let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                 pat = PatRange(start, end);\n-            } else if is_plain_ident(&*self.token) && !can_be_enum_or_struct {\n+            } else if is_plain_ident(&self.token) && !can_be_enum_or_struct {\n                 let name = self.parse_path(NoTypesAllowed).path;\n                 let sub;\n                 if self.eat(&token::AT) {\n@@ -3060,7 +3065,7 @@ impl Parser {\n                 // parse an enum pat\n                 let enum_path = self.parse_path(LifetimeAndTypesWithColons)\n                                     .path;\n-                match *self.token {\n+                match self.token {\n                     token::LBRACE => {\n                         self.bump();\n                         let (fields, etc) =\n@@ -3070,7 +3075,7 @@ impl Parser {\n                     }\n                     _ => {\n                         let mut args: ~[@Pat] = ~[];\n-                        match *self.token {\n+                        match self.token {\n                           token::LPAREN => {\n                             let is_star = self.look_ahead(1, |t| {\n                                 match *t {\n@@ -3134,7 +3139,7 @@ impl Parser {\n     fn parse_pat_ident(&mut self,\n                        binding_mode: ast::BindingMode)\n                        -> ast::Pat_ {\n-        if !is_plain_ident(&*self.token) {\n+        if !is_plain_ident(&self.token) {\n             self.span_fatal(*self.last_span,\n                             \"expected identifier, found path\");\n         }\n@@ -3152,7 +3157,7 @@ impl Parser {\n         // leads to a parse error.  Note that if there is no explicit\n         // binding mode then we do not end up here, because the lookahead\n         // will direct us over to parse_enum_variant()\n-        if *self.token == token::LPAREN {\n+        if self.token == token::LPAREN {\n             self.span_fatal(\n                 *self.last_span,\n                 \"expected identifier, found enum pattern\");\n@@ -3198,7 +3203,7 @@ impl Parser {\n                          pr: visibility,\n                          attrs: ~[Attribute]) -> struct_field {\n         let lo = self.span.lo;\n-        if !is_plain_ident(&*self.token) {\n+        if !is_plain_ident(&self.token) {\n             self.fatal(\"expected ident\");\n         }\n         let name = self.parse_ident();\n@@ -3230,8 +3235,8 @@ impl Parser {\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n             return @spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n-        } else if is_ident(&*self.token)\n-            && !token::is_any_keyword(self.token)\n+        } else if is_ident(&self.token)\n+            && !token::is_any_keyword(&self.token)\n             && self.look_ahead(1, |t| *t == token::NOT) {\n             // parse a macro invocation. Looks like there's serious\n             // overlap here; if this clause doesn't catch it (and it\n@@ -3253,7 +3258,7 @@ impl Parser {\n             let pth = self.parse_path(NoTypesAllowed).path;\n             self.bump();\n \n-            let id = if *self.token == token::LPAREN {\n+            let id = if self.token == token::LPAREN {\n                 token::special_idents::invalid // no special identifier\n             } else {\n                 self.parse_ident()\n@@ -3373,11 +3378,11 @@ impl Parser {\n \n         let mut attributes_box = attrs_remaining;\n \n-        while (*self.token != token::RBRACE) {\n+        while (self.token != token::RBRACE) {\n             // parsing items even when they're not allowed lets us give\n             // better error messages and recover more gracefully.\n             attributes_box.push_all(self.parse_outer_attributes());\n-            match *self.token {\n+            match self.token {\n                 token::SEMI => {\n                     if !attributes_box.is_empty() {\n                         self.span_err(*self.last_span, \"expected item after attributes\");\n@@ -3399,7 +3404,7 @@ impl Parser {\n                                 self.commit_stmt(stmt, &[], &[token::SEMI, token::RBRACE]);\n                             }\n \n-                            match *self.token {\n+                            match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n                                     stmts.push(@codemap::Spanned {\n@@ -3418,7 +3423,7 @@ impl Parser {\n                         StmtMac(ref m, _) => {\n                             // statement macro; might be an expr\n                             let has_semi;\n-                            match *self.token {\n+                            match self.token {\n                                 token::SEMI => {\n                                     has_semi = true;\n                                 }\n@@ -3487,7 +3492,7 @@ impl Parser {\n \n         let mut result = opt_vec::Empty;\n         loop {\n-            match *self.token {\n+            match self.token {\n                 token::LIFETIME(lifetime) => {\n                     if \"static\" == self.id_to_str(lifetime) {\n                         result.push(RegionTyParamBound);\n@@ -3554,10 +3559,10 @@ impl Parser {\n                 &token::RPAREN,\n                 seq_sep_trailing_disallowed(token::COMMA),\n                 |p| {\n-                    if *p.token == token::DOTDOTDOT {\n+                    if p.token == token::DOTDOTDOT {\n                         p.bump();\n                         if allow_variadic {\n-                            if *p.token != token::RPAREN {\n+                            if p.token != token::RPAREN {\n                                 p.span_fatal(*p.span,\n                                     \"`...` must be last in argument list for variadic function\");\n                             }\n@@ -3607,7 +3612,7 @@ impl Parser {\n     }\n \n     fn is_self_ident(&mut self) -> bool {\n-        match *self.token {\n+        match self.token {\n           token::IDENT(id, false) => id.name == special_idents::self_.name,\n           _ => false\n         }\n@@ -3696,7 +3701,7 @@ impl Parser {\n         // A bit of complexity and lookahead is needed here in order to be\n         // backwards compatible.\n         let lo = self.span.lo;\n-        let explicit_self = match *self.token {\n+        let explicit_self = match self.token {\n           token::BINOP(token::AND) => {\n             maybe_parse_borrowed_explicit_self(self)\n           }\n@@ -3720,7 +3725,7 @@ impl Parser {\n             // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n             // emitting cryptic \"unexpected token\" errors.\n             self.bump();\n-            let mutability = if Parser::token_is_mutability(self.token) {\n+            let mutability = if Parser::token_is_mutability(&self.token) {\n                 self.parse_mutability()\n             } else { MutImmutable };\n             if self.is_self_ident() {\n@@ -3729,13 +3734,13 @@ impl Parser {\n             }\n             sty_value(mutability)\n           }\n-          _ if Parser::token_is_mutability(self.token) &&\n+          _ if Parser::token_is_mutability(&self.token) &&\n                self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) => {\n             let mutability = self.parse_mutability();\n             self.expect_self_ident();\n             sty_value(mutability)\n           }\n-          _ if Parser::token_is_mutability(self.token) &&\n+          _ if Parser::token_is_mutability(&self.token) &&\n                self.look_ahead(1, |t| *t == token::TILDE) &&\n                self.look_ahead(2, |t| token::is_keyword(keywords::Self, t)) => {\n             let mutability = self.parse_mutability();\n@@ -3751,7 +3756,7 @@ impl Parser {\n         // If we parsed a self type, expect a comma before the argument list.\n         let fn_inputs;\n         if explicit_self != sty_static {\n-            match *self.token {\n+            match self.token {\n                 token::COMMA => {\n                     self.bump();\n                     let sep = seq_sep_trailing_disallowed(token::COMMA);\n@@ -3918,7 +3923,7 @@ impl Parser {\n \n         // Parse traits, if necessary.\n         let traits;\n-        if *self.token == token::COLON {\n+        if self.token == token::COLON {\n             self.bump();\n             traits = self.parse_trait_ref_list(&token::LBRACE);\n         } else {\n@@ -3942,7 +3947,7 @@ impl Parser {\n \n         // Special case: if the next identifier that follows is '(', don't\n         // allow this to be parsed as a trait.\n-        let could_be_trait = *self.token != token::LPAREN;\n+        let could_be_trait = self.token != token::LPAREN;\n \n         // Parse the trait.\n         let mut ty = self.parse_ty(false);\n@@ -4021,15 +4026,15 @@ impl Parser {\n             // It's a record-like struct.\n             is_tuple_like = false;\n             fields = ~[];\n-            while *self.token != token::RBRACE {\n+            while self.token != token::RBRACE {\n                 fields.push(self.parse_struct_decl_field());\n             }\n             if fields.len() == 0 {\n                 self.fatal(format!(\"Unit-like struct definition should be written as `struct {};`\",\n                                 get_ident_interner().get(class_name.name)));\n             }\n             self.bump();\n-        } else if *self.token == token::LPAREN {\n+        } else if self.token == token::LPAREN {\n             // It's a tuple-like struct.\n             is_tuple_like = true;\n             fields = self.parse_unspanned_seq(\n@@ -4075,7 +4080,7 @@ impl Parser {\n                                      attrs: ~[Attribute])\n                                      -> struct_field {\n         let a_var = self.parse_name_and_ty(vis, attrs);\n-        match *self.token {\n+        match self.token {\n             token::COMMA => {\n                 self.bump();\n             }\n@@ -4133,7 +4138,7 @@ impl Parser {\n         // don't think this other loop is even necessary....\n \n         let mut first = true;\n-        while *self.token != term {\n+        while self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n             if first {\n                 attrs = attrs_remaining + attrs;\n@@ -4180,7 +4185,7 @@ impl Parser {\n     fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> item_info {\n         let id_span = *self.span;\n         let id = self.parse_ident();\n-        if *self.token == token::SEMI {\n+        if self.token == token::SEMI {\n             self.bump();\n             // This mod is in an external file. Let's go get it!\n             let (m, attrs) = self.eval_src_mod(id, outer_attrs, id_span);\n@@ -4356,7 +4361,7 @@ impl Parser {\n             self.span_err(*self.last_span,\n                           \"expected item after attributes\");\n         }\n-        assert!(*self.token == token::RBRACE);\n+        assert!(self.token == token::RBRACE);\n         ast::foreign_mod {\n             abis: abis,\n             view_items: view_items,\n@@ -4376,17 +4381,17 @@ impl Parser {\n         if self.is_keyword(keywords::Mod) {\n             must_be_named_mod = true;\n             self.expect_keyword(keywords::Mod);\n-        } else if *self.token != token::LBRACE {\n+        } else if self.token != token::LBRACE {\n             let token_str = self.this_token_to_str();\n             self.span_fatal(*self.span,\n                             format!(\"expected `\\\\{` or `mod` but found `{}`\",\n                                     token_str))\n         }\n \n-        let (named, maybe_path, ident) = match *self.token {\n+        let (named, maybe_path, ident) = match self.token {\n             token::IDENT(..) => {\n                 let the_ident = self.parse_ident();\n-                let path = if *self.token == token::EQ {\n+                let path = if self.token == token::EQ {\n                     self.bump();\n                     Some(self.parse_str())\n                 }\n@@ -4465,7 +4470,7 @@ impl Parser {\n     // this should probably be renamed or refactored...\n     fn parse_struct_def(&mut self) -> @struct_def {\n         let mut fields: ~[struct_field] = ~[];\n-        while *self.token != token::RBRACE {\n+        while self.token != token::RBRACE {\n             fields.push(self.parse_struct_decl_field());\n         }\n         self.bump();\n@@ -4481,7 +4486,7 @@ impl Parser {\n         let mut variants = ~[];\n         let mut all_nullary = true;\n         let mut have_disr = false;\n-        while *self.token != token::RBRACE {\n+        while self.token != token::RBRACE {\n             let variant_attrs = self.parse_outer_attributes();\n             let vlo = self.span.lo;\n \n@@ -4496,7 +4501,7 @@ impl Parser {\n                 // Parse a struct variant.\n                 all_nullary = false;\n                 kind = struct_variant_kind(self.parse_struct_def());\n-            } else if *self.token == token::LPAREN {\n+            } else if self.token == token::LPAREN {\n                 all_nullary = false;\n                 let arg_tys = self.parse_unspanned_seq(\n                     &token::LPAREN,\n@@ -4564,7 +4569,7 @@ impl Parser {\n             return None\n         }\n \n-        match *self.token {\n+        match self.token {\n             token::LIT_STR(s)\n             | token::LIT_STR_RAW(s, _) => {\n                 self.bump();\n@@ -4611,7 +4616,7 @@ impl Parser {\n                                attrs: ~[Attribute],\n                                macros_allowed: bool)\n                                -> item_or_view_item {\n-        match *self.token {\n+        match self.token {\n             INTERPOLATED(token::nt_item(item)) => {\n                 self.bump();\n                 let new_attrs = vec::append(attrs, item.attrs);\n@@ -4802,7 +4807,7 @@ impl Parser {\n         lo : BytePos,\n         visibility : visibility\n     ) -> item_or_view_item {\n-        if macros_allowed && !token::is_any_keyword(self.token)\n+        if macros_allowed && !token::is_any_keyword(&self.token)\n                 && self.look_ahead(1, |t| *t == token::NOT)\n                 && (self.look_ahead(2, |t| is_plain_ident(t))\n                     || self.look_ahead(2, |t| *t == token::LPAREN)\n@@ -4816,15 +4821,15 @@ impl Parser {\n             // a 'special' identifier (like what `macro_rules!` uses)\n             // is optional. We should eventually unify invoc syntax\n             // and remove this.\n-            let id = if is_plain_ident(&*self.token) {\n+            let id = if is_plain_ident(&self.token) {\n                 self.parse_ident()\n             } else {\n                 token::special_idents::invalid // no special identifier\n             };\n             // eat a matched-delimiter token tree:\n-            let tts = match *self.token {\n+            let tts = match self.token {\n                 token::LPAREN | token::LBRACE => {\n-                    let ket = token::flip_delimiter(&*self.token);\n+                    let ket = token::flip_delimiter(&self.token);\n                     self.bump();\n                     self.parse_seq_to_end(&ket,\n                                           seq_sep_none(),\n@@ -4886,7 +4891,7 @@ impl Parser {\n     fn parse_view_path(&mut self) -> @view_path {\n         let lo = self.span.lo;\n \n-        if *self.token == token::LBRACE {\n+        if self.token == token::LBRACE {\n             // use {foo,bar}\n             let idents = self.parse_unspanned_seq(\n                 &token::LBRACE, &token::RBRACE,\n@@ -4904,12 +4909,12 @@ impl Parser {\n         let first_ident = self.parse_ident();\n         let mut path = ~[first_ident];\n         debug!(\"parsed view_path: {}\", self.id_to_str(first_ident));\n-        match *self.token {\n+        match self.token {\n           token::EQ => {\n             // x = foo::bar\n             self.bump();\n             path = ~[self.parse_ident()];\n-            while *self.token == token::MOD_SEP {\n+            while self.token == token::MOD_SEP {\n                 self.bump();\n                 let id = self.parse_ident();\n                 path.push(id);\n@@ -4933,10 +4938,10 @@ impl Parser {\n \n           token::MOD_SEP => {\n             // foo::bar or foo::{a,b,c} or foo::*\n-            while *self.token == token::MOD_SEP {\n+            while self.token == token::MOD_SEP {\n                 self.bump();\n \n-                match *self.token {\n+                match self.token {\n                   token::IDENT(i, _) => {\n                     self.bump();\n                     path.push(i);\n@@ -5009,7 +5014,7 @@ impl Parser {\n     // matches view_paths = view_path | view_path , view_paths\n     fn parse_view_paths(&mut self) -> ~[@view_path] {\n         let mut vp = ~[self.parse_view_path()];\n-        while *self.token == token::COMMA {\n+        while self.token == token::COMMA {\n             self.bump();\n             self.obsolete(*self.last_span, ObsoleteMultipleImport);\n             vp.push(self.parse_view_path());\n@@ -5114,7 +5119,7 @@ impl Parser {\n         loop {\n             match self.parse_foreign_item(attrs, macros_allowed) {\n                 iovi_none(returned_attrs) => {\n-                    if *self.token == token::RBRACE {\n+                    if self.token == token::RBRACE {\n                         attrs = returned_attrs;\n                         break\n                     }\n@@ -5164,7 +5169,7 @@ impl Parser {\n     }\n \n     pub fn parse_optional_str(&mut self) -> Option<(@str, ast::StrStyle)> {\n-        let (s, style) = match *self.token {\n+        let (s, style) = match self.token {\n             token::LIT_STR(s) => (s, ast::CookedStr),\n             token::LIT_STR_RAW(s, n) => (s, ast::RawStr(n)),\n             _ => return None"}]}