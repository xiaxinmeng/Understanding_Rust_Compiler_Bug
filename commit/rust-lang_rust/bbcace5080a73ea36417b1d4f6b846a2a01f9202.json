{"sha": "bbcace5080a73ea36417b1d4f6b846a2a01f9202", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiY2FjZTUwODBhNzNlYTM2NDE3YjFkNGY2Yjg0NmEyYTAxZjkyMDI=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-05-27T10:15:52Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-05-27T10:15:52Z"}, "message": "Use precomputed DFS of borrows that out of scope at a location.", "tree": {"sha": "a5cccc25e45f35b579528d935b59e3abaca69799", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5cccc25e45f35b579528d935b59e3abaca69799"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbcace5080a73ea36417b1d4f6b846a2a01f9202", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlsKhVgACgkQAXYLT59T\n8VTvUA/8C5cbZbqQGx3zylJhOSGSt4yo6f1d6WSKSYnsACGzT6rXKUjvb83Pbxko\n/YxZ8I/qyOkTgz/lFPdl1arsb7ADQ0hDqR2BskhXTbeyxEZjzGHWw+cUzy8ifpVU\nsUQp8uw9LB3WEVLPmSOXBm6VKL6HnMcR3Oqx6tgOe/AAO2oXqZNpQEBSL3mChAGP\nlYj0mal0lfxgWMRnbIzm1ycBeVQRKAv/R+p05VA1KIaUkS1bkNCh/V1aZYIe/KmB\nJdVftCwq99wFwwMUu2Ou64wU8Ee7IVNHq/iqrHYi4N4m9QK1n/iMG2h3Pua4NJDx\n9JPe+4Ztx+1hzB4mULiHf9c8eEVI5EGDlPqGucZ7eot33MQOKswN+ksGgMmRa928\nExb2XqylZNuFjxKfONnDQDo+iufaNTd9ptE3eiSZSYnNPAHxNqezv9J8pLyY5Hqw\nFwN1nN9EuL5Z2q5XnT+u5FJwgELBqBGxtxntCiiTvqlyg7cCXkHZx3rVkYG84s7J\nS3SDHD41EF9HkDTAkFPKf+HF5a9ea1ezwDwExNVvts3xanVn+lWoq6W+wxNzNQV4\n5ZnAykkKcQwT1NpCQS7GtoL9YaqUEruhG9oXimEMoyo7a1BczTJzQ9xockWLW3io\n1aGFtzcH2QKmqTPb8fvpBtESyjNk216ELXmEs1DxTnxMja4qkRU=\n=91NO\n-----END PGP SIGNATURE-----", "payload": "tree a5cccc25e45f35b579528d935b59e3abaca69799\nparent 3fd82a5e6b3a707610fdc878e2b5608340e4969a\nauthor David Wood <david@davidtw.co> 1527416152 +0100\ncommitter David Wood <david@davidtw.co> 1527416152 +0100\n\nUse precomputed DFS of borrows that out of scope at a location.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbcace5080a73ea36417b1d4f6b846a2a01f9202", "html_url": "https://github.com/rust-lang/rust/commit/bbcace5080a73ea36417b1d4f6b846a2a01f9202", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbcace5080a73ea36417b1d4f6b846a2a01f9202/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fd82a5e6b3a707610fdc878e2b5608340e4969a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fd82a5e6b3a707610fdc878e2b5608340e4969a", "html_url": "https://github.com/rust-lang/rust/commit/3fd82a5e6b3a707610fdc878e2b5608340e4969a"}], "stats": {"total": 130, "additions": 116, "deletions": 14}, "files": [{"sha": "7018ab345db4357618c0348eba8b5604a49711f0", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 116, "deletions": 14, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/bbcace5080a73ea36417b1d4f6b846a2a01f9202/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcace5080a73ea36417b1d4f6b846a2a01f9202/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=bbcace5080a73ea36417b1d4f6b846a2a01f9202", "patch": "@@ -15,12 +15,13 @@ use rustc;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n-use rustc::mir::{self, Location, Place, Mir};\n+use rustc::mir::{self, Location, Place, Mir, TerminatorKind};\n use rustc::ty::TyCtxt;\n-use rustc::ty::RegionKind;\n+use rustc::ty::{RegionKind, RegionVid};\n use rustc::ty::RegionKind::ReScope;\n \n use rustc_data_structures::bitslice::BitwiseOperator;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n@@ -46,9 +47,103 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     root_scope: Option<region::Scope>,\n \n     borrow_set: Rc<BorrowSet<'tcx>>,\n+    borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n \n     /// NLL region inference context with which NLL queries should be resolved\n-    nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n+    _nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n+}\n+\n+fn precompute_borrows_out_of_scope<'a, 'tcx>(\n+    mir: &'a Mir<'tcx>,\n+    regioncx: &Rc<RegionInferenceContext<'tcx>>,\n+    borrows_out_of_scope_at_location: &mut FxHashMap<Location, Vec<BorrowIndex>>,\n+    borrow_index: BorrowIndex,\n+    borrow_region: RegionVid,\n+    location: Location\n+) {\n+    // Start by dealing with the current location.\n+    if !regioncx.region_contains_point(borrow_region, location) {\n+        borrows_out_of_scope_at_location\n+            .entry(location.clone())\n+            .and_modify(|m| m.push(borrow_index))\n+            .or_insert(vec![ borrow_index ]);\n+    }\n+\n+    let bb_data = &mir[location.block];\n+    // If we are on the last statement, then check the terminator\n+    // to determine which location to proceed to.\n+    if location.statement_index == bb_data.statements.len() - 1 {\n+        if let Some(ref terminator) = bb_data.terminator {\n+            match terminator.kind {\n+                TerminatorKind::Goto { target } |\n+                TerminatorKind::FalseEdges { real_target: target, .. } |\n+                TerminatorKind::FalseUnwind { real_target: target, .. } => {\n+                    precompute_borrows_out_of_scope(\n+                        mir, regioncx, borrows_out_of_scope_at_location,\n+                        borrow_index, borrow_region, target.start_location()\n+                    );\n+                },\n+                TerminatorKind::SwitchInt { ref targets, .. } => {\n+                    for block in targets {\n+                        precompute_borrows_out_of_scope(\n+                            mir, regioncx, borrows_out_of_scope_at_location,\n+                            borrow_index, borrow_region, block.start_location()\n+                        );\n+                    }\n+                },\n+                TerminatorKind::Drop { target, unwind, .. } |\n+                TerminatorKind::DropAndReplace { target, unwind, .. } => {\n+                    precompute_borrows_out_of_scope(\n+                        mir, regioncx, borrows_out_of_scope_at_location,\n+                        borrow_index, borrow_region, target.start_location()\n+                    );\n+\n+                    if let Some(unwind_block) = unwind {\n+                        precompute_borrows_out_of_scope(\n+                            mir, regioncx, borrows_out_of_scope_at_location,\n+                            borrow_index, borrow_region, unwind_block.start_location()\n+                        );\n+                    }\n+                },\n+                TerminatorKind::Call { ref destination, cleanup, .. } => {\n+                    if let Some((_, block)) = destination  {\n+                        precompute_borrows_out_of_scope(\n+                            mir, regioncx, borrows_out_of_scope_at_location,\n+                            borrow_index, borrow_region, block.start_location()\n+                        );\n+                    }\n+\n+                    if let Some(block) = cleanup  {\n+                        precompute_borrows_out_of_scope(\n+                            mir, regioncx, borrows_out_of_scope_at_location,\n+                            borrow_index, borrow_region, block.start_location()\n+                        );\n+                    }\n+                },\n+                TerminatorKind::Assert { target, cleanup, .. } |\n+                TerminatorKind::Yield { resume: target, drop: cleanup, .. } => {\n+                    precompute_borrows_out_of_scope(\n+                        mir, regioncx, borrows_out_of_scope_at_location,\n+                        borrow_index, borrow_region, target.start_location()\n+                    );\n+\n+                    if let Some(block) = cleanup  {\n+                        precompute_borrows_out_of_scope(\n+                            mir, regioncx, borrows_out_of_scope_at_location,\n+                            borrow_index, borrow_region, block.start_location()\n+                        );\n+                    }\n+                },\n+                _ => {},\n+            };\n+        };\n+    // If we're not on the last statement, then go to the next\n+    // statement in this block.\n+    } else {\n+        precompute_borrows_out_of_scope(mir, regioncx, borrows_out_of_scope_at_location,\n+                                        borrow_index, borrow_region,\n+                                        location.successor_within_block());\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n@@ -65,18 +160,28 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             region::Scope::CallSite(tcx.hir.body(body_id).value.hir_id.local_id)\n         });\n \n+        let mut borrows_out_of_scope_at_location = FxHashMap();\n+        for (borrow_index, borrow_data) in borrow_set.borrows.iter_enumerated() {\n+            let borrow_region = borrow_data.region.to_region_vid();\n+            let location = borrow_set.borrows[borrow_index].reserve_location;\n+\n+            precompute_borrows_out_of_scope(mir, &nonlexical_regioncx,\n+                                            &mut borrows_out_of_scope_at_location,\n+                                            borrow_index, borrow_region, location);\n+        }\n+\n         Borrows {\n             tcx: tcx,\n             mir: mir,\n             borrow_set: borrow_set.clone(),\n+            borrows_out_of_scope_at_location,\n             scope_tree,\n             root_scope,\n-            nonlexical_regioncx,\n+            _nonlexical_regioncx: nonlexical_regioncx,\n         }\n     }\n \n     crate fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> { &self.borrow_set.borrows }\n-\n     pub fn scope_tree(&self) -> &Lrc<region::ScopeTree> { &self.scope_tree }\n \n     pub fn location(&self, idx: BorrowIndex) -> &Location {\n@@ -89,23 +194,20 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     fn kill_loans_out_of_scope_at_location(&self,\n                                            sets: &mut BlockSets<BorrowIndex>,\n                                            location: Location) {\n-        let regioncx = &self.nonlexical_regioncx;\n-\n         // NOTE: The state associated with a given `location`\n-        // reflects the dataflow on entry to the statement. If it\n-        // does not contain `borrow_region`, then then that means\n-        // that the statement at `location` kills the borrow.\n+        // reflects the dataflow on entry to the statement.\n+        // Iterate over each of the borrows that we've precomputed\n+        // to have went out of scope at this location and kill them.\n         //\n         // We are careful always to call this function *before* we\n         // set up the gen-bits for the statement or\n         // termanator. That way, if the effect of the statement or\n         // terminator *does* introduce a new loan of the same\n         // region, then setting that gen-bit will override any\n         // potential kill introduced here.\n-        for (borrow_index, borrow_data) in self.borrow_set.borrows.iter_enumerated() {\n-            let borrow_region = borrow_data.region.to_region_vid();\n-            if !regioncx.region_contains_point(borrow_region, location) {\n-                sets.kill(&borrow_index);\n+        if let Some(indices) = self.borrows_out_of_scope_at_location.get(&location) {\n+            for index in indices {\n+                sets.kill(&index);\n             }\n         }\n     }"}]}