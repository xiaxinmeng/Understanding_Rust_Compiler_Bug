{"sha": "ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "node_id": "C_kwDOAAsO6NoAKGVhMjE4MzkyYTRjZTExOWM0ZGZjZDhmYjk0YTdmZWU3N2Y3NmYyYzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-17T01:14:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-17T01:14:39Z"}, "message": "Auto merge of #108145 - matthiaskrgr:rollup-bgadak1, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #104068 (rustdoc: Add PartialOrd trait to doc comment explanation)\n - #107489 (Implement partial support for non-lifetime binders)\n - #107905 (Pass arguments to `x` subcommands with `--`)\n - #108009 (Move some tests)\n - #108086 (wasm: Register the `relaxed-simd` target feature)\n - #108104 (don't into self)\n - #108133 (Small cleanups around `EarlyBinder`)\n - #108136 (Do not ICE on unmet trait alias impl bounds)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "78b5939c0ed6ee6449bb4d7c904d25edd3f05098", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78b5939c0ed6ee6449bb4d7c904d25edd3f05098"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "html_url": "https://github.com/rust-lang/rust/commit/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "947b696ce0ce42c98b8fb82ffa0735ade051466c", "url": "https://api.github.com/repos/rust-lang/rust/commits/947b696ce0ce42c98b8fb82ffa0735ade051466c", "html_url": "https://github.com/rust-lang/rust/commit/947b696ce0ce42c98b8fb82ffa0735ade051466c"}, {"sha": "ecdb7bcee855107f5edaf29a00dadeed3a23caaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecdb7bcee855107f5edaf29a00dadeed3a23caaa", "html_url": "https://github.com/rust-lang/rust/commit/ecdb7bcee855107f5edaf29a00dadeed3a23caaa"}], "stats": {"total": 1192, "additions": 822, "deletions": 370}, "files": [{"sha": "d1ae8c1fdbd9e246c987adcf9a9e9f6cd667271b", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -294,27 +294,6 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn check_late_bound_lifetime_defs(&self, params: &[GenericParam]) {\n-        // Check only lifetime parameters are present and that the lifetime\n-        // parameters that are present have no bounds.\n-        let non_lt_param_spans: Vec<_> = params\n-            .iter()\n-            .filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => {\n-                    if !param.bounds.is_empty() {\n-                        let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-                        self.session.emit_err(ForbiddenLifetimeBound { spans });\n-                    }\n-                    None\n-                }\n-                _ => Some(param.ident.span),\n-            })\n-            .collect();\n-        if !non_lt_param_spans.is_empty() {\n-            self.session.emit_err(ForbiddenNonLifetimeParam { spans: non_lt_param_spans });\n-        }\n-    }\n-\n     fn check_fn_decl(&self, fn_decl: &FnDecl, self_semantic: SelfSemantic) {\n         self.check_decl_num_args(fn_decl);\n         self.check_decl_cvaradic_pos(fn_decl);\n@@ -745,7 +724,6 @@ impl<'a> AstValidator<'a> {\n                     )\n                     .emit();\n                 });\n-                self.check_late_bound_lifetime_defs(&bfty.generic_params);\n                 if let Extern::Implicit(_) = bfty.ext {\n                     let sig_span = self.session.source_map().next_point(ty.span.shrink_to_lo());\n                     self.maybe_lint_missing_abi(sig_span, ty.id);\n@@ -1318,9 +1296,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 WherePredicate::BoundPredicate(bound_pred) => {\n-                    // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n-                    self.check_late_bound_lifetime_defs(&bound_pred.bound_generic_params);\n-\n                     // This is slightly complicated. Our representation for poly-trait-refs contains a single\n                     // binder and thus we only allow a single level of quantification. However,\n                     // the syntax of Rust permits quantification in two places in where clauses,\n@@ -1396,11 +1371,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_param_bound(self, bound)\n     }\n \n-    fn visit_poly_trait_ref(&mut self, t: &'a PolyTraitRef) {\n-        self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n-        visit::walk_poly_trait_ref(self, t);\n-    }\n-\n     fn visit_variant_data(&mut self, s: &'a VariantData) {\n         self.with_banned_assoc_ty_bound(|this| visit::walk_struct_def(this, s))\n     }\n@@ -1437,10 +1407,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 .emit();\n         }\n \n-        if let FnKind::Closure(ClosureBinder::For { generic_params, .. }, ..) = fk {\n-            self.check_late_bound_lifetime_defs(generic_params);\n-        }\n-\n         if let FnKind::Fn(\n             _,\n             _,"}, {"sha": "3af2ef4e7271eae2db53c73473882d5f205e8750", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -11,6 +11,8 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi;\n \n+use crate::errors::ForbiddenLifetimeBound;\n+\n macro_rules! gate_feature_fn {\n     ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $help: expr) => {{\n         let (visitor, has_feature, span, name, explain, help) =\n@@ -136,6 +138,34 @@ impl<'a> PostExpansionVisitor<'a> {\n         }\n         ImplTraitVisitor { vis: self }.visit_ty(ty);\n     }\n+\n+    fn check_late_bound_lifetime_defs(&self, params: &[ast::GenericParam]) {\n+        // Check only lifetime parameters are present and that the lifetime\n+        // parameters that are present have no bounds.\n+        let non_lt_param_spans: Vec<_> = params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                ast::GenericParamKind::Lifetime { .. } => None,\n+                _ => Some(param.ident.span),\n+            })\n+            .collect();\n+        // FIXME: gate_feature_post doesn't really handle multispans...\n+        if !non_lt_param_spans.is_empty() && !self.features.non_lifetime_binders {\n+            feature_err(\n+                &self.sess.parse_sess,\n+                sym::non_lifetime_binders,\n+                non_lt_param_spans,\n+                rustc_errors::fluent::ast_passes_forbidden_non_lifetime_param,\n+            )\n+            .emit();\n+        }\n+        for param in params {\n+            if !param.bounds.is_empty() {\n+                let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n+                self.sess.emit_err(ForbiddenLifetimeBound { spans });\n+            }\n+        }\n+    }\n }\n \n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n@@ -147,7 +177,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ..\n         }) = attr_info\n         {\n-            gate_feature_fn!(self, has_feature, attr.span, *name, descr);\n+            gate_feature_fn!(self, has_feature, attr.span, *name, *descr);\n         }\n         // Check unstable flavors of the `#[doc]` attribute.\n         if attr.has_name(sym::doc) {\n@@ -306,6 +336,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::TyKind::BareFn(bare_fn_ty) => {\n                 // Function pointers cannot be `const`\n                 self.check_extern(bare_fn_ty.ext, ast::Const::No);\n+                self.check_late_bound_lifetime_defs(&bare_fn_ty.generic_params);\n             }\n             ast::TyKind::Never => {\n                 gate_feature_post!(&self, never_type, ty.span, \"the `!` type is experimental\");\n@@ -318,6 +349,19 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_ty(self, ty)\n     }\n \n+    fn visit_generics(&mut self, g: &'a ast::Generics) {\n+        for predicate in &g.where_clause.predicates {\n+            match predicate {\n+                ast::WherePredicate::BoundPredicate(bound_pred) => {\n+                    // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n+                    self.check_late_bound_lifetime_defs(&bound_pred.bound_generic_params);\n+                }\n+                _ => {}\n+            }\n+        }\n+        visit::walk_generics(self, g);\n+    }\n+\n     fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FnRetTy) {\n         if let ast::FnRetTy::Ty(output_ty) = ret_ty {\n             if let ast::TyKind::Never = output_ty.kind {\n@@ -437,12 +481,21 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_pat(self, pattern)\n     }\n \n+    fn visit_poly_trait_ref(&mut self, t: &'a ast::PolyTraitRef) {\n+        self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n+        visit::walk_poly_trait_ref(self, t);\n+    }\n+\n     fn visit_fn(&mut self, fn_kind: FnKind<'a>, span: Span, _: NodeId) {\n         if let Some(header) = fn_kind.header() {\n             // Stability of const fn methods are covered in `visit_assoc_item` below.\n             self.check_extern(header.ext, header.constness);\n         }\n \n+        if let FnKind::Closure(ast::ClosureBinder::For { generic_params, .. }, ..) = fn_kind {\n+            self.check_late_bound_lifetime_defs(generic_params);\n+        }\n+\n         if fn_kind.ctxt() != Some(FnCtxt::Foreign) && fn_kind.decl().c_variadic() {\n             gate_feature_post!(&self, c_variadic, span, \"C-variadic functions are unstable\");\n         }"}, {"sha": "3d240108b4ab103585579176758d4c8e330a2377", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -731,7 +731,7 @@ pub fn eval_condition(\n                             sess,\n                             sym::cfg_target_compact,\n                             cfg.span,\n-                            &\"compact `cfg(target(..))` is experimental and subject to change\"\n+                            \"compact `cfg(target(..))` is experimental and subject to change\"\n                         ).emit();\n                     }\n "}, {"sha": "0432a9c5a129c2088628835a3dc3e05c99e5c7d8", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -286,6 +286,7 @@ const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"mutable-globals\", Some(sym::wasm_target_feature)),\n     (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n     (\"reference-types\", Some(sym::wasm_target_feature)),\n+    (\"relaxed-simd\", Some(sym::wasm_target_feature)),\n     (\"sign-ext\", Some(sym::wasm_target_feature)),\n     (\"simd128\", None),\n     // tidy-alphabetical-end"}, {"sha": "7122ccdcd2e9f692acbd17e15d17334e2dd55074", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -473,6 +473,8 @@ declare_features! (\n     (active, no_sanitize, \"1.42.0\", Some(39699), None),\n     /// Allows using the `non_exhaustive_omitted_patterns` lint.\n     (active, non_exhaustive_omitted_patterns_lint, \"1.57.0\", Some(89554), None),\n+    /// Allows `for<T>` binders in where-clauses\n+    (incomplete, non_lifetime_binders, \"CURRENT_RUSTC_VERSION\", Some(1), None),\n     /// Allows making `dyn Trait` well-formed even if `Trait` is not object safe.\n     /// In that case, `dyn Trait: Trait` does not hold. Moreover, coercions and\n     /// casts in safe Rust to `dyn Trait` for such a `Trait` is also forbidden."}, {"sha": "221721f5909b8e7e16ba4c63f235935687834f05", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 75, "deletions": 16, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -14,7 +14,7 @@ use crate::errors::{\n     AmbiguousLifetimeBound, MultipleRelaxedDefaultBounds, TraitObjectDeclaredWithNoTraits,\n     TypeofReservedKeywordUsed, ValueOfAssociatedStructAlreadySpecified,\n };\n-use crate::middle::resolve_lifetime as rl;\n+use crate::middle::resolve_bound_vars as rbv;\n use crate::require_c_abi_if_c_variadic;\n use rustc_ast::TraitObjectSyntax;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -225,10 +225,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let tcx = self.tcx();\n         let lifetime_name = |def_id| tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id));\n \n-        match tcx.named_region(lifetime.hir_id) {\n-            Some(rl::Region::Static) => tcx.lifetimes.re_static,\n+        match tcx.named_bound_var(lifetime.hir_id) {\n+            Some(rbv::ResolvedArg::StaticLifetime) => tcx.lifetimes.re_static,\n \n-            Some(rl::Region::LateBound(debruijn, index, def_id)) => {\n+            Some(rbv::ResolvedArg::LateBound(debruijn, index, def_id)) => {\n                 let name = lifetime_name(def_id.expect_local());\n                 let br = ty::BoundRegion {\n                     var: ty::BoundVar::from_u32(index),\n@@ -237,15 +237,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.mk_re_late_bound(debruijn, br)\n             }\n \n-            Some(rl::Region::EarlyBound(def_id)) => {\n+            Some(rbv::ResolvedArg::EarlyBound(def_id)) => {\n                 let name = tcx.hir().ty_param_name(def_id.expect_local());\n                 let item_def_id = tcx.hir().ty_param_owner(def_id.expect_local());\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n                 tcx.mk_re_early_bound(ty::EarlyBoundRegion { def_id, index, name })\n             }\n \n-            Some(rl::Region::Free(scope, id)) => {\n+            Some(rbv::ResolvedArg::Free(scope, id)) => {\n                 let name = lifetime_name(id.expect_local());\n                 tcx.mk_re_free(scope, ty::BrNamed(id, name))\n \n@@ -1607,7 +1607,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             self.ast_region_to_region(lifetime, None)\n         } else {\n             self.compute_object_lifetime_bound(span, existential_predicates).unwrap_or_else(|| {\n-                if tcx.named_region(lifetime.hir_id).is_some() {\n+                if tcx.named_bound_var(lifetime.hir_id).is_some() {\n                     self.ast_region_to_region(lifetime, None)\n                 } else {\n                     self.re_infer(None, span).unwrap_or_else(|| {\n@@ -2600,6 +2600,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         opt_self_ty: Option<Ty<'tcx>>,\n         path: &hir::Path<'_>,\n+        hir_id: hir::HirId,\n         permit_variants: bool,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n@@ -2663,11 +2664,25 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 });\n \n-                let def_id = def_id.expect_local();\n-                let item_def_id = tcx.hir().ty_param_owner(def_id);\n-                let generics = tcx.generics_of(item_def_id);\n-                let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n-                tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id))\n+                match tcx.named_bound_var(hir_id) {\n+                    Some(rbv::ResolvedArg::LateBound(debruijn, index, _)) => {\n+                        let name =\n+                            tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n+                        let br = ty::BoundTy {\n+                            var: ty::BoundVar::from_u32(index),\n+                            kind: ty::BoundTyKind::Param(def_id, name),\n+                        };\n+                        tcx.mk_ty(ty::Bound(debruijn, br))\n+                    }\n+                    Some(rbv::ResolvedArg::EarlyBound(_)) => {\n+                        let def_id = def_id.expect_local();\n+                        let item_def_id = tcx.hir().ty_param_owner(def_id);\n+                        let generics = tcx.generics_of(item_def_id);\n+                        let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n+                        tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id))\n+                    }\n+                    arg => bug!(\"unexpected bound var resolution for {hir_id:?}: {arg:?}\"),\n+                }\n             }\n             Res::SelfTyParam { .. } => {\n                 // `Self` in trait or type alias.\n@@ -2870,27 +2885,50 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::TyKind::BareFn(bf) => {\n                 require_c_abi_if_c_variadic(tcx, bf.decl, bf.abi, ast_ty.span);\n \n-                tcx.mk_fn_ptr(self.ty_of_fn(\n+                let fn_ptr_ty = tcx.mk_fn_ptr(self.ty_of_fn(\n                     ast_ty.hir_id,\n                     bf.unsafety,\n                     bf.abi,\n                     bf.decl,\n                     None,\n                     Some(ast_ty),\n-                ))\n+                ));\n+\n+                if let Some(guar) =\n+                    deny_non_region_late_bound(tcx, bf.generic_params, \"function pointer\")\n+                {\n+                    tcx.ty_error_with_guaranteed(guar)\n+                } else {\n+                    fn_ptr_ty\n+                }\n             }\n             hir::TyKind::TraitObject(bounds, lifetime, repr) => {\n                 self.maybe_lint_bare_trait(ast_ty, in_path);\n                 let repr = match repr {\n                     TraitObjectSyntax::Dyn | TraitObjectSyntax::None => ty::Dyn,\n                     TraitObjectSyntax::DynStar => ty::DynStar,\n                 };\n-                self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime, borrowed, repr)\n+\n+                let object_ty = self.conv_object_ty_poly_trait_ref(\n+                    ast_ty.span,\n+                    bounds,\n+                    lifetime,\n+                    borrowed,\n+                    repr,\n+                );\n+\n+                if let Some(guar) = bounds.iter().find_map(|trait_ref| {\n+                    deny_non_region_late_bound(tcx, trait_ref.bound_generic_params, \"trait object\")\n+                }) {\n+                    tcx.ty_error_with_guaranteed(guar)\n+                } else {\n+                    object_ty\n+                }\n             }\n             hir::TyKind::Path(hir::QPath::Resolved(maybe_qself, path)) => {\n                 debug!(?maybe_qself, ?path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.ast_ty_to_ty(qself));\n-                self.res_to_ty(opt_self_ty, path, false)\n+                self.res_to_ty(opt_self_ty, path, ast_ty.hir_id, false)\n             }\n             &hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n                 let opaque_ty = tcx.hir().item(item_id);\n@@ -3346,3 +3384,24 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n }\n+\n+fn deny_non_region_late_bound(\n+    tcx: TyCtxt<'_>,\n+    params: &[hir::GenericParam<'_>],\n+    where_: &str,\n+) -> Option<ErrorGuaranteed> {\n+    params.iter().find_map(|bad_param| {\n+        let what = match bad_param.kind {\n+            hir::GenericParamKind::Type { .. } => \"type\",\n+            hir::GenericParamKind::Const { .. } => \"const\",\n+            hir::GenericParamKind::Lifetime { .. } => return None,\n+        };\n+\n+        let mut diag = tcx.sess.struct_span_err(\n+            bad_param.span,\n+            format!(\"late-bound {what} parameter not allowed on {where_} types\"),\n+        );\n+\n+        Some(if tcx.features().non_lifetime_binders { diag.emit() } else { diag.delay_as_bug() })\n+    })\n+}"}, {"sha": "8ebe576a224b3ad6f81c71e9d792f549a0d047a3", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -41,8 +41,8 @@ use std::iter;\n \n mod generics_of;\n mod item_bounds;\n-mod lifetimes;\n mod predicates_of;\n+mod resolve_bound_vars;\n mod type_of;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -53,7 +53,7 @@ fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n }\n \n pub fn provide(providers: &mut Providers) {\n-    lifetimes::provide(providers);\n+    resolve_bound_vars::provide(providers);\n     *providers = Providers {\n         opt_const_param_of: type_of::opt_const_param_of,\n         type_of: type_of::type_of,"}, {"sha": "7bcaeadbcf67b0d0fa648eb7359bdd378587327b", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1,4 +1,4 @@\n-use crate::middle::resolve_lifetime as rl;\n+use crate::middle::resolve_bound_vars as rbv;\n use hir::{\n     intravisit::{self, Visitor},\n     GenericParamKind, HirId, Node,\n@@ -394,10 +394,11 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n                 return;\n             }\n \n-            match self.tcx.named_region(lt.hir_id) {\n-                Some(rl::Region::Static | rl::Region::EarlyBound(..)) => {}\n-                Some(rl::Region::LateBound(debruijn, _, _)) if debruijn < self.outer_index => {}\n-                Some(rl::Region::LateBound(..) | rl::Region::Free(..)) | None => {\n+            match self.tcx.named_bound_var(lt.hir_id) {\n+                Some(rbv::ResolvedArg::StaticLifetime | rbv::ResolvedArg::EarlyBound(..)) => {}\n+                Some(rbv::ResolvedArg::LateBound(debruijn, _, _))\n+                    if debruijn < self.outer_index => {}\n+                Some(rbv::ResolvedArg::LateBound(..) | rbv::ResolvedArg::Free(..)) | None => {\n                     self.has_late_bound_regions = Some(lt.ident.span);\n                 }\n             }"}, {"sha": "8c388040fbf8676d5d6e8e72ab0ba6a818fd0312", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "renamed", "additions": 223, "deletions": 180, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -16,67 +16,69 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericArg, GenericParam, GenericParamKind, HirIdMap, LifetimeName, Node};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::resolve_lifetime::*;\n+use rustc_middle::middle::resolve_bound_vars::*;\n use rustc_middle::ty::{self, ir::TypeVisitor, DefIdTree, TyCtxt, TypeSuperVisitable};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use std::fmt;\n \n trait RegionExt {\n-    fn early(param: &GenericParam<'_>) -> (LocalDefId, Region);\n+    fn early(param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg);\n \n-    fn late(index: u32, param: &GenericParam<'_>) -> (LocalDefId, Region);\n+    fn late(index: u32, param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg);\n \n     fn id(&self) -> Option<DefId>;\n \n-    fn shifted(self, amount: u32) -> Region;\n+    fn shifted(self, amount: u32) -> ResolvedArg;\n }\n \n-impl RegionExt for Region {\n-    fn early(param: &GenericParam<'_>) -> (LocalDefId, Region) {\n-        debug!(\"Region::early: def_id={:?}\", param.def_id);\n-        (param.def_id, Region::EarlyBound(param.def_id.to_def_id()))\n+impl RegionExt for ResolvedArg {\n+    fn early(param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg) {\n+        debug!(\"ResolvedArg::early: def_id={:?}\", param.def_id);\n+        (param.def_id, ResolvedArg::EarlyBound(param.def_id.to_def_id()))\n     }\n \n-    fn late(idx: u32, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n+    fn late(idx: u32, param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg) {\n         let depth = ty::INNERMOST;\n         debug!(\n-            \"Region::late: idx={:?}, param={:?} depth={:?} def_id={:?}\",\n+            \"ResolvedArg::late: idx={:?}, param={:?} depth={:?} def_id={:?}\",\n             idx, param, depth, param.def_id,\n         );\n-        (param.def_id, Region::LateBound(depth, idx, param.def_id.to_def_id()))\n+        (param.def_id, ResolvedArg::LateBound(depth, idx, param.def_id.to_def_id()))\n     }\n \n     fn id(&self) -> Option<DefId> {\n         match *self {\n-            Region::Static => None,\n+            ResolvedArg::StaticLifetime => None,\n \n-            Region::EarlyBound(id) | Region::LateBound(_, _, id) | Region::Free(_, id) => Some(id),\n+            ResolvedArg::EarlyBound(id)\n+            | ResolvedArg::LateBound(_, _, id)\n+            | ResolvedArg::Free(_, id) => Some(id),\n         }\n     }\n \n-    fn shifted(self, amount: u32) -> Region {\n+    fn shifted(self, amount: u32) -> ResolvedArg {\n         match self {\n-            Region::LateBound(debruijn, idx, id) => {\n-                Region::LateBound(debruijn.shifted_in(amount), idx, id)\n+            ResolvedArg::LateBound(debruijn, idx, id) => {\n+                ResolvedArg::LateBound(debruijn.shifted_in(amount), idx, id)\n             }\n             _ => self,\n         }\n     }\n }\n \n-/// Maps the id of each lifetime reference to the lifetime decl\n+/// Maps the id of each bound variable reference to the variable decl\n /// that it corresponds to.\n ///\n-/// FIXME. This struct gets converted to a `ResolveLifetimes` for\n+/// FIXME. This struct gets converted to a `ResolveBoundVars` for\n /// actual use. It has the same data, but indexed by `LocalDefId`. This\n /// is silly.\n #[derive(Debug, Default)]\n-struct NamedRegionMap {\n-    // maps from every use of a named (not anonymous) lifetime to a\n-    // `Region` describing how that region is bound\n-    defs: HirIdMap<Region>,\n+struct NamedVarMap {\n+    // maps from every use of a named (not anonymous) bound var to a\n+    // `ResolvedArg` describing how that variable is bound\n+    defs: HirIdMap<ResolvedArg>,\n \n     // Maps relevant hir items to the bound vars on them. These include:\n     // - function defs\n@@ -87,9 +89,9 @@ struct NamedRegionMap {\n     late_bound_vars: HirIdMap<Vec<ty::BoundVariableKind>>,\n }\n \n-struct LifetimeContext<'a, 'tcx> {\n+struct BoundVarContext<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    map: &'a mut NamedRegionMap,\n+    map: &'a mut NamedVarMap,\n     scope: ScopeRef<'a>,\n }\n \n@@ -102,7 +104,7 @@ enum Scope<'a> {\n     Binder {\n         /// We use an IndexMap here because we want these lifetimes in order\n         /// for diagnostics.\n-        lifetimes: FxIndexMap<LocalDefId, Region>,\n+        bound_vars: FxIndexMap<LocalDefId, ResolvedArg>,\n \n         scope_type: BinderScopeType,\n \n@@ -141,7 +143,7 @@ enum Scope<'a> {\n     /// inferred in a function body or potentially error outside one),\n     /// for the default choice of lifetime in a trait object type.\n     ObjectLifetimeDefault {\n-        lifetime: Option<Region>,\n+        lifetime: Option<ResolvedArg>,\n         s: ScopeRef<'a>,\n     },\n \n@@ -150,7 +152,7 @@ enum Scope<'a> {\n     /// lifetimes encountered when identifying the trait that an associated type\n     /// is declared on.\n     Supertrait {\n-        lifetimes: Vec<ty::BoundVariableKind>,\n+        bound_vars: Vec<ty::BoundVariableKind>,\n         s: ScopeRef<'a>,\n     },\n \n@@ -185,9 +187,9 @@ struct TruncatedScopeDebug<'a>(&'a Scope<'a>);\n impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.0 {\n-            Scope::Binder { lifetimes, scope_type, hir_id, where_bound_origin, s: _ } => f\n+            Scope::Binder { bound_vars, scope_type, hir_id, where_bound_origin, s: _ } => f\n                 .debug_struct(\"Binder\")\n-                .field(\"lifetimes\", lifetimes)\n+                .field(\"bound_vars\", bound_vars)\n                 .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n                 .field(\"where_bound_origin\", where_bound_origin)\n@@ -202,9 +204,9 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"lifetime\", lifetime)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n-            Scope::Supertrait { lifetimes, s: _ } => f\n+            Scope::Supertrait { bound_vars, s: _ } => f\n                 .debug_struct(\"Supertrait\")\n-                .field(\"lifetimes\", lifetimes)\n+                .field(\"bound_vars\", bound_vars)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::TraitRefBoundary { s: _ } => f.debug_struct(\"TraitRefBoundary\").finish(),\n@@ -219,27 +221,27 @@ type ScopeRef<'a> = &'a Scope<'a>;\n \n pub(crate) fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n-        resolve_lifetimes,\n+        resolve_bound_vars,\n \n-        named_region_map: |tcx, id| tcx.resolve_lifetimes(id).defs.get(&id),\n+        named_variable_map: |tcx, id| tcx.resolve_bound_vars(id).defs.get(&id),\n         is_late_bound_map,\n         object_lifetime_default,\n-        late_bound_vars_map: |tcx, id| tcx.resolve_lifetimes(id).late_bound_vars.get(&id),\n+        late_bound_vars_map: |tcx, id| tcx.resolve_bound_vars(id).late_bound_vars.get(&id),\n \n         ..*providers\n     };\n }\n \n-/// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n+/// Computes the `ResolveBoundVars` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n-/// `named_region_map`, `is_late_bound_map`, etc.\n+/// `named_variable_map`, `is_late_bound_map`, etc.\n #[instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLifetimes {\n-    let mut named_region_map =\n-        NamedRegionMap { defs: Default::default(), late_bound_vars: Default::default() };\n-    let mut visitor = LifetimeContext {\n+fn resolve_bound_vars(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveBoundVars {\n+    let mut named_variable_map =\n+        NamedVarMap { defs: Default::default(), late_bound_vars: Default::default() };\n+    let mut visitor = BoundVarContext {\n         tcx,\n-        map: &mut named_region_map,\n+        map: &mut named_variable_map,\n         scope: &Scope::Root { opt_parent_item: None },\n     };\n     match tcx.hir().owner(local_def_id) {\n@@ -260,13 +262,13 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLife\n         hir::OwnerNode::Crate(_) => {}\n     }\n \n-    let mut rl = ResolveLifetimes::default();\n+    let mut rl = ResolveBoundVars::default();\n \n-    for (hir_id, v) in named_region_map.defs {\n+    for (hir_id, v) in named_variable_map.defs {\n         let map = rl.defs.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n-    for (hir_id, v) in named_region_map.late_bound_vars {\n+    for (hir_id, v) in named_variable_map.late_bound_vars {\n         let map = rl.late_bound_vars.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n@@ -276,21 +278,33 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLife\n     rl\n }\n \n-fn late_region_as_bound_region(tcx: TyCtxt<'_>, region: &Region) -> ty::BoundVariableKind {\n-    match region {\n-        Region::LateBound(_, _, def_id) => {\n+fn late_arg_as_bound_arg<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    arg: &ResolvedArg,\n+    param: &GenericParam<'tcx>,\n+) -> ty::BoundVariableKind {\n+    match arg {\n+        ResolvedArg::LateBound(_, _, def_id) => {\n             let name = tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n-            ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n+                }\n+                GenericParamKind::Type { .. } => {\n+                    ty::BoundVariableKind::Ty(ty::BoundTyKind::Param(*def_id, name))\n+                }\n+                GenericParamKind::Const { .. } => ty::BoundVariableKind::Const,\n+            }\n         }\n-        _ => bug!(\"{:?} is not a late region\", region),\n+        _ => bug!(\"{:?} is not a late argument\", arg),\n     }\n }\n \n-impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n+impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n     /// Returns the binders in scope and the type of `Binder` that should be created for a poly trait ref.\n     fn poly_trait_ref_binder_info(&mut self) -> (Vec<ty::BoundVariableKind>, BinderScopeType) {\n         let mut scope = self.scope;\n-        let mut supertrait_lifetimes = vec![];\n+        let mut supertrait_bound_vars = vec![];\n         loop {\n             match scope {\n                 Scope::Body { .. } | Scope::Root { .. } => {\n@@ -301,29 +315,29 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Supertrait { s, lifetimes } => {\n-                    supertrait_lifetimes = lifetimes.clone();\n+                Scope::Supertrait { s, bound_vars } => {\n+                    supertrait_bound_vars = bound_vars.clone();\n                     scope = s;\n                 }\n \n                 Scope::TraitRefBoundary { .. } => {\n                     // We should only see super trait lifetimes if there is a `Binder` above\n-                    assert!(supertrait_lifetimes.is_empty());\n+                    assert!(supertrait_bound_vars.is_empty());\n                     break (vec![], BinderScopeType::Normal);\n                 }\n \n                 Scope::Binder { hir_id, .. } => {\n                     // Nested poly trait refs have the binders concatenated\n                     let mut full_binders =\n                         self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                    full_binders.extend(supertrait_lifetimes.into_iter());\n+                    full_binders.extend(supertrait_bound_vars.into_iter());\n                     break (full_binders, BinderScopeType::Concatenating);\n                 }\n             }\n         }\n     }\n }\n-impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n     type NestedFilter = nested_filter::OnlyBodies;\n \n     fn nested_visit_map(&mut self) -> Self::Map {\n@@ -386,22 +400,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) =\n+            let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) =\n                 bound_generic_params\n                     .iter()\n-                    .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n                     .enumerate()\n                     .map(|(late_bound_idx, param)| {\n-                        let pair = Region::late(late_bound_idx as u32, param);\n-                        let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                        let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                        let r = late_arg_as_bound_arg(self.tcx, &pair.1, param);\n                         (pair, r)\n                     })\n                     .unzip();\n \n             self.record_late_bound_vars(e.hir_id, binders);\n             let scope = Scope::Binder {\n                 hir_id: e.hir_id,\n-                lifetimes,\n+                bound_vars,\n                 s: self.scope,\n                 scope_type: BinderScopeType::Normal,\n                 where_bound_origin: None,\n@@ -461,7 +474,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // conservatively add all resolved lifetimes. Otherwise we run into problems in\n                 // cases like `type Foo<'a> = impl Bar<As = impl Baz + 'a>`.\n                 let parent_item = self.tcx.hir().get_parent_item(item.hir_id());\n-                let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(parent_item);\n+                let resolved_lifetimes: &ResolveBoundVars =\n+                    self.tcx.resolve_bound_vars(parent_item);\n                 // We need to add *all* deps, since opaque tys may want them from *us*\n                 for (&owner, defs) in resolved_lifetimes.defs.iter() {\n                     defs.iter().for_each(|(&local_id, region)| {\n@@ -478,35 +492,33 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                origin: hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_),\n+                origin: hir::OpaqueTyOrigin::FnReturn(parent) | hir::OpaqueTyOrigin::AsyncFn(parent),\n                 generics,\n                 ..\n             }) => {\n                 // We want to start our early-bound indices at the end of the parent scope,\n                 // not including any parent `impl Trait`s.\n-                let mut lifetimes = FxIndexMap::default();\n+                let mut bound_vars = FxIndexMap::default();\n                 debug!(?generics.params);\n                 for param in generics.params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let (def_id, reg) = Region::early(&param);\n-                            lifetimes.insert(def_id, reg);\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n-                    }\n+                    let (def_id, reg) = ResolvedArg::early(&param);\n+                    bound_vars.insert(def_id, reg);\n                 }\n \n-                let scope = Scope::Binder {\n-                    hir_id: item.hir_id(),\n-                    lifetimes,\n-                    s: self.scope,\n-                    scope_type: BinderScopeType::Normal,\n-                    where_bound_origin: None,\n-                };\n+                let scope = Scope::Root { opt_parent_item: Some(parent) };\n                 self.with(scope, |this| {\n-                    let scope = Scope::TraitRefBoundary { s: this.scope };\n-                    this.with(scope, |this| intravisit::walk_item(this, item))\n-                });\n+                    let scope = Scope::Binder {\n+                        hir_id: item.hir_id(),\n+                        bound_vars,\n+                        s: this.scope,\n+                        scope_type: BinderScopeType::Normal,\n+                        where_bound_origin: None,\n+                    };\n+                    this.with(scope, |this| {\n+                        let scope = Scope::TraitRefBoundary { s: this.scope };\n+                        this.with(scope, |this| intravisit::walk_item(this, item))\n+                    });\n+                })\n             }\n             hir::ItemKind::TyAlias(_, generics)\n             | hir::ItemKind::Enum(_, generics)\n@@ -516,18 +528,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::TraitAlias(generics, ..)\n             | hir::ItemKind::Impl(&hir::Impl { generics, .. }) => {\n                 // These kinds of items have only early-bound lifetime parameters.\n-                let lifetimes = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(Region::early(param)),\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n-                    })\n-                    .collect();\n+                let bound_vars = generics.params.iter().map(ResolvedArg::early).collect();\n                 self.record_late_bound_vars(item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     scope_type: BinderScopeType::Normal,\n                     s: self.scope,\n                     where_bound_origin: None,\n@@ -562,21 +567,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         match ty.kind {\n             hir::TyKind::BareFn(c) => {\n-                let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n+                let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n-                    .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n                     .enumerate()\n                     .map(|(late_bound_idx, param)| {\n-                        let pair = Region::late(late_bound_idx as u32, param);\n-                        let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                        let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                        let r = late_arg_as_bound_arg(self.tcx, &pair.1, param);\n                         (pair, r)\n                     })\n                     .unzip();\n                 self.record_late_bound_vars(ty.hir_id, binders);\n                 let scope = Scope::Binder {\n                     hir_id: ty.hir_id,\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -674,7 +678,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     // well-supported at the moment, so this doesn't work.\n                     // In the future, this should be fixed and this error should be removed.\n                     let def = self.map.defs.get(&lifetime.hir_id).cloned();\n-                    let Some(Region::LateBound(_, _, def_id)) = def else {\n+                    let Some(ResolvedArg::LateBound(_, _, def_id)) = def else {\n                         continue\n                     };\n                     let Some(def_id) = def_id.as_local() else {\n@@ -722,18 +726,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             Type(bounds, ty) => {\n                 let generics = &trait_item.generics;\n-                let lifetimes = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(Region::early(param)),\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n-                    })\n-                    .collect();\n+                let bound_vars = generics.params.iter().map(ResolvedArg::early).collect();\n                 self.record_late_bound_vars(trait_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: trait_item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -768,18 +765,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }),\n             Type(ty) => {\n                 let generics = &impl_item.generics;\n-                let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n-                    .params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(Region::early(param)),\n-                        GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => None,\n-                    })\n-                    .collect();\n+                let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> =\n+                    generics.params.iter().map(ResolvedArg::early).collect();\n                 self.record_late_bound_vars(impl_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: impl_item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -803,7 +794,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         match lifetime_ref.res {\n-            hir::LifetimeName::Static => self.insert_lifetime(lifetime_ref, Region::Static),\n+            hir::LifetimeName::Static => {\n+                self.insert_lifetime(lifetime_ref, ResolvedArg::StaticLifetime)\n+            }\n             hir::LifetimeName::Param(param_def_id) => {\n                 self.resolve_lifetime_ref(param_def_id, lifetime_ref)\n             }\n@@ -814,13 +807,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_path(&mut self, path: &hir::Path<'tcx>, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &hir::Path<'tcx>, hir_id: hir::HirId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n             if let Some(args) = segment.args {\n                 self.visit_segment_args(path.res, depth, args);\n             }\n         }\n+        if let Res::Def(DefKind::TyParam | DefKind::ConstParam, param_def_id) = path.res {\n+            self.resolve_type_ref(param_def_id.expect_local(), hir_id);\n+        }\n     }\n \n     fn visit_fn(\n@@ -869,32 +865,25 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         origin,\n                         ..\n                     }) => {\n-                        let lifetimes: FxIndexMap<LocalDefId, Region> =\n+\n+                        let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) =\n                             bound_generic_params\n-                                .iter()\n-                                .filter(|param| {\n-                                    matches!(param.kind, GenericParamKind::Lifetime { .. })\n-                                })\n-                                .enumerate()\n-                                .map(|(late_bound_idx, param)| {\n-                                        Region::late(late_bound_idx as u32, param)\n-                                })\n-                                .collect();\n-                        let binders: Vec<_> =\n-                            lifetimes\n-                                .iter()\n-                                .map(|(_, region)| {\n-                                     late_region_as_bound_region(this.tcx, region)\n-                                })\n-                                .collect();\n+                            .iter()\n+                            .enumerate()\n+                            .map(|(late_bound_idx, param)| {\n+                                let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                                let r = late_arg_as_bound_arg(this.tcx, &pair.1, param);\n+                                (pair, r)\n+                            })\n+                            .unzip();\n                         this.record_late_bound_vars(hir_id, binders.clone());\n                         // Even if there are no lifetimes defined here, we still wrap it in a binder\n                         // scope. If there happens to be a nested poly trait ref (an error), that\n                         // will be `Concatenating` anyways, so we don't have to worry about the depth\n                         // being wrong.\n                         let scope = Scope::Binder {\n                             hir_id,\n-                            lifetimes,\n+                            bound_vars,\n                             s: this.scope,\n                             scope_type: BinderScopeType::Normal,\n                             where_bound_origin: Some(origin),\n@@ -920,7 +909,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 if lt.res != hir::LifetimeName::Static {\n                                     continue;\n                                 }\n-                                this.insert_lifetime(lt, Region::Static);\n+                                this.insert_lifetime(lt, ResolvedArg::StaticLifetime);\n                                 this.tcx\n                                     .sess\n                                     .struct_span_warn(\n@@ -964,7 +953,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.record_late_bound_vars(*hir_id, binders);\n                 let scope = Scope::Binder {\n                     hir_id: *hir_id,\n-                    lifetimes: FxIndexMap::default(),\n+                    bound_vars: FxIndexMap::default(),\n                     s: self.scope,\n                     scope_type,\n                     where_bound_origin: None,\n@@ -983,16 +972,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n         let initial_bound_vars = binders.len() as u32;\n-        let mut lifetimes: FxIndexMap<LocalDefId, Region> = FxIndexMap::default();\n-        let binders_iter = trait_ref\n-            .bound_generic_params\n-            .iter()\n-            .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n-            .enumerate()\n-            .map(|(late_bound_idx, param)| {\n-                let pair = Region::late(initial_bound_vars + late_bound_idx as u32, param);\n-                let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                lifetimes.insert(pair.0, pair.1);\n+        let mut bound_vars: FxIndexMap<LocalDefId, ResolvedArg> = FxIndexMap::default();\n+        let binders_iter =\n+            trait_ref.bound_generic_params.iter().enumerate().map(|(late_bound_idx, param)| {\n+                let pair = ResolvedArg::late(initial_bound_vars + late_bound_idx as u32, param);\n+                let r = late_arg_as_bound_arg(self.tcx, &pair.1, param);\n+                bound_vars.insert(pair.0, pair.1);\n                 r\n             });\n         binders.extend(binders_iter);\n@@ -1006,7 +991,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         // refs.\n         let scope = Scope::Binder {\n             hir_id: trait_ref.trait_ref.hir_ref_id,\n-            lifetimes,\n+            bound_vars,\n             s: self.scope,\n             scope_type,\n             where_bound_origin: None,\n@@ -1063,13 +1048,13 @@ fn object_lifetime_default(tcx: TyCtxt<'_>, param_def_id: DefId) -> ObjectLifeti\n     }\n }\n \n-impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n+impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n     fn with<F>(&mut self, wrap_scope: Scope<'_>, f: F)\n     where\n-        F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n+        F: for<'b> FnOnce(&mut BoundVarContext<'b, 'tcx>),\n     {\n-        let LifetimeContext { tcx, map, .. } = self;\n-        let mut this = LifetimeContext { tcx: *tcx, map, scope: &wrap_scope };\n+        let BoundVarContext { tcx, map, .. } = self;\n+        let mut this = BoundVarContext { tcx: *tcx, map, scope: &wrap_scope };\n         let span = debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n@@ -1110,23 +1095,25 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n     ) where\n-        F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n+        F: for<'b, 'c> FnOnce(&'b mut BoundVarContext<'c, 'tcx>),\n     {\n         let mut named_late_bound_vars = 0;\n-        let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n+        let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> = generics\n             .params\n             .iter()\n-            .filter_map(|param| match param.kind {\n+            .map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n                     if self.tcx.is_late_bound(param.hir_id) {\n                         let late_bound_idx = named_late_bound_vars;\n                         named_late_bound_vars += 1;\n-                        Some(Region::late(late_bound_idx, param))\n+                        ResolvedArg::late(late_bound_idx, param)\n                     } else {\n-                        Some(Region::early(param))\n+                        ResolvedArg::early(param)\n                     }\n                 }\n-                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n+                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n+                    ResolvedArg::early(param)\n+                }\n             })\n             .collect();\n \n@@ -1139,14 +1126,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             })\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n-                let pair = Region::late(late_bound_idx as u32, param);\n-                late_region_as_bound_region(self.tcx, &pair.1)\n+                let pair = ResolvedArg::late(late_bound_idx as u32, param);\n+                late_arg_as_bound_arg(self.tcx, &pair.1, param)\n             })\n             .collect();\n         self.record_late_bound_vars(hir_id, binders);\n         let scope = Scope::Binder {\n             hir_id,\n-            lifetimes,\n+            bound_vars,\n             s: self.scope,\n             scope_type: BinderScopeType::Normal,\n             where_bound_origin: None,\n@@ -1177,15 +1164,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Root { opt_parent_item } => {\n                     if let Some(parent_item) = opt_parent_item\n                         && let parent_generics = self.tcx.generics_of(parent_item)\n-                        && parent_generics.param_def_id_to_index.contains_key(&region_def_id.to_def_id())\n+                        && parent_generics.param_def_id_to_index(self.tcx, region_def_id.to_def_id()).is_some()\n                     {\n-                        break Some(Region::EarlyBound(region_def_id.to_def_id()));\n+                        break Some(ResolvedArg::EarlyBound(region_def_id.to_def_id()));\n                     }\n                     break None;\n                 }\n \n-                Scope::Binder { ref lifetimes, scope_type, s, where_bound_origin, .. } => {\n-                    if let Some(&def) = lifetimes.get(&region_def_id) {\n+                Scope::Binder { ref bound_vars, scope_type, s, where_bound_origin, .. } => {\n+                    if let Some(&def) = bound_vars.get(&region_def_id) {\n                         break Some(def.shifted(late_depth));\n                     }\n                     match scope_type {\n@@ -1259,7 +1246,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         };\n \n         if let Some(mut def) = result {\n-            if let Region::EarlyBound(..) = def {\n+            if let ResolvedArg::EarlyBound(..) = def {\n                 // Do not free early-bound regions, only late-bound ones.\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n@@ -1275,10 +1262,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         kind: hir::ImplItemKind::Fn(..),\n                         ..\n                     }) => {\n-                        def = Region::Free(owner_id.to_def_id(), def.id().unwrap());\n+                        def = ResolvedArg::Free(owner_id.to_def_id(), def.id().unwrap());\n                     }\n                     Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(closure), .. }) => {\n-                        def = Region::Free(closure.def_id.to_def_id(), def.id().unwrap());\n+                        def = ResolvedArg::Free(closure.def_id.to_def_id(), def.id().unwrap());\n                     }\n                     _ => {}\n                 }\n@@ -1329,6 +1316,57 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         );\n     }\n \n+    fn resolve_type_ref(&mut self, param_def_id: LocalDefId, hir_id: hir::HirId) {\n+        // Walk up the scope chain, tracking the number of fn scopes\n+        // that we pass through, until we find a lifetime with the\n+        // given name or we run out of scopes.\n+        // search.\n+        let mut late_depth = 0;\n+        let mut scope = self.scope;\n+        let result = loop {\n+            match *scope {\n+                Scope::Body { s, .. } => {\n+                    scope = s;\n+                }\n+\n+                Scope::Root { opt_parent_item } => {\n+                    if let Some(parent_item) = opt_parent_item\n+                        && let parent_generics = self.tcx.generics_of(parent_item)\n+                        && parent_generics.param_def_id_to_index(self.tcx, param_def_id.to_def_id()).is_some()\n+                    {\n+                        break Some(ResolvedArg::EarlyBound(param_def_id.to_def_id()));\n+                    }\n+                    break None;\n+                }\n+\n+                Scope::Binder { ref bound_vars, scope_type, s, .. } => {\n+                    if let Some(&def) = bound_vars.get(&param_def_id) {\n+                        break Some(def.shifted(late_depth));\n+                    }\n+                    match scope_type {\n+                        BinderScopeType::Normal => late_depth += 1,\n+                        BinderScopeType::Concatenating => {}\n+                    }\n+                    scope = s;\n+                }\n+\n+                Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => {\n+                    scope = s;\n+                }\n+            }\n+        };\n+\n+        if let Some(def) = result {\n+            self.map.defs.insert(hir_id, def);\n+            return;\n+        }\n+\n+        span_bug!(self.tcx.hir().span(hir_id), \"could not resolve {param_def_id:?}\",);\n+    }\n+\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_segment_args(\n         &mut self,\n@@ -1415,10 +1453,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     if in_body {\n                         None\n                     } else {\n-                        Some(Region::Static)\n+                        Some(ResolvedArg::StaticLifetime)\n                     }\n                 }\n-                ObjectLifetimeDefault::Static => Some(Region::Static),\n+                ObjectLifetimeDefault::Static => Some(ResolvedArg::StaticLifetime),\n                 ObjectLifetimeDefault::Param(param_def_id) => {\n                     // This index can be used with `generic_args` since `parent_count == 0`.\n                     let index = generics.param_def_id_to_index[&param_def_id] as usize;\n@@ -1507,18 +1545,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // in the trait ref `YY<...>` in `Item: YY<...>`.\n         for binding in generic_args.bindings {\n             let scope = Scope::ObjectLifetimeDefault {\n-                lifetime: if has_lifetime_parameter { None } else { Some(Region::Static) },\n+                lifetime: if has_lifetime_parameter {\n+                    None\n+                } else {\n+                    Some(ResolvedArg::StaticLifetime)\n+                },\n                 s: self.scope,\n             };\n             if let Some(type_def_id) = type_def_id {\n-                let lifetimes = LifetimeContext::supertrait_hrtb_lifetimes(\n-                    self.tcx,\n-                    type_def_id,\n-                    binding.ident,\n-                );\n+                let bound_vars =\n+                    BoundVarContext::supertrait_hrtb_vars(self.tcx, type_def_id, binding.ident);\n                 self.with(scope, |this| {\n                     let scope = Scope::Supertrait {\n-                        lifetimes: lifetimes.unwrap_or_default(),\n+                        bound_vars: bound_vars.unwrap_or_default(),\n                         s: this.scope,\n                     };\n                     this.with(scope, |this| this.visit_assoc_type_binding(binding));\n@@ -1541,7 +1580,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ```\n     /// In this case, if we wanted to the supertrait HRTB lifetimes for `As` on\n     /// the starting trait `Bar`, we would return `Some(['b, 'a])`.\n-    fn supertrait_hrtb_lifetimes(\n+    fn supertrait_hrtb_vars(\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         assoc_name: Ident,\n@@ -1626,7 +1665,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root { .. } | Scope::Elision { .. } => break Region::Static,\n+                Scope::Root { .. } | Scope::Elision { .. } => break ResolvedArg::StaticLifetime,\n \n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n@@ -1641,15 +1680,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: Region) {\n+    fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: ResolvedArg) {\n         debug!(span = ?lifetime_ref.ident.span);\n         self.map.defs.insert(lifetime_ref.hir_id, def);\n     }\n \n     /// Sometimes we resolve a lifetime, but later find that it is an\n     /// error (esp. around impl trait). In that case, we remove the\n     /// entry into `map.defs` so as not to confuse later code.\n-    fn uninsert_lifetime_on_error(&mut self, lifetime_ref: &'tcx hir::Lifetime, bad_def: Region) {\n+    fn uninsert_lifetime_on_error(\n+        &mut self,\n+        lifetime_ref: &'tcx hir::Lifetime,\n+        bad_def: ResolvedArg,\n+    ) {\n         let old_value = self.map.defs.remove(&lifetime_ref.hir_id);\n         assert_eq!(old_value, Some(bad_def));\n     }", "previous_filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs"}, {"sha": "0aa5b075d19741a57ee1d2f98d8f4b92ab768bff", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -477,14 +477,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // This is the \"trait\" (meaning, the predicate \"proved\" by this `impl`) which provides the `Self` type we care about.\n         // For the purposes of this function, we hope that it is a `struct` type, and that our current `expr` is a literal of\n         // that struct type.\n-        let impl_trait_self_ref = if self.tcx.is_trait_alias(obligation.impl_def_id) {\n+        let impl_trait_self_ref = if self.tcx.is_trait_alias(obligation.impl_or_alias_def_id) {\n             self.tcx.mk_trait_ref(\n-                obligation.impl_def_id,\n-                ty::InternalSubsts::identity_for_item(self.tcx, obligation.impl_def_id),\n+                obligation.impl_or_alias_def_id,\n+                ty::InternalSubsts::identity_for_item(self.tcx, obligation.impl_or_alias_def_id),\n             )\n         } else {\n             self.tcx\n-                .impl_trait_ref(obligation.impl_def_id)\n+                .impl_trait_ref(obligation.impl_or_alias_def_id)\n                 .map(|impl_def| impl_def.skip_binder())\n                 // It is possible that this is absent. In this case, we make no progress.\n                 .ok_or(expr)?\n@@ -494,7 +494,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let impl_self_ty: Ty<'tcx> = impl_trait_self_ref.self_ty();\n \n         let impl_predicates: ty::GenericPredicates<'tcx> =\n-            self.tcx.predicates_of(obligation.impl_def_id);\n+            self.tcx.predicates_of(obligation.impl_or_alias_def_id);\n         let Some(impl_predicate_index) = obligation.impl_def_predicate_index else {\n             // We don't have the index, so we can only guess.\n             return Err(expr);"}, {"sha": "69a7235802bb3d29fcc177f85a43ca6e6fc4faba", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1740,7 +1740,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match *qpath {\n             QPath::Resolved(ref maybe_qself, ref path) => {\n                 let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself).raw);\n-                let ty = self.astconv().res_to_ty(self_ty, path, true);\n+                let ty = self.astconv().res_to_ty(self_ty, path, hir_id, true);\n                 (path.res, self.handle_raw_ty(path_span, ty))\n             }\n             QPath::TypeRelative(ref qself, ref segment) => {"}, {"sha": "a805dad062eb7f317fc236aad0c665b8b8d81593", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1576,7 +1576,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                                 traits::ImplDerivedObligation(Box::new(\n                                     traits::ImplDerivedObligationCause {\n                                         derived,\n-                                        impl_def_id,\n+                                        impl_or_alias_def_id: impl_def_id,\n                                         impl_def_predicate_index: None,\n                                         span,\n                                     },"}, {"sha": "ef30cd55c0ed086d8c0b6dfa00223b10ee425aac", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -616,7 +616,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ObligationCauseCode::ImplDerivedObligation(data)\n                         if matches!(p.kind().skip_binder(), ty::PredicateKind::Clause(_)) =>\n                     {\n-                        Some((p, parent, data.impl_def_id, data))\n+                        Some((p, parent, data.impl_or_alias_def_id, data))\n                     }\n                     _ => None,\n                 })\n@@ -714,7 +714,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         );\n                     }\n                     Some(Node::Item(hir::Item {\n-                        ident, kind: hir::ItemKind::Trait(..), ..\n+                        ident,\n+                        kind: hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..),\n+                        ..\n                     })) => {\n                         skip_list.insert(p);\n                         let entry = spanned_predicates.entry(ident.span);"}, {"sha": "f5504b05dc4e38d18349699db352f878d5dd9355", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -125,11 +125,11 @@ impl<'tcx> InferCtxt<'tcx> {\n             }\n \n             (ty::Alias(AliasKind::Projection, _), _) if self.tcx.trait_solver_next() => {\n-                relation.register_type_equate_obligation(a.into(), b.into());\n+                relation.register_type_equate_obligation(a, b);\n                 Ok(b)\n             }\n             (_, ty::Alias(AliasKind::Projection, _)) if self.tcx.trait_solver_next() => {\n-                relation.register_type_equate_obligation(b.into(), a.into());\n+                relation.register_type_equate_obligation(b, a);\n                 Ok(a)\n             }\n "}, {"sha": "4fe6c6618f69851f7a20aabb8c0b570ab9237d5c", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -2,7 +2,7 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::resolve_lifetime as rl;\n+use rustc_middle::middle::resolve_bound_vars as rbv;\n use rustc_middle::ty::{self, Region, TyCtxt};\n \n /// This function calls the `visit_ty` method for the parameters\n@@ -99,11 +99,11 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n             hir::TyKind::Ref(ref lifetime, _) => {\n                 // the lifetime of the Ref\n                 let hir_id = lifetime.hir_id;\n-                match (self.tcx.named_region(hir_id), self.bound_region) {\n+                match (self.tcx.named_bound_var(hir_id), self.bound_region) {\n                     // Find the index of the named region that was part of the\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n-                    (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n+                    (Some(rbv::ResolvedArg::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                         debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                         if id == def_id {\n                             self.found_type = Some(arg);\n@@ -115,7 +115,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n                     (\n-                        Some(rl::Region::LateBound(debruijn_index, _, id)),\n+                        Some(rbv::ResolvedArg::LateBound(debruijn_index, _, id)),\n                         ty::BrNamed(def_id, _),\n                     ) => {\n                         debug!(\n@@ -131,10 +131,10 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n \n                     (\n                         Some(\n-                            rl::Region::Static\n-                            | rl::Region::Free(_, _)\n-                            | rl::Region::EarlyBound(_)\n-                            | rl::Region::LateBound(_, _, _),\n+                            rbv::ResolvedArg::StaticLifetime\n+                            | rbv::ResolvedArg::Free(_, _)\n+                            | rbv::ResolvedArg::EarlyBound(_)\n+                            | rbv::ResolvedArg::LateBound(_, _, _),\n                         )\n                         | None,\n                         _,\n@@ -186,17 +186,17 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n-        match (self.tcx.named_region(lifetime.hir_id), self.bound_region) {\n+        match (self.tcx.named_bound_var(lifetime.hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n-            (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rbv::ResolvedArg::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                 if id == def_id {\n                     self.found_it = true;\n                     return; // we can stop visiting now\n                 }\n             }\n \n-            (Some(rl::Region::LateBound(debruijn_index, _, id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rbv::ResolvedArg::LateBound(debruijn_index, _, id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\", debruijn_index,);\n                 debug!(\"id={:?}\", id);\n                 debug!(\"def_id={:?}\", def_id);\n@@ -208,10 +208,10 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n \n             (\n                 Some(\n-                    rl::Region::Static\n-                    | rl::Region::EarlyBound(_)\n-                    | rl::Region::LateBound(_, _, _)\n-                    | rl::Region::Free(_, _),\n+                    rbv::ResolvedArg::StaticLifetime\n+                    | rbv::ResolvedArg::EarlyBound(_)\n+                    | rbv::ResolvedArg::LateBound(_, _, _)\n+                    | rbv::ResolvedArg::Free(_, _),\n                 )\n                 | None,\n                 _,"}, {"sha": "68b39c5f00fb181d4d797135bfee37a46331d425", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -158,7 +158,7 @@ impl<'tcx> Elaborator<'tcx> {\n                                 traits::ImplDerivedObligation(Box::new(\n                                     traits::ImplDerivedObligationCause {\n                                         derived,\n-                                        impl_def_id: data.def_id(),\n+                                        impl_or_alias_def_id: data.def_id(),\n                                         impl_def_predicate_index: Some(index),\n                                         span,\n                                     },"}, {"sha": "cd793d36de6726cb738698ff432c98db5b6d14b1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -2007,7 +2007,7 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives: &[ty::Region<'tcx>],\n         predicate_span: Span,\n     ) -> Vec<(usize, Span)> {\n-        use rustc_middle::middle::resolve_lifetime::Region;\n+        use rustc_middle::middle::resolve_bound_vars::ResolvedArg;\n \n         bounds\n             .iter()\n@@ -2017,8 +2017,8 @@ impl ExplicitOutlivesRequirements {\n                     return None;\n                 };\n \n-                let is_inferred = match tcx.named_region(lifetime.hir_id) {\n-                    Some(Region::EarlyBound(def_id)) => inferred_outlives\n+                let is_inferred = match tcx.named_bound_var(lifetime.hir_id) {\n+                    Some(ResolvedArg::EarlyBound(def_id)) => inferred_outlives\n                         .iter()\n                         .any(|r| matches!(**r, ty::ReEarlyBound(ebr) if { ebr.def_id == def_id })),\n                     _ => false,\n@@ -2097,7 +2097,7 @@ impl ExplicitOutlivesRequirements {\n \n impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        use rustc_middle::middle::resolve_lifetime::Region;\n+        use rustc_middle::middle::resolve_bound_vars::ResolvedArg;\n \n         let def_id = item.owner_id.def_id;\n         if let hir::ItemKind::Struct(_, hir_generics)\n@@ -2120,8 +2120,8 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                 let (relevant_lifetimes, bounds, predicate_span, in_where_clause) =\n                     match where_predicate {\n                         hir::WherePredicate::RegionPredicate(predicate) => {\n-                            if let Some(Region::EarlyBound(region_def_id)) =\n-                                cx.tcx.named_region(predicate.lifetime.hir_id)\n+                            if let Some(ResolvedArg::EarlyBound(region_def_id)) =\n+                                cx.tcx.named_bound_var(predicate.lifetime.hir_id)\n                             {\n                                 (\n                                     Self::lifetimes_outliving_lifetime("}, {"sha": "e941dd4568889b7ce7e7dbbe0eefc422707e4966", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1541,8 +1541,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 self.tables.impl_defaultness.set_some(def_id.index, *defaultness);\n                 self.tables.constness.set_some(def_id.index, *constness);\n \n-                let trait_ref = self.tcx.impl_trait_ref(def_id).map(ty::EarlyBinder::skip_binder);\n+                let trait_ref = self.tcx.impl_trait_ref(def_id);\n                 if let Some(trait_ref) = trait_ref {\n+                    let trait_ref = trait_ref.skip_binder();\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                     if let Ok(mut an) = trait_def.ancestors(self.tcx, def_id) {\n                         if let Some(specialization_graph::Node::Impl(parent)) = an.nth(1) {"}, {"sha": "a9fb8b246c679e48893c09862fce71e8a4a5b4b5", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -18,7 +18,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n-use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use rustc_middle::middle::resolve_bound_vars::ObjectLifetimeDefault;\n use rustc_middle::mir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;"}, {"sha": "0b6774f1b1fe1d0582314b50fa764028cb2a3467", "filename": "compiler/rustc_middle/src/middle/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -29,7 +29,7 @@ pub mod lib_features {\n pub mod limits;\n pub mod privacy;\n pub mod region;\n-pub mod resolve_lifetime;\n+pub mod resolve_bound_vars;\n pub mod stability;\n \n pub fn provide(providers: &mut crate::ty::query::Providers) {"}, {"sha": "b96d07e7dc831cd43ec4156b1ade0d1f38d66c4c", "filename": "compiler/rustc_middle/src/middle/resolve_bound_vars.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1,4 +1,4 @@\n-//! Name resolution for lifetimes: type declarations.\n+//! Name resolution for lifetimes and late-bound type and const variables: type declarations.\n \n use crate::ty;\n \n@@ -8,10 +8,10 @@ use rustc_hir::{ItemLocalId, OwnerId};\n use rustc_macros::HashStable;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n-pub enum Region {\n-    Static,\n-    EarlyBound(/* lifetime decl */ DefId),\n-    LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* lifetime decl */ DefId),\n+pub enum ResolvedArg {\n+    StaticLifetime,\n+    EarlyBound(/* decl */ DefId),\n+    LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* decl */ DefId),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n \n@@ -46,10 +46,10 @@ pub enum ObjectLifetimeDefault {\n /// Maps the id of each lifetime reference to the lifetime decl\n /// that it corresponds to.\n #[derive(Default, HashStable, Debug)]\n-pub struct ResolveLifetimes {\n+pub struct ResolveBoundVars {\n     /// Maps from every use of a named (not anonymous) lifetime to a\n     /// `Region` describing how that region is bound\n-    pub defs: FxHashMap<OwnerId, FxHashMap<ItemLocalId, Region>>,\n+    pub defs: FxHashMap<OwnerId, FxHashMap<ItemLocalId, ResolvedArg>>,\n \n     pub late_bound_vars: FxHashMap<OwnerId, FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>>,\n }", "previous_filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs"}, {"sha": "6f878a955fa3ad33cb0771f649db6dae27c3c592", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -781,7 +781,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query issue33140_self_ty(key: DefId) -> Option<ty::Ty<'tcx>> {\n+    query issue33140_self_ty(key: DefId) -> Option<ty::EarlyBinder<ty::Ty<'tcx>>> {\n         desc { |tcx| \"computing Self type wrt issue #33140 `{}`\", tcx.def_path_str(key) }\n     }\n \n@@ -1641,12 +1641,12 @@ rustc_queries! {\n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n     /// See `rustc_resolve::late::lifetimes for details.\n-    query resolve_lifetimes(_: hir::OwnerId) -> &'tcx ResolveLifetimes {\n+    query resolve_bound_vars(_: hir::OwnerId) -> &'tcx ResolveBoundVars {\n         arena_cache\n         desc { \"resolving lifetimes\" }\n     }\n-    query named_region_map(_: hir::OwnerId) ->\n-        Option<&'tcx FxHashMap<ItemLocalId, Region>> {\n+    query named_variable_map(_: hir::OwnerId) ->\n+        Option<&'tcx FxHashMap<ItemLocalId, ResolvedArg>> {\n         desc { \"looking up a named region\" }\n     }\n     query is_late_bound_map(_: hir::OwnerId) -> Option<&'tcx FxIndexSet<ItemLocalId>> {"}, {"sha": "6231dd9b6f54a245e2b21f99805a23f0f806f204", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -474,7 +474,11 @@ pub enum WellFormedLoc {\n #[derive(TypeVisitable, TypeFoldable)]\n pub struct ImplDerivedObligationCause<'tcx> {\n     pub derived: DerivedObligationCause<'tcx>,\n-    pub impl_def_id: DefId,\n+    /// The `DefId` of the `impl` that gave rise to the `derived` obligation.\n+    /// If the `derived` obligation arose from a trait alias, which conceptually has a synthetic impl,\n+    /// then this will be the `DefId` of that trait alias. Care should therefore be taken to handle\n+    /// that exceptional case where appropriate.\n+    pub impl_or_alias_def_id: DefId,\n     /// The index of the derived predicate in the parent impl's predicates.\n     pub impl_def_predicate_index: Option<usize>,\n     pub span: Span,"}, {"sha": "c7268d561e5ea9f5c18cff4d5e266f18fc2bf0e1", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1,7 +1,9 @@\n+use crate::middle::resolve_bound_vars as rbv;\n use crate::mir::interpret::LitToConstInput;\n use crate::ty::{self, DefIdTree, InternalSubsts, ParamEnv, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_macros::HashStable;\n use std::fmt;\n@@ -125,16 +127,27 @@ impl<'tcx> Const<'tcx> {\n             }\n         }\n \n-        use hir::{def::DefKind::ConstParam, def::Res, ExprKind, Path, QPath};\n         match expr.kind {\n-            ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n-                // Find the name and index of the const parameter by indexing the generics of\n-                // the parent item and construct a `ParamConst`.\n-                let item_def_id = tcx.parent(def_id);\n-                let generics = tcx.generics_of(item_def_id);\n-                let index = generics.param_def_id_to_index[&def_id];\n-                let name = tcx.item_name(def_id);\n-                Some(tcx.mk_const(ty::ParamConst::new(index, name), ty))\n+            hir::ExprKind::Path(hir::QPath::Resolved(\n+                _,\n+                &hir::Path { res: Res::Def(DefKind::ConstParam, def_id), .. },\n+            )) => {\n+                match tcx.named_bound_var(expr.hir_id) {\n+                    Some(rbv::ResolvedArg::EarlyBound(_)) => {\n+                        // Find the name and index of the const parameter by indexing the generics of\n+                        // the parent item and construct a `ParamConst`.\n+                        let item_def_id = tcx.parent(def_id);\n+                        let generics = tcx.generics_of(item_def_id);\n+                        let index = generics.param_def_id_to_index[&def_id];\n+                        let name = tcx.item_name(def_id);\n+                        Some(tcx.mk_const(ty::ParamConst::new(index, name), ty))\n+                    }\n+                    Some(rbv::ResolvedArg::LateBound(debruijn, index, _)) => Some(tcx.mk_const(\n+                        ty::ConstKind::Bound(debruijn, ty::BoundVar::from_u32(index)),\n+                        ty,\n+                    )),\n+                    arg => bug!(\"unexpected bound var resolution for {:?}: {arg:?}\", expr.hir_id),\n+                }\n             }\n             _ => None,\n         }"}, {"sha": "d5be23d2b98378a765fb17ce87f11232009bc5ee", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -9,7 +9,7 @@ use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::struct_lint_level;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use crate::middle::resolve_lifetime;\n+use crate::middle::resolve_bound_vars;\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstAllocation};\n use crate::mir::{\n@@ -2368,9 +2368,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         Some(&*candidates)\n     }\n \n-    pub fn named_region(self, id: HirId) -> Option<resolve_lifetime::Region> {\n+    pub fn named_bound_var(self, id: HirId) -> Option<resolve_bound_vars::ResolvedArg> {\n         debug!(?id, \"named_region\");\n-        self.named_region_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n+        self.named_variable_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n     }\n \n     pub fn is_late_bound(self, id: HirId) -> bool {"}, {"sha": "106ce9990e1ed1c79f973ccafb43b5e507f6b268", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -290,7 +290,7 @@ impl DeepRejectCtxt {\n             // Impls cannot contain these types as these cannot be named directly.\n             ty::FnDef(..) | ty::Closure(..) | ty::Generator(..) => false,\n \n-            ty::Placeholder(..) => false,\n+            ty::Placeholder(..) | ty::Bound(..) => false,\n \n             // Depending on the value of `treat_obligation_params`, we either\n             // treat generic parameters like placeholders or like inference variables.\n@@ -310,7 +310,7 @@ impl DeepRejectCtxt {\n \n             ty::Error(_) => true,\n \n-            ty::GeneratorWitness(..) | ty::GeneratorWitnessMIR(..) | ty::Bound(..) => {\n+            ty::GeneratorWitness(..) | ty::GeneratorWitnessMIR(..) => {\n                 bug!(\"unexpected obligation type: {:?}\", obligation_ty)\n             }\n         }"}, {"sha": "8849e7eab335c6b100068acc0d7aaf5c6e30bae1", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -57,7 +57,7 @@ trivially_parameterized_over_tcx! {\n     crate::metadata::ModChild,\n     crate::middle::codegen_fn_attrs::CodegenFnAttrs,\n     crate::middle::exported_symbols::SymbolExportInfo,\n-    crate::middle::resolve_lifetime::ObjectLifetimeDefault,\n+    crate::middle::resolve_bound_vars::ObjectLifetimeDefault,\n     crate::mir::ConstQualifs,\n     ty::AssocItemContainer,\n     ty::DeducedParamAttrs,"}, {"sha": "431f3a5a0002aad4eb66fcd0d0f586dc5bc328a5", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -8,7 +8,7 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use crate::middle::lib_features::LibFeatures;\n use crate::middle::privacy::EffectiveVisibilities;\n-use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLifetimes};\n+use crate::middle::resolve_bound_vars::{ObjectLifetimeDefault, ResolveBoundVars, ResolvedArg};\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;\n use crate::mir::interpret::GlobalId;"}, {"sha": "1b3ac78fbc664feca889e12b9527507ba7634b9b", "filename": "compiler/rustc_mir_transform/src/ctfe_limit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -47,8 +47,7 @@ fn has_back_edge(\n         return false;\n     }\n     // Check if any of the dominators of the node are also the node's successor.\n-    doms.dominators(node)\n-        .any(|dom| node_data.terminator().successors().into_iter().any(|succ| succ == dom))\n+    doms.dominators(node).any(|dom| node_data.terminator().successors().any(|succ| succ == dom))\n }\n \n fn insert_counter(basic_block_data: &mut BasicBlockData<'_>) {"}, {"sha": "c1e7f62dea5c82276ddf7298b16d5f8437bc04e0", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -2,7 +2,7 @@ use either::Either;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::middle::resolve_lifetime::Set1;\n+use rustc_middle::middle::resolve_bound_vars::Set1;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{ParamEnv, TyCtxt};"}, {"sha": "7cff8996d248dbdd8e051f0d333ffd4430aa9207", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -18,7 +18,7 @@ use rustc_hir::{\n };\n use rustc_hir::{MethodKind, Target, Unsafety};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use rustc_middle::middle::resolve_bound_vars::ObjectLifetimeDefault;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{ParamEnv, TyCtxt};"}, {"sha": "0a0c94e1dfb6a132f68e4691e4b688c783103d73", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -270,10 +270,11 @@ where\n             | ty::Ref(..)\n             | ty::FnPtr(..)\n             | ty::Param(..)\n+            | ty::Bound(..)\n             | ty::Error(_)\n             | ty::GeneratorWitness(..)\n             | ty::GeneratorWitnessMIR(..) => {}\n-            ty::Bound(..) | ty::Placeholder(..) | ty::Infer(..) => {\n+            ty::Placeholder(..) | ty::Infer(..) => {\n                 bug!(\"unexpected type: {:?}\", ty)\n             }\n         }"}, {"sha": "324de7461cd95431a0a2a6f1e92e4d831d929b55", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -21,7 +21,7 @@ use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::{BindingAnnotation, PrimTy, TraitCandidate};\n-use rustc_middle::middle::resolve_lifetime::Set1;\n+use rustc_middle::middle::resolve_bound_vars::Set1;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::{CrateType, ResolveDocLinks};\n@@ -2505,7 +2505,13 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             let res = match kind {\n                 ItemRibKind(..) | AssocItemRibKind => Res::Def(def_kind, def_id.to_def_id()),\n-                NormalRibKind => Res::Err,\n+                NormalRibKind => {\n+                    if self.r.session.features_untracked().non_lifetime_binders {\n+                        Res::Def(def_kind, def_id.to_def_id())\n+                    } else {\n+                        Res::Err\n+                    }\n+                }\n                 _ => span_bug!(param.ident.span, \"Unexpected rib kind {:?}\", kind),\n             };\n             self.r.record_partial_res(param.id, PartialRes::new(res));"}, {"sha": "bd32adbbdbb54b21f0dff197c86d88ae73bead47", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -4,7 +4,7 @@ use crate::cgu_reuse_tracker::CguReuse;\n use crate::parse::ParseSess;\n use rustc_ast::token;\n use rustc_ast::util::literal::LitError;\n-use rustc_errors::MultiSpan;\n+use rustc_errors::{error_code, DiagnosticMessage, EmissionGuarantee, IntoDiagnostic, MultiSpan};\n use rustc_macros::Diagnostic;\n use rustc_span::{Span, Symbol};\n use rustc_target::spec::{SplitDebuginfo, StackProtector, TargetTriple};\n@@ -27,12 +27,22 @@ pub struct CguNotRecorded<'a> {\n     pub cgu_name: &'a str,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(session_feature_gate_error, code = \"E0658\")]\n-pub struct FeatureGateError<'a> {\n-    #[primary_span]\n+pub struct FeatureGateError {\n     pub span: MultiSpan,\n-    pub explain: &'a str,\n+    pub explain: DiagnosticMessage,\n+}\n+\n+impl<'a, T: EmissionGuarantee> IntoDiagnostic<'a, T> for FeatureGateError {\n+    #[track_caller]\n+    fn into_diagnostic(\n+        self,\n+        handler: &'a rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'a, T> {\n+        let mut diag = handler.struct_diagnostic(self.explain);\n+        diag.set_span(self.span);\n+        diag.code(error_code!(E0658));\n+        diag\n+    }\n }\n \n #[derive(Subdiagnostic)]"}, {"sha": "cbdcc5581e5eea3146980c55f926b278c95bf79b", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -88,7 +88,7 @@ pub fn feature_err<'a>(\n     sess: &'a ParseSess,\n     feature: Symbol,\n     span: impl Into<MultiSpan>,\n-    explain: &str,\n+    explain: impl Into<DiagnosticMessage>,\n ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     feature_err_issue(sess, feature, span, GateIssue::Language, explain)\n }\n@@ -103,7 +103,7 @@ pub fn feature_err_issue<'a>(\n     feature: Symbol,\n     span: impl Into<MultiSpan>,\n     issue: GateIssue,\n-    explain: &str,\n+    explain: impl Into<DiagnosticMessage>,\n ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     let span = span.into();\n \n@@ -114,7 +114,7 @@ pub fn feature_err_issue<'a>(\n             .map(|err| err.cancel());\n     }\n \n-    let mut err = sess.create_err(FeatureGateError { span, explain });\n+    let mut err = sess.create_err(FeatureGateError { span, explain: explain.into() });\n     add_feature_diagnostics_for_issue(&mut err, sess, feature, issue);\n     err\n }"}, {"sha": "37d2aea42ad8f40284609a8d118e61700373bf9c", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1016,6 +1016,7 @@ symbols! {\n         non_ascii_idents,\n         non_exhaustive,\n         non_exhaustive_omitted_patterns_lint,\n+        non_lifetime_binders,\n         non_modrs_mods,\n         nontemporal_store,\n         noop_method_borrow,"}, {"sha": "91d96655b64e2f532e5c6213c2c701f0984a34fd", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -60,7 +60,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     ) -> Option<(DefId, SubstsRef<'tcx>)> {\n         let tcx = self.tcx;\n         let param_env = obligation.param_env;\n-        let trait_ref = tcx.erase_late_bound_regions(trait_ref);\n+        let trait_ref = self.instantiate_binder_with_placeholders(trait_ref);\n         let trait_self_ty = trait_ref.self_ty();\n \n         let mut self_match_impls = vec![];"}, {"sha": "a0c67f480d0247650ed384204762f5682cd7c326", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1056,7 +1056,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n         let self_ty = self.resolve_vars_if_possible(trait_pred.self_ty());\n-        let ty = self.tcx.erase_late_bound_regions(self_ty);\n+        let ty = self.instantiate_binder_with_placeholders(self_ty);\n         let Some(generics) = self.tcx.hir().get_generics(obligation.cause.body_id) else { return false };\n         let ty::Ref(_, inner_ty, hir::Mutability::Not) = ty.kind() else { return false };\n         let ty::Param(param) = inner_ty.kind() else { return false };\n@@ -3143,7 +3143,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     parent_trait_pred.print_modifiers_and_trait_path()\n                 );\n                 let mut is_auto_trait = false;\n-                match self.tcx.hir().get_if_local(data.impl_def_id) {\n+                match self.tcx.hir().get_if_local(data.impl_or_alias_def_id) {\n                     Some(Node::Item(hir::Item {\n                         kind: hir::ItemKind::Trait(is_auto, ..),\n                         ident,"}, {"sha": "dae602908a31f6edf7da836778e8e8055e1b81c6", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -396,7 +396,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // still be provided by a manual implementation for\n                     // this trait and type.\n                 }\n-                ty::Param(..) | ty::Alias(ty::Projection, ..) => {\n+                ty::Param(..)\n+                | ty::Alias(ty::Projection, ..)\n+                | ty::Placeholder(..)\n+                | ty::Bound(..) => {\n                     // In these cases, we don't know what the actual\n                     // type is. Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n@@ -448,6 +451,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         );\n \n         self.infcx.probe(|_snapshot| {\n+            if obligation.has_non_region_late_bound() {\n+                return;\n+            }\n+\n             // The code below doesn't care about regions, and the\n             // self-ty here doesn't escape this probe, so just erase\n             // any LBR."}, {"sha": "0167f4026102e5ca072952ae70df9ecce43d479f", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1189,7 +1189,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let cause = obligation.derived_cause(|derived| {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n-                    impl_def_id,\n+                    impl_or_alias_def_id: impl_def_id,\n                     impl_def_predicate_index: None,\n                     span: obligation.cause.span,\n                 }))"}, {"sha": "26f869ac1fef6b5cd9874a98081304db0ab2c328", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -2657,7 +2657,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let cause = cause.clone().derived_cause(parent_trait_pred, |derived| {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n-                    impl_def_id: def_id,\n+                    impl_or_alias_def_id: def_id,\n                     impl_def_predicate_index: Some(index),\n                     span,\n                 }))"}, {"sha": "fc3d9fb067d7cc4395d11ddc6749262866477b7e", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1,7 +1,9 @@\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n-use rustc_middle::ty::{self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{\n+    self, Binder, EarlyBinder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt,\n+};\n use rustc_session::config::TraitSolver;\n use rustc_span::def_id::{DefId, CRATE_DEF_ID};\n use rustc_trait_selection::traits;\n@@ -355,7 +357,7 @@ fn instance_def_size_estimate<'tcx>(\n /// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n ///\n /// See [`ty::ImplOverlapKind::Issue33140`] for more details.\n-fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n+fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<EarlyBinder<Ty<'_>>> {\n     debug!(\"issue33140_self_ty({:?})\", def_id);\n \n     let trait_ref = tcx\n@@ -394,7 +396,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n \n     if self_ty_matches {\n         debug!(\"issue33140_self_ty - MATCHES!\");\n-        Some(self_ty)\n+        Some(EarlyBinder(self_ty))\n     } else {\n         debug!(\"issue33140_self_ty - non-matching self type\");\n         None"}, {"sha": "9e3e13e70040e953c7c48298aeccc8d4d5b68368", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -3502,8 +3502,10 @@ pub trait Iterator {\n         }\n     }\n \n-    /// [Lexicographically](Ord#lexicographical-comparison) compares the elements of this [`Iterator`] with those\n-    /// of another.\n+    /// [Lexicographically](Ord#lexicographical-comparison) compares the [`PartialOrd`] elements of\n+    /// this [`Iterator`] with those of another. The comparison works like short-circuit\n+    /// evaluation, returning a result without comparing the remaining elements.\n+    /// As soon as an order can be determined, the evaluation stops and a result is returned.\n     ///\n     /// # Examples\n     ///\n@@ -3513,9 +3515,25 @@ pub trait Iterator {\n     /// assert_eq!([1.].iter().partial_cmp([1.].iter()), Some(Ordering::Equal));\n     /// assert_eq!([1.].iter().partial_cmp([1., 2.].iter()), Some(Ordering::Less));\n     /// assert_eq!([1., 2.].iter().partial_cmp([1.].iter()), Some(Ordering::Greater));\n+    /// ```\n     ///\n+    /// For floating-point numbers, NaN does not have a total order and will result\n+    /// in `None` when compared:\n+    ///\n+    /// ```\n     /// assert_eq!([f64::NAN].iter().partial_cmp([1.].iter()), None);\n     /// ```\n+    ///\n+    /// The results are determined by the order of evaluation.\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// assert_eq!([1.0, f64::NAN].iter().partial_cmp([2.0, f64::NAN].iter()), Some(Ordering::Less));\n+    /// assert_eq!([2.0, f64::NAN].iter().partial_cmp([1.0, f64::NAN].iter()), Some(Ordering::Greater));\n+    /// assert_eq!([f64::NAN, 1.0].iter().partial_cmp([f64::NAN, 2.0].iter()), None);\n+    /// ```\n+    ///\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn partial_cmp<I>(self, other: I) -> Option<Ordering>\n     where"}, {"sha": "ff7821fb9ff0851c19690a53f3ee1f052ecf4d77", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -58,9 +58,10 @@ fn args(builder: &Builder<'_>) -> Vec<String> {\n         clippy_lint_warn.iter().for_each(|v| clippy_lint_levels.push(format!(\"-W{}\", v)));\n         clippy_lint_forbid.iter().for_each(|v| clippy_lint_levels.push(format!(\"-F{}\", v)));\n         args.extend(clippy_lint_levels);\n+        args.extend(builder.config.free_args.clone());\n         args\n     } else {\n-        vec![]\n+        builder.config.free_args.clone()\n     }\n }\n "}, {"sha": "cd027a4abb7faec04f2628af9474c53e814e265e", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -97,6 +97,10 @@ pub struct Config {\n     pub cmd: Subcommand,\n     pub incremental: bool,\n     pub dry_run: DryRun,\n+    /// Arguments appearing after `--` to be forwarded to tools,\n+    /// e.g. `--fix-broken` or test arguments.\n+    pub free_args: Vec<String>,\n+\n     /// `None` if we shouldn't download CI compiler artifacts, or the commit to download if we should.\n     #[cfg(not(test))]\n     download_rustc_commit: Option<String>,\n@@ -866,6 +870,7 @@ impl Config {\n         config.keep_stage = flags.keep_stage;\n         config.keep_stage_std = flags.keep_stage_std;\n         config.color = flags.color;\n+        config.free_args = flags.free_args.clone().unwrap_or_default();\n         if let Some(value) = flags.deny_warnings {\n             config.deny_warnings = value;\n         }"}, {"sha": "f07e710a9e6b76fe8bcd6563ecccb74bf60fe3dd", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -80,6 +80,10 @@ pub struct Flags {\n     pub llvm_profile_generate: bool,\n     pub llvm_bolt_profile_generate: bool,\n     pub llvm_bolt_profile_use: Option<String>,\n+\n+    /// Arguments appearing after `--` to be forwarded to tools,\n+    /// e.g. `--fix-broken` or test arguments.\n+    pub free_args: Option<Vec<String>>,\n }\n \n #[derive(Debug)]\n@@ -157,6 +161,12 @@ impl Default for Subcommand {\n \n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n+        let (args, free_args) = if let Some(pos) = args.iter().position(|s| s == \"--\") {\n+            let (args, free) = args.split_at(pos);\n+            (args, Some(free[1..].to_vec()))\n+        } else {\n+            (args, None)\n+        };\n         let mut subcommand_help = String::from(\n             \"\\\n Usage: x.py <subcommand> [options] [<paths>...]\n@@ -709,6 +719,7 @@ Arguments:\n             llvm_profile_generate: matches.opt_present(\"llvm-profile-generate\"),\n             llvm_bolt_profile_generate: matches.opt_present(\"llvm-bolt-profile-generate\"),\n             llvm_bolt_profile_use: matches.opt_str(\"llvm-bolt-profile-use\"),\n+            free_args,\n         }\n     }\n }"}, {"sha": "e14440f57a8a6a3fa531d36f406e264529a7b8a7", "filename": "src/bootstrap/run.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Fbootstrap%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Fbootstrap%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frun.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -183,6 +183,7 @@ impl Step for Miri {\n         // Forward arguments.\n         miri.arg(\"--\").arg(\"--target\").arg(target.rustc_target_arg());\n         miri.args(builder.config.cmd.args());\n+        miri.args(&builder.config.free_args);\n \n         // miri tests need to know about the stage sysroot\n         miri.env(\"MIRI_SYSROOT\", &miri_sysroot);"}, {"sha": "9cd6107b43ac3a67aede2e05be0259e9943aed12", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1588,6 +1588,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             .collect();\n \n         test_args.append(&mut builder.config.cmd.test_args());\n+        test_args.extend(builder.config.free_args.iter().map(|s| s.as_str()));\n \n         // On Windows, replace forward slashes in test-args by backslashes\n         // so the correct filters are passed to libtest"}, {"sha": "10af968e34f883f2557ec7f8460f9aa8c2b38747", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -21,7 +21,7 @@ use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::PredicateOrigin;\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n-use rustc_middle::middle::resolve_lifetime as rl;\n+use rustc_middle::middle::resolve_bound_vars as rbv;\n use rustc_middle::ty::fold::ir::TypeFolder;\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::TypeVisitable;\n@@ -200,11 +200,11 @@ fn clean_poly_trait_ref_with_bindings<'tcx>(\n }\n \n fn clean_lifetime<'tcx>(lifetime: &hir::Lifetime, cx: &mut DocContext<'tcx>) -> Lifetime {\n-    let def = cx.tcx.named_region(lifetime.hir_id);\n+    let def = cx.tcx.named_bound_var(lifetime.hir_id);\n     if let Some(\n-        rl::Region::EarlyBound(node_id)\n-        | rl::Region::LateBound(_, _, node_id)\n-        | rl::Region::Free(_, node_id),\n+        rbv::ResolvedArg::EarlyBound(node_id)\n+        | rbv::ResolvedArg::LateBound(_, _, node_id)\n+        | rbv::ResolvedArg::Free(_, node_id),\n     ) = def\n     {\n         if let Some(lt) = cx.substs.get(&node_id).and_then(|p| p.as_lt()).cloned() {"}, {"sha": "6fe665d7e4068b0e6811271781e58d6eb9f1e281", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -129,7 +129,7 @@ fn external_generic_args<'tcx>(\n         });\n         GenericArgs::Parenthesized { inputs, output }\n     } else {\n-        GenericArgs::AngleBracketed { args: args.into(), bindings: bindings.into() }\n+        GenericArgs::AngleBracketed { args: args.into(), bindings }\n     }\n }\n "}, {"sha": "fc550936165e63e21fadaf8a66f30d67549e31f1", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -505,13 +505,13 @@ fn check_mut_from_ref<'tcx>(cx: &LateContext<'tcx>, sig: &FnSig<'_>, body: Optio\n     if let FnRetTy::Return(ty) = sig.decl.output\n         && let Some((out, Mutability::Mut, _)) = get_ref_lm(ty)\n     {\n-        let out_region = cx.tcx.named_region(out.hir_id);\n+        let out_region = cx.tcx.named_bound_var(out.hir_id);\n         let args: Option<Vec<_>> = sig\n             .decl\n             .inputs\n             .iter()\n             .filter_map(get_ref_lm)\n-            .filter(|&(lt, _, _)| cx.tcx.named_region(lt.hir_id) == out_region)\n+            .filter(|&(lt, _, _)| cx.tcx.named_bound_var(lt.hir_id) == out_region)\n             .map(|(_, mutability, span)| (mutability == Mutability::Not).then_some(span))\n             .collect();\n         if let Some(args) = args"}, {"sha": "409f75631849409a1df2c268cd5f10b935c34c1e", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -10,7 +10,7 @@ use std::path::Path;\n const ENTRY_LIMIT: usize = 1000;\n // FIXME: The following limits should be reduced eventually.\n const ROOT_ENTRY_LIMIT: usize = 940;\n-const ISSUES_ENTRY_LIMIT: usize = 2001;\n+const ISSUES_ENTRY_LIMIT: usize = 1978;\n \n fn check_entries(path: &Path, bad: &mut bool) {\n     for dir in Walk::new(&path.join(\"ui\")) {"}, {"sha": "6753860e9ff80435e9c811bf1b9b0faeaa0b906b", "filename": "tests/ui/associated-types/issue-38821.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fassociated-types%2Fissue-38821.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fassociated-types%2Fissue-38821.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fissue-38821.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-38821.rs"}, {"sha": "a52a9c138f1479a3b279be892be7d6d9a7c724dd", "filename": "tests/ui/associated-types/issue-38821.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fassociated-types%2Fissue-38821.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fassociated-types%2Fissue-38821.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fissue-38821.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-38821.stderr"}, {"sha": "aa40da12b875da8ddaa5d03b1f573099309d01cb", "filename": "tests/ui/borrowck/issue-83924.fixed", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fborrowck%2Fissue-83924.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fborrowck%2Fissue-83924.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-83924.fixed?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-83924.fixed"}, {"sha": "22b80fe2f383f932380ac9f8338ddeee1be6dd4a", "filename": "tests/ui/borrowck/issue-83924.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fborrowck%2Fissue-83924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fborrowck%2Fissue-83924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-83924.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-83924.rs"}, {"sha": "572414df2bf9d6af0b37498610f95f9529cf0060", "filename": "tests/ui/borrowck/issue-83924.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fborrowck%2Fissue-83924.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fborrowck%2Fissue-83924.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-83924.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-83924.stderr"}, {"sha": "a3427e21cde2d7e957b3b33a75c93f5290172238", "filename": "tests/ui/bounds-lifetime.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fbounds-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fbounds-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbounds-lifetime.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -16,17 +16,24 @@ error: lifetime bounds cannot be used in this context\n LL | type C = for<'b, 'a: 'b +> fn();\n    |                      ^^\n \n-error: only lifetime parameters can be used in this context\n+error[E0658]: only lifetime parameters can be used in this context\n   --> $DIR/bounds-lifetime.rs:4:18\n    |\n LL | type D = for<'a, T> fn();\n    |                  ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n \n-error: only lifetime parameters can be used in this context\n+error[E0658]: only lifetime parameters can be used in this context\n   --> $DIR/bounds-lifetime.rs:5:18\n    |\n LL | type E = dyn for<T> Fn();\n    |                  ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n \n error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "9f4deaa774dd76ba2e18ffa7344624127463fa31", "filename": "tests/ui/closures/binder/disallow-const.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fclosures%2Fbinder%2Fdisallow-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fclosures%2Fbinder%2Fdisallow-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2Fbinder%2Fdisallow-const.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1,8 +1,12 @@\n-error: only lifetime parameters can be used in this context\n+error[E0658]: only lifetime parameters can be used in this context\n   --> $DIR/disallow-const.rs:4:15\n    |\n LL |     for<const N: i32> || -> () {};\n    |               ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "22882ca2ba67ac4af6de0f7919edae809ffb6b4d", "filename": "tests/ui/closures/binder/disallow-ty.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fclosures%2Fbinder%2Fdisallow-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fclosures%2Fbinder%2Fdisallow-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2Fbinder%2Fdisallow-ty.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1,8 +1,12 @@\n-error: only lifetime parameters can be used in this context\n+error[E0658]: only lifetime parameters can be used in this context\n   --> $DIR/disallow-ty.rs:4:9\n    |\n LL |     for<T> || -> () {};\n    |         ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "69b0f74115684fc2de26ee4dad1fd41735a05f7e", "filename": "tests/ui/conditional-compilation/cfg-generic-params.stderr", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fconditional-compilation%2Fcfg-generic-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fconditional-compilation%2Fcfg-generic-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconditional-compilation%2Fcfg-generic-params.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1,21 +1,3 @@\n-error: only lifetime parameters can be used in this context\n-  --> $DIR/cfg-generic-params.rs:7:45\n-   |\n-LL | type FnBad = for<#[cfg(no)] 'a, #[cfg(yes)] T> fn();\n-   |                                             ^\n-\n-error: only lifetime parameters can be used in this context\n-  --> $DIR/cfg-generic-params.rs:11:51\n-   |\n-LL | type PolyBad = dyn for<#[cfg(no)] 'a, #[cfg(yes)] T> Copy;\n-   |                                                   ^\n-\n-error: only lifetime parameters can be used in this context\n-  --> $DIR/cfg-generic-params.rs:15:54\n-   |\n-LL | struct WhereBad where for<#[cfg(no)] 'a, #[cfg(yes)] T> u8: Copy;\n-   |                                                      ^\n-\n error: cannot find attribute `unknown` in this scope\n   --> $DIR/cfg-generic-params.rs:19:29\n    |\n@@ -46,5 +28,33 @@ error: cannot find attribute `unknown` in this scope\n LL | struct WhereYes where for<#[cfg_attr(yes, unknown)] 'a> u8: Copy;\n    |                                           ^^^^^^^\n \n+error[E0658]: only lifetime parameters can be used in this context\n+  --> $DIR/cfg-generic-params.rs:7:45\n+   |\n+LL | type FnBad = for<#[cfg(no)] 'a, #[cfg(yes)] T> fn();\n+   |                                             ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n+\n+error[E0658]: only lifetime parameters can be used in this context\n+  --> $DIR/cfg-generic-params.rs:11:51\n+   |\n+LL | type PolyBad = dyn for<#[cfg(no)] 'a, #[cfg(yes)] T> Copy;\n+   |                                                   ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n+\n+error[E0658]: only lifetime parameters can be used in this context\n+  --> $DIR/cfg-generic-params.rs:15:54\n+   |\n+LL | struct WhereBad where for<#[cfg(no)] 'a, #[cfg(yes)] T> u8: Copy;\n+   |                                                      ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n+\n error: aborting due to 8 previous errors\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "613aa121a47bf5394c9a640c5bb1ab114e61280a", "filename": "tests/ui/consts/issue-33903.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fconsts%2Fissue-33903.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fconsts%2Fissue-33903.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-33903.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-33903.rs"}, {"sha": "8c50cac67f8fc4a347435b2363d382c0ce0bcdc5", "filename": "tests/ui/consts/issue-54582.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fconsts%2Fissue-54582.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fconsts%2Fissue-54582.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-54582.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-54582.rs"}, {"sha": "70ebce9d35a79c061fee0453e1091a29f5a41583", "filename": "tests/ui/drop/issue-2735-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fdrop%2Fissue-2735-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fdrop%2Fissue-2735-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop%2Fissue-2735-2.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-2735-2.rs"}, {"sha": "2330153783572e50c437c3fc80de2eb939d691c3", "filename": "tests/ui/drop/issue-2735-3.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fdrop%2Fissue-2735-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fdrop%2Fissue-2735-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop%2Fissue-2735-3.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-2735-3.rs"}, {"sha": "20d3949a9f998ca9cb98b95ba4241eb180d2f66c", "filename": "tests/ui/drop/issue-2735.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fdrop%2Fissue-2735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fdrop%2Fissue-2735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop%2Fissue-2735.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-2735.rs"}, {"sha": "221e9133fcc6b67750d064b8b19907c3dd2282b0", "filename": "tests/ui/feature-gates/feature-gate-non_lifetime_binders.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_lifetime_binders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_lifetime_binders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_lifetime_binders.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -0,0 +1,4 @@\n+fn foo() where for<T> T:, {}\n+//~^ ERROR only lifetime parameters can be used in this context\n+\n+fn main() {}"}, {"sha": "75645e324017d833f833c52d1237662558940c4a", "filename": "tests/ui/feature-gates/feature-gate-non_lifetime_binders.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_lifetime_binders.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_lifetime_binders.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-non_lifetime_binders.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: only lifetime parameters can be used in this context\n+  --> $DIR/feature-gate-non_lifetime_binders.rs:1:20\n+   |\n+LL | fn foo() where for<T> T:, {}\n+   |                    ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "cffa6bea8ed38d825faac06e0513b0fe2b09c50f", "filename": "tests/ui/fmt/issue-75307.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ffmt%2Fissue-75307.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ffmt%2Fissue-75307.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fissue-75307.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-75307.rs"}, {"sha": "c5b0b11e7d0998cfe891fa3c23bc77a7309ff1f2", "filename": "tests/ui/fmt/issue-75307.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ffmt%2Fissue-75307.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ffmt%2Fissue-75307.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fissue-75307.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-75307.stderr"}, {"sha": "d605c9e0df7e41af48c57f9ebe5e601d0abb6f6a", "filename": "tests/ui/higher-rank-trait-bounds/hrtb-wrong-kind.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-wrong-kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-wrong-kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-wrong-kind.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -1,14 +1,21 @@\n-error: only lifetime parameters can be used in this context\n+error[E0658]: only lifetime parameters can be used in this context\n   --> $DIR/hrtb-wrong-kind.rs:1:18\n    |\n LL | fn a() where for<T> T: Copy {}\n    |                  ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n \n-error: only lifetime parameters can be used in this context\n+error[E0658]: only lifetime parameters can be used in this context\n   --> $DIR/hrtb-wrong-kind.rs:4:24\n    |\n LL | fn b() where for<const C: usize> [(); C]: Copy {}\n    |                        ^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = help: add `#![feature(non_lifetime_binders)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "968cf08916fd6dd2bfd840e605fb7c0c715d4df7", "filename": "tests/ui/higher-rank-trait-bounds/issue-39292.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-39292.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-39292.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fhigher-rank-trait-bounds%2Fissue-39292.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-39292.rs"}, {"sha": "e0c36b8273af012aab6a57766aa121f2d3a7369b", "filename": "tests/ui/loops/issue-50576.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Floops%2Fissue-50576.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Floops%2Fissue-50576.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Floops%2Fissue-50576.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-50576.rs"}, {"sha": "4ec22fde9106db6dc5fcbd2caf2fc92718a410a1", "filename": "tests/ui/loops/issue-50576.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Floops%2Fissue-50576.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Floops%2Fissue-50576.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Floops%2Fissue-50576.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-50576.stderr"}, {"sha": "017f36484c1cf39a46eb730ff97b4c0b98ca1982", "filename": "tests/ui/moves/issue-22536-copy-mustnt-zero.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fmoves%2Fissue-22536-copy-mustnt-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fmoves%2Fissue-22536-copy-mustnt-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmoves%2Fissue-22536-copy-mustnt-zero.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-22536-copy-mustnt-zero.rs"}, {"sha": "84c94c7c90580da422c83d84ca405684210a0656", "filename": "tests/ui/nll/issue-27583.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fnll%2Fissue-27583.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fnll%2Fissue-27583.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-27583.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-27583.rs"}, {"sha": "f81203dc41299701e937cfd13b46cbe2bc2e826e", "filename": "tests/ui/nll/issue-48179.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fnll%2Fissue-48179.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fnll%2Fissue-48179.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-48179.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-48179.rs"}, {"sha": "a1e438bc617803de855295ed1ef5e1d6e2b7b372", "filename": "tests/ui/nll/issue-75777.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fnll%2Fissue-75777.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fnll%2Fissue-75777.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-75777.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-75777.rs"}, {"sha": "370cd72fd558d485f049cbd2cde2e36ae9a37b94", "filename": "tests/ui/nll/issue-75777.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fnll%2Fissue-75777.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fnll%2Fissue-75777.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnll%2Fissue-75777.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-75777.stderr"}, {"sha": "069fcffe9a0dfbed581f0441ce4698b6e4964804", "filename": "tests/ui/parser/recover-fn-ptr-with-generics.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fparser%2Frecover-fn-ptr-with-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Fparser%2Frecover-fn-ptr-with-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Frecover-fn-ptr-with-generics.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -88,12 +88,6 @@ error: expected identifier, found `>`\n LL |     type QuiteBroken = fn<const>();\n    |                                ^ expected identifier\n \n-error: lifetime bounds cannot be used in this context\n-  --> $DIR/recover-fn-ptr-with-generics.rs:22:26\n-   |\n-LL |     let _: extern fn<'a: 'static>();\n-   |                          ^^^^^^^\n-\n error[E0412]: cannot find type `T` in this scope\n   --> $DIR/recover-fn-ptr-with-generics.rs:5:27\n    |\n@@ -106,6 +100,12 @@ error[E0412]: cannot find type `T` in this scope\n LL |     type Identity = fn<T>(T) -> T;\n    |                                 ^ not found in this scope\n \n+error: lifetime bounds cannot be used in this context\n+  --> $DIR/recover-fn-ptr-with-generics.rs:22:26\n+   |\n+LL |     let _: extern fn<'a: 'static>();\n+   |                          ^^^^^^^\n+\n error: aborting due to 12 previous errors\n \n For more information about this error, try `rustc --explain E0412`."}, {"sha": "5e61361f9877a2a1c87db010847106719e780ff9", "filename": "tests/ui/recursion_limit/issue-40003.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Frecursion_limit%2Fissue-40003.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Frecursion_limit%2Fissue-40003.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursion_limit%2Fissue-40003.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-40003.rs"}, {"sha": "0b1f9ab57c987d499b711922747100fbd1fa024b", "filename": "tests/ui/traits/alias/issue-108132-unmet-trait-alias-bound-on-generic-impl.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Falias%2Fissue-108132-unmet-trait-alias-bound-on-generic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Falias%2Fissue-108132-unmet-trait-alias-bound-on-generic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Falias%2Fissue-108132-unmet-trait-alias-bound-on-generic-impl.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -0,0 +1,15 @@\n+// Regression test for #108132: do not ICE upon unmet trait alias constraint in generic impl\n+\n+#![feature(trait_alias)]\n+\n+trait IteratorAlias = Iterator;\n+\n+struct Foo<I>(I);\n+\n+impl<I: IteratorAlias> Foo<I> {\n+    fn f() {}\n+}\n+\n+fn main() {\n+    Foo::<()>::f() //~ trait bounds were not satisfied\n+}"}, {"sha": "f1b259d5a652d7656fd76e0c8b1a3fbfe524d4c4", "filename": "tests/ui/traits/alias/issue-108132-unmet-trait-alias-bound-on-generic-impl.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Falias%2Fissue-108132-unmet-trait-alias-bound-on-generic-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Falias%2Fissue-108132-unmet-trait-alias-bound-on-generic-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Falias%2Fissue-108132-unmet-trait-alias-bound-on-generic-impl.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -0,0 +1,25 @@\n+error[E0599]: the function or associated item `f` exists for struct `Foo<()>`, but its trait bounds were not satisfied\n+  --> $DIR/issue-108132-unmet-trait-alias-bound-on-generic-impl.rs:14:16\n+   |\n+LL | struct Foo<I>(I);\n+   | ------------- function or associated item `f` not found for this struct\n+...\n+LL |     Foo::<()>::f()\n+   |                ^ function or associated item cannot be called on `Foo<()>` due to unsatisfied trait bounds\n+   |\n+note: trait bound `(): Iterator` was not satisfied\n+  --> $DIR/issue-108132-unmet-trait-alias-bound-on-generic-impl.rs:5:23\n+   |\n+LL | trait IteratorAlias = Iterator;\n+   |       -------------   ^^^^^^^^ unsatisfied trait bound introduced here\n+note: trait bound `(): IteratorAlias` was not satisfied\n+  --> $DIR/issue-108132-unmet-trait-alias-bound-on-generic-impl.rs:9:9\n+   |\n+LL | impl<I: IteratorAlias> Foo<I> {\n+   |         ^^^^^^^^^^^^^  ------\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "a797aae65dba24335d5f7bd406f0cd0ead76d049", "filename": "tests/ui/traits/non_lifetime_binders/basic.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbasic.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+// Basic test that show's we can succesfully typeck a `for<T>` where clause.\n+\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+trait Trait {}\n+\n+impl<T: ?Sized> Trait for T {}\n+\n+fn foo()\n+where\n+    for<T> T: Trait,\n+{\n+}\n+\n+fn main() {\n+    foo();\n+}"}, {"sha": "fddc5d9fc2548bd2306849b43a6ee7e8b1bbdfa8", "filename": "tests/ui/traits/non_lifetime_binders/basic.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbasic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbasic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fbasic.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/basic.rs:4:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "460f68907e889c344f6d463bd67c8a3365f9208a", "filename": "tests/ui/traits/non_lifetime_binders/fail.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Ffail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Ffail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Ffail.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -0,0 +1,23 @@\n+// Error reporting for where `for<T> T: Trait` doesn't hold\n+\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+trait Trait {}\n+\n+fn fail()\n+where\n+    for<T> T: Trait,\n+{}\n+\n+fn auto_trait()\n+where\n+    for<T> T: Send,\n+{}\n+\n+fn main() {\n+    fail();\n+    //~^ ERROR the trait bound `T: Trait` is not satisfied\n+    auto_trait();\n+    //~^ ERROR `T` cannot be sent between threads safely\n+}"}, {"sha": "ba5953193a47bed948a457aa897ba7a135f89daf", "filename": "tests/ui/traits/non_lifetime_binders/fail.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Ffail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Ffail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Ffail.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -0,0 +1,43 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/fail.rs:3:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0277]: the trait bound `T: Trait` is not satisfied\n+  --> $DIR/fail.rs:19:5\n+   |\n+LL |     fail();\n+   |     ^^^^ the trait `Trait` is not implemented for `T`\n+   |\n+note: required by a bound in `fail`\n+  --> $DIR/fail.rs:10:15\n+   |\n+LL | fn fail()\n+   |    ---- required by a bound in this\n+LL | where\n+LL |     for<T> T: Trait,\n+   |               ^^^^^ required by this bound in `fail`\n+\n+error[E0277]: `T` cannot be sent between threads safely\n+  --> $DIR/fail.rs:21:5\n+   |\n+LL |     auto_trait();\n+   |     ^^^^^^^^^^ `T` cannot be sent between threads safely\n+   |\n+   = help: the trait `Send` is not implemented for `T`\n+note: required by a bound in `auto_trait`\n+  --> $DIR/fail.rs:15:15\n+   |\n+LL | fn auto_trait()\n+   |    ---------- required by a bound in this\n+LL | where\n+LL |     for<T> T: Send,\n+   |               ^^^^ required by this bound in `auto_trait`\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8fb7dd27605f931492beff78ec15f9fdf3d01a8f", "filename": "tests/ui/traits/non_lifetime_binders/on-dyn.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-dyn.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -0,0 +1,13 @@\n+// Tests to make sure that we reject polymorphic dyn trait.\n+\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+trait Test<T> {}\n+\n+fn foo() -> &'static dyn for<T> Test<T> {\n+    //~^ ERROR late-bound type parameter not allowed on trait object types\n+    todo!()\n+}\n+\n+fn main() {}"}, {"sha": "44071107de4119aa2f5115a4e9589b4af1faa7b2", "filename": "tests/ui/traits/non_lifetime_binders/on-dyn.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-dyn.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -0,0 +1,17 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/on-dyn.rs:3:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: late-bound type parameter not allowed on trait object types\n+  --> $DIR/on-dyn.rs:8:30\n+   |\n+LL | fn foo() -> &'static dyn for<T> Test<T> {\n+   |                              ^\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "0aaff52b6d8cda6eb4af0905844401c848da21b0", "filename": "tests/ui/traits/non_lifetime_binders/on-ptr.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-ptr.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -0,0 +1,13 @@\n+// Tests to make sure that we reject polymorphic fn ptrs.\n+\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+fn foo() -> for<T> fn(T) {\n+    //~^ ERROR late-bound type parameter not allowed on function pointer types\n+    todo!()\n+}\n+\n+fn main() {\n+    foo()(1i32);\n+}"}, {"sha": "bb7dccaf07d5f0f001deebc3440f8d9a1be6cd6d", "filename": "tests/ui/traits/non_lifetime_binders/on-ptr.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fon-ptr.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "patch": "@@ -0,0 +1,17 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/on-ptr.rs:3:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #1 <https://github.com/rust-lang/rust/issues/1> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: late-bound type parameter not allowed on function pointer types\n+  --> $DIR/on-ptr.rs:6:17\n+   |\n+LL | fn foo() -> for<T> fn(T) {\n+   |                 ^\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "2353904d79d75fadba09cf96e8f82b0d76f53606", "filename": "tests/ui/typeck/issue-53712.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftypeck%2Fissue-53712.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftypeck%2Fissue-53712.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-53712.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-53712.rs"}, {"sha": "db85919afcb556b77a2c84c71e7bfeee24ac262f", "filename": "tests/ui/typeck/issue-53712.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftypeck%2Fissue-53712.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftypeck%2Fissue-53712.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-53712.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-53712.stderr"}, {"sha": "ce549bde60117544063eacde1f106617bb0964ad", "filename": "tests/ui/typeck/issue-7813.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftypeck%2Fissue-7813.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftypeck%2Fissue-7813.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-7813.rs?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-7813.rs"}, {"sha": "2a747f679a84daa430aad2bbb4920e363b9f471e", "filename": "tests/ui/typeck/issue-7813.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftypeck%2Fissue-7813.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5/tests%2Fui%2Ftypeck%2Fissue-7813.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-7813.stderr?ref=ea218392a4ce119c4dfcd8fb94a7fee77f76f2c5", "previous_filename": "tests/ui/issues/issue-7813.stderr"}]}