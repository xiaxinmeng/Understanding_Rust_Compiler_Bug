{"sha": "7b5c59ea6506f9addc3cab6d4af062e7df607aac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiNWM1OWVhNjUwNmY5YWRkYzNjYWI2ZDRhZjA2MmU3ZGY2MDdhYWM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-16T02:52:09Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-23T06:35:33Z"}, "message": "Load extern crates in `resolve`.", "tree": {"sha": "80889247ec8aee97e5410a6e085eb17309744db0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80889247ec8aee97e5410a6e085eb17309744db0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b5c59ea6506f9addc3cab6d4af062e7df607aac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b5c59ea6506f9addc3cab6d4af062e7df607aac", "html_url": "https://github.com/rust-lang/rust/commit/7b5c59ea6506f9addc3cab6d4af062e7df607aac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b5c59ea6506f9addc3cab6d4af062e7df607aac/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "533c04dbb3e44ecb551b743993bd05e17b68236d", "url": "https://api.github.com/repos/rust-lang/rust/commits/533c04dbb3e44ecb551b743993bd05e17b68236d", "html_url": "https://github.com/rust-lang/rust/commit/533c04dbb3e44ecb551b743993bd05e17b68236d"}], "stats": {"total": 253, "additions": 98, "deletions": 155}, "files": [{"sha": "e99ffa95ed63ca3314bb81989ec3a2de3a0f49e4", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=7b5c59ea6506f9addc3cab6d4af062e7df607aac", "patch": "@@ -51,7 +51,6 @@ pub enum DepNode<D: Clone + Debug> {\n     WorkProduct(Arc<WorkProductId>),\n \n     // Represents different phases in the compiler.\n-    CrateReader,\n     CollectLanguageItems,\n     CheckStaticRecursion,\n     ResolveLifetimes,\n@@ -171,7 +170,6 @@ impl<D: Clone + Debug> DepNode<D> {\n \n         match *self {\n             Krate => Some(Krate),\n-            CrateReader => Some(CrateReader),\n             CollectLanguageItems => Some(CollectLanguageItems),\n             CheckStaticRecursion => Some(CheckStaticRecursion),\n             ResolveLifetimes => Some(ResolveLifetimes),"}, {"sha": "62e0de1ba6774bef5851d11f8f5f1a569f09d888", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=7b5c59ea6506f9addc3cab6d4af062e7df607aac", "patch": "@@ -25,7 +25,7 @@\n use hir::def::{self, Def};\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n-use hir::map::definitions::DefKey;\n+use hir::map::definitions::{Definitions, DefKey};\n use hir::svh::Svh;\n use middle::lang_items;\n use ty::{self, Ty, TyCtxt};\n@@ -422,6 +422,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n-pub trait MacroLoader {\n-     fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n+pub trait CrateLoader {\n+    fn load_macros(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n+    fn process_item(&mut self, item: &ast::Item, defs: &Definitions);\n+    fn postprocess(&mut self, krate: &ast::Crate);\n }"}, {"sha": "ae80bc53c4c36fd2712d04b2f2654eefa0efe0e8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7b5c59ea6506f9addc3cab6d4af062e7df607aac", "patch": "@@ -28,8 +28,7 @@ use rustc_back::sha2::{Sha256, Digest};\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_resolve::{MakeGlobMap, Resolver};\n-use rustc_metadata::macro_import;\n-use rustc_metadata::creader::read_local_crates;\n+use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n use rustc_trans::back::{link, write};\n use rustc_trans as trans;\n@@ -639,12 +638,10 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     }\n     sess.track_errors(|| sess.lint_store.borrow_mut().process_command_line(sess))?;\n \n-    let mut macro_loader =\n-        macro_import::MacroLoader::new(sess, &cstore, crate_name, krate.config.clone());\n-\n+    let mut crate_loader = CrateLoader::new(sess, &cstore, &krate, crate_name);\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver =\n-        Resolver::new(sess, &krate, make_glob_map, &mut macro_loader, &resolver_arenas);\n+        Resolver::new(sess, &krate, make_glob_map, &mut crate_loader, &resolver_arenas);\n     syntax_ext::register_builtins(&mut resolver, sess.features.borrow().quote);\n \n     krate = time(time_passes, \"expansion\", || {\n@@ -736,11 +733,6 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     // Collect defintions for def ids.\n     time(sess.time_passes(), \"collecting defs\", || resolver.definitions.collect(&krate));\n \n-    time(sess.time_passes(), \"external crate/lib resolution\", || {\n-        let defs = &resolver.definitions;\n-        read_local_crates(sess, &cstore, defs, &krate, crate_name, &sess.dep_graph)\n-    });\n-\n     time(sess.time_passes(),\n          \"early lint checks\",\n          || lint::check_ast_crate(sess, &krate));"}, {"sha": "71cc13aebb37044862863f22eec53071b8a48a31", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 74, "deletions": 109, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=7b5c59ea6506f9addc3cab6d4af062e7df607aac", "patch": "@@ -12,14 +12,15 @@\n \n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use loader::{self, CratePaths};\n+use macro_import;\n use schema::CrateRoot;\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n-use rustc::dep_graph::{DepGraph, DepNode};\n use rustc::session::{config, Session};\n use rustc::session::config::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n+use rustc::middle;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n use rustc::hir::map as hir_map;\n@@ -31,20 +32,18 @@ use std::rc::Rc;\n use std::fs;\n \n use syntax::ast;\n+use syntax::ext::base::LoadedMacro;\n use syntax::abi::Abi;\n use syntax::parse;\n use syntax::attr;\n use syntax::parse::token::InternedString;\n-use syntax::visit;\n use syntax_pos::{self, Span, mk_sp};\n use log;\n \n-struct LocalCrateReader<'a> {\n-    sess: &'a Session,\n+pub struct CrateLoader<'a> {\n+    pub sess: &'a Session,\n+    pub creader: CrateReader<'a>,\n     cstore: &'a CStore,\n-    creader: CrateReader<'a>,\n-    krate: &'a ast::Crate,\n-    definitions: &'a hir_map::Definitions,\n }\n \n pub struct CrateReader<'a> {\n@@ -56,13 +55,6 @@ pub struct CrateReader<'a> {\n     local_crate_config: ast::CrateConfig,\n }\n \n-impl<'a> visit::Visitor for LocalCrateReader<'a> {\n-    fn visit_item(&mut self, a: &ast::Item) {\n-        self.process_item(a);\n-        visit::walk_item(self, a);\n-    }\n-}\n-\n fn dump_crates(cstore: &CStore) {\n     info!(\"resolved crates:\");\n     cstore.iter_crate_data_origins(|_, data, opt_source| {\n@@ -918,98 +910,22 @@ impl ExtensionCrate {\n     }\n }\n \n-impl<'a> LocalCrateReader<'a> {\n-    fn new(sess: &'a Session,\n-           cstore: &'a CStore,\n-           defs: &'a hir_map::Definitions,\n-           krate: &'a ast::Crate,\n-           local_crate_name: &str)\n-           -> LocalCrateReader<'a> {\n-        LocalCrateReader {\n+impl<'a> CrateLoader<'a> {\n+    pub fn new(sess: &'a Session, cstore: &'a CStore, krate: &ast::Crate, crate_name: &str)\n+               -> Self {\n+        let loader = CrateLoader {\n             sess: sess,\n             cstore: cstore,\n-            creader: CrateReader::new(sess, cstore, local_crate_name, krate.config.clone()),\n-            krate: krate,\n-            definitions: defs,\n-        }\n-    }\n-\n-    // Traverses an AST, reading all the information about use'd crates and\n-    // extern libraries necessary for later resolving, typechecking, linking,\n-    // etc.\n-    fn read_crates(&mut self, dep_graph: &DepGraph) {\n-        let _task = dep_graph.in_task(DepNode::CrateReader);\n-\n-        self.process_crate(self.krate);\n-        visit::walk_crate(self, self.krate);\n-        self.creader.inject_allocator_crate();\n-        self.creader.inject_panic_runtime(self.krate);\n-\n-        if log_enabled!(log::INFO) {\n-            dump_crates(&self.cstore);\n-        }\n-\n-        for &(ref name, kind) in &self.sess.opts.libs {\n-            register_native_lib(self.sess, self.cstore, None, name.clone(), kind);\n-        }\n-        self.creader.register_statically_included_foreign_items();\n-    }\n+            creader: CrateReader::new(sess, cstore, crate_name, krate.config.clone()),\n+        };\n \n-    fn process_crate(&self, c: &ast::Crate) {\n-        for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n-            if let Some(ref linkarg) = a.value_str() {\n-                self.cstore.add_used_link_args(&linkarg);\n+        for attr in krate.attrs.iter().filter(|m| m.name() == \"link_args\") {\n+            if let Some(ref linkarg) = attr.value_str() {\n+                loader.cstore.add_used_link_args(&linkarg);\n             }\n         }\n-    }\n \n-    fn process_item(&mut self, i: &ast::Item) {\n-        match i.node {\n-            ast::ItemKind::ExternCrate(_) => {\n-                // If this `extern crate` item has `#[macro_use]` then we can\n-                // safely skip it. These annotations were processed during macro\n-                // expansion and are already loaded (if necessary) into our\n-                // crate store.\n-                //\n-                // Note that it's important we *don't* fall through below as\n-                // some `#[macro_use]` crate are explicitly not linked (e.g.\n-                // macro crates) so we want to ensure we avoid `resolve_crate`\n-                // with those.\n-                if attr::contains_name(&i.attrs, \"macro_use\") {\n-                    if self.cstore.was_used_for_derive_macros(i) {\n-                        return\n-                    }\n-                }\n-\n-                if let Some(info) = self.creader.extract_crate_info(i) {\n-                    if !info.should_link {\n-                        return;\n-                    }\n-                    let (cnum, ..) = self.creader.resolve_crate(&None,\n-                                                                &info.ident,\n-                                                                &info.name,\n-                                                                None,\n-                                                                i.span,\n-                                                                PathKind::Crate,\n-                                                                true);\n-\n-                    let def_id = self.definitions.opt_local_def_id(i.id).unwrap();\n-                    let len = self.definitions.def_path(def_id.index).data.len();\n-\n-                    self.creader.update_extern_crate(cnum,\n-                                                     ExternCrate {\n-                                                         def_id: def_id,\n-                                                         span: i.span,\n-                                                         direct: true,\n-                                                         path_len: len,\n-                                                     },\n-                                                     &mut FnvHashSet());\n-                    self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n-                }\n-            }\n-            ast::ItemKind::ForeignMod(ref fm) => self.process_foreign_mod(i, fm),\n-            _ => { }\n-        }\n+        loader\n     }\n \n     fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod) {\n@@ -1073,13 +989,62 @@ impl<'a> LocalCrateReader<'a> {\n     }\n }\n \n-/// Traverses an AST, reading all the information about use'd crates and extern\n-/// libraries necessary for later resolving, typechecking, linking, etc.\n-pub fn read_local_crates(sess: & Session,\n-                         cstore: & CStore,\n-                         defs: & hir_map::Definitions,\n-                         krate: & ast::Crate,\n-                         local_crate_name: &str,\n-                         dep_graph: &DepGraph) {\n-    LocalCrateReader::new(sess, cstore, defs, krate, local_crate_name).read_crates(dep_graph)\n+impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n+    fn postprocess(&mut self, krate: &ast::Crate) {\n+        self.creader.inject_allocator_crate();\n+        self.creader.inject_panic_runtime(krate);\n+\n+        if log_enabled!(log::INFO) {\n+            dump_crates(&self.cstore);\n+        }\n+\n+        for &(ref name, kind) in &self.sess.opts.libs {\n+            register_native_lib(self.sess, self.cstore, None, name.clone(), kind);\n+        }\n+        self.creader.register_statically_included_foreign_items();\n+    }\n+\n+    fn process_item(&mut self, item: &ast::Item, definitions: &hir_map::Definitions) {\n+        match item.node {\n+            ast::ItemKind::ExternCrate(_) => {}\n+            ast::ItemKind::ForeignMod(ref fm) => return self.process_foreign_mod(item, fm),\n+            _ => return,\n+        }\n+\n+        // If this `extern crate` item has `#[macro_use]` then we can safely skip it.\n+        // These annotations were processed during macro expansion and are already loaded\n+        // (if necessary) into our crate store.\n+        //\n+        // Note that it's important we *don't* fall through below as some `#[macro_use]`\n+        // crates are explicitly not linked (e.g. macro crates) so we want to ensure\n+        // we avoid `resolve_crate` with those.\n+        if attr::contains_name(&item.attrs, \"macro_use\") {\n+            if self.cstore.was_used_for_derive_macros(item) {\n+                return\n+            }\n+        }\n+\n+        if let Some(info) = self.creader.extract_crate_info(item) {\n+            if !info.should_link {\n+                return;\n+            }\n+\n+            let (cnum, ..) = self.creader.resolve_crate(\n+                &None, &info.ident, &info.name, None, item.span, PathKind::Crate, true,\n+            );\n+\n+            let def_id = definitions.opt_local_def_id(item.id).unwrap();\n+            let len = definitions.def_path(def_id.index).data.len();\n+\n+            let extern_crate =\n+                ExternCrate { def_id: def_id, span: item.span, direct: true, path_len: len };\n+            self.creader.update_extern_crate(cnum, extern_crate, &mut FnvHashSet());\n+\n+            self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+        }\n+    }\n+\n+    fn load_macros(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro> {\n+        macro_import::load_macros(self, extern_crate, allows_macros)\n+    }\n }"}, {"sha": "3fe4404525650481ce383d9ffbffd1e5c57dc817", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=7b5c59ea6506f9addc3cab6d4af062e7df607aac", "patch": "@@ -14,11 +14,9 @@ use std::collections::HashSet;\n use std::env;\n use std::mem;\n \n-use creader::{CrateReader, Macros};\n-use cstore::CStore;\n+use creader::{CrateLoader, Macros};\n \n use rustc::hir::def_id::DefIndex;\n-use rustc::middle;\n use rustc::session::Session;\n use rustc::util::nodemap::FnvHashMap;\n use rustc_back::dynamic_lib::DynamicLibrary;\n@@ -31,31 +29,18 @@ use syntax::parse::token;\n use syntax_ext::deriving::custom::CustomDerive;\n use syntax_pos::Span;\n \n-pub struct MacroLoader<'a> {\n-    sess: &'a Session,\n-    reader: CrateReader<'a>,\n-}\n-\n-impl<'a> MacroLoader<'a> {\n-    pub fn new(sess: &'a Session,\n-               cstore: &'a CStore,\n-               crate_name: &str,\n-               crate_config: ast::CrateConfig)\n-               -> MacroLoader<'a> {\n-        MacroLoader {\n-            sess: sess,\n-            reader: CrateReader::new(sess, cstore, crate_name, crate_config),\n-        }\n-    }\n-}\n-\n pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n     span_err!(a, b, E0467, \"bad macro reexport\");\n }\n \n pub type MacroSelection = FnvHashMap<token::InternedString, Span>;\n \n-impl<'a> middle::cstore::MacroLoader for MacroLoader<'a> {\n+pub fn load_macros(loader: &mut CrateLoader, extern_crate: &ast::Item, allows_macros: bool)\n+                   -> Vec<LoadedMacro> {\n+    loader.load_crate(extern_crate, allows_macros)\n+}\n+\n+impl<'a> CrateLoader<'a> {\n     fn load_crate(&mut self,\n                   extern_crate: &ast::Item,\n                   allows_macros: bool) -> Vec<LoadedMacro> {\n@@ -108,9 +93,7 @@ impl<'a> middle::cstore::MacroLoader for MacroLoader<'a> {\n \n         self.load_macros(extern_crate, allows_macros, import, reexport)\n     }\n-}\n \n-impl<'a> MacroLoader<'a> {\n     fn load_macros<'b>(&mut self,\n                        vi: &ast::Item,\n                        allows_macros: bool,\n@@ -129,7 +112,7 @@ impl<'a> MacroLoader<'a> {\n             return Vec::new();\n         }\n \n-        let mut macros = self.reader.read_macros(vi);\n+        let mut macros = self.creader.read_macros(vi);\n         let mut ret = Vec::new();\n         let mut seen = HashSet::new();\n "}, {"sha": "9202f8c0946f47e3ebb2a5c4c1ed6769e1f00e7a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7b5c59ea6506f9addc3cab6d4af062e7df607aac", "patch": "@@ -79,6 +79,8 @@ impl<'b> Resolver<'b> {\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item) {\n+        self.crate_loader.process_item(item, &self.definitions);\n+\n         let parent = self.current_module;\n         let name = item.ident.name;\n         let sp = item.span;"}, {"sha": "63ff9de2be29a82dda14fb16cf0a676c602847b9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7b5c59ea6506f9addc3cab6d4af062e7df607aac", "patch": "@@ -44,7 +44,7 @@ use self::ModulePrefixResult::*;\n \n use rustc::hir::map::Definitions;\n use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n-use rustc::middle::cstore::MacroLoader;\n+use rustc::middle::cstore::CrateLoader;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n@@ -1066,7 +1066,7 @@ pub struct Resolver<'a> {\n     dummy_binding: &'a NameBinding<'a>,\n     new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n \n-    macro_loader: &'a mut MacroLoader,\n+    crate_loader: &'a mut CrateLoader,\n     macro_names: FnvHashSet<Name>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n@@ -1172,7 +1172,7 @@ impl<'a> Resolver<'a> {\n     pub fn new(session: &'a Session,\n                krate: &Crate,\n                make_glob_map: MakeGlobMap,\n-               macro_loader: &'a mut MacroLoader,\n+               crate_loader: &'a mut CrateLoader,\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def = Def::Mod(DefId::local(CRATE_DEF_INDEX));\n@@ -1240,7 +1240,7 @@ impl<'a> Resolver<'a> {\n             }),\n             new_import_semantics: session.features.borrow().item_like_imports,\n \n-            macro_loader: macro_loader,\n+            crate_loader: crate_loader,\n             macro_names: FnvHashSet(),\n             expansion_data: expansion_data,\n         }\n@@ -1263,6 +1263,7 @@ impl<'a> Resolver<'a> {\n \n         check_unused::check_crate(self, krate);\n         self.report_errors();\n+        self.crate_loader.postprocess(krate);\n     }\n \n     fn new_module(&self, parent: Module<'a>, kind: ModuleKind, local: bool) -> Module<'a> {"}, {"sha": "0b2a70bf4a68db492de26a7409b2c282a56e1291", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5c59ea6506f9addc3cab6d4af062e7df607aac/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=7b5c59ea6506f9addc3cab6d4af062e7df607aac", "patch": "@@ -38,7 +38,7 @@ struct ModuleData {\n \n impl<'a> base::Resolver for Resolver<'a> {\n     fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro> {\n-        self.macro_loader.load_crate(extern_crate, allows_macros)\n+        self.crate_loader.load_macros(extern_crate, allows_macros)\n     }\n \n     fn next_node_id(&mut self) -> ast::NodeId {"}]}