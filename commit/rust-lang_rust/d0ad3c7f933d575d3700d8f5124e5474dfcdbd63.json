{"sha": "d0ad3c7f933d575d3700d8f5124e5474dfcdbd63", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYWQzYzdmOTMzZDU3NWQzNzAwZDhmNTEyNGU1NDc0ZGZjZGJkNjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-09T17:24:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-09T17:24:50Z"}, "message": "rollup merge of #19594: Arcterus/master\n\nIt is useful to have configurable newlines in base64 as the standard\nleaves that for the implementation to decide.  GNU `base64` apparently\nuses LF, which meant in `uutils` we had to manually convert the CRLF to\nLF.  This made the program very slow for large inputs.\n\n[breaking-change]", "tree": {"sha": "f5acdb280d284d875a7d36d84a625a480f73707e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5acdb280d284d875a7d36d84a625a480f73707e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0ad3c7f933d575d3700d8f5124e5474dfcdbd63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0ad3c7f933d575d3700d8f5124e5474dfcdbd63", "html_url": "https://github.com/rust-lang/rust/commit/d0ad3c7f933d575d3700d8f5124e5474dfcdbd63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0ad3c7f933d575d3700d8f5124e5474dfcdbd63/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae60f9c59289adf8e46b2b3152f618caffc74bf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae60f9c59289adf8e46b2b3152f618caffc74bf4", "html_url": "https://github.com/rust-lang/rust/commit/ae60f9c59289adf8e46b2b3152f618caffc74bf4"}, {"sha": "a119ad83c73c7e1c99c7e21fb2ab21bd9521077a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a119ad83c73c7e1c99c7e21fb2ab21bd9521077a", "html_url": "https://github.com/rust-lang/rust/commit/a119ad83c73c7e1c99c7e21fb2ab21bd9521077a"}], "stats": {"total": 96, "additions": 64, "deletions": 32}, "files": [{"sha": "59faf75c0c30cffccb66c2828135d539fee4e506", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 63, "deletions": 31, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d0ad3c7f933d575d3700d8f5124e5474dfcdbd63/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ad3c7f933d575d3700d8f5124e5474dfcdbd63/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=d0ad3c7f933d575d3700d8f5124e5474dfcdbd63", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -28,10 +28,22 @@ pub enum CharacterSet {\n \n impl Copy for CharacterSet {}\n \n+/// Available newline types\n+pub enum Newline {\n+    /// A linefeed (i.e. Unix-style newline)\n+    LF,\n+    /// A carriage return and a linefeed (i.e. Windows-style newline)\n+    CRLF\n+}\n+\n+impl Copy for Newline {}\n+\n /// Contains configuration parameters for `to_base64`.\n pub struct Config {\n     /// Character set to use\n     pub char_set: CharacterSet,\n+    /// Newline to use\n+    pub newline: Newline,\n     /// True to pad output with `=` characters\n     pub pad: bool,\n     /// `Some(len)` to wrap lines at `len`, `None` to disable line wrapping\n@@ -42,15 +54,15 @@ impl Copy for Config {}\n \n /// Configuration for RFC 4648 standard base64 encoding\n pub static STANDARD: Config =\n-    Config {char_set: Standard, pad: true, line_length: None};\n+    Config {char_set: Standard, newline: Newline::CRLF, pad: true, line_length: None};\n \n /// Configuration for RFC 4648 base64url encoding\n pub static URL_SAFE: Config =\n-    Config {char_set: UrlSafe, pad: false, line_length: None};\n+    Config {char_set: UrlSafe, newline: Newline::CRLF, pad: false, line_length: None};\n \n /// Configuration for RFC 2045 MIME base64 encoding\n pub static MIME: Config =\n-    Config {char_set: Standard, pad: true, line_length: Some(76)};\n+    Config {char_set: Standard, newline: Newline::CRLF, pad: true, line_length: Some(76)};\n \n static STANDARD_CHARS: &'static[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                                         abcdefghijklmnopqrstuvwxyz\\\n@@ -87,24 +99,30 @@ impl ToBase64 for [u8] {\n             UrlSafe => URLSAFE_CHARS\n         };\n \n-        let mut v = Vec::new();\n+        // In general, this Vec only needs (4/3) * self.len() memory, but\n+        // addition is faster than multiplication and division.\n+        let mut v = Vec::with_capacity(self.len() + self.len());\n         let mut i = 0;\n         let mut cur_length = 0;\n         let len = self.len();\n-        while i < len - (len % 3) {\n-            match config.line_length {\n-                Some(line_length) =>\n-                    if cur_length >= line_length {\n-                        v.push(b'\\r');\n-                        v.push(b'\\n');\n-                        cur_length = 0;\n-                    },\n-                None => ()\n+        let mod_len = len % 3;\n+        let cond_len = len - mod_len;\n+        let newline = match config.newline {\n+            Newline::LF => b\"\\n\",\n+            Newline::CRLF => b\"\\r\\n\"\n+        };\n+        while i < cond_len {\n+            let (first, second, third) = (self[i], self[i + 1], self[i + 2]);\n+            if let Some(line_length) = config.line_length {\n+                if cur_length >= line_length {\n+                    v.push_all(newline);\n+                    cur_length = 0;\n+                }\n             }\n \n-            let n = (self[i] as u32) << 16 |\n-                    (self[i + 1] as u32) << 8 |\n-                    (self[i + 2] as u32);\n+            let n = (first  as u32) << 16 |\n+                    (second as u32) << 8 |\n+                    (third  as u32);\n \n             // This 24-bit number gets separated into four 6-bit numbers.\n             v.push(bytes[((n >> 18) & 63) as uint]);\n@@ -116,20 +134,17 @@ impl ToBase64 for [u8] {\n             i += 3;\n         }\n \n-        if len % 3 != 0 {\n-            match config.line_length {\n-                Some(line_length) =>\n-                    if cur_length >= line_length {\n-                        v.push(b'\\r');\n-                        v.push(b'\\n');\n-                    },\n-                None => ()\n+        if mod_len != 0 {\n+            if let Some(line_length) = config.line_length {\n+                if cur_length >= line_length {\n+                    v.push_all(newline);\n+                }\n             }\n         }\n \n         // Heh, would be cool if we knew this was exhaustive\n         // (the dream of bounded integer types)\n-        match len % 3 {\n+        match mod_len {\n             0 => (),\n             1 => {\n                 let n = (self[i] as u32) << 16;\n@@ -232,7 +247,7 @@ impl FromBase64 for str {\n \n impl FromBase64 for [u8] {\n     fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error> {\n-        let mut r = Vec::new();\n+        let mut r = Vec::with_capacity(self.len());\n         let mut buf: u32 = 0;\n         let mut modulus = 0i;\n \n@@ -288,7 +303,7 @@ impl FromBase64 for [u8] {\n mod tests {\n     extern crate test;\n     use self::test::Bencher;\n-    use base64::{Config, FromBase64, ToBase64, STANDARD, URL_SAFE};\n+    use base64::{Config, Newline, FromBase64, ToBase64, STANDARD, URL_SAFE};\n \n     #[test]\n     fn test_to_base64_basic() {\n@@ -302,14 +317,27 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_to_base64_line_break() {\n+    fn test_to_base64_crlf_line_break() {\n         assert!(![0u8, ..1000].to_base64(Config {line_length: None, ..STANDARD})\n                               .contains(\"\\r\\n\"));\n-        assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n-                                                         ..STANDARD}),\n+        assert_eq!(b\"foobar\".to_base64(Config {line_length: Some(4),\n+                                               ..STANDARD}),\n                    \"Zm9v\\r\\nYmFy\");\n     }\n \n+    #[test]\n+    fn test_to_base64_lf_line_break() {\n+        assert!(![0u8, ..1000].to_base64(Config {line_length: None,\n+                                                 newline: Newline::LF,\n+                                                 ..STANDARD})\n+                              .as_slice()\n+                              .contains(\"\\n\"));\n+        assert_eq!(b\"foobar\".to_base64(Config {line_length: Some(4),\n+                                               newline: Newline::LF,\n+                                               ..STANDARD}),\n+                   \"Zm9v\\nYmFy\");\n+    }\n+\n     #[test]\n     fn test_to_base64_padding() {\n         assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\");\n@@ -344,6 +372,10 @@ mod tests {\n                    b\"foobar\");\n         assert_eq!(\"Zm9vYg==\\r\\n\".from_base64().unwrap(),\n                    b\"foob\");\n+        assert_eq!(\"Zm9v\\nYmFy\".from_base64().unwrap(),\n+                   b\"foobar\");\n+        assert_eq!(\"Zm9vYg==\\n\".from_base64().unwrap(),\n+                   b\"foob\");\n     }\n \n     #[test]"}, {"sha": "1cff4c334e7430d1d8827e6e89281e0c862dc934", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ad3c7f933d575d3700d8f5124e5474dfcdbd63/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ad3c7f933d575d3700d8f5124e5474dfcdbd63/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=d0ad3c7f933d575d3700d8f5124e5474dfcdbd63", "patch": "@@ -23,7 +23,7 @@ Core encoding and decoding interfaces.\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n-#![feature(macro_rules, default_type_params, phase, slicing_syntax, globs)]\n+#![feature(macro_rules, default_type_params, phase, slicing_syntax, globs, if_let)]\n \n // test harness access\n #[cfg(test)]"}]}