{"sha": "1af79cf34e1fd6f38ba256631e2997ca650e490b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZjc5Y2YzNGUxZmQ2ZjM4YmEyNTY2MzFlMjk5N2NhNjUwZTQ5MGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-02T12:14:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-02T12:14:25Z"}, "message": "Auto merge of #32562 - ben0x539:bug-macro, r=nikomatsakis\n\nlibrustc: Add bug!(), bug_span!() macros as unified entry points for internal compiler errors\n\nThe macros pass `file!()`, `line!()` and `format_args!(...)` on to a cold, never-inlined function, ultimately calling `session::{span_,}bug_fmt` via the tcx in tls or, failing that, panicking directly.\n\ncc @eddyb\nr? @nikomatsakis", "tree": {"sha": "948fcb5f24d7ab395263ac9bdf6cc34214051f1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/948fcb5f24d7ab395263ac9bdf6cc34214051f1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1af79cf34e1fd6f38ba256631e2997ca650e490b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1af79cf34e1fd6f38ba256631e2997ca650e490b", "html_url": "https://github.com/rust-lang/rust/commit/1af79cf34e1fd6f38ba256631e2997ca650e490b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1af79cf34e1fd6f38ba256631e2997ca650e490b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2285bdaf57e9cb56120902ae4b3b0a26d761f31", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2285bdaf57e9cb56120902ae4b3b0a26d761f31", "html_url": "https://github.com/rust-lang/rust/commit/f2285bdaf57e9cb56120902ae4b3b0a26d761f31"}, {"sha": "33cc0ed1f0c7aab766f2572481cea5a0401b8b8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/33cc0ed1f0c7aab766f2572481cea5a0401b8b8e", "html_url": "https://github.com/rust-lang/rust/commit/33cc0ed1f0c7aab766f2572481cea5a0401b8b8e"}], "stats": {"total": 2777, "additions": 1326, "deletions": 1451}, "files": [{"sha": "cd1e3b5f30e9ce22b0e6dd045e85e2255a6e6419", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -583,13 +583,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         return *l;\n                     }\n                 }\n-                self.tcx.sess.span_bug(expr.span,\n-                    &format!(\"no loop scope for id {}\", loop_id));\n+                span_bug!(expr.span, \"no loop scope for id {}\", loop_id);\n             }\n \n             r => {\n-                self.tcx.sess.span_bug(expr.span,\n-                    &format!(\"bad entry `{:?}` in def_map for label\", r));\n+                span_bug!(expr.span, \"bad entry `{:?}` in def_map for label\", r);\n             }\n         }\n     }"}, {"sha": "d3ced8aa518bbb3f6e9a1d21aaaad3bbacf43188", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -122,7 +122,7 @@ impl DepGraphEdges {\n     {\n         match self.current_node() {\n             Some(open_node) => self.add_edge_from_open_node(open_node, op),\n-            None => panic!(\"no current node, cannot add edge into dependency graph\")\n+            None => bug!(\"no current node, cannot add edge into dependency graph\")\n         }\n     }\n "}, {"sha": "1b1d3469bc53f6428a9fc6c1f12c0a82a7a7f8dd", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -148,7 +148,7 @@ impl DepGraphThreadData {\n \n     // Outline this too.\n     fn invalid_message(&self, string: &str) {\n-        panic!(\"{}; see src/librustc/dep_graph/README.md for more information\", string)\n+        bug!(\"{}; see src/librustc/dep_graph/README.md for more information\", string)\n     }\n }\n "}, {"sha": "2eb3d56bb5e4e1be3921b68d30d80bbbfc2c816b", "filename": "src/librustc/front/map/blocks.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -231,21 +231,21 @@ impl<'a> FnLikeNode<'a> {\n                         span: i.span,\n                         attrs: &i.attrs,\n                     }),\n-                _ => panic!(\"item FnLikeNode that is not fn-like\"),\n+                _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n             map::NodeTraitItem(ti) => match ti.node {\n                 ast::MethodTraitItem(ref sig, Some(ref body)) => {\n                     method(ti.id, ti.name, sig, None, body, ti.span, &ti.attrs)\n                 }\n-                _ => panic!(\"trait method FnLikeNode that is not fn-like\"),\n+                _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::NodeImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, ref body) => {\n                         method(ii.id, ii.name, sig, Some(ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => {\n-                        panic!(\"impl method FnLikeNode that is not fn-like\")\n+                        bug!(\"impl method FnLikeNode that is not fn-like\")\n                     }\n                 }\n             }\n@@ -256,9 +256,9 @@ impl<'a> FnLikeNode<'a> {\n                                               e.id,\n                                               e.span,\n                                               e.attrs.as_attr_slice())),\n-                _ => panic!(\"expr FnLikeNode that is not fn-like\"),\n+                _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },\n-            _ => panic!(\"other FnLikeNode that is not fn-like\"),\n+            _ => bug!(\"other FnLikeNode that is not fn-like\"),\n         }\n     }\n }"}, {"sha": "817bec5840797dff8ccde08b696c298c5f57192c", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -335,9 +335,9 @@ impl<'ast> Map<'ast> {\n                     return self.opt_local_def_id(id)\n                                .map(|def_id| DepNode::Hir(def_id))\n                                .unwrap_or_else(|| {\n-                                   panic!(\"Walking parents from `{}` \\\n-                                           led to `NotPresent` at `{}`\",\n-                                          id0, id)\n+                                   bug!(\"Walking parents from `{}` \\\n+                                         led to `NotPresent` at `{}`\",\n+                                        id0, id)\n                                }),\n             }\n         }\n@@ -363,8 +363,8 @@ impl<'ast> Map<'ast> {\n \n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| {\n-            panic!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\",\n-                   node, self.find_entry(node))\n+            bug!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\",\n+                 node, self.find_entry(node))\n         })\n     }\n \n@@ -402,7 +402,7 @@ impl<'ast> Map<'ast> {\n     pub fn get(&self, id: NodeId) -> Node<'ast> {\n         match self.find(id) {\n             Some(node) => node, // read recorded by `find`\n-            None => panic!(\"couldn't find node id {} in the AST map\", id)\n+            None => bug!(\"couldn't find node id {} in the AST map\", id)\n         }\n     }\n \n@@ -576,22 +576,22 @@ impl<'ast> Map<'ast> {\n                 self.read(id); // reveals some of the content of a node\n                 abi\n             }\n-            None => panic!(\"expected foreign mod or inlined parent, found {}\",\n+            None => bug!(\"expected foreign mod or inlined parent, found {}\",\n                           self.node_to_string(parent))\n         }\n     }\n \n     pub fn expect_item(&self, id: NodeId) -> &'ast Item {\n         match self.find(id) { // read recorded by `find`\n             Some(NodeItem(item)) => item,\n-            _ => panic!(\"expected item, found {}\", self.node_to_string(id))\n+            _ => bug!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_trait_item(&self, id: NodeId) -> &'ast TraitItem {\n         match self.find(id) {\n             Some(NodeTraitItem(item)) => item,\n-            _ => panic!(\"expected trait item, found {}\", self.node_to_string(id))\n+            _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -600,38 +600,38 @@ impl<'ast> Map<'ast> {\n             Some(NodeItem(i)) => {\n                 match i.node {\n                     ItemStruct(ref struct_def, _) => struct_def,\n-                    _ => panic!(\"struct ID bound to non-struct\")\n+                    _ => bug!(\"struct ID bound to non-struct\")\n                 }\n             }\n             Some(NodeVariant(variant)) => {\n                 if variant.node.data.is_struct() {\n                     &variant.node.data\n                 } else {\n-                    panic!(\"struct ID bound to enum variant that isn't struct-like\")\n+                    bug!(\"struct ID bound to enum variant that isn't struct-like\")\n                 }\n             }\n-            _ => panic!(format!(\"expected struct, found {}\", self.node_to_string(id))),\n+            _ => bug!(\"expected struct, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_variant(&self, id: NodeId) -> &'ast Variant {\n         match self.find(id) {\n             Some(NodeVariant(variant)) => variant,\n-            _ => panic!(format!(\"expected variant, found {}\", self.node_to_string(id))),\n+            _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_foreign_item(&self, id: NodeId) -> &'ast ForeignItem {\n         match self.find(id) {\n             Some(NodeForeignItem(item)) => item,\n-            _ => panic!(\"expected foreign item, found {}\", self.node_to_string(id))\n+            _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_expr(&self, id: NodeId) -> &'ast Expr {\n         match self.find(id) { // read recorded by find\n             Some(NodeExpr(expr)) => expr,\n-            _ => panic!(\"expected expr, found {}\", self.node_to_string(id))\n+            _ => bug!(\"expected expr, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -656,7 +656,7 @@ impl<'ast> Map<'ast> {\n             NodeLocal(&Pat { node: PatKind::Ident(_,l,_), .. }) => {\n                 PathName(l.node.name)\n             },\n-            _ => panic!(\"no path elem for {:?}\", node)\n+            _ => bug!(\"no path elem for {:?}\", node)\n         }\n     }\n \n@@ -773,7 +773,7 @@ impl<'ast> Map<'ast> {\n     pub fn span(&self, id: NodeId) -> Span {\n         self.read(id); // reveals span from node\n         self.opt_span(id)\n-            .unwrap_or_else(|| panic!(\"AstMap.span: could not find span for id {:?}\", id))\n+            .unwrap_or_else(|| bug!(\"AstMap.span: could not find span for id {:?}\", id))\n     }\n \n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n@@ -1019,12 +1019,12 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             NodePat(a)         => self.print_pat(&a),\n             NodeBlock(a)       => self.print_block(&a),\n             NodeLifetime(a)    => self.print_lifetime(&a),\n-            NodeTyParam(_)     => panic!(\"cannot print TyParam\"),\n+            NodeTyParam(_)     => bug!(\"cannot print TyParam\"),\n             // these cases do not carry enough information in the\n             // ast_map to reconstruct their full structure for pretty\n             // printing.\n-            NodeLocal(_)       => panic!(\"cannot print isolated Local\"),\n-            NodeStructCtor(_)  => panic!(\"cannot print isolated StructCtor\"),\n+            NodeLocal(_)       => bug!(\"cannot print isolated Local\"),\n+            NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n         }\n     }\n }"}, {"sha": "8edf24fbc25acb509f492acb53abf27f54a12d81", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -339,10 +339,10 @@ impl<'cx, 'tcx> ty::fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n             // Early-bound regions should really have been substituted away before\n             // we get to this point.\n             ty::ReEarlyBound(..) => {\n-                self.tcx().sess.span_bug(\n+                span_bug!(\n                     self.span,\n-                    &format!(\"Encountered early bound region when generalizing: {:?}\",\n-                            r));\n+                    \"Encountered early bound region when generalizing: {:?}\",\n+                    r);\n             }\n \n             // Always make a fresh region variable for skolemized regions;"}, {"sha": "8079a6d1bbcaf2765b76caabe52df7121f4d0b17", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -404,7 +404,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     bound_failures.push((origin.clone(), kind.clone(), region));\n                 }\n                 ProcessedErrors(..) => {\n-                    panic!(\"should not encounter a `ProcessedErrors` yet: {:?}\", error)\n+                    bug!(\"should not encounter a `ProcessedErrors` yet: {:?}\", error)\n                 }\n             }\n         }"}, {"sha": "b0f1e9d890c47d0888b3f47a07871072c34cf1ba", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -140,11 +140,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::TyInfer(ty::FreshIntTy(c)) |\n             ty::TyInfer(ty::FreshFloatTy(c)) => {\n                 if c >= self.freshen_count {\n-                    tcx.sess.bug(\n-                        &format!(\"Encountered a freshend type with id {} \\\n-                                  but our counter is only at {}\",\n-                                 c,\n-                                 self.freshen_count));\n+                    bug!(\"Encountered a freshend type with id {} \\\n+                          but our counter is only at {}\",\n+                         c,\n+                         self.freshen_count);\n                 }\n                 t\n             }"}, {"sha": "d89ef8ef6c31dbf2bb80df81d92d6967a9a7d907", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -183,11 +183,10 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                 }\n             }\n \n-            infcx.tcx.sess.span_bug(\n+            span_bug!(\n                 span,\n-                &format!(\"region {:?} is not associated with \\\n-                         any bound region from A!\",\n-                        r0))\n+                \"region {:?} is not associated with any bound region from A!\",\n+                r0)\n         }\n     }\n \n@@ -297,7 +296,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n \n             if a_r.is_some() && b_r.is_some() && only_new_vars {\n                 // Related to exactly one bound variable from each fn:\n-                return rev_lookup(infcx, span, a_map, a_r.unwrap());\n+                return rev_lookup(span, a_map, a_r.unwrap());\n             } else if a_r.is_none() && b_r.is_none() {\n                 // Not related to bound variables from either fn:\n                 assert!(!r0.is_bound());\n@@ -308,8 +307,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n             }\n         }\n \n-        fn rev_lookup(infcx: &InferCtxt,\n-                      span: Span,\n+        fn rev_lookup(span: Span,\n                       a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n                       r: ty::Region) -> ty::Region\n         {\n@@ -318,9 +316,10 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n                     return ty::ReLateBound(ty::DebruijnIndex::new(1), *a_br);\n                 }\n             }\n-            infcx.tcx.sess.span_bug(\n+            span_bug!(\n                 span,\n-                &format!(\"could not find original bound region for {:?}\", r));\n+                \"could not find original bound region for {:?}\",\n+                r);\n         }\n \n         fn fresh_bound_variable(infcx: &InferCtxt, debruijn: ty::DebruijnIndex) -> ty::Region {\n@@ -336,9 +335,10 @@ fn var_ids<'a, 'tcx>(fields: &CombineFields<'a, 'tcx>,\n        .map(|(_, r)| match *r {\n            ty::ReVar(r) => { r }\n            r => {\n-               fields.tcx().sess.span_bug(\n+               span_bug!(\n                    fields.trace.origin.span(),\n-                   &format!(\"found non-region-vid: {:?}\", r));\n+                   \"found non-region-vid: {:?}\",\n+                   r);\n            }\n        })\n        .collect()"}, {"sha": "35e1be7e5f440495d667daac3a6f396f19d6e6e2", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -471,7 +471,7 @@ pub fn mk_eq_impl_headers<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n     match (a.trait_ref, b.trait_ref) {\n         (Some(a_ref), Some(b_ref)) => mk_eq_trait_refs(cx, a_is_expected, origin, a_ref, b_ref),\n         (None, None) => mk_eqty(cx, a_is_expected, origin, a.self_ty, b.self_ty),\n-        _ => cx.tcx.sess.bug(\"mk_eq_impl_headers given mismatched impl kinds\"),\n+        _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n     }\n }\n \n@@ -536,10 +536,10 @@ pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n     match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n         Ok(v) => v,\n         Err(errors) => {\n-            infcx.tcx.sess.span_bug(\n+            span_bug!(\n                 span,\n-                &format!(\"Encountered errors `{:?}` fulfilling during trans\",\n-                         errors));\n+                \"Encountered errors `{:?}` fulfilling during trans\",\n+                errors);\n         }\n     }\n }\n@@ -1114,9 +1114,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             None if self.errors_since_creation() =>\n                 self.tcx.types.err,\n             None => {\n-                self.tcx.sess.bug(\n-                    &format!(\"no type for node {}: {} in fcx\",\n-                            id, self.tcx.map.node_to_string(id)));\n+                bug!(\"no type for node {}: {} in fcx\",\n+                     id, self.tcx.map.node_to_string(id));\n             }\n         }\n     }\n@@ -1125,7 +1124,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         match self.tables.borrow().node_types.get(&ex.id) {\n             Some(&t) => t,\n             None => {\n-                self.tcx.sess.bug(\"no type for expr in fcx\");\n+                bug!(\"no type for expr in fcx\");\n             }\n         }\n     }"}, {"sha": "e611c005691f0ccc6ba44dda974ebe17d081e5a2", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -90,7 +90,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n         };\n \n         if output_template.is_empty() {\n-            tcx.sess.bug(\"empty string provided as RUST_REGION_GRAPH\");\n+            bug!(\"empty string provided as RUST_REGION_GRAPH\");\n         }\n \n         if output_template.contains('%') {\n@@ -182,13 +182,13 @@ impl<'a, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'tcx> {\n     fn node_id(&self, n: &Node) -> dot::Id {\n         let node_id = match self.node_ids.get(n) {\n             Some(node_id) => node_id,\n-            None => panic!(\"no node_id found for node: {:?}\", n),\n+            None => bug!(\"no node_id found for node: {:?}\", n),\n         };\n         let name = || format!(\"node_{}\", node_id);\n         match dot::Id::new(name()) {\n             Ok(id) => id,\n             Err(_) => {\n-                panic!(\"failed to create graphviz node identified by {}\", name());\n+                bug!(\"failed to create graphviz node identified by {}\", name());\n             }\n         }\n     }"}, {"sha": "2f610bf2380fc67f6b34343eaa74ecd897c08cf2", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -309,7 +309,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         while undo_log.len() > snapshot.length + 1 {\n             match undo_log.pop().unwrap() {\n                 OpenSnapshot => {\n-                    panic!(\"Failure to observe stack discipline\");\n+                    bug!(\"Failure to observe stack discipline\");\n                 }\n                 CommitedSnapshot => {}\n                 AddVar(vid) => {\n@@ -413,7 +413,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.bound_count.set(sc + 1);\n \n         if sc >= self.bound_count.get() {\n-            self.tcx.sess.bug(\"rollover in RegionInference new_bound()\");\n+            bug!(\"rollover in RegionInference new_bound()\");\n         }\n \n         ReLateBound(debruijn, BrFresh(sc))\n@@ -497,10 +497,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (ReLateBound(..), _) |\n             (_, ReEarlyBound(..)) |\n             (_, ReLateBound(..)) => {\n-                self.tcx.sess.span_bug(origin.span(),\n-                                       &format!(\"cannot relate bound region: {:?} <= {:?}\",\n-                                                sub,\n-                                                sup));\n+                span_bug!(origin.span(),\n+                          \"cannot relate bound region: {:?} <= {:?}\",\n+                          sub,\n+                          sup);\n             }\n             (_, ReStatic) => {\n                 // all regions are subregions of static, so we can ignore this\n@@ -570,9 +570,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     pub fn resolve_var(&self, rid: RegionVid) -> ty::Region {\n         match *self.values.borrow() {\n             None => {\n-                self.tcx.sess.span_bug((*self.var_origins.borrow())[rid.index as usize].span(),\n-                                       \"attempt to resolve region variable before values have \\\n-                                        been computed!\")\n+                span_bug!((*self.var_origins.borrow())[rid.index as usize].span(),\n+                          \"attempt to resolve region variable before values have \\\n+                           been computed!\")\n             }\n             Some(ref values) => {\n                 let r = lookup(values, rid);\n@@ -733,7 +733,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (_, ReLateBound(..)) |\n             (ReEarlyBound(..), _) |\n             (_, ReEarlyBound(..)) => {\n-                self.tcx.sess.bug(&format!(\"cannot relate bound region: LUB({:?}, {:?})\", a, b));\n+                bug!(\"cannot relate bound region: LUB({:?}, {:?})\", a, b);\n             }\n \n             (ReStatic, _) | (_, ReStatic) => {\n@@ -745,11 +745,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n \n             (ReVar(v_id), _) | (_, ReVar(v_id)) => {\n-                self.tcx.sess.span_bug((*self.var_origins.borrow())[v_id.index as usize].span(),\n-                                       &format!(\"lub_concrete_regions invoked with non-concrete \\\n-                                                 regions: {:?}, {:?}\",\n-                                                a,\n-                                                b));\n+                span_bug!((*self.var_origins.borrow())[v_id.index as usize].span(),\n+                          \"lub_concrete_regions invoked with non-concrete \\\n+                           regions: {:?}, {:?}\",\n+                          a,\n+                          b);\n             }\n \n             (ReFree(ref fr), ReScope(s_id)) |\n@@ -1193,13 +1193,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n         }\n \n-        self.tcx.sess.span_bug((*self.var_origins.borrow())[node_idx.index as usize].span(),\n-                               &format!(\"collect_error_for_expanding_node() could not find \\\n-                                         error for var {:?}, lower_bounds={:?}, \\\n-                                         upper_bounds={:?}\",\n-                                        node_idx,\n-                                        lower_bounds,\n-                                        upper_bounds));\n+        span_bug!((*self.var_origins.borrow())[node_idx.index as usize].span(),\n+                  \"collect_error_for_expanding_node() could not find \\\n+                   error for var {:?}, lower_bounds={:?}, \\\n+                   upper_bounds={:?}\",\n+                  node_idx,\n+                  lower_bounds,\n+                  upper_bounds);\n     }\n \n     fn collect_concrete_regions(&self,"}, {"sha": "8651b52e3fece742c964f4920e7d67912b5d7f8c", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -127,9 +127,7 @@ impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                     self.tcx().types.err\n                 }\n                 ty::TyInfer(_) => {\n-                    self.infcx.tcx.sess.bug(\n-                        &format!(\"Unexpected type in full type resolver: {:?}\",\n-                                t));\n+                    bug!(\"Unexpected type in full type resolver: {:?}\", t);\n                 }\n                 _ => {\n                     t.super_fold_with(self)"}, {"sha": "3cc076f1f00be2343710241fd0c0ff7a5b0bcb9c", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -159,8 +159,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n         let (relations, default) = match old_value {\n             Bounded { relations, default } => (relations, default),\n-            Known(_) => panic!(\"Asked to instantiate variable that is \\\n-                               already instantiated\")\n+            Known(_) => bug!(\"Asked to instantiate variable that is \\\n+                              already instantiated\")\n         };\n \n         for &(dir, vid) in &relations {\n@@ -259,7 +259,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                         // quick check to see if this variable was\n                         // created since the snapshot started or not.\n                         let escaping_type = match self.values.get(vid.index as usize).value {\n-                            Bounded { .. } => unreachable!(),\n+                            Bounded { .. } => bug!(),\n                             Known(ty) => ty,\n                         };\n                         escaping_types.push(escaping_type);\n@@ -318,7 +318,7 @@ impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n \n fn relations<'a>(v: &'a mut TypeVariableData) -> &'a mut Vec<Relation> {\n     match v.value {\n-        Known(_) => panic!(\"var_sub_var: variable is known\"),\n+        Known(_) => bug!(\"var_sub_var: variable is known\"),\n         Bounded { ref mut relations, .. } => relations\n     }\n }"}, {"sha": "e78ff513ac47379e969b7b556f166cc2f5adafc0", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -183,7 +183,7 @@ impl LintStore {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n                     // Use early_error when handling -W help with no crate.\n                     (None, _) => early_error(config::ErrorOutputType::default(), &msg[..]),\n-                    (Some(sess), false) => sess.bug(&msg[..]),\n+                    (Some(_), false) => bug!(\"{}\", msg),\n \n                     // A duplicate name from a plugin is a user error.\n                     (Some(sess), true)  => sess.err(&msg[..]),\n@@ -221,7 +221,7 @@ impl LintStore {\n                 // We load builtin lints first, so a duplicate is a compiler bug.\n                 // Use early_error when handling -W help with no crate.\n                 (None, _) => early_error(config::ErrorOutputType::default(), &msg[..]),\n-                (Some(sess), false) => sess.bug(&msg[..]),\n+                (Some(_), false) => bug!(\"{}\", msg),\n \n                 // A duplicate name from a plugin is a user error.\n                 (Some(sess), true)  => sess.err(&msg[..]),\n@@ -232,7 +232,7 @@ impl LintStore {\n     pub fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n         let target = match self.by_name.get(new_name) {\n             Some(&Id(lint_id)) => lint_id.clone(),\n-            _ => panic!(\"invalid lint renaming of {} to {}\", old_name, new_name)\n+            _ => bug!(\"invalid lint renaming of {} to {}\", old_name, new_name)\n         };\n         self.by_name.insert(old_name.to_string(), Renamed(new_name.to_string(), target));\n     }\n@@ -430,7 +430,7 @@ pub fn raw_struct_lint<'a>(sess: &'a Session,\n             format!(\"{} [-{} {}]\", msg,\n                     match level {\n                         Warn => 'W', Deny => 'D', Forbid => 'F',\n-                        Allow => panic!()\n+                        Allow => bug!()\n                     }, name.replace(\"_\", \"-\"))\n         },\n         Node(src) => {\n@@ -447,7 +447,7 @@ pub fn raw_struct_lint<'a>(sess: &'a Session,\n         (Warn, None)     => sess.struct_warn(&msg[..]),\n         (Deny, Some(sp)) => sess.struct_span_err(sp, &msg[..]),\n         (Deny, None)     => sess.struct_err(&msg[..]),\n-        _ => sess.bug(\"impossible level in raw_emit_lint\"),\n+        _ => bug!(\"impossible level in raw_emit_lint\"),\n     };\n \n     // Check for future incompatibility lints and issue a stronger warning.\n@@ -1275,9 +1275,9 @@ pub fn check_crate(tcx: &TyCtxt, access_levels: &AccessLevels) {\n     // in the iteration code.\n     for (id, v) in tcx.sess.lints.borrow().iter() {\n         for &(lint, span, ref msg) in v {\n-            tcx.sess.span_bug(span,\n-                              &format!(\"unprocessed lint {} at {}: {}\",\n-                                       lint.as_str(), tcx.map.node_to_string(*id), *msg))\n+            span_bug!(span,\n+                      \"unprocessed lint {} at {}: {}\",\n+                      lint.as_str(), tcx.map.node_to_string(*id), *msg)\n         }\n     }\n \n@@ -1314,9 +1314,7 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     // in the iteration code.\n     for (_, v) in sess.lints.borrow().iter() {\n         for &(lint, span, ref msg) in v {\n-            sess.span_bug(span,\n-                          &format!(\"unprocessed lint {}: {}\",\n-                                   lint.as_str(), *msg))\n+            span_bug!(span, \"unprocessed lint {}: {}\", lint.as_str(), *msg)\n         }\n     }\n }"}, {"sha": "76dca1bb5b64941b61d989de99b18515c84c47dd", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -44,3 +44,18 @@ macro_rules! enum_from_u32 {\n         }\n     }\n }\n+\n+#[macro_export]\n+macro_rules! bug {\n+    () => ( bug!(\"impossible case reached\") );\n+    ($($message:tt)*) => ({\n+        $crate::session::bug_fmt(file!(), line!(), format_args!($($message)*))\n+    })\n+}\n+\n+#[macro_export]\n+macro_rules! span_bug {\n+    ($span:expr, $($message:tt)*) => ({\n+        $crate::session::span_bug_fmt(file!(), line!(), $span, format_args!($($message)*))\n+    })\n+}"}, {"sha": "b86d74545cb8ee700912cad20caaac32e710498d", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -67,8 +67,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &TyCtxt<'tcx>, ast_ty: &ast::Ty)\n     if let ast::TyPath(None, ref path) = ast_ty.node {\n         let def = match tcx.def_map.borrow().get(&ast_ty.id) {\n             None => {\n-                tcx.sess.span_bug(ast_ty.span,\n-                                  &format!(\"unbound path {:?}\", path))\n+                span_bug!(ast_ty.span, \"unbound path {:?}\", path)\n             }\n             Some(d) => d.full_def()\n         };"}, {"sha": "4efb40abdb0a3f4fbeff8669bf7a75bd44951721", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 71, "deletions": 69, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -309,7 +309,7 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     {\n         let mut say = |s: &str| {\n             match (sp, sess) {\n-                (_, None) => panic!(\"{}\", s),\n+                (_, None) => bug!(\"{}\", s),\n                 (Some(sp), Some(sess)) => sess.span_err(sp, s),\n                 (None, Some(sess)) => sess.err(s),\n             }\n@@ -336,121 +336,123 @@ pub struct DummyCrateStore;\n #[allow(unused_variables)]\n impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // item info\n-    fn stability(&self, def: DefId) -> Option<attr::Stability> { unimplemented!() }\n-    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { unimplemented!() }\n-    fn visibility(&self, def: DefId) -> hir::Visibility { unimplemented!() }\n+    fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n+    fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n+    fn visibility(&self, def: DefId) -> hir::Visibility { bug!(\"visibility\") }\n     fn closure_kind(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                    -> ty::ClosureKind  { unimplemented!() }\n+                    -> ty::ClosureKind  { bug!(\"closure_kind\") }\n     fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                  -> ty::ClosureTy<'tcx>  { unimplemented!() }\n-    fn item_variances(&self, def: DefId) -> ty::ItemVariances { unimplemented!() }\n-    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { unimplemented!() }\n+                  -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n+    fn item_variances(&self, def: DefId) -> ty::ItemVariances { bug!(\"item_variances\") }\n+    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n     fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                 -> ty::TypeScheme<'tcx> { unimplemented!() }\n-    fn relative_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> { unimplemented!() }\n+                 -> ty::TypeScheme<'tcx> { bug!(\"item_type\") }\n+    fn relative_item_path(&self, def: DefId)\n+                          -> Vec<hir_map::PathElem> { bug!(\"relative_item_path\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n-        unimplemented!()\n+        bug!(\"visible_parent_map\")\n     }\n-    fn extern_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> { unimplemented!() }\n-    fn item_name(&self, def: DefId) -> ast::Name { unimplemented!() }\n+    fn extern_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> { bug!(\"extern_item_path\") }\n+    fn item_name(&self, def: DefId) -> ast::Name { bug!(\"item_name\") }\n     fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                       -> ty::GenericPredicates<'tcx> { unimplemented!() }\n+                       -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n     fn item_super_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                             -> ty::GenericPredicates<'tcx> { unimplemented!() }\n-    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { unimplemented!() }\n-    fn item_symbol(&self, def: DefId) -> String { unimplemented!() }\n+                             -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n+    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n+    fn item_symbol(&self, def: DefId) -> String { bug!(\"item_symbol\") }\n     fn trait_def(&self, tcx: &TyCtxt<'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n-        { unimplemented!() }\n+        { bug!(\"trait_def\") }\n     fn adt_def(&self, tcx: &TyCtxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n-        { unimplemented!() }\n-    fn method_arg_names(&self, did: DefId) -> Vec<String> { unimplemented!() }\n+        { bug!(\"adt_def\") }\n+    fn method_arg_names(&self, did: DefId) -> Vec<String> { bug!(\"method_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n     fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n     fn provided_trait_methods(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                              -> Vec<Rc<ty::Method<'tcx>>> { unimplemented!() }\n+                              -> Vec<Rc<ty::Method<'tcx>>> { bug!(\"provided_trait_methods\") }\n     fn trait_item_def_ids(&self, def: DefId)\n-                          -> Vec<ty::ImplOrTraitItemId> { unimplemented!() }\n+                          -> Vec<ty::ImplOrTraitItemId> { bug!(\"trait_item_def_ids\") }\n \n     // impl info\n     fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n-        { unimplemented!() }\n+        { bug!(\"impl_items\") }\n     fn impl_trait_ref(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                      -> Option<ty::TraitRef<'tcx>> { unimplemented!() }\n-    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity> { unimplemented!() }\n+                      -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n+    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity> { bug!(\"impl_polarity\") }\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>\n-        { unimplemented!() }\n+        { bug!(\"custom_coerce_unsized_kind\") }\n     fn associated_consts(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                         -> Vec<Rc<ty::AssociatedConst<'tcx>>> { unimplemented!() }\n-    fn impl_parent(&self, def: DefId) -> Option<DefId> { unimplemented!() }\n+                         -> Vec<Rc<ty::AssociatedConst<'tcx>>> { bug!(\"associated_consts\") }\n+    fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n     fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                     -> Option<DefId> { unimplemented!() }\n+                     -> Option<DefId> { bug!(\"trait_of_item\") }\n     fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<ty::ImplOrTraitItem<'tcx>> { unimplemented!() }\n+                          -> Option<ty::ImplOrTraitItem<'tcx>> { bug!(\"impl_or_trait_item\") }\n \n     // flags\n-    fn is_const_fn(&self, did: DefId) -> bool { unimplemented!() }\n-    fn is_defaulted_trait(&self, did: DefId) -> bool { unimplemented!() }\n-    fn is_impl(&self, did: DefId) -> bool { unimplemented!() }\n-    fn is_default_impl(&self, impl_did: DefId) -> bool { unimplemented!() }\n-    fn is_extern_item(&self, tcx: &TyCtxt<'tcx>, did: DefId) -> bool { unimplemented!() }\n-    fn is_static_method(&self, did: DefId) -> bool { unimplemented!() }\n+    fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n+    fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n+    fn is_impl(&self, did: DefId) -> bool { bug!(\"is_impl\") }\n+    fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n+    fn is_extern_item(&self, tcx: &TyCtxt<'tcx>, did: DefId) -> bool { bug!(\"is_extern_item\") }\n+    fn is_static_method(&self, did: DefId) -> bool { bug!(\"is_static_method\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n-    fn is_typedef(&self, did: DefId) -> bool { unimplemented!() }\n+    fn is_typedef(&self, did: DefId) -> bool { bug!(\"is_typedef\") }\n \n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n                                     -> Vec<(ast::CrateNum, LinkagePreference)>\n-        { unimplemented!() }\n+        { bug!(\"dylib_dependency_formats\") }\n     fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>\n-        { unimplemented!() }\n+        { bug!(\"lang_items\") }\n     fn missing_lang_items(&self, cnum: ast::CrateNum) -> Vec<lang_items::LangItem>\n-        { unimplemented!() }\n-    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool { unimplemented!() }\n-    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool { unimplemented!() }\n-    fn is_allocator(&self, cnum: ast::CrateNum) -> bool { unimplemented!() }\n-    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate> { unimplemented!() }\n+        { bug!(\"missing_lang_items\") }\n+    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_staged_api\") }\n+    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_explicitly_linked\") }\n+    fn is_allocator(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_allocator\") }\n+    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n     fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n-        { unimplemented!() }\n-    fn crate_name(&self, cnum: ast::CrateNum) -> InternedString { unimplemented!() }\n+        { bug!(\"crate_attrs\") }\n+    fn crate_name(&self, cnum: ast::CrateNum) -> InternedString { bug!(\"crate_name\") }\n     fn original_crate_name(&self, cnum: ast::CrateNum) -> InternedString {\n-        unimplemented!()\n+        bug!(\"original_crate_name\")\n     }\n-    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh { unimplemented!() }\n-    fn crate_disambiguator(&self, cnum: ast::CrateNum) -> InternedString { unimplemented!() }\n+    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh { bug!(\"crate_hash\") }\n+    fn crate_disambiguator(&self, cnum: ast::CrateNum)\n+                           -> InternedString { bug!(\"crate_disambiguator\") }\n     fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n                                 -> FnvHashMap<DefId, Vec<ast::Attribute>>\n-        { unimplemented!() }\n+        { bug!(\"crate_struct_field_attrs\") }\n     fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>\n-        { unimplemented!() }\n+        { bug!(\"plugin_registrar_fn\") }\n     fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>\n-        { unimplemented!() }\n-    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId> { unimplemented!() }\n+        { bug!(\"native_libraries\") }\n+    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId> { bug!(\"reachable_ids\") }\n \n     // resolve\n-    fn def_key(&self, def: DefId) -> hir_map::DefKey { unimplemented!() }\n-    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath { unimplemented!() }\n-    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> { unimplemented!() }\n+    fn def_key(&self, def: DefId) -> hir_map::DefKey { bug!(\"def_key\") }\n+    fn relative_def_path(&self, def: DefId) -> hir_map::DefPath { bug!(\"relative_def_path\") }\n+    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> { bug!(\"variant_kind\") }\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n-        { unimplemented!() }\n+        { bug!(\"struct_ctor_def_id\") }\n     fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n-        { unimplemented!() }\n-    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { unimplemented!() }\n-    fn item_children(&self, did: DefId) -> Vec<ChildItem> { unimplemented!() }\n+        { bug!(\"tuple_struct_definition_if_ctor\") }\n+    fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n+    fn item_children(&self, did: DefId) -> Vec<ChildItem> { bug!(\"item_children\") }\n     fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>\n-        { unimplemented!() }\n+        { bug!(\"crate_top_level_items\") }\n \n     // misc. metadata\n     fn maybe_get_item_ast(&'tcx self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> FoundAst<'tcx> { unimplemented!() }\n+                          -> FoundAst<'tcx> { bug!(\"maybe_get_item_ast\") }\n     fn maybe_get_item_mir(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<Mir<'tcx>> { unimplemented!() }\n+                          -> Option<Mir<'tcx>> { bug!(\"maybe_get_item_mir\") }\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n-        unimplemented!()\n+        bug!(\"is_item_mir_available\")\n     }\n \n     // This is basically a 1-based range of ints, which is a little\n@@ -460,18 +462,18 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn used_link_args(&self) -> Vec<String> { vec![] }\n \n     // utility functions\n-    fn metadata_filename(&self) -> &str { unimplemented!() }\n-    fn metadata_section_name(&self, target: &Target) -> &str { unimplemented!() }\n+    fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n+    fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n     fn encode_type(&self,\n                    tcx: &TyCtxt<'tcx>,\n                    ty: Ty<'tcx>,\n                    def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n                    -> Vec<u8> {\n-        unimplemented!()\n+        bug!(\"encode_type\")\n     }\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n         { vec![] }\n-    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource { unimplemented!() }\n+    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum> { None }\n     fn encode_metadata(&self,\n                        tcx: &TyCtxt<'tcx>,\n@@ -481,7 +483,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                        reachable: &NodeSet,\n                        mir_map: &MirMap<'tcx>,\n                        krate: &hir::Crate) -> Vec<u8> { vec![] }\n-    fn metadata_encoding_version(&self) -> &[u8] { unimplemented!() }\n+    fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n "}, {"sha": "18bea745858a3aea21bd80c3e7ec1acc814cc123", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n             self.insert_def_id(def.struct_variant().field_named(name).did);\n         } else {\n-            self.tcx.sess.span_bug(lhs.span, \"named field access on non-struct\")\n+            span_bug!(lhs.span, \"named field access on non-struct\")\n         }\n     }\n \n@@ -141,7 +141,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         let pat_ty = self.tcx.node_id_to_type(lhs.id);\n         let variant = match pat_ty.sty {\n             ty::TyStruct(adt, _) | ty::TyEnum(adt, _) => adt.variant_of_def(def),\n-            _ => self.tcx.sess.span_bug(lhs.span, \"non-ADT in struct pattern\")\n+            _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n             if let PatKind::Wild = pat.node.pat.node {"}, {"sha": "e6ea000936cab8cb9fa572a63af5e54a83bc59ac", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -71,7 +71,7 @@ impl PathResolution {\n     /// Get the definition, if fully resolved, otherwise panic.\n     pub fn full_def(&self) -> Def {\n         if self.depth != 0 {\n-            panic!(\"path not fully resolved: {:?}\", self);\n+            bug!(\"path not fully resolved: {:?}\", self);\n         }\n         self.base_def\n     }\n@@ -116,7 +116,7 @@ impl Def {\n             Def::TyParam(..) | Def::Struct(..) | Def::Trait(..) |\n             Def::Method(..) | Def::Const(..) | Def::AssociatedConst(..) |\n             Def::PrimTy(..) | Def::Label(..) | Def::SelfTy(..) | Def::Err => {\n-                panic!(\"attempted .var_id() on invalid {:?}\", self)\n+                bug!(\"attempted .var_id() on invalid {:?}\", self)\n             }\n         }\n     }\n@@ -135,7 +135,7 @@ impl Def {\n             Def::PrimTy(..) |\n             Def::SelfTy(..) |\n             Def::Err => {\n-                panic!(\"attempted .def_id() on invalid def: {:?}\", self)\n+                bug!(\"attempted .def_id() on invalid def: {:?}\", self)\n             }\n         }\n     }"}, {"sha": "bfc96005bc8a41d260189c768fe14e014637690d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -224,7 +224,7 @@ impl OverloadedCallType {\n             }\n         }\n \n-        tcx.sess.bug(\"overloaded call didn't map to known function trait\")\n+        bug!(\"overloaded call didn't map to known function trait\")\n     }\n \n     fn from_method_id(tcx: &TyCtxt, method_id: DefId)\n@@ -564,9 +564,10 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                             OverloadedCallType::from_method_id(self.tcx(), method_id)\n                         }\n                         None => {\n-                            self.tcx().sess.span_bug(\n+                            span_bug!(\n                                 callee.span,\n-                                &format!(\"unexpected callee type {}\", callee_ty))\n+                                \"unexpected callee type {}\",\n+                                callee_ty)\n                         }\n                     };\n                 match overloaded_call_type {\n@@ -683,7 +684,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             // may not. This will generate an error earlier in typeck,\n             // so we can just ignore it.\n             if !self.tcx().sess.has_errors() {\n-                self.tcx().sess.span_bug(\n+                span_bug!(\n                     with_expr.span,\n                     \"with expression doesn't evaluate to a struct\");\n             }\n@@ -750,9 +751,9 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n                     let (m, r) = match self_ty.sty {\n                         ty::TyRef(r, ref m) => (m.mutbl, r),\n-                        _ => self.tcx().sess.span_bug(expr.span,\n-                                &format!(\"bad overloaded deref type {:?}\",\n-                                    method_ty))\n+                        _ => span_bug!(expr.span,\n+                                \"bad overloaded deref type {:?}\",\n+                                method_ty)\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,\n@@ -934,7 +935,6 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr,\n                pat);\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n-            let tcx = self.tcx();\n             let def_map = &self.tcx().def_map;\n             if pat_util::pat_is_binding(&def_map.borrow(), pat) {\n                 match pat.node {\n@@ -947,7 +947,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         }\n                     }\n                     _ => {\n-                        tcx.sess.span_bug(\n+                        span_bug!(\n                             pat.span,\n                             \"binding pattern not an identifier\");\n                     }\n@@ -972,8 +972,6 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(&def_map.borrow(), pat) {\n-                let tcx = typer.tcx;\n-\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n                        cmt_pat,\n                        pat,\n@@ -1007,7 +1005,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         delegate.consume_pat(pat, cmt_pat, mode);\n                     }\n                     _ => {\n-                        tcx.sess.span_bug(\n+                        span_bug!(\n                             pat.span,\n                             \"binding pattern not an identifier\");\n                     }\n@@ -1117,10 +1115,10 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                             // reported.\n \n                             if !tcx.sess.has_errors() {\n-                                let msg = format!(\"Pattern has unexpected def: {:?} and type {:?}\",\n-                                                  def,\n-                                                  cmt_pat.ty);\n-                                tcx.sess.span_bug(pat.span, &msg[..])\n+                                span_bug!(pat.span,\n+                                          \"Pattern has unexpected def: {:?} and type {:?}\",\n+                                          def,\n+                                          cmt_pat.ty);\n                             }\n                         }\n                     }"}, {"sha": "ae0540696c5728db21ac8b44fdff74f83e2fe7ea", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -49,7 +49,7 @@ impl FreeRegionMap {\n     }\n \n     pub fn relate_free_regions_from_predicates<'tcx>(&mut self,\n-                                                     tcx: &TyCtxt<'tcx>,\n+                                                     _tcx: &TyCtxt<'tcx>,\n                                                      predicates: &[ty::Predicate<'tcx>]) {\n         debug!(\"relate_free_regions_from_predicates(predicates={:?})\", predicates);\n         for predicate in predicates {\n@@ -72,10 +72,9 @@ impl FreeRegionMap {\n                         }\n                         _ => {\n                             // All named regions are instantiated with free regions.\n-                            tcx.sess.bug(\n-                                &format!(\"record_region_bounds: non free region: {:?} / {:?}\",\n-                                         r_a,\n-                                         r_b));\n+                            bug!(\"record_region_bounds: non free region: {:?} / {:?}\",\n+                                 r_a,\n+                                 r_b);\n                         }\n                     }\n                 }"}, {"sha": "fd74ccac975967e52fc3c7fd24f42110d7da5385", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         let param_env = match self.param_envs.last() {\n             Some(p) => p,\n             None => {\n-                self.tcx.sess.span_bug(\n+                span_bug!(\n                     span,\n                     \"transmute encountered outside of any fn\");\n             }\n@@ -245,9 +245,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                             }\n                         }\n                         _ => {\n-                            self.tcx\n-                                .sess\n-                                .span_bug(expr.span, \"transmute wasn't a bare fn?!\");\n+                            span_bug!(expr.span, \"transmute wasn't a bare fn?!\");\n                         }\n                     }\n                 }"}, {"sha": "cc37ee7dbda051571308108b50e9a7025f5a594d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -325,13 +325,10 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n \n     fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n         match self.variable_map.get(&node_id) {\n-          Some(&var) => var,\n-          None => {\n-            self.tcx\n-                .sess\n-                .span_bug(span, &format!(\"no variable registered for id {}\",\n-                                        node_id));\n-          }\n+            Some(&var) => var,\n+            None => {\n+                span_bug!(span, \"no variable registered for id {}\", node_id);\n+            }\n         }\n     }\n \n@@ -578,10 +575,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             // above and the propagation code below; the two sets of\n             // code have to agree about which AST nodes are worth\n             // creating liveness nodes for.\n-            self.ir.tcx.sess.span_bug(\n+            span_bug!(\n                 span,\n-                &format!(\"no live node registered for node {}\",\n-                        node_id));\n+                \"no live node registered for node {}\",\n+                node_id);\n           }\n         }\n     }\n@@ -703,15 +700,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 // to find with one\n                 match self.ir.tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n                     Some(Def::Label(loop_id)) => loop_id,\n-                    _ => self.ir.tcx.sess.span_bug(sp, \"label on break/loop \\\n-                                                        doesn't refer to a loop\")\n+                    _ => span_bug!(sp, \"label on break/loop \\\n+                                        doesn't refer to a loop\")\n                 }\n             }\n             None => {\n                 // Vanilla 'break' or 'loop', so use the enclosing\n                 // loop scope\n                 if self.loop_scope.is_empty() {\n-                    self.ir.tcx.sess.span_bug(sp, \"break outside loop\");\n+                    span_bug!(sp, \"break outside loop\");\n                 } else {\n                     *self.loop_scope.last().unwrap()\n                 }\n@@ -967,7 +964,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  let caps = match this.ir.capture_info_map.get(&expr.id) {\n                     Some(caps) => caps.clone(),\n                     None => {\n-                        this.ir.tcx.sess.span_bug(expr.span, \"no registered caps\");\n+                        span_bug!(expr.span, \"no registered caps\");\n                      }\n                  };\n                  caps.iter().rev().fold(succ, |succ, cap| {\n@@ -1061,8 +1058,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n               match self.break_ln.get(&sc) {\n                   Some(&b) => b,\n-                  None => self.ir.tcx.sess.span_bug(expr.span,\n-                                                    \"break to unknown label\")\n+                  None => span_bug!(expr.span, \"break to unknown label\")\n               }\n           }\n \n@@ -1075,8 +1071,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n               match self.cont_ln.get(&sc) {\n                   Some(&b) => b,\n-                  None => self.ir.tcx.sess.span_bug(expr.span,\n-                                                    \"loop to unknown label\")\n+                  None => span_bug!(expr.span, \"loop to unknown label\")\n               }\n           }\n "}, {"sha": "ef031ad13f16c27d78b7bec1a7e4790ac37e3b5f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -312,9 +312,9 @@ impl MutabilityCategory {\n                         McImmutable\n                     }\n                 }\n-                _ => tcx.sess.span_bug(p.span, \"expected identifier pattern\")\n+                _ => span_bug!(p.span, \"expected identifier pattern\")\n             },\n-            _ => tcx.sess.span_bug(tcx.map.span(id), \"expected identifier pattern\")\n+            _ => span_bug!(tcx.map.span(id), \"expected identifier pattern\")\n         };\n         debug!(\"MutabilityCategory::{}(tcx, id={:?}) => {:?}\",\n                \"from_local\", id, ret);\n@@ -559,8 +559,8 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           Def::TyParam(..) |\n           Def::Label(_) | Def::SelfTy(..) |\n           Def::AssociatedTy(..) => {\n-              self.tcx().sess.span_bug(span, &format!(\"Unexpected definition in \\\n-                                                       memory categorization: {:?}\", def));\n+              span_bug!(span, \"Unexpected definition in \\\n+                               memory categorization: {:?}\", def);\n           }\n \n           Def::Static(_, mutbl) => {\n@@ -583,18 +583,19 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                               self.cat_upvar(id, span, var_id, fn_node_id, kind)\n                           }\n                           None => {\n-                              self.tcx().sess.span_bug(\n+                              span_bug!(\n                                   span,\n-                                  &format!(\"No closure kind for {:?}\", closure_id));\n+                                  \"No closure kind for {:?}\",\n+                                  closure_id);\n                           }\n                       }\n                   }\n                   _ => {\n-                      self.tcx().sess.span_bug(\n+                      span_bug!(\n                           span,\n-                          &format!(\"Upvar of non-closure {} - {:?}\",\n-                                  fn_node_id,\n-                                  ty));\n+                          \"Upvar of non-closure {} - {:?}\",\n+                          fn_node_id,\n+                          ty);\n                   }\n               }\n           }\n@@ -610,7 +611,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }))\n           }\n \n-          Def::Err => panic!(\"Def::Err in memory categorization\")\n+          Def::Err => bug!(\"Def::Err in memory categorization\")\n         }\n     }\n \n@@ -723,12 +724,12 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         let fn_body_id = {\n             let fn_expr = match self.tcx().map.find(upvar_id.closure_expr_id) {\n                 Some(ast_map::NodeExpr(e)) => e,\n-                _ => unreachable!()\n+                _ => bug!()\n             };\n \n             match fn_expr.node {\n                 hir::ExprClosure(_, _, ref body) => body.id,\n-                _ => unreachable!()\n+                _ => bug!()\n             }\n         };\n \n@@ -926,7 +927,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                 let ptr = if implicit {\n                     match ptr {\n                         BorrowedPtr(bk, r) => Implicit(bk, r),\n-                        _ => self.tcx().sess.span_bug(node.span(),\n+                        _ => span_bug!(node.span(),\n                             \"Implicit deref of non-borrowed pointer\")\n                     }\n                 } else {\n@@ -1044,7 +1045,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                     mutbl:m,\n                     ty: match base_cmt.ty.builtin_deref(false, ty::NoPreference) {\n                         Some(mt) => mt.ty,\n-                        None => self.tcx().sess.bug(\"Found non-derefable type\")\n+                        None => bug!(\"Found non-derefable type\")\n                     },\n                     note: NoteNone\n                 })\n@@ -1092,8 +1093,8 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                 },\n \n                 _ => {\n-                    tcx.sess.span_bug(pat.span,\n-                                      \"type of slice pattern is not a slice\");\n+                    span_bug!(pat.span,\n+                              \"type of slice pattern is not a slice\");\n                 }\n             }\n         }\n@@ -1261,9 +1262,10 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                     }\n                 }\n                 _ => {\n-                    self.tcx().sess.span_bug(\n+                    span_bug!(\n                         pat.span,\n-                        &format!(\"enum pattern didn't resolve to enum or struct {:?}\", opt_def));\n+                        \"enum pattern didn't resolve to enum or struct {:?}\",\n+                        opt_def);\n                 }\n             }\n           }\n@@ -1451,10 +1453,10 @@ impl<'tcx> cmt_<'tcx> {\n                         match inner.cat {\n                             Categorization::Deref(ref inner, _, _) => inner.clone(),\n                             Categorization::Upvar(..) => inner.clone(),\n-                            _ => unreachable!()\n+                            _ => bug!()\n                         }\n                     }\n-                    _ => unreachable!()\n+                    _ => bug!()\n                 })\n             }\n             NoteNone => None\n@@ -1483,7 +1485,7 @@ impl<'tcx> cmt_<'tcx> {\n                     Some(&Categorization::Upvar(ref var)) => {\n                         var.to_string()\n                     }\n-                    Some(_) => unreachable!(),\n+                    Some(_) => bug!(),\n                     None => {\n                         match pk {\n                             Implicit(..) => {"}, {"sha": "149e895717c00e72525bb81bc9c6bbf1cca46570", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -67,10 +67,10 @@ fn method_might_be_inlined(tcx: &TyCtxt, sig: &hir::MethodSig,\n             Some(ast_map::NodeItem(item)) =>\n                 item_might_be_inlined(&item),\n             Some(..) | None =>\n-                tcx.sess.span_bug(impl_item.span, \"impl did is not an item\")\n+                span_bug!(impl_item.span, \"impl did is not an item\")\n         }\n     } else {\n-        tcx.sess.span_bug(impl_item.span, \"found a foreign impl as a parent of a local method\")\n+        span_bug!(impl_item.span, \"found a foreign impl as a parent of a local method\")\n     }\n }\n \n@@ -94,8 +94,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                 let def = match self.tcx.def_map.borrow().get(&expr.id) {\n                     Some(d) => d.full_def(),\n                     None => {\n-                        self.tcx.sess.span_bug(expr.span,\n-                                               \"def ID not in def map?!\")\n+                        span_bug!(expr.span, \"def ID not in def map?!\")\n                     }\n                 };\n \n@@ -312,12 +311,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             ast_map::NodeVariant(_) |\n             ast_map::NodeStructCtor(_) => {}\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .bug(&format!(\"found unexpected thingy in worklist: {}\",\n-                                 self.tcx\n-                                     .map\n-                                     .node_to_string(search_item)))\n+                bug!(\"found unexpected thingy in worklist: {}\",\n+                     self.tcx.map.node_to_string(search_item))\n             }\n         }\n     }"}, {"sha": "2cde6ce93208f27c0148c19ec58b112dc0c16ad2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -343,7 +343,7 @@ impl RegionMaps {\n     pub fn lookup_code_extent(&self, e: CodeExtentData) -> CodeExtent {\n         match self.code_extent_interner.borrow().get(&e) {\n             Some(&d) => d,\n-            None => panic!(\"unknown code extent {:?}\", e)\n+            None => bug!(\"unknown code extent {:?}\", e)\n         }\n     }\n     pub fn node_extent(&self, n: ast::NodeId) -> CodeExtent {\n@@ -385,8 +385,8 @@ impl RegionMaps {\n             }\n             Entry::Vacant(v) => {\n                 if self.code_extents.borrow().len() > 0xffffffffusize {\n-                    unreachable!() // should pass a sess,\n-                                   // but this isn't the only place\n+                    bug!() // should pass a sess,\n+                           // but this isn't the only place\n                 }\n                 let idx = CodeExtent(self.code_extents.borrow().len() as u32);\n                 info!(\"CodeExtent({}) = {:?} [parent={}]\", idx.0, e, parent.0);\n@@ -470,7 +470,7 @@ impl RegionMaps {\n     pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent {\n         match self.var_map.borrow().get(&var_id) {\n             Some(&r) => r,\n-            None => { panic!(\"no enclosing scope for id {:?}\", var_id); }\n+            None => { bug!(\"no enclosing scope for id {:?}\", var_id); }\n         }\n     }\n \n@@ -601,12 +601,12 @@ impl RegionMaps {\n                         scope_a\n                     } else {\n                         // neither fn encloses the other\n-                        unreachable!()\n+                        bug!()\n                     }\n                 }\n                 _ => {\n                     // root ids are always Misc right now\n-                    unreachable!()\n+                    bug!()\n                 }\n             };\n         }"}, {"sha": "d3757629d30de5300391076f3f8375823afa71dd", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -747,9 +747,9 @@ impl<'a> LifetimeContext<'a> {\n                        lifetime_ref: &hir::Lifetime,\n                        def: DefRegion) {\n         if lifetime_ref.id == ast::DUMMY_NODE_ID {\n-            self.sess.span_bug(lifetime_ref.span,\n-                               \"lifetime reference not renumbered, \\\n-                               probably a bug in syntax::fold\");\n+            span_bug!(lifetime_ref.span,\n+                      \"lifetime reference not renumbered, \\\n+                       probably a bug in syntax::fold\");\n         }\n \n         debug!(\"lifetime_ref={:?} id={:?} resolved to {:?}\",\n@@ -822,7 +822,7 @@ fn early_bound_lifetime_names(generics: &hir::Generics) -> Vec<ast::Name> {\n                         collector.visit_lifetime(bound);\n                     }\n                 }\n-                &hir::WherePredicate::EqPredicate(_) => unimplemented!()\n+                &hir::WherePredicate::EqPredicate(_) => bug!(\"unimplemented\")\n             }\n         }\n     }"}, {"sha": "e589743222b72c7c048e42a048d9a1575e13dc6f", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -516,18 +516,18 @@ pub fn check_expr(tcx: &TyCtxt, e: &hir::Expr,\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n                 ty::TyStruct(def, _) => def.struct_variant().field_named(field.node).did,\n-                _ => tcx.sess.span_bug(e.span,\n-                                       \"stability::check_expr: named field access on non-struct\")\n+                _ => span_bug!(e.span,\n+                               \"stability::check_expr: named field access on non-struct\")\n             }\n         }\n         hir::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n                 ty::TyStruct(def, _) => def.struct_variant().fields[field.node].did,\n                 ty::TyTuple(..) => return,\n-                _ => tcx.sess.span_bug(e.span,\n-                                       \"stability::check_expr: unnamed field access on \\\n-                                        something other than a tuple or struct\")\n+                _ => span_bug!(e.span,\n+                               \"stability::check_expr: unnamed field access on \\\n+                                something other than a tuple or struct\")\n             }\n         }\n         hir::ExprStruct(_, ref expr_fields, _) => {\n@@ -551,10 +551,10 @@ pub fn check_expr(tcx: &TyCtxt, e: &hir::Expr,\n                 // a bug to have construct one.\n                 ty::TyEnum(..) => return,\n                 _ => {\n-                    tcx.sess.span_bug(e.span,\n-                                      &format!(\"stability::check_expr: struct construction \\\n-                                                of non-struct, type {:?}\",\n-                                               type_));\n+                    span_bug!(e.span,\n+                              \"stability::check_expr: struct construction \\\n+                               of non-struct, type {:?}\",\n+                              type_);\n                 }\n             }\n         }"}, {"sha": "a33ee6bd204eb85165d1dcdd428cfcbdb780aa02", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -1016,7 +1016,7 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n         Struct(node_id) | Tuple(node_id) | Array(node_id, _) | Repeat(node_id, _) =>\n             write!(fmt, \"{}\", node_to_string(node_id)),\n         Char(c) => write!(fmt, \"{:?}\", c),\n-        Dummy => unreachable!(),\n+        Dummy => bug!(),\n     }\n }\n "}, {"sha": "ecac5d2f73f6357f00330bf6f23abde6846ceabb", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -70,7 +70,7 @@ impl<'tcx> LvalueTy<'tcx> {\n                                              variant_index: index }\n                     }\n                     _ => {\n-                        tcx.sess.bug(&format!(\"cannot downcast non-enum type: `{:?}`\", self))\n+                        bug!(\"cannot downcast non-enum type: `{:?}`\", self)\n                     }\n                 },\n             ProjectionElem::Field(_, fty) => LvalueTy::Ty { ty: fty }"}, {"sha": "4d4ba50bd4a79fe583843ddf747fb4e11db8244a", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -362,7 +362,7 @@ macro_rules! options {\n                                                              value, $outputname,\n                                                              key, type_desc))\n                         }\n-                        (None, None) => unreachable!()\n+                        (None, None) => bug!()\n                     }\n                 }\n                 found = true;"}, {"sha": "e54acf3fdc3078f9f004686d0faa4d08b0676863", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -155,14 +155,14 @@ pub fn get_or_default_sysroot() -> PathBuf {\n                 // gcc chokes on verbatim paths which fs::canonicalize generates\n                 // so we try to avoid those kinds of paths.\n                 Ok(canon) => Some(rustcfs::fix_windows_verbatim_for_gcc(&canon)),\n-                Err(e) => panic!(\"failed to get realpath: {}\", e),\n+                Err(e) => bug!(\"failed to get realpath: {}\", e),\n             }\n         })\n     }\n \n     match canonicalize(env::current_exe().ok()) {\n         Some(mut p) => { p.pop(); p.pop(); p }\n-        None => panic!(\"can't determine value for sysroot\")\n+        None => bug!(\"can't determine value for sysroot\")\n     }\n }\n "}, {"sha": "d3005ff2ded251e4c68ea560d36febb8f16f953a", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -12,6 +12,7 @@ use lint;\n use middle::cstore::CrateStore;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n+use ty::tls;\n use util::nodemap::{NodeMap, FnvHashMap};\n use mir::transform as mir_pass;\n \n@@ -35,6 +36,7 @@ use std::cell::{Cell, RefCell};\n use std::collections::{HashMap, HashSet};\n use std::env;\n use std::rc::Rc;\n+use std::fmt;\n \n pub mod config;\n pub mod filesearch;\n@@ -216,22 +218,10 @@ impl Session {\n             None => self.warn(msg),\n         }\n     }\n-    pub fn opt_span_bug<S: Into<MultiSpan>>(&self, opt_sp: Option<S>, msg: &str) -> ! {\n-        match opt_sp {\n-            Some(sp) => self.span_bug(sp, msg),\n-            None => self.bug(msg),\n-        }\n-    }\n     /// Delay a span_bug() call until abort_if_errors()\n     pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.diagnostic().delay_span_bug(sp, msg)\n     }\n-    pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.diagnostic().span_bug(sp, msg)\n-    }\n-    pub fn bug(&self, msg: &str) -> ! {\n-        self.diagnostic().bug(msg)\n-    }\n     pub fn note_without_error(&self, msg: &str) {\n         self.diagnostic().note_without_error(msg)\n     }\n@@ -268,7 +258,7 @@ impl Session {\n \n         match id.checked_add(count) {\n             Some(next) => self.next_node_id.set(next),\n-            None => self.bug(\"Input too large, ran out of node ids!\")\n+            None => bug!(\"Input too large, ran out of node ids!\")\n         }\n \n         id\n@@ -279,11 +269,6 @@ impl Session {\n     pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {\n         self.parse_sess.codemap()\n     }\n-    // This exists to help with refactoring to eliminate impossible\n-    // cases later on\n-    pub fn impossible_case<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.span_bug(sp, &format!(\"impossible case reached: {}\", msg));\n-    }\n     pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }\n     pub fn time_passes(&self) -> bool { self.opts.debugging_opts.time_passes }\n     pub fn count_llvm_insns(&self) -> bool {\n@@ -541,3 +526,35 @@ pub fn compile_result_from_err_count(err_count: usize) -> CompileResult {\n         Err(err_count)\n     }\n }\n+\n+#[cold]\n+#[inline(never)]\n+pub fn bug_fmt(file: &'static str, line: u32, args: fmt::Arguments) -> ! {\n+    // this wrapper mostly exists so I don't have to write a fully\n+    // qualified path of None::<Span> inside the bug!() macro defintion\n+    opt_span_bug_fmt(file, line, None::<Span>, args);\n+}\n+\n+#[cold]\n+#[inline(never)]\n+pub fn span_bug_fmt<S: Into<MultiSpan>>(file: &'static str,\n+                                        line: u32,\n+                                        span: S,\n+                                        args: fmt::Arguments) -> ! {\n+    opt_span_bug_fmt(file, line, Some(span), args);\n+}\n+\n+fn opt_span_bug_fmt<S: Into<MultiSpan>>(file: &'static str,\n+                                          line: u32,\n+                                          span: Option<S>,\n+                                          args: fmt::Arguments) -> ! {\n+    tls::with_opt(move |tcx| {\n+        let msg = format!(\"{}:{}: {}\", file, line, args);\n+        match (tcx, span) {\n+            (Some(tcx), Some(span)) => tcx.sess.diagnostic().span_bug(span, &msg),\n+            (Some(tcx), None) => tcx.sess.diagnostic().bug(&msg),\n+            (None, _) => panic!(msg)\n+        }\n+    });\n+    unreachable!();\n+}"}, {"sha": "a0ac514852674e86678e103482e4e848362d6400", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -291,9 +291,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n \n         ty::TyClosure(..) => {\n-            tcx.sess.bug(\n-                &format!(\"ty_is_local invoked on unexpected type: {:?}\",\n-                        ty))\n+            bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n         }\n     }\n }"}, {"sha": "f15b9ee44ce5293480e29c80d72196168da1ffe9", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -201,7 +201,7 @@ pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n \n     err.emit();\n     infcx.tcx.sess.abort_if_errors();\n-    unreachable!();\n+    bug!();\n }\n \n /// Reports that a cycle was detected which led to overflow and halts\n@@ -268,9 +268,9 @@ pub fn try_report_overflow_error_type_of_infinite_size<'a, 'tcx>(\n                      }\n                  }\n                  _ => {\n-                     infcx.tcx.sess.span_bug(obligation.cause.span,\n-                                             &format!(\"Sized cycle involving non-trait-ref: {:?}\",\n-                                                      obligation.predicate));\n+                     span_bug!(obligation.cause.span,\n+                               \"Sized cycle involving non-trait-ref: {:?}\",\n+                               obligation.predicate);\n                  }\n              })\n              .collect();\n@@ -323,7 +323,7 @@ pub fn try_report_overflow_error_type_of_infinite_size<'a, 'tcx>(\n     }\n     err.emit();\n     infcx.tcx.sess.abort_if_errors();\n-    unreachable!();\n+    bug!();\n }\n \n pub fn recursive_type_with_infinite_size_error<'tcx>(tcx: &TyCtxt<'tcx>,\n@@ -472,9 +472,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         // ambiguity; otherwise, they always\n                         // degenerate into other obligations\n                         // (which may fail).\n-                        infcx.tcx.sess.span_bug(\n+                        span_bug!(\n                             obligation.cause.span,\n-                            &format!(\"WF predicate not satisfied for {:?}\", ty));\n+                            \"WF predicate not satisfied for {:?}\",\n+                            ty);\n                     }\n                 }\n             }"}, {"sha": "f7b75c2259eb157b8e76ade7bdcdee340ca220ac", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -719,8 +719,8 @@ fn project_type<'cx,'tcx>(\n                     // The essential problem here is that the projection fails,\n                     // leaving two unnormalized types, which appear not to unify\n                     // -- so the overlap check succeeds, when it should fail.\n-                    selcx.tcx().sess.bug(\"Tried to project an inherited associated type during \\\n-                                          coherence checking, which is currently not supported.\");\n+                    bug!(\"Tried to project an inherited associated type during \\\n+                          coherence checking, which is currently not supported.\");\n                 }\n             }\n         }\n@@ -858,10 +858,10 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n     let data = match object_ty.sty {\n         ty::TyTrait(ref data) => data,\n         _ => {\n-            selcx.tcx().sess.span_bug(\n+            span_bug!(\n                 obligation.cause.span,\n-                &format!(\"assemble_candidates_from_object_type called with non-object: {:?}\",\n-                         object_ty));\n+                \"assemble_candidates_from_object_type called with non-object: {:?}\",\n+                object_ty);\n         }\n     };\n     let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n@@ -951,10 +951,10 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n         super::VtableDefaultImpl(..) |\n         super::VtableBuiltin(..) => {\n             // These traits have no associated types.\n-            selcx.tcx().sess.span_bug(\n+            span_bug!(\n                 obligation.cause.span,\n-                &format!(\"Cannot project an associated type from `{:?}`\",\n-                         vtable));\n+                \"Cannot project an associated type from `{:?}`\",\n+                vtable);\n         }\n     }\n \n@@ -1084,12 +1084,12 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n                               projection.projection_ty.trait_ref.clone()) {\n         Ok(()) => { }\n         Err(e) => {\n-            selcx.tcx().sess.span_bug(\n+            span_bug!(\n                 obligation.cause.span,\n-                &format!(\"Failed to unify `{:?}` and `{:?}` in projection: {}\",\n-                         obligation,\n-                         projection,\n-                         e));\n+                \"Failed to unify `{:?}` and `{:?}` in projection: {}\",\n+                obligation,\n+                projection,\n+                e);\n         }\n     }\n \n@@ -1124,8 +1124,9 @@ fn confirm_impl_candidate<'cx,'tcx>(\n             (ty.subst(tcx, substs), nested)\n         }\n         None => {\n-            tcx.sess.span_bug(obligation.cause.span,\n-                              &format!(\"No associated type for {:?}\", trait_ref));\n+            span_bug!(obligation.cause.span,\n+                      \"No associated type for {:?}\",\n+                      trait_ref);\n         }\n     }\n }"}, {"sha": "7635ff1eb4cb750deec24110ea48718ec1cb366d", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -1088,7 +1088,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let trait_def_id = match obligation.predicate.0.trait_ref.self_ty().sty {\n             ty::TyProjection(ref data) => data.trait_ref.def_id,\n             ty::TyInfer(ty::TyVar(_)) => {\n-                self.tcx().sess.span_bug(obligation.cause.span,\n+                span_bug!(obligation.cause.span,\n                     \"Self=_ should have been handled by assemble_candidates\");\n             }\n             _ => { return; }\n@@ -1125,11 +1125,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let projection_trait_ref = match skol_trait_predicate.trait_ref.self_ty().sty {\n             ty::TyProjection(ref data) => &data.trait_ref,\n             _ => {\n-                self.tcx().sess.span_bug(\n+                span_bug!(\n                     obligation.cause.span,\n-                    &format!(\"match_projection_obligation_against_bounds_from_trait() called \\\n-                              but self-ty not a projection: {:?}\",\n-                             skol_trait_predicate.trait_ref.self_ty()));\n+                    \"match_projection_obligation_against_bounds_from_trait() called \\\n+                     but self-ty not a projection: {:?}\",\n+                    skol_trait_predicate.trait_ref.self_ty());\n             }\n         };\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n@@ -1601,7 +1601,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ObjectCandidate |\n             ParamCandidate(_) | ProjectionCandidate => match victim.candidate {\n                 DefaultImplCandidate(..) => {\n-                    self.tcx().sess.bug(\n+                    bug!(\n                         \"default implementations shouldn't be recorded \\\n                          when there are other valid candidates\");\n                 }\n@@ -1703,7 +1703,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundSized => ok_if(Vec::new()),\n \n                     ty::BoundSync | ty::BoundSend => {\n-                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n+                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n                 }\n             }\n@@ -1713,7 +1713,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundCopy | ty::BoundSized => ok_if(Vec::new()),\n \n                     ty::BoundSync | ty::BoundSend => {\n-                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n+                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n                 }\n             }\n@@ -1741,7 +1741,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         }\n                     }\n                     ty::BoundSync | ty::BoundSend => {\n-                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n+                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n                 }\n             }\n@@ -1762,7 +1762,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundSized => ok_if(Vec::new()),\n \n                     ty::BoundSync | ty::BoundSend => {\n-                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n+                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n                 }\n             }\n@@ -1773,15 +1773,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundCopy => ok_if(vec![element_ty]),\n                     ty::BoundSized => ok_if(Vec::new()),\n                     ty::BoundSync | ty::BoundSend => {\n-                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n+                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n                 }\n             }\n \n             ty::TyStr | ty::TySlice(_) => {\n                 match bound {\n                     ty::BoundSync | ty::BoundSend => {\n-                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n+                        bug!(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n \n                     ty::BoundCopy | ty::BoundSized => Err(Unimplemented),\n@@ -1847,10 +1847,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::TyInfer(ty::FreshTy(_))\n             | ty::TyInfer(ty::FreshIntTy(_))\n             | ty::TyInfer(ty::FreshFloatTy(_)) => {\n-                self.tcx().sess.bug(\n-                    &format!(\n-                        \"asked to assemble builtin bounds of unexpected type: {:?}\",\n-                        self_ty));\n+                bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n+                     self_ty);\n             }\n         };\n \n@@ -1872,7 +1870,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::BoundSized => ok_if(types),\n \n                 // Shouldn't be coming through here.\n-                ty::BoundSend | ty::BoundSync => unreachable!(),\n+                ty::BoundSend | ty::BoundSync => bug!(),\n             }\n         }\n     }\n@@ -1911,10 +1909,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::TyInfer(ty::FreshTy(_)) |\n             ty::TyInfer(ty::FreshIntTy(_)) |\n             ty::TyInfer(ty::FreshFloatTy(_)) => {\n-                self.tcx().sess.bug(\n-                    &format!(\n-                        \"asked to assemble constituent types of unexpected type: {:?}\",\n-                        t));\n+                bug!(\"asked to assemble constituent types of unexpected type: {:?}\",\n+                     t);\n             }\n \n             ty::TyBox(referent_ty) => {  // Box<T>\n@@ -2135,10 +2131,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.match_where_clause_trait_ref(obligation, param.clone()) {\n             Ok(obligations) => obligations,\n             Err(()) => {\n-                self.tcx().sess.bug(\n-                    &format!(\"Where clause `{:?}` was applicable to `{:?}` but now is not\",\n-                             param,\n-                             obligation));\n+                bug!(\"Where clause `{:?}` was applicable to `{:?}` but now is not\",\n+                     param,\n+                     obligation);\n             }\n         }\n     }\n@@ -2155,10 +2150,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.builtin_bound(bound, obligation)? {\n             If(nested) => Ok(self.vtable_builtin_data(obligation, bound, nested)),\n             AmbiguousBuiltin | ParameterBuiltin => {\n-                self.tcx().sess.span_bug(\n+                span_bug!(\n                     obligation.cause.span,\n-                    &format!(\"builtin bound for {:?} was ambig\",\n-                            obligation));\n+                    \"builtin bound for {:?} was ambig\",\n+                    obligation);\n             }\n         }\n     }\n@@ -2175,7 +2170,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let trait_def = match self.tcx().lang_items.from_builtin_kind(bound) {\n             Ok(def_id) => def_id,\n             Err(_) => {\n-                self.tcx().sess.bug(\"builtin trait definition not found\");\n+                bug!(\"builtin trait definition not found\");\n             }\n         };\n \n@@ -2238,10 +2233,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.vtable_default_impl(obligation, trait_def_id, all_types)\n             }\n             _ => {\n-                self.tcx().sess.bug(\n-                    &format!(\n-                        \"asked to confirm default object implementation for non-object type: {:?}\",\n-                        self_ty));\n+                bug!(\"asked to confirm default object implementation for non-object type: {:?}\",\n+                     self_ty);\n             }\n         }\n     }\n@@ -2360,8 +2353,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n             }\n             _ => {\n-                self.tcx().sess.span_bug(obligation.cause.span,\n-                                         \"object candidate with non-object\");\n+                span_bug!(obligation.cause.span,\n+                          \"object candidate with non-object\");\n             }\n         };\n \n@@ -2667,7 +2660,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     vec![inner_target]));\n             }\n \n-            _ => unreachable!()\n+            _ => bug!()\n         };\n \n         Ok(VtableBuiltinData { nested: nested })\n@@ -2692,10 +2685,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.match_impl(impl_def_id, obligation, snapshot) {\n             Ok((substs, skol_map)) => (substs, skol_map),\n             Err(()) => {\n-                self.tcx().sess.bug(\n-                    &format!(\"Impl {:?} was matchable against {:?} but now is not\",\n-                            impl_def_id,\n-                            obligation));\n+                bug!(\"Impl {:?} was matchable against {:?} but now is not\",\n+                     impl_def_id,\n+                     obligation);\n             }\n         }\n     }"}, {"sha": "88f4129d8860caeeea4a3600be4fcc747e599f4c", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -93,10 +93,8 @@ pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             }\n \n             fulfill_implication(infcx, source_trait_ref, target_impl).unwrap_or_else(|_| {\n-                infcx.tcx\n-                     .sess\n-                     .bug(\"When translating substitutions for specialization, the expected \\\n-                           specializaiton failed to hold\")\n+                bug!(\"When translating substitutions for specialization, the expected \\\n+                      specializaiton failed to hold\")\n             })\n         }\n         specialization_graph::Node::Trait(..) => source_trait_ref.substs.clone(),"}, {"sha": "d3146697ee6271cd97c3860f071a5581138bb472", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -145,8 +145,8 @@ impl Graph {\n     /// Insert cached metadata mapping from a child impl back to its parent.\n     pub fn record_impl_from_cstore(&mut self, parent: DefId, child: DefId) {\n         if self.parent.insert(child, parent).is_some() {\n-            panic!(\"When recording an impl from the crate store, information about its parent \\\n-                    was already present.\");\n+            bug!(\"When recording an impl from the crate store, information about its parent \\\n+                  was already present.\");\n         }\n \n         self.children.entry(parent).or_insert(vec![]).push(child);"}, {"sha": "befca878bc0e435cb290ae3363e3a8b079c5b057", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -481,8 +481,8 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n     }\n \n-    tcx.sess.bug(&format!(\"get_vtable_index_of_object_method: {:?} was not found\",\n-                          method_def_id));\n+    bug!(\"get_vtable_index_of_object_method: {:?} was not found\",\n+         method_def_id);\n }\n \n pub enum TupleArgumentsFlag { Yes, No }"}, {"sha": "90ccdeea9289036282af36e28845f66fb658915c", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -159,9 +159,8 @@ impl<'tcx> ty::TyS<'tcx> {\n                                 cx.mk_ty(ty::TyFnPtr(b))\n                             }\n                             _ => {\n-                                cx.sess.bug(\n-                                    &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n-                                              {:?}\", self));\n+                                bug!(\"AdjustReifyFnPointer adjustment on non-fn-item: {:?}\",\n+                                     self);\n                             }\n                         }\n                     }\n@@ -170,10 +169,8 @@ impl<'tcx> ty::TyS<'tcx> {\n                         match self.sty {\n                             ty::TyFnPtr(b) => cx.safe_to_unsafe_fn_ty(b),\n                             ref b => {\n-                                cx.sess.bug(\n-                                    &format!(\"AdjustUnsafeFnPointer adjustment on non-fn-ptr: \\\n-                                             {:?}\",\n-                                            b));\n+                                bug!(\"AdjustUnsafeFnPointer adjustment on non-fn-ptr: {:?}\",\n+                                     b);\n                             }\n                         }\n                     }\n@@ -185,10 +182,8 @@ impl<'tcx> ty::TyS<'tcx> {\n                                 mutbl: hir::MutImmutable\n                             }),\n                             ref b => {\n-                                cx.sess.bug(\n-                                    &format!(\"AdjustMutToConstPointer on non-raw-ptr: \\\n-                                             {:?}\",\n-                                            b));\n+                                bug!(\"AdjustMutToConstPointer on non-raw-ptr: {:?}\",\n+                                     b);\n                             }\n                         }\n                     }\n@@ -239,12 +234,11 @@ impl<'tcx> ty::TyS<'tcx> {\n         match adjusted_ty.builtin_deref(true, NoPreference) {\n             Some(mt) => mt.ty,\n             None => {\n-                cx.sess.span_bug(\n+                span_bug!(\n                     expr_span,\n-                    &format!(\"the {}th autoderef failed: {}\",\n-                             autoderef,\n-                             adjusted_ty)\n-                        );\n+                    \"the {}th autoderef failed: {}\",\n+                    autoderef,\n+                    adjusted_ty);\n             }\n         }\n     }"}, {"sha": "ba237184a9f1d8c252280526dab77f5362bec19b", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -247,7 +247,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n                 ty::TyInfer(_) |\n                 ty::TyError => {\n-                    cx.sess.bug(\"asked to compute contents of error type\");\n+                    bug!(\"asked to compute contents of error type\");\n                 }\n             };\n "}, {"sha": "842a58571e012da1dc232615de320e6b43207378", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -462,8 +462,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let did = def.trait_ref.def_id;\n         let interned = self.arenas.trait_defs.alloc(def);\n         if let Some(prev) = self.trait_defs.borrow_mut().insert(did, interned) {\n-            self.sess.bug(&format!(\"Tried to overwrite interned TraitDef: {:?}\",\n-                                   prev))\n+            bug!(\"Tried to overwrite interned TraitDef: {:?}\", prev)\n         }\n         interned\n     }\n@@ -482,8 +481,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let interned = self.arenas.adt_defs.alloc(def);\n         // this will need a transmute when reverse-variance is removed\n         if let Some(prev) = self.adt_defs.borrow_mut().insert(did, interned) {\n-            self.sess.bug(&format!(\"Tried to overwrite interned AdtDef: {:?}\",\n-                                   prev))\n+            bug!(\"Tried to overwrite interned AdtDef: {:?}\", prev)\n         }\n         interned\n     }\n@@ -497,16 +495,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(prev) = self.stability_interner\n                                 .borrow_mut()\n                                 .insert(interned, interned) {\n-            self.sess.bug(&format!(\"Tried to overwrite interned Stability: {:?}\",\n-                                   prev))\n+            bug!(\"Tried to overwrite interned Stability: {:?}\", prev)\n         }\n         interned\n     }\n \n     pub fn store_free_region_map(&self, id: NodeId, map: FreeRegionMap) {\n         if self.free_region_maps.borrow_mut().insert(id, map).is_some() {\n-            self.sess.bug(&format!(\"Tried to overwrite interned FreeRegionMap for NodeId {:?}\",\n-                                   id))\n+            bug!(\"Tried to overwrite interned FreeRegionMap for NodeId {:?}\", id)\n         }\n     }\n "}, {"sha": "edfad09ae1fa1d5968298498482652288d384c2a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 36, "deletions": 44, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -1241,9 +1241,8 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                     cx.region_maps.call_site_extent(id, body.id))\n                             }\n                             _ => {\n-                                cx.sess\n-                                  .bug(\"ParameterEnvironment::for_item(): \\\n-                                        got non-method item from impl method?!\")\n+                                bug!(\"ParameterEnvironment::for_item(): \\\n+                                      got non-method item from impl method?!\")\n                             }\n                         }\n                     }\n@@ -1295,10 +1294,9 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                     extent)\n                             }\n                             _ => {\n-                                cx.sess\n-                                  .bug(\"ParameterEnvironment::for_item(): \\\n-                                        got non-method item from provided \\\n-                                        method?!\")\n+                                bug!(\"ParameterEnvironment::for_item(): \\\n+                                      got non-method item from provided \\\n+                                      method?!\")\n                             }\n                         }\n                     }\n@@ -1341,10 +1339,10 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                                            cx.region_maps.item_extent(id))\n                     }\n                     _ => {\n-                        cx.sess.span_bug(item.span,\n-                                         \"ParameterEnvironment::for_item():\n-                                          can't create a parameter \\\n-                                          environment for this kind of item\")\n+                        span_bug!(item.span,\n+                                  \"ParameterEnvironment::for_item():\n+                                   can't create a parameter \\\n+                                   environment for this kind of item\")\n                     }\n                 }\n             }\n@@ -1353,9 +1351,9 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                 ParameterEnvironment::for_item(cx, cx.map.get_parent(id))\n             }\n             _ => {\n-                cx.sess.bug(&format!(\"ParameterEnvironment::for_item(): \\\n-                                     `{}` is not an item\",\n-                                    cx.map.node_to_string(id)))\n+                bug!(\"ParameterEnvironment::from_item(): \\\n+                      `{}` is not an item\",\n+                     cx.map.node_to_string(id))\n             }\n         }\n     }\n@@ -1649,7 +1647,7 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n         match def {\n             Def::Variant(_, vid) => self.variant_with_id(vid),\n             Def::Struct(..) | Def::TyAlias(..) => self.struct_variant(),\n-            _ => panic!(\"unexpected def {:?} in variant_of_def\", def)\n+            _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n         }\n     }\n \n@@ -1859,7 +1857,7 @@ fn lookup_locally_or_in_crate_store<M, F>(descr: &str,\n {\n     map.memoize(def_id, || {\n         if def_id.is_local() {\n-            panic!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n+            bug!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n         }\n         load_external()\n     })\n@@ -1902,9 +1900,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n         match self.node_id_to_type_opt(id) {\n            Some(ty) => ty,\n-           None => self.sess.bug(\n-               &format!(\"node_id_to_type: no type for node `{}`\",\n-                        self.map.node_to_string(id)))\n+           None => bug!(\"node_id_to_type: no type for node `{}`\",\n+                        self.map.node_to_string(id))\n         }\n     }\n \n@@ -1980,12 +1977,10 @@ impl<'tcx> TyCtxt<'tcx> {\n                 e.span\n             }\n             Some(f) => {\n-                self.sess.bug(&format!(\"Node id {} is not an expr: {:?}\",\n-                                       id, f));\n+                bug!(\"Node id {} is not an expr: {:?}\", id, f);\n             }\n             None => {\n-                self.sess.bug(&format!(\"Node id {} is not present \\\n-                                        in the node map\", id));\n+                bug!(\"Node id {} is not present in the node map\", id);\n             }\n         }\n     }\n@@ -1996,20 +1991,19 @@ impl<'tcx> TyCtxt<'tcx> {\n                 match pat.node {\n                     PatKind::Ident(_, ref path1, _) => path1.node.name.as_str(),\n                     _ => {\n-                        self.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\", id, pat));\n+                        bug!(\"Variable id {} maps to {:?}, not local\", id, pat);\n                     },\n                 }\n             },\n-            r => self.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\", id, r)),\n+            r => bug!(\"Variable id {} maps to {:?}, not local\", id, r),\n         }\n     }\n \n     pub fn resolve_expr(&self, expr: &hir::Expr) -> Def {\n         match self.def_map.borrow().get(&expr.id) {\n             Some(def) => def.full_def(),\n             None => {\n-                self.sess.span_bug(expr.span, &format!(\n-                    \"no def-map entry for expr {}\", expr.id));\n+                span_bug!(expr.span, \"no def-map entry for expr {}\", expr.id);\n             }\n         }\n     }\n@@ -2032,8 +2026,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                     Some(&def::PathResolution { base_def: Def::Err, .. })=> true,\n                     Some(..) => false,\n-                    None => self.sess.span_bug(expr.span, &format!(\n-                        \"no def for path {}\", expr.id))\n+                    None => span_bug!(expr.span, \"no def for path {}\", expr.id)\n                 }\n             }\n \n@@ -2085,17 +2078,17 @@ impl<'tcx> TyCtxt<'tcx> {\n                         match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n                             MethodTraitItem(m) => Some(m),\n                             _ => {\n-                                self.sess.bug(\"provided_trait_methods(): \\\n-                                               non-method item found from \\\n-                                               looking up provided method?!\")\n+                                bug!(\"provided_trait_methods(): \\\n+                                      non-method item found from \\\n+                                      looking up provided method?!\")\n                             }\n                         }\n                     } else {\n                         None\n                     }\n                 }).collect()\n             } else {\n-                self.sess.bug(&format!(\"provided_trait_methods: `{:?}` is not a trait\", id))\n+                bug!(\"provided_trait_methods: `{:?}` is not a trait\", id)\n             }\n         } else {\n             self.sess.cstore.provided_trait_methods(self, id)\n@@ -2111,9 +2104,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                             match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n                                 ConstTraitItem(ac) => Some(ac),\n                                 _ => {\n-                                    self.sess.bug(\"associated_consts(): \\\n-                                                   non-const item found from \\\n-                                                   looking up a constant?!\")\n+                                    bug!(\"associated_consts(): \\\n+                                          non-const item found from \\\n+                                          looking up a constant?!\")\n                                 }\n                             }\n                         } else {\n@@ -2127,9 +2120,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                             match self.impl_or_trait_item(self.map.local_def_id(ii.id)) {\n                                 ConstTraitItem(ac) => Some(ac),\n                                 _ => {\n-                                    self.sess.bug(\"associated_consts(): \\\n-                                                   non-const item found from \\\n-                                                   looking up a constant?!\")\n+                                    bug!(\"associated_consts(): \\\n+                                          non-const item found from \\\n+                                          looking up a constant?!\")\n                                 }\n                             }\n                         } else {\n@@ -2138,8 +2131,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }).collect()\n                 }\n                 _ => {\n-                    self.sess.bug(&format!(\"associated_consts: `{:?}` is not a trait \\\n-                                            or impl\", id))\n+                    bug!(\"associated_consts: `{:?}` is not a trait or impl\", id)\n                 }\n             }\n         } else {\n@@ -2174,9 +2166,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             match kind {\n                 Some(kind) => kind,\n                 None => {\n-                    self.sess.bug(&format!(\"custom_coerce_unsized_kind: \\\n-                                            {} impl `{}` is missing its kind\",\n-                                           src, self.item_path_str(did)));\n+                    bug!(\"custom_coerce_unsized_kind: \\\n+                          {} impl `{}` is missing its kind\",\n+                          src, self.item_path_str(did));\n                 }\n             }\n         })"}, {"sha": "b39cb5ef939e548cd84b23b4382291289fdd7a8f", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -453,7 +453,7 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n         (_, &ty::TyInfer(_)) =>\n         {\n             // The caller should handle these cases!\n-            tcx.sess.bug(\"var types encountered in super_relate_tys\")\n+            bug!(\"var types encountered in super_relate_tys\")\n         }\n \n         (&ty::TyError, _) | (_, &ty::TyError) =>"}, {"sha": "fee0aaff44593cd17a2529717da49347e74ca097", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -259,7 +259,7 @@ impl<'tcx> Decodable for &'tcx ClosureSubsts<'tcx> {\n                                                               Box::new(closure_substs));\n             match ty.sty {\n                 TyClosure(_, ref closure_substs) => Ok(&**closure_substs),\n-                _ => unreachable!()\n+                _ => bug!()\n             }\n         })\n     }\n@@ -467,7 +467,7 @@ impl<'tcx> FnOutput<'tcx> {\n     pub fn unwrap(self) -> Ty<'tcx> {\n         match self {\n             ty::FnConverging(t) => t,\n-            ty::FnDiverging => unreachable!()\n+            ty::FnDiverging => bug!()\n         }\n     }\n \n@@ -978,8 +978,7 @@ impl<'tcx> TyS<'tcx> {\n         match self.sty {\n             TyArray(ty, _) | TySlice(ty) => ty,\n             TyStr => cx.mk_mach_uint(ast::UintTy::U8),\n-            _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                      self)),\n+            _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n         }\n     }\n \n@@ -988,14 +987,14 @@ impl<'tcx> TyS<'tcx> {\n             TyStruct(def, substs) => {\n                 def.struct_variant().fields[0].ty(cx, substs)\n             }\n-            _ => panic!(\"simd_type called on invalid type\")\n+            _ => bug!(\"simd_type called on invalid type\")\n         }\n     }\n \n     pub fn simd_size(&self, _cx: &TyCtxt) -> usize {\n         match self.sty {\n             TyStruct(def, _) => def.struct_variant().fields.len(),\n-            _ => panic!(\"simd_size called on invalid type\")\n+            _ => bug!(\"simd_size called on invalid type\")\n         }\n     }\n \n@@ -1148,15 +1147,15 @@ impl<'tcx> TyS<'tcx> {\n     pub fn fn_sig(&self) -> &'tcx PolyFnSig<'tcx> {\n         match self.sty {\n             TyFnDef(_, _, ref f) | TyFnPtr(ref f) => &f.sig,\n-            _ => panic!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n+            _ => bug!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }\n \n     /// Returns the ABI of the given function.\n     pub fn fn_abi(&self) -> abi::Abi {\n         match self.sty {\n             TyFnDef(_, _, ref f) | TyFnPtr(ref f) => f.abi,\n-            _ => panic!(\"Ty::fn_abi() called on non-fn type\"),\n+            _ => bug!(\"Ty::fn_abi() called on non-fn type\"),\n         }\n     }\n "}, {"sha": "5b05c632a97c6f0315257ea238050cdf6fe9b7f1", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -193,7 +193,7 @@ impl ParamSpace {\n             0 => TypeSpace,\n             1 => SelfSpace,\n             2 => FnSpace,\n-            _ => panic!(\"Invalid ParamSpace: {}\", u)\n+            _ => bug!(\"Invalid ParamSpace: {}\", u)\n         }\n     }\n }\n@@ -604,15 +604,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                     }\n                     None => {\n                         let span = self.span.unwrap_or(DUMMY_SP);\n-                        self.tcx().sess.span_bug(\n+                        span_bug!(\n                             span,\n-                            &format!(\"Region parameter out of range \\\n-                                      when substituting in region {} (root type={:?}) \\\n-                                      (space={:?}, index={})\",\n-                                     data.name,\n-                                     self.root_ty,\n-                                     data.space,\n-                                     data.index));\n+                            \"Region parameter out of range \\\n+                             when substituting in region {} (root type={:?}) \\\n+                             (space={:?}, index={})\",\n+                            data.name,\n+                            self.root_ty,\n+                            data.space,\n+                            data.index);\n                     }\n                 }\n             }\n@@ -659,16 +659,16 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n             Some(t) => *t,\n             None => {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n-                self.tcx().sess.span_bug(\n+                span_bug!(\n                     span,\n-                    &format!(\"Type parameter `{:?}` ({:?}/{:?}/{}) out of range \\\n-                                 when substituting (root type={:?}) substs={:?}\",\n-                            p,\n-                            source_ty,\n-                            p.space,\n-                            p.idx,\n-                            self.root_ty,\n-                            self.substs));\n+                    \"Type parameter `{:?}` ({:?}/{:?}/{}) out of range \\\n+                         when substituting (root type={:?}) substs={:?}\",\n+                    p,\n+                    source_ty,\n+                    p.space,\n+                    p.idx,\n+                    self.root_ty,\n+                    self.substs);\n             }\n         };\n "}, {"sha": "6e8363f629b69e3ce55f1813087d5dddd6fb877e", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -62,7 +62,7 @@ impl IntTypeExt for attr::IntType {\n             SignedInt(ast::IntTy::Is) => match tcx.sess.target.int_type {\n                 ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32(0)),\n                 ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64(0)),\n-                _ => unreachable!(),\n+                _ => bug!(),\n             },\n             UnsignedInt(ast::UintTy::U8)  => ConstInt::U8(0),\n             UnsignedInt(ast::UintTy::U16) => ConstInt::U16(0),\n@@ -71,7 +71,7 @@ impl IntTypeExt for attr::IntType {\n             UnsignedInt(ast::UintTy::Us) => match tcx.sess.target.uint_type {\n                 ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(0)),\n                 ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(0)),\n-                _ => unreachable!(),\n+                _ => bug!(),\n             },\n         }\n     }\n@@ -88,7 +88,7 @@ impl IntTypeExt for attr::IntType {\n             (UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => {},\n             (UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => {},\n             (UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => {},\n-            _ => panic!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n+            _ => bug!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n         }\n     }\n \n@@ -351,7 +351,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     ty::ReScope(..) |\n                     ty::ReVar(..) |\n                     ty::ReSkolemized(..) => {\n-                        tcx.sess.bug(\"unexpected region found when hashing a type\")\n+                        bug!(\"unexpected region found when hashing a type\")\n                     }\n                 }\n             };\n@@ -453,7 +453,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         hash!(p.idx);\n                         hash!(p.name.as_str());\n                     }\n-                    TyInfer(_) => unreachable!(),\n+                    TyInfer(_) => bug!(),\n                     TyError => byte!(21),\n                     TyClosure(d, _) => {\n                         byte!(22);\n@@ -632,7 +632,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                 TyClosure(..) => {\n                     // this check is run on type definitions, so we don't expect\n                     // to see closure types\n-                    cx.sess.bug(&format!(\"requires check invoked on inapplicable type: {:?}\", ty))\n+                    bug!(\"requires check invoked on inapplicable type: {:?}\", ty)\n                 }\n                 _ => Representability::Representable,\n             }"}, {"sha": "d1b30bb2746c934f0e4ce1c01c5b8895c2e063ad", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -27,7 +27,7 @@ use rustc::middle::mem_categorization as mc;\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n use syntax::attr::AttrMetaMethods;\n \n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n@@ -428,8 +428,8 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             let tuple_idx = match *origin_field_name {\n                 mc::PositionalField(tuple_idx) => tuple_idx,\n                 mc::NamedField(_) =>\n-                    panic!(\"tuple type {:?} should not have named fields.\",\n-                           parent_ty),\n+                    bug!(\"tuple type {:?} should not have named fields.\",\n+                         parent_ty),\n             };\n             let tuple_len = v.len();\n             for i in 0..tuple_len {\n@@ -493,10 +493,11 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n         }\n \n         ref sty_and_variant_info => {\n-            let msg = format!(\"type {:?} ({:?}) is not fragmentable\",\n-                              parent_ty, sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n-            tcx.sess.opt_span_bug(opt_span, &msg[..])\n+            span_bug!(opt_span.unwrap_or(DUMMY_SP),\n+                      \"type {:?} ({:?}) is not fragmentable\",\n+                      parent_ty,\n+                      sty_and_variant_info);\n         }\n     }\n }"}, {"sha": "489c8be4e3862e0015a89e5fe4504333d32218da", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -78,8 +78,8 @@ pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                 LpDowncast(ref base_lp, _) =>\n                     move_data.add_variant_match(\n                         tcx, lp.clone(), move_pat.id, base_lp.clone(), mode),\n-                _ => panic!(\"should only call gather_match_variant \\\n-                             for cat_downcast cmt\"),\n+                _ => bug!(\"should only call gather_match_variant \\\n+                           for cat_downcast cmt\"),\n             }\n         }\n         None => {"}, {"sha": "c759722c24b9ac338a01b22fa26b912364bf051b", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -378,10 +378,10 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     ty::ReEarlyBound(..) |\n                     ty::ReVar(..) |\n                     ty::ReSkolemized(..) => {\n-                        self.tcx().sess.span_bug(\n+                        span_bug!(\n                             cmt.span,\n-                            &format!(\"invalid borrow lifetime: {:?}\",\n-                                    loan_region));\n+                            \"invalid borrow lifetime: {:?}\",\n+                            loan_region);\n                     }\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);"}, {"sha": "f5e3bc4f6fb3aed758faa96abec1aa864785b4b7", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -134,8 +134,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                   a non-copy fixed-size array\",\n                                  b.ty)\n             } else {\n-                bccx.span_bug(move_from.span, \"this path should not cause illegal move\");\n-                unreachable!();\n+                span_bug!(move_from.span, \"this path should not cause illegal move\");\n             }\n         }\n \n@@ -150,14 +149,12 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      b.ty)\n                 },\n                 _ => {\n-                    bccx.span_bug(move_from.span, \"this path should not cause illegal move\");\n-                    unreachable!();\n+                    span_bug!(move_from.span, \"this path should not cause illegal move\");\n                 }\n             }\n         }\n         _ => {\n-            bccx.span_bug(move_from.span, \"this path should not cause illegal move\");\n-            unreachable!();\n+            span_bug!(move_from.span, \"this path should not cause illegal move\");\n         }\n     }\n }"}, {"sha": "2b1b743afe9b5a1850fe67f81370ae3ea47bb53c", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -569,7 +569,7 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &TyCtxt<'tcx>) -> MoveData<'tcx> {\n                         Rvalue::InlineAsm { .. } => {}\n \n                         Rvalue::Slice {..} => {\n-                            bb_ctxt.tcx.sess.bug(\"cannot move out of slice\");\n+                            bug!(\"cannot move out of slice\");\n                         }\n                     }\n                 }"}, {"sha": "1dfa4da46aa99e42e9e12cef6d1d6c237e73d33c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -420,10 +420,10 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n                 block.id\n             }\n             _ => {\n-                panic!(\"encountered non-closure id: {}\", closure_id)\n+                bug!(\"encountered non-closure id: {}\", closure_id)\n             }\n         },\n-        _ => panic!(\"encountered non-expr id: {}\", closure_id)\n+        _ => bug!(\"encountered non-expr id: {}\", closure_id)\n     }\n }\n \n@@ -704,10 +704,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         (self.tcx.expr_ty_adjusted(&expr), expr.span)\n                     }\n                     r => {\n-                        self.tcx.sess.bug(&format!(\"MoveExpr({}) maps to \\\n-                                                   {:?}, not Expr\",\n-                                                  the_move.id,\n-                                                  r))\n+                        bug!(\"MoveExpr({}) maps to {:?}, not Expr\",\n+                             the_move.id,\n+                             r)\n                     }\n                 };\n                 let (suggestion, _) =\n@@ -766,10 +765,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         (self.tcx.expr_ty_adjusted(&expr), expr.span)\n                     }\n                     r => {\n-                        self.tcx.sess.bug(&format!(\"Captured({}) maps to \\\n-                                                   {:?}, not Expr\",\n-                                                  the_move.id,\n-                                                  r))\n+                        bug!(\"Captured({}) maps to {:?}, not Expr\",\n+                             the_move.id,\n+                             r)\n                     }\n                 };\n                 let (suggestion, help) =\n@@ -852,10 +850,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err_with_code(s, msg, code);\n     }\n \n-    pub fn span_bug(&self, s: Span, m: &str) {\n-        self.tcx.sess.span_bug(s, m);\n-    }\n-\n     pub fn bckerr_to_string(&self, err: &BckError<'tcx>) -> String {\n         match err.code {\n             err_mutbl => {\n@@ -895,7 +889,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         format!(\"cannot borrow {} as mutable\", descr)\n                     }\n                     BorrowViolation(euv::ClosureInvocation) => {\n-                        self.tcx.sess.span_bug(err.span,\n+                        span_bug!(err.span,\n                             \"err_mutbl with a closure invocation\");\n                     }\n                 }\n@@ -1035,7 +1029,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         // We need to determine which is the case here.\n                         let kind = match err.cmt.upvar().unwrap().cat {\n                             Categorization::Upvar(mc::Upvar { kind, .. }) => kind,\n-                            _ => unreachable!()\n+                            _ => bug!()\n                         };\n                         if kind == ty::ClosureKind::Fn {\n                             db.span_help("}, {"sha": "b31f74c64760c49b74098106d9234e89e5845c0f", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -515,7 +515,7 @@ impl<'tcx> MoveData<'tcx> {\n                                          assignment_index);\n                 }\n                 LpExtend(..) => {\n-                    tcx.sess.bug(\"var assignment for non var path\");\n+                    bug!(\"var assignment for non var path\");\n                 }\n             }\n         }"}, {"sha": "6f21fcd9230cd3b1dbe2aef55e9292ad54305ad1", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -32,6 +32,7 @@\n // for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n // refers to the borrowck-specific graphviz adapter traits.\n extern crate graphviz as dot;\n+#[macro_use]\n extern crate rustc;\n extern crate rustc_front;\n extern crate rustc_mir;"}, {"sha": "a46d72840b72857721356b00f871c430ade2e221", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -339,20 +339,20 @@ fn check_arms(cx: &MatchCheckCtxt,\n                             // `Some(<head>)` and `None`. It's impossible to have an unreachable\n                             // pattern\n                             // (see libsyntax/ext/expand.rs for the full expansion of a for loop)\n-                            cx.tcx.sess.span_bug(pat.span, \"unreachable for-loop pattern\")\n+                            span_bug!(pat.span, \"unreachable for-loop pattern\")\n                         },\n \n                         hir::MatchSource::Normal => {\n                             span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\")\n                         },\n \n                         hir::MatchSource::TryDesugar => {\n-                            cx.tcx.sess.span_bug(pat.span, \"unreachable try pattern\")\n+                            span_bug!(pat.span, \"unreachable try pattern\")\n                         },\n                     }\n                 }\n                 Useful => (),\n-                UsefulWithWitness(_) => unreachable!()\n+                UsefulWithWitness(_) => bug!()\n             }\n             if guard.is_none() {\n                 let Matrix(mut rows) = seen;\n@@ -384,9 +384,9 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n                     let witness = match witnesses[0].node {\n                         PatKind::TupleStruct(_, Some(ref pats)) => match &pats[..] {\n                             [ref pat] => &**pat,\n-                            _ => unreachable!(),\n+                            _ => bug!(),\n                         },\n-                        _ => unreachable!(),\n+                        _ => bug!(),\n                     };\n                     span_err!(cx.tcx.sess, sp, E0297,\n                         \"refutable pattern in `for` loop binding: \\\n@@ -399,7 +399,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n                     }).collect();\n                     const LIMIT: usize = 3;\n                     let joined_patterns = match pattern_strings.len() {\n-                        0 => unreachable!(),\n+                        0 => bug!(),\n                         1 => format!(\"`{}`\", pattern_strings[0]),\n                         2...LIMIT => {\n                             let (tail, head) = pattern_strings.split_last().unwrap();\n@@ -420,14 +420,14 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n         NotUseful => {\n             // This is good, wildcard pattern isn't reachable\n         },\n-        _ => unreachable!()\n+        _ => bug!()\n     }\n }\n \n fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n     let node = match value {\n         &ConstVal::Bool(b) => ast::LitKind::Bool(b),\n-        _ => unreachable!()\n+        _ => bug!()\n     };\n     P(hir::Expr {\n         id: 0,\n@@ -579,14 +579,14 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                         assert_eq!(pats_len, n);\n                         PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n                     },\n-                    _ => unreachable!()\n+                    _ => bug!()\n                 },\n                 ty::TySlice(_) => match ctor {\n                     &Slice(n) => {\n                         assert_eq!(pats_len, n);\n                         PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n                     },\n-                    _ => unreachable!()\n+                    _ => bug!()\n                 },\n                 ty::TyStr => PatKind::Wild,\n \n@@ -791,17 +791,16 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::Ident(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n-                                                    been rewritten\"),\n+                    span_bug!(pat.span, \"const pattern should've \\\n+                                         been rewritten\"),\n                 Def::Struct(..) | Def::TyAlias(..) => vec![Single],\n                 Def::Variant(_, id) => vec![Variant(id)],\n                 Def::Local(..) => vec![],\n-                def => cx.tcx.sess.span_bug(pat.span, &format!(\"pat_constructors: unexpected \\\n-                                                                definition {:?}\", def)),\n+                def => span_bug!(pat.span, \"pat_constructors: unexpected \\\n+                                            definition {:?}\", def),\n             },\n         PatKind::QPath(..) =>\n-            cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n-                                            been rewritten\"),\n+            span_bug!(pat.span, \"const pattern should've been rewritten\"),\n         PatKind::Lit(ref expr) =>\n             vec!(ConstantValue(eval_const_expr(cx.tcx, &expr))),\n         PatKind::Range(ref lo, ref hi) =>\n@@ -837,7 +836,7 @@ pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> us\n             ty::TySlice(_) => match *ctor {\n                 Slice(length) => length,\n                 ConstantValue(_) => 0,\n-                _ => unreachable!()\n+                _ => bug!()\n             },\n             ty::TyStr => 0,\n             _ => 1\n@@ -856,7 +855,7 @@ fn range_covered_by_constructor(ctor: &Constructor,\n         ConstantValue(ref value)        => (value, value),\n         ConstantRange(ref from, ref to) => (from, to),\n         Single                          => return Some(true),\n-        _                               => unreachable!()\n+        _                               => bug!()\n     };\n     let cmp_from = compare_const_vals(c_from, from);\n     let cmp_to = compare_const_vals(c_to, to);\n@@ -889,22 +888,22 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n-                    cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n-                                                    been rewritten\"),\n+                    span_bug!(pat_span, \"const pattern should've \\\n+                                         been rewritten\"),\n                 Def::Variant(_, id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => Some(Vec::new()),\n                 Def::Local(..) => Some(vec![DUMMY_WILD_PAT; arity]),\n-                _ => cx.tcx.sess.span_bug(pat_span, &format!(\"specialize: unexpected \\\n-                                                              definition {:?}\", def)),\n+                _ => span_bug!(pat_span, \"specialize: unexpected \\\n+                                          definition {:?}\", def),\n             }\n         }\n \n         PatKind::TupleStruct(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n-                    cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n-                                                    been rewritten\"),\n+                    span_bug!(pat_span, \"const pattern should've \\\n+                                         been rewritten\"),\n                 Def::Variant(_, id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => {\n                     Some(match args {\n@@ -917,8 +916,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         PatKind::QPath(_, _) => {\n-            cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n-                                            been rewritten\")\n+            span_bug!(pat_span, \"const pattern should've been rewritten\")\n         }\n \n         PatKind::Struct(_, ref pattern_fields, _) => {\n@@ -1062,7 +1060,7 @@ fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A>\n     match is_useful(cx, &pats, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => Some(refutable(&pats[0])),\n         NotUseful => None,\n-        Useful => unreachable!()\n+        Useful => bug!()\n     }\n }\n \n@@ -1119,12 +1117,11 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     PatKind::Ident(hir::BindByRef(_), _, _) => {\n                     }\n                     _ => {\n-                        cx.tcx.sess.span_bug(\n+                        span_bug!(\n                             p.span,\n-                            &format!(\"binding pattern {} is not an \\\n-                                     identifier: {:?}\",\n-                                    p.id,\n-                                    p.node));\n+                            \"binding pattern {} is not an identifier: {:?}\",\n+                            p.id,\n+                            p.node);\n                     }\n                 }\n             }"}, {"sha": "4790e4819378d6fa2467ca03093527191a0c2722", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -286,7 +286,7 @@ pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, spa\n                     node: PatKind::Lit(P(expr.clone())),\n                     span: span,\n                 })),\n-                _ => unreachable!()\n+                _ => bug!()\n             };\n             let pats = try!(args.iter()\n                                 .map(|expr| const_expr_to_pat(tcx, &**expr,\n@@ -330,7 +330,7 @@ pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, spa\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n                     return const_expr_to_pat(tcx, expr, pat_id, span);\n                 },\n-                _ => unreachable!(),\n+                _ => bug!(),\n             }\n         }\n \n@@ -588,7 +588,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                         IntTy::I64 => if n == I64_OVERFLOW {\n                             return Ok(Integral(Isize(Is64(::std::i64::MIN))));\n                         },\n-                        _ => unreachable!(),\n+                        _ => bug!(),\n                     }\n                 },\n                 _ => {},\n@@ -697,7 +697,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                     Some(IntType::UnsignedInt(ty)) => ty_hint.checked_or(tcx.mk_mach_uint(ty)),\n                     Some(IntType::SignedInt(ty)) => ty_hint.checked_or(tcx.mk_mach_int(ty)),\n                     // we had a type hint, so we can't have an unknown type\n-                    None => unreachable!(),\n+                    None => bug!(),\n                 };\n                 eval_const_expr_partial(tcx, &base, hint, fn_args)?\n             },\n@@ -798,7 +798,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)?,\n-            None => unreachable!(),\n+            None => bug!(),\n         }\n       }\n       hir::ExprType(ref e, _) => eval_const_expr_partial(tcx, &e, ty_hint, fn_args)?,\n@@ -813,7 +813,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         let idx_hint = ty_hint.checked_or(tcx.types.usize);\n         let idx = match eval_const_expr_partial(tcx, idx, idx_hint, fn_args)? {\n             Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n-            Integral(_) => unreachable!(),\n+            Integral(_) => bug!(),\n             _ => signal!(idx, IndexNotInt),\n         };\n         assert_eq!(idx as usize as u64, idx);\n@@ -823,7 +823,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                 assert_eq!(n as usize as u64, n);\n                 eval_const_expr_partial(tcx, &v[idx as usize], ty_hint, fn_args)?\n             } else {\n-                unreachable!()\n+                bug!()\n             },\n \n             Repeat(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n@@ -840,7 +840,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n             },\n \n             Str(ref s) if idx as usize >= s.len() => signal!(e, IndexOutOfBounds),\n-            Str(_) => unimplemented!(), // FIXME: return a const char\n+            Str(_) => bug!(\"unimplemented\"), // FIXME: return a const char\n             _ => signal!(e, IndexedNonVec),\n         }\n       }\n@@ -867,7 +867,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                     signal!(e, TupleIndexOutOfBounds);\n                 }\n             } else {\n-                unreachable!()\n+                bug!()\n             }\n         } else {\n             signal!(base, ExpectedConstTuple);\n@@ -888,7 +888,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                     signal!(e, MissingStructField);\n                 }\n             } else {\n-                unreachable!()\n+                bug!()\n             }\n         } else {\n             signal!(base, ExpectedConstStruct);\n@@ -1025,7 +1025,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             }\n         }\n         _ => {\n-            tcx.sess.span_bug(\n+            span_bug!(\n                 ti.span,\n                 \"resolve_trait_associated_const: unexpected vtable type\")\n         }\n@@ -1127,7 +1127,7 @@ fn lit_to_const<'tcx>(lit: &ast::LitKind,\n                     let int_ty = tcx.enum_repr_type(hints.iter().next());\n                     infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty, span).map(Integral)\n                 },\n-                Some(ty_hint) => panic!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n+                Some(ty_hint) => bug!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n             }\n         },\n         LitKind::Int(n, Unsigned(ity)) => {\n@@ -1140,7 +1140,7 @@ fn lit_to_const<'tcx>(lit: &ast::LitKind,\n                 Ok(Float(x))\n             } else {\n                 // FIXME(#31407) this is only necessary because float parsing is buggy\n-                tcx.sess.span_bug(span, \"could not evaluate float literal (see issue #31407)\");\n+                span_bug!(span, \"could not evaluate float literal (see issue #31407)\");\n             }\n         }\n         LitKind::Bool(b) => Ok(Bool(b)),"}, {"sha": "b74fc121e391dd53b4e9210c5d5fedf28e2e61f7", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -32,7 +32,7 @@\n \n #[macro_use] extern crate syntax;\n #[macro_use] extern crate log;\n-extern crate rustc;\n+#[macro_use] extern crate rustc;\n extern crate rustc_front;\n extern crate rustc_back;\n extern crate rustc_const_math;"}, {"sha": "ca189d0b51961813af28617c1b1643f79d4f6d9b", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -30,7 +30,7 @@ pub enum MethodLateContext {\n pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n     let def_id = cx.tcx.map.local_def_id(id);\n     match cx.tcx.impl_or_trait_items.borrow().get(&def_id) {\n-        None => cx.sess().span_bug(span, \"missing method descriptor?!\"),\n+        None => span_bug!(span, \"missing method descriptor?!\"),\n         Some(item) => match item.container() {\n             ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n             ty::ImplContainer(cid) => {"}, {"sha": "6eeadc77698a07867fc7b5d1551472e0a4747e81", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -181,7 +181,7 @@ impl LateLintPass for TypeLimits {\n                                     return;\n                                 }\n                             }\n-                            _ => panic!()\n+                            _ => bug!()\n                         };\n                     },\n                     ty::TyUint(t) => {\n@@ -195,7 +195,7 @@ impl LateLintPass for TypeLimits {\n                             // _v is u8, within range by definition\n                             ast::LitKind::Byte(_v) => return,\n                             ast::LitKind::Int(v, _) => v,\n-                            _ => panic!()\n+                            _ => bug!()\n                         };\n                         if lit_val < min || lit_val > max {\n                             cx.span_lint(OVERFLOWING_LITERALS, e.span,\n@@ -212,7 +212,7 @@ impl LateLintPass for TypeLimits {\n                                     Err(_) => return\n                                 }\n                             }\n-                            _ => panic!()\n+                            _ => bug!()\n                         };\n                         if lit_val < min || lit_val > max {\n                             cx.span_lint(OVERFLOWING_LITERALS, e.span,\n@@ -233,7 +233,7 @@ impl LateLintPass for TypeLimits {\n                 hir::BiGt => v >= min && v <  max,\n                 hir::BiGe => v >  min && v <= max,\n                 hir::BiEq | hir::BiNe => v >= min && v <= max,\n-                _ => panic!()\n+                _ => bug!()\n             }\n         }\n \n@@ -319,7 +319,7 @@ impl LateLintPass for TypeLimits {\n                             ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i64,\n                             _ => return true\n                         },\n-                        _ => panic!()\n+                        _ => bug!()\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n@@ -330,7 +330,7 @@ impl LateLintPass for TypeLimits {\n                             ast::LitKind::Int(v, _) => v,\n                             _ => return true\n                         },\n-                        _ => panic!()\n+                        _ => bug!()\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n@@ -589,7 +589,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::TyParam(..) | ty::TyInfer(..) | ty::TyError |\n             ty::TyClosure(..) | ty::TyProjection(..) |\n             ty::TyFnDef(..) => {\n-                panic!(\"Unexpected type in foreign function\")\n+                bug!(\"Unexpected type in foreign function\")\n             }\n         }\n     }"}, {"sha": "505619d31d735700c355bdc6a4df8818b72ded10", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -991,7 +991,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                         region: this.read_enum_variant_arg(1,\n                                     |this| Ok(this.read_region(dcx))).unwrap()\n                     }),\n-                    _ => panic!(\"bad enum variant for ty::UpvarCapture\")\n+                    _ => bug!(\"bad enum variant for ty::UpvarCapture\")\n                 })\n             })\n         }).unwrap()\n@@ -1013,7 +1013,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n                         adjustment::AdjustDerefRef(auto_deref_ref)\n                     }\n-                    _ => panic!(\"bad enum variant for adjustment::AutoAdjustment\")\n+                    _ => bug!(\"bad enum variant for adjustment::AutoAdjustment\")\n                 })\n             })\n         }).unwrap()\n@@ -1072,7 +1072,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n                         adjustment::AutoUnsafe(m)\n                     }\n-                    _ => panic!(\"bad enum variant for adjustment::AutoRef\")\n+                    _ => bug!(\"bad enum variant for adjustment::AutoRef\")\n                 })\n             })\n         }).unwrap()\n@@ -1140,9 +1140,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n         let decoded_tag: Option<c::astencode_tag> = c::astencode_tag::from_u32(tag);\n         match decoded_tag {\n             None => {\n-                dcx.tcx.sess.bug(\n-                    &format!(\"unknown tag found in side tables: {:x}\",\n-                            tag));\n+                bug!(\"unknown tag found in side tables: {:x}\", tag);\n             }\n             Some(value) => {\n                 let val_dsr = &mut entry_dsr;\n@@ -1206,9 +1204,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         dcx.tcx.const_qualif_map.borrow_mut().insert(id, qualif);\n                     }\n                     _ => {\n-                        dcx.tcx.sess.bug(\n-                            &format!(\"unknown tag found in side tables: {:x}\",\n-                                    tag));\n+                        bug!(\"unknown tag found in side tables: {:x}\", tag);\n                     }\n                 }\n             }\n@@ -1404,6 +1400,6 @@ fn test_simplification() {\n         assert!(pprust::item_to_string(&item_out) ==\n                 pprust::item_to_string(&item_exp));\n       }\n-      _ => panic!()\n+      _ => bug!()\n     }\n }"}, {"sha": "edabf43a15074f14ceb3a9f69a367c1fe9131221", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -36,7 +36,6 @@ use syntax::codemap::{self, Span, mk_sp, Pos};\n use syntax::parse;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::errors::FatalError;\n use syntax::parse::token::InternedString;\n use rustc_front::intravisit::Visitor;\n use rustc_front::hir;\n@@ -527,7 +526,7 @@ impl<'a> CrateReader<'a> {\n                 load_ctxt.filesearch = self.sess.target_filesearch(PathKind::Crate);\n                 load_ctxt.load_library_crate()\n             }\n-            None => { load_ctxt.report_load_errs(); unreachable!() },\n+            None => { load_ctxt.report_load_errs(); },\n         };\n \n         let dylib = library.dylib.clone();\n@@ -573,7 +572,8 @@ impl<'a> CrateReader<'a> {\n                     Ok(body) => body,\n                     Err(mut err) => {\n                         err.emit();\n-                        panic!(FatalError);\n+                        self.sess.abort_if_errors();\n+                        unreachable!();\n                     }\n                 };\n                 let local_span = mk_sp(lo, p.last_span.hi);"}, {"sha": "e85fdb05ca890409579853109d99001bd3d5f65b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -70,7 +70,7 @@ impl crate_metadata {\n \n     fn lookup_item(&self, item_id: DefIndex) -> rbml::Doc {\n         match self.get_item(item_id) {\n-            None => panic!(\"lookup_item: id not found: {:?}\", item_id),\n+            None => bug!(\"lookup_item: id not found: {:?}\", item_id),\n             Some(d) => d\n         }\n     }\n@@ -136,7 +136,7 @@ fn item_family(item: rbml::Doc) -> Family {\n       'u' => Struct(VariantKind::Unit),\n       'g' => PublicField,\n       'N' => InheritedField,\n-       c => panic!(\"unexpected family char: {}\", c)\n+       c => bug!(\"unexpected family char: {}\", c)\n     }\n }\n \n@@ -147,7 +147,7 @@ fn item_visibility(item: rbml::Doc) -> hir::Visibility {\n             match reader::doc_as_u8(visibility_doc) as char {\n                 'y' => hir::Public,\n                 'i' => hir::Inherited,\n-                _ => panic!(\"unknown visibility character\")\n+                _ => bug!(\"unknown visibility character\")\n             }\n         }\n     }\n@@ -160,7 +160,7 @@ fn fn_constness(item: rbml::Doc) -> hir::Constness {\n             match reader::doc_as_u8(constness_doc) as char {\n                 'c' => hir::Constness::Const,\n                 'n' => hir::Constness::NotConst,\n-                _ => panic!(\"unknown constness character\")\n+                _ => bug!(\"unknown constness character\")\n             }\n         }\n     }\n@@ -173,7 +173,7 @@ fn item_defaultness(item: rbml::Doc) -> hir::Defaultness {\n             match reader::doc_as_u8(defaultness_doc) as char {\n                 'd' => hir::Defaultness::Default,\n                 'f' => hir::Defaultness::Final,\n-                _ => panic!(\"unknown defaultness character\")\n+                _ => bug!(\"unknown defaultness character\")\n             }\n         }\n     }\n@@ -387,16 +387,15 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                          item_id: DefIndex,\n                          tcx: &TyCtxt<'tcx>) -> ty::AdtDefMaster<'tcx>\n {\n-    fn expect_variant_kind<'tcx>(family: Family, tcx: &TyCtxt<'tcx>) -> ty::VariantKind {\n+    fn expect_variant_kind(family: Family) -> ty::VariantKind {\n         match family_to_variant_kind(family) {\n             Some(kind) => kind,\n-            _ => tcx.sess.bug(&format!(\"unexpected family: {:?}\", family)),\n+            _ => bug!(\"unexpected family: {:?}\", family),\n         }\n     }\n     fn get_enum_variants<'tcx>(intr: &IdentInterner,\n                                cdata: Cmd,\n-                               doc: rbml::Doc,\n-                               tcx: &TyCtxt<'tcx>) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n+                               doc: rbml::Doc) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n         let mut disr_val = 0;\n         reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n             let did = translated_def_id(cdata, p);\n@@ -411,22 +410,21 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n             ty::VariantDefData {\n                 did: did,\n                 name: item_name(intr, item),\n-                fields: get_variant_fields(intr, cdata, item, tcx),\n+                fields: get_variant_fields(intr, cdata, item),\n                 disr_val: ConstInt::Infer(disr),\n-                kind: expect_variant_kind(item_family(item), tcx),\n+                kind: expect_variant_kind(item_family(item)),\n             }\n         }).collect()\n     }\n     fn get_variant_fields<'tcx>(intr: &IdentInterner,\n                                 cdata: Cmd,\n-                                doc: rbml::Doc,\n-                                tcx: &TyCtxt<'tcx>) -> Vec<ty::FieldDefData<'tcx, 'tcx>> {\n+                                doc: rbml::Doc) -> Vec<ty::FieldDefData<'tcx, 'tcx>> {\n         let mut index = 0;\n         reader::tagged_docs(doc, tag_item_field).map(|f| {\n             let ff = item_family(f);\n             match ff {\n                 PublicField | InheritedField => {},\n-                _ => tcx.sess.bug(&format!(\"expected field, found {:?}\", ff))\n+                _ => bug!(\"expected field, found {:?}\", ff)\n             };\n             ty::FieldDefData::new(item_def_id(f, cdata),\n                                   item_name(intr, f),\n@@ -442,14 +440,13 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n     fn get_struct_variant<'tcx>(intr: &IdentInterner,\n                                 cdata: Cmd,\n                                 doc: rbml::Doc,\n-                                did: DefId,\n-                                tcx: &TyCtxt<'tcx>) -> ty::VariantDefData<'tcx, 'tcx> {\n+                                did: DefId) -> ty::VariantDefData<'tcx, 'tcx> {\n         ty::VariantDefData {\n             did: did,\n             name: item_name(intr, doc),\n-            fields: get_variant_fields(intr, cdata, doc, tcx),\n+            fields: get_variant_fields(intr, cdata, doc),\n             disr_val: ConstInt::Infer(0),\n-            kind: expect_variant_kind(item_family(doc), tcx),\n+            kind: expect_variant_kind(item_family(doc)),\n         }\n     }\n \n@@ -458,18 +455,17 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n     let (kind, variants) = match item_family(doc) {\n         Enum => {\n             (ty::AdtKind::Enum,\n-             get_enum_variants(intr, cdata, doc, tcx))\n+             get_enum_variants(intr, cdata, doc))\n         }\n         Struct(..) => {\n             let ctor_did =\n                 reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).\n                 map_or(did, |ctor_doc| translated_def_id(cdata, ctor_doc));\n             (ty::AdtKind::Struct,\n-             vec![get_struct_variant(intr, cdata, doc, ctor_did, tcx)])\n+             vec![get_struct_variant(intr, cdata, doc, ctor_did)])\n         }\n-        _ => tcx.sess.bug(\n-            &format!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n-                     item_family(doc), did))\n+        _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n+                  item_family(doc), did)\n     };\n \n     let adt = tcx.intern_adt_def(did, kind, variants);\n@@ -495,7 +491,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                     assert!(!inputs.has_escaping_regions());\n                     inputs\n                 },\n-                _ => tcx.sess.bug(\"tuple-variant ctor is not an ADT\")\n+                _ => bug!(\"tuple-variant ctor is not an ADT\")\n             };\n             for (field, &ty) in variant.fields.iter().zip(field_tys.iter()) {\n                 field.fulfill_ty(ty);\n@@ -915,7 +911,7 @@ fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n         match ch as char {\n             'i' => hir::MutImmutable,\n             'm' => hir::MutMutable,\n-            _ => panic!(\"unknown mutability character: `{}`\", ch as char),\n+            _ => bug!(\"unknown mutability character: `{}`\", ch as char),\n         }\n     }\n \n@@ -933,7 +929,7 @@ fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n                 ty::ReEmpty,\n                 get_mutability(string.as_bytes()[1]))\n         }\n-        _ => panic!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n+        _ => bug!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n     }\n }\n \n@@ -946,7 +942,7 @@ pub fn get_impl_items(cdata: Cmd, impl_id: DefIndex)\n             Some('C') | Some('c') => ty::ConstTraitItemId(def_id),\n             Some('r') | Some('p') => ty::MethodTraitItemId(def_id),\n             Some('t') => ty::TypeTraitItemId(def_id),\n-            _ => panic!(\"unknown impl item sort\"),\n+            _ => bug!(\"unknown impl item sort\"),\n         }\n     }).collect()\n }\n@@ -1012,9 +1008,9 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n             let ity = tcx.lookup_item_type(def_id).ty;\n             let fty = match ity.sty {\n                 ty::TyFnDef(_, _, fty) => fty.clone(),\n-                _ => tcx.sess.bug(&format!(\n+                _ => bug!(\n                     \"the type {:?} of the method {:?} is not a function?\",\n-                    ity, name))\n+                    ity, name)\n             };\n             let explicit_self = get_explicit_self(item_doc);\n \n@@ -1052,7 +1048,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: DefIndex)\n             Some('C') | Some('c') => ty::ConstTraitItemId(def_id),\n             Some('r') | Some('p') => ty::MethodTraitItemId(def_id),\n             Some('t') => ty::TypeTraitItemId(def_id),\n-            _ => panic!(\"unknown trait item sort\"),\n+            _ => bug!(\"unknown trait item sort\"),\n         }\n     }).collect()\n }\n@@ -1172,7 +1168,7 @@ fn struct_field_family_to_visibility(family: Family) -> hir::Visibility {\n     match family {\n       PublicField => hir::Public,\n       InheritedField => hir::Inherited,\n-      _ => panic!()\n+      _ => bug!()\n     }\n }\n \n@@ -1354,7 +1350,7 @@ pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n                 index: did.index,\n             }\n         }\n-        None => panic!(\"didn't find a crate in the cnum_map\")\n+        None => bug!(\"didn't find a crate in the cnum_map\")\n     }\n }\n \n@@ -1544,7 +1540,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n         let cnum: ast::CrateNum = cnum.parse().unwrap();\n         let cnum = match cdata.cnum_map.borrow().get(&cnum) {\n             Some(&n) => n,\n-            None => panic!(\"didn't find a crate in the cnum_map\")\n+            None => bug!(\"didn't find a crate in the cnum_map\")\n         };\n         result.push((cnum, if link == \"d\" {\n             LinkagePreference::RequireDynamic\n@@ -1772,7 +1768,7 @@ pub fn def_key(cdata: Cmd, id: DefIndex) -> hir_map::DefKey {\n             hir_map::DefKey::decode(&mut decoder).unwrap()\n         }\n         None => {\n-            panic!(\"failed to find block with tag {:?} for item with family {:?}\",\n+            bug!(\"failed to find block with tag {:?} for item with family {:?}\",\n                    tag_def_key,\n                    item_family(item_doc))\n         }"}, {"sha": "30eabb7e8f396fc0c4b5479b2cd9525a9edcdbf2", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -217,7 +217,7 @@ fn encode_symbol(ecx: &EncodeContext,\n             rbml_w.wr_tagged_str(tag_items_data_item_symbol, x);\n         }\n         None => {\n-            ecx.diag.bug(&format!(\"encode_symbol: id not found {}\", id));\n+            bug!(\"encode_symbol: id not found {}\", id);\n         }\n     }\n }"}, {"sha": "c927f53eccd6f45863c210f1a594bca53a53d460", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -33,6 +33,7 @@ extern crate flate;\n extern crate rbml;\n extern crate serialize;\n \n+#[macro_use]\n extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_front;"}, {"sha": "87e86e221f18e0f213e8f2aeb46265195e3a761a", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -300,16 +300,10 @@ impl<'a> Context<'a> {\n     }\n \n     pub fn load_library_crate(&mut self) -> Library {\n-        match self.find_library_crate() {\n-            Some(t) => t,\n-            None => {\n-                self.report_load_errs();\n-                unreachable!()\n-            }\n-        }\n+        self.find_library_crate().unwrap_or_else(|| self.report_load_errs())\n     }\n \n-    pub fn report_load_errs(&mut self) {\n+    pub fn report_load_errs(&mut self) -> ! {\n         let add = match self.root {\n             &None => String::new(),\n             &Some(ref r) => format!(\" which `{}` depends on\",\n@@ -374,6 +368,7 @@ impl<'a> Context<'a> {\n \n         err.emit();\n         self.sess.abort_if_errors();\n+        unreachable!();\n     }\n \n     fn find_library_crate(&mut self) -> Option<Library> {"}, {"sha": "28985c75a912d60aa0a3ae5869367b2a5a50f97d", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -167,7 +167,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 ty::BrFresh(id)\n             }\n             'e' => ty::BrEnv,\n-            _ => panic!(\"parse_bound_region: bad input\")\n+            _ => bug!(\"parse_bound_region: bad input\")\n         }\n     }\n \n@@ -214,7 +214,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             'e' => {\n                 ty::ReStatic\n             }\n-            _ => panic!(\"parse_region: bad input\")\n+            _ => bug!(\"parse_region: bad input\")\n         }\n     }\n \n@@ -266,7 +266,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 };\n                 region::CodeExtentData::Remainder(block_remainder)\n             }\n-            _ => panic!(\"parse_scope: bad input\")\n+            _ => bug!(\"parse_scope: bad input\")\n         })\n     }\n \n@@ -276,7 +276,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         match self.next() {\n             'n' => None,\n             's' => Some(f(self)),\n-            _ => panic!(\"parse_opt: bad input\")\n+            _ => bug!(\"parse_opt: bad input\")\n         }\n     }\n \n@@ -315,7 +315,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                     'D' => return tcx.types.i64,\n                     'f' => return tcx.types.f32,\n                     'F' => return tcx.types.f64,\n-                    _ => panic!(\"parse_ty: bad numeric type\")\n+                    _ => bug!(\"parse_ty: bad numeric type\")\n                 }\n             }\n             'c' => return tcx.types.char,\n@@ -441,7 +441,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             'e' => {\n                 return tcx.types.err;\n             }\n-            c => { panic!(\"unexpected char in type string: {}\", c);}\n+            c => { bug!(\"unexpected char in type string: {}\", c);}\n         }\n     }\n \n@@ -523,7 +523,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         let variadic = match self.next() {\n             'V' => true,\n             'N' => false,\n-            r => panic!(format!(\"bad variadic: {}\", r)),\n+            r => bug!(\"bad variadic: {}\", r),\n         };\n         let output = match self.peek() {\n             'z' => {\n@@ -553,7 +553,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 assert_eq!(self.next(), '|');\n                 ty::Predicate::ObjectSafe(def_id)\n             }\n-            c => panic!(\"Encountered invalid character in metadata: {}\", c)\n+            c => bug!(\"Encountered invalid character in metadata: {}\", c)\n         }\n     }\n \n@@ -602,7 +602,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 'R' => bounds.push(self.parse_region()),\n                 '.' => { break; }\n                 c => {\n-                    panic!(\"parse_region_param_def: bad bounds ('{}')\", c)\n+                    bug!(\"parse_region_param_def: bad bounds ('{}')\", c)\n                 }\n             }\n         }\n@@ -624,7 +624,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 let region = self.parse_region();\n                 ty::ObjectLifetimeDefault::Specific(region)\n             }\n-            _ => panic!(\"parse_object_lifetime_default: bad input\")\n+            _ => bug!(\"parse_object_lifetime_default: bad input\")\n         }\n     }\n \n@@ -640,7 +640,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 }\n                 '.' => { break; }\n                 c => {\n-                    panic!(\"parse_bounds: bad bounds ('{}')\", c)\n+                    bug!(\"parse_bounds: bad bounds ('{}')\", c)\n                 }\n             }\n         }\n@@ -669,7 +669,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                     return builtin_bounds;\n                 }\n                 c => {\n-                    panic!(\"parse_bounds: bad builtin bounds ('{}')\", c)\n+                    bug!(\"parse_bounds: bad builtin bounds ('{}')\", c)\n                 }\n             }\n         }\n@@ -683,7 +683,7 @@ fn parse_defid(buf: &[u8]) -> DefId {\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1; }\n     if colon_idx == len {\n         error!(\"didn't find ':' when parsing def id\");\n-        panic!();\n+        bug!();\n     }\n \n     let crate_part = &buf[0..colon_idx];\n@@ -693,14 +693,14 @@ fn parse_defid(buf: &[u8]) -> DefId {\n         s.parse::<usize>().ok()\n     }) {\n         Some(cn) => cn as ast::CrateNum,\n-        None => panic!(\"internal error: parse_defid: crate number expected, found {:?}\",\n+        None => bug!(\"internal error: parse_defid: crate number expected, found {:?}\",\n                        crate_part)\n     };\n     let def_num = match str::from_utf8(def_part).ok().and_then(|s| {\n         s.parse::<usize>().ok()\n     }) {\n         Some(dn) => dn,\n-        None => panic!(\"internal error: parse_defid: id expected, found {:?}\",\n+        None => bug!(\"internal error: parse_defid: id expected, found {:?}\",\n                        def_part)\n     };\n     let index = DefIndex::new(def_num);\n@@ -711,6 +711,6 @@ fn parse_unsafety(c: char) -> hir::Unsafety {\n     match c {\n         'u' => hir::Unsafety::Unsafe,\n         'n' => hir::Unsafety::Normal,\n-        _ => panic!(\"parse_unsafety: bad unsafety {}\", c)\n+        _ => bug!(\"parse_unsafety: bad unsafety {}\", c)\n     }\n }"}, {"sha": "ffaf7e2d465dba5ea73acab31336c0bc284d288c", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -146,7 +146,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n             enc_bare_fn_ty(w, cx, f);\n         }\n         ty::TyInfer(_) => {\n-            cx.diag.bug(\"cannot encode inference variable types\");\n+            bug!(\"cannot encode inference variable types\");\n         }\n         ty::TyParam(ParamTy {space, idx, name}) => {\n             write!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), name);\n@@ -285,7 +285,7 @@ pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: ty::Region) {\n         }\n         ty::ReVar(_) | ty::ReSkolemized(..) => {\n             // these should not crop up after typeck\n-            cx.diag.bug(\"cannot encode region variables\");\n+            bug!(\"cannot encode region variables\");\n         }\n     }\n }"}, {"sha": "d97245a5fc21bc6efb853c30e00198f84c58a5cd", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -33,9 +33,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             ExprKind::Literal { literal } =>\n                 Constant { span: span, ty: ty, literal: literal },\n             _ =>\n-                this.hir.span_bug(\n+                span_bug!(\n                     span,\n-                    &format!(\"expression is not a valid constant {:?}\", kind)),\n+                    \"expression is not a valid constant {:?}\",\n+                    kind),\n         }\n     }\n }"}, {"sha": "a2f7d2c9d725fdac9ae2ef1d2eb45ec5068019c4", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -38,7 +38,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let temp_lifetime = match expr.temp_lifetime {\n             Some(t) => t,\n             None => {\n-                this.hir.span_bug(expr.span, \"no temp_lifetime for expr\");\n+                span_bug!(expr.span, \"no temp_lifetime for expr\");\n             }\n         };\n         this.schedule_drop(expr.span, temp_lifetime, &temp, expr_ty);"}, {"sha": "cabf5c955466c784db03f1a1393f581886594f16", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -162,10 +162,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         unpack!(block = self.simplify_candidate(block, &mut candidate));\n \n         if !candidate.match_pairs.is_empty() {\n-            self.hir.span_bug(candidate.match_pairs[0].pattern.span,\n-                              &format!(\"match pairs {:?} remaining after simplifying \\\n-                                        irrefutable pattern\",\n-                                       candidate.match_pairs));\n+            span_bug!(candidate.match_pairs[0].pattern.span,\n+                      \"match pairs {:?} remaining after simplifying \\\n+                       irrefutable pattern\",\n+                      candidate.match_pairs);\n         }\n \n         // now apply the bindings, which will also declare the variables"}, {"sha": "f70d4321a49b7669442abb9cfc73b52a76a48efa", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -521,8 +521,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     }\n \n     fn error_simplifyable<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> ! {\n-        self.hir.span_bug(match_pair.pattern.span,\n-                          &format!(\"simplifyable pattern found: {:?}\", match_pair.pattern))\n+        span_bug!(match_pair.pattern.span,\n+                  \"simplifyable pattern found: {:?}\",\n+                  match_pair.pattern)\n     }\n }\n "}, {"sha": "51069c3885704e11320dd42e77a6a1528bcc4eff", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -218,8 +218,8 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n                    .enumerate()\n                    .all(|(index, block)| {\n                        if block.terminator.is_none() {\n-                           panic!(\"no terminator on block {:?} in fn {:?}\",\n-                               index, fn_id)\n+                           bug!(\"no terminator on block {:?} in fn {:?}\",\n+                                index, fn_id)\n                        }\n                        true\n                    }));"}, {"sha": "bda9cf058f6e966420dc7663f6d3864b4261070f", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -306,7 +306,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         debug!(\"exit_scope(extent={:?}, block={:?}, target={:?})\", extent, block, target);\n         let scope_count = 1 + self.scopes.iter().rev().position(|scope| scope.extent == extent)\n                                                       .unwrap_or_else(||{\n-            self.hir.span_bug(span, &format!(\"extent {:?} does not enclose\", extent))\n+            span_bug!(span, \"extent {:?} does not enclose\", extent)\n         });\n \n         let tmp = self.get_unit_temp();\n@@ -345,7 +345,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                            span: Span,\n                            label: Option<CodeExtent>)\n                            -> &mut LoopScope {\n-        let Builder { ref mut loop_scopes, ref mut hir, .. } = *self;\n+        let loop_scopes = &mut self.loop_scopes;\n         match label {\n             None => {\n                 // no label? return the innermost loop scope\n@@ -358,7 +358,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                            .filter(|loop_scope| loop_scope.extent == label)\n                            .next()\n             }\n-        }.unwrap_or_else(|| hir.span_bug(span, \"no enclosing loop scope found?\"))\n+        }.unwrap_or_else(|| span_bug!(span, \"no enclosing loop scope found?\"))\n     }\n \n     pub fn innermost_scope_id(&self) -> ScopeId {\n@@ -410,8 +410,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 scope.invalidate_cache()\n             }\n         }\n-        self.hir.span_bug(span,\n-                          &format!(\"extent {:?} not in scope to drop {:?}\", extent, lvalue));\n+        span_bug!(span, \"extent {:?} not in scope to drop {:?}\", extent, lvalue);\n     }\n \n     /// Schedule dropping of a not-yet-fully-initialised box.\n@@ -444,8 +443,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 scope.invalidate_cache();\n             }\n         }\n-        self.hir.span_bug(span,\n-                          &format!(\"extent {:?} not in scope to free {:?}\", extent, value));\n+        span_bug!(span, \"extent {:?} not in scope to free {:?}\", extent, value);\n     }\n \n     // Other\n@@ -531,7 +529,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let tup_ty = if let ty::TyRef(_, tyandmut) = ref_ty.sty {\n             tyandmut.ty\n         } else {\n-            self.hir.span_bug(span, &format!(\"unexpected panic_bound_check type: {:?}\", func.ty));\n+            span_bug!(span, \"unexpected panic_bound_check type: {:?}\", func.ty);\n         };\n \n         let (tuple, tuple_ref) = (self.temp(tup_ty), self.temp(ref_ty));\n@@ -566,7 +564,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let tup_ty = if let ty::TyRef(_, tyandmut) = ref_ty.sty {\n             tyandmut.ty\n         } else {\n-            self.hir.span_bug(span, &format!(\"unexpected panic type: {:?}\", func.ty));\n+            span_bug!(span, \"unexpected panic type: {:?}\", func.ty);\n         };\n \n         let (tuple, tuple_ref) = (self.temp(tup_ty), self.temp(ref_ty));"}, {"sha": "7e16883e7542c39c575c142f351482fc59b26026", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -64,11 +64,11 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n \n                     let sig = match method.ty.sty {\n                         ty::TyFnDef(_, _, fn_ty) => &fn_ty.sig,\n-                        _ => cx.tcx.sess.span_bug(self.span, \"type of method is not an fn\")\n+                        _ => span_bug!(self.span, \"type of method is not an fn\")\n                     };\n \n                     let sig = cx.tcx.no_late_bound_regions(sig).unwrap_or_else(|| {\n-                        cx.tcx.sess.span_bug(self.span, \"method call has late-bound regions\")\n+                        span_bug!(self.span, \"method call has late-bound regions\")\n                     });\n \n                     assert_eq!(sig.inputs.len(), 2);\n@@ -128,7 +128,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             hir::ExprAddrOf(mutbl, ref expr) => {\n                 let region = match expr_ty.sty {\n                     ty::TyRef(r, _) => r,\n-                    _ => cx.tcx.sess.span_bug(expr.span, \"type of & not region\"),\n+                    _ => span_bug!(expr.span, \"type of & not region\"),\n                 };\n                 ExprKind::Borrow {\n                     region: *region,\n@@ -297,16 +297,18 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 }\n                             }\n                             ref def => {\n-                                cx.tcx.sess.span_bug(\n+                                span_bug!(\n                                     self.span,\n-                                    &format!(\"unexpected def: {:?}\", def));\n+                                    \"unexpected def: {:?}\",\n+                                    def);\n                             }\n                         }\n                     }\n                     _ => {\n-                        cx.tcx.sess.span_bug(\n+                        span_bug!(\n                             self.span,\n-                            &format!(\"unexpected type for struct literal: {:?}\", expr_ty));\n+                            \"unexpected type for struct literal: {:?}\",\n+                            expr_ty);\n                     }\n                 }\n             }\n@@ -316,9 +318,9 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 let (def_id, substs) = match closure_ty.sty {\n                     ty::TyClosure(def_id, ref substs) => (def_id, substs),\n                     _ => {\n-                        cx.tcx.sess.span_bug(self.span,\n-                                             &format!(\"closure expr w/o closure type: {:?}\",\n-                                                      closure_ty));\n+                        span_bug!(self.span,\n+                                  \"closure expr w/o closure type: {:?}\",\n+                                  closure_ty);\n                     }\n                 };\n                 let upvars = cx.tcx.with_freevars(self.id, |freevars| {\n@@ -355,7 +357,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     span: c.span,\n                     value: match const_eval::eval_const_expr(cx.tcx, c) {\n                         ConstVal::Integral(ConstInt::Usize(u)) => u,\n-                        other => panic!(\"constant evaluation of repeat count yielded {:?}\", other),\n+                        other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                     },\n                 }\n             },\n@@ -383,14 +385,16 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     ty::TyStruct(adt_def, _) =>\n                         adt_def.variants[0].index_of_field_named(name.node),\n                     ref ty =>\n-                        cx.tcx.sess.span_bug(\n+                        span_bug!(\n                             self.span,\n-                            &format!(\"field of non-struct: {:?}\", ty)),\n+                            \"field of non-struct: {:?}\",\n+                            ty),\n                 };\n                 let index = index.unwrap_or_else(|| {\n-                    cx.tcx.sess.span_bug(\n+                    span_bug!(\n                         self.span,\n-                        &format!(\"no index found for field `{}`\", name.node));\n+                        \"no index found for field `{}`\",\n+                        name.node)\n                 });\n                 ExprKind::Field { lhs: source.to_ref(), name: Field::new(index) }\n             }\n@@ -474,8 +478,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                             Some(ty::FnConverging(&ty::TyS {\n                                 sty: ty::TyRef(region, mt), ..\n                             })) => (region, mt.mutbl),\n-                            _ => cx.tcx.sess.span_bug(\n-                                expr.span, \"autoderef returned bad type\")\n+                            _ => span_bug!(expr.span, \"autoderef returned bad type\")\n                         };\n \n                         expr = Expr {\n@@ -651,7 +654,7 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n                 fields: vec![],\n                 base: None\n             },\n-            ref sty => panic!(\"unexpected sty: {:?}\", sty)\n+            ref sty => bug!(\"unexpected sty: {:?}\", sty)\n         },\n         Def::Variant(enum_id, variant_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n             // A variant constructor. Should only be reached if not called in the same\n@@ -669,7 +672,7 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n                     base: None\n                 };\n             },\n-            ref sty => panic!(\"unexpected sty: {:?}\", sty)\n+            ref sty => bug!(\"unexpected sty: {:?}\", sty)\n         },\n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => {\n@@ -693,9 +696,10 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n         def @ Def::Upvar(..) => return convert_var(cx, expr, def),\n \n         def =>\n-            cx.tcx.sess.span_bug(\n+            span_bug!(\n                 expr.span,\n-                &format!(\"def `{:?}` not yet implemented\", def)),\n+                \"def `{:?}` not yet implemented\",\n+                def),\n     };\n     ExprKind::Literal {\n         literal: Literal::Item { def_id: def_id, substs: substs }\n@@ -724,12 +728,12 @@ fn convert_var<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n                     match expr.node {\n                         hir::ExprClosure(_, _, ref body) => body.id,\n                         _ => {\n-                            cx.tcx.sess.span_bug(expr.span, \"closure expr is not a closure expr\");\n+                            span_bug!(expr.span, \"closure expr is not a closure expr\");\n                         }\n                     }\n                 }\n                 _ => {\n-                    cx.tcx.sess.span_bug(expr.span, \"ast-map has garbage for closure expr\");\n+                    span_bug!(expr.span, \"ast-map has garbage for closure expr\");\n                 }\n             };\n \n@@ -809,9 +813,10 @@ fn convert_var<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n             let upvar_capture = match cx.tcx.upvar_capture(upvar_id) {\n                 Some(c) => c,\n                 None => {\n-                    cx.tcx.sess.span_bug(\n+                    span_bug!(\n                         expr.span,\n-                        &format!(\"no upvar_capture for {:?}\", upvar_id));\n+                        \"no upvar_capture for {:?}\",\n+                        upvar_id);\n                 }\n             };\n             match upvar_capture {\n@@ -834,7 +839,7 @@ fn convert_var<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n             }\n         }\n \n-        _ => cx.tcx.sess.span_bug(expr.span, \"type of & not region\"),\n+        _ => span_bug!(expr.span, \"type of & not region\"),\n     }\n }\n \n@@ -857,7 +862,7 @@ fn bin_op(op: hir::BinOp_) -> BinOp {\n         hir::BinOp_::BiNe => BinOp::Ne,\n         hir::BinOp_::BiGe => BinOp::Ge,\n         hir::BinOp_::BiGt => BinOp::Gt,\n-        _ => panic!(\"no equivalent for ast binop {:?}\", op),\n+        _ => bug!(\"no equivalent for ast binop {:?}\", op),\n     }\n }\n \n@@ -997,7 +1002,7 @@ fn loop_label<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> Cod\n     match cx.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n         Some(Def::Label(loop_id)) => cx.tcx.region_maps.node_extent(loop_id),\n         d => {\n-            cx.tcx.sess.span_bug(expr.span, &format!(\"loop scope resolved to {:?}\", d));\n+            span_bug!(expr.span, \"loop scope resolved to {:?}\", d);\n         }\n     }\n }"}, {"sha": "05448a7deab369afd61a47c1e453701277e095e4", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -24,7 +24,6 @@ use rustc::middle::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n-use syntax::codemap::Span;\n use syntax::parse::token;\n use rustc_front::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n@@ -57,7 +56,7 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n     pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n         match ConstUsize::new(value, self.tcx.sess.target.uint_type) {\n             Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val))},\n-            Err(_) => panic!(\"usize literal out of range for target\"),\n+            Err(_) => bug!(\"usize literal out of range for target\"),\n         }\n     }\n \n@@ -124,7 +123,7 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n             }\n         }\n \n-        self.tcx.sess.bug(&format!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id));\n+        bug!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id);\n     }\n \n     pub fn num_variants(&mut self, adt_def: ty::AdtDef<'tcx>) -> usize {\n@@ -141,10 +140,6 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n         self.tcx.type_needs_drop_given_env(ty, &self.infcx.parameter_environment)\n     }\n \n-    pub fn span_bug(&mut self, span: Span, message: &str) -> ! {\n-        self.tcx.sess.span_bug(span, message)\n-    }\n-\n     pub fn tcx(&self) -> &'a TyCtxt<'tcx> {\n         self.tcx\n     }"}, {"sha": "8ec8cd4bf814c28ce756cd70dcb6293d5f07b1fb", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -97,21 +97,23 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                                     Ok(pat) =>\n                                         return self.to_pattern(&pat),\n                                     Err(_) =>\n-                                        self.cx.tcx.sess.span_bug(\n+                                        span_bug!(\n                                             pat.span, \"illegal constant\"),\n                                 }\n                             }\n                             None => {\n-                                self.cx.tcx.sess.span_bug(\n+                                span_bug!(\n                                     pat.span,\n-                                    &format!(\"cannot eval constant: {:?}\", def_id))\n+                                    \"cannot eval constant: {:?}\",\n+                                    def_id)\n                             }\n                         }\n                     }\n                     _ =>\n-                        self.cx.tcx.sess.span_bug(\n+                        span_bug!(\n                             pat.span,\n-                            &format!(\"def not a constant: {:?}\", def)),\n+                            \"def not a constant: {:?}\",\n+                            def),\n                 }\n             }\n \n@@ -138,9 +140,10 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                         self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n \n                     ref sty =>\n-                        self.cx.tcx.sess.span_bug(\n+                        span_bug!(\n                             pat.span,\n-                            &format!(\"unexpanded type for vector pattern: {:?}\", sty)),\n+                            \"unexpanded type for vector pattern: {:?}\",\n+                            sty),\n                 }\n             }\n \n@@ -186,7 +189,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                     if let ty::TyRef(_, mt) = ty.sty {\n                         ty = mt.ty;\n                     } else {\n-                        unreachable!(\"`ref {}` has wrong type {}\", ident.node, ty);\n+                        bug!(\"`ref {}` has wrong type {}\", ident.node, ty);\n                     }\n                 }\n \n@@ -222,7 +225,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 let adt_def = match pat_ty.sty {\n                     ty::TyStruct(adt_def, _) | ty::TyEnum(adt_def, _) => adt_def,\n                     _ => {\n-                        self.cx.tcx.sess.span_bug(\n+                        span_bug!(\n                             pat.span,\n                             \"struct pattern not applied to struct or enum\");\n                     }\n@@ -236,9 +239,10 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                           .map(|field| {\n                               let index = variant_def.index_of_field_named(field.node.name);\n                               let index = index.unwrap_or_else(|| {\n-                                  self.cx.tcx.sess.span_bug(\n+                                  span_bug!(\n                                       pat.span,\n-                                      &format!(\"no field with name {:?}\", field.node.name));\n+                                      \"no field with name {:?}\",\n+                                      field.node.name);\n                               });\n                               FieldPattern {\n                                   field: Field::new(index),\n@@ -251,7 +255,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n             }\n \n             PatKind::QPath(..) => {\n-                self.cx.tcx.sess.span_bug(pat.span, \"unexpanded macro or bad constant etc\");\n+                span_bug!(pat.span, \"unexpanded macro or bad constant etc\");\n             }\n         };\n \n@@ -298,7 +302,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n             }\n \n             _ => {\n-                self.cx.tcx.sess.span_bug(span, \"unexpanded macro or bad constant etc\");\n+                span_bug!(span, \"unexpanded macro or bad constant etc\");\n             }\n         }\n     }\n@@ -327,8 +331,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n             }\n \n             _ => {\n-                self.cx.tcx.sess.span_bug(pat.span,\n-                                          &format!(\"inappropriate def for pattern: {:?}\", def));\n+                span_bug!(pat.span, \"inappropriate def for pattern: {:?}\", def);\n             }\n         }\n     }"}, {"sha": "e7c0a3d9cae018d8bbd589c1dcfaf729d65843dc", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -27,6 +27,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #[macro_use] extern crate log;\n extern crate graphviz as dot;\n+#[macro_use]\n extern crate rustc;\n extern crate rustc_data_structures;\n extern crate rustc_front;"}, {"sha": "9ec88c1b59a69dfe066654b7e21b7cdf009119b2", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -165,8 +165,7 @@ fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n     let fn_sig = match cx.tcx().tables.borrow().liberated_fn_sigs.get(&fn_id) {\n         Some(f) => f.clone(),\n         None => {\n-            cx.tcx().sess.span_bug(span,\n-                                   &format!(\"no liberated fn sig for {:?}\", fn_id));\n+            span_bug!(span, \"no liberated fn sig for {:?}\", fn_id);\n         }\n     };\n "}, {"sha": "97a4c14863d59c083b54ea56fce231dea707ede8", "filename": "src/librustc_passes/const_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_passes%2Fconst_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_passes%2Fconst_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconst_fn.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -44,13 +44,13 @@ impl<'a, 'v> Visitor<'v> for CheckBlock<'a> {\n             visit::walk_expr(self, e);\n         }\n     }\n-    fn visit_item(&mut self, _i: &'v ast::Item) { panic!(\"should be handled in CheckConstFn\") }\n+    fn visit_item(&mut self, _i: &'v ast::Item) { bug!(\"should be handled in CheckConstFn\") }\n     fn visit_fn(&mut self,\n                 _fk: FnKind<'v>,\n                 _fd: &'v ast::FnDecl,\n                 _b: &'v ast::Block,\n                 _s: Span,\n-                _fn_id: ast::NodeId) { panic!(\"should be handled in CheckConstFn\") }\n+                _fn_id: ast::NodeId) { bug!(\"should be handled in CheckConstFn\") }\n }\n \n fn check_block(sess: &Session, b: &ast::Block, kind: &'static str) {\n@@ -67,7 +67,7 @@ fn check_block(sess: &Session, b: &ast::Block, kind: &'static str) {\n             }\n             ast::StmtKind::Expr(ref expr, _) => expr.span,\n             ast::StmtKind::Semi(ref semi, _) => semi.span,\n-            ast::StmtKind::Mac(..) => unreachable!(),\n+            ast::StmtKind::Mac(..) => bug!(),\n         };\n         span_err!(sess, span, E0016,\n                   \"blocks in {}s are limited to items and tail expressions\", kind);"}, {"sha": "a7f0088873506ecc9c154f755cdf6961f4fede86", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -229,7 +229,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             Mode::Const => \"constant\",\n             Mode::ConstFn => \"constant function\",\n             Mode::StaticMut | Mode::Static => \"static\",\n-            Mode::Var => unreachable!(),\n+            Mode::Var => bug!(),\n         }\n     }\n \n@@ -400,7 +400,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 // The count is checked elsewhere (typeck).\n                 let count = match node_ty.sty {\n                     ty::TyArray(_, n) => n,\n-                    _ => unreachable!()\n+                    _ => bug!()\n                 };\n                 // [element; 0] is always zero-sized.\n                 if count == 0 {\n@@ -570,7 +570,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         hir::ExprCast(ref from, _) => {\n             debug!(\"Checking const cast(id={})\", from.id);\n             match v.tcx.cast_kinds.borrow().get(&from.id) {\n-                None => v.tcx.sess.span_bug(e.span, \"no kind for cast\"),\n+                None => span_bug!(e.span, \"no kind for cast\"),\n                 Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n                     v.add_qualif(ConstQualif::NOT_CONST);\n                     if v.mode != Mode::Var {"}, {"sha": "44bcdcdb364953a32227322f0b77ae9d0fb605df", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -28,7 +28,7 @@\n #![feature(rustc_private)]\n \n extern crate core;\n-extern crate rustc;\n+#[macro_use] extern crate rustc;\n extern crate rustc_front;\n extern crate rustc_const_eval;\n "}, {"sha": "2230283c9777ee529a5d6e2547bd3d7e86b3e340", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -218,9 +218,9 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n             // borrow fall out of scope, so that we can reborrow farther down.\n             maybe_expr = (*get_expr).clone();\n         } else {\n-            self.sess.span_bug(variant.span,\n-                               \"`check_static_recursion` attempted to visit \\\n-                                variant with unknown discriminant\")\n+            span_bug!(variant.span,\n+                      \"`check_static_recursion` attempted to visit \\\n+                      variant with unknown discriminant\")\n         }\n         // If `maybe_expr` is `None`, that's because no discriminant is\n         // specified that affects this variant. Thus, no risk of recursion.\n@@ -254,10 +254,10 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                                     self.visit_impl_item(item),\n                                 ast_map::NodeForeignItem(_) => {},\n                                 _ => {\n-                                    self.sess.span_bug(\n+                                    span_bug!(\n                                         e.span,\n-                                        &format!(\"expected item, found {}\",\n-                                                 self.ast_map.node_to_string(node_id)));\n+                                        \"expected item, found {}\",\n+                                        self.ast_map.node_to_string(node_id));\n                                 }\n                             }\n                         }\n@@ -277,9 +277,9 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                                 let variant = self.ast_map.expect_variant(variant_id);\n                                 self.visit_variant(variant, generics, enum_id);\n                             } else {\n-                                self.sess.span_bug(e.span,\n-                                                   \"`check_static_recursion` found \\\n-                                                    non-enum in Def::Variant\");\n+                                span_bug!(e.span,\n+                                          \"`check_static_recursion` found \\\n+                                           non-enum in Def::Variant\");\n                             }\n                         }\n                     }"}, {"sha": "80df21e85f6f583cd56b9c9ff5626b79db9310cf", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -24,7 +24,7 @@\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n \n-extern crate rustc;\n+#[macro_use] extern crate rustc;\n extern crate rustc_front;\n \n use std::cmp;"}, {"sha": "fe44743ede3bd322a833ad72a394e92d6bf94385", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -507,7 +507,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n             Def::Label(..) |\n             Def::SelfTy(..) |\n             Def::Err => {\n-                panic!(\"didn't expect `{:?}`\", def);\n+                bug!(\"didn't expect `{:?}`\", def);\n             }\n         }\n     }"}, {"sha": "e5576b00a76d5c44c228c14c51e3683dd8429de4", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -32,6 +32,7 @@ extern crate arena;\n #[no_link]\n extern crate rustc_bitflags;\n extern crate rustc_front;\n+#[macro_use]\n extern crate rustc;\n \n use self::PatternBindingMode::*;\n@@ -2375,11 +2376,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // The below shouldn't happen because all\n                         // qualified paths should be in PatKind::QPath.\n                         TypecheckRequired =>\n-                            self.session.span_bug(path.span,\n-                                                  \"resolve_possibly_assoc_item claimed that a path \\\n-                                                   in PatKind::Path or PatKind::TupleStruct \\\n-                                                   requires typecheck to resolve, but qualified \\\n-                                                   paths should be PatKind::QPath\"),\n+                            span_bug!(path.span,\n+                                      \"resolve_possibly_assoc_item claimed that a path \\\n+                                       in PatKind::Path or PatKind::TupleStruct \\\n+                                       requires typecheck to resolve, but qualified \\\n+                                       paths should be PatKind::QPath\"),\n                         ResolveAttempt(resolution) => resolution,\n                     };\n                     if let Some(path_res) = resolution {\n@@ -2668,7 +2669,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut def = local_def.def;\n         match def {\n             Def::Upvar(..) => {\n-                self.session.span_bug(span, &format!(\"unexpected {:?} in bindings\", def))\n+                span_bug!(span, \"unexpected {:?} in bindings\", def)\n             }\n             Def::Local(_, node_id) => {\n                 for rib in ribs {\n@@ -3189,7 +3190,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         })\n                     }\n                     Some(_) => {\n-                        self.session.span_bug(expr.span, \"label wasn't mapped to a label def!\")\n+                        span_bug!(expr.span, \"label wasn't mapped to a label def!\")\n                     }\n                 }\n             }\n@@ -3346,7 +3347,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             paths.push(segm);\n                             paths\n                         }\n-                        _ => unreachable!(),\n+                        _ => bug!(),\n                     };\n \n                     if !in_module_is_extern || name_binding.is_public() {\n@@ -3368,10 +3369,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         debug!(\"(recording def) recording {:?} for {}\", resolution, node_id);\n         if let Some(prev_res) = self.def_map.borrow_mut().insert(node_id, resolution) {\n             let span = self.ast_map.opt_span(node_id).unwrap_or(codemap::DUMMY_SP);\n-            self.session.span_bug(span,\n-                                  &format!(\"path resolved multiple times ({:?} before, {:?} now)\",\n-                                           prev_res,\n-                                           resolution));\n+            span_bug!(span,\n+                      \"path resolved multiple times ({:?} before, {:?} now)\",\n+                      prev_res,\n+                      resolution);\n         }\n     }\n "}, {"sha": "649c8387eb37c48595a23748d6b95d820eeddd08", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -20,17 +20,6 @@ use rustc::ty;\n use syntax::ast::{CrateNum, NodeId};\n use syntax::codemap::Span;\n \n-#[macro_export]\n-macro_rules! down_cast_data {\n-    ($id:ident, $kind:ident, $this:ident, $sp:expr) => {\n-        let $id = if let super::Data::$kind(data) = $id {\n-            data\n-        } else {\n-            $this.sess.span_bug($sp, &format!(\"unexpected data kind: {:?}\", $id));\n-        }\n-    };\n-}\n-\n pub struct CrateData {\n     pub name: String,\n     pub number: u32,"}, {"sha": "35ca2a9b0149a5c80acb5df9795f604924b75e08", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -51,11 +51,11 @@ use super::span_utils::SpanUtils;\n use super::recorder;\n \n macro_rules! down_cast_data {\n-    ($id:ident, $kind:ident, $this:ident, $sp:expr) => {\n+    ($id:ident, $kind:ident, $sp:expr) => {\n         let $id = if let super::Data::$kind(data) = $id {\n             data\n         } else {\n-            $this.sess.span_bug($sp, &format!(\"unexpected data kind: {:?}\", $id));\n+            span_bug!($sp, \"unexpected data kind: {:?}\", $id);\n         }\n     };\n }\n@@ -271,8 +271,7 @@ where D: Dump\n     // looks up anything, not just a type\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n-            self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                   ref_id));\n+            bug!(\"def_map has no key for {} in lookup_type_ref\", ref_id);\n         }\n         let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n@@ -294,9 +293,9 @@ where D: Dump\n \n         let def_map = self.tcx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n-            self.sess.span_bug(span,\n-                               &format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                        ref_id));\n+            span_bug!(span,\n+                      \"def_map has no key for {} in lookup_def_kind\",\n+                      ref_id);\n         }\n         let def = def_map.get(&ref_id).unwrap().full_def();\n         match def {\n@@ -347,8 +346,9 @@ where D: Dump\n             Def::Method(..) |\n             Def::PrimTy(_) |\n             Def::Err => {\n-                self.sess.span_bug(span,\n-                                   &format!(\"process_def_kind for unexpected item: {:?}\", def));\n+               span_bug!(span,\n+                         \"process_def_kind for unexpected item: {:?}\",\n+                         def);\n             }\n         }\n     }\n@@ -480,7 +480,7 @@ where D: Dump\n                   ty_params: &ast::Generics,\n                   body: &ast::Block) {\n         if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(fn_data, FunctionData, self, item.span);\n+            down_cast_data!(fn_data, FunctionData, item.span);\n             if !self.span.filter_generated(Some(fn_data.span), item.span) {\n                 self.dumper.function(item.span, fn_data.clone().normalize(&self.tcx));\n             }\n@@ -502,7 +502,7 @@ where D: Dump\n \n     fn process_static_or_const_item(&mut self, item: &ast::Item, typ: &ast::Ty, expr: &ast::Expr) {\n         if let Some(var_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(var_data, VariableData, self, item.span);\n+            down_cast_data!(var_data, VariableData, item.span);\n             if !self.span.filter_generated(Some(var_data.span), item.span) {\n                 let mut var_data = var_data;\n                 var_data.scope = normalize_node_id(&self.tcx, var_data.scope) as u32;\n@@ -578,7 +578,7 @@ where D: Dump\n             None => return,\n             Some(data) => data,\n         };\n-        down_cast_data!(enum_data, EnumData, self, item.span);\n+        down_cast_data!(enum_data, EnumData, item.span);\n         let normalized = enum_data.clone().normalize(&self.tcx);\n         if !self.span.filter_generated(Some(normalized.span), item.span) {\n             self.dumper.enum_data(item.span, normalized);\n@@ -638,7 +638,7 @@ where D: Dump\n                     impl_items: &[ast::ImplItem]) {\n         let mut has_self_ref = false;\n         if let Some(impl_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(impl_data, ImplData, self, item.span);\n+            down_cast_data!(impl_data, ImplData, item.span);\n             if let Some(ref self_ref) = impl_data.self_ref {\n                 has_self_ref = true;\n                 if !self.span.filter_generated(Some(self_ref.span), item.span) {\n@@ -734,7 +734,7 @@ where D: Dump\n     // `item` is the module in question, represented as an item.\n     fn process_mod(&mut self, item: &ast::Item) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(mod_data, ModData, self, item.span);\n+            down_cast_data!(mod_data, ModData, item.span);\n             if !self.span.filter_generated(Some(mod_data.span), item.span) {\n                 self.dumper.mod_data(mod_data.normalize(&self.tcx));\n             }\n@@ -750,10 +750,9 @@ where D: Dump\n         let path_data = match path_data {\n             Some(pd) => pd,\n             None => {\n-                self.tcx.sess.span_bug(path.span,\n-                                       &format!(\"Unexpected def kind while looking up path in \\\n-                                                 `{}`\",\n-                                                self.span.snippet(path.span)))\n+                span_bug!(path.span,\n+                          \"Unexpected def kind while looking up path in `{}`\",\n+                          self.span.snippet(path.span))\n             }\n         };\n \n@@ -807,8 +806,7 @@ where D: Dump\n                 }\n             }\n             _ => {\n-                self.sess.span_bug(path.span,\n-                                   &format!(\"Unexpected data: {:?}\", path_data));\n+               span_bug!(path.span, \"Unexpected data: {:?}\", path_data);\n             }\n         }\n \n@@ -844,7 +842,7 @@ where D: Dump\n         self.write_sub_paths_truncated(path, false);\n \n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n-            down_cast_data!(struct_lit_data, TypeRefData, self, ex.span);\n+            down_cast_data!(struct_lit_data, TypeRefData, ex.span);\n             if !self.span.filter_generated(Some(struct_lit_data.span), ex.span) {\n                 self.dumper.type_ref(ex.span, struct_lit_data.normalize(&self.tcx));\n             }\n@@ -869,7 +867,7 @@ where D: Dump\n \n     fn process_method_call(&mut self, ex: &ast::Expr, args: &Vec<P<ast::Expr>>) {\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n-            down_cast_data!(mcd, MethodCallData, self, ex.span);\n+            down_cast_data!(mcd, MethodCallData, ex.span);\n             if !self.span.filter_generated(Some(mcd.span), ex.span) {\n                 self.dumper.method_call(ex.span, mcd.normalize(&self.tcx));\n             }\n@@ -1234,7 +1232,7 @@ impl<'l, 'tcx, 'v, D: Dump + 'l> Visitor<'v> for DumpVisitor<'l, 'tcx, D> {\n                 self.visit_expr(&sub_ex);\n \n                 if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n-                    down_cast_data!(field_data, VariableRefData, self, ex.span);\n+                    down_cast_data!(field_data, VariableRefData, ex.span);\n                     if !self.span.filter_generated(Some(field_data.span), ex.span) {\n                         self.dumper.variable_ref(ex.span, field_data.normalize(&self.tcx));\n                     }\n@@ -1258,9 +1256,9 @@ impl<'l, 'tcx, 'v, D: Dump + 'l> Visitor<'v> for DumpVisitor<'l, 'tcx, D> {\n                         }\n                     }\n                     ty::TyTuple(_) => {}\n-                    _ => self.sess.span_bug(ex.span,\n-                                            &format!(\"Expected struct or tuple type, found {:?}\",\n-                                                     ty)),\n+                    _ => span_bug!(ex.span,\n+                                   \"Expected struct or tuple type, found {:?}\",\n+                                   ty),\n                 }\n             }\n             ast::ExprKind::Closure(_, ref decl, ref body) => {\n@@ -1302,7 +1300,7 @@ impl<'l, 'tcx, 'v, D: Dump + 'l> Visitor<'v> for DumpVisitor<'l, 'tcx, D> {\n \n     fn visit_mac(&mut self, mac: &ast::Mac) {\n         // These shouldn't exist in the AST at this point, log a span bug.\n-        self.sess.span_bug(mac.span, \"macro invocation should have been expanded out of AST\");\n+        span_bug!(mac.span, \"macro invocation should have been expanded out of AST\");\n     }\n \n     fn visit_pat(&mut self, p: &ast::Pat) {\n@@ -1325,8 +1323,7 @@ impl<'l, 'tcx, 'v, D: Dump + 'l> Visitor<'v> for DumpVisitor<'l, 'tcx, D> {\n         for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n             let def_map = self.tcx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n-                self.sess.span_bug(p.span,\n-                                   &format!(\"def_map has no key for {} in visit_arm\", id));\n+                span_bug!(p.span, \"def_map has no key for {} in visit_arm\", id);\n             }\n             let def = def_map.get(&id).unwrap().full_def();\n             match def {"}, {"sha": "36b94731e45ab1b7feef21d945a8ef3eec21ef13", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -22,7 +22,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n \n-extern crate rustc;\n+#[macro_use] extern crate rustc;\n extern crate rustc_front;\n \n #[macro_use] extern crate log;\n@@ -47,7 +47,6 @@ use syntax::visit::{self, Visitor};\n use syntax::print::pprust::ty_to_string;\n \n mod csv_dumper;\n-#[macro_use]\n mod data;\n mod dump;\n mod dump_visitor;\n@@ -240,7 +239,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             _ => {\n                 // FIXME\n-                unimplemented!();\n+                bug!();\n             }\n         }\n     }\n@@ -292,21 +291,19 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             result\n                         }\n                         _ => {\n-                            self.tcx.sess.span_bug(span,\n-                                                   &format!(\"Container {:?} for method {} not \\\n-                                                             an impl?\",\n-                                                            impl_id,\n-                                                            id));\n+                            span_bug!(span,\n+                                      \"Container {:?} for method {} not an impl?\",\n+                                      impl_id,\n+                                      id);\n                         }\n                     }\n                 }\n                 r => {\n-                    self.tcx.sess.span_bug(span,\n-                                           &format!(\"Container {:?} for method {} is not a node \\\n-                                                     item {:?}\",\n-                                                    impl_id,\n-                                                    id,\n-                                                    r));\n+                    span_bug!(span,\n+                              \"Container {:?} for method {} is not a node item {:?}\",\n+                              impl_id,\n+                              id,\n+                              r);\n                 }\n             },\n             None => match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n@@ -316,18 +313,17 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             format!(\"::{}\", self.tcx.item_path_str(def_id))\n                         }\n                         r => {\n-                            self.tcx.sess.span_bug(span,\n-                                                   &format!(\"Could not find container {:?} for \\\n-                                                             method {}, got {:?}\",\n-                                                            def_id,\n-                                                            id,\n-                                                            r));\n+                            span_bug!(span,\n+                                      \"Could not find container {:?} for \\\n+                                       method {}, got {:?}\",\n+                                      def_id,\n+                                      id,\n+                                      r);\n                         }\n                     }\n                 }\n                 None => {\n-                    self.tcx.sess.span_bug(span,\n-                                           &format!(\"Could not find container for method {}\", id));\n+                    span_bug!(span, \"Could not find container for method {}\", id);\n                 }\n             },\n         };\n@@ -443,16 +439,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             _ => {\n                 // FIXME\n-                unimplemented!();\n+                bug!();\n             }\n         }\n     }\n \n     pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Data> {\n         let def_map = self.tcx.def_map.borrow();\n         if !def_map.contains_key(&id) {\n-            self.tcx.sess.span_bug(path.span,\n-                                   &format!(\"def_map has no key for {} in visit_expr\", id));\n+            span_bug!(path.span, \"def_map has no key for {} in visit_expr\", id);\n         }\n         let def = def_map.get(&id).unwrap().full_def();\n         let sub_span = self.span_utils.span_for_last_ident(path.span);\n@@ -618,13 +613,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_data_for_id(&self, _id: &NodeId) -> Data {\n         // FIXME\n-        unimplemented!();\n+        bug!();\n     }\n \n     fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n-            self.tcx.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                       ref_id));\n+            bug!(\"def_map has no key for {} in lookup_type_ref\", ref_id);\n         }\n         let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {"}, {"sha": "f410d428177cd6a920706d9d84d3970183bf60ec", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -223,12 +223,12 @@ impl<'a> SpanUtils<'a> {\n         }\n         if bracket_count != 0 {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n-            self.sess.span_bug(span,\n-                               &format!(\"Mis-counted brackets when breaking path? Parsing '{}' \\\n-                                         in {}, line {}\",\n-                                        self.snippet(span),\n-                                        loc.file.name,\n-                                        loc.line));\n+            span_bug!(span,\n+                      \"Mis-counted brackets when breaking path? Parsing '{}' \\\n+                       in {}, line {}\",\n+                      self.snippet(span),\n+                      loc.file.name,\n+                      loc.line);\n         }\n         if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n@@ -256,12 +256,12 @@ impl<'a> SpanUtils<'a> {\n                         return vec!();\n                     }\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n-                    self.sess.span_bug(span,\n-                                       &format!(\"Mis-counted brackets when breaking path? \\\n-                                                 Parsing '{}' in {}, line {}\",\n-                                                self.snippet(span),\n-                                                loc.file.name,\n-                                                loc.line));\n+                    span_bug!(span,\n+                              \"Mis-counted brackets when breaking path? \\\n+                               Parsing '{}' in {}, line {}\",\n+                              self.snippet(span),\n+                              loc.file.name,\n+                              loc.line);\n                 }\n                 return result\n             }\n@@ -374,7 +374,7 @@ impl<'a> SpanUtils<'a> {\n               loc.line);\n         self.err_count.set(self.err_count.get() + 1);\n         if self.err_count.get() > 1000 {\n-            self.sess.bug(\"span errors reached 1000, giving up\");\n+            bug!(\"span errors reached 1000, giving up\");\n         }\n     }\n "}, {"sha": "b27929c80c2d8a9a789d66d9130294f5a6b4ad3f", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -242,7 +242,7 @@ impl<'a> ConstantExpr<'a> {\n     fn eq(self, other: ConstantExpr<'a>, tcx: &TyCtxt) -> bool {\n         match compare_lit_exprs(tcx, self.0, other.0) {\n             Some(result) => result == Ordering::Equal,\n-            None => panic!(\"compare_list_exprs: type mismatch\"),\n+            None => bug!(\"compare_list_exprs: type mismatch\"),\n         }\n     }\n }\n@@ -828,7 +828,7 @@ impl FailureHandler {\n     fn handle_fail(&self, bcx: Block) {\n         match *self {\n             Infallible =>\n-                panic!(\"attempted to panic in a non-panicking panic handler!\"),\n+                bug!(\"attempted to panic in a non-panicking panic handler!\"),\n             JumpToBasicBlock(basic_block) =>\n                 Br(bcx, basic_block, DebugLoc::None),\n             Unreachable =>\n@@ -939,11 +939,11 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n                     compare_str(cx, lhs_data, lhs_len, rhs_data, rhs_len, rhs_t, debug_loc)\n                 },\n-                _ => cx.sess().bug(\"only byte strings supported in compare_values\"),\n+                _ => bug!(\"only byte strings supported in compare_values\"),\n             },\n-            _ => cx.sess().bug(\"only string and byte strings supported in compare_values\"),\n+            _ => bug!(\"only string and byte strings supported in compare_values\"),\n         },\n-        _ => cx.sess().bug(\"only scalars, byte strings, and strings supported in compare_values\"),\n+        _ => bug!(\"only scalars, byte strings, and strings supported in compare_values\"),\n     }\n }\n \n@@ -986,7 +986,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         Lvalue::new_with_hint(\"_match::insert_lllocals (match_input)\",\n                                               bcx, binding_info.id, hint_kind)\n                     }\n-                    _ => unreachable!(),\n+                    _ => bug!(),\n                 };\n                 let datum = Datum::new(llval, binding_info.ty, lvalue);\n                 call_lifetime_start(bcx, llbinding);\n@@ -1317,7 +1317,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                             bcx = r.bcx;\n                         }\n                         _ => {\n-                            bcx.sess().bug(\n+                            bug!(\n                                 \"in compile_submatch, expected \\\n                                  opt.trans() to return a SingleResult\")\n                         }"}, {"sha": "6edc26c70097ac4c470ce42c475350ff1de48025", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -218,7 +218,7 @@ impl FnType {\n             Rust | RustCall => llvm::CCallConv,\n \n             // It's the ABI's job to select this, not us.\n-            System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n+            System => bug!(\"system abi should be selected elsewhere\"),\n \n             Stdcall => llvm::X86StdcallCallConv,\n             Fastcall => llvm::X86FastcallCallConv,\n@@ -241,8 +241,8 @@ impl FnType {\n                     &tupled_arguments[..]\n                 }\n                 _ => {\n-                    unreachable!(\"argument to function with \\\"rust-call\\\" ABI \\\n-                                  is not a tuple\");\n+                    bug!(\"argument to function with \\\"rust-call\\\" ABI \\\n+                          is not a tuple\");\n                 }\n             }\n         } else {"}, {"sha": "8922aa061820f3ac8bd61e7abd07f03a194de735", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -302,9 +302,8 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == Disr::from(i)) {\n-                cx.sess().bug(&format!(\"non-C-like enum {} with specified \\\n-                                        discriminants\",\n-                                       cx.tcx().item_path_str(def.did)));\n+                bug!(\"non-C-like enum {} with specified discriminants\",\n+                     cx.tcx().item_path_str(def.did));\n             }\n \n             if cases.len() == 1 {\n@@ -430,7 +429,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             General(ity, fields, dtor_to_init_u8(dtor))\n         }\n-        _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\", t))\n+        _ => bug!(\"adt::represent_type called on non-ADT type: {}\", t)\n     }\n }\n \n@@ -615,7 +614,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n     match hint {\n         attr::ReprInt(span, ity) => {\n             if !bounds_usable(cx, ity, bounds) {\n-                cx.sess().span_bug(span, \"representation hint insufficient for discriminant range\")\n+                span_bug!(span, \"representation hint insufficient for discriminant range\")\n             }\n             return ity;\n         }\n@@ -632,10 +631,10 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             attempts = choose_shortest;\n         },\n         attr::ReprPacked => {\n-            cx.tcx().sess.bug(\"range_to_inttype: found ReprPacked on an enum\");\n+            bug!(\"range_to_inttype: found ReprPacked on an enum\");\n         }\n         attr::ReprSimd => {\n-            cx.tcx().sess.bug(\"range_to_inttype: found ReprSimd on an enum\");\n+            bug!(\"range_to_inttype: found ReprSimd on an enum\");\n         }\n     }\n     for &ity in attempts {\n@@ -835,7 +834,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  Type::array(&Type::i64(cx), align_units),\n                 a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(cx), a / 4),\n                                                               align_units),\n-                _ => panic!(\"unsupported enum alignment: {}\", align)\n+                _ => bug!(\"unsupported enum alignment: {}\", align)\n             };\n             assert_eq!(machine::llalign_of_min(cx, fill_ty), align);\n             assert_eq!(padded_discr_size % discr_size, 0); // Ensure discr_ty can fill pad evenly\n@@ -984,7 +983,7 @@ pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n             C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true)\n         }\n         Univariant(..) => {\n-            bcx.ccx().sess().bug(\"no cases for univariants or structs\")\n+            bug!(\"no cases for univariants or structs\")\n         }\n         RawNullablePointer { .. } |\n         StructWrappedNullablePointer { .. } => {\n@@ -1088,7 +1087,7 @@ pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     // someday), it will need to return a possibly-new bcx as well.\n     match *r {\n         CEnum(..) => {\n-            bcx.ccx().sess().bug(\"element access in C-like enum\")\n+            bug!(\"element access in C-like enum\")\n         }\n         Univariant(ref st, _dtor) => {\n             assert_eq!(discr, Disr(0));\n@@ -1279,7 +1278,7 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n             bcx_next\n         }\n-        _ => unreachable!()\n+        _ => bug!()\n     }\n }\n \n@@ -1319,7 +1318,7 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n             datum::DatumBlock::new(bcx, expr_datum)\n         }\n-        _ => bcx.ccx().sess().bug(\"tried to get drop flag of non-droppable type\")\n+        _ => bug!(\"tried to get drop flag of non-droppable type\")\n     }\n }\n \n@@ -1478,7 +1477,7 @@ pub fn const_get_discrim(r: &Repr, val: ValueRef) -> Disr {\n         }\n         Univariant(..) => Disr(0),\n         RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n-            unreachable!(\"const discrim access of non c-like enum\")\n+            bug!(\"const discrim access of non c-like enum\")\n         }\n     }\n }\n@@ -1488,10 +1487,10 @@ pub fn const_get_discrim(r: &Repr, val: ValueRef) -> Disr {\n ///\n /// (Not to be confused with `common::const_get_elt`, which operates on\n /// raw LLVM-level structs and arrays.)\n-pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n-                       _discr: Disr, ix: usize) -> ValueRef {\n+pub fn const_get_field(r: &Repr, val: ValueRef, _discr: Disr,\n+                       ix: usize) -> ValueRef {\n     match *r {\n-        CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n+        CEnum(..) => bug!(\"element access in C-like enum const\"),\n         Univariant(..) => const_struct_field(val, ix),\n         General(..) => const_struct_field(val, ix + 1),\n         RawNullablePointer { .. } => {"}, {"sha": "bd98b3950d44c634f1d019724666004be0aa8809", "filename": "src/librustc_trans/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_dep_graph.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -221,7 +221,7 @@ fn dump_graph(tcx: &TyCtxt) {\n             // Expect one of: \"-> target\", \"source -> target\", or \"source ->\".\n             let parts: Vec<_> = string.split(\"->\").collect();\n             if parts.len() > 2 {\n-                panic!(\"Invalid RUST_DEP_GRAPH_FILTER: expected '[source] -> [target]'\");\n+                bug!(\"Invalid RUST_DEP_GRAPH_FILTER: expected '[source] -> [target]'\");\n             }\n             let sources = node_set(&query, &parts[0]);\n             let targets = node_set(&query, &parts[1]);"}, {"sha": "7aef1d912ecceaabce11a024982902b8aa465674", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -187,8 +187,8 @@ pub fn link_binary(sess: &Session,\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n         if invalid_output_for_target(sess, crate_type) {\n-            sess.bug(&format!(\"invalid output type `{:?}` for target os `{}`\",\n-                             crate_type, sess.opts.target_triple));\n+           bug!(\"invalid output type `{:?}` for target os `{}`\",\n+                crate_type, sess.opts.target_triple);\n         }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs,\n                                           crate_name);\n@@ -282,7 +282,7 @@ pub fn each_linked_rlib(sess: &Session,\n     let fmts = fmts.get(&config::CrateTypeExecutable).or_else(|| {\n         fmts.get(&config::CrateTypeStaticlib)\n     }).unwrap_or_else(|| {\n-        sess.bug(\"could not find formats for rlibs\")\n+        bug!(\"could not find formats for rlibs\")\n     });\n     for (cnum, path) in crates {\n         match fmts[cnum as usize - 1] {\n@@ -895,7 +895,7 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n         match kind {\n             NativeLibraryKind::NativeUnknown => cmd.link_dylib(l),\n             NativeLibraryKind::NativeFramework => cmd.link_framework(l),\n-            NativeLibraryKind::NativeStatic => unreachable!(),\n+            NativeLibraryKind::NativeStatic => bug!(),\n         }\n     }\n }\n@@ -1081,7 +1081,7 @@ fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session) {\n                 NativeLibraryKind::NativeUnknown => cmd.link_dylib(lib),\n                 NativeLibraryKind::NativeFramework => cmd.link_framework(lib),\n                 NativeLibraryKind::NativeStatic => {\n-                    sess.bug(\"statics shouldn't be propagated\");\n+                    bug!(\"statics shouldn't be propagated\");\n                 }\n             }\n         }"}, {"sha": "c02a482f81275c2248e3a796608cf7e06e1fc078", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -271,10 +271,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n     }\n \n     fn framework_path(&mut self, _path: &Path) {\n-        panic!(\"frameworks are not supported on windows\")\n+        bug!(\"frameworks are not supported on windows\")\n     }\n     fn link_framework(&mut self, _framework: &str) {\n-        panic!(\"frameworks are not supported on windows\")\n+        bug!(\"frameworks are not supported on windows\")\n     }\n \n     fn link_whole_staticlib(&mut self, lib: &str, _search_path: &[PathBuf]) {"}, {"sha": "a458307da407048b5ac3e26ed0a1c4dd8595963e", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -224,8 +224,8 @@ fn exported_name_with_opt_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 // to be a value or type-def or something in there\n                 // *somewhere*\n                 ty_def_id.index = key.parent.unwrap_or_else(|| {\n-                    panic!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                            parent\", def_id, ty_def_id);\n+                    bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                         parent\", def_id, ty_def_id);\n                 });\n             }\n         }"}, {"sha": "e6a51eb7c87e994a2f86398f40bff8c54f0f1e76", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -113,7 +113,7 @@ impl Emitter for SharedEmitter {\n     }\n \n     fn custom_emit(&mut self, _sp: &errors::RenderSpan, _msg: &str, _lvl: Level) {\n-        panic!(\"SharedEmitter doesn't support custom_emit\");\n+        bug!(\"SharedEmitter doesn't support custom_emit\");\n     }\n }\n \n@@ -159,7 +159,7 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n                                  .cg\n                                  .relocation_model));\n             sess.abort_if_errors();\n-            unreachable!();\n+            bug!();\n         }\n     };\n \n@@ -190,7 +190,7 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n                                  .cg\n                                  .code_model));\n             sess.abort_if_errors();\n-            unreachable!();\n+            bug!();\n         }\n     };\n "}, {"sha": "e5667e06b44113b2fc368721b8d4db72c5ab0761", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -227,8 +227,7 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n \n-pub fn bin_op_to_icmp_predicate(ccx: &CrateContext,\n-                                op: hir::BinOp_,\n+pub fn bin_op_to_icmp_predicate(op: hir::BinOp_,\n                                 signed: bool)\n                                 -> llvm::IntPredicate {\n     match op {\n@@ -239,15 +238,14 @@ pub fn bin_op_to_icmp_predicate(ccx: &CrateContext,\n         hir::BiGt => if signed { llvm::IntSGT } else { llvm::IntUGT },\n         hir::BiGe => if signed { llvm::IntSGE } else { llvm::IntUGE },\n         op => {\n-            ccx.sess()\n-               .bug(&format!(\"comparison_op_to_icmp_predicate: expected comparison operator, \\\n-                              found {:?}\",\n-                             op));\n+            bug!(\"comparison_op_to_icmp_predicate: expected comparison operator, \\\n+                  found {:?}\",\n+                 op)\n         }\n     }\n }\n \n-pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: hir::BinOp_) -> llvm::RealPredicate {\n+pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n     match op {\n         hir::BiEq => llvm::RealOEQ,\n         hir::BiNe => llvm::RealUNE,\n@@ -256,10 +254,9 @@ pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: hir::BinOp_) -> llvm::Re\n         hir::BiGt => llvm::RealOGT,\n         hir::BiGe => llvm::RealOGE,\n         op => {\n-            ccx.sess()\n-               .bug(&format!(\"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n-                              found {:?}\",\n-                             op));\n+            bug!(\"comparison_op_to_fcmp_predicate: expected comparison operator, \\\n+                  found {:?}\",\n+                 op);\n         }\n     }\n }\n@@ -291,7 +288,7 @@ pub fn compare_fat_ptrs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 hir::BiLe => (llvm::IntULE, llvm::IntULT),\n                 hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n                 hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n-                _ => unreachable!(),\n+                _ => bug!(),\n             };\n \n             let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n@@ -302,7 +299,7 @@ pub fn compare_fat_ptrs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             Or(bcx, addr_strict, addr_eq_extra_op, debug_loc)\n         }\n         _ => {\n-            bcx.tcx().sess.bug(\"unexpected fat ptr binop\");\n+            bug!(\"unexpected fat ptr binop\");\n         }\n     }\n }\n@@ -322,19 +319,19 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 hir::BiEq | hir::BiLe | hir::BiGe => return C_bool(bcx.ccx(), true),\n                 hir::BiNe | hir::BiLt | hir::BiGt => return C_bool(bcx.ccx(), false),\n                 // refinements would be nice\n-                _ => bcx.sess().bug(\"compare_scalar_types: must be a comparison operator\"),\n+                _ => bug!(\"compare_scalar_types: must be a comparison operator\"),\n             }\n         }\n         ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyBool | ty::TyUint(_) | ty::TyChar => {\n             ICmp(bcx,\n-                 bin_op_to_icmp_predicate(bcx.ccx(), op, false),\n+                 bin_op_to_icmp_predicate(op, false),\n                  lhs,\n                  rhs,\n                  debug_loc)\n         }\n         ty::TyRawPtr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {\n             ICmp(bcx,\n-                 bin_op_to_icmp_predicate(bcx.ccx(), op, false),\n+                 bin_op_to_icmp_predicate(op, false),\n                  lhs,\n                  rhs,\n                  debug_loc)\n@@ -356,20 +353,20 @@ pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         ty::TyInt(_) => {\n             ICmp(bcx,\n-                 bin_op_to_icmp_predicate(bcx.ccx(), op, true),\n+                 bin_op_to_icmp_predicate(op, true),\n                  lhs,\n                  rhs,\n                  debug_loc)\n         }\n         ty::TyFloat(_) => {\n             FCmp(bcx,\n-                 bin_op_to_fcmp_predicate(bcx.ccx(), op),\n+                 bin_op_to_fcmp_predicate(op),\n                  lhs,\n                  rhs,\n                  debug_loc)\n         }\n         // Should never get here, because t is scalar.\n-        _ => bcx.sess().bug(\"non-scalar type passed to compare_scalar_types\"),\n+        _ => bug!(\"non-scalar type passed to compare_scalar_types\"),\n     }\n }\n \n@@ -383,15 +380,15 @@ pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       -> ValueRef {\n     let signed = match t.sty {\n         ty::TyFloat(_) => {\n-            let cmp = bin_op_to_fcmp_predicate(bcx.ccx(), op);\n+            let cmp = bin_op_to_fcmp_predicate(op);\n             return SExt(bcx, FCmp(bcx, cmp, lhs, rhs, debug_loc), ret_ty);\n         },\n         ty::TyUint(_) => false,\n         ty::TyInt(_) => true,\n-        _ => bcx.sess().bug(\"compare_simd_types: invalid SIMD type\"),\n+        _ => bug!(\"compare_simd_types: invalid SIMD type\"),\n     };\n \n-    let cmp = bin_op_to_icmp_predicate(bcx.ccx(), op, signed);\n+    let cmp = bin_op_to_icmp_predicate(op, signed);\n     // LLVM outputs an `< size x i1 >`, so we need to perform a sign extension\n     // to get the correctly sized type. This will compile to a single instruction\n     // once the IR is converted to assembly if the SIMD instruction is supported\n@@ -578,9 +575,9 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             consts::ptrcast(meth::get_vtable(ccx, trait_ref),\n                             Type::vtable_ptr(ccx))\n         }\n-        _ => ccx.sess().bug(&format!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n+        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n                                      source,\n-                                     target)),\n+                                     target),\n     }\n }\n \n@@ -604,7 +601,7 @@ pub fn unsize_thin_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             (PointerCast(bcx, src, ptr_ty),\n              unsized_info(bcx.ccx(), a, b, None))\n         }\n-        _ => bcx.sess().bug(\"unsize_thin_ptr: called on bad types\"),\n+        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n }\n \n@@ -638,12 +635,12 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let src_repr = adt::represent_type(bcx.ccx(), src_ty);\n             let src_fields = match &*src_repr {\n                 &adt::Repr::Univariant(ref s, _) => &s.fields,\n-                _ => bcx.sess().bug(\"struct has non-univariant repr\"),\n+                _ => bug!(\"struct has non-univariant repr\"),\n             };\n             let dst_repr = adt::represent_type(bcx.ccx(), dst_ty);\n             let dst_fields = match &*dst_repr {\n                 &adt::Repr::Univariant(ref s, _) => &s.fields,\n-                _ => bcx.sess().bug(\"struct has non-univariant repr\"),\n+                _ => bug!(\"struct has non-univariant repr\"),\n             };\n \n             let src = adt::MaybeSizedValue::sized(src);\n@@ -664,9 +661,9 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-        _ => bcx.sess().bug(&format!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n-                                     src_ty,\n-                                     dst_ty)),\n+        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n+                  src_ty,\n+                  dst_ty),\n     }\n }\n \n@@ -689,8 +686,7 @@ pub fn custom_coerce_unsize_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             ccx.tcx().custom_coerce_unsized_kind(impl_def_id)\n         }\n         vtable => {\n-            ccx.sess().bug(&format!(\"invalid CoerceUnsized vtable: {:?}\",\n-                                    vtable));\n+            bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);\n         }\n     }\n }\n@@ -758,7 +754,7 @@ pub fn llty_and_min_for_signed_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             };\n             (llty, min)\n         }\n-        _ => unreachable!(),\n+        _ => bug!(),\n     }\n }\n \n@@ -798,7 +794,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             (res, false)\n         }\n         _ => {\n-            cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\", rhs_t));\n+            bug!(\"fail-if-zero on unexpected type: {}\", rhs_t);\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -1323,30 +1319,30 @@ fn build_cfg(tcx: &TyCtxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>) {\n                 hir::ItemFn(_, _, _, _, _, ref blk) => {\n                     blk\n                 }\n-                _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\"),\n+                _ => bug!(\"unexpected item variant in has_nested_returns\"),\n             }\n         }\n         Some(hir_map::NodeTraitItem(trait_item)) => {\n             match trait_item.node {\n                 hir::MethodTraitItem(_, Some(ref body)) => body,\n                 _ => {\n-                    tcx.sess.bug(\"unexpected variant: trait item other than a provided method in \\\n-                                  has_nested_returns\")\n+                    bug!(\"unexpected variant: trait item other than a provided method in \\\n+                          has_nested_returns\")\n                 }\n             }\n         }\n         Some(hir_map::NodeImplItem(impl_item)) => {\n             match impl_item.node {\n                 hir::ImplItemKind::Method(_, ref body) => body,\n                 _ => {\n-                    tcx.sess.bug(\"unexpected variant: non-method impl item in has_nested_returns\")\n+                    bug!(\"unexpected variant: non-method impl item in has_nested_returns\")\n                 }\n             }\n         }\n         Some(hir_map::NodeExpr(e)) => {\n             match e.node {\n                 hir::ExprClosure(_, _, ref blk) => blk,\n-                _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\"),\n+                _ => bug!(\"unexpected expr variant in has_nested_returns\"),\n             }\n         }\n         Some(hir_map::NodeVariant(..)) |\n@@ -1355,8 +1351,8 @@ fn build_cfg(tcx: &TyCtxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>) {\n         // glue, shims, etc\n         None if id == ast::DUMMY_NODE_ID => return (ast::DUMMY_NODE_ID, None),\n \n-        _ => tcx.sess.bug(&format!(\"unexpected variant in has_nested_returns: {}\",\n-                                   tcx.map.path_to_string(id))),\n+        _ => bug!(\"unexpected variant in has_nested_returns: {}\",\n+                  tcx.map.path_to_string(id)),\n     };\n \n     (blk.id, Some(cfg::CFG::new(tcx, blk)))\n@@ -1675,7 +1671,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                 // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n                 let tupled_arg_tys = match arg_ty.sty {\n                     ty::TyTuple(ref tys) => tys,\n-                    _ => unreachable!(\"last argument of `rust-call` fn isn't a tuple?!\")\n+                    _ => bug!(\"last argument of `rust-call` fn isn't a tuple?!\")\n                 };\n \n                 unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx,\n@@ -1978,7 +1974,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       expr::SaveIn(llresult),\n                                       debug_loc);\n             }\n-            _ => ccx.sess().bug(\"expected expr as arguments for variant/struct tuple constructor\"),\n+            _ => bug!(\"expected expr as arguments for variant/struct tuple constructor\"),\n         }\n     } else {\n         // Just eval all the expressions (if any). Since expressions in Rust can have arbitrary\n@@ -2381,7 +2377,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n                       .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n                       .emit();\n             ccx.sess().abort_if_errors();\n-            panic!();\n+            bug!();\n         }\n         let llfn = declare::declare_cfn(ccx, \"main\", llfty);\n \n@@ -2734,7 +2730,7 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n         });\n \n         if POISONED {\n-            tcx.sess.bug(\"couldn't enable multi-threaded LLVM\");\n+            bug!(\"couldn't enable multi-threaded LLVM\");\n         }\n     }\n "}, {"sha": "0185d1587625c378c476add77f94d05d1066da0a", "filename": "src/librustc_trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuild.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -32,7 +32,7 @@ pub fn terminate(cx: Block, _: &str) {\n \n pub fn check_not_terminated(cx: Block) {\n     if cx.terminated.get() {\n-        panic!(\"already terminated!\");\n+        bug!(\"already terminated!\");\n     }\n }\n "}, {"sha": "92fb342497b5adc9a207ac4b58785250d882b91f", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -871,12 +871,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .zip(args.iter().map(|&v| val_ty(v)));\n         for (i, (expected_ty, actual_ty)) in iter.enumerate() {\n             if expected_ty != actual_ty {\n-                self.ccx.sess().bug(\n-                    &format!(\n-                        \"Type mismatch in function call of {:?}. \\\n-                         Expected {:?} for param {}, got {:?}\",\n-                        Value(llfn),\n-                        expected_ty, i, actual_ty));\n+                bug!(\"Type mismatch in function call of {:?}. \\\n+                      Expected {:?} for param {}, got {:?}\",\n+                     Value(llfn),\n+                     expected_ty, i, actual_ty);\n \n             }\n         }"}, {"sha": "4903af2a6ff7df5442aa848b4dfc6412f97a3057", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -49,7 +49,7 @@ fn ty_align(ty: Type) -> usize {\n             let elt = ty.element_type();\n             ty_align(elt) * len\n         }\n-        _ => panic!(\"ty_align: unhandled type\")\n+        _ => bug!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -81,7 +81,7 @@ fn ty_size(ty: Type) -> usize {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        _ => bug!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "35099399e317c3c86673a2af67881eebffd802fc", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -56,7 +56,7 @@ fn general_ty_align(ty: Type) -> usize {\n             let elt = ty.element_type();\n             general_ty_align(elt) * len\n         }\n-        _ => panic!(\"ty_align: unhandled type\")\n+        _ => bug!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -90,7 +90,7 @@ fn ios_ty_align(ty: Type) -> usize {\n             let elt = ty.element_type();\n             ios_ty_align(elt) * len\n         }\n-        _ => panic!(\"ty_align: unhandled type\")\n+        _ => bug!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -125,7 +125,7 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n             let eltsz = ty_size(elt, align_fn);\n             len * eltsz\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        _ => bug!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "be9d4cad1db684af77eed434f5f9e37da7fbba4d", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -50,7 +50,7 @@ fn ty_align(ty: Type) -> usize {\n             let elt = ty.element_type();\n             ty_align(elt) * len\n         }\n-        _ => panic!(\"ty_align: unhandled type\")\n+        _ => bug!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -82,7 +82,7 @@ fn ty_size(ty: Type) -> usize {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        _ => bug!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "d118cc86f2443056bc8051568fc99601b917eb90", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -48,7 +48,7 @@ fn ty_align(ty: Type) -> usize {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        _ => bug!(\"ty_size: unhandled type\")\n     }\n }\n \n@@ -78,7 +78,7 @@ fn ty_size(ty: Type) -> usize {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        _ => bug!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "7bc41d26f8b757b41ab446d0dc4a29900d1d1cc3", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -49,7 +49,7 @@ fn ty_align(ty: Type) -> usize {\n             let elt = ty.element_type();\n             ty_align(elt)\n         }\n-        _ => panic!(\"ty_align: unhandled type\")\n+        _ => bug!(\"ty_align: unhandled type\")\n     }\n }\n \n@@ -75,7 +75,7 @@ fn ty_size(ty: Type) -> usize {\n             let eltsz = ty_size(elt);\n             len * eltsz\n         }\n-        _ => panic!(\"ty_size: unhandled type\")\n+        _ => bug!(\"ty_size: unhandled type\")\n     }\n }\n "}, {"sha": "e9e9e266c77863ea61794edc516a30cb01e90e69", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -112,7 +112,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                 let elt = ty.element_type();\n                 ty_align(elt) * len\n             }\n-            _ => panic!(\"ty_align: unhandled type\")\n+            _ => bug!(\"ty_align: unhandled type\")\n         }\n     }\n \n@@ -144,7 +144,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                 len * eltsz\n             }\n \n-            _ => panic!(\"ty_size: unhandled type\")\n+            _ => bug!(\"ty_size: unhandled type\")\n         }\n     }\n \n@@ -255,7 +255,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                     Integer => SSEInt(elt.int_width()),\n                     Float => SSEFv,\n                     Double => SSEDv,\n-                    _ => panic!(\"classify: unhandled vector element type\")\n+                    _ => bug!(\"classify: unhandled vector element type\")\n                 };\n \n                 let mut i = 0;\n@@ -268,7 +268,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                     i += 1;\n                 }\n             }\n-            _ => panic!(\"classify: unhandled type\")\n+            _ => bug!(\"classify: unhandled type\")\n         }\n     }\n \n@@ -357,7 +357,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n                                 \"llreg_ty: unsupported SSEInt width {}\", bits);\n                         (64 / bits, Type::ix(ccx, bits))\n                     }\n-                    _ => unreachable!(),\n+                    _ => bug!(),\n                 };\n                 let vec_len = llvec_len(&cls[i + 1..]);\n                 let vec_ty = Type::vector(&elt_ty, vec_len as u64 * elts_per_word);\n@@ -371,7 +371,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n             SSEDs => {\n                 tys.push(Type::f64(ccx));\n             }\n-            _ => panic!(\"llregtype: unhandled class\")\n+            _ => bug!(\"llregtype: unhandled class\")\n         }\n         i += 1;\n     }"}, {"sha": "a323d63adaeb665a32255234bea4113462dfe1ea", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -184,8 +184,8 @@ impl<'tcx> Callee<'tcx> {\n                 let method_ty = def_ty(tcx, def_id, substs);\n                 let fn_ptr_ty = match method_ty.sty {\n                     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n-                    _ => unreachable!(\"expected fn item type, found {}\",\n-                                      method_ty)\n+                    _ => bug!(\"expected fn item type, found {}\",\n+                              method_ty)\n                 };\n                 Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n             }\n@@ -196,8 +196,8 @@ impl<'tcx> Callee<'tcx> {\n                 let method_ty = def_ty(tcx, def_id, substs);\n                 let fn_ptr_ty = match method_ty.sty {\n                     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n-                    _ => unreachable!(\"expected fn item type, found {}\",\n-                                      method_ty)\n+                    _ => bug!(\"expected fn item type, found {}\",\n+                              method_ty)\n                 };\n                 Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n             }\n@@ -209,7 +209,7 @@ impl<'tcx> Callee<'tcx> {\n                 }\n             }\n             vtable => {\n-                unreachable!(\"resolved vtable bad vtable {:?} in trans\", vtable);\n+                bug!(\"resolved vtable bad vtable {:?} in trans\", vtable);\n             }\n         }\n     }\n@@ -269,9 +269,9 @@ impl<'tcx> Callee<'tcx> {\n                 ty::TyFnDef(def_id, substs, _) => {\n                     return get_fn(ccx, def_id, substs);\n                 }\n-                _ => unreachable!(\"expected fn item type, found {}\", self.ty)\n+                _ => bug!(\"expected fn item type, found {}\", self.ty)\n             },\n-            Intrinsic => unreachable!(\"intrinsic {} getting reified\", self.ty)\n+            Intrinsic => bug!(\"intrinsic {} getting reified\", self.ty)\n         }\n     }\n }\n@@ -356,8 +356,8 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                     ref sig }) => sig,\n \n         _ => {\n-            tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                    bare_fn_ty));\n+            bug!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n+                 bare_fn_ty);\n         }\n     };\n     let sig = tcx.erase_late_bound_regions(sig);\n@@ -481,7 +481,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 // Create a fn pointer with the substituted signature.\n                 tcx.mk_ty(ty::TyFnPtr(fty))\n             }\n-            _ => unreachable!(\"expected fn item type, found {}\", fn_ty)\n+            _ => bug!(\"expected fn item type, found {}\", fn_ty)\n         };\n         assert_eq!(type_of::type_of(ccx, fn_ptr_ty), common::val_ty(val));\n         return immediate_rvalue(val, fn_ptr_ty);\n@@ -494,7 +494,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // Create a fn pointer with the normalized signature.\n             tcx.mk_fn_ptr(infer::normalize_associated_type(tcx, fty))\n         }\n-        _ => unreachable!(\"expected fn item type, found {}\", ty)\n+        _ => bug!(\"expected fn item type, found {}\", ty)\n     };\n \n     let instance = Instance::mono(ccx.tcx(), def_id);\n@@ -537,7 +537,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n \n         ref variant => {\n-            ccx.sess().bug(&format!(\"get_fn: unexpected variant: {:?}\", variant))\n+            bug!(\"get_fn: unexpected variant: {:?}\", variant)\n         }\n     };\n \n@@ -689,7 +689,7 @@ fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let llfn = match callee {\n         Fn(f) => f,\n-        _ => unreachable!(\"expected fn pointer callee, found {:?}\", callee)\n+        _ => bug!(\"expected fn pointer callee, found {:?}\", callee)\n     };\n \n     let (llret, mut bcx) = base::invoke(bcx, llfn, &llargs, debug_loc);\n@@ -830,8 +830,8 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n             }\n         }\n         _ => {\n-            bcx.sess().span_bug(tuple_expr.span,\n-                                \"argument to `.call()` wasn't a tuple?!\")\n+            span_bug!(tuple_expr.span,\n+                      \"argument to `.call()` wasn't a tuple?!\")\n         }\n     };\n "}, {"sha": "514e6bda594277dfae7dd8e64f1f98e825a4237a", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -378,7 +378,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                 return id;\n             }\n         }\n-        self.ccx.sess().bug(\"no loop scope found\");\n+        bug!(\"no loop scope found\");\n     }\n \n     /// Returns a block to branch to which will perform all pending cleanups and\n@@ -568,9 +568,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             }\n         }\n \n-        self.ccx.sess().bug(\n-            &format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx().map.node_to_string(cleanup_scope)));\n+        bug!(\"no cleanup scope {} found\",\n+             self.ccx.tcx().map.node_to_string(cleanup_scope));\n     }\n \n     /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n@@ -763,9 +762,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     }\n \n                     LoopExit(id, _) => {\n-                        self.ccx.sess().bug(&format!(\n-                                \"cannot exit from scope {}, \\\n-                                not in scope\", id));\n+                        bug!(\"cannot exit from scope {}, not in scope\", id);\n                     }\n                 }\n             }\n@@ -1189,8 +1186,7 @@ pub fn temporary_scope(tcx: &TyCtxt,\n             r\n         }\n         None => {\n-            tcx.sess.bug(&format!(\"no temporary scope available for expr {}\",\n-                                 id))\n+            bug!(\"no temporary scope available for expr {}\", id)\n         }\n     }\n }"}, {"sha": "cb94c9dfeb8d99a459f9e24fe90566211a76d8b2", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -297,7 +297,6 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let llfn_closure_kind = ccx.tcx().closure_kind(closure_def_id);\n \n     let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n-    let tcx = ccx.tcx();\n \n     debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n            trait_closure_kind={:?}, llfn={:?})\",\n@@ -329,9 +328,9 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n             trans_fn_once_adapter_shim(ccx, closure_def_id, substs, llfn)\n         }\n         _ => {\n-            tcx.sess.bug(&format!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n-                                  llfn_closure_kind,\n-                                  trait_closure_kind));\n+            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n+                 llfn_closure_kind,\n+                 trait_closure_kind);\n         }\n     }\n }"}, {"sha": "1c18f3ca393c209f91a4a85f81443850e36853ea", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -597,7 +597,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         let substs = match fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n             traits::VtableImpl(data) => data.substs,\n-            _ => unreachable!()\n+            _ => bug!()\n         };\n \n         if can_have_local_instance(ccx, destructor_did) {\n@@ -665,7 +665,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::TyParam(_)      |\n         ty::TyInfer(_)      |\n         ty::TyError         => {\n-            ccx.sess().bug(\"encountered unexpected type\");\n+            bug!(\"encountered unexpected type\");\n         }\n     }\n }\n@@ -701,7 +701,7 @@ fn do_static_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     }\n                 }\n             }\n-            _ => unreachable!()\n+            _ => bug!()\n         }\n     } else {\n         debug!(\" => regular function\");\n@@ -760,7 +760,7 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             None\n         }\n         _ => {\n-            tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\", vtbl))\n+            bug!(\"static call to invalid vtable: {:?}\", vtbl)\n         }\n     }\n }\n@@ -845,10 +845,9 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                            target_fields[coerce_index].ty(ccx.tcx(),\n                                                                           target_substs))\n         }\n-        _ => ccx.sess()\n-                .bug(&format!(\"find_vtable_types_for_unsizing: invalid coercion {:?} -> {:?}\",\n-                               source_ty,\n-                               target_ty))\n+        _ => bug!(\"find_vtable_types_for_unsizing: invalid coercion {:?} -> {:?}\",\n+                  source_ty,\n+                  target_ty)\n     }\n }\n \n@@ -1019,7 +1018,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                         generics.is_type_parameterized()\n                     }\n                     _ => {\n-                        unreachable!()\n+                        bug!()\n                     }\n                 };\n \n@@ -1101,7 +1100,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         _ => {\n-            unreachable!()\n+            bug!()\n         }\n     }\n }\n@@ -1252,8 +1251,8 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyInfer(_) |\n         ty::TyProjection(..) |\n         ty::TyParam(_) => {\n-            cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {:?}\", t));\n+            bug!(\"debuginfo: Trying to create type name for \\\n+                  unexpected type: {:?}\", t);\n         }\n     }\n }"}, {"sha": "589e6f3266e8e5b1d6476f4571d803f725a4d7f1", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -194,9 +194,7 @@ impl<'tcx> VariantInfo<'tcx> {\n             }\n \n             _ => {\n-                tcx.sess.bug(&format!(\n-                    \"cannot get field types from the type {:?}\",\n-                    ty));\n+                bug!(\"cannot get field types from the type {:?}\", ty);\n             }\n         }\n     }\n@@ -209,7 +207,7 @@ impl<'tcx> VariantInfo<'tcx> {\n \n     pub fn field_index(&self, name: ast::Name) -> usize {\n         self.fields.iter().position(|&Field(n,_)| n == name).unwrap_or_else(|| {\n-            panic!(\"unknown field `{}`\", name)\n+            bug!(\"unknown field `{}`\", name)\n         })\n     }\n }\n@@ -596,8 +594,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         match self.tcx().def_map.borrow().get(&nid) {\n             Some(v) => v.full_def(),\n             None => {\n-                self.tcx().sess.bug(&format!(\n-                    \"no def associated with node id {}\", nid));\n+                bug!(\"no def associated with node id {}\", nid);\n             }\n         }\n     }\n@@ -910,7 +907,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n         let gsym = token::gensym(\"str\");\n         let sym = format!(\"str{}\", gsym.0);\n         let g = declare::define_global(cx, &sym[..], val_ty(sc)).unwrap_or_else(||{\n-            cx.sess().bug(&format!(\"symbol `{}` is already defined\", sym));\n+            bug!(\"symbol `{}` is already defined\", sym);\n         });\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n@@ -1102,11 +1099,11 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 \"reached the recursion limit during monomorphization (selection ambiguity)\");\n         }\n         Err(e) => {\n-            tcx.sess.span_bug(\n+            span_bug!(\n                 span,\n-                &format!(\"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                        e,\n-                        trait_ref))\n+                \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                e,\n+                trait_ref)\n         }\n     };\n \n@@ -1194,7 +1191,7 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         inlined_vid_def_id == v.did ||\n             ccx.external().borrow().get(&v.did) == Some(&Some(inlined_vid))\n     }).unwrap_or_else(|| {\n-        ccx.sess().bug(&format!(\"no variant for {:?}::{}\", adt_def, inlined_vid))\n+        bug!(\"no variant for {:?}::{}\", adt_def, inlined_vid)\n     })\n }\n \n@@ -1255,6 +1252,6 @@ pub fn shift_mask_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let mask = shift_mask_val(bcx, llty.element_type(), mask_llty.element_type(), invert);\n             build::VectorSplat(bcx, mask_llty.vector_length(), mask)\n         },\n-        _ => panic!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n+        _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }\n }"}, {"sha": "3e516c0eec418b1b697c9c55d6c084ea694e7644", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -75,10 +75,10 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &ast::Lit)\n                 ty::TyUint(t) => {\n                     C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n                 }\n-                _ => cx.sess().span_bug(lit.span,\n-                        &format!(\"integer literal has type {:?} (expected int \\\n-                                 or usize)\",\n-                                lit_int_ty))\n+                _ => span_bug!(lit.span,\n+                        \"integer literal has type {:?} (expected int \\\n+                         or usize)\",\n+                        lit_int_ty)\n             }\n         }\n         LitKind::Float(ref fs, t) => {\n@@ -91,7 +91,7 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &ast::Lit)\n                     C_floating(&fs, Type::float_from_ty(cx, t))\n                 }\n                 _ => {\n-                    cx.sess().span_bug(lit.span,\n+                    span_bug!(lit.span,\n                         \"floating point literal doesn't have the right type\");\n                 }\n             }\n@@ -121,7 +121,7 @@ fn addr_of_mut(ccx: &CrateContext,\n         let gsym = token::gensym(\"_\");\n         let name = format!(\"{}{}\", kind, gsym.0);\n         let gv = declare::define_global(ccx, &name[..], val_ty(cv)).unwrap_or_else(||{\n-            ccx.sess().bug(&format!(\"symbol `{}` is already defined\", name));\n+            bug!(\"symbol `{}` is already defined\", name);\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetAlignment(gv, align);\n@@ -186,8 +186,7 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         None => {\n-            cx.sess().bug(&format!(\"unexpected dereferenceable type {:?}\",\n-                                   ty))\n+            bug!(\"unexpected dereferenceable type {:?}\", ty)\n         }\n     }\n }\n@@ -232,7 +231,7 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match lookup_const_by_id(ccx.tcx(), def_id, Some(substs)) {\n         Some((ref expr, _ty)) => expr,\n         None => {\n-            ccx.sess().span_bug(ref_expr.span, \"constant item not found\")\n+            span_bug!(ref_expr.span, \"constant item not found\")\n         }\n     }\n }\n@@ -357,7 +356,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     llconst = Callee::def(cx, def_id, substs).reify(cx).val;\n                 }\n                 _ => {\n-                    unreachable!(\"{} cannot be reified to a fn ptr\", ety)\n+                    bug!(\"{} cannot be reified to a fn ptr\", ety)\n                 }\n             }\n         }\n@@ -441,9 +440,9 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMDumpValue(llconst);\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n-        cx.sess().bug(&format!(\"const {:?} of type {:?} has size {} instead of {}\",\n-                         e, ety_adjusted,\n-                         csize, tsize));\n+        bug!(\"const {:?} of type {:?} has size {} instead of {}\",\n+             e, ety_adjusted,\n+             csize, tsize);\n     }\n     Ok((llconst, ety_adjusted))\n }\n@@ -550,7 +549,7 @@ fn const_err(cx: &CrateContext,\n fn check_binary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n                               te1: ValueRef, te2: ValueRef,\n                               trueconst: TrueConst) -> Result<(), ConstEvalFailure> {\n-    let b = if let hir::ExprBinary(b, _, _) = e.node { b } else { unreachable!() };\n+    let b = if let hir::ExprBinary(b, _, _) = e.node { b } else { bug!() };\n     let (lhs, rhs) = match (to_const_int(te1, t, cx.tcx()), to_const_int(te2, t, cx.tcx())) {\n         (Some(v1), Some(v2)) => (v1, v2),\n         _ => return Ok(()),\n@@ -642,10 +641,10 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 },\n                 hir::BiEq | hir::BiNe | hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe => {\n                     if is_float {\n-                        let cmp = base::bin_op_to_fcmp_predicate(cx, b.node);\n+                        let cmp = base::bin_op_to_fcmp_predicate(b.node);\n                         ConstFCmp(cmp, te1, te2)\n                     } else {\n-                        let cmp = base::bin_op_to_icmp_predicate(cx, b.node, signed);\n+                        let cmp = base::bin_op_to_icmp_predicate(b.node, signed);\n                         ConstICmp(cmp, te1, te2)\n                     }\n                 },\n@@ -669,21 +668,21 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n             let ix = vinfo.field_index(field.node);\n-            adt::const_get_field(cx, &brepr, bv, vinfo.discr, ix)\n+            adt::const_get_field(&brepr, bv, vinfo.discr, ix)\n         },\n         hir::ExprTupField(ref base, idx) => {\n             let (bv, bt) = const_expr(cx, &base, param_substs, fn_args, trueconst)?;\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n-            adt::const_get_field(cx, &brepr, bv, vinfo.discr, idx.node)\n+            adt::const_get_field(&brepr, bv, vinfo.discr, idx.node)\n         },\n         hir::ExprIndex(ref base, ref index) => {\n             let (bv, bt) = const_expr(cx, &base, param_substs, fn_args, trueconst)?;\n             let iv = const_expr(cx, &index, param_substs, fn_args, TrueConst::Yes)?.0;\n             let iv = if let Some(iv) = const_to_opt_uint(iv) {\n                 iv\n             } else {\n-                cx.sess().span_bug(index.span, \"index is not an integer-constant expression\");\n+                span_bug!(index.span, \"index is not an integer-constant expression\");\n             };\n             let (arr, len) = match bt.sty {\n                 ty::TyArray(_, u) => (bv, C_uint(cx, u)),\n@@ -695,15 +694,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     ty::TyArray(_, u) => {\n                         (load_const(cx, bv, mt.ty), C_uint(cx, u))\n                     },\n-                    _ => cx.sess().span_bug(base.span,\n-                                            &format!(\"index-expr base must be a vector \\\n-                                                      or string type, found {:?}\",\n-                                                     bt)),\n+                    _ => span_bug!(base.span,\n+                                   \"index-expr base must be a vector \\\n+                                    or string type, found {:?}\",\n+                                   bt),\n                 },\n-                _ => cx.sess().span_bug(base.span,\n-                                        &format!(\"index-expr base must be a vector \\\n-                                                  or string type, found {:?}\",\n-                                                 bt)),\n+                _ => span_bug!(base.span,\n+                               \"index-expr base must be a vector \\\n+                                or string type, found {:?}\",\n+                               bt),\n             };\n \n             let len = unsafe { llvm::LLVMConstIntGetZExtValue(len) as u64 };\n@@ -784,8 +783,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                   llvm::LLVMConstPtrToInt(v, llty.to_ref())\n                 },\n                 _ => {\n-                  cx.sess().impossible_case(e.span,\n-                                            \"bad combination of types for cast\")\n+                  span_bug!(e.span, \"bad combination of types for cast\")\n                 },\n             } } // unsafe { match ( ... ) {\n         },\n@@ -845,8 +843,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     (Some(ref f), _) => {\n                         const_expr(cx, &f.expr, param_substs, fn_args, trueconst).map(|(l, _)| l)\n                     },\n-                    (_, Some((bv, _))) => Ok(adt::const_get_field(cx, &repr, bv, discr, ix)),\n-                    (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),\n+                    (_, Some((bv, _))) => Ok(adt::const_get_field(&repr, bv, discr, ix)),\n+                    (_, None) => span_bug!(e.span, \"missing struct field\"),\n                 }\n             })\n             .collect::<Vec<Result<_, ConstEvalFailure>>>()\n@@ -900,7 +898,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     if let Some(val) = fn_args.and_then(|args| args.get(&id).cloned()) {\n                         val\n                     } else {\n-                        cx.sess().span_bug(e.span, \"const fn argument not found\")\n+                        span_bug!(e.span, \"const fn argument not found\")\n                     }\n                 }\n                 Def::Fn(..) | Def::Method(..) => C_nil(cx),\n@@ -917,15 +915,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         }\n                         ty::VariantKind::Tuple => C_nil(cx),\n                         ty::VariantKind::Struct => {\n-                            cx.sess().span_bug(e.span, \"path-expr refers to a dict variant!\")\n+                            span_bug!(e.span, \"path-expr refers to a dict variant!\")\n                         }\n                     }\n                 }\n                 // Unit struct or ctor.\n                 Def::Struct(..) => C_null(type_of::type_of(cx, ety)),\n                 _ => {\n-                    cx.sess().span_bug(e.span, \"expected a const, fn, struct, \\\n-                                                or variant def\")\n+                    span_bug!(e.span, \"expected a const, fn, struct, \\\n+                                       or variant def\")\n                 }\n             }\n         },\n@@ -969,7 +967,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      Disr::from(vinfo.disr_val),\n                                      &arg_vals[..])\n                 }\n-                _ => cx.sess().span_bug(e.span, \"expected a struct, variant, or const fn def\"),\n+                _ => span_bug!(e.span, \"expected a struct, variant, or const fn def\"),\n             }\n         },\n         hir::ExprMethodCall(_, _, ref args) => {\n@@ -1003,14 +1001,14 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                 substs);\n                 }\n                 _ =>\n-                    cx.sess().span_bug(\n+                    span_bug!(\n                         e.span,\n-                        &format!(\"bad type for closure expr: {:?}\", ety))\n+                        \"bad type for closure expr: {:?}\", ety)\n             }\n             C_null(type_of::type_of(cx, ety))\n         },\n-        _ => cx.sess().span_bug(e.span,\n-                                \"bad constant expression type in consts::const_expr\"),\n+        _ => span_bug!(e.span,\n+                       \"bad constant expression type in consts::const_expr\"),\n     })\n }\n \n@@ -1105,7 +1103,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                 g\n             }\n \n-            item => unreachable!(\"get_static: expected static, found {:?}\", item)\n+            item => bug!(\"get_static: expected static, found {:?}\", item)\n         }\n     } else {\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?"}, {"sha": "3574883c5f58823ddf4b56521e593fbed12bcc79", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -596,7 +596,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         }\n         match declare_intrinsic(self, key) {\n             Some(v) => return v,\n-            None => panic!(\"unknown intrinsic '{}'\", key)\n+            None => bug!(\"unknown intrinsic '{}'\", key)\n         }\n     }\n \n@@ -785,7 +785,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         match &self.sess().target.target.target_pointer_width[..] {\n             \"32\" => 1 << 31,\n             \"64\" => 1 << 47,\n-            _ => unreachable!() // error handled by config::build_target_config\n+            _ => bug!() // error handled by config::build_target_config\n         }\n     }\n "}, {"sha": "6d4b02f076c872c47131f6cdf38d1b6d58c36673", "filename": "src/librustc_trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontrolflow.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -322,7 +322,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match bcx.tcx().def_map.borrow().get(&expr.id).map(|d| d.full_def())  {\n                 Some(Def::Label(loop_id)) => loop_id,\n                 r => {\n-                    bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\", r))\n+                    bug!(\"{:?} in def-map for label\", r)\n                 }\n             }\n         }"}, {"sha": "0ed38f0681762468fc3e629adf85c87efda9f0eb", "filename": "src/librustc_trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdatum.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -584,10 +584,10 @@ impl<'tcx> Datum<'tcx, Expr> {\n \n     /// Asserts that this datum *is* an lvalue and returns it.\n     #[allow(dead_code)] // potentially useful\n-    pub fn assert_lvalue(self, bcx: Block) -> Datum<'tcx, Lvalue> {\n+    pub fn assert_lvalue(self) -> Datum<'tcx, Lvalue> {\n         self.match_kind(\n             |d| d,\n-            |_| bcx.sess().bug(\"assert_lvalue given rvalue\"))\n+            |_| bug!(\"assert_lvalue given rvalue\"))\n     }\n \n     pub fn store_to_dest<'blk>(self,"}, {"sha": "a7f2bf4a5fa23e5b92e2fb25f3ba8d08d6cce837", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -98,7 +98,7 @@ fn with_new_scope<F>(cx: &CrateContext,\n     }\n \n     if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n-        cx.sess().span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n+        span_bug!(scope_span, \"debuginfo: Inconsistency in scope management.\");\n     }\n \n     scope_stack.pop();"}, {"sha": "cf312855d75bc8bf081d13cbcf2e985d902244fc", "filename": "src/librustc_trans/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -71,7 +71,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n \n             let section_var = declare::define_global(ccx, section_var_name,\n                                                      llvm_type).unwrap_or_else(||{\n-                ccx.sess().bug(&format!(\"symbol `{}` is already defined\", section_var_name))\n+                bug!(\"symbol `{}` is already defined\", section_var_name)\n             });\n             llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n             llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));"}, {"sha": "5690b18bc8edefea77a5aa180f9afe9c53e73c23", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 74, "deletions": 85, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -102,25 +102,22 @@ impl<'tcx> TypeMap<'tcx> {\n     // Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n     // the mapping already exists.\n     fn register_type_with_metadata<'a>(&mut self,\n-                                       cx: &CrateContext<'a, 'tcx>,\n                                        type_: Ty<'tcx>,\n                                        metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n-            cx.sess().bug(&format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   type_));\n+            bug!(\"Type metadata for Ty '{}' is already in the TypeMap!\", type_);\n         }\n     }\n \n     // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will\n     // fail if the mapping already exists.\n     fn register_unique_id_with_metadata(&mut self,\n-                                        cx: &CrateContext,\n                                         unique_type_id: UniqueTypeId,\n                                         metadata: DIType) {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n-            cx.sess().bug(&format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                                  &unique_type_id_str[..]));\n+            bug!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n+                 &unique_type_id_str[..]);\n         }\n     }\n \n@@ -305,8 +302,8 @@ impl<'tcx> TypeMap<'tcx> {\n                 }\n             },\n             _ => {\n-                cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {:?}\",\n-                                       type_))\n+                bug!(\"get_unique_type_id_of_type() - unexpected type: {:?}\",\n+                     type_)\n             }\n         };\n \n@@ -415,8 +412,8 @@ fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n \n     // Insert the stub into the TypeMap in order to allow for recursive references\n     let mut type_map = debug_context(cx).type_map.borrow_mut();\n-    type_map.register_unique_id_with_metadata(cx, unique_type_id, metadata_stub);\n-    type_map.register_type_with_metadata(cx, unfinished_type, metadata_stub);\n+    type_map.register_unique_id_with_metadata(unique_type_id, metadata_stub);\n+    type_map.register_type_with_metadata(unfinished_type, metadata_stub);\n \n     UnfinishedMetadata {\n         unfinished_type: unfinished_type,\n@@ -452,10 +449,9 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                     let type_map = debug_context(cx).type_map.borrow();\n                     if type_map.find_metadata_for_unique_id(unique_type_id).is_none() ||\n                        type_map.find_metadata_for_type(unfinished_type).is_none() {\n-                        cx.sess().bug(&format!(\"Forward declaration of potentially recursive type \\\n-                                              '{:?}' was not found in TypeMap!\",\n-                                              unfinished_type)\n-                                      );\n+                        bug!(\"Forward declaration of potentially recursive type \\\n+                              '{:?}' was not found in TypeMap!\",\n+                             unfinished_type);\n                     }\n                 }\n \n@@ -640,9 +636,9 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let def_id = match trait_type.sty {\n         ty::TyTrait(ref data) => data.principal_def_id(),\n         _ => {\n-            cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n-                                   trait_pointer_metadata(): {:?}\",\n-                                   trait_type));\n+            bug!(\"debuginfo: Unexpected trait-object type in \\\n+                  trait_pointer_metadata(): {:?}\",\n+                 trait_type);\n         }\n     };\n \n@@ -688,7 +684,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         // There is already an equivalent type in the TypeMap.\n                         // Register this Ty as an alias in the cache and\n                         // return the cached metadata.\n-                        type_map.register_type_with_metadata(cx, t, metadata);\n+                        type_map.register_type_with_metadata(t, metadata);\n                         return metadata;\n                     },\n                     None => {\n@@ -803,8 +799,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n-            cx.sess().bug(&format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n-                                  sty))\n+            bug!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty)\n         }\n     };\n \n@@ -818,13 +813,13 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 None => {\n                     let unique_type_id_str =\n                         type_map.get_unique_type_id_as_string(unique_type_id);\n-                    let error_message = format!(\"Expected type metadata for unique \\\n-                                                 type id '{}' to already be in \\\n-                                                 the debuginfo::TypeMap but it \\\n-                                                 was not. (Ty = {})\",\n-                                                &unique_type_id_str[..],\n-                                                t);\n-                    cx.sess().span_bug(usage_site_span, &error_message[..]);\n+                    span_bug!(usage_site_span,\n+                              \"Expected type metadata for unique \\\n+                               type id '{}' to already be in \\\n+                               the debuginfo::TypeMap but it \\\n+                               was not. (Ty = {})\",\n+                              &unique_type_id_str[..],\n+                              t);\n                 }\n             };\n \n@@ -833,22 +828,22 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     if metadata != metadata_for_uid {\n                         let unique_type_id_str =\n                             type_map.get_unique_type_id_as_string(unique_type_id);\n-                        let error_message = format!(\"Mismatch between Ty and \\\n-                                                     UniqueTypeId maps in \\\n-                                                     debuginfo::TypeMap. \\\n-                                                     UniqueTypeId={}, Ty={}\",\n-                            &unique_type_id_str[..],\n-                            t);\n-                        cx.sess().span_bug(usage_site_span, &error_message[..]);\n+                        span_bug!(usage_site_span,\n+                                  \"Mismatch between Ty and \\\n+                                   UniqueTypeId maps in \\\n+                                   debuginfo::TypeMap. \\\n+                                   UniqueTypeId={}, Ty={}\",\n+                                  &unique_type_id_str[..],\n+                                  t);\n                     }\n                 }\n                 None => {\n-                    type_map.register_type_with_metadata(cx, t, metadata);\n+                    type_map.register_type_with_metadata(t, metadata);\n                 }\n             }\n         } else {\n-            type_map.register_type_with_metadata(cx, t, metadata);\n-            type_map.register_unique_id_with_metadata(cx, unique_type_id, metadata);\n+            type_map.register_type_with_metadata(t, metadata);\n+            type_map.register_unique_id_with_metadata(unique_type_id, metadata);\n         }\n     }\n \n@@ -901,16 +896,16 @@ pub fn scope_metadata(fcx: &FunctionContext,\n                   error_reporting_span: Span)\n                -> DIScope {\n     let scope_map = &fcx.debug_context\n-                        .get_ref(fcx.ccx, error_reporting_span)\n+                        .get_ref(error_reporting_span)\n                         .scope_map;\n     match scope_map.borrow().get(&node_id).cloned() {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n             let node = fcx.ccx.tcx().map.get(node_id);\n \n-            fcx.ccx.sess().span_bug(error_reporting_span,\n-                &format!(\"debuginfo: Could not find scope info for node {:?}\",\n-                        node));\n+            span_bug!(error_reporting_span,\n+                      \"debuginfo: Could not find scope info for node {:?}\",\n+                      node);\n         }\n     }\n }\n@@ -945,7 +940,7 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyFloat(float_ty) => {\n             (float_ty.ty_to_string(), DW_ATE_float)\n         },\n-        _ => cx.sess().bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n+        _ => bug!(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n \n     let llvm_type = type_of::type_of(cx, t);\n@@ -1162,7 +1157,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let (variant, substs) = match struct_type.sty {\n         ty::TyStruct(def, substs) => (def.struct_variant(), substs),\n-        _ => cx.tcx().sess.bug(\"prepare_struct_metadata on a non-struct\")\n+        _ => bug!(\"prepare_struct_metadata on a non-struct\")\n     };\n \n     let (containing_scope, _) = get_namespace_and_span_for_item(cx, variant.did);\n@@ -1362,7 +1357,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         ty::VariantKind::Struct => {\n                             non_null_variant.fields[0].name.to_string()\n                         }\n-                        ty::VariantKind::Unit => unreachable!()\n+                        ty::VariantKind::Unit => bug!()\n                     },\n                     llvm_type: non_null_llvm_type,\n                     type_metadata: non_null_type_metadata,\n@@ -1452,7 +1447,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }\n                 ]\n             },\n-            adt::CEnum(..) => cx.sess().span_bug(self.span, \"This should be unreachable.\")\n+            adt::CEnum(..) => span_bug!(self.span, \"This should be unreachable.\")\n         }\n     }\n }\n@@ -1747,8 +1742,8 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         let mut composite_types_completed =\n             debug_context(cx).composite_types_completed.borrow_mut();\n         if composite_types_completed.contains(&composite_type_metadata) {\n-            cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n-                           Already completed forward declaration re-encountered.\");\n+            bug!(\"debuginfo::set_members_of_composite_type() - \\\n+                  Already completed forward declaration re-encountered.\");\n         } else {\n             composite_types_completed.insert(composite_type_metadata);\n         }\n@@ -1855,20 +1850,19 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                 hir::ItemStatic(..) => (item.name, item.span),\n                 hir::ItemConst(..) => (item.name, item.span),\n                 _ => {\n-                    cx.sess()\n-                      .span_bug(item.span,\n-                                &format!(\"debuginfo::\\\n-                                         create_global_var_metadata() -\n-                                         Captured var-id refers to \\\n-                                         unexpected ast_item variant: {:?}\",\n-                                        var_item))\n+                    span_bug!(item.span,\n+                              \"debuginfo::\\\n+                               create_global_var_metadata() -\n+                               Captured var-id refers to \\\n+                               unexpected ast_item variant: {:?}\",\n+                              var_item)\n                 }\n             }\n         },\n-        _ => cx.sess().bug(&format!(\"debuginfo::create_global_var_metadata() \\\n-                                    - Captured var-id refers to unexpected \\\n-                                    hir_map variant: {:?}\",\n-                                   var_item))\n+        _ => bug!(\"debuginfo::create_global_var_metadata() \\\n+                   - Captured var-id refers to unexpected \\\n+                   hir_map variant: {:?}\",\n+                  var_item)\n     };\n \n     let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n@@ -1924,15 +1918,15 @@ pub fn create_local_var_metadata(bcx: Block, local: &hir::Local) {\n         let datum = match locals.get(&node_id) {\n             Some(datum) => datum,\n             None => {\n-                bcx.sess().span_bug(span,\n-                    &format!(\"no entry in lllocals table for {}\",\n-                            node_id));\n+                span_bug!(span,\n+                          \"no entry in lllocals table for {}\",\n+                          node_id);\n             }\n         };\n \n         if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            cx.sess().span_bug(span, \"debuginfo::create_local_var_metadata() - \\\n-                                      Referenced variable location is not an alloca!\");\n+            span_bug!(span, \"debuginfo::create_local_var_metadata() - \\\n+                             Referenced variable location is not an alloca!\");\n         }\n \n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n@@ -1968,36 +1962,33 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let variable_name = match ast_item {\n         None => {\n-            cx.sess().span_bug(span, \"debuginfo::create_captured_var_metadata: node not found\");\n+            span_bug!(span, \"debuginfo::create_captured_var_metadata: node not found\");\n         }\n         Some(hir_map::NodeLocal(pat)) => {\n             match pat.node {\n                 PatKind::Ident(_, ref path1, _) => {\n                     path1.node.name\n                 }\n                 _ => {\n-                    cx.sess()\n-                      .span_bug(span,\n-                                &format!(\n-                                \"debuginfo::create_captured_var_metadata() - \\\n-                                 Captured var-id refers to unexpected \\\n-                                 hir_map variant: {:?}\",\n-                                 ast_item));\n+                    span_bug!(span,\n+                              \"debuginfo::create_captured_var_metadata() - \\\n+                               Captured var-id refers to unexpected \\\n+                               hir_map variant: {:?}\",\n+                              ast_item);\n                 }\n             }\n         }\n         _ => {\n-            cx.sess()\n-              .span_bug(span,\n-                        &format!(\"debuginfo::create_captured_var_metadata() - \\\n-                                 Captured var-id refers to unexpected \\\n-                                 hir_map variant: {:?}\",\n-                                ast_item));\n+            span_bug!(span,\n+                      \"debuginfo::create_captured_var_metadata() - \\\n+                       Captured var-id refers to unexpected \\\n+                       hir_map variant: {:?}\",\n+                      ast_item);\n         }\n     };\n \n     let variable_type = common::node_id_type(bcx, node_id);\n-    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, span).fn_metadata;\n+    let scope_metadata = bcx.fcx.debug_context.get_ref(span).fn_metadata;\n \n     // env_pointer is the alloca containing the pointer to the environment,\n     // so it's type is **EnvironmentType. In order to find out the type of\n@@ -2096,30 +2087,28 @@ pub fn create_argument_metadata(bcx: Block, arg: &hir::Arg) {\n     let scope_metadata = bcx\n                          .fcx\n                          .debug_context\n-                         .get_ref(bcx.ccx(), arg.pat.span)\n+                         .get_ref(arg.pat.span)\n                          .fn_metadata;\n     let locals = bcx.fcx.lllocals.borrow();\n \n     pat_util::pat_bindings(def_map, &arg.pat, |_, node_id, span, var_name| {\n         let datum = match locals.get(&node_id) {\n             Some(v) => v,\n             None => {\n-                bcx.sess().span_bug(span,\n-                    &format!(\"no entry in lllocals table for {}\",\n-                            node_id));\n+                span_bug!(span, \"no entry in lllocals table for {}\", node_id);\n             }\n         };\n \n         if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            bcx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n-                                       Referenced variable location is not an alloca!\");\n+            span_bug!(span, \"debuginfo::create_argument_metadata() - \\\n+                             Referenced variable location is not an alloca!\");\n         }\n \n         let argument_index = {\n             let counter = &bcx\n                           .fcx\n                           .debug_context\n-                          .get_ref(bcx.ccx(), span)\n+                          .get_ref(span)\n                           .argument_counter;\n             let argument_index = counter.get();\n             counter.set(argument_index + 1);"}, {"sha": "6b92989cf464856a803a83a971689df1bc628ab1", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -119,18 +119,19 @@ pub enum FunctionDebugContext {\n \n impl FunctionDebugContext {\n     fn get_ref<'a>(&'a self,\n-                   cx: &CrateContext,\n                    span: Span)\n                    -> &'a FunctionDebugContextData {\n         match *self {\n             FunctionDebugContext::RegularContext(box ref data) => data,\n             FunctionDebugContext::DebugInfoDisabled => {\n-                cx.sess().span_bug(span,\n-                                   FunctionDebugContext::debuginfo_disabled_message());\n+                span_bug!(span,\n+                          \"{}\",\n+                          FunctionDebugContext::debuginfo_disabled_message());\n             }\n             FunctionDebugContext::FunctionWithoutDebugInfo => {\n-                cx.sess().span_bug(span,\n-                                   FunctionDebugContext::should_be_ignored_message());\n+                span_bug!(span,\n+                          \"{}\",\n+                          FunctionDebugContext::should_be_ignored_message());\n             }\n         }\n     }\n@@ -253,7 +254,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     (item.name, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {\n-                    cx.sess().span_bug(item.span,\n+                    span_bug!(item.span,\n                         \"create_function_debug_context: item bound to non-function\");\n                 }\n             }\n@@ -273,9 +274,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                      true)\n                 }\n                 _ => {\n-                    cx.sess().span_bug(impl_item.span,\n-                                       \"create_function_debug_context() \\\n-                                        called on non-method impl item?!\")\n+                    span_bug!(impl_item.span,\n+                              \"create_function_debug_context() \\\n+                               called on non-method impl item?!\")\n                 }\n             }\n         }\n@@ -293,7 +294,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         // Don't try to lookup the item path:\n                         false)\n                 }\n-                _ => cx.sess().span_bug(expr.span,\n+                _ => span_bug!(expr.span,\n                         \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n@@ -312,10 +313,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                      true)\n                 }\n                 _ => {\n-                    cx.sess()\n-                      .bug(&format!(\"create_function_debug_context: \\\n-                                    unexpected sort of node: {:?}\",\n-                                    fnitem))\n+                    bug!(\"create_function_debug_context: \\\n+                          unexpected sort of node: {:?}\",\n+                         fnitem)\n                 }\n             }\n         }\n@@ -324,9 +324,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir_map::NodeStructCtor(..) => {\n             return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n-        _ => cx.sess().bug(&format!(\"create_function_debug_context: \\\n-                                    unexpected sort of node: {:?}\",\n-                                   fnitem))\n+        _ => bug!(\"create_function_debug_context: \\\n+                   unexpected sort of node: {:?}\",\n+                  fnitem)\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -441,7 +441,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 (sig, closure_type.abi)\n             }\n \n-            _ => cx.sess().bug(\"get_function_metdata: Expected a function type!\")\n+            _ => bug!(\"get_function_metdata: Expected a function type!\")\n         };\n \n         let mut signature = Vec::with_capacity(sig.inputs.len() + 1);\n@@ -640,7 +640,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ArgumentVariable(_) | CapturedVariable => {\n             assert!(!bcx.fcx\n                         .debug_context\n-                        .get_ref(cx, span)\n+                        .get_ref(span)\n                         .source_locations_enabled\n                         .get());\n             source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);"}, {"sha": "445f85c52fc75b89c20eda87fe7cc709bbf148d7", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -126,9 +126,9 @@ pub fn namespace_for_item(cx: &CrateContext, def_id: DefId) -> Rc<NamespaceTreeN\n         match parent_node {\n             Some(node) => node,\n             None => {\n-                cx.sess().bug(&format!(\"debuginfo::namespace_for_item(): \\\n-                                       path too short for {:?}\",\n-                                      def_id));\n+                bug!(\"debuginfo::namespace_for_item(): \\\n+                      path too short for {:?}\",\n+                     def_id);\n             }\n         }\n     })"}, {"sha": "a6aa8df92db291d70abe1877aebcce853aac065b", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -154,8 +154,8 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyInfer(_) |\n         ty::TyProjection(..) |\n         ty::TyParam(_) => {\n-            cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {:?}\", t));\n+            bug!(\"debuginfo: Trying to create type name for \\\n+                unexpected type: {:?}\", t);\n         }\n     }\n \n@@ -178,7 +178,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n \n                 if path_element_count == 0 {\n-                    cx.sess().bug(\"debuginfo: Encountered empty item path!\");\n+                    bug!(\"debuginfo: Encountered empty item path!\");\n                 }\n \n                 output.pop();"}, {"sha": "61dc3dc3f8fdbf8c22499af737feccc068e67fd4", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -91,8 +91,8 @@ pub fn assert_type_for_node_id(cx: &CrateContext,\n                            node_id: ast::NodeId,\n                            error_reporting_span: Span) {\n     if !cx.tcx().node_types().contains_key(&node_id) {\n-        cx.sess().span_bug(error_reporting_span,\n-                           \"debuginfo: Could not find type for node id!\");\n+        span_bug!(error_reporting_span,\n+                  \"debuginfo: Could not find type for node id!\");\n     }\n }\n "}, {"sha": "f49d303a5a802a519e63c6b55027cf8a0cb3a2dd", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -38,7 +38,7 @@ use libc::c_uint;\n pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRef {\n     debug!(\"declare_global(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n-        ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n+        bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     unsafe {\n         llvm::LLVMGetOrInsertGlobal(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n@@ -53,7 +53,7 @@ pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRe\n fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty: Type) -> ValueRef {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n-        ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n+        bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     let llfn = unsafe {\n         llvm::LLVMGetOrInsertFunction(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n@@ -152,7 +152,7 @@ pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n     debug!(\"get_defined_value(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n-        ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n+        bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     let val = unsafe { llvm::LLVMGetNamedValue(ccx.llmod(), namebuf.as_ptr()) };\n     if val.is_null() {"}, {"sha": "5e193b962783b233098d00555c6abd654fc1429c", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 67, "deletions": 74, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -388,7 +388,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         .reify(bcx.ccx()).to_expr_datum();\n                 }\n                 _ => {\n-                    unreachable!(\"{} cannot be reified to a fn ptr\", datum.ty)\n+                    bug!(\"{} cannot be reified to a fn ptr\", datum.ty)\n                 }\n             }\n         }\n@@ -516,16 +516,16 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let repr_source = adt::represent_type(bcx.ccx(), source.ty);\n             let src_fields = match &*repr_source {\n                 &adt::Repr::Univariant(ref s, _) => &s.fields,\n-                _ => bcx.sess().span_bug(span,\n-                                         &format!(\"Non univariant struct? (repr_source: {:?})\",\n-                                                  repr_source)),\n+                _ => span_bug!(span,\n+                               \"Non univariant struct? (repr_source: {:?})\",\n+                               repr_source),\n             };\n             let repr_target = adt::represent_type(bcx.ccx(), target.ty);\n             let target_fields = match &*repr_target {\n                 &adt::Repr::Univariant(ref s, _) => &s.fields,\n-                _ => bcx.sess().span_bug(span,\n-                                         &format!(\"Non univariant struct? (repr_target: {:?})\",\n-                                                  repr_target)),\n+                _ => span_bug!(span,\n+                               \"Non univariant struct? (repr_target: {:?})\",\n+                               repr_target),\n             };\n \n             let coerce_index = match kind {\n@@ -555,9 +555,9 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-        _ => bcx.sess().bug(&format!(\"coerce_unsized: invalid coercion {:?} -> {:?}\",\n-                                     source.ty,\n-                                     target.ty))\n+        _ => bug!(\"coerce_unsized: invalid coercion {:?} -> {:?}\",\n+                  source.ty,\n+                  target.ty)\n     }\n     bcx\n }\n@@ -671,8 +671,8 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 ty::TyBox(..) => {\n                     trans_uniq_expr(bcx, expr, box_ty, &contents, contents_ty)\n                 }\n-                _ => bcx.sess().span_bug(expr.span,\n-                                         \"expected unique box\")\n+                _ => span_bug!(expr.span,\n+                               \"expected unique box\")\n             }\n \n         }\n@@ -708,11 +708,11 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_imm_cast(bcx, &val, expr.id)\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(\n+            span_bug!(\n                 expr.span,\n-                &format!(\"trans_rvalue_datum_unadjusted reached \\\n-                         fall-through case: {:?}\",\n-                        expr.node));\n+                \"trans_rvalue_datum_unadjusted reached \\\n+                 fall-through case: {:?}\",\n+                expr.node);\n         }\n     }\n }\n@@ -798,9 +798,9 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap().unwrap();\n             let elt_ty = match ref_ty.builtin_deref(true, ty::NoPreference) {\n                 None => {\n-                    bcx.tcx().sess.span_bug(index_expr.span,\n-                                            \"index method didn't return a \\\n-                                             dereferenceable type?!\")\n+                    span_bug!(index_expr.span,\n+                              \"index method didn't return a \\\n+                              dereferenceable type?!\")\n                 }\n                 Some(elt_tm) => elt_tm.ty,\n             };\n@@ -895,26 +895,22 @@ pub fn trans_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, def: Def)\n             match bcx.fcx.llupvars.borrow().get(&nid) {\n                 Some(&val) => Datum::new(val, local_ty, lval),\n                 None => {\n-                    bcx.sess().bug(&format!(\n-                        \"trans_var: no llval for upvar {} found\",\n-                        nid));\n+                    bug!(\"trans_var: no llval for upvar {} found\", nid);\n                 }\n             }\n         }\n         Def::Local(_, nid) => {\n             let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n                 Some(&v) => v,\n                 None => {\n-                    bcx.sess().bug(&format!(\n-                        \"trans_var: no datum for local/arg {} found\",\n-                        nid));\n+                    bug!(\"trans_var: no datum for local/arg {} found\", nid);\n                 }\n             };\n             debug!(\"take_local(nid={}, v={:?}, ty={})\",\n                    nid, Value(datum.val), datum.ty);\n             datum\n         }\n-        _ => unreachable!(\"{:?} should not reach expr::trans_var\", def)\n+        _ => bug!(\"{:?} should not reach expr::trans_var\", def)\n     }\n }\n \n@@ -1051,11 +1047,11 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(\n+            span_bug!(\n                 expr.span,\n-                &format!(\"trans_rvalue_stmt_unadjusted reached \\\n-                         fall-through case: {:?}\",\n-                        expr.node));\n+                \"trans_rvalue_stmt_unadjusted reached \\\n+                 fall-through case: {:?}\",\n+                expr.node);\n         }\n     }\n }\n@@ -1114,11 +1110,9 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     tvec::trans_lit_str(bcx, expr, (*s).clone(), dest)\n                 }\n                 _ => {\n-                    bcx.tcx()\n-                       .sess\n-                       .span_bug(expr.span,\n-                                 \"trans_rvalue_dps_unadjusted shouldn't be \\\n-                                  translating this type of literal\")\n+                    span_bug!(expr.span,\n+                              \"trans_rvalue_dps_unadjusted shouldn't be \\\n+                              translating this type of literal\")\n                 }\n             }\n         }\n@@ -1141,9 +1135,9 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let (def_id, substs) = match expr_ty(bcx, expr).sty {\n                 ty::TyClosure(def_id, ref substs) => (def_id, substs),\n                 ref t =>\n-                    bcx.tcx().sess.span_bug(\n+                    span_bug!(\n                         expr.span,\n-                        &format!(\"closure expr without closure type: {:?}\", t)),\n+                        \"closure expr without closure type: {:?}\", t),\n             };\n \n             closure::trans_closure_expr(dest,\n@@ -1172,8 +1166,8 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         Callee::ptr(f)\n                     }\n                     _ => {\n-                        bcx.tcx().sess.span_bug(expr.span,\n-                            &format!(\"type of callee is not a fn: {}\", f.ty));\n+                        span_bug!(expr.span,\n+                            \"type of callee is not a fn: {}\", f.ty);\n                     }\n                 }, ArgExprs(&args))\n             };\n@@ -1205,20 +1199,20 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         hir::ExprCast(..) => {\n             // Trait casts used to come this way, now they should be coercions.\n-            bcx.tcx().sess.span_bug(expr.span, \"DPS expr_cast (residual trait cast?)\")\n+            span_bug!(expr.span, \"DPS expr_cast (residual trait cast?)\")\n         }\n         hir::ExprAssignOp(op, _, _) => {\n-            bcx.tcx().sess.span_bug(\n+            span_bug!(\n                 expr.span,\n-                &format!(\"augmented assignment `{}=` should always be a rvalue_stmt\",\n-                         rustc_front::util::binop_to_string(op.node)))\n+                \"augmented assignment `{}=` should always be a rvalue_stmt\",\n+                rustc_front::util::binop_to_string(op.node))\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(\n+            span_bug!(\n                 expr.span,\n-                &format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n-                         case: {:?}\",\n-                        expr.node));\n+                \"trans_rvalue_dps_unadjusted reached fall-through \\\n+                 case: {:?}\",\n+                expr.node);\n         }\n     }\n }\n@@ -1261,9 +1255,9 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(ref_expr.span, &format!(\n-                \"Non-DPS def {:?} referened by {}\",\n-                def, bcx.node_id_to_string(ref_expr.id)));\n+            span_bug!(ref_expr.span,\n+                      \"Non-DPS def {:?} referened by {}\",\n+                      def, bcx.node_id_to_string(ref_expr.id));\n         }\n     }\n }\n@@ -1301,7 +1295,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         None => {\n             if need_base.iter().any(|b| *b) {\n-                tcx.sess.span_bug(expr_span, \"missing fields and no base expr\")\n+                span_bug!(expr_span, \"missing fields and no base expr\")\n             }\n             None\n         }\n@@ -1415,7 +1409,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 bcx = trans_into(bcx, &base.expr, SaveIn(addr.value));\n             },\n             ExprKind::RvalueStmt => {\n-                bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\")\n+                bug!(\"unexpected expr kind for struct base expr\")\n             }\n             _ => {\n                 let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &base.expr, \"base\"));\n@@ -1728,7 +1722,7 @@ fn trans_scalar_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n           base::compare_scalar_types(bcx, lhs, rhs, lhs_t, op.node, binop_debug_loc)\n       }\n       _ => {\n-        bcx.tcx().sess.span_bug(binop_expr.span, \"unexpected binop\");\n+        span_bug!(binop_expr.span, \"unexpected binop\");\n       }\n     };\n \n@@ -1968,12 +1962,11 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         (Float, Int(I)) => FPToSI(bcx, llexpr, ll_t_out),\n         (Float, Int(_)) => FPToUI(bcx, llexpr, ll_t_out),\n \n-        _ => ccx.sess().span_bug(expr.span,\n-                                  &format!(\"translating unsupported cast: \\\n-                                            {:?} -> {:?}\",\n-                                           t_in,\n-                                           t_out)\n-                                 )\n+        _ => span_bug!(expr.span,\n+                       \"translating unsupported cast: \\\n+                        {:?} -> {:?}\",\n+                       t_in,\n+                       t_out)\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n@@ -2140,10 +2133,10 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         _ => {\n-            bcx.tcx().sess.span_bug(\n+            span_bug!(\n                 expr.span,\n-                &format!(\"deref invoked on expr of invalid type {:?}\",\n-                        datum.ty));\n+                \"deref invoked on expr of invalid type {:?}\",\n+                datum.ty);\n         }\n     };\n \n@@ -2200,16 +2193,16 @@ impl OverflowOpViaIntrinsic {\n             TyInt(Is) => match &tcx.sess.target.target.target_pointer_width[..] {\n                 \"32\" => TyInt(I32),\n                 \"64\" => TyInt(I64),\n-                _ => panic!(\"unsupported target word size\")\n+                _ => bug!(\"unsupported target word size\")\n             },\n             TyUint(Us) => match &tcx.sess.target.target.target_pointer_width[..] {\n                 \"32\" => TyUint(U32),\n                 \"64\" => TyUint(U64),\n-                _ => panic!(\"unsupported target word size\")\n+                _ => bug!(\"unsupported target word size\")\n             },\n             ref t @ TyUint(_) | ref t @ TyInt(_) => t.clone(),\n-            _ => panic!(\"tried to get overflow intrinsic for {:?} applied to non-int type\",\n-                        *self)\n+            _ => bug!(\"tried to get overflow intrinsic for {:?} applied to non-int type\",\n+                      *self)\n         };\n \n         match *self {\n@@ -2224,7 +2217,7 @@ impl OverflowOpViaIntrinsic {\n                 TyUint(U32) => \"llvm.uadd.with.overflow.i32\",\n                 TyUint(U64) => \"llvm.uadd.with.overflow.i64\",\n \n-                _ => unreachable!(),\n+                _ => bug!(),\n             },\n             OverflowOpViaIntrinsic::Sub => match new_sty {\n                 TyInt(I8) => \"llvm.ssub.with.overflow.i8\",\n@@ -2237,7 +2230,7 @@ impl OverflowOpViaIntrinsic {\n                 TyUint(U32) => \"llvm.usub.with.overflow.i32\",\n                 TyUint(U64) => \"llvm.usub.with.overflow.i64\",\n \n-                _ => unreachable!(),\n+                _ => bug!(),\n             },\n             OverflowOpViaIntrinsic::Mul => match new_sty {\n                 TyInt(I8) => \"llvm.smul.with.overflow.i8\",\n@@ -2250,7 +2243,7 @@ impl OverflowOpViaIntrinsic {\n                 TyUint(U32) => \"llvm.umul.with.overflow.i32\",\n                 TyUint(U64) => \"llvm.umul.with.overflow.i64\",\n \n-                _ => unreachable!(),\n+                _ => bug!(),\n             },\n         }\n     }\n@@ -2337,7 +2330,7 @@ fn build_nonzero_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let int_value = BitCast(bcx, value, Type::ix(bcx.ccx(), width));\n             build_nonzero_check(bcx, int_value, binop_debug_loc)\n         },\n-        _ => panic!(\"build_nonzero_check: expected Integer or Vector, found {:?}\", kind),\n+        _ => bug!(\"build_nonzero_check: expected Integer or Vector, found {:?}\", kind),\n     }\n }\n \n@@ -2423,11 +2416,11 @@ fn expr_kind(tcx: &TyCtxt, expr: &hir::Expr) -> ExprKind {\n                 Def::AssociatedConst(..) => ExprKind::RvalueDatum,\n \n                 def => {\n-                    tcx.sess.span_bug(\n+                    span_bug!(\n                         expr.span,\n-                        &format!(\"uncategorized def for expr {}: {:?}\",\n-                                expr.id,\n-                                def));\n+                        \"uncategorized def for expr {}: {:?}\",\n+                        expr.id,\n+                        def);\n                 }\n             }\n         }"}, {"sha": "6ef4ed4b87e55792bb25ac2cecec776c81a33cbd", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -367,7 +367,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     });\n     let vtbl = match fulfill_obligation(bcx.ccx(), DUMMY_SP, trait_ref) {\n         traits::VtableImpl(data) => data,\n-        _ => tcx.sess.bug(&format!(\"dtor for {:?} is not an impl???\", t))\n+        _ => bug!(\"dtor for {:?} is not an impl???\", t)\n     };\n     let dtor_did = def.destructor().unwrap();\n     bcx = Callee::def(bcx.ccx(), dtor_did, vtbl.substs)\n@@ -482,7 +482,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             (bcx.mul(info, C_uint(bcx.ccx(), unit_size)),\n              C_uint(bcx.ccx(), unit_align))\n         }\n-        _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\", t))\n+        _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }\n }\n "}, {"sha": "4d18e3bd4958ff971c8323ba8c73c1d46688d137", "filename": "src/librustc_trans/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Finline.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -102,16 +102,16 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n                 }\n                 hir::ItemStruct(ref struct_def, _) => {\n                     if struct_def.is_struct() {\n-                        ccx.sess().bug(\"instantiate_inline: called on a \\\n-                                                                 non-tuple struct\")\n+                        bug!(\"instantiate_inline: called on a \\\n+                              non-tuple struct\")\n                     } else {\n                         ccx.external().borrow_mut().insert(fn_id, Some(struct_def.id()));\n                         ccx.external_srcs().borrow_mut().insert(struct_def.id(), fn_id);\n                         my_id = struct_def.id();\n                     }\n                 }\n-                _ => ccx.sess().bug(\"instantiate_inline: item has a \\\n-                                 non-enum, non-struct parent\")\n+                _ => bug!(\"instantiate_inline: item has a \\\n+                           non-enum, non-struct parent\")\n             }\n             my_id\n         }"}, {"sha": "219f970835a4a305283424107d808637bb65fc17", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -188,7 +188,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let sig = tcx.erase_late_bound_regions(&fty.sig);\n             (def_id, substs, infer::normalize_associated_type(tcx, &sig))\n         }\n-        _ => unreachable!(\"expected fn item type, found {}\", callee_ty)\n+        _ => bug!(\"expected fn item type, found {}\", callee_ty)\n     };\n     let arg_tys = sig.inputs;\n     let ret_ty = sig.output;\n@@ -311,7 +311,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n \n             _ => {\n-                ccx.sess().bug(\"expected expr as argument for transmute\");\n+                bug!(\"expected expr as argument for transmute\");\n             }\n         }\n     }\n@@ -323,7 +323,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     if name == \"move_val_init\" {\n         if let callee::ArgExprs(ref exprs) = args {\n             let (dest_expr, source_expr) = if exprs.len() != 2 {\n-                ccx.sess().bug(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n+                bug!(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n             } else {\n                 (&exprs[0], &exprs[1])\n             };\n@@ -350,7 +350,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n             return Result::new(bcx, llresult);\n         } else {\n-            ccx.sess().bug(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n+            bug!(\"expected two exprs as arguments for `move_val_init` intrinsic\");\n         }\n     }\n \n@@ -388,7 +388,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let ret_ty = match ret_ty {\n         ty::FnConverging(ret_ty) => ret_ty,\n-        ty::FnDiverging => unreachable!()\n+        ty::FnDiverging => bug!()\n     };\n \n     let llret_ty = type_of::type_of(ccx, ret_ty);\n@@ -651,7 +651,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                             } else {\n                                 URem(bcx, llargs[0], llargs[1], call_debug_location)\n                             },\n-                        _ => unreachable!(),\n+                        _ => bug!(),\n                     },\n                 None => {\n                     span_invalid_monomorphization_error(\n@@ -674,7 +674,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         \"fmul_fast\" => FMulFast(bcx, llargs[0], llargs[1], call_debug_location),\n                         \"fdiv_fast\" => FDivFast(bcx, llargs[0], llargs[1], call_debug_location),\n                         \"frem_fast\" => FRemFast(bcx, llargs[0], llargs[1], call_debug_location),\n-                        _ => unreachable!(),\n+                        _ => bug!(),\n                     },\n                 None => {\n                     span_invalid_monomorphization_error(\n@@ -820,7 +820,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, _) => {\n             let intr = match Intrinsic::find(&name) {\n                 Some(intr) => intr,\n-                None => unreachable!(\"unknown intrinsic '{}'\", name),\n+                None => bug!(\"unknown intrinsic '{}'\", name),\n             };\n             fn one<T>(x: Vec<T>) -> T {\n                 assert_eq!(x.len(), 1);\n@@ -839,7 +839,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         match x {\n                             32 => vec![Type::f32(ccx)],\n                             64 => vec![Type::f64(ccx)],\n-                            _ => unreachable!()\n+                            _ => bug!()\n                         }\n                     }\n                     Pointer(ref t, ref llvm_elem, _const) => {\n@@ -1242,7 +1242,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             Some(did) => {\n                 Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n             }\n-            None => ccx.sess().bug(\"eh_personality_catch not defined\"),\n+            None => bug!(\"eh_personality_catch not defined\"),\n         };\n \n         let then = bcx.fcx.new_temp_block(\"then\");\n@@ -1357,7 +1357,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         Some(did) => {\n             Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n         }\n-        None => ccx.sess().bug(\"msvc_try_filter not defined\"),\n+        None => bug!(\"msvc_try_filter not defined\"),\n     };\n \n     let output = ty::FnOutput::FnConverging(tcx.types.i32);\n@@ -1417,7 +1417,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n             do_trans(bcx, exn, rbp);\n         })\n     } else {\n-        panic!(\"unknown target to generate a filter function\")\n+        bug!(\"unknown target to generate a filter function\")\n     }\n }\n \n@@ -1513,8 +1513,8 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n     if name.starts_with(\"simd_shuffle\") {\n         let n: usize = match name[\"simd_shuffle\".len()..].parse() {\n             Ok(n) => n,\n-            Err(_) => tcx.sess.span_bug(span,\n-                                        \"bad `simd_shuffle` instruction only caught in trans?\")\n+            Err(_) => span_bug!(span,\n+                                \"bad `simd_shuffle` instruction only caught in trans?\")\n         };\n \n         require_simd!(ret_ty, \"return\");\n@@ -1687,7 +1687,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n         simd_or: TyUint, TyInt => Or;\n         simd_xor: TyUint, TyInt => Xor;\n     }\n-    bcx.sess().span_bug(span, \"unknown SIMD intrinsic\");\n+    span_bug!(span, \"unknown SIMD intrinsic\");\n }\n \n // Returns the width of an int TypeVariant, and if it's signed or not\n@@ -1701,7 +1701,7 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n                 match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n                     \"32\" => 32,\n                     \"64\" => 64,\n-                    tws => panic!(\"Unsupported target word size for isize: {}\", tws),\n+                    tws => bug!(\"Unsupported target word size for isize: {}\", tws),\n                 }\n             },\n             ast::IntTy::I8 => 8,\n@@ -1714,7 +1714,7 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n                 match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n                     \"32\" => 32,\n                     \"64\" => 64,\n-                    tws => panic!(\"Unsupported target word size for usize: {}\", tws),\n+                    tws => bug!(\"Unsupported target word size for usize: {}\", tws),\n                 }\n             },\n             ast::UintTy::U8 => 8,"}, {"sha": "8c6a68cfcf11032706d1f33f171aebeb571ed056", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -43,7 +43,7 @@ extern crate flate;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n-extern crate rustc;\n+#[macro_use] extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n extern crate rustc_front;"}, {"sha": "82b61e15f2bfe1561d04dfc1c80979519eb3a9e3", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -186,15 +186,13 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 // this would imply that the Self type being erased is\n                 // an object type; this cannot happen because we\n                 // cannot cast an unsized type into a trait object\n-                tcx.sess.bug(\n-                    &format!(\"cannot get vtable for an object type: {:?}\",\n-                            data));\n+                bug!(\"cannot get vtable for an object type: {:?}\",\n+                     data);\n             }\n             traits::VtableParam(..) => {\n-                tcx.sess.bug(\n-                    &format!(\"resolved vtable for {:?} to bad vtable {:?} in trans\",\n-                            trait_ref,\n-                            vtable));\n+                bug!(\"resolved vtable for {:?} to bad vtable {:?} in trans\",\n+                     trait_ref,\n+                     vtable);\n             }\n         }\n     });\n@@ -229,8 +227,8 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let trt_id = match tcx.impl_trait_ref(impl_id) {\n         Some(t_id) => t_id.def_id,\n-        None       => ccx.sess().bug(\"make_impl_vtable: don't know how to \\\n-                                      make a vtable for a type impl!\")\n+        None       => bug!(\"make_impl_vtable: don't know how to \\\n+                            make a vtable for a type impl!\")\n     };\n \n     tcx.populate_implementations_for_trait_if_necessary(trt_id);\n@@ -256,7 +254,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             let trait_method_type = match tcx.impl_or_trait_item(trait_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n-                _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n+                _ => bug!(\"should be a method, not other assoc item\"),\n             };\n             let name = trait_method_type.name;\n \n@@ -330,7 +328,7 @@ pub fn get_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n             }\n         }\n         None => {\n-            tcx.sess.bug(&format!(\"method {:?} not found in {:?}\", name, impl_def_id))\n+            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n         }\n     }\n }"}, {"sha": "cbe21664d28a75bfca0d86435df8265111eec53f", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -166,7 +166,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             ty: callee.ty\n                         }, f.abi, &f.sig)\n                     }\n-                    _ => unreachable!(\"{} is not callable\", callee.ty)\n+                    _ => bug!(\"{} is not callable\", callee.ty)\n                 };\n \n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n@@ -295,7 +295,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         return;\n                     }\n                     Fn(f) => f,\n-                    Virtual(_) => unreachable!(\"Virtual fn ptr not extracted\")\n+                    Virtual(_) => bug!(\"Virtual fn ptr not extracted\")\n                 };\n \n                 // Many different ways to call a function handled here\n@@ -417,7 +417,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n             Immediate(llval) => (llval, false),\n             Ref(llval) => (llval, true),\n-            FatPtr(_, _) => unreachable!(\"fat pointers handled above\")\n+            FatPtr(_, _) => bug!(\"fat pointers handled above\")\n         };\n \n         if by_ref && !arg.is_indirect() {\n@@ -470,9 +470,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let lv_ty = lv.ty.to_ty(bcx.tcx());\n         let result_types = match lv_ty.sty {\n             ty::TyTuple(ref tys) => tys,\n-            _ => bcx.tcx().sess.span_bug(\n+            _ => span_bug!(\n                 self.mir.span,\n-                &format!(\"bad final argument to \\\"rust-call\\\" fn {:?}\", lv_ty))\n+                \"bad final argument to \\\"rust-call\\\" fn {:?}\", lv_ty)\n         };\n \n         let base_repr = adt::represent_type(bcx.ccx(), lv_ty);"}, {"sha": "cf85595c08e961053db44534dd32d22b9f9c91cb", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -89,10 +89,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             ConstVal::Struct(_) | ConstVal::Tuple(_) |\n             ConstVal::Array(..) | ConstVal::Repeat(..) |\n             ConstVal::Function(_) => {\n-                unreachable!(\"MIR must not use {:?} (which refers to a local ID)\", cv)\n+                bug!(\"MIR must not use {:?} (which refers to a local ID)\", cv)\n             }\n             ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n-            ConstVal::Dummy => unreachable!(),\n+            ConstVal::Dummy => bug!(),\n         }\n     }\n "}, {"sha": "c9087181f9ddcea7d0b3db273dae8adaa64264a6", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -81,7 +81,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 assert!(lvalue.llextra != ptr::null_mut());\n                 lvalue.llextra\n             }\n-            _ => bcx.sess().bug(\"unexpected type in lvalue_len\"),\n+            _ => bug!(\"unexpected type in lvalue_len\"),\n         }\n     }\n \n@@ -100,7 +100,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 TempRef::Lvalue(lvalue) =>\n                     lvalue,\n                 TempRef::Operand(..) =>\n-                    tcx.sess.bug(&format!(\"using operand temp {:?} as lvalue\", lvalue)),\n+                    bug!(\"using operand temp {:?} as lvalue\", lvalue),\n             },\n             mir::Lvalue::Arg(index) => self.args[index as usize],\n             mir::Lvalue::Static(def_id) => {"}, {"sha": "a7e57fc714b92b3d24a5fd4e7b5520a5e0d5d2a9", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -180,7 +180,7 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n \n             let tupled_arg_tys = match arg_ty.sty {\n                 ty::TyTuple(ref tys) => tys,\n-                _ => unreachable!(\"spread argument isn't a tuple?!\")\n+                _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n             let lltemp = bcx.with_block(|bcx| {"}, {"sha": "c15d6cd5b2440929536cf4a4030a9ac8b74e705d", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> OperandRef<'tcx> {\n     pub fn immediate(self) -> ValueRef {\n         match self.val {\n             OperandValue::Immediate(s) => s,\n-            _ => unreachable!()\n+            _ => bug!()\n         }\n     }\n }\n@@ -124,8 +124,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             return o;\n                         }\n                         TempRef::Operand(None) => {\n-                            bcx.tcx().sess.bug(\n-                                &format!(\"use of {:?} before def\", lvalue));\n+                            bug!(\"use of {:?} before def\", lvalue);\n                         }\n                         TempRef::Lvalue(..) => {\n                             // use path below"}, {"sha": "3f7a6c5f180451f3ae669f7423347dc7f9d68c42", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -70,7 +70,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let operand = self.trans_operand(&bcx, source);\n                 bcx.with_block(|bcx| {\n                     match operand.val {\n-                        OperandValue::FatPtr(..) => unreachable!(),\n+                        OperandValue::FatPtr(..) => bug!(),\n                         OperandValue::Immediate(llval) => {\n                             // unsize from an immediate structure. We don't\n                             // really need a temporary alloca here, but\n@@ -185,7 +185,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     ty::TySlice(_) | ty::TyStr => {\n                         (bcx.gepi(input.llval, &[from_start]), input.llextra)\n                     }\n-                    _ => unreachable!(\"cannot slice {}\", ty)\n+                    _ => bug!(\"cannot slice {}\", ty)\n                 };\n                 let adj = C_uint(ccx, from_start + from_end);\n                 let lllen1 = bcx.sub(lllen, adj);\n@@ -246,7 +246,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                         .reify(bcx.ccx()).val)\n                             }\n                             _ => {\n-                                unreachable!(\"{} cannot be reified to a fn ptr\", operand.ty)\n+                                bug!(\"{} cannot be reified to a fn ptr\", operand.ty)\n                             }\n                         }\n                     }\n@@ -279,9 +279,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 OperandValue::FatPtr(lldata, llextra)\n                             }\n                             OperandValue::Ref(_) => {\n-                                bcx.sess().bug(\n-                                    &format!(\"by-ref operand {:?} in trans_rvalue_operand\",\n-                                             operand));\n+                                bug!(\"by-ref operand {:?} in trans_rvalue_operand\",\n+                                     operand);\n                             }\n                         }\n                     }\n@@ -341,9 +340,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 bcx.fptosi(llval, ll_t_out),\n                             (CastTy::Float, CastTy::Int(_)) =>\n                                 bcx.fptoui(llval, ll_t_out),\n-                            _ => bcx.ccx().sess().bug(\n-                                &format!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n-                            )\n+                            _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n                         };\n                         OperandValue::Immediate(newval)\n                     }\n@@ -364,7 +361,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 OperandValue::Immediate(llval)\n                             }\n                         } else {\n-                            panic!(\"Unexpected non-FatPtr operand\")\n+                            bug!(\"Unexpected non-FatPtr operand\")\n                         }\n                     }\n                 };\n@@ -425,7 +422,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                        DebugLoc::None)\n                             })\n                         }\n-                        _ => unreachable!()\n+                        _ => bug!()\n                     }\n \n                 } else {\n@@ -489,7 +486,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::Aggregate(..) |\n             mir::Rvalue::Slice { .. } |\n             mir::Rvalue::InlineAsm { .. } => {\n-                bcx.tcx().sess.bug(&format!(\"cannot generate operand from rvalue {:?}\", rvalue));\n+                bug!(\"cannot generate operand from rvalue {:?}\", rvalue);\n+\n             }\n         }\n     }"}, {"sha": "1d85ac6fb796074867e003d5b158a4cb78ff1703", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -36,9 +36,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 bcx\n                             }\n                             TempRef::Operand(Some(_)) => {\n-                                bcx.tcx().sess.span_bug(\n-                                    statement.span,\n-                                    &format!(\"operand {:?} already assigned\", rvalue));\n+                                span_bug!(statement.span,\n+                                          \"operand {:?} already assigned\",\n+                                          rvalue);\n                             }\n                         }\n                     }"}, {"sha": "554e1948fe9de2e729df0bed93189503ceefd685", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -149,13 +149,13 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     Disr::from(inlined_variant_def(ccx, fn_node_id).disr_val)\n                 }\n                 hir_map::NodeStructCtor(_) => Disr(0),\n-                _ => unreachable!()\n+                _ => bug!()\n             };\n             attributes::inline(lldecl, attributes::InlineAttr::Hint);\n             base::trans_ctor_shim(ccx, fn_node_id, disr, psubsts, lldecl);\n         }\n \n-        _ => unreachable!(\"can't monomorphize a {:?}\", map_node)\n+        _ => bug!(\"can't monomorphize a {:?}\", map_node)\n     };\n \n     ccx.monomorphizing().borrow_mut().insert(fn_id, depth);"}, {"sha": "b9af02ac529f513f1d75cea9e6e3906fc1f7a4dd", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -183,8 +183,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     }\n                 }\n                 _ => {\n-                    bcx.tcx().sess.span_bug(content_expr.span,\n-                                            \"unexpected evec content\");\n+                    span_bug!(content_expr.span, \"unexpected evec content\");\n                 }\n             }\n         }\n@@ -236,8 +235,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(content_expr.span,\n-                                    \"unexpected vec content\");\n+            span_bug!(content_expr.span, \"unexpected vec content\");\n         }\n     }\n }\n@@ -264,17 +262,15 @@ fn elements_required(bcx: Block, content_expr: &hir::Expr) -> usize {\n             match lit.node {\n                 ast::LitKind::Str(ref s, _) => s.len(),\n                 _ => {\n-                    bcx.tcx().sess.span_bug(content_expr.span,\n-                                            \"unexpected evec content\")\n+                    span_bug!(content_expr.span, \"unexpected evec content\")\n                 }\n             }\n         },\n         hir::ExprVec(ref es) => es.len(),\n         hir::ExprRepeat(_, ref count_expr) => {\n             eval_repeat_count(bcx.tcx(), &count_expr)\n         }\n-        _ => bcx.tcx().sess.span_bug(content_expr.span,\n-                                     \"unexpected vec content\")\n+        _ => span_bug!(content_expr.span, \"unexpected vec content\")\n     }\n }\n \n@@ -298,8 +294,6 @@ pub fn get_base_and_len<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     llval: ValueRef,\n                                     vec_ty: Ty<'tcx>)\n                                     -> (ValueRef, ValueRef) {\n-    let ccx = bcx.ccx();\n-\n     match vec_ty.sty {\n         ty::TyArray(_, n) => get_fixed_base_and_len(bcx, llval, n),\n         ty::TySlice(_) | ty::TyStr => {\n@@ -317,7 +311,7 @@ pub fn get_base_and_len<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n             get_base_and_len(bcx, inner, ty)\n         },\n-        _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n+        _ => bug!(\"unexpected type in get_base_and_len\"),\n     }\n }\n "}, {"sha": "35a60cd5422b40ac0dcc5be1a1aa6876c0bbbb89", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -124,7 +124,7 @@ impl Type {\n         match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n             \"32\" => Type::i32(ccx),\n             \"64\" => Type::i64(ccx),\n-            tws => panic!(\"Unsupported target word size for int: {}\", tws),\n+            tws => bug!(\"Unsupported target word size for int: {}\", tws),\n         }\n     }\n \n@@ -288,7 +288,7 @@ impl Type {\n             Double => 64,\n             X86_FP80 => 80,\n             FP128 | PPC_FP128 => 128,\n-            _ => panic!(\"llvm_float_width called on a non-float type\")\n+            _ => bug!(\"llvm_float_width called on a non-float type\")\n         }\n     }\n "}, {"sha": "8b1aaafab58ed243de3f5b953ece999994595b50", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -113,10 +113,9 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         }\n \n         ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) | ty::TyError => {\n-            cx.sess().bug(&format!(\"fictitious type {:?} in sizing_type_of()\",\n-                                   t))\n+            bug!(\"fictitious type {:?} in sizing_type_of()\", t)\n         }\n-        ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => unreachable!()\n+        ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => bug!()\n     };\n \n     debug!(\"--> mapped t={:?} to llsizingty={:?}\", t, llsizingty);\n@@ -132,7 +131,7 @@ fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type\n             Type::uint_from_ty(ccx, ast::UintTy::Us)\n         }\n         ty::TyTrait(_) => Type::vtable_ptr(ccx),\n-        _ => unreachable!(\"Unexpected tail in unsized_info_ty: {:?} for ty={:?}\",\n+        _ => bug!(\"Unexpected tail in unsized_info_ty: {:?} for ty={:?}\",\n                           unsized_part, ty)\n     }\n }\n@@ -296,10 +295,10 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           }\n       }\n \n-      ty::TyInfer(..) => cx.sess().bug(\"type_of with TyInfer\"),\n-      ty::TyProjection(..) => cx.sess().bug(\"type_of with TyProjection\"),\n-      ty::TyParam(..) => cx.sess().bug(\"type_of with ty_param\"),\n-      ty::TyError => cx.sess().bug(\"type_of with TyError\"),\n+      ty::TyInfer(..) => bug!(\"type_of with TyInfer\"),\n+      ty::TyProjection(..) => bug!(\"type_of with TyProjection\"),\n+      ty::TyParam(..) => bug!(\"type_of with ty_param\"),\n+      ty::TyError => bug!(\"type_of with TyError\"),\n     };\n \n     debug!(\"--> mapped t={:?} to llty={:?}\", t, llty);"}, {"sha": "d925ff9fa3cf60afe16e450bf6736f7a35b5dade", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -161,7 +161,7 @@ pub fn ast_region_to_region(tcx: &TyCtxt, lifetime: &hir::Lifetime)\n     let r = match tcx.named_region_map.get(&lifetime.id) {\n         None => {\n             // should have been recorded by the `resolve_lifetime` pass\n-            tcx.sess.span_bug(lifetime.span, \"unresolved lifetime\");\n+            span_bug!(lifetime.span, \"unresolved lifetime\");\n         }\n \n         Some(&rl::DefStaticRegion) => {\n@@ -485,7 +485,7 @@ fn create_substs_for_ast_path<'tcx>(\n                 substs.types.push(TypeSpace, default);\n             }\n         } else {\n-            tcx.sess.span_bug(span, \"extra parameter without default\");\n+            span_bug!(span, \"extra parameter without default\");\n         }\n     }\n \n@@ -839,7 +839,7 @@ fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n         Err(ErrorReported) => {\n             // No convenient way to recover from a cycle here. Just bail. Sorry!\n             this.tcx().sess.abort_if_errors();\n-            this.tcx().sess.bug(\"ErrorReported returned, but no errors reports?\")\n+            bug!(\"ErrorReported returned, but no errors reports?\")\n         }\n     };\n \n@@ -1353,7 +1353,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                       .expect(\"missing associated type\");\n                 tcx.map.local_def_id(item.id)\n             }\n-            _ => unreachable!()\n+            _ => bug!()\n         }\n     } else {\n         let trait_items = tcx.trait_items(trait_did);\n@@ -1496,7 +1496,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     ty\n                 }\n             } else {\n-                tcx.sess.span_bug(span, \"self type has not been fully resolved\")\n+                span_bug!(span, \"self type has not been fully resolved\")\n             }\n         }\n         Def::SelfTy(Some(_), None) => {\n@@ -1654,7 +1654,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     depth: path.segments.len()\n                 }\n             } else {\n-                tcx.sess.span_bug(ast_ty.span, &format!(\"unbound path {:?}\", ast_ty))\n+                span_bug!(ast_ty.span, \"unbound path {:?}\", ast_ty)\n             };\n             let def = path_res.base_def;\n             let base_ty_end = path.segments.len() - path_res.depth;\n@@ -1961,7 +1961,7 @@ pub fn ty_of_closure<'tcx>(\n             ty::FnConverging(this.ty_infer(None, None, None, decl.output.span())),\n         hir::Return(ref output) =>\n             ty::FnConverging(ast_ty_to_ty(this, &rb, &output)),\n-        hir::DefaultReturn(..) => unreachable!(),\n+        hir::DefaultReturn(..) => bug!(),\n         hir::NoReturn(..) => ty::FnDiverging\n     };\n "}, {"sha": "6dad3ff850ba74409ad395958ae50570d4cc7ad2", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -413,8 +413,7 @@ fn check_assoc_item_is_const(pcx: &pat_ctxt, def: Def, span: Span) -> bool {\n             false\n         }\n         _ => {\n-            pcx.fcx.ccx.tcx.sess.span_bug(span, \"non-associated item in\n-                                                 check_assoc_item_is_const\");\n+            span_bug!(span, \"non-associated item in check_assoc_item_is_const\");\n         }\n     }\n }\n@@ -588,7 +587,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx hir::Pat,\n     let pat_ty = pcx.fcx.instantiate_type(def.def_id(), path);\n     let item_substs = match pat_ty.sty {\n         ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n-        _ => tcx.sess.span_bug(pat.span, \"struct variant is not an ADT\")\n+        _ => span_bug!(pat.span, \"struct variant is not an ADT\")\n     };\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n     check_struct_pat_fields(pcx, pat.span, fields, variant, &item_substs, etc);"}, {"sha": "bedf4753313fdf3504907e5de31674357037f90b", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -397,7 +397,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                 write_overloaded_call_method_map(fcx, self.call_expr, method_callee);\n             }\n             None => {\n-                fcx.tcx().sess.span_bug(\n+                span_bug!(\n                     self.call_expr.span,\n                     \"failed to find an overloaded call trait for closure call\");\n             }"}, {"sha": "d743a036040d50568039561a2080111186dc2b46", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> CastCheck<'tcx> {\n                             CastError::NeedViaThinPtr => \"a thin pointer\",\n                             CastError::NeedViaInt => \"an integer\",\n                             CastError::NeedViaUsize => \"a usize\",\n-                            _ => unreachable!()\n+                            _ => bug!()\n                         }))\n                     .emit();\n             }"}, {"sha": "70467e2d2dd9f6e5f35ce676a94198c72314c03f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -372,8 +372,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n         let r_borrow = match ty.sty {\n             ty::TyRef(r_borrow, _) => r_borrow,\n-            _ => self.tcx().sess.span_bug(span,\n-                                          &format!(\"expected a ref type, got {:?}\", ty))\n+            _ => span_bug!(span, \"expected a ref type, got {:?}\", ty)\n         };\n         let autoref = Some(AutoPtr(r_borrow, mt_b.mutbl));\n         debug!(\"coerce_borrowed_pointer: succeeded ty={:?} autoderefs={:?} autoref={:?}\","}, {"sha": "1f1bba509e01ecdd4835736a91b248f1445b3f14", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -62,9 +62,9 @@ pub fn check_drop_impl(tcx: &TyCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n             // Destructors only work on nominal types.  This was\n             // already checked by coherence, so we can panic here.\n             let span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n-            tcx.sess.span_bug(\n-                span, &format!(\"should have been rejected by coherence check: {}\",\n-                               dtor_self_type));\n+            span_bug!(span,\n+                      \"should have been rejected by coherence check: {}\",\n+                      dtor_self_type);\n         }\n     }\n }\n@@ -276,8 +276,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n            typ, scope);\n \n     let parent_scope = rcx.tcx().region_maps.opt_encl_scope(scope).unwrap_or_else(|| {\n-        rcx.tcx().sess.span_bug(\n-            span, &format!(\"no enclosing scope found for scope: {:?}\", scope))\n+        span_bug!(span, \"no enclosing scope found for scope: {:?}\", scope)\n     });\n \n     let result = iterate_over_potentially_unsafe_regions_in_type(\n@@ -493,7 +492,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n         }\n \n         // these are always dtorck\n-        ty::TyTrait(..) | ty::TyProjection(_) => unreachable!(),\n+        ty::TyTrait(..) | ty::TyProjection(_) => bug!(),\n     }\n }\n "}, {"sha": "f90a56965397218628cd1b5d87412f152fc73448", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -300,10 +300,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         match result {\n             Some(r) => r,\n             None => {\n-                self.tcx().sess.span_bug(\n+                span_bug!(\n                     self.span,\n-                    &format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n-                            self_ty))\n+                    \"self-type `{}` for ObjectPick never dereferenced to an object\",\n+                    self_ty)\n             }\n         }\n     }\n@@ -372,10 +372,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         match self.fcx.mk_subty(false, TypeOrigin::Misc(self.span), self_ty, method_self_ty) {\n             Ok(_) => {}\n             Err(_) => {\n-                self.tcx().sess.span_bug(\n+                span_bug!(\n                     self.span,\n-                    &format!(\"{} was a subtype of {} but now is not?\",\n-                             self_ty, method_self_ty));\n+                    \"{} was a subtype of {} but now is not?\",\n+                    self_ty, method_self_ty);\n             }\n         }\n     }\n@@ -550,15 +550,15 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                 }))\n                             }\n                             Some(_) => {\n-                                self.tcx().sess.span_bug(\n+                                span_bug!(\n                                     base_expr.span,\n-                                    &format!(\"unexpected adjustment autoref {:?}\",\n-                                            adr));\n+                                    \"unexpected adjustment autoref {:?}\",\n+                                    adr);\n                             }\n                         },\n                         None => (0, None),\n                         Some(_) => {\n-                            self.tcx().sess.span_bug(\n+                            span_bug!(\n                                 base_expr.span,\n                                 \"unexpected adjustment type\");\n                         }\n@@ -646,12 +646,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // must be exactly one trait ref or we'd get an ambig error etc\n         if upcast_trait_refs.len() != 1 {\n-            self.tcx().sess.span_bug(\n+            span_bug!(\n                 self.span,\n-                &format!(\"cannot uniquely upcast `{:?}` to `{:?}`: `{:?}`\",\n-                         source_trait_ref,\n-                         target_trait_def_id,\n-                         upcast_trait_refs));\n+                \"cannot uniquely upcast `{:?}` to `{:?}`: `{:?}`\",\n+                source_trait_ref,\n+                target_trait_def_id,\n+                upcast_trait_refs);\n         }\n \n         upcast_trait_refs.into_iter().next().unwrap()"}, {"sha": "43a18d2c1024f417657cde88ad7c4d312b777303", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -302,21 +302,19 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         }\n \n                         _ => {\n-                            fcx.tcx().sess.span_bug(\n+                            span_bug!(\n                                 span,\n-                                &format!(\n-                                    \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty));\n+                                \"trait method is &self but first arg is: {}\",\n+                                transformed_self_ty);\n                         }\n                     }\n                 }\n \n                 _ => {\n-                    fcx.tcx().sess.span_bug(\n+                    span_bug!(\n                         span,\n-                        &format!(\n-                            \"unexpected explicit self type in operator method: {:?}\",\n-                            method_ty.explicit_self));\n+                        \"unexpected explicit self type in operator method: {:?}\",\n+                        method_ty.explicit_self);\n                 }\n             }\n         }"}, {"sha": "c4a8022071bf8877ecfdae715fe012795d14d81a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -877,8 +877,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                         match tcx.trait_id_of_impl(impl_id) {\n                             Some(id) => id,\n                             None =>\n-                                tcx.sess.span_bug(span,\n-                                                  \"found inherent method when looking at traits\")\n+                                span_bug!(span,\n+                                          \"found inherent method when looking at traits\")\n                         }\n                     }\n                 }\n@@ -889,7 +889,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             }\n             Some(Err(MethodError::ClosureAmbiguity(..))) => {\n                 // this error only occurs when assembling candidates\n-                tcx.sess.span_bug(span, \"encountered ClosureAmbiguity from pick_core\");\n+                span_bug!(span, \"encountered ClosureAmbiguity from pick_core\");\n             }\n             _ => vec![],\n         };"}, {"sha": "6c3469c9d7245edc46eadafc26662b234fc78453", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -463,8 +463,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             regionck::regionck_fn(&fcx, fn_id, fn_span, decl, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n-        _ => ccx.tcx.sess.impossible_case(body.span,\n-                                 \"check_bare_fn: function type expected\")\n+        _ => span_bug!(body.span, \"check_bare_fn: function type expected\")\n     }\n }\n \n@@ -946,7 +945,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 hir::ImplItemKind::Const(..) => {\n                     let impl_const = match ty_impl_item {\n                         ty::ConstTraitItem(ref cti) => cti,\n-                        _ => tcx.sess.span_bug(impl_item.span, \"non-const impl-item for const\")\n+                        _ => span_bug!(impl_item.span, \"non-const impl-item for const\")\n                     };\n \n                     // Find associated const definition.\n@@ -969,7 +968,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n                     let impl_method = match ty_impl_item {\n                         ty::MethodTraitItem(ref mti) => mti,\n-                        _ => tcx.sess.span_bug(impl_item.span, \"non-method impl-item for method\")\n+                        _ => span_bug!(impl_item.span, \"non-method impl-item for method\")\n                     };\n \n                     if let &ty::MethodTraitItem(ref trait_method) = ty_trait_item {\n@@ -990,7 +989,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 hir::ImplItemKind::Type(_) => {\n                     let impl_type = match ty_impl_item {\n                         ty::TypeTraitItem(ref tti) => tti,\n-                        _ => tcx.sess.span_bug(impl_item.span, \"non-type impl-item for type\")\n+                        _ => span_bug!(impl_item.span, \"non-type impl-item for type\")\n                     };\n \n                     if let &ty::TypeTraitItem(ref at) = ty_trait_item {\n@@ -1567,8 +1566,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match self.inh.tables.borrow().node_types.get(&ex.id) {\n             Some(&t) => t,\n             None => {\n-                self.tcx().sess.bug(&format!(\"no type for expr in fcx {}\",\n-                                            self.tag()));\n+                bug!(\"no type for expr in fcx {}\", self.tag());\n             }\n         }\n     }\n@@ -1593,10 +1591,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(&t) => t,\n             None if self.err_count_since_creation() != 0 => self.tcx().types.err,\n             None => {\n-                self.tcx().sess.bug(\n-                    &format!(\"no type for node {}: {} in fcx {}\",\n-                            id, self.tcx().map.node_to_string(id),\n-                            self.tag()));\n+                bug!(\"no type for node {}: {} in fcx {}\",\n+                     id, self.tcx().map.node_to_string(id),\n+                     self.tag());\n             }\n         }\n     }\n@@ -2386,8 +2383,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 fty.sig.0.output\n             }\n             _ => {\n-                fcx.tcx().sess.span_bug(callee_expr.span,\n-                                        \"method without bare fn type\");\n+                span_bug!(callee_expr.span, \"method without bare fn type\");\n             }\n         }\n     }\n@@ -3139,7 +3135,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let tcx = fcx.ccx.tcx;\n         let substs = match adt_ty.sty {\n             ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n-            _ => tcx.sess.span_bug(span, \"non-ADT passed to check_expr_struct_fields\")\n+            _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n \n         let mut remaining_fields = FnvHashMap();\n@@ -3400,8 +3396,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     depth: path.segments.len()\n                 }\n             } else {\n-              tcx.sess.span_bug(expr.span,\n-                                &format!(\"unbound path {:?}\", expr))\n+              span_bug!(expr.span, \"unbound path {:?}\", expr)\n           };\n \n           if let Some((opt_ty, segments, def)) =\n@@ -4224,7 +4219,7 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Def::Label(..) |\n         Def::SelfTy(..) |\n         Def::Err => {\n-            fcx.ccx.tcx.sess.span_bug(sp, &format!(\"expected value, found {:?}\", defn));\n+            span_bug!(sp, \"expected value, found {:?}\", defn);\n         }\n     }\n }\n@@ -4485,11 +4480,10 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let impl_ty = fcx.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n         if fcx.mk_subty(false, TypeOrigin::Misc(span), self_ty, impl_ty).is_err() {\n-            fcx.tcx().sess.span_bug(span,\n-            &format!(\n+            span_bug!(span,\n                 \"instantiate_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n                 self_ty,\n-                impl_ty));\n+                impl_ty);\n         }\n     }\n "}, {"sha": "494135ee3ffb14e5d531b3a30aafd3bea9b1b2b6", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -270,8 +270,9 @@ fn name_and_trait_def_id(fcx: &FnCtxt,\n             hir::BiShr => (\"shr_assign\", lang.shr_assign_trait()),\n             hir::BiLt | hir::BiLe | hir::BiGe | hir::BiGt | hir::BiEq | hir::BiNe | hir::BiAnd |\n             hir::BiOr => {\n-                fcx.tcx().sess.span_bug(op.span, &format!(\"impossible assignment operation: {}=\",\n-                                        hir_util::binop_to_string(op.node)))\n+                span_bug!(op.span,\n+                          \"impossible assignment operation: {}=\",\n+                          hir_util::binop_to_string(op.node))\n             }\n         }\n     } else {\n@@ -293,7 +294,7 @@ fn name_and_trait_def_id(fcx: &FnCtxt,\n             hir::BiEq => (\"eq\", lang.eq_trait()),\n             hir::BiNe => (\"ne\", lang.eq_trait()),\n             hir::BiAnd | hir::BiOr => {\n-                fcx.tcx().sess.span_bug(op.span, \"&& and || are not overloadable\")\n+                span_bug!(op.span, \"&& and || are not overloadable\")\n             }\n         }\n     }"}, {"sha": "283245bd6f46a0b903d8702481ebdcbfcb9049e0", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -298,8 +298,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             match fn_sig_map.get(&id) {\n                 Some(f) => f.clone(),\n                 None => {\n-                    self.tcx().sess.bug(\n-                        &format!(\"No fn-sig entry for id={}\", id));\n+                    bug!(\"No fn-sig entry for id={}\", id);\n                 }\n             }\n         };\n@@ -446,8 +445,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         let subject_node_id = match self.subject {\n             Subject(s) => s,\n             SubjectNode::None => {\n-                self.tcx().sess.bug(\"cannot resolve_regions_and_report_errors \\\n-                                     without subject node\");\n+                bug!(\"cannot resolve_regions_and_report_errors \\\n+                      without subject node\");\n             }\n         };\n \n@@ -886,9 +885,10 @@ fn constrain_callee(rcx: &mut Rcx,\n             // this should not happen, but it does if the program is\n             // erroneous\n             //\n-            // tcx.sess.span_bug(\n+            // bug!(\n             //     callee_expr.span,\n-            //     format!(\"Calling non-function: {}\", callee_ty));\n+            //     \"Calling non-function: {}\",\n+            //     callee_ty);\n         }\n     }\n }\n@@ -986,10 +986,10 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 let (m, r) = match self_ty.sty {\n                     ty::TyRef(r, ref m) => (m.mutbl, r),\n                     _ => {\n-                        rcx.tcx().sess.span_bug(\n+                        span_bug!(\n                             deref_expr.span,\n-                            &format!(\"bad overloaded deref type {:?}\",\n-                                     method.ty))\n+                            \"bad overloaded deref type {:?}\",\n+                            method.ty)\n                     }\n                 };\n \n@@ -1014,7 +1014,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                           return_type, r_deref_expr);\n                         return_type\n                     }\n-                    ty::FnDiverging => unreachable!()\n+                    ty::FnDiverging => bug!()\n                 }\n             }\n             None => derefd_ty\n@@ -1057,12 +1057,10 @@ fn check_safety_of_rvalue_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 't\n                 }\n                 ty::ReStatic => {}\n                 region => {\n-                    rcx.tcx()\n-                       .sess\n-                       .span_bug(span,\n-                                 &format!(\"unexpected rvalue region in rvalue \\\n-                                           destructor safety checking: `{:?}`\",\n-                                          region));\n+                    span_bug!(span,\n+                              \"unexpected rvalue region in rvalue \\\n+                               destructor safety checking: `{:?}`\",\n+                              region);\n                 }\n             }\n         }\n@@ -1394,10 +1392,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                     infer::ReborrowUpvar(span, *upvar_id)\n                 }\n                 _ => {\n-                    rcx.tcx().sess.span_bug(\n-                        span,\n-                        &format!(\"Illegal upvar id: {:?}\",\n-                                upvar_id));\n+                    span_bug!( span, \"Illegal upvar id: {:?}\", upvar_id);\n                 }\n             }\n         }"}, {"sha": "7d51d5ec7f74470ded2e157a863b5e24adfc5d9d", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -209,10 +209,10 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         let closure_substs = match self.fcx.node_ty(id).sty {\n             ty::TyClosure(_, ref substs) => substs,\n             ref t => {\n-                self.fcx.tcx().sess.span_bug(\n+                span_bug!(\n                     span,\n-                    &format!(\"type of closure expr {:?} is not a closure {:?}\",\n-                             id, t));\n+                    \"type of closure expr {:?} is not a closure {:?}\",\n+                    id, t);\n             }\n         };\n "}, {"sha": "68c9816b48c3ea4032a0d692fa53bb8c3367effd", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -257,7 +257,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let bare_fn_ty = match item_ty.sty {\n                 ty::TyFnDef(_, _, ref bare_fn_ty) => bare_fn_ty,\n                 _ => {\n-                    this.tcx().sess.span_bug(item.span, \"Fn item without fn type\");\n+                    span_bug!(item.span, \"Fn item without fn type\");\n                 }\n             };\n \n@@ -473,7 +473,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let name = match space {\n             TypeSpace => ast_generics.ty_params[index].name,\n             SelfSpace => special_idents::type_self.name,\n-            FnSpace => self.tcx().sess.bug(\"Fn space occupied?\"),\n+            FnSpace => bug!(\"Fn space occupied?\"),\n         };\n \n         ty::ParamTy { space: space, idx: index as u32, name: name }\n@@ -489,7 +489,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         match space {\n             TypeSpace => ast_generics.ty_params[index].span,\n             SelfSpace => item.span,\n-            FnSpace => self.tcx().sess.span_bug(item.span, \"Fn space occupied?\"),\n+            FnSpace => span_bug!(item.span, \"Fn space occupied?\"),\n         }\n     }\n "}, {"sha": "f9a4cfadc0b11073f880ba70a43d56c0ffcd462d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -77,10 +77,10 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n         TyInfer(..) | TyClosure(..) => {\n             // `ty` comes from a user declaration so we should only expect types\n             // that the user can type\n-            inference_context.tcx.sess.span_bug(\n+            span_bug!(\n                 span,\n-                &format!(\"coherence encountered unexpected type searching for base type: {}\",\n-                         ty));\n+                \"coherence encountered unexpected type searching for base type: {}\",\n+                ty);\n         }\n     }\n }\n@@ -219,9 +219,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 }).collect()\n             }\n             _ => {\n-                self.crate_context.tcx.sess.span_bug(item.span,\n-                                                     \"can't convert a non-impl \\\n-                                                      to an impl\");\n+                span_bug!(item.span, \"can't convert a non-impl to an impl\");\n             }\n         }\n     }\n@@ -263,13 +261,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                           \"the Drop trait may only be implemented on structures\");\n                             }\n                             _ => {\n-                                tcx.sess.bug(\"didn't find impl in ast \\\n-                                              map\");\n+                                bug!(\"didn't find impl in ast map\");\n                             }\n                         }\n                     } else {\n-                        tcx.sess.bug(\"found external impl of Drop trait on \\\n-                                      something other than a struct\");\n+                        bug!(\"found external impl of Drop trait on \\\n+                              :omething other than a struct\");\n                     }\n                 }\n             }"}, {"sha": "59546f619c0ac3b1738164d0ae1c42aac9080136", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -274,7 +274,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         if let Some(trait_id) = tcx.map.as_local_node_id(trait_id) {\n             let item = match tcx.map.get(trait_id) {\n                 hir_map::NodeItem(item) => item,\n-                _ => tcx.sess.bug(&format!(\"get_trait_def({:?}): not an item\", trait_id))\n+                _ => bug!(\"get_trait_def({:?}): not an item\", trait_id)\n             };\n \n             trait_def_of_item(self, &item)\n@@ -1165,13 +1165,13 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n     let superpredicates = superpredicates.unwrap_or_else(|| {\n         let item = match ccx.tcx.map.get(trait_node_id) {\n             hir_map::NodeItem(item) => item,\n-            _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not an item\", trait_node_id))\n+            _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n         };\n \n         let (generics, bounds) = match item.node {\n             hir::ItemTrait(_, ref generics, ref supertraits, _) => (generics, supertraits),\n-            _ => tcx.sess.span_bug(item.span,\n-                                   \"ensure_super_predicates_step invoked on non-trait\"),\n+            _ => span_bug!(item.span,\n+                           \"ensure_super_predicates_step invoked on non-trait\"),\n         };\n \n         // In-scope when converting the superbounds for `Trait` are\n@@ -1237,7 +1237,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let (unsafety, generics, items) = match it.node {\n         hir::ItemTrait(unsafety, ref generics, _, ref items) => (unsafety, generics, items),\n-        _ => tcx.sess.span_bug(it.span, \"trait_def_of_item invoked on non-trait\"),\n+        _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n     let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n@@ -1317,12 +1317,12 @@ fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n {\n     let item = match ccx.tcx.map.get(trait_node_id) {\n         hir_map::NodeItem(item) => item,\n-        _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not an item\", trait_node_id))\n+        _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n     };\n \n     let trait_items = match item.node {\n         hir::ItemTrait(_, _, _, ref trait_items) => trait_items,\n-        _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not a trait\", trait_node_id))\n+        _ => bug!(\"trait_node_id {} is not a trait\", trait_node_id)\n     };\n \n     trait_items.iter().any(|trait_item| {\n@@ -1342,9 +1342,10 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n     let (generics, items) = match it.node {\n         hir::ItemTrait(_, ref generics, _, ref items) => (generics, items),\n         ref s => {\n-            tcx.sess.span_bug(\n+            span_bug!(\n                 it.span,\n-                &format!(\"trait_def_of_item invoked on {:?}\", s));\n+                \"trait_def_of_item invoked on {:?}\",\n+                s);\n         }\n     };\n \n@@ -1421,9 +1422,8 @@ fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 type_scheme_of_foreign_item(ccx, &foreign_item, abi)\n             }\n             x => {\n-                ccx.tcx.sess.bug(&format!(\"unexpected sort of node \\\n-                                           in get_item_type_scheme(): {:?}\",\n-                                          x));\n+                bug!(\"unexpected sort of node in get_item_type_scheme(): {:?}\",\n+                     x);\n             }\n         }\n     } else {\n@@ -1489,10 +1489,10 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         hir::ItemForeignMod(..) |\n         hir::ItemExternCrate(..) |\n         hir::ItemUse(..) => {\n-            tcx.sess.span_bug(\n+            span_bug!(\n                 it.span,\n-                &format!(\"compute_type_scheme_of_item: unexpected item type: {:?}\",\n-                         it.node));\n+                \"compute_type_scheme_of_item: unexpected item type: {:?}\",\n+                it.node);\n         }\n     }\n }\n@@ -1528,10 +1528,10 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         hir::ItemImpl(..) |\n         hir::ItemMod(..) |\n         hir::ItemForeignMod(..) => {\n-            tcx.sess.span_bug(\n+            span_bug!(\n                 it.span,\n-                &format!(\"compute_type_scheme_of_item: unexpected item type: {:?}\",\n-                         it.node));\n+                \"compute_type_scheme_of_item: unexpected item type: {:?}\",\n+                it.node);\n         }\n     };\n \n@@ -1836,9 +1836,9 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n             &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n                 // FIXME(#20041)\n-                tcx.sess.span_bug(eq_pred.span,\n-                                    \"Equality constraints are not yet \\\n-                                        implemented (#20041)\")\n+                span_bug!(eq_pred.span,\n+                         \"Equality constraints are not yet \\\n+                          implemented (#20041)\")\n             }\n         }\n     }"}, {"sha": "fa23445fe630d3824bd5a6839b9e37771e3b9126", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -88,7 +88,7 @@ This API is completely unstable and subject to change.\n \n extern crate arena;\n extern crate fmt_macros;\n-extern crate rustc;\n+#[macro_use] extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_front;\n extern crate rustc_back;\n@@ -258,9 +258,9 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 });\n         }\n         _ => {\n-            tcx.sess.span_bug(main_span,\n-                              &format!(\"main has a non-function type: found `{}`\",\n-                                       main_t));\n+            span_bug!(main_span,\n+                      \"main has a non-function type: found `{}`\",\n+                      main_t);\n         }\n     }\n }\n@@ -310,9 +310,9 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n \n         }\n         _ => {\n-            tcx.sess.span_bug(start_span,\n-                              &format!(\"start has a non-function type: found `{}`\",\n-                                       start_t));\n+            span_bug!(start_span,\n+                      \"start has a non-function type: found `{}`\",\n+                      start_t);\n         }\n     }\n }\n@@ -325,7 +325,7 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n             Some(config::EntryMain) => check_main_fn_ty(ccx, id, sp),\n             Some(config::EntryStart) => check_start_fn_ty(ccx, id, sp),\n             Some(config::EntryNone) => {}\n-            None => tcx.sess.bug(\"entry function without a type\")\n+            None => bug!(\"entry function without a type\")\n         },\n         None => {}\n     }"}, {"sha": "50c99e33b4455125db073d92129f5974045a333a", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af79cf34e1fd6f38ba256631e2997ca650e490b/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=1af79cf34e1fd6f38ba256631e2997ca650e490b", "patch": "@@ -135,9 +135,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         match self.terms_cx.inferred_map.get(&param_id) {\n             Some(&index) => index,\n             None => {\n-                self.tcx().sess.bug(&format!(\n-                        \"no inferred index entry for {}\",\n-                        self.tcx().map.node_to_string(param_id)));\n+                bug!(\"no inferred index entry for {}\",\n+                     self.tcx().map.node_to_string(param_id));\n             }\n         }\n     }\n@@ -148,7 +147,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         match tcx.named_region_map.get(&param_id) {\n             Some(&rl::DefEarlyBoundRegion(_, _, lifetime_decl_id))\n                 => lifetime_decl_id,\n-            Some(_) => panic!(\"should not encounter non early-bound cases\"),\n+            Some(_) => bug!(\"should not encounter non early-bound cases\"),\n \n             // The lookup should only fail when `param_id` is\n             // itself a lifetime binding: use it as the decl_id.\n@@ -173,13 +172,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             assert!(is_lifetime(&tcx.map, param_id));\n             let parent_id = tcx.map.get_parent(decl_id);\n             let parent = tcx.map.find(parent_id).unwrap_or_else(\n-                || panic!(\"tcx.map missing entry for id: {}\", parent_id));\n+                || bug!(\"tcx.map missing entry for id: {}\", parent_id));\n \n             let is_inferred;\n             macro_rules! cannot_happen { () => { {\n-                panic!(\"invalid parent: {} for {}\",\n-                      tcx.map.node_to_string(parent_id),\n-                      tcx.map.node_to_string(param_id));\n+                bug!(\"invalid parent: {} for {}\",\n+                     tcx.map.node_to_string(parent_id),\n+                     tcx.map.node_to_string(param_id));\n             } } }\n \n             match parent {\n@@ -328,7 +327,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyClosure(..) => {\n-                self.tcx().sess.bug(\"Unexpected closure type in variance computation\");\n+                bug!(\"Unexpected closure type in variance computation\");\n             }\n \n             ty::TyRef(region, ref mt) => {\n@@ -440,9 +439,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyInfer(..) => {\n-                self.tcx().sess.bug(\n-                    &format!(\"unexpected type encountered in \\\n-                              variance inference: {}\", ty));\n+                bug!(\"unexpected type encountered in \\\n+                      variance inference: {}\", ty);\n             }\n         }\n     }\n@@ -525,11 +523,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             ty::ReSkolemized(..) | ty::ReEmpty => {\n                 // We don't expect to see anything but 'static or bound\n                 // regions when visiting member types or method types.\n-                self.tcx()\n-                    .sess\n-                    .bug(&format!(\"unexpected region encountered in variance \\\n-                                  inference: {:?}\",\n-                                 region));\n+                bug!(\"unexpected region encountered in variance \\\n+                      inference: {:?}\",\n+                     region);\n             }\n         }\n     }"}]}