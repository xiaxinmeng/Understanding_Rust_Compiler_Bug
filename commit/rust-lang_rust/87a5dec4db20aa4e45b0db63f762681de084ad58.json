{"sha": "87a5dec4db20aa4e45b0db63f762681de084ad58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YTVkZWM0ZGIyMGFhNGU0NWIwZGI2M2Y3NjI2ODFkZTA4NGFkNTg=", "commit": {"author": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-09-22T22:16:16Z"}, "committer": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-09-22T22:16:16Z"}, "message": "Use Self more in core in doc when possible", "tree": {"sha": "27a37329932a41daea1e6e9c2708dba2a28ba25a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27a37329932a41daea1e6e9c2708dba2a28ba25a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87a5dec4db20aa4e45b0db63f762681de084ad58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87a5dec4db20aa4e45b0db63f762681de084ad58", "html_url": "https://github.com/rust-lang/rust/commit/87a5dec4db20aa4e45b0db63f762681de084ad58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87a5dec4db20aa4e45b0db63f762681de084ad58/comments", "author": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "committer": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6e72837fd36f65f7ff73dcf6e915971296a9af8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6e72837fd36f65f7ff73dcf6e915971296a9af8", "html_url": "https://github.com/rust-lang/rust/commit/b6e72837fd36f65f7ff73dcf6e915971296a9af8"}], "stats": {"total": 107, "additions": 55, "deletions": 52}, "files": [{"sha": "cdf742057b7b6f37458e1a009f774f2815dd6127", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87a5dec4db20aa4e45b0db63f762681de084ad58/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a5dec4db20aa4e45b0db63f762681de084ad58/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=87a5dec4db20aa4e45b0db63f762681de084ad58", "patch": "@@ -643,9 +643,9 @@ macro_rules! impls {\n /// }\n ///\n /// impl<R: ResType> ExternalResource<R> {\n-///     fn new() -> ExternalResource<R> {\n+///     fn new() -> Self {\n ///         let size_of_res = mem::size_of::<R>();\n-///         ExternalResource {\n+///         Self {\n ///             resource_handle: foreign_lib::new(size_of_res),\n ///             resource_type: PhantomData,\n ///         }"}, {"sha": "19f86ced5007ceb72e5de4647cb363b21732c231", "filename": "library/core/src/ops/arith.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/87a5dec4db20aa4e45b0db63f762681de084ad58/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a5dec4db20aa4e45b0db63f762681de084ad58/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Farith.rs?ref=87a5dec4db20aa4e45b0db63f762681de084ad58", "patch": "@@ -128,10 +128,10 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// }\n ///\n /// impl Sub for Point {\n-///     type Output = Point;\n+///     type Output = Self;\n ///\n-///     fn sub(self, other: Point) -> Point {\n-///         Point {\n+///     fn sub(self, other: Self) -> Self::Output {\n+///         Self {\n ///             x: self.x - other.x,\n ///             y: self.y - other.y,\n ///         }\n@@ -241,7 +241,7 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///         // Reduce to lowest terms by dividing by the greatest common\n ///         // divisor.\n ///         let gcd = gcd(numerator, denominator);\n-///         Rational {\n+///         Self {\n ///             numerator: numerator / gcd,\n ///             denominator: denominator / gcd,\n ///         }\n@@ -255,7 +255,7 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     fn mul(self, rhs: Self) -> Self {\n ///         let numerator = self.numerator * rhs.numerator;\n ///         let denominator = self.denominator * rhs.denominator;\n-///         Rational::new(numerator, denominator)\n+///         Self::new(numerator, denominator)\n ///     }\n /// }\n ///\n@@ -291,7 +291,7 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     type Output = Self;\n ///\n ///     fn mul(self, rhs: Scalar) -> Self::Output {\n-///         Vector { value: self.value.iter().map(|v| v * rhs.value).collect() }\n+///         Self { value: self.value.iter().map(|v| v * rhs.value).collect() }\n ///     }\n /// }\n ///\n@@ -369,7 +369,7 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///         // Reduce to lowest terms by dividing by the greatest common\n ///         // divisor.\n ///         let gcd = gcd(numerator, denominator);\n-///         Rational {\n+///         Self {\n ///             numerator: numerator / gcd,\n ///             denominator: denominator / gcd,\n ///         }\n@@ -387,7 +387,7 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///\n ///         let numerator = self.numerator * rhs.denominator;\n ///         let denominator = self.denominator * rhs.numerator;\n-///         Rational::new(numerator, denominator)\n+///         Self::new(numerator, denominator)\n ///     }\n /// }\n ///\n@@ -423,7 +423,7 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     type Output = Self;\n ///\n ///     fn div(self, rhs: Scalar) -> Self::Output {\n-///         Vector { value: self.value.iter().map(|v| v / rhs.value).collect() }\n+///         Self { value: self.value.iter().map(|v| v / rhs.value).collect() }\n ///     }\n /// }\n ///\n@@ -515,7 +515,7 @@ div_impl_float! { f32 f64 }\n ///         let len = self.slice.len();\n ///         let rem = len % modulus;\n ///         let start = len - rem;\n-///         SplitSlice {slice: &self.slice[start..]}\n+///         Self {slice: &self.slice[start..]}\n ///     }\n /// }\n ///\n@@ -615,7 +615,7 @@ rem_impl_float! { f32 f64 }\n /// }\n ///\n /// impl Neg for Sign {\n-///     type Output = Sign;\n+///     type Output = Self;\n ///\n ///     fn neg(self) -> Self::Output {\n ///         match self {"}, {"sha": "6120da50c3cdfe4036a3d8c0d1b68cc760fd2eba", "filename": "library/core/src/ops/bit.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/87a5dec4db20aa4e45b0db63f762681de084ad58/library%2Fcore%2Fsrc%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a5dec4db20aa4e45b0db63f762681de084ad58/library%2Fcore%2Fsrc%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fbit.rs?ref=87a5dec4db20aa4e45b0db63f762681de084ad58", "patch": "@@ -15,7 +15,7 @@\n /// }\n ///\n /// impl Not for Answer {\n-///     type Output = Answer;\n+///     type Output = Self;\n ///\n ///     fn not(self) -> Self::Output {\n ///         match self {\n@@ -85,7 +85,7 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n ///     // rhs is the \"right-hand side\" of the expression `a & b`\n ///     fn bitand(self, rhs: Self) -> Self::Output {\n-///         Scalar(self.0 & rhs.0)\n+///         Self(self.0 & rhs.0)\n ///     }\n /// }\n ///\n@@ -106,10 +106,13 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// impl BitAnd for BooleanVector {\n ///     type Output = Self;\n ///\n-///     fn bitand(self, BooleanVector(rhs): Self) -> Self::Output {\n-///         let BooleanVector(lhs) = self;\n+///     fn bitand(self, Self(rhs): Self) -> Self::Output {\n+///         let Self(lhs) = self;\n ///         assert_eq!(lhs.len(), rhs.len());\n-///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x && *y).collect())\n+///         Self(lhs.iter()\n+///                 .zip(rhs.iter())\n+///                 .map(|(x, y)| *x && *y)\n+///                 .collect())\n ///     }\n /// }\n ///\n@@ -179,8 +182,8 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     type Output = Self;\n ///\n ///     // rhs is the \"right-hand side\" of the expression `a | b`\n-///     fn bitor(self, rhs: Self) -> Self {\n-///         Scalar(self.0 | rhs.0)\n+///     fn bitor(self, rhs: Self) -> Self::Output {\n+///         Self(self.0 | rhs.0)\n ///     }\n /// }\n ///\n@@ -201,10 +204,10 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// impl BitOr for BooleanVector {\n ///     type Output = Self;\n ///\n-///     fn bitor(self, BooleanVector(rhs): Self) -> Self::Output {\n-///         let BooleanVector(lhs) = self;\n+///     fn bitor(self, Self(rhs): Self) -> Self::Output {\n+///         let Self(lhs) = self;\n ///         assert_eq!(lhs.len(), rhs.len());\n-///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x || *y).collect())\n+///         Self(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x || *y).collect())\n ///     }\n /// }\n ///\n@@ -275,7 +278,7 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n ///     // rhs is the \"right-hand side\" of the expression `a ^ b`\n ///     fn bitxor(self, rhs: Self) -> Self::Output {\n-///         Scalar(self.0 ^ rhs.0)\n+///         Self(self.0 ^ rhs.0)\n ///     }\n /// }\n ///\n@@ -296,13 +299,13 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// impl BitXor for BooleanVector {\n ///     type Output = Self;\n ///\n-///     fn bitxor(self, BooleanVector(rhs): Self) -> Self::Output {\n-///         let BooleanVector(lhs) = self;\n+///     fn bitxor(self, Self(rhs): Self) -> Self::Output {\n+///         let Self(lhs) = self;\n ///         assert_eq!(lhs.len(), rhs.len());\n-///         BooleanVector(lhs.iter()\n-///                          .zip(rhs.iter())\n-///                          .map(|(x, y)| (*x || *y) && !(*x && *y))\n-///                          .collect())\n+///         Self(lhs.iter()\n+///                 .zip(rhs.iter())\n+///                 .map(|(x, y)| (*x || *y) && !(*x && *y))\n+///                 .collect())\n ///     }\n /// }\n ///\n@@ -375,9 +378,9 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// impl Shl<Scalar> for Scalar {\n ///     type Output = Self;\n ///\n-///     fn shl(self, Scalar(rhs): Self) -> Scalar {\n-///         let Scalar(lhs) = self;\n-///         Scalar(lhs << rhs)\n+///     fn shl(self, Self(rhs): Self) -> Self::Output {\n+///         let Self(lhs) = self;\n+///         Self(lhs << rhs)\n ///     }\n /// }\n ///\n@@ -400,10 +403,10 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     fn shl(self, rhs: usize) -> Self::Output {\n ///         // Rotate the vector by `rhs` places.\n ///         let (a, b) = self.vec.split_at(rhs);\n-///         let mut spun_vector: Vec<T> = vec![];\n+///         let mut spun_vector = vec![];\n ///         spun_vector.extend_from_slice(b);\n ///         spun_vector.extend_from_slice(a);\n-///         SpinVector { vec: spun_vector }\n+///         Self { vec: spun_vector }\n ///     }\n /// }\n ///\n@@ -493,9 +496,9 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n /// impl Shr<Scalar> for Scalar {\n ///     type Output = Self;\n ///\n-///     fn shr(self, Scalar(rhs): Self) -> Scalar {\n-///         let Scalar(lhs) = self;\n-///         Scalar(lhs >> rhs)\n+///     fn shr(self, Self(rhs): Self) -> Self::Output {\n+///         let Self(lhs) = self;\n+///         Self(lhs >> rhs)\n ///     }\n /// }\n ///\n@@ -518,10 +521,10 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n ///     fn shr(self, rhs: usize) -> Self::Output {\n ///         // Rotate the vector by `rhs` places.\n ///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n-///         let mut spun_vector: Vec<T> = vec![];\n+///         let mut spun_vector = vec![];\n ///         spun_vector.extend_from_slice(b);\n ///         spun_vector.extend_from_slice(a);\n-///         SpinVector { vec: spun_vector }\n+///         Self { vec: spun_vector }\n ///     }\n /// }\n ///\n@@ -606,7 +609,7 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n /// impl BitAndAssign for Scalar {\n ///     // rhs is the \"right-hand side\" of the expression `a &= b`\n ///     fn bitand_assign(&mut self, rhs: Self) {\n-///         *self = Scalar(self.0 & rhs.0)\n+///         *self = Self(self.0 & rhs.0)\n ///     }\n /// }\n ///\n@@ -640,11 +643,11 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///     // `rhs` is the \"right-hand side\" of the expression `a &= b`.\n ///     fn bitand_assign(&mut self, rhs: Self) {\n ///         assert_eq!(self.0.len(), rhs.0.len());\n-///         *self = BooleanVector(self.0\n-///                                   .iter()\n-///                                   .zip(rhs.0.iter())\n-///                                   .map(|(x, y)| *x && *y)\n-///                                   .collect());\n+///         *self = Self(self.0\n+///                          .iter()\n+///                          .zip(rhs.0.iter())\n+///                          .map(|(x, y)| *x && *y)\n+///                          .collect());\n ///     }\n /// }\n ///"}, {"sha": "354ad6b7b7333b0cc4a2b42083db8dca7b808738", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87a5dec4db20aa4e45b0db63f762681de084ad58/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87a5dec4db20aa4e45b0db63f762681de084ad58/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=87a5dec4db20aa4e45b0db63f762681de084ad58", "patch": "@@ -49,18 +49,18 @@\n //! }\n //!\n //! impl Add for Point {\n-//!     type Output = Point;\n+//!     type Output = Self;\n //!\n-//!     fn add(self, other: Point) -> Point {\n-//!         Point {x: self.x + other.x, y: self.y + other.y}\n+//!     fn add(self, other: Self) -> Self {\n+//!         Self {x: self.x + other.x, y: self.y + other.y}\n //!     }\n //! }\n //!\n //! impl Sub for Point {\n-//!     type Output = Point;\n+//!     type Output = Self;\n //!\n-//!     fn sub(self, other: Point) -> Point {\n-//!         Point {x: self.x - other.x, y: self.y - other.y}\n+//!     fn sub(self, other: Self) -> Self {\n+//!         Self {x: self.x - other.x, y: self.y - other.y}\n //!     }\n //! }\n //!"}]}