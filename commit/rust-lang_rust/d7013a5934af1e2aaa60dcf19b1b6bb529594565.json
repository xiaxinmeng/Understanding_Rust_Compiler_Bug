{"sha": "d7013a5934af1e2aaa60dcf19b1b6bb529594565", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MDEzYTU5MzRhZjFlMmFhYTYwZGNmMTliMWI2YmI1Mjk1OTQ1NjU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-05T12:04:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-05T12:04:35Z"}, "message": "Merge #7140\n\n7140: Store trait associated items in fst r=matklad a=SomeoneToIgnore\n\nStore imported traits' associated function/methods and constants into `ImportMap.fst` and pefrorm the imports search on them.\r\n\r\nThis is a first step towards trait autoimport during completion functionality, the way I see it, after this PR, only a few major things are left to be done:\r\n\r\n* store all traits' assoc items into fst, not only the ones in scope, as we do now. Any code pointers on how to do this are welcome \ud83d\ude04 \r\n* adjust a few modules in completions crate (`dot.rs`, `qualified_path.rs` at least) to query the import map, reusing the `import_assets` logic heavily\r\n\r\n==\r\nWith the current import and autoimport implementations, it looks like for a single query, we're either interested in either associated items lookup or in all other `fst` contents lookup, but never both simultaneously.\r\nI would rather not split `fst` in two but add another `Query` parameter to separate those, but let me know if you have any ideas.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "d9383f5f08d2beed056aa013da3a21f76002f06c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9383f5f08d2beed056aa013da3a21f76002f06c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7013a5934af1e2aaa60dcf19b1b6bb529594565", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf9FXTCRBK7hj4Ov3rIwAAdHIIAEwi99nr8F9sIvTMDx6cz64T\ne8Y9akItz+PL8EfKPqB2WinJmdYntZUvQweovoI7DJ/Jy0ZgXCYsyqm79ZiWyy31\nS3JkHT5vhI/ShaUCazMfrraFQirXpxG8rMPRq9j4O+n7Hhxs/eLOJvPOwHxK1z0F\ngPuTnmxokxlNACmC38cCErigsU4RqqZmaE0VWDY0OnSWTE4HshTr5qIMpcef/Nig\n4WopA96HH3yasImIcuWHgQh06jphEKRYk/7Pl7dniz3TOi8qqEkbda5k6ub4kQ0G\np6pVUrSArK7I/QRKJtqPyyJx7k46Vpo+RXPnNJC1dhAkpg9LSXrbibYa4Xc8hII=\n=cR3F\n-----END PGP SIGNATURE-----\n", "payload": "tree d9383f5f08d2beed056aa013da3a21f76002f06c\nparent 5c10f2f705d6757b9821387a5be759789b7ee480\nparent 543e950e305aa7bd7e0b185753752d0561c70459\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1609848275 +0000\ncommitter GitHub <noreply@github.com> 1609848275 +0000\n\nMerge #7140\n\n7140: Store trait associated items in fst r=matklad a=SomeoneToIgnore\n\nStore imported traits' associated function/methods and constants into `ImportMap.fst` and pefrorm the imports search on them.\r\n\r\nThis is a first step towards trait autoimport during completion functionality, the way I see it, after this PR, only a few major things are left to be done:\r\n\r\n* store all traits' assoc items into fst, not only the ones in scope, as we do now. Any code pointers on how to do this are welcome \ud83d\ude04 \r\n* adjust a few modules in completions crate (`dot.rs`, `qualified_path.rs` at least) to query the import map, reusing the `import_assets` logic heavily\r\n\r\n==\r\nWith the current import and autoimport implementations, it looks like for a single query, we're either interested in either associated items lookup or in all other `fst` contents lookup, but never both simultaneously.\r\nI would rather not split `fst` in two but add another `Query` parameter to separate those, but let me know if you have any ideas.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7013a5934af1e2aaa60dcf19b1b6bb529594565", "html_url": "https://github.com/rust-lang/rust/commit/d7013a5934af1e2aaa60dcf19b1b6bb529594565", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7013a5934af1e2aaa60dcf19b1b6bb529594565/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c10f2f705d6757b9821387a5be759789b7ee480", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c10f2f705d6757b9821387a5be759789b7ee480", "html_url": "https://github.com/rust-lang/rust/commit/5c10f2f705d6757b9821387a5be759789b7ee480"}, {"sha": "543e950e305aa7bd7e0b185753752d0561c70459", "url": "https://api.github.com/repos/rust-lang/rust/commits/543e950e305aa7bd7e0b185753752d0561c70459", "html_url": "https://github.com/rust-lang/rust/commit/543e950e305aa7bd7e0b185753752d0561c70459"}], "stats": {"total": 314, "additions": 197, "deletions": 117}, "files": [{"sha": "2f41a3f96dc8db7b64122adcf16df77250567878", "filename": "crates/completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7013a5934af1e2aaa60dcf19b1b6bb529594565/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7013a5934af1e2aaa60dcf19b1b6bb529594565/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=d7013a5934af1e2aaa60dcf19b1b6bb529594565", "patch": "@@ -124,8 +124,8 @@ fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &T\n // Note that having this flag set to `true` does not guarantee that the feature is enabled: your client needs to have the corredponding\n // capability enabled.\n fn fuzzy_completion(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    let _p = profile::span(\"fuzzy_completion\");\n     let potential_import_name = ctx.token.to_string();\n+    let _p = profile::span(\"fuzzy_completion\").detail(|| potential_import_name.clone());\n \n     if potential_import_name.len() < 2 {\n         return None;\n@@ -142,6 +142,7 @@ fn fuzzy_completion(acc: &mut Completions, ctx: &CompletionContext) -> Option<()\n         Some(40),\n         potential_import_name,\n         true,\n+        true,\n     )\n     .filter_map(|import_candidate| {\n         Some(match import_candidate {"}, {"sha": "e5368b293cfee4f66dad49774875b1aca7ab96c3", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 176, "deletions": 111, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/d7013a5934af1e2aaa60dcf19b1b6bb529594565/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7013a5934af1e2aaa60dcf19b1b6bb529594565/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=d7013a5934af1e2aaa60dcf19b1b6bb529594565", "patch": "@@ -7,9 +7,8 @@ use fst::{self, Streamer};\n use hir_expand::name::Name;\n use indexmap::{map::Entry, IndexMap};\n use itertools::Itertools;\n-use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n-use smallvec::SmallVec;\n-use syntax::SmolStr;\n+use rustc_hash::{FxHashSet, FxHasher};\n+use test_utils::mark;\n \n use crate::{\n     db::DefDatabase, item_scope::ItemInNs, visibility::Visibility, AssocItemId, ModuleDefId,\n@@ -25,6 +24,8 @@ pub struct ImportInfo {\n     pub path: ImportPath,\n     /// The module containing this item.\n     pub container: ModuleId,\n+    /// Whether the import is a trait associated item or not.\n+    pub is_trait_assoc_item: bool,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -64,10 +65,6 @@ pub struct ImportMap {\n     /// the index of the first one.\n     importables: Vec<ItemInNs>,\n     fst: fst::Map<Vec<u8>>,\n-\n-    /// Maps names of associated items to the item's ID. Only includes items whose defining trait is\n-    /// exported.\n-    assoc_map: FxHashMap<SmolStr, SmallVec<[AssocItemId; 1]>>,\n }\n \n impl ImportMap {\n@@ -108,14 +105,27 @@ impl ImportMap {\n \n                 for item in per_ns.iter_items() {\n                     let path = mk_path();\n+                    let path_len = path.len();\n+                    let import_info =\n+                        ImportInfo { path, container: module, is_trait_assoc_item: false };\n+\n+                    if let Some(ModuleDefId::TraitId(tr)) = item.as_module_def_id() {\n+                        import_map.collect_trait_assoc_items(\n+                            db,\n+                            tr,\n+                            matches!(item, ItemInNs::Types(_)),\n+                            &import_info,\n+                        );\n+                    }\n+\n                     match import_map.map.entry(item) {\n                         Entry::Vacant(entry) => {\n-                            entry.insert(ImportInfo { path, container: module });\n+                            entry.insert(import_info);\n                         }\n                         Entry::Occupied(mut entry) => {\n                             // If the new path is shorter, prefer that one.\n-                            if path.len() < entry.get().path.len() {\n-                                *entry.get_mut() = ImportInfo { path, container: module };\n+                            if path_len < entry.get().path.len() {\n+                                *entry.get_mut() = import_info;\n                             } else {\n                                 continue;\n                             }\n@@ -128,11 +138,6 @@ impl ImportMap {\n                     if let Some(ModuleDefId::ModuleId(mod_id)) = item.as_module_def_id() {\n                         worklist.push((mod_id, mk_path()));\n                     }\n-\n-                    // If we've added a path to a trait, add the trait's methods to the method map.\n-                    if let Some(ModuleDefId::TraitId(tr)) = item.as_module_def_id() {\n-                        import_map.collect_trait_methods(db, tr);\n-                    }\n                 }\n             }\n         }\n@@ -153,12 +158,10 @@ impl ImportMap {\n                 }\n             }\n \n-            let start = last_batch_start;\n-            last_batch_start = idx + 1;\n-\n-            let key = fst_path(&importables[start].1.path);\n+            let key = fst_path(&importables[last_batch_start].1.path);\n+            builder.insert(key, last_batch_start as u64).unwrap();\n \n-            builder.insert(key, start as u64).unwrap();\n+            last_batch_start = idx + 1;\n         }\n \n         import_map.fst = fst::Map::new(builder.into_inner().unwrap()).unwrap();\n@@ -176,10 +179,34 @@ impl ImportMap {\n         self.map.get(&item)\n     }\n \n-    fn collect_trait_methods(&mut self, db: &dyn DefDatabase, tr: TraitId) {\n-        let data = db.trait_data(tr);\n-        for (name, item) in data.items.iter() {\n-            self.assoc_map.entry(name.to_string().into()).or_default().push(*item);\n+    fn collect_trait_assoc_items(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        tr: TraitId,\n+        is_type_in_ns: bool,\n+        original_import_info: &ImportInfo,\n+    ) {\n+        for (assoc_item_name, item) in &db.trait_data(tr).items {\n+            let module_def_id = match item {\n+                AssocItemId::FunctionId(f) => ModuleDefId::from(*f),\n+                AssocItemId::ConstId(c) => ModuleDefId::from(*c),\n+                // cannot use associated type aliases directly: need a `<Struct as Trait>::TypeAlias`\n+                // qualifier, ergo no need to store it for imports in import_map\n+                AssocItemId::TypeAliasId(_) => {\n+                    mark::hit!(type_aliases_ignored);\n+                    continue;\n+                }\n+            };\n+            let assoc_item = if is_type_in_ns {\n+                ItemInNs::Types(module_def_id)\n+            } else {\n+                ItemInNs::Values(module_def_id)\n+            };\n+\n+            let mut assoc_item_info = original_import_info.clone();\n+            assoc_item_info.path.segments.push(assoc_item_name.to_owned());\n+            assoc_item_info.is_trait_assoc_item = true;\n+            self.map.insert(assoc_item, assoc_item_info);\n         }\n     }\n }\n@@ -302,38 +329,38 @@ impl Query {\n         self.exclude_import_kinds.insert(import_kind);\n         self\n     }\n-}\n \n-fn contains_query(query: &Query, input_path: &ImportPath, enforce_lowercase: bool) -> bool {\n-    let mut input = if query.name_only {\n-        input_path.segments.last().unwrap().to_string()\n-    } else {\n-        input_path.to_string()\n-    };\n-    if enforce_lowercase || !query.case_sensitive {\n-        input.make_ascii_lowercase();\n-    }\n-\n-    let query_string =\n-        if !enforce_lowercase && query.case_sensitive { &query.query } else { &query.lowercased };\n-\n-    match query.search_mode {\n-        SearchMode::Equals => &input == query_string,\n-        SearchMode::Contains => input.contains(query_string),\n-        SearchMode::Fuzzy => {\n-            let mut unchecked_query_chars = query_string.chars();\n-            let mut mismatching_query_char = unchecked_query_chars.next();\n-\n-            for input_char in input.chars() {\n-                match mismatching_query_char {\n-                    None => return true,\n-                    Some(matching_query_char) if matching_query_char == input_char => {\n-                        mismatching_query_char = unchecked_query_chars.next();\n+    fn import_matches(&self, import: &ImportInfo, enforce_lowercase: bool) -> bool {\n+        let mut input = if import.is_trait_assoc_item || self.name_only {\n+            import.path.segments.last().unwrap().to_string()\n+        } else {\n+            import.path.to_string()\n+        };\n+        if enforce_lowercase || !self.case_sensitive {\n+            input.make_ascii_lowercase();\n+        }\n+\n+        let query_string =\n+            if !enforce_lowercase && self.case_sensitive { &self.query } else { &self.lowercased };\n+\n+        match self.search_mode {\n+            SearchMode::Equals => &input == query_string,\n+            SearchMode::Contains => input.contains(query_string),\n+            SearchMode::Fuzzy => {\n+                let mut unchecked_query_chars = query_string.chars();\n+                let mut mismatching_query_char = unchecked_query_chars.next();\n+\n+                for input_char in input.chars() {\n+                    match mismatching_query_char {\n+                        None => return true,\n+                        Some(matching_query_char) if matching_query_char == input_char => {\n+                            mismatching_query_char = unchecked_query_chars.next();\n+                        }\n+                        _ => (),\n                     }\n-                    _ => (),\n                 }\n+                mismatching_query_char.is_none()\n             }\n-            mismatching_query_char.is_none()\n         }\n     }\n }\n@@ -366,13 +393,13 @@ pub fn search_dependencies<'a>(\n             let import_map = &import_maps[indexed_value.index];\n             let importables = &import_map.importables[indexed_value.value as usize..];\n \n-            // Path shared by the importable items in this group.\n-            let common_importables_path = &import_map.map[&importables[0]].path;\n-            if !contains_query(&query, common_importables_path, true) {\n+            let common_importable_data = &import_map.map[&importables[0]];\n+            if !query.import_matches(common_importable_data, true) {\n                 continue;\n             }\n \n-            let common_importables_path_fst = fst_path(common_importables_path);\n+            // Path shared by the importable items in this group.\n+            let common_importables_path_fst = fst_path(&common_importable_data.path);\n             // Add the items from this `ModPath` group. Those are all subsequent items in\n             // `importables` whose paths match `path`.\n             let iter = importables\n@@ -387,7 +414,7 @@ pub fn search_dependencies<'a>(\n                 })\n                 .filter(|item| {\n                     !query.case_sensitive // we've already checked the common importables path case-insensitively\n-                        || contains_query(&query, &import_map.map[item].path, false)\n+                        || query.import_matches(&import_map.map[item], false)\n                 });\n             res.extend(iter);\n \n@@ -398,19 +425,6 @@ pub fn search_dependencies<'a>(\n         }\n     }\n \n-    // Add all exported associated items whose names match the query (exactly).\n-    for map in &import_maps {\n-        if let Some(v) = map.assoc_map.get(&*query.query) {\n-            res.extend(v.iter().map(|&assoc| {\n-                ItemInNs::Types(match assoc {\n-                    AssocItemId::FunctionId(it) => it.into(),\n-                    AssocItemId::ConstId(it) => it.into(),\n-                    AssocItemId::TypeAliasId(it) => it.into(),\n-                })\n-            }));\n-        }\n-    }\n-\n     res\n }\n \n@@ -432,9 +446,9 @@ fn item_import_kind(item: ItemInNs) -> Option<ImportKind> {\n mod tests {\n     use base_db::{fixture::WithFixture, SourceDatabase, Upcast};\n     use expect_test::{expect, Expect};\n-    use stdx::format_to;\n+    use test_utils::mark;\n \n-    use crate::{data::FunctionData, test_db::TestDB, AssocContainerId, Lookup};\n+    use crate::{test_db::TestDB, AssocContainerId, Lookup};\n \n     use super::*;\n \n@@ -451,46 +465,66 @@ mod tests {\n \n         let actual = search_dependencies(db.upcast(), krate, query)\n             .into_iter()\n-            .filter_map(|item| {\n-                let mark = match item {\n-                    ItemInNs::Types(ModuleDefId::FunctionId(_))\n-                    | ItemInNs::Values(ModuleDefId::FunctionId(_)) => \"f\",\n-                    ItemInNs::Types(_) => \"t\",\n-                    ItemInNs::Values(_) => \"v\",\n-                    ItemInNs::Macros(_) => \"m\",\n+            .filter_map(|dependency| {\n+                let dependency_krate = dependency.krate(db.upcast())?;\n+                let dependency_imports = db.import_map(dependency_krate);\n+\n+                let (path, mark) = match assoc_item_path(&db, &dependency_imports, dependency) {\n+                    Some(assoc_item_path) => (assoc_item_path, \"a\"),\n+                    None => (\n+                        dependency_imports.path_of(dependency)?.to_string(),\n+                        match dependency {\n+                            ItemInNs::Types(ModuleDefId::FunctionId(_))\n+                            | ItemInNs::Values(ModuleDefId::FunctionId(_)) => \"f\",\n+                            ItemInNs::Types(_) => \"t\",\n+                            ItemInNs::Values(_) => \"v\",\n+                            ItemInNs::Macros(_) => \"m\",\n+                        },\n+                    ),\n                 };\n-                item.krate(db.upcast()).map(|krate| {\n-                    let map = db.import_map(krate);\n-\n-                    let path = match assoc_to_trait(&db, item) {\n-                        Some(trait_) => {\n-                            let mut full_path = map.path_of(trait_).unwrap().to_string();\n-                            if let ItemInNs::Types(ModuleDefId::FunctionId(function_id))\n-                            | ItemInNs::Values(ModuleDefId::FunctionId(function_id)) = item\n-                            {\n-                                format_to!(\n-                                    full_path,\n-                                    \"::{}\",\n-                                    FunctionData::fn_data_query(&db, function_id).name,\n-                                );\n-                            }\n-                            full_path\n-                        }\n-                        None => map.path_of(item).unwrap().to_string(),\n-                    };\n-\n-                    format!(\n-                        \"{}::{} ({})\\n\",\n-                        crate_graph[krate].display_name.as_ref().unwrap(),\n-                        path,\n-                        mark\n-                    )\n-                })\n+\n+                Some(format!(\n+                    \"{}::{} ({})\\n\",\n+                    crate_graph[dependency_krate].display_name.as_ref()?,\n+                    path,\n+                    mark\n+                ))\n             })\n             .collect::<String>();\n         expect.assert_eq(&actual)\n     }\n \n+    fn assoc_item_path(\n+        db: &dyn DefDatabase,\n+        dependency_imports: &ImportMap,\n+        dependency: ItemInNs,\n+    ) -> Option<String> {\n+        let dependency_assoc_item_id = match dependency {\n+            ItemInNs::Types(ModuleDefId::FunctionId(id))\n+            | ItemInNs::Values(ModuleDefId::FunctionId(id)) => AssocItemId::from(id),\n+            ItemInNs::Types(ModuleDefId::ConstId(id))\n+            | ItemInNs::Values(ModuleDefId::ConstId(id)) => AssocItemId::from(id),\n+            ItemInNs::Types(ModuleDefId::TypeAliasId(id))\n+            | ItemInNs::Values(ModuleDefId::TypeAliasId(id)) => AssocItemId::from(id),\n+            _ => return None,\n+        };\n+\n+        let trait_ = assoc_to_trait(db, dependency)?;\n+        if let ModuleDefId::TraitId(tr) = trait_.as_module_def_id()? {\n+            let trait_data = db.trait_data(tr);\n+            let assoc_item_name =\n+                trait_data.items.iter().find_map(|(assoc_item_name, assoc_item_id)| {\n+                    if &dependency_assoc_item_id == assoc_item_id {\n+                        Some(assoc_item_name)\n+                    } else {\n+                        None\n+                    }\n+                })?;\n+            return Some(format!(\"{}::{}\", dependency_imports.path_of(trait_)?, assoc_item_name));\n+        }\n+        None\n+    }\n+\n     fn assoc_to_trait(db: &dyn DefDatabase, item: ItemInNs) -> Option<ItemInNs> {\n         let assoc: AssocItemId = match item {\n             ItemInNs::Types(it) | ItemInNs::Values(it) => match it {\n@@ -748,6 +782,37 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn fuzzy_import_trait_and_assoc_items() {\n+        mark::check!(type_aliases_ignored);\n+        let ra_fixture = r#\"\n+        //- /main.rs crate:main deps:dep\n+        //- /dep.rs crate:dep\n+        pub mod fmt {\n+            pub trait Display {\n+                type FmtTypeAlias;\n+                const FMT_CONST: bool;\n+\n+                fn format_function();\n+                fn format_method(&self);\n+            }\n+        }\n+    \"#;\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string()).search_mode(SearchMode::Fuzzy),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::fmt::Display (t)\n+                dep::fmt::Display::FMT_CONST (a)\n+                dep::fmt::Display::format_function (a)\n+                dep::fmt::Display::format_method (a)\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn search_mode() {\n         let ra_fixture = r#\"\n@@ -784,8 +849,8 @@ mod tests {\n                 dep::Fmt (v)\n                 dep::Fmt (m)\n                 dep::fmt::Display (t)\n+                dep::fmt::Display::fmt (a)\n                 dep::format (f)\n-                dep::fmt::Display::fmt (f)\n             \"#]],\n         );\n \n@@ -798,7 +863,7 @@ mod tests {\n                 dep::Fmt (t)\n                 dep::Fmt (v)\n                 dep::Fmt (m)\n-                dep::fmt::Display::fmt (f)\n+                dep::fmt::Display::fmt (a)\n             \"#]],\n         );\n \n@@ -812,7 +877,7 @@ mod tests {\n                 dep::Fmt (v)\n                 dep::Fmt (m)\n                 dep::fmt::Display (t)\n-                dep::fmt::Display::fmt (f)\n+                dep::fmt::Display::fmt (a)\n             \"#]],\n         );\n     }\n@@ -853,7 +918,7 @@ mod tests {\n                 dep::Fmt (v)\n                 dep::Fmt (m)\n                 dep::fmt::Display (t)\n-                dep::fmt::Display::fmt (f)\n+                dep::fmt::Display::fmt (a)\n             \"#]],\n         );\n \n@@ -866,7 +931,7 @@ mod tests {\n                 dep::Fmt (t)\n                 dep::Fmt (v)\n                 dep::Fmt (m)\n-                dep::fmt::Display::fmt (f)\n+                dep::fmt::Display::fmt (a)\n             \"#]],\n         );\n     }"}, {"sha": "2750e1c915d59dcb3174c7a6e89b180d4783b7fb", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7013a5934af1e2aaa60dcf19b1b6bb529594565/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7013a5934af1e2aaa60dcf19b1b6bb529594565/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=d7013a5934af1e2aaa60dcf19b1b6bb529594565", "patch": "@@ -10,10 +10,9 @@ use once_cell::sync::Lazy;\n use rustc_hash::{FxHashMap, FxHashSet};\n use test_utils::mark;\n \n-use crate::ModuleId;\n use crate::{\n     db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, HasModule, ImplId,\n-    LocalModuleId, Lookup, MacroDefId, ModuleDefId, TraitId,\n+    LocalModuleId, Lookup, MacroDefId, ModuleDefId, ModuleId, TraitId,\n };\n \n #[derive(Copy, Clone)]"}, {"sha": "0782ab070957ee75038e889bfa7590d9270f9e89", "filename": "crates/ide_db/src/imports_locator.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d7013a5934af1e2aaa60dcf19b1b6bb529594565/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7013a5934af1e2aaa60dcf19b1b6bb529594565/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=d7013a5934af1e2aaa60dcf19b1b6bb529594565", "patch": "@@ -1,7 +1,7 @@\n //! This module contains an import search funcionality that is provided to the assists module.\n //! Later, this should be moved away to a separate crate that is accessible from the assists module.\n \n-use hir::{import_map, Crate, MacroDef, ModuleDef, Semantics};\n+use hir::{import_map, AsAssocItem, Crate, MacroDef, ModuleDef, Semantics};\n use syntax::{ast, AstNode, SyntaxKind::NAME};\n \n use crate::{\n@@ -40,8 +40,9 @@ pub fn find_similar_imports<'a>(\n     krate: Crate,\n     limit: Option<usize>,\n     fuzzy_search_string: String,\n+    ignore_assoc_items: bool,\n     name_only: bool,\n-) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n+) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> + 'a {\n     let _p = profile::span(\"find_similar_imports\");\n \n     let mut external_query = import_map::Query::new(fuzzy_search_string.clone())\n@@ -57,7 +58,21 @@ pub fn find_similar_imports<'a>(\n         external_query = external_query.limit(limit);\n     }\n \n-    find_imports(sema, krate, local_query, external_query)\n+    let db = sema.db;\n+    find_imports(sema, krate, local_query, external_query).filter(move |import_candidate| {\n+        if ignore_assoc_items {\n+            match import_candidate {\n+                Either::Left(ModuleDef::Function(function)) => function.as_assoc_item(db).is_none(),\n+                Either::Left(ModuleDef::Const(const_)) => const_.as_assoc_item(db).is_none(),\n+                Either::Left(ModuleDef::TypeAlias(type_alias)) => {\n+                    type_alias.as_assoc_item(db).is_none()\n+                }\n+                _ => true,\n+            }\n+        } else {\n+            true\n+        }\n+    })\n }\n \n fn find_imports<'a>("}]}