{"sha": "e915cf45dc48e90653081f9d760a7f4f803ce428", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MTVjZjQ1ZGM0OGU5MDY1MzA4MWY5ZDc2MGE3ZjRmODAzY2U0Mjg=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-02-15T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-02-16T22:52:05Z"}, "message": "Pass OpTy by reference not value", "tree": {"sha": "1be12beed610bdfd2538e3fe42f3c0904f433ce7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1be12beed610bdfd2538e3fe42f3c0904f433ce7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e915cf45dc48e90653081f9d760a7f4f803ce428", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e915cf45dc48e90653081f9d760a7f4f803ce428", "html_url": "https://github.com/rust-lang/rust/commit/e915cf45dc48e90653081f9d760a7f4f803ce428", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e915cf45dc48e90653081f9d760a7f4f803ce428/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c9d7fbeedd31398f363185106da292c2cdccb7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9d7fbeedd31398f363185106da292c2cdccb7f", "html_url": "https://github.com/rust-lang/rust/commit/6c9d7fbeedd31398f363185106da292c2cdccb7f"}], "stats": {"total": 386, "additions": 193, "deletions": 193}, "files": [{"sha": "e573eeae00314ef5a3f927421240d455afdf3bbe", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -105,7 +105,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n /// type system.\n pub(super) fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, 'tcx>,\n-    op: OpTy<'tcx>,\n+    op: &OpTy<'tcx>,\n ) -> ConstValue<'tcx> {\n     // We do not have value optimizations for everything.\n     // Only scalars and slices, since they are very common.\n@@ -201,7 +201,7 @@ fn turn_into_const_value<'tcx>(\n         \"the `eval_to_const_value_raw` query should not be used for statics, use `eval_to_allocation` instead\"\n     );\n     // Turn this into a proper constant.\n-    op_to_const(&ecx, mplace.into())\n+    op_to_const(&ecx, &mplace.into())\n }\n \n pub fn eval_to_const_value_raw_provider<'tcx>(\n@@ -348,7 +348,7 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                         Some(_) => CtfeValidationMode::Regular, // a `static`\n                         None => CtfeValidationMode::Const { inner, allow_static_ptrs: false },\n                     };\n-                    ecx.const_validate_operand(mplace.into(), path, &mut ref_tracking, mode)?;\n+                    ecx.const_validate_operand(&mplace.into(), path, &mut ref_tracking, mode)?;\n                     inner = true;\n                 }\n             };"}, {"sha": "6282288b26e927fac4f457670fc1195e7f20df21", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -39,7 +39,7 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n             // &str\n             assert!(args.len() == 1);\n \n-            let msg_place = self.deref_operand(args[0])?;\n+            let msg_place = self.deref_operand(&args[0])?;\n             let msg = Symbol::intern(self.read_str(msg_place)?);\n             let span = self.find_closest_untracked_caller_location();\n             let (file, line, col) = self.location_triple_for_span(span);\n@@ -284,8 +284,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         };\n         match intrinsic_name {\n             sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n-                let a = ecx.read_immediate(args[0])?.to_scalar()?;\n-                let b = ecx.read_immediate(args[1])?.to_scalar()?;\n+                let a = ecx.read_immediate(&args[0])?.to_scalar()?;\n+                let b = ecx.read_immediate(&args[1])?.to_scalar()?;\n                 let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n                     ecx.guaranteed_eq(a, b)\n                 } else {\n@@ -294,8 +294,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 ecx.write_scalar(Scalar::from_bool(cmp), dest)?;\n             }\n             sym::const_allocate => {\n-                let size = ecx.read_scalar(args[0])?.to_machine_usize(ecx)?;\n-                let align = ecx.read_scalar(args[1])?.to_machine_usize(ecx)?;\n+                let size = ecx.read_scalar(&args[0])?.to_machine_usize(ecx)?;\n+                let align = ecx.read_scalar(&args[1])?.to_machine_usize(ecx)?;\n \n                 let align = match Align::from_bytes(align) {\n                     Ok(a) => a,\n@@ -330,7 +330,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         use rustc_middle::mir::AssertKind::*;\n         // Convert `AssertKind<Operand>` to `AssertKind<Scalar>`.\n         let eval_to_int =\n-            |op| ecx.read_immediate(ecx.eval_operand(op, None)?).map(|x| x.to_const_int());\n+            |op| ecx.read_immediate(&ecx.eval_operand(op, None)?).map(|x| x.to_const_int());\n         let err = match msg {\n             BoundsCheck { ref len, ref index } => {\n                 let len = eval_to_int(len)?;\n@@ -358,8 +358,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     fn binary_ptr_op(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n-        _left: ImmTy<'tcx>,\n-        _right: ImmTy<'tcx>,\n+        _left: &ImmTy<'tcx>,\n+        _right: &ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n         Err(ConstEvalErrKind::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n     }"}, {"sha": "480489c9bc0b15e74fed7a155dafcc482530fca1", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -55,17 +55,17 @@ pub(crate) fn destructure_const<'tcx>(\n             return mir::DestructuredConst { variant: None, fields: &[] };\n         }\n         ty::Adt(def, _) => {\n-            let variant = ecx.read_discriminant(op).unwrap().1;\n-            let down = ecx.operand_downcast(op, variant).unwrap();\n+            let variant = ecx.read_discriminant(&op).unwrap().1;\n+            let down = ecx.operand_downcast(&op, variant).unwrap();\n             (def.variants[variant].fields.len(), Some(variant), down)\n         }\n         ty::Tuple(substs) => (substs.len(), None, op),\n         _ => bug!(\"cannot destructure constant {:?}\", val),\n     };\n \n     let fields_iter = (0..field_count).map(|i| {\n-        let field_op = ecx.operand_field(down, i).unwrap();\n-        let val = op_to_const(&ecx, field_op);\n+        let field_op = ecx.operand_field(&down, i).unwrap();\n+        let val = op_to_const(&ecx, &field_op);\n         ty::Const::from_value(tcx, val, field_op.layout.ty)\n     });\n     let fields = tcx.arena.alloc_from_iter(fields_iter);\n@@ -81,7 +81,7 @@ pub(crate) fn deref_const<'tcx>(\n     trace!(\"deref_const: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n     let op = ecx.const_to_op(val, None).unwrap();\n-    let mplace = ecx.deref_operand(op).unwrap();\n+    let mplace = ecx.deref_operand(&op).unwrap();\n     if let Scalar::Ptr(ptr) = mplace.ptr {\n         assert_eq!(\n             ecx.memory.get_raw(ptr.alloc_id).unwrap().mutability,\n@@ -106,5 +106,5 @@ pub(crate) fn deref_const<'tcx>(\n         },\n     };\n \n-    tcx.mk_const(ty::Const { val: ty::ConstKind::Value(op_to_const(&ecx, mplace.into())), ty })\n+    tcx.mk_const(ty::Const { val: ty::ConstKind::Value(op_to_const(&ecx, &mplace.into())), ty })\n }"}, {"sha": "257012ead6641d49224bad1d87ad51dcdee9da87", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -17,7 +17,7 @@ use super::{\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn cast(\n         &mut self,\n-        src: OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n         cast_kind: CastKind,\n         cast_ty: Ty<'tcx>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n@@ -259,7 +259,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn unsize_into_ptr(\n         &mut self,\n-        src: OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n         // The pointee types\n         source_ty: Ty<'tcx>,\n@@ -300,7 +300,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn unsize_into(\n         &mut self,\n-        src: OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n         cast_ty: TyAndLayout<'tcx>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n@@ -340,9 +340,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let src_field = self.operand_field(src, i)?;\n                     let dst_field = self.place_field(dest, i)?;\n                     if src_field.layout.ty == cast_ty_field.ty {\n-                        self.copy_op(src_field, dst_field)?;\n+                        self.copy_op(&src_field, dst_field)?;\n                     } else {\n-                        self.unsize_into(src_field, cast_ty_field, dst_field)?;\n+                        self.unsize_into(&src_field, cast_ty_field, dst_field)?;\n                     }\n                 }\n                 Ok(())"}, {"sha": "7173e1eca5973fc8178159d332d19c9105d52451", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -779,7 +779,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Copy the return value to the caller's stack frame.\n             if let Some(return_place) = frame.return_place {\n                 let op = self.access_local(&frame, mir::RETURN_PLACE, None)?;\n-                self.copy_op_transmute(op, return_place)?;\n+                self.copy_op_transmute(&op, return_place)?;\n                 trace!(\"{:?}\", self.dump_place(*return_place));\n             } else {\n                 throw_ub!(Unreachable);"}, {"sha": "7f0b74cf6e5f24c2dc32a408173ea48968ac6023", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -167,7 +167,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n \n     fn visit_aggregate(\n         &mut self,\n-        mplace: MPlaceTy<'tcx>,\n+        mplace: &MPlaceTy<'tcx>,\n         fields: impl Iterator<Item = InterpResult<'tcx, Self::V>>,\n     ) -> InterpResult<'tcx> {\n         // ZSTs cannot contain pointers, so we can skip them.\n@@ -191,13 +191,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n         self.walk_aggregate(mplace, fields)\n     }\n \n-    fn visit_value(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n+    fn visit_value(&mut self, mplace: &MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n         // Handle Reference types, as these are the only relocations supported by const eval.\n         // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n         let tcx = self.ecx.tcx;\n         let ty = mplace.layout.ty;\n         if let ty::Ref(_, referenced_ty, ref_mutability) = *ty.kind() {\n-            let value = self.ecx.read_immediate(mplace.into())?;\n+            let value = self.ecx.read_immediate(&(*mplace).into())?;\n             let mplace = self.ecx.ref_to_mplace(value)?;\n             assert_eq!(mplace.layout.ty, referenced_ty);\n             // Handle trait object vtables.\n@@ -338,7 +338,7 @@ where\n             leftover_allocations,\n             inside_unsafe_cell: false,\n         }\n-        .visit_value(mplace);\n+        .visit_value(&mplace);\n         // We deliberately *ignore* interpreter errors here.  When there is a problem, the remaining\n         // references are \"leftover\"-interned, and later validation will show a proper error\n         // and point at the right part of the value causing the problem."}, {"sha": "0252dd15888af179c53c6bb410f389240c6526e6", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -143,7 +143,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::min_align_of_val | sym::size_of_val => {\n                 // Avoid `deref_operand` -- this is not a deref, the ptr does not have to be\n                 // dereferencable!\n-                let place = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n+                let place = self.ref_to_mplace(self.read_immediate(&args[0])?)?;\n                 let (size, align) = self\n                     .size_and_align_of_mplace(place)?\n                     .ok_or_else(|| err_unsup_format!(\"`extern type` does not have known layout\"))?;\n@@ -177,7 +177,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     self.tcx.const_eval_global_id(self.param_env, gid, Some(self.tcx.span))?;\n                 let const_ = ty::Const { val: ty::ConstKind::Value(val), ty };\n                 let val = self.const_to_op(&const_, None)?;\n-                self.copy_op(val, dest)?;\n+                self.copy_op(&val, dest)?;\n             }\n \n             sym::ctpop\n@@ -189,7 +189,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::bitreverse => {\n                 let ty = substs.type_at(0);\n                 let layout_of = self.layout_of(ty)?;\n-                let val = self.read_scalar(args[0])?.check_init()?;\n+                let val = self.read_scalar(&args[0])?.check_init()?;\n                 let bits = self.force_bits(val, layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     Abi::Scalar(ref scalar) => scalar.value,\n@@ -212,22 +212,22 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(out_val, dest)?;\n             }\n             sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {\n-                let lhs = self.read_immediate(args[0])?;\n-                let rhs = self.read_immediate(args[1])?;\n+                let lhs = self.read_immediate(&args[0])?;\n+                let rhs = self.read_immediate(&args[1])?;\n                 let bin_op = match intrinsic_name {\n                     sym::add_with_overflow => BinOp::Add,\n                     sym::sub_with_overflow => BinOp::Sub,\n                     sym::mul_with_overflow => BinOp::Mul,\n                     _ => bug!(\"Already checked for int ops\"),\n                 };\n-                self.binop_with_overflow(bin_op, lhs, rhs, dest)?;\n+                self.binop_with_overflow(bin_op, &lhs, &rhs, dest)?;\n             }\n             sym::saturating_add | sym::saturating_sub => {\n-                let l = self.read_immediate(args[0])?;\n-                let r = self.read_immediate(args[1])?;\n+                let l = self.read_immediate(&args[0])?;\n+                let r = self.read_immediate(&args[1])?;\n                 let is_add = intrinsic_name == sym::saturating_add;\n                 let (val, overflowed, _ty) =\n-                    self.overflowing_binary_op(if is_add { BinOp::Add } else { BinOp::Sub }, l, r)?;\n+                    self.overflowing_binary_op(if is_add { BinOp::Add } else { BinOp::Sub }, &l, &r)?;\n                 let val = if overflowed {\n                     let num_bits = l.layout.size.bits();\n                     if l.layout.abi.is_signed() {\n@@ -269,8 +269,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(val, dest)?;\n             }\n             sym::discriminant_value => {\n-                let place = self.deref_operand(args[0])?;\n-                let discr_val = self.read_discriminant(place.into())?.0;\n+                let place = self.deref_operand(&args[0])?;\n+                let discr_val = self.read_discriminant(&place.into())?.0;\n                 self.write_scalar(discr_val, dest)?;\n             }\n             sym::unchecked_shl\n@@ -280,8 +280,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::unchecked_mul\n             | sym::unchecked_div\n             | sym::unchecked_rem => {\n-                let l = self.read_immediate(args[0])?;\n-                let r = self.read_immediate(args[1])?;\n+                let l = self.read_immediate(&args[0])?;\n+                let r = self.read_immediate(&args[1])?;\n                 let bin_op = match intrinsic_name {\n                     sym::unchecked_shl => BinOp::Shl,\n                     sym::unchecked_shr => BinOp::Shr,\n@@ -292,7 +292,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     sym::unchecked_rem => BinOp::Rem,\n                     _ => bug!(\"Already checked for int ops\"),\n                 };\n-                let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, l, r)?;\n+                let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, &l, &r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val = self.force_bits(r.to_scalar()?, layout.size)?;\n@@ -308,9 +308,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n                 let layout = self.layout_of(substs.type_at(0))?;\n-                let val = self.read_scalar(args[0])?.check_init()?;\n+                let val = self.read_scalar(&args[0])?.check_init()?;\n                 let val_bits = self.force_bits(val, layout.size)?;\n-                let raw_shift = self.read_scalar(args[1])?.check_init()?;\n+                let raw_shift = self.read_scalar(&args[1])?.check_init()?;\n                 let raw_shift_bits = self.force_bits(raw_shift, layout.size)?;\n                 let width_bits = u128::from(layout.size.bits());\n                 let shift_bits = raw_shift_bits % width_bits;\n@@ -327,15 +327,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::copy | sym::copy_nonoverlapping => {\n                 let elem_ty = instance.substs.type_at(0);\n                 let elem_layout = self.layout_of(elem_ty)?;\n-                let count = self.read_scalar(args[2])?.to_machine_usize(self)?;\n+                let count = self.read_scalar(&args[2])?.to_machine_usize(self)?;\n                 let elem_align = elem_layout.align.abi;\n \n                 let size = elem_layout.size.checked_mul(count, self).ok_or_else(|| {\n                     err_ub_format!(\"overflow computing total size of `{}`\", intrinsic_name)\n                 })?;\n-                let src = self.read_scalar(args[0])?.check_init()?;\n+                let src = self.read_scalar(&args[0])?.check_init()?;\n                 let src = self.memory.check_ptr_access(src, size, elem_align)?;\n-                let dest = self.read_scalar(args[1])?.check_init()?;\n+                let dest = self.read_scalar(&args[1])?.check_init()?;\n                 let dest = self.memory.check_ptr_access(dest, size, elem_align)?;\n \n                 if let (Some(src), Some(dest)) = (src, dest) {\n@@ -348,16 +348,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n             sym::offset => {\n-                let ptr = self.read_scalar(args[0])?.check_init()?;\n-                let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n+                let ptr = self.read_scalar(&args[0])?.check_init()?;\n+                let offset_count = self.read_scalar(&args[1])?.to_machine_isize(self)?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n                 self.write_scalar(offset_ptr, dest)?;\n             }\n             sym::arith_offset => {\n-                let ptr = self.read_scalar(args[0])?.check_init()?;\n-                let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n+                let ptr = self.read_scalar(&args[0])?.check_init()?;\n+                let offset_count = self.read_scalar(&args[1])?.to_machine_isize(self)?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n@@ -366,8 +366,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(offset_ptr, dest)?;\n             }\n             sym::ptr_offset_from => {\n-                let a = self.read_immediate(args[0])?.to_scalar()?;\n-                let b = self.read_immediate(args[1])?.to_scalar()?;\n+                let a = self.read_immediate(&args[0])?.to_scalar()?;\n+                let b = self.read_immediate(&args[1])?.to_scalar()?;\n \n                 // Special case: if both scalars are *equal integers*\n                 // and not NULL, we pretend there is an allocation of size 0 right there,\n@@ -406,16 +406,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let a_offset = ImmTy::from_uint(a.offset.bytes(), usize_layout);\n                     let b_offset = ImmTy::from_uint(b.offset.bytes(), usize_layout);\n                     let (val, _overflowed, _ty) =\n-                        self.overflowing_binary_op(BinOp::Sub, a_offset, b_offset)?;\n+                        self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?;\n                     let pointee_layout = self.layout_of(substs.type_at(0))?;\n                     let val = ImmTy::from_scalar(val, isize_layout);\n                     let size = ImmTy::from_int(pointee_layout.size.bytes(), isize_layout);\n-                    self.exact_div(val, size, dest)?;\n+                    self.exact_div(&val, &size, dest)?;\n                 }\n             }\n \n             sym::transmute => {\n-                self.copy_op_transmute(args[0], dest)?;\n+                self.copy_op_transmute(&args[0], dest)?;\n             }\n             sym::assert_inhabited => {\n                 let ty = instance.substs.type_at(0);\n@@ -434,9 +434,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n             sym::simd_insert => {\n-                let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n-                let elem = args[2];\n-                let input = args[0];\n+                let index = u64::from(self.read_scalar(&args[1])?.to_u32()?);\n+                let elem = &args[2];\n+                let input = &args[0];\n                 let (len, e_ty) = input.layout.ty.simd_size_and_type(*self.tcx);\n                 assert!(\n                     index < len,\n@@ -458,12 +458,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 for i in 0..len {\n                     let place = self.place_index(dest, i)?;\n-                    let value = if i == index { elem } else { self.operand_index(input, i)? };\n-                    self.copy_op(value, place)?;\n+                    let value = if i == index { *elem } else { self.operand_index(input, i)? };\n+                    self.copy_op(&value, place)?;\n                 }\n             }\n             sym::simd_extract => {\n-                let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n+                let index = u64::from(self.read_scalar(&args[1])?.to_u32()?);\n                 let (len, e_ty) = args[0].layout.ty.simd_size_and_type(*self.tcx);\n                 assert!(\n                     index < len,\n@@ -477,14 +477,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     \"Return type `{}` must match vector element type `{}`\",\n                     dest.layout.ty, e_ty\n                 );\n-                self.copy_op(self.operand_index(args[0], index)?, dest)?;\n+                self.copy_op(&self.operand_index(&args[0], index)?, dest)?;\n             }\n             sym::likely | sym::unlikely => {\n                 // These just return their argument\n-                self.copy_op(args[0], dest)?;\n+                self.copy_op(&args[0], dest)?;\n             }\n             sym::assume => {\n-                let cond = self.read_scalar(args[0])?.check_init()?.to_bool()?;\n+                let cond = self.read_scalar(&args[0])?.check_init()?.to_bool()?;\n                 if !cond {\n                     throw_ub_format!(\"`assume` intrinsic called with `false`\");\n                 }\n@@ -499,14 +499,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn exact_div(\n         &mut self,\n-        a: ImmTy<'tcx, M::PointerTag>,\n-        b: ImmTy<'tcx, M::PointerTag>,\n+        a: &ImmTy<'tcx, M::PointerTag>,\n+        b: &ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // Performs an exact division, resulting in undefined behavior where\n         // `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`.\n         // First, check x % y != 0 (or if that computation overflows).\n-        let (res, overflow, _ty) = self.overflowing_binary_op(BinOp::Rem, a, b)?;\n+        let (res, overflow, _ty) = self.overflowing_binary_op(BinOp::Rem, &a, &b)?;\n         if overflow || res.assert_bits(a.layout.size) != 0 {\n             // Then, check if `b` is -1, which is the \"MIN / -1\" case.\n             let minus1 = Scalar::from_int(-1, dest.layout.size);\n@@ -518,7 +518,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n         // `Rem` says this is all right, so we can let `Div` do its job.\n-        self.binop_ignore_overflow(BinOp::Div, a, b, dest)\n+        self.binop_ignore_overflow(BinOp::Div, &a, &b, dest)\n     }\n \n     /// Offsets a pointer by some multiple of its type, returning an error if the pointer leaves its"}, {"sha": "91f0587a3417699d805e55a129e4151b3c400c9b", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -200,8 +200,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn binary_ptr_op(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, Self::PointerTag>,\n-        right: ImmTy<'tcx, Self::PointerTag>,\n+        left: &ImmTy<'tcx, Self::PointerTag>,\n+        right: &ImmTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool, Ty<'tcx>)>;\n \n     /// Heap allocations via the `box` keyword."}, {"sha": "626f8915ecf0801d933c2979e009fd15b7c1fd57", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -231,7 +231,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     pub fn force_op_ptr(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         match op.try_as_mplace(self) {\n             Ok(mplace) => Ok(self.force_mplace_ptr(mplace)?.into()),\n@@ -304,7 +304,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// in a `Immediate`, not on which data is stored there currently.\n     pub(crate) fn try_read_immediate(\n         &self,\n-        src: OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n         Ok(match src.try_as_mplace(self) {\n             Ok(mplace) => {\n@@ -322,7 +322,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn read_immediate(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         if let Ok(imm) = self.try_read_immediate(op)? {\n             Ok(imm)\n@@ -334,7 +334,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Read a scalar from a place\n     pub fn read_scalar(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<M::PointerTag>> {\n         Ok(self.read_immediate(op)?.to_scalar_or_uninit())\n     }\n@@ -350,7 +350,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Projection functions\n     pub fn operand_field(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         field: usize,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base = match op.try_as_mplace(self) {\n@@ -388,7 +388,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn operand_index(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         index: u64,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         if let Ok(index) = usize::try_from(index) {\n@@ -403,22 +403,22 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     pub fn operand_downcast(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Downcasts only change the layout\n         Ok(match op.try_as_mplace(self) {\n             Ok(mplace) => self.mplace_downcast(mplace, variant)?.into(),\n             Err(..) => {\n                 let layout = op.layout.for_variant(self, variant);\n-                OpTy { layout, ..op }\n+                OpTy { layout, ..*op }\n             }\n         })\n     }\n \n     pub fn operand_projection(\n         &self,\n-        base: OpTy<'tcx, M::PointerTag>,\n+        base: &OpTy<'tcx, M::PointerTag>,\n         proj_elem: mir::PlaceElem<'tcx>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n@@ -489,7 +489,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let op = place\n             .projection\n             .iter()\n-            .try_fold(base_op, |op, elem| self.operand_projection(op, elem))?;\n+            .try_fold(base_op, |op, elem| self.operand_projection(&op, elem))?;\n \n         trace!(\"eval_place_to_op: got {:?}\", *op);\n         // Sanity-check the type we ended up with.\n@@ -599,7 +599,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Read discriminant, return the runtime value as well as the variant index.\n     pub fn read_discriminant(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", op.layout);\n         // Get type and layout of the discriminant.\n@@ -645,7 +645,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(*self.tcx))?;\n \n         // Read tag and sanity-check `tag_layout`.\n-        let tag_val = self.read_immediate(self.operand_field(op, tag_field)?)?;\n+        let tag_val = self.read_immediate(&self.operand_field(op, tag_field)?)?;\n         assert_eq!(tag_layout.size, tag_val.layout.size);\n         assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n         let tag_val = tag_val.to_scalar()?;\n@@ -699,7 +699,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         let tag_val = ImmTy::from_uint(tag_bits, tag_layout);\n                         let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n                         let variant_index_relative_val =\n-                            self.binary_op(mir::BinOp::Sub, tag_val, niche_start_val)?;\n+                            self.binary_op(mir::BinOp::Sub, &tag_val, &niche_start_val)?;\n                         let variant_index_relative = variant_index_relative_val\n                             .to_scalar()?\n                             .assert_bits(tag_val.layout.size);"}, {"sha": "7d2dcedda47a6622f22d62008c95d421ef12bc3b", "filename": "compiler/rustc_mir/src/interpret/operator.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -14,11 +14,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        left: ImmTy<'tcx, M::PointerTag>,\n-        right: ImmTy<'tcx, M::PointerTag>,\n+        left: &ImmTy<'tcx, M::PointerTag>,\n+        right: &ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        let (val, overflowed, ty) = self.overflowing_binary_op(op, left, right)?;\n+        let (val, overflowed, ty) = self.overflowing_binary_op(op, &left, &right)?;\n         debug_assert_eq!(\n             self.tcx.intern_tup(&[ty, self.tcx.types.bool]),\n             dest.layout.ty,\n@@ -34,8 +34,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn binop_ignore_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        left: ImmTy<'tcx, M::PointerTag>,\n-        right: ImmTy<'tcx, M::PointerTag>,\n+        left: &ImmTy<'tcx, M::PointerTag>,\n+        right: &ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         let (val, _overflowed, ty) = self.overflowing_binary_op(op, left, right)?;\n@@ -269,8 +269,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn overflowing_binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, M::PointerTag>,\n-        right: ImmTy<'tcx, M::PointerTag>,\n+        left: &ImmTy<'tcx, M::PointerTag>,\n+        right: &ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n         trace!(\n             \"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n@@ -347,8 +347,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, M::PointerTag>,\n-        right: ImmTy<'tcx, M::PointerTag>,\n+        left: &ImmTy<'tcx, M::PointerTag>,\n+        right: &ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         let (val, _overflow, ty) = self.overflowing_binary_op(bin_op, left, right)?;\n         Ok(ImmTy::from_scalar(val, self.layout_of(ty)?))\n@@ -359,7 +359,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn overflowing_unary_op(\n         &self,\n         un_op: mir::UnOp,\n-        val: ImmTy<'tcx, M::PointerTag>,\n+        val: &ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n         use rustc_middle::mir::UnOp::*;\n \n@@ -409,7 +409,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n-        val: ImmTy<'tcx, M::PointerTag>,\n+        val: &ImmTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         let (val, _overflow, ty) = self.overflowing_unary_op(un_op, val)?;\n         Ok(ImmTy::from_scalar(val, self.layout_of(ty)?))"}, {"sha": "fa21ca56eba9484d01701da6d41c928be459d7a6", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -248,10 +248,10 @@ impl<'tcx, Tag: Debug + Copy> OpTy<'tcx, Tag> {\n     /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n     /// read from the resulting mplace, not to get its address back.\n     pub fn try_as_mplace(\n-        self,\n+        &self,\n         cx: &impl HasDataLayout,\n     ) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n-        match *self {\n+        match **self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n             Operand::Immediate(_) if self.layout.is_zst() => {\n                 Ok(MPlaceTy::dangling(self.layout, cx))\n@@ -263,7 +263,7 @@ impl<'tcx, Tag: Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n     /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n     /// read from the resulting mplace, not to get its address back.\n-    pub fn assert_mem_place(self, cx: &impl HasDataLayout) -> MPlaceTy<'tcx, Tag> {\n+    pub fn assert_mem_place(&self, cx: &impl HasDataLayout) -> MPlaceTy<'tcx, Tag> {\n         self.try_as_mplace(cx).unwrap()\n     }\n }\n@@ -331,7 +331,7 @@ where\n     /// will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n     pub fn deref_operand(\n         &self,\n-        src: OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let val = self.read_immediate(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n@@ -551,12 +551,12 @@ where\n         Ok(match proj_elem {\n             Field(field, _) => self.mplace_field(base, field.index())?,\n             Downcast(_, variant) => self.mplace_downcast(base, variant)?,\n-            Deref => self.deref_operand(base.into())?,\n+            Deref => self.deref_operand(&base.into())?,\n \n             Index(local) => {\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n                 let n = self.access_local(self.frame(), local, Some(layout))?;\n-                let n = self.read_scalar(n)?;\n+                let n = self.read_scalar(&n)?;\n                 let n = u64::try_from(\n                     self.force_bits(n.check_init()?, self.tcx.data_layout.pointer_size)?,\n                 )\n@@ -637,7 +637,7 @@ where\n         Ok(match proj_elem {\n             Field(field, _) => self.place_field(base, field.index())?,\n             Downcast(_, variant) => self.place_downcast(base, variant)?,\n-            Deref => self.deref_operand(self.place_to_op(base)?)?.into(),\n+            Deref => self.deref_operand(&self.place_to_op(base)?)?.into(),\n             // For the other variants, we have to force an allocation.\n             // This matches `operand_projection`.\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n@@ -697,7 +697,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?)?;\n+            self.validate_operand(&self.place_to_op(dest)?)?;\n         }\n \n         Ok(())\n@@ -714,7 +714,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into())?;\n+            self.validate_operand(&dest.into())?;\n         }\n \n         Ok(())\n@@ -843,14 +843,14 @@ where\n     #[inline(always)]\n     pub fn copy_op(\n         &mut self,\n-        src: OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         self.copy_op_no_validate(src, dest)?;\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?)?;\n+            self.validate_operand(&self.place_to_op(dest)?)?;\n         }\n \n         Ok(())\n@@ -862,7 +862,7 @@ where\n     /// right type.\n     fn copy_op_no_validate(\n         &mut self,\n-        src: OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n@@ -921,7 +921,7 @@ where\n     /// have the same size.\n     pub fn copy_op_transmute(\n         &mut self,\n-        src: OpTy<'tcx, M::PointerTag>,\n+        src: &OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         if mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n@@ -964,7 +964,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into())?;\n+            self.validate_operand(&dest.into())?;\n         }\n \n         Ok(())\n@@ -1118,8 +1118,8 @@ where\n                         ImmTy::from_uint(variant_index_relative, tag_layout);\n                     let tag_val = self.binary_op(\n                         mir::BinOp::Add,\n-                        variant_index_relative_val,\n-                        niche_start_val,\n+                        &variant_index_relative_val,\n+                        &niche_start_val,\n                     )?;\n                     // Write result.\n                     let niche_dest = self.place_field(dest, tag_field)?;"}, {"sha": "b4a2bb809af549c064acf3bd6a4e455fad9c9631", "filename": "compiler/rustc_mir/src/interpret/step.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -162,29 +162,29 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Use(ref operand) => {\n                 // Avoid recomputing the layout\n                 let op = self.eval_operand(operand, Some(dest.layout))?;\n-                self.copy_op(op, dest)?;\n+                self.copy_op(&op, dest)?;\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n                 let layout = binop_left_homogeneous(bin_op).then_some(dest.layout);\n-                let left = self.read_immediate(self.eval_operand(left, layout)?)?;\n+                let left = self.read_immediate(&self.eval_operand(left, layout)?)?;\n                 let layout = binop_right_homogeneous(bin_op).then_some(left.layout);\n-                let right = self.read_immediate(self.eval_operand(right, layout)?)?;\n-                self.binop_ignore_overflow(bin_op, left, right, dest)?;\n+                let right = self.read_immediate(&self.eval_operand(right, layout)?)?;\n+                self.binop_ignore_overflow(bin_op, &left, &right, dest)?;\n             }\n \n             CheckedBinaryOp(bin_op, ref left, ref right) => {\n                 // Due to the extra boolean in the result, we can never reuse the `dest.layout`.\n-                let left = self.read_immediate(self.eval_operand(left, None)?)?;\n+                let left = self.read_immediate(&self.eval_operand(left, None)?)?;\n                 let layout = binop_right_homogeneous(bin_op).then_some(left.layout);\n-                let right = self.read_immediate(self.eval_operand(right, layout)?)?;\n-                self.binop_with_overflow(bin_op, left, right, dest)?;\n+                let right = self.read_immediate(&self.eval_operand(right, layout)?)?;\n+                self.binop_with_overflow(bin_op, &left, &right, dest)?;\n             }\n \n             UnaryOp(un_op, ref operand) => {\n                 // The operand always has the same type as the result.\n-                let val = self.read_immediate(self.eval_operand(operand, Some(dest.layout))?)?;\n-                let val = self.unary_op(un_op, val)?;\n+                let val = self.read_immediate(&self.eval_operand(operand, Some(dest.layout))?)?;\n+                let val = self.unary_op(un_op, &val)?;\n                 assert_eq!(val.layout, dest.layout, \"layout mismatch for result of {:?}\", un_op);\n                 self.write_immediate(*val, dest)?;\n             }\n@@ -208,7 +208,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n                         let field_dest = self.place_field(dest, field_index)?;\n-                        self.copy_op(op, field_dest)?;\n+                        self.copy_op(&op, field_dest)?;\n                     }\n                 }\n             }\n@@ -221,7 +221,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if let Some(first_ptr) = self.check_mplace_access(dest, None)? {\n                     // Write the first.\n                     let first = self.mplace_field(dest, 0)?;\n-                    self.copy_op(op, first.into())?;\n+                    self.copy_op(&op, first.into())?;\n \n                     if length > 1 {\n                         let elem_size = first.layout.size;\n@@ -278,12 +278,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Cast(cast_kind, ref operand, cast_ty) => {\n                 let src = self.eval_operand(operand, None)?;\n                 let cast_ty = self.subst_from_current_frame_and_normalize_erasing_regions(cast_ty);\n-                self.cast(src, cast_kind, cast_ty, dest)?;\n+                self.cast(&src, cast_kind, cast_ty, dest)?;\n             }\n \n             Discriminant(place) => {\n                 let op = self.eval_place_to_op(place, None)?;\n-                let discr_val = self.read_discriminant(op)?.0;\n+                let discr_val = self.read_discriminant(&op)?.0;\n                 self.write_scalar(discr_val, dest)?;\n             }\n         }"}, {"sha": "8c172a581a37cf86dcc831655dbe784eab730dfc", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -25,7 +25,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Goto { target } => self.go_to_block(target),\n \n             SwitchInt { ref discr, ref targets, switch_ty } => {\n-                let discr = self.read_immediate(self.eval_operand(discr, None)?)?;\n+                let discr = self.read_immediate(&self.eval_operand(discr, None)?)?;\n                 trace!(\"SwitchInt({:?})\", *discr);\n                 assert_eq!(discr.layout.ty, switch_ty);\n \n@@ -38,8 +38,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let res = self\n                         .overflowing_binary_op(\n                             mir::BinOp::Eq,\n-                            discr,\n-                            ImmTy::from_uint(const_int, discr.layout),\n+                            &discr,\n+                            &ImmTy::from_uint(const_int, discr.layout),\n                         )?\n                         .0;\n                     if res.to_bool()? {\n@@ -58,7 +58,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (fn_val, abi) = match *func.layout.ty.kind() {\n                     ty::FnPtr(sig) => {\n                         let caller_abi = sig.abi();\n-                        let fn_ptr = self.read_scalar(func)?.check_init()?;\n+                        let fn_ptr = self.read_scalar(&func)?.check_init()?;\n                         let fn_val = self.memory.get_fn(fn_ptr)?;\n                         (fn_val, caller_abi)\n                     }\n@@ -101,7 +101,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n                 let cond_val =\n-                    self.read_immediate(self.eval_operand(cond, None)?)?.to_scalar()?.to_bool()?;\n+                    self.read_immediate(&self.eval_operand(cond, None)?)?.to_scalar()?.to_bool()?;\n                 if expected == cond_val {\n                     self.go_to_block(target);\n                 } else {\n@@ -202,7 +202,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             )\n         }\n         // We allow some transmutes here\n-        self.copy_op_transmute(caller_arg, callee_arg)\n+        self.copy_op_transmute(&caller_arg, callee_arg)\n     }\n \n     /// Call this function -- pushing the stack frame and initializing the arguments.\n@@ -314,7 +314,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let caller_args: Cow<'_, [OpTy<'tcx, M::PointerTag>]> =\n                         if caller_abi == Abi::RustCall && !args.is_empty() {\n                             // Untuple\n-                            let (&untuple_arg, args) = args.split_last().unwrap();\n+                            let (untuple_arg, args) = args.split_last().unwrap();\n                             trace!(\"eval_fn_call: Will pass last argument by untupling\");\n                             Cow::from(\n                                 args.iter()\n@@ -397,7 +397,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let receiver_place = match args[0].layout.ty.builtin_deref(true) {\n                     Some(_) => {\n                         // Built-in pointer.\n-                        self.deref_operand(args[0])?\n+                        self.deref_operand(&args[0])?\n                     }\n                     None => {\n                         // Unsized self."}, {"sha": "9c2ae1c7fe30e6d1c729720c9aec9ef0cf10906b", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -375,7 +375,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     /// Check a reference or `Box`.\n     fn check_safe_pointer(\n         &mut self,\n-        value: OpTy<'tcx, M::PointerTag>,\n+        value: &OpTy<'tcx, M::PointerTag>,\n         kind: &str,\n     ) -> InterpResult<'tcx> {\n         let value = try_validation!(\n@@ -491,7 +491,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn read_scalar(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<M::PointerTag>> {\n         Ok(try_validation!(\n             self.ecx.read_scalar(op),\n@@ -504,7 +504,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     /// at that type.  Return `true` if the type is indeed primitive.\n     fn try_visit_primitive(\n         &mut self,\n-        value: OpTy<'tcx, M::PointerTag>,\n+        value: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, bool> {\n         // Go over all the primitive types\n         let ty = value.layout.ty;\n@@ -552,7 +552,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // actually enforce the strict rules for raw pointers (mostly because\n                 // that lets us re-use `ref_to_mplace`).\n                 let place = try_validation!(\n-                    self.ecx.read_immediate(value).and_then(|i| self.ecx.ref_to_mplace(i)),\n+                    self.ecx.read_immediate(value).and_then(|ref i| self.ecx.ref_to_mplace(i)),\n                     self.path,\n                     err_ub!(InvalidUninitBytes(None)) => { \"uninitialized raw pointer\" },\n                     err_unsup!(ReadPointerAsBytes) => { \"part of a pointer\" } expected { \"a proper pointer or integer value\" },\n@@ -631,7 +631,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn visit_scalar(\n         &mut self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         scalar_layout: &Scalar,\n     ) -> InterpResult<'tcx> {\n         let value = self.read_scalar(op)?;\n@@ -705,7 +705,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n \n     fn read_discriminant(\n         &mut self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, VariantIdx> {\n         self.with_elem(PathElem::EnumTag, move |this| {\n             Ok(try_validation!(\n@@ -725,9 +725,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     #[inline]\n     fn visit_field(\n         &mut self,\n-        old_op: OpTy<'tcx, M::PointerTag>,\n+        old_op: &OpTy<'tcx, M::PointerTag>,\n         field: usize,\n-        new_op: OpTy<'tcx, M::PointerTag>,\n+        new_op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         let elem = self.aggregate_field_path_elem(old_op.layout, field);\n         self.with_elem(elem, move |this| this.visit_value(new_op))\n@@ -736,9 +736,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     #[inline]\n     fn visit_variant(\n         &mut self,\n-        old_op: OpTy<'tcx, M::PointerTag>,\n+        old_op: &OpTy<'tcx, M::PointerTag>,\n         variant_id: VariantIdx,\n-        new_op: OpTy<'tcx, M::PointerTag>,\n+        new_op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         let name = match old_op.layout.ty.kind() {\n             ty::Adt(adt, _) => PathElem::Variant(adt.variants[variant_id].ident.name),\n@@ -752,14 +752,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     #[inline(always)]\n     fn visit_union(\n         &mut self,\n-        _op: OpTy<'tcx, M::PointerTag>,\n+        _op: &OpTy<'tcx, M::PointerTag>,\n         _fields: NonZeroUsize,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n     #[inline]\n-    fn visit_value(&mut self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+    fn visit_value(&mut self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n \n         // Check primitive types -- the leafs of our recursive descend.\n@@ -816,7 +816,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n \n     fn visit_aggregate(\n         &mut self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         fields: impl Iterator<Item = InterpResult<'tcx, Self::V>>,\n     ) -> InterpResult<'tcx> {\n         match op.layout.ty.kind() {\n@@ -918,7 +918,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn validate_operand_internal(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n         ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n         ctfe_mode: Option<CtfeValidationMode>,\n@@ -929,10 +929,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let mut visitor = ValidityVisitor { path, ref_tracking, ctfe_mode, ecx: self };\n \n         // Try to cast to ptr *once* instead of all the time.\n-        let op = self.force_op_ptr(op).unwrap_or(op);\n+        let op = self.force_op_ptr(&op).unwrap_or(*op);\n \n         // Run it.\n-        match visitor.visit_value(op) {\n+        match visitor.visit_value(&op) {\n             Ok(()) => Ok(()),\n             // Pass through validation failures.\n             Err(err) if matches!(err.kind, err_ub!(ValidationFailure { .. })) => Err(err),\n@@ -960,7 +960,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn const_validate_operand(\n         &self,\n-        op: OpTy<'tcx, M::PointerTag>,\n+        op: &OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n         ref_tracking: &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n         ctfe_mode: CtfeValidationMode,\n@@ -972,7 +972,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// `op` is assumed to cover valid memory if it is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     #[inline(always)]\n-    pub fn validate_operand(&self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+    pub fn validate_operand(&self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         self.validate_operand_internal(op, vec![], None, None)\n     }\n }"}, {"sha": "7efed19362680e20644f294329e7099f122116ed", "filename": "compiler/rustc_mir/src/interpret/visitor.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -18,20 +18,20 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     fn layout(&self) -> TyAndLayout<'tcx>;\n \n     /// Makes this into an `OpTy`.\n-    fn to_op(self, ecx: &InterpCx<'mir, 'tcx, M>) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+    fn to_op(&self, ecx: &InterpCx<'mir, 'tcx, M>) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n \n     /// Creates this from an `MPlaceTy`.\n     fn from_mem_place(mplace: MPlaceTy<'tcx, M::PointerTag>) -> Self;\n \n     /// Projects to the given enum variant.\n     fn project_downcast(\n-        self,\n+        &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self>;\n \n     /// Projects to the n-th field.\n-    fn project_field(self, ecx: &InterpCx<'mir, 'tcx, M>, field: usize)\n+    fn project_field(&self, ecx: &InterpCx<'mir, 'tcx, M>, field: usize)\n     -> InterpResult<'tcx, Self>;\n }\n \n@@ -45,10 +45,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tc\n \n     #[inline(always)]\n     fn to_op(\n-        self,\n+        &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        Ok(self)\n+        Ok(*self)\n     }\n \n     #[inline(always)]\n@@ -58,7 +58,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tc\n \n     #[inline(always)]\n     fn project_downcast(\n-        self,\n+        &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n@@ -67,7 +67,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tc\n \n     #[inline(always)]\n     fn project_field(\n-        self,\n+        &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         field: usize,\n     ) -> InterpResult<'tcx, Self> {\n@@ -85,10 +85,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n \n     #[inline(always)]\n     fn to_op(\n-        self,\n+        &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        Ok(self.into())\n+        Ok((*self).into())\n     }\n \n     #[inline(always)]\n@@ -98,20 +98,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n \n     #[inline(always)]\n     fn project_downcast(\n-        self,\n+        &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n-        ecx.mplace_downcast(self, variant)\n+        ecx.mplace_downcast(*self, variant)\n     }\n \n     #[inline(always)]\n     fn project_field(\n-        self,\n+        &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         field: usize,\n     ) -> InterpResult<'tcx, Self> {\n-        ecx.mplace_field(self, field)\n+        ecx.mplace_field(*self, field)\n     }\n }\n \n@@ -129,21 +129,21 @@ macro_rules! make_value_visitor {\n             #[inline(always)]\n             fn read_discriminant(\n                 &mut self,\n-                op: OpTy<'tcx, M::PointerTag>,\n+                op: &OpTy<'tcx, M::PointerTag>,\n             ) -> InterpResult<'tcx, VariantIdx> {\n                 Ok(self.ecx().read_discriminant(op)?.1)\n             }\n \n             // Recursive actions, ready to be overloaded.\n             /// Visits the given value, dispatching as appropriate to more specialized visitors.\n             #[inline(always)]\n-            fn visit_value(&mut self, v: Self::V) -> InterpResult<'tcx>\n+            fn visit_value(&mut self, v: &Self::V) -> InterpResult<'tcx>\n             {\n                 self.walk_value(v)\n             }\n             /// Visits the given value as a union. No automatic recursion can happen here.\n             #[inline(always)]\n-            fn visit_union(&mut self, _v: Self::V, _fields: NonZeroUsize) -> InterpResult<'tcx>\n+            fn visit_union(&mut self, _v: &Self::V, _fields: NonZeroUsize) -> InterpResult<'tcx>\n             {\n                 Ok(())\n             }\n@@ -153,7 +153,7 @@ macro_rules! make_value_visitor {\n             #[inline(always)]\n             fn visit_aggregate(\n                 &mut self,\n-                v: Self::V,\n+                v: &Self::V,\n                 fields: impl Iterator<Item=InterpResult<'tcx, Self::V>>,\n             ) -> InterpResult<'tcx> {\n                 self.walk_aggregate(v, fields)\n@@ -167,9 +167,9 @@ macro_rules! make_value_visitor {\n             #[inline(always)]\n             fn visit_field(\n                 &mut self,\n-                _old_val: Self::V,\n+                _old_val: &Self::V,\n                 _field: usize,\n-                new_val: Self::V,\n+                new_val: &Self::V,\n             ) -> InterpResult<'tcx> {\n                 self.visit_value(new_val)\n             }\n@@ -179,26 +179,26 @@ macro_rules! make_value_visitor {\n             #[inline(always)]\n             fn visit_variant(\n                 &mut self,\n-                _old_val: Self::V,\n+                _old_val: &Self::V,\n                 _variant: VariantIdx,\n-                new_val: Self::V,\n+                new_val: &Self::V,\n             ) -> InterpResult<'tcx> {\n                 self.visit_value(new_val)\n             }\n \n             // Default recursors. Not meant to be overloaded.\n             fn walk_aggregate(\n                 &mut self,\n-                v: Self::V,\n+                v: &Self::V,\n                 fields: impl Iterator<Item=InterpResult<'tcx, Self::V>>,\n             ) -> InterpResult<'tcx> {\n                 // Now iterate over it.\n                 for (idx, field_val) in fields.enumerate() {\n-                    self.visit_field(v, idx, field_val?)?;\n+                    self.visit_field(v, idx, &field_val?)?;\n                 }\n                 Ok(())\n             }\n-            fn walk_value(&mut self, v: Self::V) -> InterpResult<'tcx>\n+            fn walk_value(&mut self, v: &Self::V) -> InterpResult<'tcx>\n             {\n                 trace!(\"walk_value: type: {}\", v.layout().ty);\n \n@@ -211,7 +211,7 @@ macro_rules! make_value_visitor {\n                         let inner = self.ecx().unpack_dyn_trait(dest)?.1;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n                         // recurse with the inner type\n-                        return self.visit_field(v, 0, Value::from_mem_place(inner));\n+                        return self.visit_field(&v, 0, &Value::from_mem_place(inner));\n                     },\n                     // Slices do not need special handling here: they have `Array` field\n                     // placement with length 0, so we enter the `Array` case below which\n@@ -254,11 +254,11 @@ macro_rules! make_value_visitor {\n                     // with *its* fields.\n                     Variants::Multiple { .. } => {\n                         let op = v.to_op(self.ecx())?;\n-                        let idx = self.read_discriminant(op)?;\n+                        let idx = self.read_discriminant(&op)?;\n                         let inner = v.project_downcast(self.ecx(), idx)?;\n                         trace!(\"walk_value: variant layout: {:#?}\", inner.layout());\n                         // recurse with the inner type\n-                        self.visit_variant(v, idx, inner)\n+                        self.visit_variant(v, idx, &inner)\n                     }\n                     // For single-variant layouts, we already did anything there is to do.\n                     Variants::Single { .. } => Ok(())"}, {"sha": "90143c616c5e07eb4cb3be275ee97558b088a99b", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e915cf45dc48e90653081f9d760a7f4f803ce428/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=e915cf45dc48e90653081f9d760a7f4f803ce428", "patch": "@@ -228,8 +228,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     fn binary_ptr_op(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _bin_op: BinOp,\n-        _left: ImmTy<'tcx>,\n-        _right: ImmTy<'tcx>,\n+        _left: &ImmTy<'tcx>,\n+        _right: &ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n         // We can't do this because aliasing of memory can differ between const eval and llvm\n         throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n@@ -426,7 +426,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n-        Some(match self.ecx.try_read_immediate(op) {\n+        Some(match self.ecx.try_read_immediate(&op) {\n             Ok(Ok(imm)) => imm.into(),\n             _ => op,\n         })\n@@ -548,8 +548,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<()> {\n         if let (val, true) = self.use_ecx(|this| {\n-            let val = this.ecx.read_immediate(this.ecx.eval_operand(arg, None)?)?;\n-            let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, val)?;\n+            let val = this.ecx.read_immediate(&this.ecx.eval_operand(arg, None)?)?;\n+            let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, &val)?;\n             Ok((val, overflow))\n         })? {\n             // `AssertKind` only has an `OverflowNeg` variant, so make sure that is\n@@ -573,8 +573,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         right: &Operand<'tcx>,\n         source_info: SourceInfo,\n     ) -> Option<()> {\n-        let r = self.use_ecx(|this| this.ecx.read_immediate(this.ecx.eval_operand(right, None)?));\n-        let l = self.use_ecx(|this| this.ecx.read_immediate(this.ecx.eval_operand(left, None)?));\n+        let r = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?));\n+        let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if op == BinOp::Shr || op == BinOp::Shl {\n             let r = r?;\n@@ -609,7 +609,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             }\n         }\n \n-        if let (Some(l), Some(r)) = (l, r) {\n+        if let (Some(l), Some(r)) = (&l, &r) {\n             // The remaining operators are handled through `overflowing_binary_op`.\n             if self.use_ecx(|this| {\n                 let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n@@ -630,7 +630,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         match *operand {\n             Operand::Copy(l) | Operand::Move(l) => {\n                 if let Some(value) = self.get_const(l) {\n-                    if self.should_const_prop(value) {\n+                    if self.should_const_prop(&value) {\n                         // FIXME(felix91gr): this code only handles `Scalar` cases.\n                         // For now, we're not handling `ScalarPair` cases because\n                         // doing so here would require a lot of code duplication.\n@@ -745,7 +745,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     let r = this.ecx.eval_operand(right, None);\n \n                     let const_arg = match (l, r) {\n-                        (Ok(x), Err(_)) | (Err(_), Ok(x)) => this.ecx.read_immediate(x)?,\n+                        (Ok(ref x), Err(_)) | (Err(_), Ok(ref x)) => this.ecx.read_immediate(x)?,\n                         (Err(e), Err(_)) => return Err(e),\n                         (Ok(_), Ok(_)) => {\n                             this.ecx.eval_rvalue_into_place(rvalue, place)?;\n@@ -809,7 +809,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn replace_with_const(\n         &mut self,\n         rval: &mut Rvalue<'tcx>,\n-        value: OpTy<'tcx>,\n+        value: &OpTy<'tcx>,\n         source_info: SourceInfo,\n     ) {\n         if let Rvalue::Use(Operand::Constant(c)) = rval {\n@@ -902,7 +902,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     /// Returns `true` if and only if this `op` should be const-propagated into.\n-    fn should_const_prop(&mut self, op: OpTy<'tcx>) -> bool {\n+    fn should_const_prop(&mut self, op: &OpTy<'tcx>) -> bool {\n         let mir_opt_level = self.tcx.sess.opts.debugging_opts.mir_opt_level;\n \n         if mir_opt_level == 0 {\n@@ -913,7 +913,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return false;\n         }\n \n-        match *op {\n+        match **op {\n             interpret::Operand::Immediate(Immediate::Scalar(ScalarMaybeUninit::Scalar(s))) => {\n                 s.is_bits()\n             }\n@@ -1094,7 +1094,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 // This will return None if the above `const_prop` invocation only \"wrote\" a\n                 // type whose creation requires no write. E.g. a generator whose initial state\n                 // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                if let Some(value) = self.get_const(place) {\n+                if let Some(ref value) = self.get_const(place) {\n                     if self.should_const_prop(value) {\n                         trace!(\"replacing {:?} with {:?}\", rval, value);\n                         self.replace_with_const(rval, value, source_info);\n@@ -1177,10 +1177,10 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n         self.super_terminator(terminator, location);\n         match &mut terminator.kind {\n             TerminatorKind::Assert { expected, ref msg, ref mut cond, .. } => {\n-                if let Some(value) = self.eval_operand(&cond, source_info) {\n+                if let Some(ref value) = self.eval_operand(&cond, source_info) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                     let expected = ScalarMaybeUninit::from(Scalar::from_bool(*expected));\n-                    let value_const = self.ecx.read_scalar(value).unwrap();\n+                    let value_const = self.ecx.read_scalar(&value).unwrap();\n                     if expected != value_const {\n                         enum DbgVal<T> {\n                             Val(T),\n@@ -1199,7 +1199,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                             // triggered the assert on the value of the rhs.\n                             match self.eval_operand(op, source_info) {\n                                 Some(op) => {\n-                                    DbgVal::Val(self.ecx.read_immediate(op).unwrap().to_const_int())\n+                                    DbgVal::Val(self.ecx.read_immediate(&op).unwrap().to_const_int())\n                                 }\n                                 None => DbgVal::Underscore,\n                             }"}]}