{"sha": "cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYTg4ZWJiMzk0MDJjZWVlOWVjNWY3Y2Q2MWM4NzdhZTRjZDE2ZGM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-07-16T20:18:20Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-07-22T11:32:56Z"}, "message": "refactor type error reporting", "tree": {"sha": "08fcaf5551494eeca21ce37d2d0019e44b7af3ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08fcaf5551494eeca21ce37d2d0019e44b7af3ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc", "html_url": "https://github.com/rust-lang/rust/commit/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eb12d91aaf95432ca73bda429af04e0710c984d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb12d91aaf95432ca73bda429af04e0710c984d", "html_url": "https://github.com/rust-lang/rust/commit/8eb12d91aaf95432ca73bda429af04e0710c984d"}], "stats": {"total": 344, "additions": 141, "deletions": 203}, "files": [{"sha": "be73818c8a4ebdea291bded641e3bb5e00e35d28", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 82, "deletions": 153, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc", "patch": "@@ -83,7 +83,7 @@ use hir::def_id::DefId;\n use infer::{self, TypeOrigin};\n use middle::region;\n use ty::subst;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, ReFree};\n use ty::error::TypeError;\n \n@@ -462,52 +462,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn report_type_error(&self,\n-                         trace: TypeTrace<'tcx>,\n-                         terr: &TypeError<'tcx>)\n-                         -> DiagnosticBuilder<'tcx> {\n-        let (expected, found) = match self.values_str(&trace.values) {\n-            Some(v) => v,\n-            None => {\n-                return self.tcx.sess.diagnostic().struct_dummy(); /* derived error */\n-            }\n-        };\n-\n-        let is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n-            values.expected.is_primitive() && values.found.is_primitive()\n-        } else {\n-            false\n-        };\n-\n-        let mut err = struct_span_err!(self.tcx.sess,\n-                                       trace.origin.span(),\n-                                       E0308,\n-                                       \"{}\",\n-                                       trace.origin);\n-\n-        if !is_simple_error || check_old_school() {\n-            err.note_expected_found(&\"type\", &expected, &found);\n-        }\n-\n-        err.span_label(trace.origin.span(), &terr);\n-\n-        self.check_and_note_conflicting_crates(&mut err, terr, trace.origin.span());\n-\n-        match trace.origin {\n-            TypeOrigin::MatchExpressionArm(_, arm_span, source) => match source {\n-                hir::MatchSource::IfLetDesugar{..} => {\n-                    err.span_note(arm_span, \"`if let` arm with an incompatible type\");\n-                }\n-                _ => {\n-                    err.span_note(arm_span, \"match arm with an incompatible type\");\n-                }\n-            },\n-            _ => ()\n-        }\n-\n-        err\n-    }\n-\n     /// Adds a note if the types come from similarly named crates\n     fn check_and_note_conflicting_crates(&self,\n                                          err: &mut DiagnosticBuilder,\n@@ -550,43 +504,91 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn report_and_explain_type_error(&self,\n-                                         trace: TypeTrace<'tcx>,\n-                                         terr: &TypeError<'tcx>)\n-                                         -> DiagnosticBuilder<'tcx> {\n-        let trace = self.resolve_type_vars_if_possible(&trace);\n+    fn note_error_origin(&self,\n+                         err: &mut DiagnosticBuilder<'tcx>,\n+                         origin: &TypeOrigin)\n+    {\n+        match origin {\n+            &TypeOrigin::MatchExpressionArm(_, arm_span, source) => match source {\n+                hir::MatchSource::IfLetDesugar {..} => {\n+                    err.span_note(arm_span, \"`if let` arm with an incompatible type\");\n+                }\n+                _ => {\n+                    err.span_note(arm_span, \"match arm with an incompatible type\");\n+                }\n+            },\n+            _ => ()\n+        }\n+    }\n+\n+    pub fn report_and_explain_type_error_with_code(&self,\n+                                                   trace: TypeTrace<'tcx>,\n+                                                   terr: &TypeError<'tcx>,\n+                                                   message: &str,\n+                                                   code: &str)\n+                                                   -> DiagnosticBuilder<'tcx>\n+    {\n+        let (expected, found) = match self.values_str(&trace.values) {\n+            Some((expected, found)) => (expected, found),\n+            None => return self.tcx.sess.diagnostic().struct_dummy() /* derived error */\n+        };\n+\n         let span = trace.origin.span();\n-        let mut err = self.report_type_error(trace, terr);\n+\n+        let is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n+            values.expected.is_primitive() && values.found.is_primitive()\n+        } else {\n+            false\n+        };\n+\n+        let mut err = self.tcx.sess.struct_span_err_with_code(\n+            trace.origin.span(),\n+            message,\n+            code);\n+\n+        if !is_simple_error || check_old_school() {\n+            err.note_expected_found(&\"type\", &expected, &found);\n+        }\n+\n+        err.span_label(span, &terr);\n+\n+        self.note_error_origin(&mut err, &trace.origin);\n+        self.check_and_note_conflicting_crates(&mut err, terr, span);\n         self.tcx.note_and_explain_type_err(&mut err, terr, span);\n+\n         err\n     }\n \n-    /// Returns a string of the form \"expected `{}`, found `{}`\", or None if this is a derived\n-    /// error.\n+    pub fn report_and_explain_type_error(&self,\n+                                         trace: TypeTrace<'tcx>,\n+                                         terr: &TypeError<'tcx>)\n+                                         -> DiagnosticBuilder<'tcx>\n+    {\n+        // FIXME: do we want to use a different error code for each origin?\n+        let failure_str = trace.origin.as_failure_str();\n+        type_err!(self, trace, terr, E0308, \"{}\", failure_str)\n+    }\n+\n+    /// Returns a string of the form \"expected `{}`, found `{}`\".\n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<(String, String)> {\n         match *values {\n             infer::Types(ref exp_found) => self.expected_found_str(exp_found),\n             infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n-            infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found)\n+            infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n         }\n     }\n \n-    fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + TypeFoldable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>)\n         -> Option<(String, String)>\n     {\n-        let expected = exp_found.expected.resolve(self);\n-        if expected.references_error() {\n+        let exp_found = self.resolve_type_vars_if_possible(exp_found);\n+        if exp_found.references_error() {\n             return None;\n         }\n \n-        let found = exp_found.found.resolve(self);\n-        if found.references_error() {\n-            return None;\n-        }\n-\n-        Some((format!(\"{}\", expected), format!(\"{}\", found)))\n+        Some((format!(\"{}\", exp_found.expected), format!(\"{}\", exp_found.found)))\n     }\n \n     fn report_generic_bound_failure(&self,\n@@ -1609,68 +1611,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn note_region_origin(&self, err: &mut DiagnosticBuilder, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n             infer::Subtype(ref trace) => {\n-                let desc = match trace.origin {\n-                    TypeOrigin::Misc(_) => {\n-                        \"types are compatible\"\n-                    }\n-                    TypeOrigin::MethodCompatCheck(_) => {\n-                        \"method type is compatible with trait\"\n-                    }\n-                    TypeOrigin::ExprAssignable(_) => {\n-                        \"expression is assignable\"\n-                    }\n-                    TypeOrigin::RelateTraitRefs(_) => {\n-                        \"traits are compatible\"\n-                    }\n-                    TypeOrigin::RelateSelfType(_) => {\n-                        \"self type matches impl self type\"\n-                    }\n-                    TypeOrigin::RelateOutputImplTypes(_) => {\n-                        \"trait type parameters matches those \\\n-                                 specified on the impl\"\n-                    }\n-                    TypeOrigin::MatchExpressionArm(_, _, _) => {\n-                        \"match arms have compatible types\"\n-                    }\n-                    TypeOrigin::IfExpression(_) => {\n-                        \"if and else have compatible types\"\n-                    }\n-                    TypeOrigin::IfExpressionWithNoElse(_) => {\n-                        \"if may be missing an else clause\"\n-                    }\n-                    TypeOrigin::RangeExpression(_) => {\n-                        \"start and end of range have compatible types\"\n-                    }\n-                    TypeOrigin::EquatePredicate(_) => {\n-                        \"equality where clause is satisfied\"\n-                    }\n-                    TypeOrigin::MainFunctionType(_) => {\n-                        \"the `main` function has the correct type\"\n-                    }\n-                    TypeOrigin::StartFunctionType(_) => {\n-                        \"the `start` function has the correct type\"\n-                    }\n-                    TypeOrigin::IntrinsicType(_) => {\n-                        \"the intrinsic has the correct type\"\n-                    }\n-                };\n-\n-                match self.values_str(&trace.values) {\n-                    Some((expected, found)) => {\n-                        err.span_note(\n-                            trace.origin.span(),\n-                            &format!(\"...so that {} (expected {}, found {})\",\n-                                    desc, expected, found));\n-                    }\n-                    None => {\n-                        // Really should avoid printing this error at\n-                        // all, since it is derived, but that would\n-                        // require more refactoring than I feel like\n-                        // doing right now. - nmatsakis\n-                        err.span_note(\n-                            trace.origin.span(),\n-                            &format!(\"...so that {}\", desc));\n-                    }\n+                if let Some((expected, found)) = self.values_str(&trace.values) {\n+                    // FIXME: do we want a \"the\" here?\n+                    err.span_note(\n+                        trace.origin.span(),\n+                        &format!(\"...so that {} (expected {}, found {})\",\n+                                 trace.origin.as_requirement_str(), expected, found));\n+                } else {\n+                    // FIXME: this really should be handled at some earlier stage. Our\n+                    // handling of region checking when type errors are present is\n+                    // *terrible*.\n+\n+                    err.span_note(\n+                        trace.origin.span(),\n+                        &format!(\"...so that {}\",\n+                                 trace.origin.as_requirement_str()));\n                 }\n             }\n             infer::Reborrow(span) => {\n@@ -1813,32 +1768,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub trait Resolvable<'tcx> {\n-    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self;\n-}\n-\n-impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n-    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        infcx.resolve_type_vars_if_possible(self)\n-    }\n-}\n-\n-impl<'tcx> Resolvable<'tcx> for ty::TraitRef<'tcx> {\n-    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                         -> ty::TraitRef<'tcx> {\n-        infcx.resolve_type_vars_if_possible(self)\n-    }\n-}\n-\n-impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n-    fn resolve<'a, 'gcx>(&self,\n-                         infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                         -> ty::PolyTraitRef<'tcx>\n-    {\n-        infcx.resolve_type_vars_if_possible(self)\n-    }\n-}\n-\n fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                       scope_id: ast::NodeId)\n                                       -> Vec<hir::LifetimeDef> {"}, {"sha": "fd65e06ea972c7ff7dcfd54b5c453aac1abe0c63", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc", "patch": "@@ -231,7 +231,7 @@ pub enum TypeOrigin {\n }\n \n impl TypeOrigin {\n-    fn as_str(&self) -> &'static str {\n+    fn as_failure_str(&self) -> &'static str {\n         match self {\n             &TypeOrigin::Misc(_) |\n             &TypeOrigin::RelateSelfType(_) |\n@@ -252,11 +252,26 @@ impl TypeOrigin {\n             &TypeOrigin::IntrinsicType(_) => \"intrinsic has wrong type\",\n         }\n     }\n-}\n \n-impl fmt::Display for TypeOrigin {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(),fmt::Error> {\n-        fmt::Display::fmt(self.as_str(), f)\n+    fn as_requirement_str(&self) -> &'static str {\n+        match self {\n+            &TypeOrigin::Misc(_) => \"types are compatible\",\n+            &TypeOrigin::MethodCompatCheck(_) => \"method type is compatible with trait\",\n+            &TypeOrigin::ExprAssignable(_) => \"expression is assignable\",\n+            &TypeOrigin::RelateTraitRefs(_) => \"traits are compatible\",\n+            &TypeOrigin::RelateSelfType(_) => \"self type matches impl self type\",\n+            &TypeOrigin::RelateOutputImplTypes(_) => {\n+                \"trait type parameters matches those specified on the impl\"\n+            }\n+            &TypeOrigin::MatchExpressionArm(_, _, _) => \"match arms have compatible types\",\n+            &TypeOrigin::IfExpression(_) => \"if and else have compatible types\",\n+            &TypeOrigin::IfExpressionWithNoElse(_) => \"if missing an else returns ()\",\n+            &TypeOrigin::RangeExpression(_) => \"start and end of range have compatible types\",\n+            &TypeOrigin::EquatePredicate(_) => \"equality where clause is satisfied\",\n+            &TypeOrigin::MainFunctionType(_) => \"`main` function has the correct type\",\n+            &TypeOrigin::StartFunctionType(_) => \"`start` function has the correct type\",\n+            &TypeOrigin::IntrinsicType(_) => \"intrinsic has the correct type\",\n+        }\n     }\n }\n \n@@ -1489,22 +1504,20 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn type_error_message<M>(&self,\n                                  sp: Span,\n                                  mk_msg: M,\n-                                 actual_ty: Ty<'tcx>,\n-                                 err: Option<&TypeError<'tcx>>)\n+                                 actual_ty: Ty<'tcx>)\n         where M: FnOnce(String) -> String,\n     {\n-        self.type_error_struct(sp, mk_msg, actual_ty, err).emit();\n+        self.type_error_struct(sp, mk_msg, actual_ty).emit();\n     }\n \n     pub fn type_error_struct<M>(&self,\n                                 sp: Span,\n                                 mk_msg: M,\n-                                actual_ty: Ty<'tcx>,\n-                                err: Option<&TypeError<'tcx>>)\n+                                actual_ty: Ty<'tcx>)\n                                 -> DiagnosticBuilder<'tcx>\n         where M: FnOnce(String) -> String,\n     {\n-        debug!(\"type_error_struct({:?}, {:?}, {:?})\", sp, actual_ty, err);\n+        debug!(\"type_error_struct({:?}, {:?})\", sp, actual_ty);\n \n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n \n@@ -1513,21 +1526,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             return self.tcx.sess.diagnostic().struct_dummy();\n         }\n \n-        let error_str = err.map_or(\"\".to_string(), |t_err| {\n-            format!(\" ({})\", t_err)\n-        });\n-\n         let msg = mk_msg(self.ty_to_string(actual_ty));\n \n         // FIXME: use an error code.\n-        let mut db = self.tcx.sess.struct_span_err(\n-            sp, &format!(\"{} {}\", msg, error_str));\n-\n-        if let Some(err) = err {\n-            self.tcx.note_and_explain_type_err(&mut db, err, sp);\n-        }\n-\n-        db\n+        self.tcx.sess.struct_span_err(sp, &msg)\n     }\n \n     pub fn report_mismatched_types(&self,"}, {"sha": "52420475db1002db565b5f9541caf5d338782cb8", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc", "patch": "@@ -59,3 +59,15 @@ macro_rules! span_bug {\n         $crate::session::span_bug_fmt(file!(), line!(), $span, format_args!($($message)*))\n     })\n }\n+\n+#[macro_export]\n+macro_rules! type_err {\n+    ($infcx:expr, $trace: expr, $terr: expr, $code:ident, $($message:tt)*) => ({\n+        __diagnostic_used!($code);\n+        $infcx.report_and_explain_type_error_with_code(\n+            $trace,\n+            $terr,\n+            &format!($($message)*),\n+            stringify!($code))\n+    })\n+}"}, {"sha": "9c6727ebbfcf955d30f6507ef5b1719b3b5314d5", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc", "patch": "@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => {\n                 let mut err = self.type_error_struct(call_expr.span, |actual| {\n                     format!(\"expected function, found `{}`\", actual)\n-                }, callee_ty, None);\n+                }, callee_ty);\n \n                 if let hir::ExprCall(ref expr, _) = call_expr.node {\n                     let tcx = self.tcx;"}, {"sha": "7a4cc09a7d5064d3a9ac408103df64cdf885dca3", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None)\n+                }, self.expr_ty)\n                     .help(&format!(\"cast through {} first\", match e {\n                             CastError::NeedViaPtr => \"a raw pointer\",\n                             CastError::NeedViaThinPtr => \"a thin pointer\",\n@@ -167,35 +167,35 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             CastError::CastToChar => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n-                }, self.expr_ty, None);\n+                }, self.expr_ty);\n             }\n             CastError::NonScalar => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"non-scalar cast: `{}` as `{}`\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None);\n+                }, self.expr_ty);\n             }\n             CastError::IllegalCast => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None);\n+                }, self.expr_ty);\n             }\n             CastError::SizedUnsizedCast => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"cannot cast thin pointer `{}` to fat pointer `{}`\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None)\n+                }, self.expr_ty)\n             }\n             CastError::DifferingKinds => {\n                 fcx.type_error_struct(self.span, |actual| {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None)\n+                }, self.expr_ty)\n                     .note(\"vtable kinds may not match\")\n                     .emit();\n             }\n@@ -213,7 +213,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         let tstr = fcx.ty_to_string(self.cast_ty);\n         let mut err = fcx.type_error_struct(self.span, |actual| {\n             format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n-        }, self.expr_ty, None);\n+        }, self.expr_ty);\n         match self.expr_ty.sty {\n             ty::TyRef(_, ty::TypeAndMut { mutbl: mt, .. }) => {\n                 let mtstr = match mt {\n@@ -484,4 +484,3 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundSized, span)\n     }\n }\n-"}, {"sha": "346449d0a51331465bde2b99b5eec3048bb74e7c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc", "patch": "@@ -160,8 +160,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 item_name,\n                                 actual)\n                     },\n-                    rcvr_ty,\n-                    None);\n+                    rcvr_ty);\n \n                 // If the item has the name of a field, give a help note\n                 if let (&ty::TyStruct(def, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {"}, {"sha": "7076b6a2a900b23da8930f94ca222a6c9355b98e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc", "patch": "@@ -2541,21 +2541,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.type_error_message(arg.span, |t| {\n                             format!(\"can't pass an `{}` to variadic \\\n                                      function, cast to `c_double`\", t)\n-                        }, arg_ty, None);\n+                        }, arg_ty);\n                     }\n                     ty::TyInt(ast::IntTy::I8) | ty::TyInt(ast::IntTy::I16) | ty::TyBool => {\n                         self.type_error_message(arg.span, |t| {\n                             format!(\"can't pass `{}` to variadic \\\n                                      function, cast to `c_int`\",\n                                            t)\n-                        }, arg_ty, None);\n+                        }, arg_ty);\n                     }\n                     ty::TyUint(ast::UintTy::U8) | ty::TyUint(ast::UintTy::U16) => {\n                         self.type_error_message(arg.span, |t| {\n                             format!(\"can't pass `{}` to variadic \\\n                                      function, cast to `c_uint`\",\n                                            t)\n-                        }, arg_ty, None);\n+                        }, arg_ty);\n                     }\n                     ty::TyFnDef(_, _, f) => {\n                         let ptr_ty = self.tcx.mk_fn_ptr(f);\n@@ -2564,7 +2564,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                 |t| {\n                             format!(\"can't pass `{}` to variadic \\\n                                      function, cast to `{}`\", t, ptr_ty)\n-                        }, arg_ty, None);\n+                        }, arg_ty);\n                     }\n                     _ => {}\n                 }\n@@ -2908,9 +2908,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.type_error_struct(field.span, |actual| {\n                 format!(\"attempted to take value of method `{}` on type \\\n                          `{}`\", field.node, actual)\n-            }, expr_t, None)\n-                .help(\n-                       \"maybe a `()` to call it is missing? \\\n+            }, expr_t)\n+                .help(\"maybe a `()` to call it is missing? \\\n                        If not, try an anonymous function\")\n                 .emit();\n             self.write_error(expr.id);\n@@ -2919,7 +2918,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"attempted access of field `{}` on type `{}`, \\\n                          but no field with that name was found\",\n                         field.node, actual)\n-            }, expr_t, None);\n+            }, expr_t);\n             if let ty::TyStruct(def, _) = expr_t.sty {\n                 Self::suggest_field_names(&mut err, def.struct_variant(), field, vec![]);\n             }\n@@ -3019,7 +3018,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     actual)\n                 }\n             },\n-            expr_t, None);\n+            expr_t);\n \n         self.write_error(expr.id);\n     }\n@@ -3038,8 +3037,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"structure `{}` has no field named `{}`\",\n                         actual, field.name.node)\n             },\n-            ty,\n-            None);\n+            ty);\n         // prevent all specified fields from being suggested\n         let skip_fields = skip_fields.iter().map(|ref x| x.name.node.as_str());\n         Self::suggest_field_names(&mut err, variant, &field.name, skip_fields.collect());\n@@ -3272,7 +3270,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             self.type_error_message(expr.span, |actual| {\n                                 format!(\"type `{}` cannot be \\\n                                         dereferenced\", actual)\n-                            }, oprnd_t, None);\n+                            }, oprnd_t);\n                             oprnd_t = tcx.types.err;\n                         }\n                     }\n@@ -3647,8 +3645,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   format!(\"cannot index a value of type `{}`\",\n                                           actual)\n                               },\n-                              base_t,\n-                              None);\n+                              base_t);\n                           // Try to give some advice about indexing tuples.\n                           if let ty::TyTuple(_) = base_t.sty {\n                               let mut needs_note = true;\n@@ -4523,7 +4520,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if !self.is_tainted_by_errors() {\n                     self.type_error_message(sp, |_actual| {\n                         \"the type of this value must be known in this context\".to_string()\n-                    }, ty, None);\n+                    }, ty);\n                 }\n                 self.demand_suptype(sp, self.tcx.types.err, ty);\n                 ty = self.tcx.types.err;"}, {"sha": "d02f87d0b9cd64236700279cd10bfc1744f0c7af", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=cea88ebb39402ceee9ec5f7cd61c877ae4cd16dc", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.type_error_message(ex.span, |actual| {\n                     format!(\"cannot apply unary operator `{}` to type `{}`\",\n                             op_str, actual)\n-                }, operand_ty, None);\n+                }, operand_ty);\n                 self.tcx.types.err\n             }\n         }"}]}