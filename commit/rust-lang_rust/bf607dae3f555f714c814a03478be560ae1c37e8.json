{"sha": "bf607dae3f555f714c814a03478be560ae1c37e8", "node_id": "C_kwDOAAsO6NoAKGJmNjA3ZGFlM2Y1NTVmNzE0YzgxNGEwMzQ3OGJlNTYwYWUxYzM3ZTg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-14T18:40:20Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-14T19:29:37Z"}, "message": "Move logic into method", "tree": {"sha": "ebdde445a973238c91b9b46ffab740cae7484f77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebdde445a973238c91b9b46ffab740cae7484f77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf607dae3f555f714c814a03478be560ae1c37e8", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf607dae3f555f714c814a03478be560ae1c37e8", "html_url": "https://github.com/rust-lang/rust/commit/bf607dae3f555f714c814a03478be560ae1c37e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf607dae3f555f714c814a03478be560ae1c37e8/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f697b85f2196ea7d2a5d4fa1f88c39e63871d39", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f697b85f2196ea7d2a5d4fa1f88c39e63871d39", "html_url": "https://github.com/rust-lang/rust/commit/3f697b85f2196ea7d2a5d4fa1f88c39e63871d39"}], "stats": {"total": 256, "additions": 140, "deletions": 116}, "files": [{"sha": "821492179136bf9b9a56fcc7ef29eed47efc4f67", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 140, "deletions": 116, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/bf607dae3f555f714c814a03478be560ae1c37e8/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf607dae3f555f714c814a03478be560ae1c37e8/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=bf607dae3f555f714c814a03478be560ae1c37e8", "patch": "@@ -398,122 +398,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     custom_span_label = true;\n                 }\n                 if static_candidates.len() == 1 {\n-                    let mut has_unsuggestable_args = false;\n-                    let ty_str = if let Some(CandidateSource::Impl(impl_did)) =\n-                        static_candidates.get(0)\n-                    {\n-                        // When the \"method\" is resolved through dereferencing, we really want the\n-                        // original type that has the associated function for accurate suggestions.\n-                        // (#61411)\n-                        let ty = tcx.at(span).type_of(*impl_did);\n-                        match (&ty.peel_refs().kind(), &rcvr_ty.peel_refs().kind()) {\n-                            (ty::Adt(def, _), ty::Adt(def_actual, substs)) if def == def_actual => {\n-                                // If there are any inferred arguments, (`{integer}`), we should replace\n-                                // them with underscores to allow the compiler to infer them\n-                                let infer_substs: Vec<GenericArg<'_>> = substs\n-                                    .into_iter()\n-                                    .map(|arg| {\n-                                        if !arg.is_suggestable(tcx, true) {\n-                                            has_unsuggestable_args = true;\n-                                            match arg.unpack() {\n-                                            GenericArgKind::Lifetime(_) => self\n-                                                .next_region_var(RegionVariableOrigin::MiscVariable(\n-                                                    rustc_span::DUMMY_SP,\n-                                                ))\n-                                                .into(),\n-                                            GenericArgKind::Type(_) => self\n-                                                .next_ty_var(TypeVariableOrigin {\n-                                                    span: rustc_span::DUMMY_SP,\n-                                                    kind: TypeVariableOriginKind::MiscVariable,\n-                                                })\n-                                                .into(),\n-                                            GenericArgKind::Const(arg) => self\n-                                                .next_const_var(\n-                                                    arg.ty(),\n-                                                    ConstVariableOrigin {\n-                                                        span: rustc_span::DUMMY_SP,\n-                                                        kind: ConstVariableOriginKind::MiscVariable,\n-                                                    },\n-                                                )\n-                                                .into(),\n-                                            }\n-                                        } else {\n-                                            arg\n-                                        }\n-                                    })\n-                                    .collect::<Vec<_>>();\n-\n-                                tcx.value_path_str_with_substs(\n-                                    def_actual.did(),\n-                                    tcx.intern_substs(&infer_substs),\n-                                )\n-                            }\n-                            _ => self.ty_to_value_string(ty.peel_refs()),\n-                        }\n-                    } else {\n-                        self.ty_to_value_string(rcvr_ty.peel_refs())\n-                    };\n-                    if let SelfSource::MethodCall(_) = source {\n-                        let first_arg = if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) &&\n-                            let Some(assoc) = self.associated_value(*impl_did, item_name) {\n-                            let sig = self.tcx.fn_sig(assoc.def_id);\n-                            if let Some(first) = sig.inputs().skip_binder().get(0) {\n-                                if first.peel_refs() == rcvr_ty.peel_refs() {\n-                                    None\n-                                } else {\n-                                    Some(if first.is_region_ptr() {\n-                                        if first.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n-                                    } else {\n-                                        \"\"\n-                                    })\n-                                }\n-                            } else {\n-                                None\n-                            }\n-                        } else {\n-                            None\n-                        };\n-                        let mut applicability = Applicability::MachineApplicable;\n-                        let args = if let Some((receiver, args)) = args {\n-                            // The first arg is the same kind as the receiver\n-                            let explicit_args = if first_arg.is_some() {\n-                                std::iter::once(receiver).chain(args.iter()).collect::<Vec<_>>()\n-                            } else {\n-                                // There is no `Self` kind to infer the arguments from\n-                                if has_unsuggestable_args {\n-                                    applicability = Applicability::HasPlaceholders;\n-                                }\n-                                args.iter().collect()\n-                            };\n-                            format!(\n-                                \"({}{})\",\n-                                first_arg.unwrap_or(\"\"),\n-                                explicit_args\n-                                    .iter()\n-                                    .map(|arg| tcx\n-                                        .sess\n-                                        .source_map()\n-                                        .span_to_snippet(arg.span)\n-                                        .unwrap_or_else(|_| {\n-                                            applicability = Applicability::HasPlaceholders;\n-                                            \"_\".to_owned()\n-                                        }))\n-                                    .collect::<Vec<_>>()\n-                                    .join(\", \"),\n-                            )\n-                        } else {\n-                            applicability = Applicability::HasPlaceholders;\n-                            \"(...)\".to_owned()\n-                        };\n-                        err.span_suggestion(\n-                            sugg_span,\n-                            \"use associated function syntax instead\",\n-                            format!(\"{}::{}{}\", ty_str, item_name, args),\n-                            applicability,\n-                        );\n-                    } else {\n-                        err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n-                    }\n+                    self.suggest_associated_call_syntax(\n+                        &mut err,\n+                        &static_candidates,\n+                        rcvr_ty,\n+                        source,\n+                        item_name,\n+                        args,\n+                        sugg_span,\n+                    );\n \n                     report_candidates(span, &mut err, &mut static_candidates, sugg_span);\n                 } else if static_candidates.len() > 1 {\n@@ -1180,6 +1073,137 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n+    /// Suggest calling `Ty::method` if `.method()` isn't found because the method\n+    /// doesn't take a `self` receiver.\n+    fn suggest_associated_call_syntax(\n+        &self,\n+        err: &mut Diagnostic,\n+        static_candidates: &Vec<CandidateSource>,\n+        rcvr_ty: Ty<'tcx>,\n+        source: SelfSource<'tcx>,\n+        item_name: Ident,\n+        args: Option<(&hir::Expr<'tcx>, &[hir::Expr<'tcx>])>,\n+        sugg_span: Span,\n+    ) {\n+        let mut has_unsuggestable_args = false;\n+        let ty_str = if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) {\n+            // When the \"method\" is resolved through dereferencing, we really want the\n+            // original type that has the associated function for accurate suggestions.\n+            // (#61411)\n+            let ty = self.tcx.type_of(*impl_did);\n+            match (&ty.peel_refs().kind(), &rcvr_ty.peel_refs().kind()) {\n+                (ty::Adt(def, _), ty::Adt(def_actual, substs)) if def == def_actual => {\n+                    // If there are any inferred arguments, (`{integer}`), we should replace\n+                    // them with underscores to allow the compiler to infer them\n+                    let infer_substs: Vec<GenericArg<'_>> = substs\n+                        .into_iter()\n+                        .map(|arg| {\n+                            if !arg.is_suggestable(self.tcx, true) {\n+                                has_unsuggestable_args = true;\n+                                match arg.unpack() {\n+                                    GenericArgKind::Lifetime(_) => self\n+                                        .next_region_var(RegionVariableOrigin::MiscVariable(\n+                                            rustc_span::DUMMY_SP,\n+                                        ))\n+                                        .into(),\n+                                    GenericArgKind::Type(_) => self\n+                                        .next_ty_var(TypeVariableOrigin {\n+                                            span: rustc_span::DUMMY_SP,\n+                                            kind: TypeVariableOriginKind::MiscVariable,\n+                                        })\n+                                        .into(),\n+                                    GenericArgKind::Const(arg) => self\n+                                        .next_const_var(\n+                                            arg.ty(),\n+                                            ConstVariableOrigin {\n+                                                span: rustc_span::DUMMY_SP,\n+                                                kind: ConstVariableOriginKind::MiscVariable,\n+                                            },\n+                                        )\n+                                        .into(),\n+                                }\n+                            } else {\n+                                arg\n+                            }\n+                        })\n+                        .collect::<Vec<_>>();\n+\n+                    self.tcx.value_path_str_with_substs(\n+                        def_actual.did(),\n+                        self.tcx.intern_substs(&infer_substs),\n+                    )\n+                }\n+                _ => self.ty_to_value_string(ty.peel_refs()),\n+            }\n+        } else {\n+            self.ty_to_value_string(rcvr_ty.peel_refs())\n+        };\n+        if let SelfSource::MethodCall(_) = source {\n+            let first_arg = if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0)\n+                && let Some(assoc) = self.associated_value(*impl_did, item_name)\n+                && assoc.kind == ty::AssocKind::Fn\n+            {\n+                let sig = self.tcx.fn_sig(assoc.def_id);\n+                if let Some(first) = sig.inputs().skip_binder().get(0) {\n+                    if first.peel_refs() == rcvr_ty.peel_refs() {\n+                        None\n+                    } else {\n+                        Some(if first.is_region_ptr() {\n+                            if first.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n+                        } else {\n+                            \"\"\n+                        })\n+                    }\n+                } else {\n+                    None\n+                }\n+            } else {\n+                None\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            let args = if let Some((receiver, args)) = args {\n+                // The first arg is the same kind as the receiver\n+                let explicit_args = if first_arg.is_some() {\n+                    std::iter::once(receiver).chain(args.iter()).collect::<Vec<_>>()\n+                } else {\n+                    // There is no `Self` kind to infer the arguments from\n+                    if has_unsuggestable_args {\n+                        applicability = Applicability::HasPlaceholders;\n+                    }\n+                    args.iter().collect()\n+                };\n+                format!(\n+                    \"({}{})\",\n+                    first_arg.unwrap_or(\"\"),\n+                    explicit_args\n+                        .iter()\n+                        .map(|arg| self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(arg.span)\n+                            .unwrap_or_else(|_| {\n+                                applicability = Applicability::HasPlaceholders;\n+                                \"_\".to_owned()\n+                            }))\n+                        .collect::<Vec<_>>()\n+                        .join(\", \"),\n+                )\n+            } else {\n+                applicability = Applicability::HasPlaceholders;\n+                \"(...)\".to_owned()\n+            };\n+            err.span_suggestion(\n+                sugg_span,\n+                \"use associated function syntax instead\",\n+                format!(\"{}::{}{}\", ty_str, item_name, args),\n+                applicability,\n+            );\n+        } else {\n+            err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n+        }\n+    }\n+\n     /// Suggest calling a field with a type that implements the `Fn*` traits instead of a method with\n     /// the same name as the field i.e. `(a.my_fn_ptr)(10)` instead of `a.my_fn_ptr(10)`.\n     fn suggest_calling_field_as_fn("}]}