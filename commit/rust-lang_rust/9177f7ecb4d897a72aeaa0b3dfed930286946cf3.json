{"sha": "9177f7ecb4d897a72aeaa0b3dfed930286946cf3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNzdmN2VjYjRkODk3YTcyYWVhYTBiM2RmZWQ5MzAyODY5NDZjZjM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-17T15:13:20Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-12-18T23:18:02Z"}, "message": "std::vec: remove .as_muf_buf, replaced by .as_mut_ptr & .len.", "tree": {"sha": "8a2eb18e41f2d4262e2ed32f30e614aee567e72e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a2eb18e41f2d4262e2ed32f30e614aee567e72e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9177f7ecb4d897a72aeaa0b3dfed930286946cf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9177f7ecb4d897a72aeaa0b3dfed930286946cf3", "html_url": "https://github.com/rust-lang/rust/commit/9177f7ecb4d897a72aeaa0b3dfed930286946cf3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c79b22ef26a2b846d84c46bc8fea50c953559dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c79b22ef26a2b846d84c46bc8fea50c953559dd", "html_url": "https://github.com/rust-lang/rust/commit/4c79b22ef26a2b846d84c46bc8fea50c953559dd"}], "stats": {"total": 183, "additions": 71, "deletions": 112}, "files": [{"sha": "83ca964b030426dc79d739a750db99966de0ead0", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=9177f7ecb4d897a72aeaa0b3dfed930286946cf3", "patch": "@@ -295,13 +295,12 @@ unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T {\n         vec::bytes::copy_memory(buf, v);\n         buf[v.len()] = 0;\n \n-        buf.as_mut_buf(|buf, _| {\n-            if checked {\n-                check_for_null(v, buf as *mut libc::c_char);\n-            }\n+        let buf = buf.as_mut_ptr();\n+        if checked {\n+            check_for_null(v, buf as *mut libc::c_char);\n+        }\n \n-            f(buf as *libc::c_char)\n-        })\n+        f(buf as *libc::c_char)\n     } else if checked {\n         v.to_c_str().with_ref(f)\n     } else {"}, {"sha": "d55d7ec8a1ac495d6624f9040122a808909cd631", "filename": "src/libstd/os.rs", "status": "modified", "additions": 36, "deletions": 49, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=9177f7ecb4d897a72aeaa0b3dfed930286946cf3", "patch": "@@ -59,15 +59,12 @@ static BUF_BYTES : uint = 2048u;\n #[cfg(unix)]\n pub fn getcwd() -> Path {\n     let mut buf = [0 as libc::c_char, ..BUF_BYTES];\n-    buf.as_mut_buf(|buf, len| {\n-        unsafe {\n-            if libc::getcwd(buf, len as size_t).is_null() {\n-                fail!()\n-            }\n-\n-            Path::new(CString::new(buf as *c_char, false))\n+    unsafe {\n+        if libc::getcwd(buf.as_mut_ptr(), buf.len() as size_t).is_null() {\n+            fail!()\n         }\n-    })\n+        Path::new(CString::new(buf.as_ptr(), false))\n+    }\n }\n \n #[cfg(windows)]\n@@ -103,20 +100,17 @@ pub mod win32 {\n             let mut res = None;\n             let mut done = false;\n             while !done {\n-                let mut k: DWORD = 0;\n                 let mut buf = vec::from_elem(n as uint, 0u16);\n-                buf.as_mut_buf(|b, _sz| {\n-                    k = f(b, TMPBUF_SZ as DWORD);\n-                    if k == (0 as DWORD) {\n-                        done = true;\n-                    } else if (k == n &&\n-                               libc::GetLastError() ==\n-                               libc::ERROR_INSUFFICIENT_BUFFER as DWORD) {\n-                        n *= (2 as DWORD);\n-                    } else {\n-                        done = true;\n-                    }\n-                });\n+                let k = f(buf.as_mut_ptr(), TMPBUF_SZ as DWORD);\n+                if k == (0 as DWORD) {\n+                    done = true;\n+                } else if (k == n &&\n+                           libc::GetLastError() ==\n+                           libc::ERROR_INSUFFICIENT_BUFFER as DWORD) {\n+                    n *= (2 as DWORD);\n+                } else {\n+                    done = true;\n+                }\n                 if k != 0 && done {\n                     let sub = buf.slice(0, k as uint);\n                     res = option::Some(str::from_utf16(sub));\n@@ -363,10 +357,8 @@ pub fn self_exe_path() -> Option<Path> {\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             let mut v: ~[u8] = vec::with_capacity(sz as uint);\n-            let err = v.as_mut_buf(|buf,_| {\n-                sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n-                       buf as *mut c_void, &mut sz, ptr::null(), 0u as size_t)\n-            });\n+            let err = sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n+                             v.as_mut_ptr() as *mut c_void, &mut sz, ptr::null(), 0u as size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n@@ -394,9 +386,7 @@ pub fn self_exe_path() -> Option<Path> {\n             _NSGetExecutablePath(ptr::mut_null(), &mut sz);\n             if sz == 0 { return None; }\n             let mut v: ~[u8] = vec::with_capacity(sz as uint);\n-            let err = v.as_mut_buf(|buf, _| {\n-                _NSGetExecutablePath(buf as *mut i8, &mut sz)\n-            });\n+            let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n             if err != 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n             Some(v)\n@@ -628,15 +618,14 @@ pub fn last_os_error() -> ~str {\n \n         let mut buf = [0 as c_char, ..TMPBUF_SZ];\n \n-        buf.as_mut_buf(|buf, len| {\n-            unsafe {\n-                if strerror_r(errno() as c_int, buf, len as size_t) < 0 {\n-                    fail!(\"strerror_r failure\");\n-                }\n-\n-                str::raw::from_c_str(buf as *c_char)\n+        let p = buf.as_mut_ptr();\n+        unsafe {\n+            if strerror_r(errno() as c_int, p, buf.len() as size_t) < 0 {\n+                fail!(\"strerror_r failure\");\n             }\n-        })\n+\n+            str::raw::from_c_str(p as *c_char)\n+        }\n     }\n \n     #[cfg(windows)]\n@@ -669,19 +658,17 @@ pub fn last_os_error() -> ~str {\n         let mut buf = [0 as WCHAR, ..TMPBUF_SZ];\n \n         unsafe {\n-            buf.as_mut_buf(|buf, len| {\n-                let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n-                                         FORMAT_MESSAGE_IGNORE_INSERTS,\n-                                         ptr::mut_null(),\n-                                         err,\n-                                         langId,\n-                                         buf,\n-                                         len as DWORD,\n-                                         ptr::null());\n-                if res == 0 {\n-                    fail!(\"[{}] FormatMessage failure\", errno());\n-                }\n-            });\n+            let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n+                                     FORMAT_MESSAGE_IGNORE_INSERTS,\n+                                     ptr::mut_null(),\n+                                     err,\n+                                     langId,\n+                                     buf.as_mut_ptr(),\n+                                     buf.len() as DWORD,\n+                                     ptr::null());\n+            if res == 0 {\n+                fail!(\"[{}] FormatMessage failure\", errno());\n+            }\n \n             str::from_utf16(buf)\n         }"}, {"sha": "1eaff3f51a6d775eae22f5495bbe03243d701e11", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=9177f7ecb4d897a72aeaa0b3dfed930286946cf3", "patch": "@@ -111,9 +111,7 @@ impl Rng for OSRng {\n                                    pbBuffer: *mut BYTE);\n         }\n \n-        v.as_mut_buf(|ptr, len| {\n-            unsafe {rust_win32_rand_gen(self.hcryptprov, len as DWORD, ptr)}\n-        })\n+        unsafe {rust_win32_rand_gen(self.hcryptprov, v.len() as DWORD, v.as_mut_ptr())}\n     }\n }\n "}, {"sha": "cd21cdeb711b720eafe1355f50550cd711aceacb", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=9177f7ecb4d897a72aeaa0b3dfed930286946cf3", "patch": "@@ -914,13 +914,11 @@ fn new_sched_rng() -> XorShiftRng {\n     let mut seeds = [0u32, .. 4];\n     let size = mem::size_of_val(&seeds);\n     loop {\n-        let nbytes = seeds.as_mut_buf(|buf, _| {\n-            unsafe {\n-                libc::read(fd,\n-                           buf as *mut libc::c_void,\n-                           size as libc::size_t)\n-            }\n-        });\n+        let nbytes = unsafe {\n+            libc::read(fd,\n+                       seeds.as_mut_ptr() as *mut libc::c_void,\n+                       size as libc::size_t)\n+        };\n         rtassert!(nbytes as uint == size);\n \n         if !seeds.iter().all(|x| *x == 0) {"}, {"sha": "d564c55fb60993cf95c80b826e3f844311ddf56a", "filename": "src/libstd/str.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=9177f7ecb4d897a72aeaa0b3dfed930286946cf3", "patch": "@@ -1000,7 +1000,7 @@ pub mod raw {\n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len);\n-        v.as_mut_buf(|vbuf, _len| ptr::copy_memory(vbuf, buf as *u8, len));\n+        ptr::copy_memory(v.as_mut_ptr(), buf as *u8, len);\n         v.set_len(len);\n \n         assert!(is_utf8(v));\n@@ -2282,7 +2282,7 @@ impl<'a> StrSlice<'a> for &'a str {\n             unsafe {\n                 let mut v = vec::with_capacity(len);\n \n-                v.as_mut_buf(|dst, _| ptr::copy_memory(dst, src, len));\n+                ptr::copy_memory(v.as_mut_ptr(), src, len);\n                 v.set_len(len);\n                 ::cast::transmute(v)\n             }\n@@ -2697,7 +2697,8 @@ impl OwnedStr for ~str {\n     #[inline]\n     fn as_mut_buf<T>(&mut self, f: |*mut u8, uint| -> T) -> T {\n         unsafe {\n-            raw::as_owned_vec(self).as_mut_buf(f)\n+            let v = raw::as_owned_vec(self);\n+            f(v.as_mut_ptr(), v.len())\n         }\n     }\n "}, {"sha": "ad0d8861ee9c4e7e9b477327526858536bc71606", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 20, "deletions": 44, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9177f7ecb4d897a72aeaa0b3dfed930286946cf3/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=9177f7ecb4d897a72aeaa0b3dfed930286946cf3", "patch": "@@ -1681,15 +1681,16 @@ impl<T> OwnedVector<T> for ~[T] {\n         self.pop()\n     }\n     fn truncate(&mut self, newlen: uint) {\n-        self.as_mut_buf(|p, oldlen| {\n-            assert!(newlen <= oldlen);\n-            unsafe {\n-                // This loop is optimized out for non-drop types.\n-                for i in range(newlen, oldlen) {\n-                    ptr::read_and_zero_ptr(ptr::mut_offset(p, i as int));\n-                }\n+        let oldlen = self.len();\n+        assert!(newlen <= oldlen);\n+\n+        unsafe {\n+            let p = self.as_mut_ptr();\n+            // This loop is optimized out for non-drop types.\n+            for i in range(newlen, oldlen) {\n+                ptr::read_and_zero_ptr(p.offset(i as int));\n             }\n-        });\n+        }\n         unsafe { self.set_len(newlen); }\n     }\n \n@@ -2053,24 +2054,19 @@ pub trait MutableVector<'a, T> {\n     /// `self` and `src` must not overlap. Fails if `self` is\n     /// shorter than `src`.\n     unsafe fn copy_memory(self, src: &[T]);\n-\n-    /// Similar to `as_imm_buf` but passing a `*mut T`\n-    fn as_mut_buf<U>(self, f: |*mut T, uint| -> U) -> U;\n }\n \n impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     #[inline]\n     fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n-        self.as_mut_buf(|p, _len| {\n-            unsafe {\n-                cast::transmute(Slice {\n-                    data: ptr::mut_offset(p, start as int) as *T,\n+        unsafe {\n+            cast::transmute(Slice {\n+                    data: self.as_mut_ptr().offset(start as int) as *T,\n                     len: (end - start)\n                 })\n-            }\n-        })\n+        }\n     }\n \n     #[inline]\n@@ -2189,17 +2185,9 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n \n     #[inline]\n     unsafe fn copy_memory(self, src: &[T]) {\n-        self.as_mut_buf(|p_dst, len_dst| {\n-            let len_src = src.len();\n-            assert!(len_dst >= len_src);\n-            ptr::copy_nonoverlapping_memory(p_dst, src.as_ptr(), len_src)\n-        })\n-    }\n-\n-    #[inline]\n-    fn as_mut_buf<U>(self, f: |*mut T, uint| -> U) -> U {\n-        let Slice{ data, len } = self.repr();\n-        f(data as *mut T, len)\n+        let len_src = src.len();\n+        assert!(self.len() >= len_src);\n+        ptr::copy_nonoverlapping_memory(self.as_mut_ptr(), src.as_ptr(), len_src)\n     }\n }\n \n@@ -2283,7 +2271,7 @@ pub mod raw {\n     pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n         let mut dst = with_capacity(elts);\n         dst.set_len(elts);\n-        dst.as_mut_buf(|p_dst, _len_dst| ptr::copy_memory(p_dst, ptr, elts));\n+        ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n         dst\n     }\n \n@@ -2315,6 +2303,7 @@ pub mod raw {\n \n /// Operations on `[u8]`.\n pub mod bytes {\n+    use container::Container;\n     use vec::MutableVector;\n     use ptr;\n \n@@ -2327,9 +2316,7 @@ pub mod bytes {\n     impl<'a> MutableByteVector for &'a mut [u8] {\n         #[inline]\n         fn set_memory(self, value: u8) {\n-            self.as_mut_buf(|p, len| {\n-                unsafe { ptr::set_memory(p, value, len) };\n-            })\n+            unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n         }\n     }\n \n@@ -2351,9 +2338,7 @@ pub mod bytes {\n         let old_len = dst.len();\n         dst.reserve_additional(src.len());\n         unsafe {\n-            dst.as_mut_buf(|p_dst, len_dst| {\n-                ptr::copy_memory(p_dst.offset(len_dst as int), src.as_ptr(), src.len())\n-            });\n+            ptr::copy_memory(dst.as_mut_ptr().offset(old_len as int), src.as_ptr(), src.len());\n             dst.set_len(old_len + src.len());\n         }\n     }\n@@ -3534,15 +3519,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_as_mut_buf_fail() {\n-        let mut v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        v.as_mut_buf(|_buf, _i| {\n-            fail!()\n-        })\n-    }\n-\n     #[test]\n     #[should_fail]\n     fn test_copy_memory_oob() {"}]}