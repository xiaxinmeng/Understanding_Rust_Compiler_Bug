{"sha": "9d3f4624e1a83eb945f4df6427fc650356ea77fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkM2Y0NjI0ZTFhODNlYjk0NWY0ZGY2NDI3ZmM2NTAzNTZlYTc3ZmE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-01T06:00:47Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-01T06:00:47Z"}, "message": "Merge #721\n\n721: Go To Implementation for Trait r=matklad a=kjeremy\n\nIf on a trait def you can now go to all the impls of that trait in the crate.\r\n\r\nThis is more of #620.\n\nCo-authored-by: kjeremy <kjeremy@gmail.com>", "tree": {"sha": "0015874d918f8be2ec848ab2b110d4478890388b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0015874d918f8be2ec848ab2b110d4478890388b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d3f4624e1a83eb945f4df6427fc650356ea77fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3f4624e1a83eb945f4df6427fc650356ea77fa", "html_url": "https://github.com/rust-lang/rust/commit/9d3f4624e1a83eb945f4df6427fc650356ea77fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d3f4624e1a83eb945f4df6427fc650356ea77fa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1", "html_url": "https://github.com/rust-lang/rust/commit/4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1"}, {"sha": "f0fdc9d5c0b5c8712bbd94da20289fda4259d793", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0fdc9d5c0b5c8712bbd94da20289fda4259d793", "html_url": "https://github.com/rust-lang/rust/commit/f0fdc9d5c0b5c8712bbd94da20289fda4259d793"}], "stats": {"total": 166, "additions": 140, "deletions": 26}, "files": [{"sha": "a1b94ed9c9cfed493c299531dffa4bd212b44e9d", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f4624e1a83eb945f4df6427fc650356ea77fa/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f4624e1a83eb945f4df6427fc650356ea77fa/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=9d3f4624e1a83eb945f4df6427fc650356ea77fa", "patch": "@@ -14,7 +14,7 @@ use ra_syntax::{\n \n use crate::{\n     HirDatabase, Function, ModuleDef, Struct, Enum,\n-    AsName, Module, HirFileId, Crate,\n+    AsName, Module, HirFileId, Crate, Trait,\n     ids::{LocationCtx, SourceFileItemId},\n };\n \n@@ -151,6 +151,19 @@ pub fn enum_from_module(db: &impl HirDatabase, module: Module, enum_def: &ast::E\n     }\n }\n \n+pub fn trait_from_module(\n+    db: &impl HirDatabase,\n+    module: Module,\n+    trait_def: &ast::TraitDef,\n+) -> Trait {\n+    let (file_id, _) = module.definition_source(db);\n+    let file_id = file_id.into();\n+    let ctx = LocationCtx::new(db, module, file_id);\n+    Trait {\n+        id: ctx.to_def(trait_def),\n+    }\n+}\n+\n pub fn macro_symbols(db: &impl HirDatabase, file_id: FileId) -> Vec<(SmolStr, TextRange)> {\n     let module = match module_from_file_id(db, file_id) {\n         Some(it) => it,"}, {"sha": "e857d6856eb2e11bc07717ea61b1c4701803c144", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 48, "deletions": 19, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f4624e1a83eb945f4df6427fc650356ea77fa/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f4624e1a83eb945f4df6427fc650356ea77fa/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=9d3f4624e1a83eb945f4df6427fc650356ea77fa", "patch": "@@ -7,17 +7,18 @@ use std::sync::Arc;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    HirDatabase, module_tree::ModuleId, Module, Crate, Name, Function,\n+    HirDatabase, module_tree::ModuleId, Module, ModuleDef, Crate, Name, Function, Trait,\n+    ids::TraitId,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n     generics::GenericParams,\n-    ty::{AdtDef, Ty}\n+    ty::{AdtDef, Ty},\n+    type_ref::TypeRef,\n };\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum TyFingerprint {\n-    Adt(AdtDef),\n-    // we'll also want to index impls for primitive types etc.\n+    Adt(AdtDef), // we'll also want to index impls for primitive types etc.\n }\n \n impl TyFingerprint {\n@@ -37,6 +38,7 @@ pub struct CrateImplBlocks {\n     /// To make sense of the ModuleIds, we need the source root.\n     krate: Crate,\n     impls: FxHashMap<TyFingerprint, Vec<(ModuleId, ImplId)>>,\n+    impls_by_trait: FxHashMap<TraitId, Vec<(ModuleId, ImplId)>>,\n }\n \n impl CrateImplBlocks {\n@@ -60,27 +62,53 @@ impl CrateImplBlocks {\n             })\n     }\n \n+    pub fn lookup_impl_blocks_for_trait<'a>(\n+        &'a self,\n+        db: &'a impl HirDatabase,\n+        tr: &Trait,\n+    ) -> impl Iterator<Item = (Module, ImplBlock)> + 'a {\n+        let id = tr.id;\n+        self.impls_by_trait\n+            .get(&id)\n+            .into_iter()\n+            .flat_map(|i| i.iter())\n+            .map(move |(module_id, impl_id)| {\n+                let module = Module {\n+                    krate: self.krate,\n+                    module_id: *module_id,\n+                };\n+                let module_impl_blocks = db.impls_in_module(module);\n+                (module, ImplBlock::from_id(module_impl_blocks, *impl_id))\n+            })\n+    }\n+\n     fn collect_recursive(&mut self, db: &impl HirDatabase, module: &Module) {\n         let module_impl_blocks = db.impls_in_module(module.clone());\n \n         for (impl_id, impl_data) in module_impl_blocks.impls.iter() {\n             let impl_block = ImplBlock::from_id(Arc::clone(&module_impl_blocks), impl_id);\n+            // TODO provide generics of impl\n+            let generics = GenericParams::default();\n+            let target_ty = Ty::from_hir(\n+                db,\n+                &module,\n+                Some(&impl_block),\n+                &generics,\n+                impl_data.target_type(),\n+            );\n+\n+            if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n+                self.impls\n+                    .entry(target_ty_fp)\n+                    .or_insert_with(Vec::new)\n+                    .push((module.module_id, impl_id));\n+            }\n \n-            if let Some(_target_trait) = impl_data.target_trait() {\n-                // ignore for now\n-            } else {\n-                // TODO provide generics of impl\n-                let generics = GenericParams::default();\n-                let target_ty = Ty::from_hir(\n-                    db,\n-                    &module,\n-                    Some(&impl_block),\n-                    &generics,\n-                    impl_data.target_type(),\n-                );\n-                if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n-                    self.impls\n-                        .entry(target_ty_fp)\n+            if let Some(TypeRef::Path(path)) = impl_data.target_trait() {\n+                let perns = module.resolve_path(db, path);\n+                if let Some(ModuleDef::Trait(tr)) = perns.take_types() {\n+                    self.impls_by_trait\n+                        .entry(tr.id)\n                         .or_insert_with(Vec::new)\n                         .push((module.module_id, impl_id));\n                 }\n@@ -99,6 +127,7 @@ impl CrateImplBlocks {\n         let mut crate_impl_blocks = CrateImplBlocks {\n             krate: krate.clone(),\n             impls: FxHashMap::default(),\n+            impls_by_trait: FxHashMap::default(),\n         };\n         if let Some(module) = krate.root_module(db) {\n             crate_impl_blocks.collect_recursive(db, &module);"}, {"sha": "91fa41f1f4ba0eef543335d9633afb898f93165a", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f4624e1a83eb945f4df6427fc650356ea77fa/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f4624e1a83eb945f4df6427fc650356ea77fa/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=9d3f4624e1a83eb945f4df6427fc650356ea77fa", "patch": "@@ -15,9 +15,27 @@ pub(crate) fn goto_implementation(\n     let syntax = file.syntax();\n \n     let module = source_binder::module_from_position(db, position)?;\n-    let krate = module.krate(db)?;\n \n-    let node = find_node_at_offset::<ast::NominalDef>(syntax, position.offset)?;\n+    if let Some(nominal_def) = find_node_at_offset::<ast::NominalDef>(syntax, position.offset) {\n+        return Some(RangeInfo::new(\n+            nominal_def.syntax().range(),\n+            impls_for_def(db, nominal_def, module)?,\n+        ));\n+    } else if let Some(trait_def) = find_node_at_offset::<ast::TraitDef>(syntax, position.offset) {\n+        return Some(RangeInfo::new(\n+            trait_def.syntax().range(),\n+            impls_for_trait(db, trait_def, module)?,\n+        ));\n+    }\n+\n+    None\n+}\n+\n+fn impls_for_def(\n+    db: &RootDatabase,\n+    node: &ast::NominalDef,\n+    module: hir::Module,\n+) -> Option<Vec<NavigationTarget>> {\n     let ty = match node.kind() {\n         ast::NominalDefKind::StructDef(def) => {\n             source_binder::struct_from_module(db, module, &def).ty(db)\n@@ -27,13 +45,33 @@ pub(crate) fn goto_implementation(\n         }\n     };\n \n+    let krate = module.krate(db)?;\n     let impls = db.impls_in_crate(krate);\n \n-    let navs = impls\n-        .lookup_impl_blocks(db, &ty)\n-        .map(|(module, imp)| NavigationTarget::from_impl_block(db, module, &imp));\n+    Some(\n+        impls\n+            .lookup_impl_blocks(db, &ty)\n+            .map(|(module, imp)| NavigationTarget::from_impl_block(db, module, &imp))\n+            .collect(),\n+    )\n+}\n+\n+fn impls_for_trait(\n+    db: &RootDatabase,\n+    node: &ast::TraitDef,\n+    module: hir::Module,\n+) -> Option<Vec<NavigationTarget>> {\n+    let tr = source_binder::trait_from_module(db, module, node);\n \n-    Some(RangeInfo::new(node.syntax().range(), navs.collect()))\n+    let krate = module.krate(db)?;\n+    let impls = db.impls_in_crate(krate);\n+\n+    Some(\n+        impls\n+            .lookup_impl_blocks_for_trait(db, &tr)\n+            .map(|(module, imp)| NavigationTarget::from_impl_block(db, module, &imp))\n+            .collect(),\n+    )\n }\n \n #[cfg(test)]\n@@ -117,4 +155,38 @@ mod tests {\n             ],\n         );\n     }\n+\n+    #[test]\n+    fn goto_implementation_for_trait() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            trait T<|> {}\n+            struct Foo;\n+            impl T for Foo {}\n+            \",\n+            &[\"impl IMPL_BLOCK FileId(1) [23; 40)\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_implementation_for_trait_multiple_files() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            trait T<|> {};\n+            struct Foo;\n+            mod a;\n+            mod b;\n+            //- /a.rs\n+            impl crate::T for crate::Foo {}\n+            //- /b.rs\n+            impl crate::T for crate::Foo {}\n+            \",\n+            &[\n+                \"impl IMPL_BLOCK FileId(2) [0; 31)\",\n+                \"impl IMPL_BLOCK FileId(3) [0; 31)\",\n+            ],\n+        );\n+    }\n }"}]}