{"sha": "6d4dc35882a55610e9da81237d62bea1c0c1634e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNGRjMzU4ODJhNTU2MTBlOWRhODEyMzdkNjJiZWExYzBjMTYzNGU=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-18T00:35:39Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-05-20T13:03:47Z"}, "message": "Improve `needless_borrow` lint\nSuggest changing usages of ref bindings to match the new type\nSplit out some cases into new lint `ref_binding_to_reference`", "tree": {"sha": "b64bbdd7c9e90986f0d9d028147dd24e44230e24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b64bbdd7c9e90986f0d9d028147dd24e44230e24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d4dc35882a55610e9da81237d62bea1c0c1634e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmCmXjYACgkQ2lnoZDo37QYYVgEA+JnHEtTvQPpgDqR4Nhv/zxFq\nktMhdnDPPY6k1C238LoA/19wSQXifUwlW64kJtQlj/YyWuBq7Te/xETfemZdeBEC\n=QrJU\n-----END PGP SIGNATURE-----", "payload": "tree b64bbdd7c9e90986f0d9d028147dd24e44230e24\nparent 6e03a306ac44c6670064c68197df8813fe1cac06\nauthor Jason Newcomb <jsnewcomb@pm.me> 1618706139 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1621515827 -0400\n\nImprove `needless_borrow` lint\nSuggest changing usages of ref bindings to match the new type\nSplit out some cases into new lint `ref_binding_to_reference`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d4dc35882a55610e9da81237d62bea1c0c1634e", "html_url": "https://github.com/rust-lang/rust/commit/6d4dc35882a55610e9da81237d62bea1c0c1634e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d4dc35882a55610e9da81237d62bea1c0c1634e/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e03a306ac44c6670064c68197df8813fe1cac06", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e03a306ac44c6670064c68197df8813fe1cac06", "html_url": "https://github.com/rust-lang/rust/commit/6e03a306ac44c6670064c68197df8813fe1cac06"}], "stats": {"total": 728, "additions": 626, "deletions": 102}, "files": [{"sha": "abfe7f91f4b9b6ef1d852ca7f74ab260f2f97403", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -2622,6 +2622,7 @@ Released 2018-09-13\n [`redundant_pub_crate`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pub_crate\n [`redundant_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_slicing\n [`redundant_static_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_static_lifetimes\n+[`ref_binding_to_reference`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_binding_to_reference\n [`ref_in_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_in_deref\n [`ref_option_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_option_ref\n [`regex_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#regex_macro"}, {"sha": "a263e8b0ca4e519fde2a61e28bdd465b5c6a998f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -841,6 +841,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         needless_bool::BOOL_COMPARISON,\n         needless_bool::NEEDLESS_BOOL,\n         needless_borrow::NEEDLESS_BORROW,\n+        needless_borrow::REF_BINDING_TO_REFERENCE,\n         needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n         needless_continue::NEEDLESS_CONTINUE,\n         needless_for_each::NEEDLESS_FOR_EACH,\n@@ -1116,6 +1117,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(misc_early::UNSEPARATED_LITERAL_SUFFIX),\n         LintId::of(mut_mut::MUT_MUT),\n         LintId::of(needless_bitwise_bool::NEEDLESS_BITWISE_BOOL),\n+        LintId::of(needless_borrow::REF_BINDING_TO_REFERENCE),\n         LintId::of(needless_continue::NEEDLESS_CONTINUE),\n         LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n         LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n@@ -1890,7 +1892,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box zero_div_zero::ZeroDiv);\n     store.register_late_pass(|| box mutex_atomic::Mutex);\n     store.register_late_pass(|| box needless_update::NeedlessUpdate);\n-    store.register_late_pass(|| box needless_borrow::NeedlessBorrow);\n+    store.register_late_pass(|| box needless_borrow::NeedlessBorrow::default());\n     store.register_late_pass(|| box needless_borrowed_ref::NeedlessBorrowedRef);\n     store.register_late_pass(|| box no_effect::NoEffect);\n     store.register_late_pass(|| box temporary_assignment::TemporaryAssignment);"}, {"sha": "965b131770e0e161c8d21c20357244dd9c6e7d1e", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 178, "deletions": 25, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -3,14 +3,18 @@\n //! This lint is **warn** by default\n \n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet_opt;\n+use clippy_utils::source::{snippet_opt, snippet_with_applicability, snippet_with_context};\n+use clippy_utils::{get_parent_expr, in_macro, path_to_local};\n use if_chain::if_chain;\n+use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n+use rustc_hir::{BindingAnnotation, Body, BodyId, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for address of operations (`&`) that are going to\n@@ -34,13 +38,65 @@ declare_clippy_lint! {\n     \"taking a reference that is going to be automatically dereferenced\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `ref` bindings which create a reference to a reference.\n+    ///\n+    /// **Why is this bad?** The address-of operator at the use site is clearer about the need for a reference.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// let x = Some(\"\");\n+    /// if let Some(ref x) = x {\n+    ///     // use `x` here\n+    /// }\n+    ///\n+    /// // Good\n+    /// let x = Some(\"\");\n+    /// if let Some(x) = x {\n+    ///     // use `&x` here\n+    /// }\n+    /// ```\n+    pub REF_BINDING_TO_REFERENCE,\n+    pedantic,\n+    \"`ref` binding to a reference\"\n+}\n+\n+impl_lint_pass!(NeedlessBorrow => [NEEDLESS_BORROW, REF_BINDING_TO_REFERENCE]);\n #[derive(Default)]\n-pub struct NeedlessBorrow;\n+pub struct NeedlessBorrow {\n+    /// The body the first local was found in. Used to emit lints when the traversal of the body has\n+    /// been finished. Note we can't lint at the end of every body as they can be nested within each\n+    /// other.\n+    current_body: Option<BodyId>,\n+    /// The list of locals currently being checked by the lint.\n+    /// If the value is `None`, then the binding has been seen as a ref pattern, but is not linted.\n+    /// This is needed for or patterns where one of the branches can be linted, but another can not\n+    /// be.\n+    ///\n+    /// e.g. `m!(x) | Foo::Bar(ref x)`\n+    ref_locals: FxIndexMap<HirId, Option<RefPat>>,\n+}\n \n-impl_lint_pass!(NeedlessBorrow => [NEEDLESS_BORROW]);\n+struct RefPat {\n+    /// Whether every usage of the binding is dereferenced.\n+    always_deref: bool,\n+    /// The spans of all the ref bindings for this local.\n+    spans: Vec<Span>,\n+    /// The applicability of this suggestion.\n+    app: Applicability,\n+    /// All the replacements which need to be made.\n+    replacements: Vec<(Span, String)>,\n+}\n \n impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        if let Some(local) = path_to_local(e) {\n+            self.check_local_usage(cx, e, local);\n+        }\n+\n         if e.span.from_expansion() {\n             return;\n         }\n@@ -81,35 +137,132 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n             }\n         }\n     }\n+\n     fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n-        if pat.span.from_expansion() {\n-            return;\n+        if let PatKind::Binding(BindingAnnotation::Ref, id, name, _) = pat.kind {\n+            if let Some(opt_prev_pat) = self.ref_locals.get_mut(&id) {\n+                // This binding id has been seen before. Add this pattern to the list of changes.\n+                if let Some(prev_pat) = opt_prev_pat {\n+                    if in_macro(pat.span) {\n+                        // Doesn't match the context of the previous pattern. Can't lint here.\n+                        *opt_prev_pat = None;\n+                    } else {\n+                        prev_pat.spans.push(pat.span);\n+                        prev_pat.replacements.push((\n+                            pat.span,\n+                            snippet_with_context(cx, name.span, pat.span.ctxt(), \"..\", &mut prev_pat.app)\n+                                .0\n+                                .into(),\n+                        ));\n+                    }\n+                }\n+                return;\n+            }\n+\n+            if_chain! {\n+                if !in_macro(pat.span);\n+                if let ty::Ref(_, tam, _) = *cx.typeck_results().pat_ty(pat).kind();\n+                // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n+                if let ty::Ref(_, _, Mutability::Not) = *tam.kind();\n+                then {\n+                    let mut app = Applicability::MachineApplicable;\n+                    let snip = snippet_with_context(cx, name.span, pat.span.ctxt(), \"..\", &mut app).0;\n+                    self.current_body = self.current_body.or(cx.enclosing_body);\n+                    self.ref_locals.insert(\n+                        id,\n+                        Some(RefPat {\n+                            always_deref: true,\n+                            spans: vec![pat.span],\n+                            app,\n+                            replacements: vec![(pat.span, snip.into())],\n+                        }),\n+                    );\n+                }\n+            }\n         }\n-        if_chain! {\n-            if let PatKind::Binding(BindingAnnotation::Ref, .., name, _) = pat.kind;\n-            if let ty::Ref(_, tam, mutbl) = *cx.typeck_results().pat_ty(pat).kind();\n-            if mutbl == Mutability::Not;\n-            if let ty::Ref(_, _, mutbl) = *tam.kind();\n-            // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n-            if mutbl == Mutability::Not;\n-            then {\n+    }\n+\n+    fn check_body_post(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n+        if Some(body.id()) == self.current_body {\n+            for pat in self.ref_locals.drain(..).filter_map(|(_, x)| x) {\n+                let replacements = pat.replacements;\n+                let app = pat.app;\n                 span_lint_and_then(\n                     cx,\n-                    NEEDLESS_BORROW,\n-                    pat.span,\n+                    if pat.always_deref {\n+                        NEEDLESS_BORROW\n+                    } else {\n+                        REF_BINDING_TO_REFERENCE\n+                    },\n+                    pat.spans,\n                     \"this pattern creates a reference to a reference\",\n                     |diag| {\n-                        if let Some(snippet) = snippet_opt(cx, name.span) {\n-                            diag.span_suggestion(\n-                                pat.span,\n-                                \"change this to\",\n-                                snippet,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    }\n+                        diag.multipart_suggestion(\"try this\", replacements, app);\n+                    },\n                 )\n             }\n+            self.current_body = None;\n+        }\n+    }\n+}\n+impl NeedlessBorrow {\n+    fn check_local_usage(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, local: HirId) {\n+        if let Some(outer_pat) = self.ref_locals.get_mut(&local) {\n+            if let Some(pat) = outer_pat {\n+                // Check for auto-deref\n+                if !matches!(\n+                    cx.typeck_results().expr_adjustments(e),\n+                    [\n+                        Adjustment {\n+                            kind: Adjust::Deref(_),\n+                            ..\n+                        },\n+                        Adjustment {\n+                            kind: Adjust::Deref(_),\n+                            ..\n+                        },\n+                        ..\n+                    ]\n+                ) {\n+                    match get_parent_expr(cx, e) {\n+                        // Field accesses are the same no matter the number of references.\n+                        Some(Expr {\n+                            kind: ExprKind::Field(..),\n+                            ..\n+                        }) => (),\n+                        Some(&Expr {\n+                            span,\n+                            kind: ExprKind::Unary(UnOp::Deref, _),\n+                            ..\n+                        }) if !in_macro(span) => {\n+                            // Remove explicit deref.\n+                            let snip = snippet_with_context(cx, e.span, span.ctxt(), \"..\", &mut pat.app).0;\n+                            pat.replacements.push((span, snip.into()));\n+                        },\n+                        Some(parent) if !in_macro(parent.span) => {\n+                            // Double reference might be needed at this point.\n+                            if parent.precedence().order() == PREC_POSTFIX {\n+                                // Parentheses would be needed here, don't lint.\n+                                *outer_pat = None;\n+                            } else {\n+                                pat.always_deref = false;\n+                                let snip = snippet_with_context(cx, e.span, parent.span.ctxt(), \"..\", &mut pat.app).0;\n+                                pat.replacements.push((e.span, format!(\"&{}\", snip)));\n+                            }\n+                        },\n+                        _ if !in_macro(e.span) => {\n+                            // Double reference might be needed at this point.\n+                            pat.always_deref = false;\n+                            let snip = snippet_with_applicability(cx, e.span, \"..\", &mut pat.app);\n+                            pat.replacements.push((e.span, format!(\"&{}\", snip)));\n+                        },\n+                        // Edge case for macros. The span of the identifier will usually match the context of the\n+                        // binding, but not if the identifier was created in a macro. e.g. `concat_idents` and proc\n+                        // macros\n+                        _ => *outer_pat = None,\n+                    }\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "25b4491616c1ceff609d170fe1a9f114787a8bf2", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -70,7 +70,7 @@ pub fn range<'a>(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n                 limits: ast::RangeLimits::Closed,\n             })\n         },\n-        hir::ExprKind::Struct(ref path, ref fields, None) => match path {\n+        hir::ExprKind::Struct(path, ref fields, None) => match path {\n             hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n                 start: None,\n                 end: None,"}, {"sha": "2b9b214daa7f9df10e827c9673ebbc0f9b903a61", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -1254,12 +1254,12 @@ pub fn match_function_call<'tcx>(\n     path: &[&str],\n ) -> Option<&'tcx [Expr<'tcx>]> {\n     if_chain! {\n-        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let ExprKind::Call(ref fun, args) = expr.kind;\n         if let ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n         if match_def_path(cx, fun_def_id, path);\n         then {\n-            return Some(&args)\n+            return Some(args)\n         }\n     };\n     None"}, {"sha": "73f132eef4d9ac53aa0622e88e6b040d08ba6293", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -189,34 +189,21 @@ impl<'v> Visitor<'v> for LocalUsedVisitor<'v> {\n     }\n }\n \n+/// A type which can be visited.\n pub trait Visitable<'tcx> {\n-    fn visit<V: Visitor<'tcx>>(self, v: &mut V);\n+    /// Calls the corresponding `visit_*` function on the visitor.\n+    fn visit<V: Visitor<'tcx>>(self, visitor: &mut V);\n }\n-impl Visitable<'tcx> for &'tcx Expr<'tcx> {\n-    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n-        v.visit_expr(self)\n-    }\n-}\n-impl Visitable<'tcx> for &'tcx Block<'tcx> {\n-    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n-        v.visit_block(self)\n-    }\n-}\n-impl<'tcx> Visitable<'tcx> for &'tcx Stmt<'tcx> {\n-    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n-        v.visit_stmt(self)\n-    }\n-}\n-impl<'tcx> Visitable<'tcx> for &'tcx Body<'tcx> {\n-    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n-        v.visit_body(self)\n-    }\n-}\n-impl<'tcx> Visitable<'tcx> for &'tcx Arm<'tcx> {\n-    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n-        v.visit_arm(self)\n-    }\n+macro_rules! visitable_ref {\n+    ($t:ident, $f:ident) => {\n+        impl Visitable<'tcx> for &'tcx $t<'tcx> {\n+            fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n+                visitor.$f(self);\n+            }\n+        }\n+    };\n }\n+visitable_ref!(Block, visit_block);\n \n /// Calls the given function for each break expression.\n pub fn visit_break_exprs<'tcx>("}, {"sha": "a87171dc3f24d80a8abf684916ac58e39bd29e80", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -18,7 +18,6 @@ fn main() {\n     let vec = Vec::new();\n     let vec_val = g(&vec); // should not error, because `&Vec<T>` derefs to `&[T]`\n     h(&\"foo\"); // should not error, because the `&&str` is required, due to `&Trait`\n-    if let Some(cake) = Some(&5) {}\n     let garbl = match 42 {\n         44 => &a,\n         45 => {\n@@ -43,19 +42,3 @@ trait Trait {}\n impl<'a> Trait for &'a str {}\n \n fn h(_: &dyn Trait) {}\n-#[warn(clippy::needless_borrow)]\n-#[allow(dead_code)]\n-fn issue_1432() {\n-    let mut v = Vec::<String>::new();\n-    let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n-    let _ = v.iter().filter(|&a| a.is_empty());\n-\n-    let _ = v.iter().filter(|&a| a.is_empty());\n-}\n-\n-#[allow(dead_code)]\n-#[warn(clippy::needless_borrow)]\n-#[derive(Debug)]\n-enum Foo<'a> {\n-    Str(&'a str),\n-}"}, {"sha": "059dc8ceac31a1521aabc2928d80b9b129d7b003", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -18,7 +18,6 @@ fn main() {\n     let vec = Vec::new();\n     let vec_val = g(&vec); // should not error, because `&Vec<T>` derefs to `&[T]`\n     h(&\"foo\"); // should not error, because the `&&str` is required, due to `&Trait`\n-    if let Some(ref cake) = Some(&5) {}\n     let garbl = match 42 {\n         44 => &a,\n         45 => {\n@@ -43,19 +42,3 @@ trait Trait {}\n impl<'a> Trait for &'a str {}\n \n fn h(_: &dyn Trait) {}\n-#[warn(clippy::needless_borrow)]\n-#[allow(dead_code)]\n-fn issue_1432() {\n-    let mut v = Vec::<String>::new();\n-    let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n-    let _ = v.iter().filter(|&ref a| a.is_empty());\n-\n-    let _ = v.iter().filter(|&a| a.is_empty());\n-}\n-\n-#[allow(dead_code)]\n-#[warn(clippy::needless_borrow)]\n-#[derive(Debug)]\n-enum Foo<'a> {\n-    Str(&'a str),\n-}"}, {"sha": "6eddf26db068f8fa58f3f89894f2ca3cd6d02978", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -6,23 +6,11 @@ LL |     let c = x(&&a);\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n-error: this pattern creates a reference to a reference\n-  --> $DIR/needless_borrow.rs:21:17\n-   |\n-LL |     if let Some(ref cake) = Some(&5) {}\n-   |                 ^^^^^^^^ help: change this to: `cake`\n-\n error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:28:15\n+  --> $DIR/needless_borrow.rs:27:15\n    |\n LL |         46 => &&a,\n    |               ^^^ help: change this to: `&a`\n \n-error: this pattern creates a reference to a reference\n-  --> $DIR/needless_borrow.rs:51:31\n-   |\n-LL |     let _ = v.iter().filter(|&ref a| a.is_empty());\n-   |                               ^^^^^ help: change this to: `a`\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "f0926220755a2006f061657a43aad2188e932a38", "filename": "tests/ui/needless_borrow_pat.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fneedless_borrow_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fneedless_borrow_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow_pat.rs?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -0,0 +1,151 @@\n+// edition:2018\n+// FIXME: run-rustfix waiting on multi-span suggestions\n+\n+#![warn(clippy::needless_borrow)]\n+#![allow(clippy::needless_borrowed_reference)]\n+\n+fn f1(_: &str) {}\n+macro_rules! m1 {\n+    ($e:expr) => {\n+        f1($e);\n+    };\n+}\n+macro_rules! m3 {\n+    ($i:ident) => {\n+        Some(ref $i)\n+    };\n+}\n+macro_rules! if_chain {\n+    (if $e:expr; $($rest:tt)*) => {\n+        if $e {\n+            if_chain!($($rest)*)\n+        }\n+    };\n+\n+    (if let $p:pat = $e:expr; $($rest:tt)*) => {\n+        if let $p = $e {\n+            if_chain!($($rest)*)\n+        }\n+    };\n+\n+    (then $b:block) => {\n+        $b\n+    };\n+}\n+\n+#[allow(dead_code)]\n+fn main() {\n+    let x = String::new();\n+\n+    // Ok, reference to a String.\n+    let _: &String = match Some(x.clone()) {\n+        Some(ref x) => x,\n+        None => return,\n+    };\n+\n+    // Ok, reference to a &mut String\n+    let _: &&mut String = match Some(&mut x.clone()) {\n+        Some(ref x) => x,\n+        None => return,\n+    };\n+\n+    // Ok, the pattern is from a macro\n+    let _: &String = match Some(&x) {\n+        m3!(x) => x,\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    let _: &String = match Some(&x) {\n+        Some(ref x) => x,\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String.\n+    let _: &String = match Some(&x) {\n+        Some(ref x) => *x,\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    let _: &String = match Some(&x) {\n+        Some(ref x) => {\n+            f1(x);\n+            f1(*x);\n+            x\n+        },\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    match Some(&x) {\n+        Some(ref x) => m1!(x),\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    let _ = |&ref x: &&String| {\n+        let _: &String = x;\n+    };\n+\n+    // Err, reference to a &String\n+    let (ref y,) = (&x,);\n+    let _: &String = *y;\n+\n+    let y = &&x;\n+    // Ok, different y\n+    let _: &String = *y;\n+\n+    let x = (0, 0);\n+    // Err, reference to a &u32. Don't suggest adding a reference to the field access.\n+    let _: u32 = match Some(&x) {\n+        Some(ref x) => x.0,\n+        None => return,\n+    };\n+\n+    enum E {\n+        A(&'static u32),\n+        B(&'static u32),\n+    }\n+    // Err, reference to &u32.\n+    let _: &u32 = match E::A(&0) {\n+        E::A(ref x) | E::B(ref x) => *x,\n+    };\n+\n+    // Err, reference to &String.\n+    if_chain! {\n+        if true;\n+        if let Some(ref x) = Some(&String::new());\n+        then {\n+            f1(x);\n+        }\n+    }\n+}\n+\n+// Err, reference to a &String\n+fn f2<'a>(&ref x: &&'a String) -> &'a String {\n+    let _: &String = x;\n+    *x\n+}\n+\n+trait T1 {\n+    // Err, reference to a &String\n+    fn f(&ref x: &&String) {\n+        let _: &String = x;\n+    }\n+}\n+\n+struct S;\n+impl T1 for S {\n+    // Err, reference to a &String\n+    fn f(&ref x: &&String) {\n+        let _: &String = *x;\n+    }\n+}\n+\n+// Ok - used to error due to rustc bug\n+#[allow(dead_code)]\n+#[derive(Debug)]\n+enum Foo<'a> {\n+    Str(&'a str),\n+}"}, {"sha": "32913d59f7ae89075354b675f4f5afc58da5308c", "filename": "tests/ui/needless_borrow_pat.stderr", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fneedless_borrow_pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fneedless_borrow_pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow_pat.stderr?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -0,0 +1,112 @@\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:60:14\n+   |\n+LL |         Some(ref x) => x,\n+   |              ^^^^^ help: try this: `x`\n+   |\n+   = note: `-D clippy::needless-borrow` implied by `-D warnings`\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:66:14\n+   |\n+LL |         Some(ref x) => *x,\n+   |              ^^^^^\n+   |\n+help: try this\n+   |\n+LL |         Some(x) => x,\n+   |              ^     ^\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:72:14\n+   |\n+LL |         Some(ref x) => {\n+   |              ^^^^^\n+   |\n+help: try this\n+   |\n+LL |         Some(x) => {\n+LL |             f1(x);\n+LL |             f1(x);\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:82:14\n+   |\n+LL |         Some(ref x) => m1!(x),\n+   |              ^^^^^ help: try this: `x`\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:87:15\n+   |\n+LL |     let _ = |&ref x: &&String| {\n+   |               ^^^^^ help: try this: `x`\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:92:10\n+   |\n+LL |     let (ref y,) = (&x,);\n+   |          ^^^^^\n+   |\n+help: try this\n+   |\n+LL |     let (y,) = (&x,);\n+LL |     let _: &String = y;\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:102:14\n+   |\n+LL |         Some(ref x) => x.0,\n+   |              ^^^^^ help: try this: `x`\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:112:14\n+   |\n+LL |         E::A(ref x) | E::B(ref x) => *x,\n+   |              ^^^^^         ^^^^^\n+   |\n+help: try this\n+   |\n+LL |         E::A(x) | E::B(x) => x,\n+   |              ^         ^     ^\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:118:21\n+   |\n+LL |         if let Some(ref x) = Some(&String::new());\n+   |                     ^^^^^ help: try this: `x`\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:126:12\n+   |\n+LL | fn f2<'a>(&ref x: &&'a String) -> &'a String {\n+   |            ^^^^^\n+   |\n+help: try this\n+   |\n+LL | fn f2<'a>(&x: &&'a String) -> &'a String {\n+LL |     let _: &String = x;\n+LL |     x\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:133:11\n+   |\n+LL |     fn f(&ref x: &&String) {\n+   |           ^^^^^ help: try this: `x`\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/needless_borrow_pat.rs:141:11\n+   |\n+LL |     fn f(&ref x: &&String) {\n+   |           ^^^^^\n+   |\n+help: try this\n+   |\n+LL |     fn f(&x: &&String) {\n+LL |         let _: &String = x;\n+   |\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "c7235e1c221057528a40b310a372971cf0201f87", "filename": "tests/ui/ref_binding_to_reference.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fref_binding_to_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fref_binding_to_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fref_binding_to_reference.rs?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -0,0 +1,76 @@\n+// edition:2018\n+// FIXME: run-rustfix waiting on multi-span suggestions\n+\n+#![warn(clippy::ref_binding_to_reference)]\n+#![allow(clippy::needless_borrowed_reference)]\n+\n+fn f1(_: &str) {}\n+macro_rules! m2 {\n+    ($e:expr) => {\n+        f1(*$e);\n+    };\n+}\n+macro_rules! m3 {\n+    ($i:ident) => {\n+        Some(ref $i)\n+    };\n+}\n+\n+#[allow(dead_code)]\n+fn main() {\n+    let x = String::new();\n+\n+    // Ok, the pattern is from a macro\n+    let _: &&String = match Some(&x) {\n+        m3!(x) => x,\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    let _: &&String = match Some(&x) {\n+        Some(ref x) => x,\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    let _: &&String = match Some(&x) {\n+        Some(ref x) => {\n+            f1(x);\n+            f1(*x);\n+            x\n+        },\n+        None => return,\n+    };\n+\n+    // Err, reference to a &String\n+    match Some(&x) {\n+        Some(ref x) => m2!(x),\n+        None => return,\n+    }\n+\n+    // Err, reference to a &String\n+    let _ = |&ref x: &&String| {\n+        let _: &&String = x;\n+    };\n+}\n+\n+// Err, reference to a &String\n+fn f2<'a>(&ref x: &&'a String) -> &'a String {\n+    let _: &&String = x;\n+    *x\n+}\n+\n+trait T1 {\n+    // Err, reference to a &String\n+    fn f(&ref x: &&String) {\n+        let _: &&String = x;\n+    }\n+}\n+\n+struct S;\n+impl T1 for S {\n+    // Err, reference to a &String\n+    fn f(&ref x: &&String) {\n+        let _: &&String = x;\n+    }\n+}"}, {"sha": "00aeff4fefa32536d43acb6bc3ae9261c0e603fb", "filename": "tests/ui/ref_binding_to_reference.stderr", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fref_binding_to_reference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d4dc35882a55610e9da81237d62bea1c0c1634e/tests%2Fui%2Fref_binding_to_reference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fref_binding_to_reference.stderr?ref=6d4dc35882a55610e9da81237d62bea1c0c1634e", "patch": "@@ -0,0 +1,88 @@\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:31:14\n+   |\n+LL |         Some(ref x) => x,\n+   |              ^^^^^\n+   |\n+   = note: `-D clippy::ref-binding-to-reference` implied by `-D warnings`\n+help: try this\n+   |\n+LL |         Some(x) => &x,\n+   |              ^     ^^\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:37:14\n+   |\n+LL |         Some(ref x) => {\n+   |              ^^^^^\n+   |\n+help: try this\n+   |\n+LL |         Some(x) => {\n+LL |             f1(x);\n+LL |             f1(x);\n+LL |             &x\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:47:14\n+   |\n+LL |         Some(ref x) => m2!(x),\n+   |              ^^^^^\n+   |\n+help: try this\n+   |\n+LL |         Some(x) => m2!(&x),\n+   |              ^         ^^\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:52:15\n+   |\n+LL |     let _ = |&ref x: &&String| {\n+   |               ^^^^^\n+   |\n+help: try this\n+   |\n+LL |     let _ = |&x: &&String| {\n+LL |         let _: &&String = &x;\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:58:12\n+   |\n+LL | fn f2<'a>(&ref x: &&'a String) -> &'a String {\n+   |            ^^^^^\n+   |\n+help: try this\n+   |\n+LL | fn f2<'a>(&x: &&'a String) -> &'a String {\n+LL |     let _: &&String = &x;\n+LL |     x\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:65:11\n+   |\n+LL |     fn f(&ref x: &&String) {\n+   |           ^^^^^\n+   |\n+help: try this\n+   |\n+LL |     fn f(&x: &&String) {\n+LL |         let _: &&String = &x;\n+   |\n+\n+error: this pattern creates a reference to a reference\n+  --> $DIR/ref_binding_to_reference.rs:73:11\n+   |\n+LL |     fn f(&ref x: &&String) {\n+   |           ^^^^^\n+   |\n+help: try this\n+   |\n+LL |     fn f(&x: &&String) {\n+LL |         let _: &&String = &x;\n+   |\n+\n+error: aborting due to 7 previous errors\n+"}]}