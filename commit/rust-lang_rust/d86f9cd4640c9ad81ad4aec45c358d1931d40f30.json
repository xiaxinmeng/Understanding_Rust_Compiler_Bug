{"sha": "d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "node_id": "C_kwDOAAsO6NoAKGQ4NmY5Y2Q0NjQwYzlhZDgxYWQ0YWVjNDVjMzU4ZDE5MzFkNDBmMzA", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-09-15T16:27:23Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-10-01T10:13:02Z"}, "message": "Replace some `bool` params with an enum", "tree": {"sha": "08417ec5fcd94d686f0385549d3cbe62aa65e142", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08417ec5fcd94d686f0385549d3cbe62aa65e142"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "html_url": "https://github.com/rust-lang/rust/commit/d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38b086524875c1ed9904f94eca64a162f7572dae", "url": "https://api.github.com/repos/rust-lang/rust/commits/38b086524875c1ed9904f94eca64a162f7572dae", "html_url": "https://github.com/rust-lang/rust/commit/38b086524875c1ed9904f94eca64a162f7572dae"}], "stats": {"total": 110, "additions": 63, "deletions": 47}, "files": [{"sha": "9c1dfeb1a61428920e20e4ac69f61e9913701094", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "patch": "@@ -29,6 +29,7 @@ extern crate rustc_macros;\n extern crate tracing;\n \n pub mod util {\n+    pub mod case;\n     pub mod classify;\n     pub mod comments;\n     pub mod literal;"}, {"sha": "5cdd0bf60a9d1893e842f087107483558b8ed534", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "patch": "@@ -5,6 +5,7 @@ pub use TokenKind::*;\n \n use crate::ast;\n use crate::ptr::P;\n+use crate::util::case::Case;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n@@ -618,10 +619,10 @@ impl Token {\n         self.is_non_raw_ident_where(|id| id.name == kw)\n     }\n \n-    /// Returns `true` if the token is a given keyword, `kw` or if `case_insensitive` is true and this token is an identifier equal to `kw` ignoring the case.\n-    pub fn is_keyword_case(&self, kw: Symbol, case_insensitive: bool) -> bool {\n+    /// Returns `true` if the token is a given keyword, `kw` or if `case` is `Insensitive` and this token is an identifier equal to `kw` ignoring the case.\n+    pub fn is_keyword_case(&self, kw: Symbol, case: Case) -> bool {\n         self.is_keyword(kw)\n-            || (case_insensitive\n+            || (case == Case::Insensitive\n                 && self.is_non_raw_ident_where(|id| {\n                     id.name.as_str().to_lowercase() == kw.as_str().to_lowercase()\n                 }))"}, {"sha": "1afd7dea7408ecb9c247e101ac7f4f951c636cf3", "filename": "compiler/rustc_ast/src/util/case.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs?ref=d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "patch": "@@ -0,0 +1,6 @@\n+/// Whatever to ignore case (`fn` vs `Fn` vs `FN`) or not. Used for recovering.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum Case {\n+    Sensitive,\n+    Insensitive,\n+}"}, {"sha": "6fbcc3fe5a1b941ded321ebad155a2e5f0fffe5b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "patch": "@@ -33,6 +33,7 @@ use core::mem;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::Spacing;\n+use rustc_ast::util::case::Case;\n use rustc_ast::util::classify;\n use rustc_ast::util::literal::LitError;\n use rustc_ast::util::parser::{prec_let_scrutinee_needs_par, AssocOp, Fixity};\n@@ -2024,7 +2025,7 @@ impl<'a> Parser<'a> {\n             if self.eat_keyword(kw::Static) { Movability::Static } else { Movability::Movable };\n \n         let asyncness = if self.token.uninterpolated_span().rust_2018() {\n-            self.parse_asyncness(false)\n+            self.parse_asyncness(Case::Sensitive)\n         } else {\n             Async::No\n         };"}, {"sha": "83a5704b6680c68297a4906390a5ca2b4337dc43", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "patch": "@@ -8,6 +8,7 @@ use rustc_ast::ast::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n+use rustc_ast::util::case::Case;\n use rustc_ast::{self as ast, AttrVec, Attribute, DUMMY_NODE_ID};\n use rustc_ast::{Async, Const, Defaultness, IsAuto, Mutability, Unsafe, UseTree, UseTreeKind};\n use rustc_ast::{BindingAnnotation, Block, FnDecl, FnSig, Param, SelfKind};\n@@ -34,7 +35,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n     fn parse_item_mod(&mut self, attrs: &mut AttrVec) -> PResult<'a, ItemInfo> {\n-        let unsafety = self.parse_unsafety(false);\n+        let unsafety = self.parse_unsafety(Case::Sensitive);\n         self.expect_keyword(kw::Mod)?;\n         let id = self.parse_ident()?;\n         let mod_kind = if self.eat(&token::Semi) {\n@@ -150,7 +151,7 @@ impl<'a> Parser<'a> {\n             &vis,\n             &mut def,\n             fn_parse_mode,\n-            false,\n+            Case::Sensitive,\n         )?;\n         if let Some((ident, kind)) = kind {\n             self.error_on_unconsumed_default(def, &kind);\n@@ -212,14 +213,14 @@ impl<'a> Parser<'a> {\n         vis: &Visibility,\n         def: &mut Defaultness,\n         fn_parse_mode: FnParseMode,\n-        kw_case_insensitive: bool,\n+        case: Case,\n     ) -> PResult<'a, Option<ItemInfo>> {\n         let def_final = def == &Defaultness::Final;\n         let mut def_ = || mem::replace(def, Defaultness::Final);\n \n-        let info = if self.eat_keyword_case(kw::Use, kw_case_insensitive) {\n+        let info = if self.eat_keyword_case(kw::Use, case) {\n             self.parse_use_item()?\n-        } else if self.check_fn_front_matter(def_final, kw_case_insensitive) {\n+        } else if self.check_fn_front_matter(def_final, case) {\n             // FUNCTION ITEM\n             let (ident, sig, generics, body) = self.parse_fn(attrs, fn_parse_mode, lo, vis)?;\n             (ident, ItemKind::Fn(Box::new(Fn { defaultness: def_(), sig, generics, body })))\n@@ -233,7 +234,7 @@ impl<'a> Parser<'a> {\n             }\n         } else if self.is_unsafe_foreign_mod() {\n             // EXTERN BLOCK\n-            let unsafety = self.parse_unsafety(false);\n+            let unsafety = self.parse_unsafety(Case::Sensitive);\n             self.expect_keyword(kw::Extern)?;\n             self.parse_item_foreign_mod(attrs, unsafety)?\n         } else if self.is_static_global() {\n@@ -242,7 +243,7 @@ impl<'a> Parser<'a> {\n             let m = self.parse_mutability();\n             let (ident, ty, expr) = self.parse_item_global(Some(m))?;\n             (ident, ItemKind::Static(ty, m, expr))\n-        } else if let Const::Yes(const_span) = self.parse_constness(false) {\n+        } else if let Const::Yes(const_span) = self.parse_constness(Case::Sensitive) {\n             // CONST ITEM\n             if self.token.is_keyword(kw::Impl) {\n                 // recover from `const impl`, suggest `impl const`\n@@ -294,11 +295,19 @@ impl<'a> Parser<'a> {\n         } else if self.isnt_macro_invocation() && vis.kind.is_pub() {\n             self.recover_missing_kw_before_item()?;\n             return Ok(None);\n-        } else if self.isnt_macro_invocation() && !kw_case_insensitive {\n+        } else if self.isnt_macro_invocation() && case == Case::Sensitive {\n             _ = def_;\n \n             // Recover wrong cased keywords\n-            return self.parse_item_kind(attrs, macros_allowed, lo, vis, def, fn_parse_mode, true);\n+            return self.parse_item_kind(\n+                attrs,\n+                macros_allowed,\n+                lo,\n+                vis,\n+                def,\n+                fn_parse_mode,\n+                Case::Insensitive,\n+            );\n         } else if macros_allowed && self.check_path() {\n             // MACRO INVOCATION ITEM\n             (Ident::empty(), ItemKind::MacCall(P(self.parse_item_macro(vis)?)))\n@@ -551,7 +560,7 @@ impl<'a> Parser<'a> {\n         attrs: &mut AttrVec,\n         defaultness: Defaultness,\n     ) -> PResult<'a, ItemInfo> {\n-        let unsafety = self.parse_unsafety(false);\n+        let unsafety = self.parse_unsafety(Case::Sensitive);\n         self.expect_keyword(kw::Impl)?;\n \n         // First, parse generic parameters if necessary.\n@@ -565,7 +574,7 @@ impl<'a> Parser<'a> {\n             generics\n         };\n \n-        let constness = self.parse_constness(false);\n+        let constness = self.parse_constness(Case::Sensitive);\n         if let Const::Yes(span) = constness {\n             self.sess.gated_spans.gate(sym::const_trait_impl, span);\n         }\n@@ -809,7 +818,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses `unsafe? auto? trait Foo { ... }` or `trait Foo = Bar;`.\n     fn parse_item_trait(&mut self, attrs: &mut AttrVec, lo: Span) -> PResult<'a, ItemInfo> {\n-        let unsafety = self.parse_unsafety(false);\n+        let unsafety = self.parse_unsafety(Case::Sensitive);\n         // Parse optional `auto` prefix.\n         let is_auto = if self.eat_keyword(kw::Auto) { IsAuto::Yes } else { IsAuto::No };\n \n@@ -1758,7 +1767,7 @@ impl<'a> Parser<'a> {\n         let (ident, is_raw) = self.ident_or_err()?;\n         if !is_raw && ident.is_reserved() {\n             let snapshot = self.create_snapshot_for_diagnostic();\n-            let err = if self.check_fn_front_matter(false, false) {\n+            let err = if self.check_fn_front_matter(false, Case::Sensitive) {\n                 let inherited_vis = Visibility {\n                     span: rustc_span::DUMMY_SP,\n                     kind: VisibilityKind::Inherited,\n@@ -2147,11 +2156,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// `check_pub` adds additional `pub` to the checks in case users place it\n     /// wrongly, can be used to ensure `pub` never comes after `default`.\n-    pub(super) fn check_fn_front_matter(\n-        &mut self,\n-        check_pub: bool,\n-        kw_case_insensitive: bool,\n-    ) -> bool {\n+    pub(super) fn check_fn_front_matter(&mut self, check_pub: bool, case: Case) -> bool {\n         // We use an over-approximation here.\n         // `const const`, `fn const` won't parse, but we're not stepping over other syntax either.\n         // `pub` is added in case users got confused with the ordering like `async pub fn`,\n@@ -2161,12 +2166,12 @@ impl<'a> Parser<'a> {\n         } else {\n             &[kw::Const, kw::Async, kw::Unsafe, kw::Extern]\n         };\n-        self.check_keyword_case(kw::Fn, kw_case_insensitive) // Definitely an `fn`.\n+        self.check_keyword_case(kw::Fn, case) // Definitely an `fn`.\n             // `$qual fn` or `$qual $qual`:\n-            || quals.iter().any(|&kw| self.check_keyword_case(kw, kw_case_insensitive))\n+            || quals.iter().any(|&kw| self.check_keyword_case(kw, case))\n                 && self.look_ahead(1, |t| {\n                     // `$qual fn`, e.g. `const fn` or `async fn`.\n-                    t.is_keyword_case(kw::Fn, kw_case_insensitive)\n+                    t.is_keyword_case(kw::Fn, case)\n                     // Two qualifiers `$qual $qual` is enough, e.g. `async unsafe`.\n                     || (\n                         (\n@@ -2175,16 +2180,16 @@ impl<'a> Parser<'a> {\n                                     // Rule out 2015 `const async: T = val`.\n                                     && i.is_reserved()\n                             )\n-                            || kw_case_insensitive\n+                            || case == Case::Insensitive\n                                 && t.is_non_raw_ident_where(|i| quals.iter().any(|qual| qual.as_str() == i.name.as_str().to_lowercase()))\n                         )\n                         // Rule out unsafe extern block.\n                         && !self.is_unsafe_foreign_mod())\n                 })\n             // `extern ABI fn`\n-            || self.check_keyword_case(kw::Extern, kw_case_insensitive)\n+            || self.check_keyword_case(kw::Extern, case)\n                 && self.look_ahead(1, |t| t.can_begin_literal_maybe_minus())\n-                && self.look_ahead(2, |t| t.is_keyword_case(kw::Fn, kw_case_insensitive))\n+                && self.look_ahead(2, |t| t.is_keyword_case(kw::Fn, case))\n     }\n \n     /// Parses all the \"front matter\" (or \"qualifiers\") for a `fn` declaration,\n@@ -2200,22 +2205,22 @@ impl<'a> Parser<'a> {\n     /// `Visibility::Inherited` when no visibility is known.\n     pub(super) fn parse_fn_front_matter(&mut self, orig_vis: &Visibility) -> PResult<'a, FnHeader> {\n         let sp_start = self.token.span;\n-        let constness = self.parse_constness(true);\n+        let constness = self.parse_constness(Case::Insensitive);\n \n         let async_start_sp = self.token.span;\n-        let asyncness = self.parse_asyncness(true);\n+        let asyncness = self.parse_asyncness(Case::Insensitive);\n \n         let unsafe_start_sp = self.token.span;\n-        let unsafety = self.parse_unsafety(true);\n+        let unsafety = self.parse_unsafety(Case::Insensitive);\n \n         let ext_start_sp = self.token.span;\n-        let ext = self.parse_extern(true);\n+        let ext = self.parse_extern(Case::Insensitive);\n \n         if let Async::Yes { span, .. } = asyncness {\n             self.ban_async_in_2015(span);\n         }\n \n-        if !self.eat_keyword_case(kw::Fn, true) {\n+        if !self.eat_keyword_case(kw::Fn, Case::Insensitive) {\n             // It is possible for `expect_one_of` to recover given the contents of\n             // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n             // account for this."}, {"sha": "11753af7039e85f50b82243e4020745adabb3f22", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "patch": "@@ -22,6 +22,7 @@ use rustc_ast::token::{self, Delimiter, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::AttributesData;\n use rustc_ast::tokenstream::{self, DelimSpan, Spacing};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast::util::case::Case;\n use rustc_ast::AttrId;\n use rustc_ast::DUMMY_NODE_ID;\n use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, Extern};\n@@ -604,12 +605,12 @@ impl<'a> Parser<'a> {\n         self.token.is_keyword(kw)\n     }\n \n-    fn check_keyword_case(&mut self, kw: Symbol, case_insensitive: bool) -> bool {\n+    fn check_keyword_case(&mut self, kw: Symbol, case: Case) -> bool {\n         if self.check_keyword(kw) {\n             return true;\n         }\n \n-        if case_insensitive\n+        if case == Case::Insensitive\n         && let Some((ident, /* is_raw */ false)) = self.token.ident()\n         && ident.as_str().to_lowercase() == kw.as_str().to_lowercase() {\n             true\n@@ -633,12 +634,12 @@ impl<'a> Parser<'a> {\n     /// Eats a keyword, optionally ignoring the case.\n     /// If the case differs (and is ignored) an error is issued.\n     /// This is useful for recovery.\n-    fn eat_keyword_case(&mut self, kw: Symbol, case_insensitive: bool) -> bool {\n+    fn eat_keyword_case(&mut self, kw: Symbol, case: Case) -> bool {\n         if self.eat_keyword(kw) {\n             return true;\n         }\n \n-        if case_insensitive\n+        if case == Case::Insensitive\n         && let Some((ident, /* is_raw */ false)) = self.token.ident()\n         && ident.as_str().to_lowercase() == kw.as_str().to_lowercase() {\n             self\n@@ -1136,8 +1137,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses asyncness: `async` or nothing.\n-    fn parse_asyncness(&mut self, case_insensitive: bool) -> Async {\n-        if self.eat_keyword_case(kw::Async, case_insensitive) {\n+    fn parse_asyncness(&mut self, case: Case) -> Async {\n+        if self.eat_keyword_case(kw::Async, case) {\n             let span = self.prev_token.uninterpolated_span();\n             Async::Yes { span, closure_id: DUMMY_NODE_ID, return_impl_trait_id: DUMMY_NODE_ID }\n         } else {\n@@ -1146,19 +1147,19 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses unsafety: `unsafe` or nothing.\n-    fn parse_unsafety(&mut self, case_insensitive: bool) -> Unsafe {\n-        if self.eat_keyword_case(kw::Unsafe, case_insensitive) {\n+    fn parse_unsafety(&mut self, case: Case) -> Unsafe {\n+        if self.eat_keyword_case(kw::Unsafe, case) {\n             Unsafe::Yes(self.prev_token.uninterpolated_span())\n         } else {\n             Unsafe::No\n         }\n     }\n \n     /// Parses constness: `const` or nothing.\n-    fn parse_constness(&mut self, case_insensitive: bool) -> Const {\n+    fn parse_constness(&mut self, case: Case) -> Const {\n         // Avoid const blocks to be parsed as const items\n         if self.look_ahead(1, |t| t != &token::OpenDelim(Delimiter::Brace))\n-            && self.eat_keyword_case(kw::Const, case_insensitive)\n+            && self.eat_keyword_case(kw::Const, case)\n         {\n             Const::Yes(self.prev_token.uninterpolated_span())\n         } else {\n@@ -1413,8 +1414,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `extern string_literal?`.\n-    fn parse_extern(&mut self, case_insensitive: bool) -> Extern {\n-        if self.eat_keyword_case(kw::Extern, case_insensitive) {\n+    fn parse_extern(&mut self, case: Case) -> Extern {\n+        if self.eat_keyword_case(kw::Extern, case) {\n             let mut extern_span = self.prev_token.span;\n             let abi = self.parse_abi();\n             if let Some(abi) = abi {"}, {"sha": "0f3281e52856592720b57141f5a5e0a5f0e8e9bb", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d86f9cd4640c9ad81ad4aec45c358d1931d40f30/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "patch": "@@ -4,6 +4,7 @@ use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n+use rustc_ast::util::case::Case;\n use rustc_ast::{\n     self as ast, BareFnTy, FnRetTy, GenericBound, GenericBounds, GenericParam, Generics, Lifetime,\n     MacCall, MutTy, Mutability, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax, Ty, TyKind,\n@@ -267,15 +268,15 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::Underscore) {\n             // A type to be inferred `_`\n             TyKind::Infer\n-        } else if self.check_fn_front_matter(false, false) {\n+        } else if self.check_fn_front_matter(false, Case::Sensitive) {\n             // Function pointer type\n             self.parse_ty_bare_fn(lo, Vec::new(), recover_return_sign)?\n         } else if self.check_keyword(kw::For) {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n             //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n             let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-            if self.check_fn_front_matter(false, false) {\n+            if self.check_fn_front_matter(false, Case::Sensitive) {\n                 self.parse_ty_bare_fn(lo, lifetime_defs, recover_return_sign)?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;"}]}