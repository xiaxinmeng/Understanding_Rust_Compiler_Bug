{"sha": "86b9377dd67019db9f0dacb1c077eb6ff24a64ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YjkzNzdkZDY3MDE5ZGI5ZjBkYWNiMWMwNzdlYjZmZjI0YTY0YWU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-26T14:34:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-26T14:34:29Z"}, "message": "Rollup merge of #68712 - HeroicKatora:finalize-ref-cell, r=dtolnay\n\nAdd methods to 'leak' RefCell borrows as references with the lifetime of the original reference\n\nUsually, references to the interior are only created by the `Deref` and\n`DerefMut` impl of the guards `Ref` and `RefMut`. Note that `RefCell`\nalready has to cope with leaks of such guards which, when it occurs,\neffectively makes it impossible to ever acquire a mutable guard or any\nguard for `Ref` and `RefMut` respectively. It is already safe to use\nthis to create a reference to the inner of the ref cell that lives as\nlong as the reference to the `RefCell` itself, e.g.\n\n```rust\nfn leak(r: &RefCell<usize>) -> Option<&usize> {\n    let guard = r.try_borrow().ok()?;\n    let leaked = Box::leak(Box::new(guard));\n    Some(&*leaked)\n}\n```\n\nThe newly added methods allow the same reference conversion without an\nindirection over a leaked allocation. It's placed on the `Ref`/`RefMut` to\ncompose with both borrow and try_borrow directly.", "tree": {"sha": "c08b61d06eddd53b0b095165494186d05bc1482f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c08b61d06eddd53b0b095165494186d05bc1482f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86b9377dd67019db9f0dacb1c077eb6ff24a64ae", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeVoH1CRBK7hj4Ov3rIwAAdHIIAHhmfpMnpNpdKExCwO4u2Gig\npPw8T6cCch3rwGTpGomkYpAZfEdoExcqlXn+i7cK2+9r/qAqfDXI46sdCb6V1zdd\naiSNS21PeU9c1oHDknE6mCuhero51iUhYKeDw5tfKL1uTuhbHFOGG+Bev6md0/Wa\n+im3vmO+dJFgodYCRI5g3Dbk5IMTkVU+9DYfptQaPQ84bglD3yiiHZqnY3yfsC4y\nqghnrA/wsSSbgsuF6fKNqxzK0+/s7w0XHHp7DGN/n6xBGWRLGexHtgzm8diIR1yQ\n19tRCLB2Bvl3zin3Kldf2Sy6mp+IHU89QytX6pP47khAQ97LWGC1rRGzXTGOuw0=\n=Pam1\n-----END PGP SIGNATURE-----\n", "payload": "tree c08b61d06eddd53b0b095165494186d05bc1482f\nparent 3a0d106109d73ed2e45a9925a9512ade2afb7df9\nparent 329022dfad7199053cbe225e8d7d13ebbd5eb230\nauthor Dylan DPC <dylan.dpc@gmail.com> 1582727669 +0100\ncommitter GitHub <noreply@github.com> 1582727669 +0100\n\nRollup merge of #68712 - HeroicKatora:finalize-ref-cell, r=dtolnay\n\nAdd methods to 'leak' RefCell borrows as references with the lifetime of the original reference\n\nUsually, references to the interior are only created by the `Deref` and\n`DerefMut` impl of the guards `Ref` and `RefMut`. Note that `RefCell`\nalready has to cope with leaks of such guards which, when it occurs,\neffectively makes it impossible to ever acquire a mutable guard or any\nguard for `Ref` and `RefMut` respectively. It is already safe to use\nthis to create a reference to the inner of the ref cell that lives as\nlong as the reference to the `RefCell` itself, e.g.\n\n```rust\nfn leak(r: &RefCell<usize>) -> Option<&usize> {\n    let guard = r.try_borrow().ok()?;\n    let leaked = Box::leak(Box::new(guard));\n    Some(&*leaked)\n}\n```\n\nThe newly added methods allow the same reference conversion without an\nindirection over a leaked allocation. It's placed on the `Ref`/`RefMut` to\ncompose with both borrow and try_borrow directly.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86b9377dd67019db9f0dacb1c077eb6ff24a64ae", "html_url": "https://github.com/rust-lang/rust/commit/86b9377dd67019db9f0dacb1c077eb6ff24a64ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86b9377dd67019db9f0dacb1c077eb6ff24a64ae/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a0d106109d73ed2e45a9925a9512ade2afb7df9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a0d106109d73ed2e45a9925a9512ade2afb7df9", "html_url": "https://github.com/rust-lang/rust/commit/3a0d106109d73ed2e45a9925a9512ade2afb7df9"}, {"sha": "329022dfad7199053cbe225e8d7d13ebbd5eb230", "url": "https://api.github.com/repos/rust-lang/rust/commits/329022dfad7199053cbe225e8d7d13ebbd5eb230", "html_url": "https://github.com/rust-lang/rust/commit/329022dfad7199053cbe225e8d7d13ebbd5eb230"}], "stats": {"total": 63, "additions": 63, "deletions": 0}, "files": [{"sha": "9ebb317641875ae42b31634c61f3eeff9781cff2", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/86b9377dd67019db9f0dacb1c077eb6ff24a64ae/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b9377dd67019db9f0dacb1c077eb6ff24a64ae/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=86b9377dd67019db9f0dacb1c077eb6ff24a64ae", "patch": "@@ -1245,6 +1245,38 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         let borrow = orig.borrow.clone();\n         (Ref { value: a, borrow }, Ref { value: b, borrow: orig.borrow })\n     }\n+\n+    /// Convert into a reference to the underlying data.\n+    ///\n+    /// The underlying `RefCell` can never be mutably borrowed from again and will always appear\n+    /// already immutably borrowed. It is not a good idea to leak more than a constant number of\n+    /// references. The `RefCell` can be immutably borrowed again if only a smaller number of leaks\n+    /// have occurred in total.\n+    ///\n+    /// This is an associated function that needs to be used as\n+    /// `Ref::leak(...)`. A method would interfere with methods of the\n+    /// same name on the contents of a `RefCell` used through `Deref`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cell_leak)]\n+    /// use std::cell::{RefCell, Ref};\n+    /// let cell = RefCell::new(0);\n+    ///\n+    /// let value = Ref::leak(cell.borrow());\n+    /// assert_eq!(*value, 0);\n+    ///\n+    /// assert!(cell.try_borrow().is_ok());\n+    /// assert!(cell.try_borrow_mut().is_err());\n+    /// ```\n+    #[unstable(feature = \"cell_leak\", issue = \"69099\")]\n+    pub fn leak(orig: Ref<'b, T>) -> &'b T {\n+        // By forgetting this Ref we ensure that the borrow counter in the RefCell never goes back\n+        // to UNUSED again. No further mutable references can be created from the original cell.\n+        mem::forget(orig.borrow);\n+        orig.value\n+    }\n }\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n@@ -1330,6 +1362,37 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         let borrow = orig.borrow.clone();\n         (RefMut { value: a, borrow }, RefMut { value: b, borrow: orig.borrow })\n     }\n+\n+    /// Convert into a mutable reference to the underlying data.\n+    ///\n+    /// The underlying `RefCell` can not be borrowed from again and will always appear already\n+    /// mutably borrowed, making the returned reference the only to the interior.\n+    ///\n+    /// This is an associated function that needs to be used as\n+    /// `RefMut::leak(...)`. A method would interfere with methods of the\n+    /// same name on the contents of a `RefCell` used through `Deref`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cell_leak)]\n+    /// use std::cell::{RefCell, RefMut};\n+    /// let cell = RefCell::new(0);\n+    ///\n+    /// let value = RefMut::leak(cell.borrow_mut());\n+    /// assert_eq!(*value, 0);\n+    /// *value = 1;\n+    ///\n+    /// assert!(cell.try_borrow_mut().is_err());\n+    /// ```\n+    #[unstable(feature = \"cell_leak\", issue = \"69099\")]\n+    pub fn leak(orig: RefMut<'b, T>) -> &'b mut T {\n+        // By forgetting this BorrowRefMut we ensure that the borrow counter in the RefCell never\n+        // goes back to UNUSED again. No further references can be created from the original cell,\n+        // making the current borrow the only reference for the remaining lifetime.\n+        mem::forget(orig.borrow);\n+        orig.value\n+    }\n }\n \n struct BorrowRefMut<'b> {"}]}