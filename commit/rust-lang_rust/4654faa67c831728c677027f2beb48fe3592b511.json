{"sha": "4654faa67c831728c677027f2beb48fe3592b511", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NTRmYWE2N2M4MzE3MjhjNjc3MDI3ZjJiZWI0OGZlMzU5MmI1MTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-08T20:42:56Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-08T20:42:56Z"}, "message": "rustc: Add a slot for explicit type parameter instantations to the typechecker's AST annotation", "tree": {"sha": "36352677b4415e077c97dc688583a1ce7f097e79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36352677b4415e077c97dc688583a1ce7f097e79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4654faa67c831728c677027f2beb48fe3592b511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4654faa67c831728c677027f2beb48fe3592b511", "html_url": "https://github.com/rust-lang/rust/commit/4654faa67c831728c677027f2beb48fe3592b511", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4654faa67c831728c677027f2beb48fe3592b511/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2f6f19fc807e1e9067a5fa6abc188ddf21f775c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2f6f19fc807e1e9067a5fa6abc188ddf21f775c", "html_url": "https://github.com/rust-lang/rust/commit/e2f6f19fc807e1e9067a5fa6abc188ddf21f775c"}], "stats": {"total": 203, "additions": 122, "deletions": 81}, "files": [{"sha": "5691480016b7d8fd24525d26c633c26bc5f390e2", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4654faa67c831728c677027f2beb48fe3592b511/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4654faa67c831728c677027f2beb48fe3592b511/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=4654faa67c831728c677027f2beb48fe3592b511", "patch": "@@ -21,7 +21,7 @@ type ty_param = rec(ident ident, def_id id);\n // Annotations added during successive passes.\n tag ann {\n     ann_none;\n-    ann_type(@middle.ty.t);\n+    ann_type(@middle.ty.t, option.t[vec[@middle.ty.t]] /* ty param substs */);\n }\n \n tag def {"}, {"sha": "7457a5326bd89d4088b754bc17f1eb510d190baa", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4654faa67c831728c677027f2beb48fe3592b511/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4654faa67c831728c677027f2beb48fe3592b511/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4654faa67c831728c677027f2beb48fe3592b511", "patch": "@@ -2238,7 +2238,7 @@ fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> @ty.t {\n         case (ast.ann_none) {\n             cx.sess.bug(\"missing type annotation\");\n         }\n-        case (ast.ann_type(?t)) {\n+        case (ast.ann_type(?t, _)) {\n             ret target_type(cx, t);\n         }\n     }"}, {"sha": "9ae39c9d42026745d48c5a908cc9026a408d1dd9", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4654faa67c831728c677027f2beb48fe3592b511/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4654faa67c831728c677027f2beb48fe3592b511/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=4654faa67c831728c677027f2beb48fe3592b511", "patch": "@@ -599,7 +599,7 @@ fn ann_to_type(&ast.ann ann) -> @t {\n             // shouldn't happen, but can until the typechecker is complete\n             ret plain_ty(ty_var(-1));    // FIXME: broken, broken, broken\n         }\n-        case (ast.ann_type(?ty)) {\n+        case (ast.ann_type(?ty, _)) {\n             ret ty;\n         }\n     }"}, {"sha": "cf917d19ef07e43e30ec97b461367528bc728cdf", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 119, "deletions": 78, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/4654faa67c831728c677027f2beb48fe3592b511/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4654faa67c831728c677027f2beb48fe3592b511/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=4654faa67c831728c677027f2beb48fe3592b511", "patch": "@@ -540,7 +540,10 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n             item_to_ty.insert(variant.id, result_ty);\n \n-            auto variant_t = rec(ann=ast.ann_type(result_ty) with variant);\n+            auto variant_t = rec(\n+                ann=ast.ann_type(result_ty, none[vec[@ty.t]])\n+                with variant\n+            );\n             result += vec(variant_t);\n         }\n \n@@ -641,9 +644,9 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                        @ast.ty t, @ast.expr ex,\n                        ast.def_id id, ast.ann a) -> @ast.item {\n         check (e.item_to_ty.contains_key(id));\n-        auto ty = e.item_to_ty.get(id);\n+        auto typ = e.item_to_ty.get(id);\n         auto item = ast.item_const(i, t, ex, id,\n-                                   ast.ann_type(ty));\n+                                   ast.ann_type(typ, none[vec[@ty.t]]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -653,9 +656,9 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         collect_ty_params(e, id, ty_params);\n \n         check (e.item_to_ty.contains_key(id));\n-        auto ty = e.item_to_ty.get(id);\n+        auto typ = e.item_to_ty.get(id);\n         auto item = ast.item_fn(i, f, ty_params, id,\n-                                ast.ann_type(ty));\n+                                ast.ann_type(typ, none[vec[@ty.t]]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -665,9 +668,9 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         collect_ty_params(e, id, ty_params);\n \n         check (e.item_to_ty.contains_key(id));\n-        auto ty = e.item_to_ty.get(id);\n+        auto typ = e.item_to_ty.get(id);\n         auto item = ast.native_item_fn(i, d, ty_params, id,\n-                                       ast.ann_type(ty));\n+                                       ast.ann_type(typ, none[vec[@ty.t]]));\n         ret @fold.respan[ast.native_item_](sp, item);\n     }\n \n@@ -713,22 +716,28 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             auto meth_tfn = plain_ty(ty.ty_fn(meth_ty.proto,\n                                               meth_ty.inputs,\n                                               meth_ty.output));\n-            m_ = rec(ann=ast.ann_type(meth_tfn) with meth.node);\n+            m_ = rec(\n+                ann=ast.ann_type(meth_tfn, none[vec[@ty.t]])\n+                with meth.node\n+            );\n             m = @rec(node=m_ with *meth);\n             append[@ast.method](methods, m);\n         }\n         auto g = bind getter(e.id_to_ty_item, e.item_to_ty, _);\n         for (ast.obj_field fld in ob.fields) {\n             let @ty.t fty = ast_ty_to_ty(g, fld.ty);\n-            let ast.obj_field f = rec(ann=ast.ann_type(fty) with fld);\n+            let ast.obj_field f = rec(\n+                ann=ast.ann_type(fty, none[vec[@ty.t]])\n+                with fld\n+            );\n             append[ast.obj_field](fields, f);\n         }\n \n         auto ob_ = rec(methods = methods,\n                        fields = fields\n                        with ob);\n         auto item = ast.item_obj(i, ob_, ty_params, id,\n-                                 ast.ann_type(t));\n+                                 ast.ann_type(t, none[vec[@ty.t]]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -738,9 +747,9 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         collect_ty_params(e, id, ty_params);\n \n         check (e.item_to_ty.contains_key(id));\n-        auto ty = e.item_to_ty.get(id);\n+        auto typ = e.item_to_ty.get(id);\n         auto item = ast.item_ty(i, t, ty_params, id,\n-                                ast.ann_type(ty));\n+                                ast.ann_type(typ, none[vec[@ty.t]]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -908,16 +917,16 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n     alt (pat.node) {\n         case (ast.pat_wild(?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n-            p_1 = ast.pat_wild(ast.ann_type(t));\n+            p_1 = ast.pat_wild(ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.pat_lit(?lit, ?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n-            p_1 = ast.pat_lit(lit, ast.ann_type(t));\n+            p_1 = ast.pat_lit(lit, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.pat_bind(?id, ?did, ?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n             fcx.locals.insert(did, t);\n-            p_1 = ast.pat_bind(id, did, ast.ann_type(t));\n+            p_1 = ast.pat_bind(id, did, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n             auto t = demand(fcx, pat.span, expected, ann_to_type(ann));\n@@ -939,10 +948,14 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n             alt (variant_ty.struct) {\n                 case (ty.ty_tag(_, _)) {\n                     // Nullary tag variant.\n+                    // TODO: ty param substs\n                     check (subpats_len == 0u);\n-                    p_1 = ast.pat_tag(id, subpats, vdef_opt, ast.ann_type(t));\n+                    p_1 = ast.pat_tag(id, subpats, vdef_opt,\n+                                      ast.ann_type(t, none[vec[@ty.t]]));\n                 }\n                 case (ty.ty_fn(_, ?args, ?tag_ty)) {\n+                    // N-ary tag variant.\n+                    // TODO: ty param substs\n                     let vec[@ast.pat] new_subpats = vec();\n                     auto i = 0u;\n                     for (arg a in args) {\n@@ -951,7 +964,7 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n                         i += 1u;\n                     }\n                     p_1 = ast.pat_tag(id, new_subpats, vdef_opt,\n-                                      ast.ann_type(tag_ty));\n+                                      ast.ann_type(tag_ty, none[vec[@ty.t]]));\n                 }\n             }\n         }\n@@ -990,7 +1003,7 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     fail;\n                 }\n             }\n-            e_1 = ast.expr_vec(es_1, ast.ann_type(t));\n+            e_1 = ast.expr_vec(es_1, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_tup(?es_0, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n@@ -1009,7 +1022,7 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     fail;\n                 }\n             }\n-            e_1 = ast.expr_tup(elts_1, ast.ann_type(t));\n+            e_1 = ast.expr_tup(elts_1, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_rec(?fields_0, ?base_0, ?ann)) {\n \n@@ -1062,37 +1075,41 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     fail;\n                 }\n             }\n-            e_1 = ast.expr_rec(fields_1, base_1, ast.ann_type(t));\n+            e_1 = ast.expr_rec(fields_1, base_1,\n+                               ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_bind(?sube, ?es, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_bind(sube, es, ast.ann_type(t));\n+            e_1 = ast.expr_bind(sube, es, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_call(?sube, ?es, ?ann)) {\n             // NB: we call 'demand_full' and pass in adk only in cases where\n             // e is an expression that could *possibly* produce a box; things\n             // like expr_binary or expr_bind can't, so there's no need.\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_call(sube, es, ast.ann_type(t));\n+            e_1 = ast.expr_call(sube, es, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_binary(bop, lhs, rhs, ast.ann_type(t));\n+            e_1 = ast.expr_binary(bop, lhs, rhs,\n+                                  ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_unary(?uop, ?sube, ?ann)) {\n             // See note in expr_unary for why we're calling demand_full.\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_unary(uop, sube, ast.ann_type(t));\n+            e_1 = ast.expr_unary(uop, sube,\n+                                 ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_lit(?lit, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_lit(lit, ast.ann_type(t));\n+            e_1 = ast.expr_lit(lit, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_cast(?sube, ?ast_ty, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_cast(sube, ast_ty, ast.ann_type(t));\n+            e_1 = ast.expr_cast(sube, ast_ty,\n+                                ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_if(?cond, ?then_0, ?elifs_0, ?else_0, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n@@ -1115,62 +1132,71 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n                     else_1 = some[ast.block](b_1);\n                 }\n             }\n-            e_1 = ast.expr_if(cond, then_1, elifs_1, else_1, ast.ann_type(t));\n+            e_1 = ast.expr_if(cond, then_1, elifs_1, else_1,\n+                              ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_for(?decl, ?seq, ?bloc, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_for(decl, seq, bloc, ast.ann_type(t));\n+            e_1 = ast.expr_for(decl, seq, bloc,\n+                               ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_for_each(decl, seq, bloc, ast.ann_type(t));\n+            e_1 = ast.expr_for_each(decl, seq, bloc,\n+                                    ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_while(?cond, ?bloc, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_while(cond, bloc, ast.ann_type(t));\n+            e_1 = ast.expr_while(cond, bloc,\n+                                 ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_do_while(?bloc, ?cond, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n-            e_1 = ast.expr_do_while(bloc, cond, ast.ann_type(t));\n+            e_1 = ast.expr_do_while(bloc, cond,\n+                                    ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_block(?bloc, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_block(bloc, ast.ann_type(t));\n+            e_1 = ast.expr_block(bloc, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n             auto lhs_1 = demand_expr(fcx, expected, lhs_0);\n             auto rhs_1 = demand_expr(fcx, expected, rhs_0);\n-            e_1 = ast.expr_assign(lhs_1, rhs_1, ast.ann_type(t));\n+            e_1 = ast.expr_assign(lhs_1, rhs_1,\n+                                  ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n             auto lhs_1 = demand_expr(fcx, expected, lhs_0);\n             auto rhs_1 = demand_expr(fcx, expected, rhs_0);\n-            e_1 = ast.expr_assign_op(op, lhs_1, rhs_1, ast.ann_type(t));\n+            e_1 = ast.expr_assign_op(op, lhs_1, rhs_1,\n+                                     ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_field(?lhs, ?rhs, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_field(lhs, rhs, ast.ann_type(t));\n+            e_1 = ast.expr_field(lhs, rhs, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_index(?base, ?index, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_index(base, index, ast.ann_type(t));\n+            e_1 = ast.expr_index(base, index,\n+                                 ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_path(?pth, ?d, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_path(pth, d, ast.ann_type(t));\n+            e_1 = ast.expr_path(pth, d, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n-            e_1 = ast.expr_ext(p, args, body, expanded, ast.ann_type(t));\n+            e_1 = ast.expr_ext(p, args, body, expanded,\n+                               ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_fail) { e_1 = e.node; }\n         case (ast.expr_log(_)) { e_1 = e.node; }\n@@ -1213,7 +1239,10 @@ fn writeback_local(&@fn_ctxt fcx, &span sp, @ast.local local)\n                               + local.ident);\n     }\n     auto local_ty = fcx.locals.get(local.id);\n-    auto local_wb = @rec(ann=ast.ann_type(local_ty) with *local);\n+    auto local_wb = @rec(\n+        ann=ast.ann_type(local_ty, none[vec[@ty.t]])\n+        with *local\n+    );\n     ret @fold.respan[ast.decl_](sp, ast.decl_local(local_wb));\n }\n \n@@ -1245,13 +1274,15 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n     auto new_pat;\n     alt (pat.node) {\n         case (ast.pat_wild(_)) {\n-            new_pat = ast.pat_wild(ast.ann_type(next_ty_var(fcx.ccx)));\n+            new_pat = ast.pat_wild(ast.ann_type(next_ty_var(fcx.ccx),\n+                                                none[vec[@ty.t]]));\n         }\n         case (ast.pat_lit(?lt, _)) {\n-            new_pat = ast.pat_lit(lt, ast.ann_type(check_lit(lt)));\n+            new_pat = ast.pat_lit(lt, ast.ann_type(check_lit(lt),\n+                                                   none[vec[@ty.t]]));\n         }\n         case (ast.pat_bind(?id, ?def_id, _)) {\n-            auto ann = ast.ann_type(next_ty_var(fcx.ccx));\n+            auto ann = ast.ann_type(next_ty_var(fcx.ccx), none[vec[@ty.t]]);\n             new_pat = ast.pat_bind(id, def_id, ann);\n         }\n         case (ast.pat_tag(?p, ?subpats, ?vdef_opt, _)) {\n@@ -1280,7 +1311,7 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n                         new_subpats += vec(check_pat(fcx, subpat));\n                     }\n \n-                    auto ann = ast.ann_type(tag_ty);\n+                    auto ann = ast.ann_type(tag_ty, none[vec[@ty.t]]);\n                     new_pat = ast.pat_tag(p, new_subpats, vdef_opt, ann);\n                 }\n \n@@ -1302,7 +1333,8 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n                     }\n \n                     let vec[@ty.t] tys = vec(); // FIXME\n-                    auto ann = ast.ann_type(plain_ty(ty.ty_tag(tid, tys)));\n+                    auto ann = ast.ann_type(plain_ty(ty.ty_tag(tid, tys)),\n+                                            none[vec[@ty.t]]);\n                     new_pat = ast.pat_tag(p, subpats, vdef_opt, ann);\n                 }\n             }\n@@ -1399,9 +1431,9 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n     alt (expr.node) {\n         case (ast.expr_lit(?lit, _)) {\n-            auto ty = check_lit(lit);\n-            ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_lit(lit, ast.ann_type(ty)));\n+            auto typ = check_lit(lit);\n+            auto ann = ast.ann_type(typ, none[vec[@ty.t]]);\n+            ret @fold.respan[ast.expr_](expr.span, ast.expr_lit(lit, ann));\n         }\n \n \n@@ -1427,9 +1459,11 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (ast.gt) { t = plain_ty(ty.ty_bool); }\n                 case (_) { /* fall through */ }\n             }\n+\n+            auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_binary(binop, lhs_1, rhs_1,\n-                                                        ast.ann_type(t)));\n+                                                        ann));\n         }\n \n \n@@ -1456,9 +1490,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n                 case (_) { oper_t = strip_boxes(oper_t); }\n             }\n+\n+            auto ann = ast.ann_type(oper_t, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_unary(unop, oper_1,\n-                                                       ast.ann_type(oper_t)));\n+                                        ast.expr_unary(unop, oper_1, ann));\n         }\n \n         case (ast.expr_path(?pth, ?defopt, _)) {\n@@ -1552,17 +1587,18 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n             }\n \n+            auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_path(pth, defopt,\n-                                                      ast.ann_type(t)));\n+                                        ast.expr_path(pth, defopt, ann));\n         }\n \n         case (ast.expr_ext(?p, ?args, ?body, ?expanded, _)) {\n             auto exp_ = check_expr(fcx, expanded);\n             auto t = expr_ty(exp_);\n+            auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_ext(p, args, body, exp_,\n-                                                     ast.ann_type(t)));\n+                                                     ann));\n         }\n \n         case (ast.expr_fail) {\n@@ -1641,7 +1677,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n             auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n \n-            auto ann = ast.ann_type(rhs_t0);\n+            auto ann = ast.ann_type(rhs_t0, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_assign(lhs_1, rhs_1, ann));\n         }\n@@ -1655,7 +1691,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n             auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n \n-            auto ann = ast.ann_type(rhs_t0);\n+            auto ann = ast.ann_type(rhs_t0, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_assign_op(op, lhs_1, rhs_1,\n                                                            ann));\n@@ -1700,10 +1736,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             auto thn_1 = demand_block(fcx, elsopt_t, thn_0);\n \n+            auto ann = ast.ann_type(elsopt_t, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_if(cond_1, thn_1,\n-                                                    elifs_1, elsopt_1,\n-                                                    ast.ann_type(elsopt_t)));\n+                                                    elifs_1, elsopt_1, ann));\n         }\n \n         case (ast.expr_for(?decl, ?seq, ?body, _)) {\n@@ -1714,7 +1750,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             // FIXME: enforce that the type of the decl is the element type\n             // of the seq.\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_nil));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_nil), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for(decl_1, seq_1,\n                                                      body_1, ann));\n@@ -1725,7 +1761,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto seq_1 = check_expr(fcx, seq);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_nil));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_nil), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for_each(decl_1, seq_1,\n                                                           body_1, ann));\n@@ -1736,7 +1772,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_nil));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_nil), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_while(cond_1, body_1, ann));\n         }\n@@ -1746,7 +1782,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = ast.ann_type(block_ty(body_1));\n+            auto ann = ast.ann_type(block_ty(body_1), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_do_while(body_1, cond_1,\n                                                           ann));\n@@ -1796,7 +1832,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             auto expr_1 = demand_expr(fcx, pattern_ty, expr_0);\n \n-            auto ann = ast.ann_type(result_ty);\n+            auto ann = ast.ann_type(result_ty, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_alt(expr_1, arms_1, ann));\n         }\n@@ -1806,10 +1842,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto ann;\n             alt (b_0.node.expr) {\n                 case (some[@ast.expr](?expr)) {\n-                    ann = ast.ann_type(expr_ty(expr));\n+                    ann = ast.ann_type(expr_ty(expr), none[vec[@ty.t]]);\n                 }\n                 case (none[@ast.expr]) {\n-                    ann = ast.ann_type(plain_ty(ty.ty_nil));\n+                    ann = ast.ann_type(plain_ty(ty.ty_nil), none[vec[@ty.t]]);\n                 }\n             }\n             ret @fold.respan[ast.expr_](expr.span,\n@@ -1849,9 +1885,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             }\n \n             auto t_1 = plain_ty(ty.ty_fn(proto_1, arg_tys_1, rt_1));\n+            auto ann = ast.ann_type(t_1, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_bind(result._0, result._1,\n-                                                      ast.ann_type(t_1)));\n+                                                      ann));\n         }\n \n         case (ast.expr_call(?f, ?args, _)) {\n@@ -1880,9 +1917,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n             }\n \n+            auto ann = ast.ann_type(rt_1, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_call(result._0, args_1,\n-                                                      ast.ann_type(rt_1)));\n+                                                      ann));\n         }\n \n         case (ast.expr_cast(?e, ?t, _)) {\n@@ -1897,9 +1935,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                       + \" as \"\n                                       +  ty_to_str(t_1));\n             }\n+\n+            auto ann = ast.ann_type(t_1, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_cast(e_1, t,\n-                                                      ast.ann_type(t_1)));\n+                                        ast.expr_cast(e_1, t, ann));\n         }\n \n         case (ast.expr_vec(?args, _)) {\n@@ -1922,7 +1961,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 demand(fcx, expr.span, t, expr_t);\n                 append[@ast.expr](args_1,expr_1);\n             }\n-            auto ann = ast.ann_type(plain_ty(ty.ty_vec(t)));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_vec(t)), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_vec(args_1, ann));\n         }\n@@ -1941,7 +1980,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 append[@ty.t](elts_t, expr_t);\n             }\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_tup(elts_t)));\n+            auto ann = ast.ann_type(plain_ty(ty.ty_tup(elts_t)),\n+                                    none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_tup(elts_1, ann));\n         }\n@@ -1967,7 +2007,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             alt (base) {\n                 case (none[@ast.expr]) {\n-                    ann = ast.ann_type(plain_ty(ty.ty_rec(fields_t)));\n+                    ann = ast.ann_type(plain_ty(ty.ty_rec(fields_t)),\n+                                       none[vec[@ty.t]]);\n                 }\n \n                 case (some[@ast.expr](?bexpr)) {\n@@ -1987,7 +2028,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         }\n                     }\n \n-                    ann = ast.ann_type(bexpr_t);\n+                    ann = ast.ann_type(bexpr_t, none[vec[@ty.t]]);\n \n                     for (ty.field f in fields_t) {\n                         auto found = false;\n@@ -2022,7 +2063,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n-                    auto ann = ast.ann_type(args.(ix));\n+                    auto ann = ast.ann_type(args.(ix), none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2036,7 +2077,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n-                    auto ann = ast.ann_type(fields.(ix).ty);\n+                    auto ann = ast.ann_type(fields.(ix).ty, none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2053,7 +2094,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     auto meth = methods.(ix);\n                     auto t = plain_ty(ty.ty_fn(meth.proto,\n                                                meth.inputs, meth.output));\n-                    auto ann = ast.ann_type(t);\n+                    auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2083,7 +2124,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                              \"non-integral type of vec index: \"\n                              + ty_to_str(idx_t));\n                     }\n-                    auto ann = ast.ann_type(t);\n+                    auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n                                                                idx_1,\n@@ -2097,7 +2138,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                              + ty_to_str(idx_t));\n                     }\n                     auto t = ty.ty_machine(common.ty_u8);\n-                    auto ann = ast.ann_type(plain_ty(t));\n+                    auto ann = ast.ann_type(plain_ty(t), none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n                                                                idx_1,\n@@ -2272,7 +2313,7 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n     auto fn_sty = ty.ty_fn(f.proto, inputs, output_ty);\n-    auto fn_ann = ast.ann_type(plain_ty(fn_sty));\n+    auto fn_ann = ast.ann_type(plain_ty(fn_sty), none[vec[@ty.t]]);\n \n     auto item = ast.item_fn(ident, f, ty_params, id, fn_ann);\n     ret @fold.respan[ast.item_](sp, item);"}]}