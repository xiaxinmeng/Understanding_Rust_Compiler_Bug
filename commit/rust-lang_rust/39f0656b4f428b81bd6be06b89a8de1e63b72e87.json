{"sha": "39f0656b4f428b81bd6be06b89a8de1e63b72e87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZjA2NTZiNGY0MjhiODFiZDZiZTA2Yjg5YThkZTFlNjNiNzJlODc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-03-29T10:46:55Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-31T14:41:40Z"}, "message": "Improve line comment positioning\n\nThis involved making ast.variant spanned.", "tree": {"sha": "212cc3c132a48f497f7243956bd0e2235cd6b00e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/212cc3c132a48f497f7243956bd0e2235cd6b00e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39f0656b4f428b81bd6be06b89a8de1e63b72e87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39f0656b4f428b81bd6be06b89a8de1e63b72e87", "html_url": "https://github.com/rust-lang/rust/commit/39f0656b4f428b81bd6be06b89a8de1e63b72e87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39f0656b4f428b81bd6be06b89a8de1e63b72e87/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a7ea941bb47326ea05431fa58c3d88d60e4a6d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a7ea941bb47326ea05431fa58c3d88d60e4a6d3", "html_url": "https://github.com/rust-lang/rust/commit/8a7ea941bb47326ea05431fa58c3d88d60e4a6d3"}], "stats": {"total": 190, "additions": 117, "deletions": 73}, "files": [{"sha": "fae9039205d0dd9c20a58b54d8b3938f1ce2282d", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=39f0656b4f428b81bd6be06b89a8de1e63b72e87", "patch": "@@ -385,7 +385,8 @@ type native_mod = rec(str native_name,\n type native_mod_index = hashmap[ident,native_mod_index_entry];\n \n type variant_arg = rec(@ty ty, def_id id);\n-type variant = rec(str name, vec[variant_arg] args, def_id id, ann ann);\n+type variant_ = rec(str name, vec[variant_arg] args, def_id id, ann ann);\n+type variant = spanned[variant_];\n \n type view_item = spanned[view_item_];\n tag view_item_ {\n@@ -451,7 +452,7 @@ fn index_item(mod_index index, @item it) {\n             index.insert(id, ast.mie_item(it));\n             let uint variant_idx = 0u;\n             for (ast.variant v in variants) {\n-                index.insert(v.name,\n+                index.insert(v.node.name,\n                              ast.mie_tag_variant(it, variant_idx));\n                 variant_idx += 1u;\n             }\n@@ -509,7 +510,7 @@ fn index_stmt(block_index index, @stmt s) {\n                             let uint vid = 0u;\n                             for (ast.variant v in variants) {\n                                 auto t = ast.bie_tag_variant(it, vid);\n-                                index.insert(v.name, t);\n+                                index.insert(v.node.name, t);\n                                 vid += 1u;\n                             }\n                         }"}, {"sha": "8562c56ae7a0004e1b13f6dd240057d2e903189f", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=39f0656b4f428b81bd6be06b89a8de1e63b72e87", "patch": "@@ -451,7 +451,9 @@ impure fn parse_ty(parser p) -> @ast.ty {\n         }\n \n         case (token.IDENT(_)) {\n-            t = ast.ty_path(parse_path(p, GREEDY), none[ast.def]);\n+            auto path = parse_path(p, GREEDY);\n+            t = ast.ty_path(path, none[ast.def]);\n+            hi = path.span;\n         }\n \n         case (token.MUTABLE) {\n@@ -2067,6 +2069,7 @@ impure fn parse_item_tag(parser p) -> @ast.item {\n         auto tok = p.peek();\n         alt (tok) {\n             case (token.IDENT(?name)) {\n+                auto vlo = p.get_span();\n                 p.bump();\n \n                 let vec[ast.variant_arg] args = vec();\n@@ -2084,11 +2087,12 @@ impure fn parse_item_tag(parser p) -> @ast.item {\n                     case (_) { /* empty */ }\n                 }\n \n+                auto vhi = p.get_span();\n                 expect(p, token.SEMI);\n \n                 auto id = p.next_def_id();\n-                variants += vec(rec(name=name, args=args, id=id,\n-                                    ann=ast.ann_none));\n+                auto vr = rec(name=name, args=args, id=id, ann=ast.ann_none);\n+                variants += vec(spanned[ast.variant_](vlo, vhi, vr));\n             }\n             case (token.RBRACE) { /* empty */ }\n             case (_) {"}, {"sha": "0b1a01ad6b42fa8aa47ea313f5dc682f5c102d84", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=39f0656b4f428b81bd6be06b89a8de1e63b72e87", "patch": "@@ -965,12 +965,13 @@ fn fold_item[ENV](&ENV env, ast_fold[ENV] fld, @item i) -> @item {\n             let vec[ast.variant] new_variants = vec();\n             for (ast.variant v in variants) {\n                 let vec[ast.variant_arg] new_args = vec();\n-                for (ast.variant_arg va in v.args) {\n+                for (ast.variant_arg va in v.node.args) {\n                     auto new_ty = fold_ty[ENV](env_, fld, va.ty);\n                     new_args += vec(rec(ty=new_ty, id=va.id));\n                 }\n-                new_variants += vec(rec(name=v.name, args=new_args, id=v.id,\n-                                        ann=v.ann));\n+                auto new_v = rec(name=v.node.name, args=new_args,\n+                                 id=v.node.id, ann=v.node.ann);\n+                new_variants += vec(respan[ast.variant_](v.span, new_v));\n             }\n             ret fld.fold_item_tag(env_, i.span, ident, new_variants,\n                                   ty_params, id);"}, {"sha": "f4854733a3642981717093baacf16be740fabcc4", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=39f0656b4f428b81bd6be06b89a8de1e63b72e87", "patch": "@@ -169,8 +169,8 @@ fn encode_def_id(&ebml.writer ebml_w, &ast.def_id id) {\n fn encode_tag_variant_paths(&ebml.writer ebml_w, vec[ast.variant] variants) {\n     for (ast.variant variant in variants) {\n         ebml.start_tag(ebml_w, tag_paths_item);\n-        encode_name(ebml_w, variant.name);\n-        encode_def_id(ebml_w, variant.id);\n+        encode_name(ebml_w, variant.node.name);\n+        encode_def_id(ebml_w, variant.node.id);\n         ebml.end_tag(ebml_w);\n     }\n }\n@@ -314,14 +314,14 @@ fn encode_tag_variant_info(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n                            ast.def_id did, vec[ast.variant] variants) {\n     for (ast.variant variant in variants) {\n         ebml.start_tag(ebml_w, tag_items_item);\n-        encode_def_id(ebml_w, variant.id);\n+        encode_def_id(ebml_w, variant.node.id);\n         encode_kind(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, did);\n-        encode_type(ebml_w, trans.node_ann_type(cx, variant.ann));\n-        if (_vec.len[ast.variant_arg](variant.args) > 0u) {\n-            encode_symbol(cx, ebml_w, variant.id);\n+        encode_type(ebml_w, trans.node_ann_type(cx, variant.node.ann));\n+        if (_vec.len[ast.variant_arg](variant.node.args) > 0u) {\n+            encode_symbol(cx, ebml_w, variant.node.id);\n         }\n-        encode_discriminant(cx, ebml_w, variant.id);\n+        encode_discriminant(cx, ebml_w, variant.node.id);\n         ebml.end_tag(ebml_w);\n     }\n }"}, {"sha": "39c4294d6bc58e5663eed91e313d3545d07c7cff", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=39f0656b4f428b81bd6be06b89a8de1e63b72e87", "patch": "@@ -389,7 +389,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n                     case (ast.mie_tag_variant(?item, ?variant_idx)) {\n                         alt (item.node) {\n                             case (ast.item_tag(_, ?variants, _, ?tid)) {\n-                                auto vid = variants.(variant_idx).id;\n+                                auto vid = variants.(variant_idx).node.id;\n                                 auto t = ast.def_variant(tid, vid);\n                                 ret some[def_wrap](def_wrap_other(t));\n                             }\n@@ -446,7 +446,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n     fn found_tag(@ast.item item, uint variant_idx) -> def_wrap {\n         alt (item.node) {\n             case (ast.item_tag(_, ?variants, _, ?tid)) {\n-                auto vid = variants.(variant_idx).id;\n+                auto vid = variants.(variant_idx).node.id;\n                 auto t = ast.def_variant(tid, vid);\n                 ret def_wrap_other(t);\n             }"}, {"sha": "2471d85ed99683301450ff05a7caf54ec40b6f2b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=39f0656b4f428b81bd6be06b89a8de1e63b72e87", "patch": "@@ -1355,7 +1355,7 @@ fn GEP_tag(@block_ctxt cx,\n \n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n     // Separately, store the type of the element we're interested in.\n-    auto arg_tys = arg_tys_of_fn(variant.ann);\n+    auto arg_tys = arg_tys_of_fn(variant.node.ann);\n     auto elem_ty = ty.plain_ty(ty.ty_nil);  // typestate infelicity\n     auto i = 0;\n     let vec[@ty.t] true_arg_tys = vec();\n@@ -1892,7 +1892,7 @@ fn decr_refcnt_and_if_zero(@block_ctxt cx,\n \n fn variant_types(@crate_ctxt cx, &ast.variant v) -> vec[@ty.t] {\n     let vec[@ty.t] tys = vec();\n-    alt (ty.ann_to_type(v.ann).struct) {\n+    alt (ty.ann_to_type(v.node.ann).struct) {\n         case (ty.ty_fn(_, ?args, _)) {\n             for (ty.arg arg in args) {\n                 tys += vec(arg.ty);\n@@ -1931,7 +1931,7 @@ fn tag_variant_with_id(@crate_ctxt cx,\n     auto i = 0u;\n     while (i < _vec.len[ast.variant](variants)) {\n         auto variant = variants.(i);\n-        if (common.def_eq(variant.id, variant_id)) {\n+        if (common.def_eq(variant.node.id, variant_id)) {\n             ret variant;\n         }\n         i += 1u;\n@@ -2074,22 +2074,22 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                                                      _uint.to_str(i, 10u));\n                 llvm.LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n \n-                if (_vec.len[ast.variant_arg](variant.args) > 0u) {\n+                if (_vec.len[ast.variant_arg](variant.node.args) > 0u) {\n                     // N-ary variant.\n-                    auto fn_ty = ty.ann_to_type(variants.(i).ann);\n+                    auto fn_ty = ty.ann_to_type(variants.(i).node.ann);\n                     alt (fn_ty.struct) {\n                         case (ty.ty_fn(_, ?args, _)) {\n                             auto j = 0;\n                             for (ty.arg a in args) {\n                                 auto v = vec(C_int(0), C_int(j as int));\n \n                                 auto rslt = GEP_tag(variant_cx, llunion_a_ptr,\n-                                    tid, variants.(i).id, tps, j);\n+                                    tid, variants.(i).node.id, tps, j);\n                                 auto llfldp_a = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n                                 rslt = GEP_tag(variant_cx, llunion_b_ptr, tid,\n-                                    variants.(i).id, tps, j);\n+                                    variants.(i).node.id, tps, j);\n                                 auto llfldp_b = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n@@ -3436,7 +3436,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n             auto variants = tag_variants(cx.fcx.ccx, vdef._0);\n             auto i = 0;\n             for (ast.variant v in variants) {\n-                auto this_variant_id = v.id;\n+                auto this_variant_id = v.node.id;\n                 if (variant_id._0 == this_variant_id._0 &&\n                     variant_id._1 == this_variant_id._1) {\n                     variant_tag = i;\n@@ -3698,9 +3698,9 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                         alt (tag_item.node) {\n                             case (ast.item_tag(_, ?variants, _, _)) {\n                                 for (ast.variant v in variants) {\n-                                    if (v.id == vid) {\n+                                    if (v.node.id == vid) {\n                                         fty = node_ann_type(cx.fcx.ccx,\n-                                                            v.ann);\n+                                                            v.node.ann);\n                                     }\n                                 }\n                             }\n@@ -5731,35 +5731,35 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n                      &ast.variant variant, int index,\n                      &vec[ast.ty_param] ty_params) {\n-    if (_vec.len[ast.variant_arg](variant.args) == 0u) {\n+    if (_vec.len[ast.variant_arg](variant.node.args) == 0u) {\n         ret;    // nullary constructors are just constants\n     }\n \n     // Translate variant arguments to function arguments.\n     let vec[ast.arg] fn_args = vec();\n     auto i = 0u;\n-    for (ast.variant_arg varg in variant.args) {\n+    for (ast.variant_arg varg in variant.node.args) {\n         fn_args += vec(rec(mode=ast.alias,\n                            ty=varg.ty,\n                            ident=\"arg\" + _uint.to_str(i, 10u),\n                            id=varg.id));\n     }\n \n-    check (cx.item_ids.contains_key(variant.id));\n-    let ValueRef llfndecl = cx.item_ids.get(variant.id);\n+    check (cx.item_ids.contains_key(variant.node.id));\n+    let ValueRef llfndecl = cx.item_ids.get(variant.node.id);\n \n     auto fcx = new_fn_ctxt(cx, llfndecl);\n \n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n-                              none[TypeRef], ret_ty_of_fn(variant.ann),\n+                              none[TypeRef], ret_ty_of_fn(variant.node.ann),\n                               fn_args, ty_params);\n \n     let vec[@ty.t] ty_param_substs = vec();\n     for (ast.ty_param tp in ty_params) {\n         ty_param_substs += vec(plain_ty(ty.ty_param(tp.id)));\n     }\n \n-    auto arg_tys = arg_tys_of_fn(variant.ann);\n+    auto arg_tys = arg_tys_of_fn(variant.node.ann);\n     copy_args_to_allocas(fcx, fn_args, arg_tys);\n \n     auto bcx = new_top_block_ctxt(fcx);\n@@ -5777,8 +5777,8 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n                                    vec(C_int(0), C_int(1)));\n \n     i = 0u;\n-    for (ast.variant_arg va in variant.args) {\n-        auto rslt = GEP_tag(bcx, llblobptr, tag_id, variant.id,\n+    for (ast.variant_arg va in variant.node.args) {\n+        auto rslt = GEP_tag(bcx, llblobptr, tag_id, variant.node.id,\n                             ty_param_substs, i as int);\n         bcx = rslt.bcx;\n         auto lldestptr = rslt.val;\n@@ -6182,9 +6182,10 @@ fn collect_tag_ctor(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n \n         case (ast.item_tag(_, ?variants, ?tps, _)) {\n             for (ast.variant variant in variants) {\n-                if (_vec.len[ast.variant_arg](variant.args) != 0u) {\n-                    decl_fn_and_pair(extend_path(cx, variant.name), \"tag\",\n-                                     tps, variant.ann, variant.id);\n+                if (_vec.len[ast.variant_arg](variant.node.args) != 0u) {\n+                    decl_fn_and_pair(extend_path(cx, variant.node.name),\n+                                     \"tag\", tps, variant.node.ann,\n+                                     variant.node.id);\n                 }\n             }\n         }\n@@ -6229,8 +6230,8 @@ fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n                 llvm.LLVMSetLinkage(discrim_gvar, lib.llvm.LLVMPrivateLinkage\n                                     as llvm.Linkage);\n \n-                cx.discrims.insert(variant.id, discrim_gvar);\n-                cx.discrim_symbols.insert(variant.id, s);\n+                cx.discrims.insert(variant.node.id, discrim_gvar);\n+                cx.discrim_symbols.insert(variant.node.id, s);\n \n                 i += 1u;\n             }"}, {"sha": "9ea1c44c750a8688b5c5d335781f980836b3ac4d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=39f0656b4f428b81bd6be06b89a8de1e63b72e87", "patch": "@@ -656,15 +656,15 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             // Nullary tag constructors get turned into constants; n-ary tag\n             // constructors get turned into functions.\n             auto result_ty;\n-            if (_vec.len[ast.variant_arg](variant.args) == 0u) {\n+            if (_vec.len[ast.variant_arg](variant.node.args) == 0u) {\n                 result_ty = plain_ty(ty.ty_tag(tag_id, ty_param_tys));\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n                 auto f = bind getter(sess, id_to_ty_item, type_cache, _);\n \n                 let vec[arg] args = vec();\n-                for (ast.variant_arg va in variant.args) {\n+                for (ast.variant_arg va in variant.node.args) {\n                     auto arg_ty = ast_ty_to_ty(f, va.ty);\n                     args += vec(rec(mode=ast.alias, ty=arg_ty));\n                 }\n@@ -673,13 +673,13 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             }\n \n             auto tpt = tup(params_opt, result_ty);\n-            type_cache.insert(variant.id, tpt);\n+            type_cache.insert(variant.node.id, tpt);\n \n             auto variant_t = rec(\n                 ann=ast.ann_type(result_ty, none[vec[@ty.t]])\n-                with variant\n+                with variant.node\n             );\n-            result += vec(variant_t);\n+            result += vec(fold.respan[ast.variant_](variant.span, variant_t));\n         }\n \n         ret result;"}, {"sha": "0007cfd5f9e32175309083ca9952712c6ffd30e2", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 64, "deletions": 27, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f0656b4f428b81bd6be06b89a8de1e63b72e87/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=39f0656b4f428b81bd6be06b89a8de1e63b72e87", "patch": "@@ -4,6 +4,7 @@ import std.io;\n import std.option;\n import front.ast;\n import front.lexer;\n+import util.common;\n import pp.end; import pp.wrd; import pp.space; import pp.line;\n \n const uint indent_unit = 4u;\n@@ -59,18 +60,37 @@ impure fn bclose(ps s) {\n     end(s.s);\n     pp.cwrd(s.s, \"}\");\n }\n-impure fn bclose_c(ps s, util.common.span span) {\n+impure fn bclose_c(ps s, common.span span) {\n     maybe_print_comment(s, span.hi);\n     bclose(s);\n }\n-impure fn commasep[IN](ps s, vec[IN] elts, impure fn (ps, &IN) op) {\n+impure fn commasep[IN](ps s, vec[IN] elts, impure fn(ps, &IN) op) {\n     auto first = true;\n     for (IN elt in elts) {\n         if (first) {first = false;}\n         else {wrd1(s, \",\");}\n         op(s, elt);\n     }\n }\n+impure fn commasep_cmnt[IN](ps s, vec[IN] elts, impure fn(ps, &IN) op,\n+                            fn(&IN) -> common.span get_span) {\n+    auto len = _vec.len[IN](elts);\n+    auto i = 0u;\n+    for (IN elt in elts) {\n+        op(s, elt);\n+        i += 1u;\n+        if (i < len) {\n+            wrd(s.s, \",\");\n+            if (!maybe_print_line_comment(s, get_span(elt))) {space(s.s);}\n+        }\n+    }\n+}\n+impure fn commasep_exprs(ps s, vec[@ast.expr] exprs) {\n+    fn expr_span(&@ast.expr expr) -> common.span {ret expr.span;}\n+    auto f = print_expr;\n+    auto gs = expr_span;\n+    commasep_cmnt[@ast.expr](s, exprs, f, gs);\n+}\n \n impure fn print_mod(ps s, ast._mod _mod) {\n     for (@ast.view_item vitem in _mod.view_items) {print_view_item(s, vitem);}\n@@ -87,7 +107,7 @@ impure fn print_type(ps s, &@ast.ty ty) {\n         case (ast.ty_bool) {wrd(s.s, \"bool\");}\n         case (ast.ty_int) {wrd(s.s, \"int\");}\n         case (ast.ty_uint) {wrd(s.s, \"uint\");}\n-        case (ast.ty_machine(?tm)) {wrd(s.s, util.common.ty_mach_to_str(tm));}\n+        case (ast.ty_machine(?tm)) {wrd(s.s, common.ty_mach_to_str(tm));}\n         case (ast.ty_char) {wrd(s.s, \"char\");}\n         case (ast.ty_str) {wrd(s.s, \"str\");}\n         case (ast.ty_box(?mt)) {wrd(s.s, \"@\"); print_mt(s, mt);}\n@@ -118,8 +138,16 @@ impure fn print_type(ps s, &@ast.ty ty) {\n                 wrd(s.s, f.ident);\n                 end(s.s);\n             }\n+            fn get_span(&ast.ty_field f) -> common.span {\n+              // Try to reconstruct the span for this field\n+              auto sp = f.mt.ty.span;\n+              auto hi = rec(line=sp.hi.line,\n+                            col=sp.hi.col + _str.char_len(f.ident) + 1u);\n+              ret rec(hi=hi with sp);\n+            }\n             auto f = print_field;\n-            commasep[ast.ty_field](s, fields, f);\n+            auto gs = get_span;\n+            commasep_cmnt[ast.ty_field](s, fields, f, gs);\n             pclose(s);\n         }\n         case (ast.ty_obj(?methods)) {\n@@ -219,18 +247,19 @@ impure fn print_item(ps s, @ast.item item) {\n             space(s.s);\n             bopen(s);\n             for (ast.variant v in variants) {\n-                wrd(s.s, v.name);\n-                if (_vec.len[ast.variant_arg](v.args) > 0u) {\n+                maybe_print_comment(s, v.span.lo);\n+                wrd(s.s, v.node.name);\n+                if (_vec.len[ast.variant_arg](v.node.args) > 0u) {\n                     popen(s);\n                     impure fn print_variant_arg(ps s, &ast.variant_arg arg) {\n                         print_type(s, arg.ty);\n                     }\n                     auto f = print_variant_arg;\n-                    commasep[ast.variant_arg](s, v.args, f);\n+                    commasep[ast.variant_arg](s, v.node.args, f);\n                     pclose(s);\n                 }\n                 wrd(s.s, \";\");\n-                line(s.s);\n+                if (!maybe_print_line_comment(s, v.span)) {line(s.s);}\n             }\n             bclose_c(s, item.span);\n         }\n@@ -246,8 +275,10 @@ impure fn print_item(ps s, @ast.item item) {\n                 wrd(s.s, field.ident);\n                 end(s.s);\n             }\n+            fn get_span(&ast.obj_field f) -> common.span {ret f.ty.span;}\n             auto f = print_field;\n-            commasep[ast.obj_field](s, _obj.fields, f);\n+            auto gs = get_span;\n+            commasep_cmnt[ast.obj_field](s, _obj.fields, f, gs);\n             pclose(s);\n             space(s.s);\n             bopen(s);\n@@ -284,25 +315,25 @@ impure fn print_block(ps s, ast.block blk) {\n     maybe_print_comment(s, blk.span.lo);\n     bopen(s);\n     for (@ast.stmt st in blk.node.stmts) {\n-        if (cur_line != 0u && blk.span.lo.line > cur_line + 1u) {\n+        if (cur_line != 0u && st.span.lo.line > cur_line + 1u) {\n             line(s.s);\n         }\n-        cur_line = blk.span.hi.line;\n+        cur_line = st.span.hi.line;\n         maybe_print_comment(s, st.span.lo);\n         alt (st.node) {\n             case (ast.stmt_decl(?decl)) {print_decl(s, decl);}\n             case (ast.stmt_expr(?expr)) {print_expr(s, expr);}\n         }\n         if (front.parser.stmt_ends_with_semi(st)) {wrd(s.s, \";\");}\n-        if (!maybe_print_stmt_comment(s, st.span)) {line(s.s);}\n+        if (!maybe_print_line_comment(s, st.span)) {line(s.s);}\n     }\n     alt (blk.node.expr) {\n         case (option.some[@ast.expr](?expr)) {\n-            if (cur_line != 0u && blk.span.lo.line > cur_line + 1u) {\n+            if (cur_line != 0u && expr.span.lo.line > cur_line + 1u) {\n                 line(s.s);\n             }\n             print_expr(s, expr);\n-            if (!maybe_print_stmt_comment(s, expr.span)) {line(s.s);}\n+            if (!maybe_print_line_comment(s, expr.span)) {line(s.s);}\n         }\n         case (_) {}\n     }\n@@ -318,17 +349,17 @@ impure fn print_literal(ps s, @ast.lit lit) {\n                 + \"'\");\n         }\n         case (ast.lit_int(?val)) {\n-            wrd(s.s, util.common.istr(val));\n+            wrd(s.s, common.istr(val));\n         }\n         case (ast.lit_uint(?val)) { // FIXME clipping? uistr?\n-            wrd(s.s, util.common.istr(val as int) + \"u\");\n+            wrd(s.s, common.istr(val as int) + \"u\");\n         }\n         case (ast.lit_float(?fstr)) {\n             wrd(s.s, fstr);\n         }\n         case (ast.lit_mach_int(?mach,?val)) {\n-            wrd(s.s, util.common.istr(val as int));\n-            wrd(s.s, util.common.ty_mach_to_str(mach));\n+            wrd(s.s, common.istr(val as int));\n+            wrd(s.s, common.ty_mach_to_str(mach));\n         }\n         case (ast.lit_nil) {wrd(s.s, \"()\");}\n         case (ast.lit_bool(?val)) {\n@@ -339,7 +370,6 @@ impure fn print_literal(ps s, @ast.lit lit) {\n \n impure fn print_expr(ps s, &@ast.expr expr) {\n     maybe_print_comment(s, expr.span.lo);\n-    auto pe = print_expr;\n     hbox(s);\n     alt (expr.node) {\n         case (ast.expr_vec(?exprs,?mut,_)) {\n@@ -348,7 +378,7 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n             }\n             wrd(s.s, \"vec\");\n             popen(s);\n-            commasep[@ast.expr](s, exprs, pe);\n+            commasep_exprs(s, exprs);\n             pclose(s);\n         }\n         case (ast.expr_tup(?exprs,_)) {\n@@ -358,10 +388,12 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n                 print_expr(s, elt.expr);\n                 end(s.s);\n             }\n+            fn get_span(&ast.elt elt) -> common.span {ret elt.expr.span;}\n             wrd(s.s, \"tup\");\n             popen(s);\n             auto f = printElt;\n-            commasep[ast.elt](s, exprs, f);\n+            auto gs = get_span;\n+            commasep_cmnt[ast.elt](s, exprs, f, gs);\n             pclose(s);\n         }\n         case (ast.expr_rec(?fields,?wth,_)) {\n@@ -373,10 +405,14 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n                 print_expr(s, field.expr);\n                 end(s.s);\n             }\n+            fn get_span(&ast.field field) -> common.span {\n+                ret field.expr.span;\n+            }\n             wrd(s.s, \"rec\");\n             popen(s);\n             auto f = print_field;\n-            commasep[ast.field](s, fields, f);\n+            auto gs = get_span;\n+            commasep_cmnt[ast.field](s, fields, f, gs);\n             alt (wth) {\n                 case (option.some[@ast.expr](?expr)) {\n                     if (_vec.len[ast.field](fields) > 0u) {space(s.s);}\n@@ -392,7 +428,7 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n         case (ast.expr_call(?func,?args,_)) {\n             print_expr(s, func);\n             popen(s);\n-            commasep[@ast.expr](s, args, pe);\n+            commasep_exprs(s, args);\n             pclose(s);\n         }\n         case (ast.expr_bind(?func,?args,_)) {\n@@ -598,7 +634,7 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n             print_path(s, path);\n             if (_vec.len[@ast.expr](args) > 0u) {\n                 popen(s);\n-                commasep[@ast.expr](s, args, pe);\n+                commasep_exprs(s, args);\n                 pclose(s);\n             }\n             // FIXME: extension 'body'\n@@ -891,7 +927,7 @@ fn next_comment(ps s) -> option.t[lexer.cmnt] {\n     }\n }\n \n-impure fn maybe_print_comment(ps s, util.common.pos pos) {\n+impure fn maybe_print_comment(ps s, common.pos pos) {\n     while (true) {\n         alt (next_comment(s)) {\n             case (option.some[lexer.cmnt](?cmnt)) {\n@@ -907,10 +943,11 @@ impure fn maybe_print_comment(ps s, util.common.pos pos) {\n     }\n }\n \n-impure fn maybe_print_stmt_comment(ps s, util.common.span span) -> bool {\n+impure fn maybe_print_line_comment(ps s, common.span span) -> bool {\n     alt (next_comment(s)) {\n         case (option.some[lexer.cmnt](?cmnt)) {\n-            if (span.hi.line == cmnt.pos.line) {\n+            if (span.hi.line == cmnt.pos.line &&\n+                span.hi.col + 4u >= cmnt.pos.col) {\n                 wrd(s.s, \" \");\n                 print_comment(s, cmnt.val);\n                 s.cur_cmnt += 1u;"}]}