{"sha": "e52fb6c96b96fdaba14f31ca583baebdec14366b", "node_id": "C_kwDOAAsO6NoAKGU1MmZiNmM5NmI5NmZkYWJhMTRmMzFjYTU4M2JhZWJkZWMxNDM2NmI", "commit": {"author": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2022-05-02T07:45:49Z"}, "committer": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2022-05-02T07:51:18Z"}, "message": "extract ProcOutput out of the function to make it testable", "tree": {"sha": "0cedfadeb6695c534d25f0e1cf7e9b69485462e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cedfadeb6695c534d25f0e1cf7e9b69485462e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e52fb6c96b96fdaba14f31ca583baebdec14366b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEMycKYjxLY0eb13b7zXazX3c0dp4FAmJvjXcACgkQzXazX3c0\ndp6Ndw/9H8vXBdA7NRndL2UHyaCl9uOZjsDL+nd0egrqRsiuw38z+vTZn6eXdksW\nGEaQD++Z0i6erFvRhaUAh80KRTtbwi/2jiPZ9mA5P+rfsmMgOPq25w4rMRTl2ciW\nqqaD+JyHSrefp3T5SR6YDNmlXfl5E9utA0j1B1t8oxUYcCiFca5eHOWQcubRxoIA\nzAabP3JgIC7Gy/Lz3+Go/VfiBpfNRgb7l/4by3UN61Zi/tGv8zG65f+hLjxoUNXK\nHslcDshyFSApdKtnszUK4050eBxEwwdvMVXw0HaNXukFnDKPPBC+AgCgJuTIj7+R\nVUS1vSNCScJOUj/4X8Y+2RUyAy+Hu1tUnizKE8nNAd8UorfU4mIdJSDNPBMGOSG0\ncjgXuBkrnR51C23SbhOxvP5QvyIca8ht4r6yDjVnczof2ZkM9xhijn43ZQSrk4r4\n3LLF5UjVX6l6cnOHIwbJo/xZxWR+05nE5BfO52A/S2XTqjcO0H9a4fMfsYHSeL+p\nLjUYeNhF7GYw2JWpalUXbnUGipZtK6I4Xc3TT72NVvKNzXRhcgZ+wZiMPBZrh5AH\nP5I+SQYJixOCey9cf9VjI5XA6j4qjSSH3sltSsgeBa4TKG9yth6oxGMI2G6RtBld\nRtd7ZyR1ydTw0ya+hNQpxlG/QijtlQMiExCU7tbra8JucxHwe3k=\n=Bksl\n-----END PGP SIGNATURE-----", "payload": "tree 0cedfadeb6695c534d25f0e1cf7e9b69485462e1\nparent b7473be6b1f0618127887d5b8a13830ea874f3c1\nauthor Pietro Albini <pietro.albini@ferrous-systems.com> 1651477549 +0200\ncommitter Pietro Albini <pietro.albini@ferrous-systems.com> 1651477878 +0200\n\nextract ProcOutput out of the function to make it testable\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e52fb6c96b96fdaba14f31ca583baebdec14366b", "html_url": "https://github.com/rust-lang/rust/commit/e52fb6c96b96fdaba14f31ca583baebdec14366b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e52fb6c96b96fdaba14f31ca583baebdec14366b/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7473be6b1f0618127887d5b8a13830ea874f3c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7473be6b1f0618127887d5b8a13830ea874f3c1", "html_url": "https://github.com/rust-lang/rust/commit/b7473be6b1f0618127887d5b8a13830ea874f3c1"}], "stats": {"total": 166, "additions": 84, "deletions": 82}, "files": [{"sha": "19c11a1e6b8f11e0ad0961f4ca69b4f4d9cc43d6", "filename": "src/tools/compiletest/src/read2.rs", "status": "modified", "additions": 84, "deletions": 82, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/e52fb6c96b96fdaba14f31ca583baebdec14366b/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e52fb6c96b96fdaba14f31ca583baebdec14366b/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs?ref=e52fb6c96b96fdaba14f31ca583baebdec14366b", "patch": "@@ -2,91 +2,13 @@\n // Consider unify the read2() in libstd, cargo and this to prevent further code duplication.\n \n pub use self::imp::read2;\n-use std::io;\n+use std::io::{self, Write};\n+use std::mem::replace;\n use std::process::{Child, Output};\n \n pub fn read2_abbreviated(mut child: Child, exclude_from_len: &[String]) -> io::Result<Output> {\n-    use io::Write;\n-    use std::mem::replace;\n-\n-    const HEAD_LEN: usize = 160 * 1024;\n-    const TAIL_LEN: usize = 256 * 1024;\n-    const EXCLUDED_PLACEHOLDER_LEN: isize = 32;\n-\n-    enum ProcOutput {\n-        Full { bytes: Vec<u8>, excluded_len: isize },\n-        Abbreviated { head: Vec<u8>, skipped: usize, tail: Box<[u8]> },\n-    }\n-\n-    impl ProcOutput {\n-        fn extend(&mut self, data: &[u8], exclude_from_len: &[String]) {\n-            let new_self = match *self {\n-                ProcOutput::Full { ref mut bytes, ref mut excluded_len } => {\n-                    let old_len = bytes.len();\n-                    bytes.extend_from_slice(data);\n-\n-                    // We had problems in the past with tests failing only in some environments,\n-                    // due to the length of the base path pushing the output size over the limit.\n-                    //\n-                    // To make those failures deterministic across all environments we ignore known\n-                    // paths when calculating the string length, while still including the full\n-                    // path in the output. This could result in some output being larger than the\n-                    // threshold, but it's better than having nondeterministic failures.\n-                    //\n-                    // The compiler emitting only excluded strings is addressed by adding a\n-                    // placeholder size for each excluded segment, which will eventually reach\n-                    // the configured threshold.\n-                    for pattern in exclude_from_len {\n-                        let pattern_bytes = pattern.as_bytes();\n-                        // We start matching `pattern_bytes - 1` into the previously loaded data,\n-                        // to account for the fact a pattern might be included across multiple\n-                        // `extend` calls. Starting from `- 1` avoids double-counting patterns.\n-                        let matches = (&bytes[(old_len.saturating_sub(pattern_bytes.len() - 1))..])\n-                            .windows(pattern_bytes.len())\n-                            .filter(|window| window == &pattern_bytes)\n-                            .count();\n-                        *excluded_len += matches as isize\n-                            * (EXCLUDED_PLACEHOLDER_LEN - pattern_bytes.len() as isize);\n-                    }\n-\n-                    let new_len = bytes.len();\n-                    if (new_len as isize + *excluded_len) as usize <= HEAD_LEN + TAIL_LEN {\n-                        return;\n-                    }\n-\n-                    let mut head = replace(bytes, Vec::new());\n-                    let tail = head.split_off(new_len - TAIL_LEN).into_boxed_slice();\n-                    let skipped = new_len - HEAD_LEN - TAIL_LEN;\n-                    ProcOutput::Abbreviated { head, skipped, tail }\n-                }\n-                ProcOutput::Abbreviated { ref mut skipped, ref mut tail, .. } => {\n-                    *skipped += data.len();\n-                    if data.len() <= TAIL_LEN {\n-                        tail[..data.len()].copy_from_slice(data);\n-                        tail.rotate_left(data.len());\n-                    } else {\n-                        tail.copy_from_slice(&data[(data.len() - TAIL_LEN)..]);\n-                    }\n-                    return;\n-                }\n-            };\n-            *self = new_self;\n-        }\n-\n-        fn into_bytes(self) -> Vec<u8> {\n-            match self {\n-                ProcOutput::Full { bytes, .. } => bytes,\n-                ProcOutput::Abbreviated { mut head, skipped, tail } => {\n-                    write!(&mut head, \"\\n\\n<<<<<< SKIPPED {} BYTES >>>>>>\\n\\n\", skipped).unwrap();\n-                    head.extend_from_slice(&tail);\n-                    head\n-                }\n-            }\n-        }\n-    }\n-\n-    let mut stdout = ProcOutput::Full { bytes: Vec::new(), excluded_len: 0 };\n-    let mut stderr = ProcOutput::Full { bytes: Vec::new(), excluded_len: 0 };\n+    let mut stdout = ProcOutput::new();\n+    let mut stderr = ProcOutput::new();\n \n     drop(child.stdin.take());\n     read2(\n@@ -102,6 +24,86 @@ pub fn read2_abbreviated(mut child: Child, exclude_from_len: &[String]) -> io::R\n     Ok(Output { status, stdout: stdout.into_bytes(), stderr: stderr.into_bytes() })\n }\n \n+const HEAD_LEN: usize = 160 * 1024;\n+const TAIL_LEN: usize = 256 * 1024;\n+const EXCLUDED_PLACEHOLDER_LEN: isize = 32;\n+\n+enum ProcOutput {\n+    Full { bytes: Vec<u8>, excluded_len: isize },\n+    Abbreviated { head: Vec<u8>, skipped: usize, tail: Box<[u8]> },\n+}\n+\n+impl ProcOutput {\n+    fn new() -> Self {\n+        ProcOutput::Full { bytes: Vec::new(), excluded_len: 0 }\n+    }\n+\n+    fn extend(&mut self, data: &[u8], exclude_from_len: &[String]) {\n+        let new_self = match *self {\n+            ProcOutput::Full { ref mut bytes, ref mut excluded_len } => {\n+                let old_len = bytes.len();\n+                bytes.extend_from_slice(data);\n+\n+                // We had problems in the past with tests failing only in some environments,\n+                // due to the length of the base path pushing the output size over the limit.\n+                //\n+                // To make those failures deterministic across all environments we ignore known\n+                // paths when calculating the string length, while still including the full\n+                // path in the output. This could result in some output being larger than the\n+                // threshold, but it's better than having nondeterministic failures.\n+                //\n+                // The compiler emitting only excluded strings is addressed by adding a\n+                // placeholder size for each excluded segment, which will eventually reach\n+                // the configured threshold.\n+                for pattern in exclude_from_len {\n+                    let pattern_bytes = pattern.as_bytes();\n+                    // We start matching `pattern_bytes - 1` into the previously loaded data,\n+                    // to account for the fact a pattern might be included across multiple\n+                    // `extend` calls. Starting from `- 1` avoids double-counting patterns.\n+                    let matches = (&bytes[(old_len.saturating_sub(pattern_bytes.len() - 1))..])\n+                        .windows(pattern_bytes.len())\n+                        .filter(|window| window == &pattern_bytes)\n+                        .count();\n+                    *excluded_len += matches as isize\n+                        * (EXCLUDED_PLACEHOLDER_LEN - pattern_bytes.len() as isize);\n+                }\n+\n+                let new_len = bytes.len();\n+                if (new_len as isize + *excluded_len) as usize <= HEAD_LEN + TAIL_LEN {\n+                    return;\n+                }\n+\n+                let mut head = replace(bytes, Vec::new());\n+                let tail = head.split_off(new_len - TAIL_LEN).into_boxed_slice();\n+                let skipped = new_len - HEAD_LEN - TAIL_LEN;\n+                ProcOutput::Abbreviated { head, skipped, tail }\n+            }\n+            ProcOutput::Abbreviated { ref mut skipped, ref mut tail, .. } => {\n+                *skipped += data.len();\n+                if data.len() <= TAIL_LEN {\n+                    tail[..data.len()].copy_from_slice(data);\n+                    tail.rotate_left(data.len());\n+                } else {\n+                    tail.copy_from_slice(&data[(data.len() - TAIL_LEN)..]);\n+                }\n+                return;\n+            }\n+        };\n+        *self = new_self;\n+    }\n+\n+    fn into_bytes(self) -> Vec<u8> {\n+        match self {\n+            ProcOutput::Full { bytes, .. } => bytes,\n+            ProcOutput::Abbreviated { mut head, skipped, tail } => {\n+                write!(&mut head, \"\\n\\n<<<<<< SKIPPED {} BYTES >>>>>>\\n\\n\", skipped).unwrap();\n+                head.extend_from_slice(&tail);\n+                head\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(not(any(unix, windows)))]\n mod imp {\n     use std::io::{self, Read};"}]}