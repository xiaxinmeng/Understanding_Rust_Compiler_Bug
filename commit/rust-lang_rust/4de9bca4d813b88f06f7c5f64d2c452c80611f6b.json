{"sha": "4de9bca4d813b88f06f7c5f64d2c452c80611f6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkZTliY2E0ZDgxM2I4OGYwNmY3YzVmNjRkMmM0NTJjODA2MTFmNmI=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-26T09:48:49Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-26T11:30:46Z"}, "message": "std::str: Tune CharSplitIterator after benchmarks\n\nImplement Huon Wilson's suggestions (since the benchmarks agree!).\n\nUse `self.sep.matches(byte as char) && byte < 128u8` to match in the\nonly_ascii case so that mistaken matches outside the ascii range can't\ncreate invalid substrings.\n\nPut the conditional on only_ascii outside the loop.", "tree": {"sha": "44abd3b4ce1069795e8fa108390e185c6567bd7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44abd3b4ce1069795e8fa108390e185c6567bd7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4de9bca4d813b88f06f7c5f64d2c452c80611f6b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4de9bca4d813b88f06f7c5f64d2c452c80611f6b", "html_url": "https://github.com/rust-lang/rust/commit/4de9bca4d813b88f06f7c5f64d2c452c80611f6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4de9bca4d813b88f06f7c5f64d2c452c80611f6b/comments", "author": null, "committer": null, "parents": [{"sha": "413f868220e0ccd5fcc728be5ebde1f8e4eabf19", "url": "https://api.github.com/repos/rust-lang/rust/commits/413f868220e0ccd5fcc728be5ebde1f8e4eabf19", "html_url": "https://github.com/rust-lang/rust/commit/413f868220e0ccd5fcc728be5ebde1f8e4eabf19"}], "stats": {"total": 99, "additions": 44, "deletions": 55}, "files": [{"sha": "431ce7fb6fe35a82103242dacaf17dd273c6cf58", "filename": "src/libstd/str.rs", "status": "modified", "additions": 44, "deletions": 55, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/4de9bca4d813b88f06f7c5f64d2c452c80611f6b/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de9bca4d813b88f06f7c5f64d2c452c80611f6b/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=4de9bca4d813b88f06f7c5f64d2c452c80611f6b", "patch": "@@ -21,7 +21,6 @@ use char;\n use char::Char;\n use clone::{Clone, DeepClone};\n use container::{Container, Mutable};\n-use either::{Left, Right};\n use iter::Times;\n use iterator::{Iterator, FromIterator, Extendable};\n use iterator::{Filter, AdditiveIterator, Map};\n@@ -411,36 +410,30 @@ impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitIterator<'self, Sep>\n     fn next(&mut self) -> Option<&'self str> {\n         if self.finished { return None }\n \n-        let len = self.string.len();\n-        let mut iter = match self.only_ascii {\n-            true => Left(self.string.byte_iter().enumerate()),\n-            false => Right(self.string.char_offset_iter())\n-        };\n-\n-        loop {\n-            let (idx, next) = match iter {\n-                // this gives a *huge* speed up for splitting on ASCII\n-                // characters (e.g. '\\n' or ' ')\n-                Left(ref mut it) => match it.next() {\n-                    Some((idx, byte)) if byte < 128u8 && self.sep.matches(byte as char) =>\n-                        (idx, idx + 1),\n-                    Some(*) => loop,\n-                    None => break,\n-                },\n-                Right(ref mut it) => match it.next() {\n-                    Some((idx, ch)) if self.sep.matches(ch) =>\n-                        (idx, self.string.char_range_at(idx).next),\n-                    Some(*) => loop,\n-                    None => break,\n+        let mut next_split = None;\n+        if self.only_ascii {\n+            for (idx, byte) in self.string.byte_iter().enumerate() {\n+                if self.sep.matches(byte as char) && byte < 128u8 {\n+                    next_split = Some((idx, idx + 1));\n+                    break;\n                 }\n-            };\n-            unsafe {\n-                let elt = raw::slice_bytes(self.string, 0, idx);\n-                self.string = raw::slice_bytes(self.string, next, len);\n-                return Some(elt)\n             }\n+        } else {\n+            for (idx, ch) in self.string.char_offset_iter() {\n+                if self.sep.matches(ch) {\n+                    next_split = Some((idx, self.string.char_range_at(idx).next));\n+                    break;\n+                }\n+            }\n+        }\n+        match next_split {\n+            Some((a, b)) => unsafe {\n+                let elt = raw::slice_unchecked(self.string, 0, a);\n+                self.string = raw::slice_unchecked(self.string, b, self.string.len());\n+                Some(elt)\n+            },\n+            None => self.get_end(),\n         }\n-        self.get_end()\n     }\n }\n \n@@ -458,36 +451,32 @@ for CharSplitIterator<'self, Sep> {\n             }\n         }\n         let len = self.string.len();\n-        let mut iter = match self.only_ascii {\n-            true => Left(self.string.byte_rev_iter().enumerate()),\n-            false => Right(self.string.char_offset_iter())\n-        };\n-\n-        loop {\n-            let (idx, next) = match iter {\n-                Left(ref mut it) => match it.next() {\n-                    Some((j, byte)) if byte < 128u8 && self.sep.matches(byte as char) => {\n-                        let idx = self.string.len() - j - 1;\n-                        (idx, idx + 1)\n-                    },\n-                    Some(*) => loop,\n-                    None => break,\n-                },\n-                Right(ref mut it) => match it.next_back() {\n-                    Some((idx, ch)) if self.sep.matches(ch) =>\n-                        (idx, self.string.char_range_at(idx).next),\n-                    Some(*) => loop,\n-                    None => break,\n+        let mut next_split = None;\n+\n+        if self.only_ascii {\n+            for (j, byte) in self.string.byte_rev_iter().enumerate() {\n+                if self.sep.matches(byte as char) && byte < 128u8 {\n+                    let idx = len - j - 1;\n+                    next_split = Some((idx, idx + 1));\n+                    break;\n                 }\n-            };\n-            unsafe {\n-                let elt = raw::slice_bytes(self.string, next, len);\n-                self.string = raw::slice_bytes(self.string, 0, idx);\n-                return Some(elt)\n             }\n+        } else {\n+            for (idx, ch) in self.string.char_offset_rev_iter() {\n+                if self.sep.matches(ch) {\n+                    next_split = Some((idx, self.string.char_range_at(idx).next));\n+                    break;\n+                }\n+            }\n+        }\n+        match next_split {\n+            Some((a, b)) => unsafe {\n+                let elt = raw::slice_unchecked(self.string, b, len);\n+                self.string = raw::slice_unchecked(self.string, 0, a);\n+                Some(elt)\n+            },\n+            None => { self.finished = true; Some(self.string) }\n         }\n-        self.finished = true;\n-        Some(self.string)\n     }\n }\n "}]}