{"sha": "0c4062175994d28120da4aa7518e3e10b19e2db3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNDA2MjE3NTk5NGQyODEyMGRhNGFhNzUxOGUzZTEwYjE5ZTJkYjM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-01-31T00:38:45Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-03T23:39:14Z"}, "message": "Refactor away resolve_module_in_lexical_scope", "tree": {"sha": "79803ca17c57f40a545f7c5a080cced5699a7630", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79803ca17c57f40a545f7c5a080cced5699a7630"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c4062175994d28120da4aa7518e3e10b19e2db3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c4062175994d28120da4aa7518e3e10b19e2db3", "html_url": "https://github.com/rust-lang/rust/commit/0c4062175994d28120da4aa7518e3e10b19e2db3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c4062175994d28120da4aa7518e3e10b19e2db3/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23bdbb13f4087751d7310ae896ccd3e1ae690abb", "url": "https://api.github.com/repos/rust-lang/rust/commits/23bdbb13f4087751d7310ae896ccd3e1ae690abb", "html_url": "https://github.com/rust-lang/rust/commit/23bdbb13f4087751d7310ae896ccd3e1ae690abb"}], "stats": {"total": 45, "additions": 11, "deletions": 34}, "files": [{"sha": "761365122effa676420895c6069c6178e03074b4", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 11, "deletions": 34, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0c4062175994d28120da4aa7518e3e10b19e2db3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c4062175994d28120da4aa7518e3e10b19e2db3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0c4062175994d28120da4aa7518e3e10b19e2db3", "patch": "@@ -1387,16 +1387,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        match self.resolve_module_in_lexical_scope(module_, module_path[0]) {\n+                        match self.resolve_item_in_lexical_scope(module_,\n+                                                                 module_path[0],\n+                                                                 TypeNS,\n+                                                                 true) {\n                             Failed(err) => return Failed(err),\n                             Indeterminate => {\n                                 debug!(\"(resolving module path for import) indeterminate; bailing\");\n                                 return Indeterminate;\n                             }\n-                            Success(containing_module) => {\n-                                search_module = containing_module;\n-                                start_index = 1;\n-                                last_private = LastMod(AllPublic);\n+                            Success((target, _)) => match target.binding.module() {\n+                                Some(containing_module) => {\n+                                    search_module = containing_module;\n+                                    start_index = 1;\n+                                    last_private = LastMod(AllPublic);\n+                                }\n+                                None => return Failed(None),\n                             }\n                         }\n                     }\n@@ -1477,35 +1483,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    /// Resolves a module name in the current lexical scope.\n-    fn resolve_module_in_lexical_scope(&mut self,\n-                                       module_: Module<'a>,\n-                                       name: Name)\n-                                       -> ResolveResult<Module<'a>> {\n-        // If this module is an anonymous module, resolve the item in the\n-        // lexical scope. Otherwise, resolve the item from the crate root.\n-        let resolve_result = self.resolve_item_in_lexical_scope(module_, name, TypeNS, true);\n-        match resolve_result {\n-            Success((target, _)) => {\n-                if let Some(module_def) = target.binding.module() {\n-                    return Success(module_def)\n-                } else {\n-                    debug!(\"!!! (resolving module in lexical scope) module \\\n-                            wasn't actually a module!\");\n-                    return Failed(None);\n-                }\n-            }\n-            Indeterminate => {\n-                debug!(\"(resolving module in lexical scope) indeterminate; bailing\");\n-                return Indeterminate;\n-            }\n-            Failed(err) => {\n-                debug!(\"(resolving module in lexical scope) failed to resolve\");\n-                return Failed(err);\n-            }\n-        }\n-    }\n-\n     /// Returns the nearest normal module parent of the given module.\n     fn get_nearest_normal_module_parent(&mut self, module_: Module<'a>) -> Option<Module<'a>> {\n         let mut module_ = module_;"}]}