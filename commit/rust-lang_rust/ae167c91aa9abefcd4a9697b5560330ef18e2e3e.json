{"sha": "ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMTY3YzkxYWE5YWJlZmNkNGE5Njk3YjU1NjAzMzBlZjE4ZTJlM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-04T14:21:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-04T14:21:19Z"}, "message": "Auto merge of #56074 - matthewjasper:forbid-recursive-impl-trait, r=nikomatsakis\n\nForbid recursive impl trait\n\nThere is no type T, such that `T = [T; 2]`, but impl Trait could sometimes\nbe to circumvented this.\n\nThis patch makes it a hard error for an opaque type to resolve to such a\n\"type\". Before this can be merged it needs\n\n- [x] A better error message - it's good enough for now.\n- [x] A crater run (?) to see if this any real-world code\n\ncloses #47659", "tree": {"sha": "8ad1bd3c76a46b262b7a7ebbe666e1161a6fa173", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ad1bd3c76a46b262b7a7ebbe666e1161a6fa173"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "html_url": "https://github.com/rust-lang/rust/commit/ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4", "html_url": "https://github.com/rust-lang/rust/commit/a602f13f02acc17eda0d7f2c2d9adeabbdb59cf4"}, {"sha": "65c1f54a06293b2a1345c69d0b5d88d1343e3b5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/65c1f54a06293b2a1345c69d0b5d88d1343e3b5b", "html_url": "https://github.com/rust-lang/rust/commit/65c1f54a06293b2a1345c69d0b5d88d1343e3b5b"}], "stats": {"total": 353, "additions": 342, "deletions": 11}, "files": [{"sha": "e989ef823e979ea9c1bd09ef049ef9f49b1fb8c6", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "patch": "@@ -7,15 +7,15 @@ use hir::{self, Node};\n use ich::NodeIdHashingMode;\n use traits::{self, ObligationCause};\n use ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n-use ty::subst::{Substs, UnpackedKind};\n+use ty::subst::{Subst, Substs, UnpackedKind};\n use ty::query::TyCtxtAt;\n use ty::TyKind::*;\n use ty::layout::{Integer, IntegerExt};\n use util::common::ErrorReported;\n use middle::lang_items;\n \n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::{cmp, fmt};\n use syntax::ast;\n use syntax::attr::{self, SignedInt, UnsignedInt};\n@@ -618,6 +618,76 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    /// Expands the given impl trait type, stopping if the type is recursive.\n+    pub fn try_expand_impl_trait_type(\n+        self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+    ) -> Result<Ty<'tcx>, Ty<'tcx>> {\n+        use crate::ty::fold::TypeFolder;\n+\n+        struct OpaqueTypeExpander<'a, 'gcx, 'tcx> {\n+            // Contains the DefIds of the opaque types that are currently being\n+            // expanded. When we expand an opaque type we insert the DefId of\n+            // that type, and when we finish expanding that type we remove the\n+            // its DefId.\n+            seen_opaque_tys: FxHashSet<DefId>,\n+            primary_def_id: DefId,\n+            found_recursion: bool,\n+            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        }\n+\n+        impl<'a, 'gcx, 'tcx> OpaqueTypeExpander<'a, 'gcx, 'tcx> {\n+            fn expand_opaque_ty(\n+                &mut self,\n+                def_id: DefId,\n+                substs: &'tcx Substs<'tcx>,\n+            ) -> Option<Ty<'tcx>> {\n+                if self.found_recursion {\n+                    None\n+                } else if self.seen_opaque_tys.insert(def_id) {\n+                    let generic_ty = self.tcx.type_of(def_id);\n+                    let concrete_ty = generic_ty.subst(self.tcx, substs);\n+                    let expanded_ty = self.fold_ty(concrete_ty);\n+                    self.seen_opaque_tys.remove(&def_id);\n+                    Some(expanded_ty)\n+                } else {\n+                    // If another opaque type that we contain is recursive, then it\n+                    // will report the error, so we don't have to.\n+                    self.found_recursion = def_id == self.primary_def_id;\n+                    None\n+                }\n+            }\n+        }\n+\n+        impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpaqueTypeExpander<'a, 'gcx, 'tcx> {\n+            fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+                self.tcx\n+            }\n+\n+            fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+                if let ty::Opaque(def_id, substs) = t.sty {\n+                    self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n+                } else {\n+                    t.super_fold_with(self)\n+                }\n+            }\n+        }\n+\n+        let mut visitor = OpaqueTypeExpander {\n+            seen_opaque_tys: FxHashSet::default(),\n+            primary_def_id: def_id,\n+            found_recursion: false,\n+            tcx: self,\n+        };\n+        let expanded_type = visitor.expand_opaque_ty(def_id, substs).unwrap();\n+        if visitor.found_recursion {\n+            Err(expanded_type)\n+        } else {\n+            Ok(expanded_type)\n+        }\n+    }\n }\n \n impl<'a, 'tcx> ty::TyS<'tcx> {"}, {"sha": "34fea495aa64beb3d364dd1f3c819969ec21e9fc", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "patch": "@@ -1325,6 +1325,8 @@ define_print! {\n                         }\n                         if !is_sized {\n                             write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n+                        } else if first {\n+                            write!(f, \" Sized\")?;\n                         }\n                         Ok(())\n                     })"}, {"sha": "8262c3067969370446a3d513a6942a45b459f0d9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "patch": "@@ -1305,6 +1305,27 @@ fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_packed(tcx, span, def_id);\n }\n \n+fn check_opaque<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>,\n+    span: Span,\n+) {\n+    if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id, substs) {\n+        let mut err = struct_span_err!(\n+            tcx.sess, span, E0720,\n+            \"opaque type expands to a recursive type\",\n+        );\n+        err.span_label(span, \"expands to self-referential type\");\n+        if let ty::Opaque(..) = partially_expanded_type.sty {\n+            err.note(\"type resolves to itself\");\n+        } else {\n+            err.note(&format!(\"expanded type is `{}`\", partially_expanded_type));\n+        }\n+        err.emit();\n+    }\n+}\n+\n pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item) {\n     debug!(\n         \"check_item_type(it.id={}, it.name={})\",\n@@ -1351,7 +1372,16 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n         hir::ItemKind::Union(..) => {\n             check_union(tcx, it.id, it.span);\n         }\n-        hir::ItemKind::Existential(..) | hir::ItemKind::Ty(..) => {\n+        hir::ItemKind::Existential(..) => {\n+            let def_id = tcx.hir().local_def_id(it.id);\n+            let pty_ty = tcx.type_of(def_id);\n+            let generics = tcx.generics_of(def_id);\n+\n+            check_bounds_are_used(tcx, &generics, pty_ty);\n+            let substs = Substs::identity_for_item(tcx, def_id);\n+            check_opaque(tcx, def_id, substs, it.span);\n+        }\n+        hir::ItemKind::Ty(..) => {\n             let def_id = tcx.hir().local_def_id(it.id);\n             let pty_ty = tcx.type_of(def_id);\n             let generics = tcx.generics_of(def_id);"}, {"sha": "387dabe747ab881ebc511adaed0b5272b838cf29", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "patch": "@@ -4816,6 +4816,21 @@ type, it's not allowed to override anything in those implementations, as it\n would be ambiguous which override should actually be used.\n \"##,\n \n+\n+E0720: r##\"\n+An `impl Trait` type expands to a recursive type.\n+\n+An `impl Trait` type must be expandable to a concrete type that contains no\n+`impl Trait` types. For example the following example tries to create an\n+`impl Trait` type `T` that is equal to `[T, T]`:\n+\n+```compile_fail,E0720\n+fn make_recursive_type() -> impl Sized {\n+    [make_recursive_type(), make_recursive_type()]\n+}\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "150a8015cbc756190e7c25e9799cf166327e5c3c", "filename": "src/test/ui/impl-trait/infinite-impl-trait-issue-38064.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Ftest%2Fui%2Fimpl-trait%2Finfinite-impl-trait-issue-38064.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Ftest%2Fui%2Fimpl-trait%2Finfinite-impl-trait-issue-38064.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Finfinite-impl-trait-issue-38064.rs?ref=ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "patch": "@@ -3,17 +3,15 @@\n //\n // Regression test for #38064.\n \n-// error-pattern:overflow evaluating the requirement `impl Quux`\n-\n trait Quux {}\n \n-fn foo() -> impl Quux {\n+fn foo() -> impl Quux { //~ opaque type expands to a recursive type\n     struct Foo<T>(T);\n     impl<T> Quux for Foo<T> {}\n     Foo(bar())\n }\n \n-fn bar() -> impl Quux {\n+fn bar() -> impl Quux { //~ opaque type expands to a recursive type\n     struct Bar<T>(T);\n     impl<T> Quux for Bar<T> {}\n     Bar(foo())"}, {"sha": "99c8fe35c66d0ffb04bd3f70bf8198d0a86eec9a", "filename": "src/test/ui/impl-trait/infinite-impl-trait-issue-38064.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Ftest%2Fui%2Fimpl-trait%2Finfinite-impl-trait-issue-38064.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Ftest%2Fui%2Fimpl-trait%2Finfinite-impl-trait-issue-38064.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Finfinite-impl-trait-issue-38064.stderr?ref=ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "patch": "@@ -1,7 +1,19 @@\n-error[E0275]: overflow evaluating the requirement `impl Quux`\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/infinite-impl-trait-issue-38064.rs:8:13\n    |\n-   = help: consider adding a `#![recursion_limit=\"128\"]` attribute to your crate\n+LL | fn foo() -> impl Quux { //~ opaque type expands to a recursive type\n+   |             ^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `foo::Foo<bar::Bar<impl Quux>>`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/infinite-impl-trait-issue-38064.rs:14:13\n+   |\n+LL | fn bar() -> impl Quux { //~ opaque type expands to a recursive type\n+   |             ^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `bar::Bar<foo::Foo<impl Quux>>`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0275`.\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "facb191a37081f64e33add598c99d11cf0e1029b", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type.rs?ref=ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "patch": "@@ -0,0 +1,81 @@\n+// Test that impl trait does not allow creating recursive types that are\n+// otherwise forbidden.\n+\n+#![feature(await_macro, async_await, futures_api, generators)]\n+\n+fn option(i: i32) -> impl Sized { //~ ERROR\n+    if i < 0 {\n+        None\n+    } else {\n+        Some((option(i - 1), i))\n+    }\n+}\n+\n+fn tuple() -> impl Sized { //~ ERROR\n+    (tuple(),)\n+}\n+\n+fn array() -> impl Sized { //~ ERROR\n+    [array()]\n+}\n+\n+fn ptr() -> impl Sized { //~ ERROR\n+    &ptr() as *const _\n+}\n+\n+fn fn_ptr() -> impl Sized { //~ ERROR\n+    fn_ptr as fn() -> _\n+}\n+\n+fn closure_capture() -> impl Sized { //~ ERROR\n+    let x = closure_capture();\n+    move || { x; }\n+}\n+\n+fn closure_ref_capture() -> impl Sized { //~ ERROR\n+    let x = closure_ref_capture();\n+    move || { &x; }\n+}\n+\n+fn closure_sig() -> impl Sized { //~ ERROR\n+    || closure_sig()\n+}\n+\n+fn generator_sig() -> impl Sized { //~ ERROR\n+    || generator_sig()\n+}\n+\n+fn generator_capture() -> impl Sized { //~ ERROR\n+    let x = generator_capture();\n+    move || { yield; x; }\n+}\n+\n+fn substs_change<T>() -> impl Sized { //~ ERROR\n+    (substs_change::<&T>(),)\n+}\n+\n+fn generator_hold() -> impl Sized { //~ ERROR\n+    move || {\n+        let x = generator_hold();\n+        yield;\n+        x;\n+    }\n+}\n+\n+async fn recursive_async_function() -> () { //~ ERROR\n+    await!(recursive_async_function());\n+}\n+\n+fn use_fn_ptr() -> impl Sized { // OK, error already reported\n+    fn_ptr()\n+}\n+\n+fn mutual_recursion() -> impl Sync { //~ ERROR\n+    mutual_recursion_b()\n+}\n+\n+fn mutual_recursion_b() -> impl Sized { //~ ERROR\n+    mutual_recursion()\n+}\n+\n+fn main() {}"}, {"sha": "8a8789120577e72a681b3d57d7bf3a0e18b1d858", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type.stderr", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae167c91aa9abefcd4a9697b5560330ef18e2e3e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type.stderr?ref=ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "patch": "@@ -0,0 +1,123 @@\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:6:22\n+   |\n+LL | fn option(i: i32) -> impl Sized { //~ ERROR\n+   |                      ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `std::option::Option<(impl Sized, i32)>`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:14:15\n+   |\n+LL | fn tuple() -> impl Sized { //~ ERROR\n+   |               ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `(impl Sized,)`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:18:15\n+   |\n+LL | fn array() -> impl Sized { //~ ERROR\n+   |               ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `[impl Sized; 1]`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:22:13\n+   |\n+LL | fn ptr() -> impl Sized { //~ ERROR\n+   |             ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `*const impl Sized`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:26:16\n+   |\n+LL | fn fn_ptr() -> impl Sized { //~ ERROR\n+   |                ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `fn() -> impl Sized`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:30:25\n+   |\n+LL | fn closure_capture() -> impl Sized { //~ ERROR\n+   |                         ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type.rs:32:5: 32:19 x:impl Sized]`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:35:29\n+   |\n+LL | fn closure_ref_capture() -> impl Sized { //~ ERROR\n+   |                             ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type.rs:37:5: 37:20 x:impl Sized]`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:40:21\n+   |\n+LL | fn closure_sig() -> impl Sized { //~ ERROR\n+   |                     ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type.rs:41:5: 41:21]`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:44:23\n+   |\n+LL | fn generator_sig() -> impl Sized { //~ ERROR\n+   |                       ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type.rs:45:5: 45:23]`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:48:27\n+   |\n+LL | fn generator_capture() -> impl Sized { //~ ERROR\n+   |                           ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type.rs:50:5: 50:26 x:impl Sized {()}]`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:53:26\n+   |\n+LL | fn substs_change<T>() -> impl Sized { //~ ERROR\n+   |                          ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `(impl Sized,)`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:57:24\n+   |\n+LL | fn generator_hold() -> impl Sized { //~ ERROR\n+   |                        ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type.rs:58:5: 62:6 {impl Sized, ()}]`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:65:40\n+   |\n+LL | async fn recursive_async_function() -> () { //~ ERROR\n+   |                                        ^^ expands to self-referential type\n+   |\n+   = note: expanded type is `std::future::GenFuture<[static generator@$DIR/recursive-impl-trait-type.rs:65:43: 67:2 {impl std::future::Future, ()}]>`\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:73:26\n+   |\n+LL | fn mutual_recursion() -> impl Sync { //~ ERROR\n+   |                          ^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: type resolves to itself\n+\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/recursive-impl-trait-type.rs:77:28\n+   |\n+LL | fn mutual_recursion_b() -> impl Sized { //~ ERROR\n+   |                            ^^^^^^^^^^ expands to self-referential type\n+   |\n+   = note: type resolves to itself\n+\n+error: aborting due to 15 previous errors\n+\n+For more information about this error, try `rustc --explain E0720`."}]}