{"sha": "a52eaaa996a7edeb699a756f755ad4b8c23dc9df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MmVhYWE5OTZhN2VkZWI2OTlhNzU2Zjc1NWFkNGI4YzIzZGM5ZGY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-09-24T22:35:44Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-09-26T17:17:01Z"}, "message": "Disable runtime split stack support on Windows", "tree": {"sha": "684d2450cc33dd13cff1a73fdb9c69678c763546", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/684d2450cc33dd13cff1a73fdb9c69678c763546"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a52eaaa996a7edeb699a756f755ad4b8c23dc9df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a52eaaa996a7edeb699a756f755ad4b8c23dc9df", "html_url": "https://github.com/rust-lang/rust/commit/a52eaaa996a7edeb699a756f755ad4b8c23dc9df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a52eaaa996a7edeb699a756f755ad4b8c23dc9df/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91e30ecf6774929babdc6ed7660a39f539239565", "url": "https://api.github.com/repos/rust-lang/rust/commits/91e30ecf6774929babdc6ed7660a39f539239565", "html_url": "https://github.com/rust-lang/rust/commit/91e30ecf6774929babdc6ed7660a39f539239565"}], "stats": {"total": 69, "additions": 13, "deletions": 56}, "files": [{"sha": "a4cbbf248113f89a4979f96732bd786d175e0ab0", "filename": "src/librustrt/stack.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a52eaaa996a7edeb699a756f755ad4b8c23dc9df/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52eaaa996a7edeb699a756f755ad4b8c23dc9df/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=a52eaaa996a7edeb699a756f755ad4b8c23dc9df", "patch": "@@ -200,11 +200,7 @@ pub unsafe fn record_sp_limit(limit: uint) {\n         asm!(\"movq $0, %fs:112\" :: \"r\"(limit) :: \"volatile\")\n     }\n     #[cfg(target_arch = \"x86_64\", target_os = \"windows\")] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n-        // see: http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n-        // store this inside of the \"arbitrary data slot\", but double the size\n-        // because this is 64 bit instead of 32 bit\n-        asm!(\"movq $0, %gs:0x28\" :: \"r\"(limit) :: \"volatile\")\n+    unsafe fn target_record_sp_limit(_: uint) {\n     }\n     #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n@@ -228,10 +224,7 @@ pub unsafe fn record_sp_limit(limit: uint) {\n         asm!(\"movl $0, %gs:48\" :: \"r\"(limit) :: \"volatile\")\n     }\n     #[cfg(target_arch = \"x86\", target_os = \"windows\")] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n-        // see: http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n-        // store this inside of the \"arbitrary data slot\"\n-        asm!(\"movl $0, %fs:0x14\" :: \"r\"(limit) :: \"volatile\")\n+    unsafe fn target_record_sp_limit(_: uint) {\n     }\n \n     // mips, arm - Some brave soul can port these to inline asm, but it's over\n@@ -282,9 +275,7 @@ pub unsafe fn get_sp_limit() -> uint {\n     }\n     #[cfg(target_arch = \"x86_64\", target_os = \"windows\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n-        let limit;\n-        asm!(\"movq %gs:0x28, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n+        return 1024;\n     }\n     #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n@@ -318,9 +309,7 @@ pub unsafe fn get_sp_limit() -> uint {\n     }\n     #[cfg(target_arch = \"x86\", target_os = \"windows\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n-        let limit;\n-        asm!(\"movl %fs:0x14, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n+        return 1024;\n     }\n \n     // mips, arm - Some brave soul can port these to inline asm, but it's over"}, {"sha": "120ace1c36a5f99bdb00dbbffd8c44f250760174", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a52eaaa996a7edeb699a756f755ad4b8c23dc9df/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52eaaa996a7edeb699a756f755ad4b8c23dc9df/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=a52eaaa996a7edeb699a756f755ad4b8c23dc9df", "patch": "@@ -136,7 +136,6 @@ mod imp {\n     use os;\n     use rand::Rng;\n     use result::{Ok, Err};\n-    use rt::stack;\n     use self::libc::{DWORD, BYTE, LPCSTR, BOOL};\n     use self::libc::types::os::arch::extra::{LONG_PTR};\n     use slice::MutableSlice;\n@@ -159,7 +158,6 @@ mod imp {\n     static PROV_RSA_FULL: DWORD = 1;\n     static CRYPT_SILENT: DWORD = 64;\n     static CRYPT_VERIFYCONTEXT: DWORD = 0xF0000000;\n-    static NTE_BAD_SIGNATURE: DWORD = 0x80090006;\n \n     #[allow(non_snake_case)]\n     extern \"system\" {\n@@ -178,48 +176,12 @@ mod imp {\n         /// Create a new `OsRng`.\n         pub fn new() -> IoResult<OsRng> {\n             let mut hcp = 0;\n-            let mut ret = unsafe {\n+            let ret = unsafe {\n                 CryptAcquireContextA(&mut hcp, 0 as LPCSTR, 0 as LPCSTR,\n                                      PROV_RSA_FULL,\n                                      CRYPT_VERIFYCONTEXT | CRYPT_SILENT)\n             };\n \n-            // FIXME #13259:\n-            // It turns out that if we can't acquire a context with the\n-            // NTE_BAD_SIGNATURE error code, the documentation states:\n-            //\n-            //     The provider DLL signature could not be verified. Either the\n-            //     DLL or the digital signature has been tampered with.\n-            //\n-            // Sounds fishy, no? As it turns out, our signature can be bad\n-            // because our Thread Information Block (TIB) isn't exactly what it\n-            // expects. As to why, I have no idea. The only data we store in the\n-            // TIB is the stack limit for each thread, but apparently that's\n-            // enough to make the signature valid.\n-            //\n-            // Furthermore, this error only happens the *first* time we call\n-            // CryptAcquireContext, so we don't have to worry about future\n-            // calls.\n-            //\n-            // Anyway, the fix employed here is that if we see this error, we\n-            // pray that we're not close to the end of the stack, temporarily\n-            // set the stack limit to 0 (what the TIB originally was), acquire a\n-            // context, and then reset the stack limit.\n-            //\n-            // Again, I'm not sure why this is the fix, nor why we're getting\n-            // this error. All I can say is that this seems to allow libnative\n-            // to progress where it otherwise would be hindered. Who knew?\n-            if ret == 0 && os::errno() as DWORD == NTE_BAD_SIGNATURE {\n-                unsafe {\n-                    let limit = stack::get_sp_limit();\n-                    stack::record_sp_limit(0);\n-                    ret = CryptAcquireContextA(&mut hcp, 0 as LPCSTR, 0 as LPCSTR,\n-                                               PROV_RSA_FULL,\n-                                               CRYPT_VERIFYCONTEXT | CRYPT_SILENT);\n-                    stack::record_sp_limit(limit);\n-                }\n-            }\n-\n             if ret == 0 {\n                 Err(IoError::last_error())\n             } else {"}, {"sha": "bbaa09bfac3100d5a4f110f7c73395d2522a99f4", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a52eaaa996a7edeb699a756f755ad4b8c23dc9df/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52eaaa996a7edeb699a756f755ad4b8c23dc9df/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=a52eaaa996a7edeb699a756f755ad4b8c23dc9df", "patch": "@@ -42,11 +42,17 @@ fn main() {\n         let silent = Command::new(args[0].as_slice()).arg(\"silent\").output().unwrap();\n         assert!(!silent.status.success());\n         let error = String::from_utf8_lossy(silent.error.as_slice());\n-        assert!(error.as_slice().contains(\"has overflowed its stack\"));\n+        // FIXME #17562: Windows is using stack probes and isn't wired up to print an error\n+        if !cfg!(windows) {\n+            assert!(error.as_slice().contains(\"has overflowed its stack\"));\n+        }\n \n         let loud = Command::new(args[0].as_slice()).arg(\"loud\").output().unwrap();\n         assert!(!loud.status.success());\n         let error = String::from_utf8_lossy(silent.error.as_slice());\n-        assert!(error.as_slice().contains(\"has overflowed its stack\"));\n+        // FIXME #17562: Windows is using stack probes and isn't wired up to print an error\n+        if !cfg!(windows) {\n+            assert!(error.as_slice().contains(\"has overflowed its stack\"));\n+        }\n     }\n }"}]}