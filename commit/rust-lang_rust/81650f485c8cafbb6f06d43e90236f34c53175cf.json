{"sha": "81650f485c8cafbb6f06d43e90236f34c53175cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNjUwZjQ4NWM4Y2FmYmI2ZjA2ZDQzZTkwMjM2ZjM0YzUzMTc1Y2Y=", "commit": {"author": {"name": "khyperia", "email": "github@khyperia.com", "date": "2020-08-29T16:10:01Z"}, "committer": {"name": "khyperia", "email": "github@khyperia.com", "date": "2020-08-29T17:02:04Z"}, "message": "Make to_immediate/from_immediate configurable by backends\n\nlibrustc_codegen_ssa has the concept of an immediate vs. memory type,\nand librustc_codegen_llvm uses this distinction to implement bools being\ni8 in memory, and i1 in immediate contexts. However, some of that\nimplementation leaked into codegen_ssa when converting to/from immediate\nvalues. So, move those methods into builder traits, so that behavior can\nbe configured by backends.\n\nThis is useful if a backend is able to keep bools as bools, or, needs to\ndo more trickery than just bools to bytes.", "tree": {"sha": "5369aab7687fdeb4504171d8b5dc7da1ccc915b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5369aab7687fdeb4504171d8b5dc7da1ccc915b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81650f485c8cafbb6f06d43e90236f34c53175cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81650f485c8cafbb6f06d43e90236f34c53175cf", "html_url": "https://github.com/rust-lang/rust/commit/81650f485c8cafbb6f06d43e90236f34c53175cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81650f485c8cafbb6f06d43e90236f34c53175cf/comments", "author": {"login": "khyperia", "id": 953151, "node_id": "MDQ6VXNlcjk1MzE1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/953151?v=4", "gravatar_id": "", "url": "https://api.github.com/users/khyperia", "html_url": "https://github.com/khyperia", "followers_url": "https://api.github.com/users/khyperia/followers", "following_url": "https://api.github.com/users/khyperia/following{/other_user}", "gists_url": "https://api.github.com/users/khyperia/gists{/gist_id}", "starred_url": "https://api.github.com/users/khyperia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/khyperia/subscriptions", "organizations_url": "https://api.github.com/users/khyperia/orgs", "repos_url": "https://api.github.com/users/khyperia/repos", "events_url": "https://api.github.com/users/khyperia/events{/privacy}", "received_events_url": "https://api.github.com/users/khyperia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "khyperia", "id": 953151, "node_id": "MDQ6VXNlcjk1MzE1MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/953151?v=4", "gravatar_id": "", "url": "https://api.github.com/users/khyperia", "html_url": "https://github.com/khyperia", "followers_url": "https://api.github.com/users/khyperia/followers", "following_url": "https://api.github.com/users/khyperia/following{/other_user}", "gists_url": "https://api.github.com/users/khyperia/gists{/gist_id}", "starred_url": "https://api.github.com/users/khyperia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/khyperia/subscriptions", "organizations_url": "https://api.github.com/users/khyperia/orgs", "repos_url": "https://api.github.com/users/khyperia/repos", "events_url": "https://api.github.com/users/khyperia/events{/privacy}", "received_events_url": "https://api.github.com/users/khyperia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "286a346d00ea534985195f3d72f4e1c5f3b07e2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/286a346d00ea534985195f3d72f4e1c5f3b07e2e", "html_url": "https://github.com/rust-lang/rust/commit/286a346d00ea534985195f3d72f4e1c5f3b07e2e"}], "stats": {"total": 122, "additions": 54, "deletions": 68}, "files": [{"sha": "89c3e21632ead841c7ac4063061e7fdc37e13312", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=81650f485c8cafbb6f06d43e90236f34c53175cf", "patch": "@@ -6,7 +6,6 @@ use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n use libc::{c_char, c_uint};\n-use rustc_codegen_ssa::base::to_immediate;\n use rustc_codegen_ssa::common::{IntPredicate, RealPredicate, TypeKind};\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n@@ -367,6 +366,20 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         (self.extract_value(res, 0), self.extract_value(res, 1))\n     }\n \n+    fn from_immediate(&mut self, val: Self::Value) -> Self::Value {\n+        if self.cx().val_ty(val) == self.cx().type_i1() {\n+            self.zext(val, self.cx().type_i8())\n+        } else {\n+            val\n+        }\n+    }\n+    fn to_immediate_scalar(&mut self, val: Self::Value, scalar: &abi::Scalar) -> Self::Value {\n+        if scalar.is_bool() {\n+            return self.trunc(val, self.cx().type_i1());\n+        }\n+        val\n+    }\n+\n     fn alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         let mut bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe { llvm::LLVMGetFirstBasicBlock(self.llfn()) });\n@@ -471,15 +484,15 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n                 load\n             });\n-            OperandValue::Immediate(to_immediate(self, llval, place.layout))\n+            OperandValue::Immediate(self.to_immediate(llval, place.layout))\n         } else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n             let b_offset = a.value.size(self).align_to(b.value.align(self).abi);\n \n             let mut load = |i, scalar: &abi::Scalar, align| {\n                 let llptr = self.struct_gep(place.llval, i as u64);\n                 let load = self.load(llptr, align);\n                 scalar_load_metadata(self, load, scalar);\n-                if scalar.is_bool() { self.trunc(load, self.type_i1()) } else { load }\n+                self.to_immediate_scalar(load, scalar)\n             };\n \n             OperandValue::Pair("}, {"sha": "951b9928cc99d9779c0fe6b5ec09d7d69d9bec72", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=81650f485c8cafbb6f06d43e90236f34c53175cf", "patch": "@@ -8,7 +8,7 @@ use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n \n use rustc_ast as ast;\n-use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n+use rustc_codegen_ssa::base::{compare_simd_types, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc_codegen_ssa::glue;\n@@ -301,7 +301,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 unsafe {\n                     llvm::LLVMSetAlignment(load, align);\n                 }\n-                to_immediate(self, load, self.layout_of(tp_ty))\n+                self.to_immediate(load, self.layout_of(tp_ty))\n             }\n             sym::volatile_store => {\n                 let dst = args[0].deref(self.cx());"}, {"sha": "e0b649d91c79e43e99cb393cf835942ccd7e8fc6", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=81650f485c8cafbb6f06d43e90236f34c53175cf", "patch": "@@ -38,7 +38,7 @@ use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::middle::cstore::{self, LinkagePreference};\n use rustc_middle::middle::lang_items;\n use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, MonoItem};\n-use rustc_middle::ty::layout::{self, HasTyCtxt, TyAndLayout};\n+use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n@@ -48,7 +48,7 @@ use rustc_session::utils::NativeLibKind;\n use rustc_session::Session;\n use rustc_span::Span;\n use rustc_symbol_mangling::test as symbol_names_test;\n-use rustc_target::abi::{Abi, Align, LayoutOf, Scalar, VariantIdx};\n+use rustc_target::abi::{Align, LayoutOf, VariantIdx};\n \n use std::cmp;\n use std::ops::{Deref, DerefMut};\n@@ -330,35 +330,6 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n     sess.target.target.options.is_like_msvc\n }\n \n-pub fn from_immediate<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &mut Bx,\n-    val: Bx::Value,\n-) -> Bx::Value {\n-    if bx.cx().val_ty(val) == bx.cx().type_i1() { bx.zext(val, bx.cx().type_i8()) } else { val }\n-}\n-\n-pub fn to_immediate<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &mut Bx,\n-    val: Bx::Value,\n-    layout: layout::TyAndLayout<'_>,\n-) -> Bx::Value {\n-    if let Abi::Scalar(ref scalar) = layout.abi {\n-        return to_immediate_scalar(bx, val, scalar);\n-    }\n-    val\n-}\n-\n-pub fn to_immediate_scalar<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &mut Bx,\n-    val: Bx::Value,\n-    scalar: &Scalar,\n-) -> Bx::Value {\n-    if scalar.is_bool() {\n-        return bx.trunc(val, bx.cx().type_i1());\n-    }\n-    val\n-}\n-\n pub fn memcpy_ty<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     dst: Bx::Value,"}, {"sha": "6eb80157239ea240d31ff5c97192fccab0228954", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=81650f485c8cafbb6f06d43e90236f34c53175cf", "patch": "@@ -1143,7 +1143,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 }\n                 // We store bools as `i8` so we need to truncate to `i1`.\n-                llval = base::to_immediate(bx, llval, arg.layout);\n+                llval = bx.to_immediate(llval, arg.layout);\n             }\n         }\n "}, {"sha": "fb84e9146619214c68e9111f393fa25fb5bce306", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=81650f485c8cafbb6f06d43e90236f34c53175cf", "patch": "@@ -147,8 +147,8 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\", self, llty);\n             // Reconstruct the immediate aggregate.\n             let mut llpair = bx.cx().const_undef(llty);\n-            let imm_a = base::from_immediate(bx, a);\n-            let imm_b = base::from_immediate(bx, b);\n+            let imm_a = bx.from_immediate(a);\n+            let imm_b = bx.from_immediate(b);\n             llpair = bx.insert_value(llpair, imm_a, 0);\n             llpair = bx.insert_value(llpair, imm_b, 1);\n             llpair\n@@ -168,9 +168,9 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n \n             // Deconstruct the immediate aggregate.\n             let a_llval = bx.extract_value(llval, 0);\n-            let a_llval = base::to_immediate_scalar(bx, a_llval, a);\n+            let a_llval = bx.to_immediate_scalar(a_llval, a);\n             let b_llval = bx.extract_value(llval, 1);\n-            let b_llval = base::to_immediate_scalar(bx, b_llval, b);\n+            let b_llval = bx.to_immediate_scalar(b_llval, b);\n             OperandValue::Pair(a_llval, b_llval)\n         } else {\n             OperandValue::Immediate(llval)\n@@ -220,29 +220,21 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             _ => bug!(\"OperandRef::extract_field({:?}): not applicable\", self),\n         };\n \n-        // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-        // Bools in union fields needs to be truncated.\n-        let to_immediate_or_cast = |bx: &mut Bx, val, ty| {\n-            if ty == bx.cx().type_i1() { bx.trunc(val, ty) } else { bx.bitcast(val, ty) }\n-        };\n-\n-        match val {\n-            OperandValue::Immediate(ref mut llval) => {\n-                *llval = to_immediate_or_cast(bx, *llval, bx.cx().immediate_backend_type(field));\n+        match (&mut val, &self.layout.abi) {\n+            (OperandValue::Immediate(llval), _) => {\n+                // Bools in union fields needs to be truncated.\n+                *llval = bx.to_immediate(*llval, field);\n+                // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+                *llval = bx.bitcast(*llval, bx.cx().immediate_backend_type(field));\n             }\n-            OperandValue::Pair(ref mut a, ref mut b) => {\n-                *a = to_immediate_or_cast(\n-                    bx,\n-                    *a,\n-                    bx.cx().scalar_pair_element_backend_type(field, 0, true),\n-                );\n-                *b = to_immediate_or_cast(\n-                    bx,\n-                    *b,\n-                    bx.cx().scalar_pair_element_backend_type(field, 1, true),\n-                );\n+            (OperandValue::Pair(a, b), Abi::ScalarPair(a_abi, b_abi)) => {\n+                *a = bx.to_immediate_scalar(*a, a_abi);\n+                *a = bx.bitcast(*a, bx.cx().scalar_pair_element_backend_type(field, 0, true));\n+                *b = bx.to_immediate_scalar(*b, b_abi);\n+                *b = bx.bitcast(*b, bx.cx().scalar_pair_element_backend_type(field, 1, true));\n             }\n-            OperandValue::Ref(..) => bug!(),\n+            (OperandValue::Pair(..), _) => bug!(),\n+            (OperandValue::Ref(..), _) => bug!(),\n         }\n \n         OperandRef { val, layout: field }\n@@ -302,7 +294,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n                 bug!(\"cannot directly store unsized values\");\n             }\n             OperandValue::Immediate(s) => {\n-                let val = base::from_immediate(bx, s);\n+                let val = bx.from_immediate(s);\n                 bx.store_with_flags(val, dest.llval, dest.align, flags);\n             }\n             OperandValue::Pair(a, b) => {\n@@ -313,12 +305,12 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n                 let b_offset = a_scalar.value.size(bx).align_to(b_scalar.value.align(bx).abi);\n \n                 let llptr = bx.struct_gep(dest.llval, 0);\n-                let val = base::from_immediate(bx, a);\n+                let val = bx.from_immediate(a);\n                 let align = dest.align;\n                 bx.store_with_flags(val, llptr, align, flags);\n \n                 let llptr = bx.struct_gep(dest.llval, 1);\n-                let val = base::from_immediate(bx, b);\n+                let val = bx.from_immediate(b);\n                 let align = dest.align.restrict_for_offset(b_offset);\n                 bx.store_with_flags(val, llptr, align, flags);\n             }"}, {"sha": "1994c45707cedbe2570dac989d0a76e863818e37", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=81650f485c8cafbb6f06d43e90236f34c53175cf", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n-                    let v = base::from_immediate(&mut bx, v);\n+                    let v = bx.from_immediate(v);\n                     if bx.cx().val_ty(v) == bx.cx().type_i8() {\n                         bx.memset(start, v, size, dest.align, MemFlags::empty());\n                         return bx;"}, {"sha": "5142922260a5722c8bb645f24d5956449b6e12c5", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81650f485c8cafbb6f06d43e90236f34c53175cf/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=81650f485c8cafbb6f06d43e90236f34c53175cf", "patch": "@@ -13,9 +13,9 @@ use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n use crate::MemFlags;\n \n-use rustc_middle::ty::layout::HasParamEnv;\n+use rustc_middle::ty::layout::{HasParamEnv, TyAndLayout};\n use rustc_middle::ty::Ty;\n-use rustc_target::abi::{Align, Size};\n+use rustc_target::abi::{Abi, Align, Scalar, Size};\n use rustc_target::spec::HasTargetSpec;\n \n use std::iter::TrustedLen;\n@@ -115,6 +115,16 @@ pub trait BuilderMethods<'a, 'tcx>:\n         rhs: Self::Value,\n     ) -> (Self::Value, Self::Value);\n \n+    fn from_immediate(&mut self, val: Self::Value) -> Self::Value;\n+    fn to_immediate(&mut self, val: Self::Value, layout: TyAndLayout<'_>) -> Self::Value {\n+        if let Abi::Scalar(ref scalar) = layout.abi {\n+            self.to_immediate_scalar(val, scalar)\n+        } else {\n+            val\n+        }\n+    }\n+    fn to_immediate_scalar(&mut self, val: Self::Value, scalar: &Scalar) -> Self::Value;\n+\n     fn alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n     fn dynamic_alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n     fn array_alloca(&mut self, ty: Self::Type, len: Self::Value, align: Align) -> Self::Value;"}]}