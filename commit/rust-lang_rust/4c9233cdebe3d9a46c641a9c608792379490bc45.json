{"sha": "4c9233cdebe3d9a46c641a9c608792379490bc45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjOTIzM2NkZWJlM2Q5YTQ2YzY0MWE5YzYwODc5MjM3OTQ5MGJjNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-09T15:11:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-09T15:11:43Z"}, "message": "Auto merge of #57885 - arielb1:xform-probe, r=nikomatsakis\n\nAvoid committing to autoderef in object method probing\n\nThis fixes the \"leak\" introduced in #57835 (see test for details, also apparently #54252 had no tests for the \"leaks\" that were fixed in it, so go ahead and add one).\n\nMaybe beta-nominating because regression, but I'm against landing things on beta we don't have to.\n\nr? @nikomatsakis", "tree": {"sha": "270cb0804fba68d56a3f1ef8679696a621c1ca25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/270cb0804fba68d56a3f1ef8679696a621c1ca25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c9233cdebe3d9a46c641a9c608792379490bc45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c9233cdebe3d9a46c641a9c608792379490bc45", "html_url": "https://github.com/rust-lang/rust/commit/4c9233cdebe3d9a46c641a9c608792379490bc45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c9233cdebe3d9a46c641a9c608792379490bc45/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d329d46a3fcca61a1359c7c8f3b4ed0bccadd32e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d329d46a3fcca61a1359c7c8f3b4ed0bccadd32e", "html_url": "https://github.com/rust-lang/rust/commit/d329d46a3fcca61a1359c7c8f3b4ed0bccadd32e"}, {"sha": "927d01fdb9adb7ee716af987f7074d5af5426a5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/927d01fdb9adb7ee716af987f7074d5af5426a5d", "html_url": "https://github.com/rust-lang/rust/commit/927d01fdb9adb7ee716af987f7074d5af5426a5d"}], "stats": {"total": 409, "additions": 402, "deletions": 7}, "files": [{"sha": "ada4a95ed7a34ef49988e4a0f640816466640ee0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4c9233cdebe3d9a46c641a9c608792379490bc45/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9233cdebe3d9a46c641a9c608792379490bc45/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4c9233cdebe3d9a46c641a9c608792379490bc45", "patch": "@@ -85,6 +85,37 @@ impl<'a, 'gcx, 'tcx> Deref for ProbeContext<'a, 'gcx, 'tcx> {\n \n #[derive(Debug)]\n struct Candidate<'tcx> {\n+    // Candidates are (I'm not quite sure, but they are mostly) basically\n+    // some metadata on top of a `ty::AssociatedItem` (without substs).\n+    //\n+    // However, method probing wants to be able to evaluate the predicates\n+    // for a function with the substs applied - for example, if a function\n+    // has `where Self: Sized`, we don't want to consider it unless `Self`\n+    // is actually `Sized`, and similarly, return-type suggestions want\n+    // to consider the \"actual\" return type.\n+    //\n+    // The way this is handled is through `xform_self_ty`. It contains\n+    // the receiver type of this candidate, but `xform_self_ty`,\n+    // `xform_ret_ty` and `kind` (which contains the predicates) have the\n+    // generic parameters of this candidate substituted with the *same set*\n+    // of inference variables, which acts as some weird sort of \"query\".\n+    //\n+    // When we check out a candidate, we require `xform_self_ty` to be\n+    // a subtype of the passed-in self-type, and this equates the type\n+    // variables in the rest of the fields.\n+    //\n+    // For example, if we have this candidate:\n+    // ```\n+    //    trait Foo {\n+    //        fn foo(&self) where Self: Sized;\n+    //    }\n+    // ```\n+    //\n+    // Then `xform_self_ty` will be `&'erased ?X` and `kind` will contain\n+    // the predicate `?X: Sized`, so if we are evaluating `Foo` for a\n+    // the receiver `&T`, we'll do the subtyping which will make `?X`\n+    // get the right value, then when we evaluate the predicate we'll check\n+    // if `T: Sized`.\n     xform_self_ty: Ty<'tcx>,\n     xform_ret_ty: Option<Ty<'tcx>>,\n     item: ty::AssociatedItem,\n@@ -506,13 +537,28 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         match self_ty.value.value.sty {\n             ty::Dynamic(ref data, ..) => {\n                 if let Some(p) = data.principal() {\n-                    let InferOk { value: instantiated_self_ty, obligations: _ } =\n-                        self.fcx.probe_instantiate_query_response(\n-                            self.span, &self.orig_steps_var_values, self_ty)\n-                        .unwrap_or_else(|_| {\n-                            span_bug!(self.span, \"{:?} was applicable but now isn't?\", self_ty)\n-                        });\n-                    self.assemble_inherent_candidates_from_object(instantiated_self_ty);\n+                    // Subtle: we can't use `instantiate_query_response` here: using it will\n+                    // commit to all of the type equalities assumed by inference going through\n+                    // autoderef (see the `method-probe-no-guessing` test).\n+                    //\n+                    // However, in this code, it is OK if we end up with an object type that is\n+                    // \"more general\" than the object type that we are evaluating. For *every*\n+                    // object type `MY_OBJECT`, a function call that goes through a trait-ref\n+                    // of the form `<MY_OBJECT as SuperTraitOf(MY_OBJECT)>::func` is a valid\n+                    // `ObjectCandidate`, and it should be discoverable \"exactly\" through one\n+                    // of the iterations in the autoderef loop, so there is no problem with it\n+                    // being discoverable in another one of these iterations.\n+                    //\n+                    // Using `instantiate_canonical_with_fresh_inference_vars` on our\n+                    // `Canonical<QueryResponse<Ty<'tcx>>>` and then *throwing away* the\n+                    // `CanonicalVarValues` will exactly give us such a generalization - it\n+                    // will still match the original object type, but it won't pollute our\n+                    // type variables in any form, so just do that!\n+                    let (QueryResponse { value: generalized_self_ty, .. }, _ignored_var_values) =\n+                        self.fcx.instantiate_canonical_with_fresh_inference_vars(\n+                            self.span, &self_ty);\n+\n+                    self.assemble_inherent_candidates_from_object(generalized_self_ty);\n                     self.assemble_inherent_impl_candidates_for_type(p.def_id());\n                 }\n             }"}, {"sha": "8c8165a1004499fcd78606bfff539bd4497ab199", "filename": "src/test/run-pass/methods/method-probe-no-guessing-dyn-trait.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4c9233cdebe3d9a46c641a9c608792379490bc45/src%2Ftest%2Frun-pass%2Fmethods%2Fmethod-probe-no-guessing-dyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9233cdebe3d9a46c641a9c608792379490bc45/src%2Ftest%2Frun-pass%2Fmethods%2Fmethod-probe-no-guessing-dyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethods%2Fmethod-probe-no-guessing-dyn-trait.rs?ref=4c9233cdebe3d9a46c641a9c608792379490bc45", "patch": "@@ -0,0 +1,59 @@\n+// Check that method matching does not make \"guesses\" depending on\n+// Deref impls that don't eventually end up being picked.\n+\n+use std::ops::Deref;\n+\n+// An impl with less derefs will get called over an impl with more derefs,\n+// so `(t: Foo<_>).my_fn()` will use `<Foo<u32> as MyTrait1>::my_fn(t)`,\n+// and does *not* force the `_` to equal `()`, because the Deref impl\n+// was *not* used.\n+\n+trait MyTrait1 {\n+    fn my_fn(&self) {}\n+}\n+\n+impl MyTrait1 for Foo<u32> {}\n+\n+struct Foo<T>(T);\n+\n+impl Deref for Foo<()> {\n+    type Target = dyn MyTrait1 + 'static;\n+    fn deref(&self) -> &(dyn MyTrait1 + 'static) {\n+        panic!()\n+    }\n+}\n+\n+// ...but if there is no impl with less derefs, the \"guess\" will be\n+// forced, so `(t: Bar<_>).my_fn2()` is `<dyn MyTrait2 as MyTrait2>::my_fn2(*t)`,\n+// and because the deref impl is used, the `_` is forced to equal `u8`.\n+\n+trait MyTrait2 {\n+    fn my_fn2(&self) {}\n+}\n+\n+impl MyTrait2 for u32 {}\n+struct Bar<T>(T, u32);\n+impl Deref for Bar<u8> {\n+    type Target = dyn MyTrait2 + 'static;\n+    fn deref(&self) -> &(dyn MyTrait2 + 'static) {\n+        &self.1\n+    }\n+}\n+\n+// actually invoke things\n+\n+fn main() {\n+    let mut foo: Option<Foo<_>> = None;\n+    let mut bar: Option<Bar<_>> = None;\n+    let mut first_iter = true;\n+    loop {\n+        if !first_iter {\n+            foo.as_ref().unwrap().my_fn();\n+            bar.as_ref().unwrap().my_fn2();\n+            break;\n+        }\n+        foo = Some(Foo(0));\n+        bar = Some(Bar(Default::default(), 0));\n+        first_iter = false;\n+    }\n+}"}, {"sha": "a5dae1c71cdaaf5ed7206aca3afc6499ed00acb6", "filename": "src/test/ui/methods/method-deref-to-same-trait-object-with-separate-params.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/4c9233cdebe3d9a46c641a9c608792379490bc45/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9233cdebe3d9a46c641a9c608792379490bc45/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.rs?ref=4c9233cdebe3d9a46c641a9c608792379490bc45", "patch": "@@ -0,0 +1,177 @@\n+#![feature(arbitrary_self_types, coerce_unsized, dispatch_from_dyn, unsize, unsized_locals)]\n+\n+// This tests a few edge-cases around `arbitrary_self_types`. Most specifically,\n+// it checks that the `ObjectCandidate` you get from method matching can't\n+// match a trait with the same DefId as a supertrait but a bad type parameter.\n+\n+use std::marker::PhantomData;\n+\n+mod internal {\n+    use std::ops::{CoerceUnsized, Deref, DispatchFromDyn};\n+    use std::marker::{PhantomData, Unsize};\n+\n+    pub struct Smaht<T: ?Sized, MISC>(pub Box<T>, pub PhantomData<MISC>);\n+\n+    impl<T: ?Sized, MISC> Deref for Smaht<T, MISC> {\n+        type Target = T;\n+\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    impl<T: ?Sized + Unsize<U>, U: ?Sized, MISC> CoerceUnsized<Smaht<U, MISC>>\n+        for Smaht<T, MISC>\n+    {}\n+    impl<T: ?Sized + Unsize<U>, U: ?Sized, MISC> DispatchFromDyn<Smaht<U, MISC>>\n+        for Smaht<T, MISC>\n+    {}\n+\n+    pub trait Foo: X<u32> {}\n+    pub trait X<T> {\n+        fn foo(self: Smaht<Self, T>) -> T;\n+    }\n+\n+    impl X<u32> for () {\n+        fn foo(self: Smaht<Self, u32>) -> u32 {\n+            0\n+        }\n+    }\n+\n+    pub trait Marker {}\n+    impl Marker for dyn Foo {}\n+    impl<T: Marker + ?Sized> X<u64> for T {\n+        fn foo(self: Smaht<Self, u64>) -> u64 {\n+            1\n+        }\n+    }\n+\n+    impl Deref for dyn Foo {\n+        type Target = ();\n+        fn deref(&self) -> &() { &() }\n+    }\n+\n+    impl Foo for () {}\n+}\n+\n+pub trait FinalFoo {\n+    fn foo(&self) -> u8;\n+}\n+\n+impl FinalFoo for () {\n+    fn foo(&self) -> u8 { 0 }\n+}\n+\n+mod nuisance_foo {\n+    pub trait NuisanceFoo {\n+        fn foo(self);\n+    }\n+\n+    impl<T: ?Sized> NuisanceFoo for T {\n+        fn foo(self) {}\n+    }\n+}\n+\n+\n+fn objectcandidate_impl() {\n+    let x: internal::Smaht<(), u32> = internal::Smaht(Box::new(()), PhantomData);\n+    let x: internal::Smaht<dyn internal::Foo, u32> = x;\n+\n+    // This picks `<dyn internal::Foo as X<u32>>::foo` via `ObjectCandidate`.\n+    //\n+    // The `TraitCandidate` is not relevant because `X` is not in scope.\n+    let z = x.foo();\n+\n+    // Observe the type of `z` is `u32`\n+    let _seetype: () = z; //~ ERROR mismatched types\n+    //~| expected (), found u32\n+}\n+\n+fn traitcandidate_impl() {\n+    use internal::X;\n+\n+    let x: internal::Smaht<(), u64> = internal::Smaht(Box::new(()), PhantomData);\n+    let x: internal::Smaht<dyn internal::Foo, u64> = x;\n+\n+    // This picks `<dyn internal::Foo as X<u64>>::foo` via `TraitCandidate`.\n+    //\n+    // The `ObjectCandidate` does not apply, as it only applies to\n+    // `X<u32>` (and not `X<u64>`).\n+    let z = x.foo();\n+\n+    // Observe the type of `z` is `u64`\n+    let _seetype: () = z; //~ ERROR mismatched types\n+    //~| expected (), found u64\n+}\n+\n+fn traitcandidate_impl_with_nuisance() {\n+    use internal::X;\n+    use nuisance_foo::NuisanceFoo;\n+\n+    let x: internal::Smaht<(), u64> = internal::Smaht(Box::new(()), PhantomData);\n+    let x: internal::Smaht<dyn internal::Foo, u64> = x;\n+\n+    // This picks `<dyn internal::Foo as X<u64>>::foo` via `TraitCandidate`.\n+    //\n+    // The `ObjectCandidate` does not apply, as it only applies to\n+    // `X<u32>` (and not `X<u64>`).\n+    //\n+    // The NuisanceFoo impl has the same priority as the `X` impl,\n+    // so we get a conflict.\n+    let z = x.foo(); //~ ERROR multiple applicable items in scope\n+}\n+\n+\n+fn neither_impl() {\n+    let x: internal::Smaht<(), u64> = internal::Smaht(Box::new(()), PhantomData);\n+    let x: internal::Smaht<dyn internal::Foo, u64> = x;\n+\n+    // This can't pick the `TraitCandidate` impl, because `Foo` is not\n+    // imported. However, this also can't pick the `ObjectCandidate`\n+    // impl, because it only applies to `X<u32>` (and not `X<u64>`).\n+    //\n+    // Therefore, neither of the candidates is applicable, and we pick\n+    // the `FinalFoo` impl after another deref, which will return `u8`.\n+    let z = x.foo();\n+\n+    // Observe the type of `z` is `u8`\n+    let _seetype: () = z; //~ ERROR mismatched types\n+    //~| expected (), found u8\n+}\n+\n+fn both_impls() {\n+    use internal::X;\n+\n+    let x: internal::Smaht<(), u32> = internal::Smaht(Box::new(()), PhantomData);\n+    let x: internal::Smaht<dyn internal::Foo, u32> = x;\n+\n+    // This can pick both the `TraitCandidate` and the `ObjectCandidate` impl.\n+    //\n+    // However, the `ObjectCandidate` is considered an \"inherent candidate\",\n+    // and therefore has priority over both the `TraitCandidate` as well as\n+    // any other \"nuisance\" candidate\" (if present).\n+    let z = x.foo();\n+\n+    // Observe the type of `z` is `u32`\n+    let _seetype: () = z; //~ ERROR mismatched types\n+    //~| expected (), found u32\n+}\n+\n+\n+fn both_impls_with_nuisance() {\n+    // Similar to the `both_impls` example, except with a nuisance impl to\n+    // make sure the `ObjectCandidate` indeed has a higher priority.\n+\n+    use internal::X;\n+    use nuisance_foo::NuisanceFoo;\n+\n+    let x: internal::Smaht<(), u32> = internal::Smaht(Box::new(()), PhantomData);\n+    let x: internal::Smaht<dyn internal::Foo, u32> = x;\n+    let z = x.foo();\n+\n+    // Observe the type of `z` is `u32`\n+    let _seetype: () = z; //~ ERROR mismatched types\n+    //~| expected (), found u32\n+}\n+\n+fn main() {\n+}"}, {"sha": "2d8449b96de410202d0026e357df0ead1757902b", "filename": "src/test/ui/methods/method-deref-to-same-trait-object-with-separate-params.stderr", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4c9233cdebe3d9a46c641a9c608792379490bc45/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c9233cdebe3d9a46c641a9c608792379490bc45/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr?ref=4c9233cdebe3d9a46c641a9c608792379490bc45", "patch": "@@ -0,0 +1,72 @@\n+error[E0308]: mismatched types\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:85:24\n+   |\n+LL |     let _seetype: () = z; //~ ERROR mismatched types\n+   |                        ^ expected (), found u32\n+   |\n+   = note: expected type `()`\n+              found type `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:102:24\n+   |\n+LL |     let _seetype: () = z; //~ ERROR mismatched types\n+   |                        ^ expected (), found u64\n+   |\n+   = note: expected type `()`\n+              found type `u64`\n+\n+error[E0034]: multiple applicable items in scope\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:120:15\n+   |\n+LL |     let z = x.foo(); //~ ERROR multiple applicable items in scope\n+   |               ^^^ multiple `foo` found\n+   |\n+note: candidate #1 is defined in an impl of the trait `internal::X` for the type `_`\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:43:9\n+   |\n+LL |         fn foo(self: Smaht<Self, u64>) -> u64 {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: candidate #2 is defined in an impl of the trait `nuisance_foo::NuisanceFoo` for the type `_`\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:70:9\n+   |\n+LL |         fn foo(self) {}\n+   |         ^^^^^^^^^^^^\n+note: candidate #3 is defined in the trait `FinalFoo`\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:57:5\n+   |\n+LL |     fn foo(&self) -> u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `FinalFoo::foo(x)` instead\n+\n+error[E0308]: mismatched types\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:137:24\n+   |\n+LL |     let _seetype: () = z; //~ ERROR mismatched types\n+   |                        ^ expected (), found u8\n+   |\n+   = note: expected type `()`\n+              found type `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:155:24\n+   |\n+LL |     let _seetype: () = z; //~ ERROR mismatched types\n+   |                        ^ expected (), found u32\n+   |\n+   = note: expected type `()`\n+              found type `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:172:24\n+   |\n+LL |     let _seetype: () = z; //~ ERROR mismatched types\n+   |                        ^ expected (), found u32\n+   |\n+   = note: expected type `()`\n+              found type `u32`\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors occurred: E0034, E0308.\n+For more information about an error, try `rustc --explain E0034`."}, {"sha": "da2f13f5a2f8a5304a1be4d60fb607cc63105b25", "filename": "src/test/ui/methods/method-trait-object-with-hrtb.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4c9233cdebe3d9a46c641a9c608792379490bc45/src%2Ftest%2Fui%2Fmethods%2Fmethod-trait-object-with-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9233cdebe3d9a46c641a9c608792379490bc45/src%2Ftest%2Fui%2Fmethods%2Fmethod-trait-object-with-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-trait-object-with-hrtb.rs?ref=4c9233cdebe3d9a46c641a9c608792379490bc45", "patch": "@@ -0,0 +1,41 @@\n+// compile-pass\n+\n+// Check that method probing ObjectCandidate works in the presence of\n+// auto traits and/or HRTBs.\n+\n+mod internal {\n+    pub trait MyObject<'a> {\n+        type Output;\n+\n+        fn foo(&self) -> Self::Output;\n+    }\n+\n+    impl<'a> MyObject<'a> for () {\n+        type Output = &'a u32;\n+\n+        fn foo(&self) -> Self::Output { &4 }\n+    }\n+}\n+\n+fn t1(d: &dyn for<'a> internal::MyObject<'a, Output=&'a u32>) {\n+    d.foo();\n+}\n+\n+fn t2(d: &dyn internal::MyObject<'static, Output=&'static u32>) {\n+    d.foo();\n+}\n+\n+fn t3(d: &(dyn for<'a> internal::MyObject<'a, Output=&'a u32> + Sync)) {\n+    d.foo();\n+}\n+\n+fn t4(d: &(dyn internal::MyObject<'static, Output=&'static u32> + Sync)) {\n+    d.foo();\n+}\n+\n+fn main() {\n+    t1(&());\n+    t2(&());\n+    t3(&());\n+    t4(&());\n+}"}]}