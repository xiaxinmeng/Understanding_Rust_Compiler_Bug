{"sha": "3e15dc108c66891da04aa8c3f77162746fab4277", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMTVkYzEwOGM2Njg5MWRhMDRhYThjM2Y3NzE2Mjc0NmZhYjQyNzc=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-12-14T17:20:12Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-12-14T17:20:12Z"}, "message": "Merge branch 'master' into redox", "tree": {"sha": "0f738754591bda950bf0d1e1ef39e39c97dc1d11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f738754591bda950bf0d1e1ef39e39c97dc1d11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e15dc108c66891da04aa8c3f77162746fab4277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e15dc108c66891da04aa8c3f77162746fab4277", "html_url": "https://github.com/rust-lang/rust/commit/3e15dc108c66891da04aa8c3f77162746fab4277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e15dc108c66891da04aa8c3f77162746fab4277/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daaa23187624543189e58fda5e5893c76252ff0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/daaa23187624543189e58fda5e5893c76252ff0a", "html_url": "https://github.com/rust-lang/rust/commit/daaa23187624543189e58fda5e5893c76252ff0a"}, {"sha": "01d53df82ef12625f947f5c0a6004e1aea2f9782", "url": "https://api.github.com/repos/rust-lang/rust/commits/01d53df82ef12625f947f5c0a6004e1aea2f9782", "html_url": "https://github.com/rust-lang/rust/commit/01d53df82ef12625f947f5c0a6004e1aea2f9782"}], "stats": {"total": 2200, "additions": 1780, "deletions": 420}, "files": [{"sha": "9cd77e71b82dde04638ee53c04353b5ced783024", "filename": "src/Cargo.lock", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -19,7 +19,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n ]\n \n@@ -42,7 +42,7 @@ dependencies = [\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -63,7 +63,7 @@ name = \"cmake\"\n version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -80,7 +80,7 @@ name = \"compiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n  \"core 0.0.0\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -121,7 +121,7 @@ name = \"flate\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -130,7 +130,7 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.38\"\n+version = \"0.3.40\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -402,7 +402,7 @@ name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_bitflags 0.0.0\",\n ]\n \n@@ -551,7 +551,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -587,7 +587,7 @@ dependencies = [\n  \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n@@ -677,7 +677,7 @@ dependencies = [\n \"checksum cmake 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e5bcf27e097a184c1df4437654ed98df3d7a516e8508a6ba45d8b092bbdf283\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\" = \"553f11439bdefe755bf366b264820f1da70f3aaf3924e594b886beb9c831bcf5\"\n+\"checksum gcc 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"872db9e59486ef2b14f8e8c10e9ef02de2bccef6363d7f34835dedb386b3d950\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n \"checksum libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"044d1360593a78f5c8e5e710beccdc24ab71d1f01bc19a29bcacdba22e8475d8\"\n \"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\""}, {"sha": "c38bb33aa02b124f62aa78d7bd715cd66e12bd0d", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -15,7 +15,7 @@\n //! `package_vers`, and otherwise indicating to the compiler what it should\n //! print out as part of its version information.\n \n-use std::fs::{self, File};\n+use std::fs::File;\n use std::io::prelude::*;\n use std::process::Command;\n \n@@ -69,7 +69,7 @@ pub fn collect(build: &mut Build) {\n \n     // If we have a git directory, add in some various SHA information of what\n     // commit this compiler was compiled from.\n-    if fs::metadata(build.src.join(\".git\")).is_ok() {\n+    if build.src.join(\".git\").is_dir() {\n         let ver_date = output(Command::new(\"git\").current_dir(&build.src)\n                                       .arg(\"log\").arg(\"-1\")\n                                       .arg(\"--date=short\")"}, {"sha": "712c4c52baa5f55ab9b7ada5dfdaf850eda72aa4", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -299,6 +299,7 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n     build.add_rust_test_threads(&mut cmd);\n     cmd.arg(\"--test\");\n     cmd.arg(markdown);\n+    cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n \n     let mut test_args = build.flags.cmd.test_args().join(\" \");\n     if build.config.quiet_tests {"}, {"sha": "60352cc894e9970b0ec253079f91cdd979f72892", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -48,6 +48,11 @@ pub fn tmpdir(build: &Build) -> PathBuf {\n /// Slurps up documentation from the `stage`'s `host`.\n pub fn docs(build: &Build, stage: u32, host: &str) {\n     println!(\"Dist docs stage{} ({})\", stage, host);\n+    if !build.config.docs {\n+        println!(\"\\tskipping - docs disabled\");\n+        return\n+    }\n+\n     let name = format!(\"rust-docs-{}\", package_vers(build));\n     let image = tmpdir(build).join(format!(\"{}-{}-image\", name, name));\n     let _ = fs::remove_dir_all(&image);\n@@ -260,6 +265,14 @@ pub fn debugger_scripts(build: &Build,\n pub fn std(build: &Build, compiler: &Compiler, target: &str) {\n     println!(\"Dist std stage{} ({} -> {})\", compiler.stage, compiler.host,\n              target);\n+\n+    // The only true set of target libraries came from the build triple, so\n+    // let's reduce redundant work by only producing archives from that host.\n+    if compiler.host != build.config.build {\n+        println!(\"\\tskipping, not a build host\");\n+        return\n+    }\n+\n     let name = format!(\"rust-std-{}\", package_vers(build));\n     let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n     let _ = fs::remove_dir_all(&image);\n@@ -294,10 +307,15 @@ pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n     println!(\"Dist analysis\");\n \n     if build.config.channel != \"nightly\" {\n-        println!(\"Skipping dist-analysis - not on nightly channel\");\n+        println!(\"\\tskipping - not on nightly channel\");\n         return;\n     }\n+    if compiler.host != build.config.build {\n+        println!(\"\\tskipping - not a build host\");\n+        return\n+    }\n     if compiler.stage != 2 {\n+        println!(\"\\tskipping - not stage2\");\n         return\n     }\n \n@@ -324,13 +342,6 @@ pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n        .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n     build.run(&mut cmd);\n     t!(fs::remove_dir_all(&image));\n-\n-    // Create plain source tarball\n-    let mut cmd = Command::new(\"tar\");\n-    cmd.arg(\"-czf\").arg(sanitize_sh(&distdir(build).join(&format!(\"{}.tar.gz\", name))))\n-       .arg(\"analysis\")\n-       .current_dir(&src);\n-    build.run(&mut cmd);\n }\n \n /// Creates the `rust-src` installer component and the plain source tarball"}, {"sha": "631e5fa1afd9e94b69c553758289d870a3e22830", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -499,7 +499,7 @@ pub fn build_rules(build: &Build) -> Rules {\n          .default(true)\n          .dep(|s| s.name(\"default:doc\"))\n          .run(move |s| dist::docs(build, s.stage, s.target));\n-    rules.dist(\"dist-analysis\", \"src/libstd\")\n+    rules.dist(\"dist-analysis\", \"analysis\")\n          .dep(|s| s.name(\"dist-std\"))\n          .default(true)\n          .run(move |s| dist::analysis(build, &s.compiler(), s.target));"}, {"sha": "5489fb7304d1c7d8b5b6335673dfa91312fc3b66", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -25,8 +25,13 @@ COPY install-ndk.sh install-sdk.sh accept-licenses.sh /android/\n RUN sh /android/install-ndk.sh\n RUN sh /android/install-sdk.sh\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+\n COPY start-emulator.sh /android/\n-ENTRYPOINT [\"/android/start-emulator.sh\"]\n+\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\", \"/android/start-emulator.sh\"]\n \n ENV TARGETS=arm-linux-androideabi\n ENV TARGETS=$TARGETS,i686-linux-android"}, {"sha": "eeb6c79d69bccee81d2dfffb7d6aa9d789e5690d", "filename": "src/ci/docker/cross/Dockerfile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -23,6 +23,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gcc-powerpc64le-linux-gnu libc6-dev-ppc64el-cross \\\n   gcc-s390x-linux-gnu libc6-dev-s390x-cross\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n ENV TARGETS=aarch64-unknown-linux-gnu\n ENV TARGETS=$TARGETS,arm-unknown-linux-gnueabi\n ENV TARGETS=$TARGETS,arm-unknown-linux-gnueabihf"}, {"sha": "51161997e222708f45121db2644f336c05d4f072", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -13,6 +13,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   sudo \\\n   gdb\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n ENV RUST_CHECK_TARGET check\n RUN mkdir /tmp/obj"}, {"sha": "1603d353275beaecdff7e73e2a2a76ebf839e67d", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -13,6 +13,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   sudo \\\n   gdb\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check\n RUN mkdir /tmp/obj"}, {"sha": "629cfbc3a9c6f1f8f1244dc4667ee543f30e70e2", "filename": "src/ci/docker/x86_64-freebsd/Dockerfile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -18,6 +18,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY build-toolchain.sh /tmp/\n RUN sh /tmp/build-toolchain.sh\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n ENV \\\n     AR_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-ar \\\n     CC_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-gcc"}, {"sha": "78aa510ec04235821e640701e6c343ebe5ff701f", "filename": "src/ci/docker/x86_64-gnu-cargotest/Dockerfile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -13,6 +13,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   libssl-dev \\\n   sudo\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check-cargotest\n ENV NO_VENDOR 1"}, {"sha": "7d00f11cbb800fa0c0920a4f64de2d087c972dc5", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -13,6 +13,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   sudo \\\n   gdb\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-debug \\"}, {"sha": "95484c660e67c1d9ab08418cc6c846d3426649de", "filename": "src/ci/docker/x86_64-gnu-llvm-3.7/Dockerfile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -16,6 +16,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   libedit-dev \\\n   zlib1g-dev\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --llvm-root=/usr/lib/llvm-3.7"}, {"sha": "4a5c5b57ea7c402d5df486b101af4cc4ef49f0fa", "filename": "src/ci/docker/x86_64-gnu-make/Dockerfile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -13,6 +13,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   sudo \\\n   gdb\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-rustbuild\n ENV RUST_CHECK_TARGET check\n RUN mkdir /tmp/obj"}, {"sha": "c2a5449d2e393f388890f4638b63eec365a20f6d", "filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -13,6 +13,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   sudo \\\n   gdb\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-optimize-tests\n ENV RUST_CHECK_TARGET check\n RUN mkdir /tmp/obj"}, {"sha": "54bbc9b342150477ab63f6b8a32b4f55416bb0f0", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -13,6 +13,11 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   sudo \\\n   gdb\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check\n RUN mkdir /tmp/obj"}, {"sha": "b3068cacd04641e9612619590bc96dce33cb459d", "filename": "src/ci/docker/x86_64-musl/Dockerfile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -18,6 +18,11 @@ WORKDIR /build/\n COPY build-musl.sh /build/\n RUN sh /build/build-musl.sh && rm -rf /build\n \n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n ENV RUST_CONFIGURE_ARGS \\\n       --target=x86_64-unknown-linux-musl \\\n       --musl-root-x86_64=/musl-x86_64"}, {"sha": "664bc0fdab0025c0e5111f448cb7f0c8ba7aa2ac", "filename": "src/doc/rust.css", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -44,7 +44,9 @@\n     font-family: 'Source Code Pro';\n     font-style: normal;\n     font-weight: 400;\n-    src: local('Source Code Pro'), url(\"SourceCodePro-Regular.woff\") format('woff');\n+    /* Avoid using locally installed font because bad versions are in circulation:\n+     * see https://github.com/rust-lang/rust/issues/24355 */\n+    src: url(\"SourceCodePro-Regular.woff\") format('woff');\n }\n \n *:not(body) {"}, {"sha": "e3ca8eca76c570979eaa607bb4f422368985863d", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -117,6 +117,8 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n /// because it will attempt to drop the value previously at `*src`.\n ///\n+/// The pointer must be aligned; use `read_unaligned` if that is not the case.\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -137,6 +139,44 @@ pub unsafe fn read<T>(src: *const T) -> T {\n     tmp\n }\n \n+/// Reads the value from `src` without moving it. This leaves the\n+/// memory in `src` unchanged.\n+///\n+/// Unlike `read`, the pointer may be unaligned.\n+///\n+/// # Safety\n+///\n+/// Beyond accepting a raw pointer, this is unsafe because it semantically\n+/// moves the value out of `src` without preventing further usage of `src`.\n+/// If `T` is not `Copy`, then care must be taken to ensure that the value at\n+/// `src` is not used before the data is overwritten again (e.g. with `write`,\n+/// `zero_memory`, or `copy_memory`). Note that `*src = foo` counts as a use\n+/// because it will attempt to drop the value previously at `*src`.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(ptr_unaligned)]\n+///\n+/// let x = 12;\n+/// let y = &x as *const i32;\n+///\n+/// unsafe {\n+///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+/// }\n+/// ```\n+#[inline(always)]\n+#[unstable(feature = \"ptr_unaligned\", issue = \"37955\")]\n+pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n+    let mut tmp: T = mem::uninitialized();\n+    copy_nonoverlapping(src as *const u8,\n+                        &mut tmp as *mut T as *mut u8,\n+                        mem::size_of::<T>());\n+    tmp\n+}\n+\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n@@ -151,6 +191,8 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been `read` from.\n ///\n+/// The pointer must be aligned; use `write_unaligned` if that is not the case.\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -171,6 +213,47 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n+/// Overwrites a memory location with the given value without reading or\n+/// dropping the old value.\n+///\n+/// Unlike `write`, the pointer may be unaligned.\n+///\n+/// # Safety\n+///\n+/// This operation is marked unsafe because it accepts a raw pointer.\n+///\n+/// It does not drop the contents of `dst`. This is safe, but it could leak\n+/// allocations or resources, so care must be taken not to overwrite an object\n+/// that should be dropped.\n+///\n+/// This is appropriate for initializing uninitialized memory, or overwriting\n+/// memory that has previously been `read` from.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(ptr_unaligned)]\n+///\n+/// let mut x = 0;\n+/// let y = &mut x as *mut i32;\n+/// let z = 12;\n+///\n+/// unsafe {\n+///     std::ptr::write_unaligned(y, z);\n+///     assert_eq!(std::ptr::read_unaligned(y), 12);\n+/// }\n+/// ```\n+#[inline]\n+#[unstable(feature = \"ptr_unaligned\", issue = \"37955\")]\n+pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n+    copy_nonoverlapping(&src as *const T as *const u8,\n+                        dst as *mut u8,\n+                        mem::size_of::<T>());\n+    mem::forget(src);\n+}\n+\n /// Performs a volatile read of the value from `src` without moving it. This\n /// leaves the memory in `src` unchanged.\n ///"}, {"sha": "05d98d4a2128d5657c3d00b5c8e7b55499117943", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -36,6 +36,7 @@\n #![feature(iter_min_by)]\n #![feature(ordering_chaining)]\n #![feature(result_unwrap_or_default)]\n+#![feature(ptr_unaligned)]\n \n extern crate core;\n extern crate test;"}, {"sha": "7f6f472bfbb78ea5588f7a770a61792f95bc6f1a", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::ptr::*;\n+use core::cell::RefCell;\n \n #[test]\n fn test() {\n@@ -189,3 +190,25 @@ pub fn test_variadic_fnptr() {\n     let mut s = SipHasher::new();\n     assert_eq!(p.hash(&mut s), q.hash(&mut s));\n }\n+\n+#[test]\n+fn write_unaligned_drop() {\n+    thread_local! {\n+        static DROPS: RefCell<Vec<u32>> = RefCell::new(Vec::new());\n+    }\n+\n+    struct Dropper(u32);\n+\n+    impl Drop for Dropper {\n+        fn drop(&mut self) {\n+            DROPS.with(|d| d.borrow_mut().push(self.0));\n+        }\n+    }\n+\n+    {\n+        let c = Dropper(0);\n+        let mut t = Dropper(1);\n+        unsafe { write_unaligned(&mut t, c); }\n+    }\n+    DROPS.with(|d| assert_eq!(*d.borrow(), [0]));\n+}"}, {"sha": "4359581a897f57153df7e6179f8bb9f4ba553548", "filename": "src/librustc_data_structures/base_n.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_data_structures%2Fbase_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_data_structures%2Fbase_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbase_n.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -14,6 +14,8 @@\n use std::str;\n \n pub const MAX_BASE: u64 = 64;\n+pub const ALPHANUMERIC_ONLY: u64 = 62;\n+\n const BASE_64: &'static [u8; MAX_BASE as usize] =\n     b\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@$\";\n "}, {"sha": "f3d4c17654dcc7a0f650ff0c849ad539eccd631a", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -1417,7 +1417,8 @@ extern \"C\" {\n                                                  Ty: DIType,\n                                                  isLocalToUnit: bool,\n                                                  Val: ValueRef,\n-                                                 Decl: DIDescriptor)\n+                                                 Decl: DIDescriptor,\n+                                                 AlignInBits: u64)\n                                                  -> DIGlobalVariable;\n \n     pub fn LLVMRustDIBuilderCreateVariable(Builder: DIBuilderRef,\n@@ -1429,7 +1430,8 @@ extern \"C\" {\n                                            Ty: DIType,\n                                            AlwaysPreserve: bool,\n                                            Flags: DIFlags,\n-                                           ArgNo: c_uint)\n+                                           ArgNo: c_uint,\n+                                           AlignInBits: u64)\n                                            -> DIVariable;\n \n     pub fn LLVMRustDIBuilderCreateArrayType(Builder: DIBuilderRef,"}, {"sha": "539c05b71bb1c13ce59c7043fe48d13013080c33", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -44,7 +44,7 @@ use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, NodeId};\n use syntax::codemap;\n-use syntax_pos::{self, Span, BytePos, Pos};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Decoder<'a>,\n@@ -515,7 +515,12 @@ impl<'tcx> EntryKind<'tcx> {\n }\n \n impl<'a, 'tcx> CrateMetadata {\n+    fn is_proc_macro(&self, id: DefIndex) -> bool {\n+        self.proc_macros.is_some() && id != CRATE_DEF_INDEX\n+    }\n+\n     fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n+        assert!(!self.is_proc_macro(item_id));\n         self.root.index.lookup(self.blob.raw_bytes(), item_id)\n     }\n \n@@ -548,18 +553,17 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_def(&self, index: DefIndex) -> Option<Def> {\n-        if self.proc_macros.is_some() {\n-            Some(match index {\n-                CRATE_DEF_INDEX => Def::Mod(self.local_def_id(index)),\n-                _ => Def::Macro(self.local_def_id(index)),\n-            })\n-        } else {\n-            self.entry(index).kind.to_def(self.local_def_id(index))\n+        match self.is_proc_macro(index) {\n+            true => Some(Def::Macro(self.local_def_id(index))),\n+            false => self.entry(index).kind.to_def(self.local_def_id(index)),\n         }\n     }\n \n     pub fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        self.entry(index).span.decode((self, sess))\n+        match self.is_proc_macro(index) {\n+            true => DUMMY_SP,\n+            false => self.entry(index).span.decode((self, sess)),\n+        }\n     }\n \n     pub fn get_trait_def(&self,\n@@ -670,23 +674,23 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n-        match self.proc_macros {\n-            Some(_) if id != CRATE_DEF_INDEX => None,\n-            _ => self.entry(id).stability.map(|stab| stab.decode(self)),\n+        match self.is_proc_macro(id) {\n+            true => None,\n+            false => self.entry(id).stability.map(|stab| stab.decode(self)),\n         }\n     }\n \n     pub fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n-        match self.proc_macros {\n-            Some(_) if id != CRATE_DEF_INDEX => None,\n-            _ => self.entry(id).deprecation.map(|depr| depr.decode(self)),\n+        match self.is_proc_macro(id) {\n+            true => None,\n+            false => self.entry(id).deprecation.map(|depr| depr.decode(self)),\n         }\n     }\n \n     pub fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n-        match self.proc_macros {\n-            Some(_) => ty::Visibility::Public,\n-            _ => self.entry(id).visibility,\n+        match self.is_proc_macro(id) {\n+            true => ty::Visibility::Public,\n+            false => self.entry(id).visibility,\n         }\n     }\n \n@@ -832,6 +836,7 @@ impl<'a, 'tcx> CrateMetadata {\n                               id: DefIndex)\n                               -> Option<&'tcx InlinedItem> {\n         debug!(\"Looking up item: {:?}\", id);\n+        if self.is_proc_macro(id) { return None; }\n         let item_doc = self.entry(id);\n         let item_did = self.local_def_id(id);\n         let parent_def_id = self.local_def_id(self.def_key(id).parent.unwrap());\n@@ -844,6 +849,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n+        !self.is_proc_macro(id) &&\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n@@ -874,7 +880,10 @@ impl<'a, 'tcx> CrateMetadata {\n                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               id: DefIndex)\n                               -> Option<Mir<'tcx>> {\n-        self.entry(id).mir.map(|mir| mir.decode((self, tcx)))\n+        match self.is_proc_macro(id) {\n+            true => None,\n+            false => self.entry(id).mir.map(|mir| mir.decode((self, tcx))),\n+        }\n     }\n \n     pub fn get_associated_item(&self, id: DefIndex) -> Option<ty::AssociatedItem> {\n@@ -950,7 +959,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_item_attrs(&self, node_id: DefIndex) -> Vec<ast::Attribute> {\n-        if self.proc_macros.is_some() && node_id != CRATE_DEF_INDEX {\n+        if self.is_proc_macro(node_id) {\n             return Vec::new();\n         }\n         // The attributes for a tuple struct are attached to the definition, not the ctor;\n@@ -1131,15 +1140,26 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn def_key(&self, id: DefIndex) -> hir_map::DefKey {\n         debug!(\"def_key: id={:?}\", id);\n-        self.entry(id).def_key.decode(self)\n+        if self.is_proc_macro(id) {\n+            let name = self.proc_macros.as_ref().unwrap()[id.as_usize() - 1].0;\n+            hir_map::DefKey {\n+                parent: Some(CRATE_DEF_INDEX),\n+                disambiguated_data: hir_map::DisambiguatedDefPathData {\n+                    data: hir_map::DefPathData::MacroDef(name.as_str()),\n+                    disambiguator: 0,\n+                },\n+            }\n+        } else {\n+            self.entry(id).def_key.decode(self)\n+        }\n     }\n \n     // Returns the path leading to the thing with this `id`. Note that\n     // some def-ids don't wind up in the metadata, so `def_path` sometimes\n     // returns `None`\n     pub fn def_path(&self, id: DefIndex) -> Option<hir_map::DefPath> {\n         debug!(\"def_path(id={:?})\", id);\n-        if self.maybe_entry(id).is_some() {\n+        if self.is_proc_macro(id) || self.maybe_entry(id).is_some() {\n             Some(hir_map::DefPath::make(self.cnum, id, |parent| self.def_key(parent)))\n         } else {\n             None"}, {"sha": "b355c8f2c4c6f57be318a2143a50e7cb61c31220", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -26,47 +26,52 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n             extent: cx.tcx.region_maps.node_extent(self.id),\n             span: self.span,\n             stmts: stmts,\n-            expr: self.expr.to_ref()\n+            expr: self.expr.to_ref(),\n         }\n     }\n }\n \n fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 block_id: ast::NodeId,\n                                 stmts: &'tcx [hir::Stmt])\n-                                -> Vec<StmtRef<'tcx>>\n-{\n+                                -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n         match stmt.node {\n-            hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) =>\n+            hir::StmtExpr(ref expr, id) |\n+            hir::StmtSemi(ref expr, id) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     span: stmt.span,\n                     kind: StmtKind::Expr {\n                         scope: cx.tcx.region_maps.node_extent(id),\n-                        expr: expr.to_ref()\n+                        expr: expr.to_ref(),\n+                    },\n+                })))\n+            }\n+            hir::StmtDecl(ref decl, id) => {\n+                match decl.node {\n+                    hir::DeclItem(..) => {\n+                        // ignore for purposes of the MIR\n                     }\n-                }))),\n-            hir::StmtDecl(ref decl, id) => match decl.node {\n-                hir::DeclItem(..) => { /* ignore for purposes of the MIR */ }\n-                hir::DeclLocal(ref local) => {\n-                    let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n-                        block: block_id,\n-                        first_statement_index: index as u32,\n-                    });\n-                    let remainder_extent =\n-                        cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n+                    hir::DeclLocal(ref local) => {\n+                        let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n+                            block: block_id,\n+                            first_statement_index: index as u32,\n+                        });\n+                        let remainder_extent =\n+                            cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n \n-                    let pattern = Pattern::from_hir(cx.tcx, &local.pat);\n-                    result.push(StmtRef::Mirror(Box::new(Stmt {\n-                        span: stmt.span,\n-                        kind: StmtKind::Let {\n-                            remainder_scope: remainder_extent,\n-                            init_scope: cx.tcx.region_maps.node_extent(id),\n-                            pattern: pattern,\n-                            initializer: local.init.to_ref(),\n-                        },\n-                    })));\n+                        let pattern = Pattern::from_hir(cx.tcx, &local.pat);\n+                        result.push(StmtRef::Mirror(Box::new(Stmt {\n+                            span: stmt.span,\n+                            kind: StmtKind::Let {\n+                                remainder_scope: remainder_extent,\n+                                init_scope: cx.tcx.region_maps.node_extent(id),\n+                                pattern: pattern,\n+                                initializer: local.init.to_ref(),\n+                            },\n+                        })));\n+                    }\n                 }\n             }\n         }"}, {"sha": "d579cdb042fb3f3b7d4075beacff0eef321d121b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 307, "deletions": 258, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -36,7 +36,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         let adj = cx.tcx.tables().adjustments.get(&self.id).cloned();\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n-               expr, adj);\n+               expr,\n+               adj);\n \n         // Now apply adjustments, if any.\n         match adj.map(|adj| (adj.kind, adj.target)) {\n@@ -78,41 +79,44 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 for i in 0..autoderefs {\n                     let i = i as u32;\n                     let adjusted_ty =\n-                        expr.ty.adjust_for_autoderef(\n-                            cx.tcx,\n-                            self.id,\n-                            self.span,\n-                            i,\n-                            |mc| cx.tcx.tables().method_map.get(&mc).map(|m| m.ty));\n-                    debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\", i, adjusted_ty);\n+                        expr.ty.adjust_for_autoderef(cx.tcx, self.id, self.span, i, |mc| {\n+                            cx.tcx.tables().method_map.get(&mc).map(|m| m.ty)\n+                        });\n+                    debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\",\n+                           i,\n+                           adjusted_ty);\n                     let method_key = ty::MethodCall::autoderef(self.id, i);\n-                    let meth_ty =\n-                        cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n+                    let meth_ty = cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n                     let kind = if let Some(meth_ty) = meth_ty {\n                         debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n \n                         let ref_ty = cx.tcx.no_late_bound_regions(&meth_ty.fn_ret());\n                         let (region, mutbl) = match ref_ty {\n-                            Some(&ty::TyS {\n-                                sty: ty::TyRef(region, mt), ..\n-                            }) => (region, mt.mutbl),\n-                            _ => span_bug!(expr.span, \"autoderef returned bad type\")\n+                            Some(&ty::TyS { sty: ty::TyRef(region, mt), .. }) => (region, mt.mutbl),\n+                            _ => span_bug!(expr.span, \"autoderef returned bad type\"),\n                         };\n \n                         expr = Expr {\n                             temp_lifetime: temp_lifetime,\n-                            ty: cx.tcx.mk_ref(\n-                                region, ty::TypeAndMut { ty: expr.ty, mutbl: mutbl }),\n+                            ty: cx.tcx.mk_ref(region,\n+                                              ty::TypeAndMut {\n+                                                  ty: expr.ty,\n+                                                  mutbl: mutbl,\n+                                              }),\n                             span: expr.span,\n                             kind: ExprKind::Borrow {\n                                 region: region,\n                                 borrow_kind: to_borrow_kind(mutbl),\n-                                arg: expr.to_ref()\n-                            }\n+                                arg: expr.to_ref(),\n+                            },\n                         };\n \n-                        overloaded_lvalue(cx, self, method_key,\n-                                          PassArgs::ByRef, expr.to_ref(), vec![])\n+                        overloaded_lvalue(cx,\n+                                          self,\n+                                          method_key,\n+                                          PassArgs::ByRef,\n+                                          expr.to_ref(),\n+                                          vec![])\n                     } else {\n                         debug!(\"make_mirror: built-in autoderef\");\n                         ExprKind::Deref { arg: expr.to_ref() }\n@@ -148,7 +152,11 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                             let region = cx.tcx.mk_region(region);\n                             expr = Expr {\n                                 temp_lifetime: temp_lifetime,\n-                                ty: cx.tcx.mk_ref(region, ty::TypeAndMut { ty: expr.ty, mutbl: m }),\n+                                ty: cx.tcx.mk_ref(region,\n+                                                  ty::TypeAndMut {\n+                                                      ty: expr.ty,\n+                                                      mutbl: m,\n+                                                  }),\n                                 span: self.span,\n                                 kind: ExprKind::Borrow {\n                                     region: region,\n@@ -240,57 +248,62 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n                 let sig = match method.ty.sty {\n                     ty::TyFnDef(.., fn_ty) => &fn_ty.sig,\n-                    _ => span_bug!(expr.span, \"type of method is not an fn\")\n+                    _ => span_bug!(expr.span, \"type of method is not an fn\"),\n                 };\n \n-                let sig = cx.tcx.no_late_bound_regions(sig).unwrap_or_else(|| {\n-                    span_bug!(expr.span, \"method call has late-bound regions\")\n-                });\n+                let sig = cx.tcx\n+                    .no_late_bound_regions(sig)\n+                    .unwrap_or_else(|| span_bug!(expr.span, \"method call has late-bound regions\"));\n \n                 assert_eq!(sig.inputs().len(), 2);\n \n                 let tupled_args = Expr {\n                     ty: sig.inputs()[1],\n                     temp_lifetime: temp_lifetime,\n                     span: expr.span,\n-                    kind: ExprKind::Tuple {\n-                        fields: args.iter().map(ToRef::to_ref).collect()\n-                    }\n+                    kind: ExprKind::Tuple { fields: args.iter().map(ToRef::to_ref).collect() },\n                 };\n \n                 ExprKind::Call {\n                     ty: method.ty,\n                     fun: method.to_ref(),\n-                    args: vec![fun.to_ref(), tupled_args.to_ref()]\n+                    args: vec![fun.to_ref(), tupled_args.to_ref()],\n                 }\n             } else {\n                 let adt_data = if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = fun.node {\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n-                    expr_ty.ty_adt_def().and_then(|adt_def|{\n+                    expr_ty.ty_adt_def().and_then(|adt_def| {\n                         match path.def {\n                             Def::VariantCtor(variant_id, CtorKind::Fn) => {\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n-                            },\n-                            Def::StructCtor(_, CtorKind::Fn) => {\n-                                Some((adt_def, 0))\n-                            },\n-                            _ => None\n+                            }\n+                            Def::StructCtor(_, CtorKind::Fn) => Some((adt_def, 0)),\n+                            _ => None,\n                         }\n                     })\n-                } else { None };\n+                } else {\n+                    None\n+                };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tcx.tables().node_id_item_substs(fun.id)\n+                    let substs = cx.tcx\n+                        .tables()\n+                        .node_id_item_substs(fun.id)\n                         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n-                    let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n-                        name: Field::new(idx),\n-                        expr: e.to_ref()\n-                    }).collect();\n+                    let field_refs = args.iter()\n+                        .enumerate()\n+                        .map(|(idx, e)| {\n+                            FieldExprRef {\n+                                name: Field::new(idx),\n+                                expr: e.to_ref(),\n+                            }\n+                        })\n+                        .collect();\n                     ExprKind::Adt {\n                         adt_def: adt_def,\n                         substs: substs,\n                         variant_index: index,\n                         fields: field_refs,\n-                        base: None\n+                        base: None,\n                     }\n                 } else {\n                     ExprKind::Call {\n@@ -314,9 +327,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprBlock(ref blk) => {\n-            ExprKind::Block { body: &blk }\n-        }\n+        hir::ExprBlock(ref blk) => ExprKind::Block { body: &blk },\n \n         hir::ExprAssign(ref lhs, ref rhs) => {\n             ExprKind::Assign {\n@@ -332,8 +343,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 } else {\n                     PassArgs::ByRef\n                 };\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    pass_args, lhs.to_ref(), vec![rhs])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    pass_args,\n+                                    lhs.to_ref(),\n+                                    vec![rhs])\n             } else {\n                 ExprKind::AssignOp {\n                     op: bin_op(op.node),\n@@ -343,9 +358,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprLit(..) => ExprKind::Literal {\n-            literal: cx.const_eval_literal(expr)\n-        },\n+        hir::ExprLit(..) => ExprKind::Literal { literal: cx.const_eval_literal(expr) },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n@@ -354,8 +367,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 } else {\n                     PassArgs::ByRef\n                 };\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    pass_args, lhs.to_ref(), vec![rhs])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    pass_args,\n+                                    lhs.to_ref(),\n+                                    vec![rhs])\n             } else {\n                 // FIXME overflow\n                 match (op.node, cx.constness) {\n@@ -405,8 +422,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprIndex(ref lhs, ref index) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n-                                  PassArgs::ByValue, lhs.to_ref(), vec![index])\n+                overloaded_lvalue(cx,\n+                                  expr,\n+                                  ty::MethodCall::expr(expr.id),\n+                                  PassArgs::ByValue,\n+                                  lhs.to_ref(),\n+                                  vec![index])\n             } else {\n                 ExprKind::Index {\n                     lhs: lhs.to_ref(),\n@@ -417,17 +438,25 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n-                                  PassArgs::ByValue, arg.to_ref(), vec![])\n+                overloaded_lvalue(cx,\n+                                  expr,\n+                                  ty::MethodCall::expr(expr.id),\n+                                  PassArgs::ByValue,\n+                                  arg.to_ref(),\n+                                  vec![])\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    PassArgs::ByValue, arg.to_ref(), vec![])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    PassArgs::ByValue,\n+                                    arg.to_ref(),\n+                                    vec![])\n             } else {\n                 ExprKind::Unary {\n                     op: UnOp::Not,\n@@ -438,14 +467,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n             if cx.tcx.tables().is_method_call(expr.id) {\n-                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n-                                    PassArgs::ByValue, arg.to_ref(), vec![])\n+                overloaded_operator(cx,\n+                                    expr,\n+                                    ty::MethodCall::expr(expr.id),\n+                                    PassArgs::ByValue,\n+                                    arg.to_ref(),\n+                                    vec![])\n             } else {\n                 // FIXME runtime-overflow\n                 if let hir::ExprLit(_) = arg.node {\n-                    ExprKind::Literal {\n-                        literal: cx.const_eval_literal(expr),\n-                    }\n+                    ExprKind::Literal { literal: cx.const_eval_literal(expr) }\n                 } else {\n                     ExprKind::Unary {\n                         op: UnOp::Neg,\n@@ -457,56 +488,54 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprStruct(ref qpath, ref fields, ref base) => {\n             match expr_ty.sty {\n-                ty::TyAdt(adt, substs) => match adt.adt_kind() {\n-                    AdtKind::Struct | AdtKind::Union => {\n-                        let field_refs = field_refs(&adt.variants[0], fields);\n-                        ExprKind::Adt {\n-                            adt_def: adt,\n-                            variant_index: 0,\n-                            substs: substs,\n-                            fields: field_refs,\n-                            base: base.as_ref().map(|base| {\n-                                FruInfo {\n-                                    base: base.to_ref(),\n-                                    field_types:\n-                                        cx.tcx.tables().fru_field_types[&expr.id].clone()\n-                                }\n-                            })\n+                ty::TyAdt(adt, substs) => {\n+                    match adt.adt_kind() {\n+                        AdtKind::Struct | AdtKind::Union => {\n+                            let field_refs = field_refs(&adt.variants[0], fields);\n+                            ExprKind::Adt {\n+                                adt_def: adt,\n+                                variant_index: 0,\n+                                substs: substs,\n+                                fields: field_refs,\n+                                base: base.as_ref().map(|base| {\n+                                    FruInfo {\n+                                        base: base.to_ref(),\n+                                        field_types: cx.tcx.tables().fru_field_types[&expr.id]\n+                                            .clone(),\n+                                    }\n+                                }),\n+                            }\n                         }\n-                    }\n-                    AdtKind::Enum => {\n-                        let def = match *qpath {\n-                            hir::QPath::Resolved(_, ref path) => path.def,\n-                            hir::QPath::TypeRelative(..) => Def::Err\n-                        };\n-                        match def {\n-                            Def::Variant(variant_id) => {\n-                                assert!(base.is_none());\n-\n-                                let index = adt.variant_index_with_id(variant_id);\n-                                let field_refs = field_refs(&adt.variants[index], fields);\n-                                ExprKind::Adt {\n-                                    adt_def: adt,\n-                                    variant_index: index,\n-                                    substs: substs,\n-                                    fields: field_refs,\n-                                    base: None\n+                        AdtKind::Enum => {\n+                            let def = match *qpath {\n+                                hir::QPath::Resolved(_, ref path) => path.def,\n+                                hir::QPath::TypeRelative(..) => Def::Err,\n+                            };\n+                            match def {\n+                                Def::Variant(variant_id) => {\n+                                    assert!(base.is_none());\n+\n+                                    let index = adt.variant_index_with_id(variant_id);\n+                                    let field_refs = field_refs(&adt.variants[index], fields);\n+                                    ExprKind::Adt {\n+                                        adt_def: adt,\n+                                        variant_index: index,\n+                                        substs: substs,\n+                                        fields: field_refs,\n+                                        base: None,\n+                                    }\n+                                }\n+                                _ => {\n+                                    span_bug!(expr.span, \"unexpected def: {:?}\", def);\n                                 }\n-                            }\n-                            _ => {\n-                                span_bug!(\n-                                    expr.span,\n-                                    \"unexpected def: {:?}\",\n-                                    def);\n                             }\n                         }\n                     }\n-                },\n+                }\n                 _ => {\n-                    span_bug!(\n-                        expr.span,\n-                        \"unexpected type for struct literal: {:?}\",\n-                        expr_ty);\n+                    span_bug!(expr.span,\n+                              \"unexpected type for struct literal: {:?}\",\n+                              expr_ty);\n                 }\n             }\n         }\n@@ -516,9 +545,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let (def_id, substs) = match closure_ty.sty {\n                 ty::TyClosure(def_id, substs) => (def_id, substs),\n                 _ => {\n-                    span_bug!(expr.span,\n-                              \"closure expr w/o closure type: {:?}\",\n-                              closure_ty);\n+                    span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n             };\n             let upvars = cx.tcx.with_freevars(expr.id, |freevars| {\n@@ -543,69 +570,81 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::InlineAsm {\n                 asm: asm,\n                 outputs: outputs.to_ref(),\n-                inputs: inputs.to_ref()\n+                inputs: inputs.to_ref(),\n             }\n         }\n \n         // Now comes the rote stuff:\n-\n-        hir::ExprRepeat(ref v, ref c) => ExprKind::Repeat {\n-            value: v.to_ref(),\n-            count: TypedConstVal {\n-                ty: cx.tcx.tables().expr_ty(c),\n-                span: c.span,\n-                value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n-                    ConstVal::Integral(ConstInt::Usize(u)) => u,\n-                    other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n+        hir::ExprRepeat(ref v, ref c) => {\n+            ExprKind::Repeat {\n+                value: v.to_ref(),\n+                count: TypedConstVal {\n+                    ty: cx.tcx.tables().expr_ty(c),\n+                    span: c.span,\n+                    value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n+                        ConstVal::Integral(ConstInt::Usize(u)) => u,\n+                        other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n+                    },\n                 },\n             }\n-        },\n-        hir::ExprRet(ref v) =>\n-            ExprKind::Return { value: v.to_ref() },\n-        hir::ExprBreak(label, ref value) =>\n+        }\n+        hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n+        hir::ExprBreak(label, ref value) => {\n             ExprKind::Break {\n-                label: label.map(|label| {\n-                    cx.tcx.region_maps.node_extent(label.loop_id)\n-                }),\n-                value: value.to_ref()\n-            },\n-        hir::ExprAgain(label) =>\n+                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n+                value: value.to_ref(),\n+            }\n+        }\n+        hir::ExprAgain(label) => {\n             ExprKind::Continue {\n-                label: label.map(|label| {\n-                    cx.tcx.region_maps.node_extent(label.loop_id)\n-                })\n-            },\n-        hir::ExprMatch(ref discr, ref arms, _) =>\n-            ExprKind::Match { discriminant: discr.to_ref(),\n-                              arms: arms.iter().map(|a| convert_arm(cx, a)).collect() },\n-        hir::ExprIf(ref cond, ref then, ref otherwise) =>\n-            ExprKind::If { condition: cond.to_ref(),\n-                           then: block::to_expr_ref(cx, then),\n-                           otherwise: otherwise.to_ref() },\n-        hir::ExprWhile(ref cond, ref body, _) =>\n-            ExprKind::Loop { condition: Some(cond.to_ref()),\n-                             body: block::to_expr_ref(cx, body) },\n-        hir::ExprLoop(ref body, _, _) =>\n-            ExprKind::Loop { condition: None,\n-                             body: block::to_expr_ref(cx, body) },\n+                label: label.map(|label| cx.tcx.region_maps.node_extent(label.loop_id)),\n+            }\n+        }\n+        hir::ExprMatch(ref discr, ref arms, _) => {\n+            ExprKind::Match {\n+                discriminant: discr.to_ref(),\n+                arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n+            }\n+        }\n+        hir::ExprIf(ref cond, ref then, ref otherwise) => {\n+            ExprKind::If {\n+                condition: cond.to_ref(),\n+                then: block::to_expr_ref(cx, then),\n+                otherwise: otherwise.to_ref(),\n+            }\n+        }\n+        hir::ExprWhile(ref cond, ref body, _) => {\n+            ExprKind::Loop {\n+                condition: Some(cond.to_ref()),\n+                body: block::to_expr_ref(cx, body),\n+            }\n+        }\n+        hir::ExprLoop(ref body, _, _) => {\n+            ExprKind::Loop {\n+                condition: None,\n+                body: block::to_expr_ref(cx, body),\n+            }\n+        }\n         hir::ExprField(ref source, name) => {\n             let index = match cx.tcx.tables().expr_ty_adjusted(source).sty {\n-                ty::TyAdt(adt_def, _) =>\n-                    adt_def.variants[0].index_of_field_named(name.node),\n-                ref ty =>\n-                    span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n+                ty::TyAdt(adt_def, _) => adt_def.variants[0].index_of_field_named(name.node),\n+                ref ty => span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n             };\n-            let index = index.unwrap_or_else(|| {\n-                span_bug!(\n-                    expr.span,\n-                    \"no index found for field `{}`\",\n-                    name.node)\n-            });\n-            ExprKind::Field { lhs: source.to_ref(), name: Field::new(index) }\n+            let index =\n+                index.unwrap_or_else(|| {\n+                    span_bug!(expr.span, \"no index found for field `{}`\", name.node)\n+                });\n+            ExprKind::Field {\n+                lhs: source.to_ref(),\n+                name: Field::new(index),\n+            }\n+        }\n+        hir::ExprTupField(ref source, index) => {\n+            ExprKind::Field {\n+                lhs: source.to_ref(),\n+                name: Field::new(index.node as usize),\n+            }\n         }\n-        hir::ExprTupField(ref source, index) =>\n-            ExprKind::Field { lhs: source.to_ref(),\n-                              name: Field::new(index.node as usize) },\n         hir::ExprCast(ref source, _) => {\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n@@ -616,17 +655,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ExprKind::Cast { source: source.to_ref() }\n             }\n         }\n-        hir::ExprType(ref source, _) =>\n-            return source.make_mirror(cx),\n-        hir::ExprBox(ref value) =>\n+        hir::ExprType(ref source, _) => return source.make_mirror(cx),\n+        hir::ExprBox(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),\n-                value_extents: cx.tcx.region_maps.node_extent(value.id)\n-            },\n-        hir::ExprArray(ref fields) =>\n-            ExprKind::Vec { fields: fields.to_ref() },\n-        hir::ExprTup(ref fields) =>\n-            ExprKind::Tuple { fields: fields.to_ref() },\n+                value_extents: cx.tcx.region_maps.node_extent(value.id),\n+            }\n+        }\n+        hir::ExprArray(ref fields) => ExprKind::Vec { fields: fields.to_ref() },\n+        hir::ExprTup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n     };\n \n     Expr {\n@@ -663,8 +700,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                               arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n         patterns: arm.pats.iter().map(|p| Pattern::from_hir(cx.tcx, p)).collect(),\n         guard: arm.guard.to_ref(),\n@@ -676,41 +712,48 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tcx.tables().node_id_item_substs(expr.id)\n+    let substs = cx.tcx\n+        .tables()\n+        .node_id_item_substs(expr.id)\n         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n     let def_id = match def {\n         // A regular function, constructor function or a constant.\n-        Def::Fn(def_id) | Def::Method(def_id) |\n+        Def::Fn(def_id) |\n+        Def::Method(def_id) |\n         Def::StructCtor(def_id, CtorKind::Fn) |\n         Def::VariantCtor(def_id, CtorKind::Fn) |\n-        Def::Const(def_id) | Def::AssociatedConst(def_id) => def_id,\n+        Def::Const(def_id) |\n+        Def::AssociatedConst(def_id) => def_id,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n             match cx.tcx.tables().node_id_to_type(expr.id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n-                ty::TyAdt(adt_def, substs) => return ExprKind::Adt {\n-                    adt_def: adt_def,\n-                    variant_index: adt_def.variant_index_with_id(def_id),\n-                    substs: substs,\n-                    fields: vec![],\n-                    base: None,\n-                },\n-                ref sty => bug!(\"unexpected sty: {:?}\", sty)\n+                ty::TyAdt(adt_def, substs) => {\n+                    return ExprKind::Adt {\n+                        adt_def: adt_def,\n+                        variant_index: adt_def.variant_index_with_id(def_id),\n+                        substs: substs,\n+                        fields: vec![],\n+                        base: None,\n+                    }\n+                }\n+                ref sty => bug!(\"unexpected sty: {:?}\", sty),\n             }\n         }\n \n-        Def::Static(node_id, _) => return ExprKind::StaticRef {\n-            id: node_id,\n-        },\n+        Def::Static(node_id, _) => return ExprKind::StaticRef { id: node_id },\n \n         Def::Local(..) | Def::Upvar(..) => return convert_var(cx, expr, def),\n \n         _ => span_bug!(expr.span, \"def `{:?}` not yet implemented\", def),\n     };\n     ExprKind::Literal {\n-        literal: Literal::Item { def_id: def_id, substs: substs }\n+        literal: Literal::Item {\n+            def_id: def_id,\n+            substs: substs,\n+        },\n     }\n }\n \n@@ -723,14 +766,15 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     match def {\n         Def::Local(def_id) => {\n             let node_id = cx.tcx.map.as_local_node_id(def_id).unwrap();\n-            ExprKind::VarRef {\n-                id: node_id,\n-            }\n+            ExprKind::VarRef { id: node_id }\n         }\n \n         Def::Upvar(def_id, index, closure_expr_id) => {\n             let id_var = cx.tcx.map.as_local_node_id(def_id).unwrap();\n-            debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\", id_var, index, closure_expr_id);\n+            debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\",\n+                   id_var,\n+                   index,\n+                   closure_expr_id);\n             let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n \n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n@@ -761,41 +805,45 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n             let self_expr = match cx.tcx.closure_kind(cx.tcx.map.local_def_id(closure_expr_id)) {\n                 ty::ClosureKind::Fn => {\n-                    let ref_closure_ty =\n-                        cx.tcx.mk_ref(region,\n-                                   ty::TypeAndMut { ty: closure_ty,\n-                                                    mutbl: hir::MutImmutable });\n+                    let ref_closure_ty = cx.tcx.mk_ref(region,\n+                                                       ty::TypeAndMut {\n+                                                           ty: closure_ty,\n+                                                           mutbl: hir::MutImmutable,\n+                                                       });\n                     Expr {\n                         ty: closure_ty,\n                         temp_lifetime: temp_lifetime,\n                         span: expr.span,\n                         kind: ExprKind::Deref {\n                             arg: Expr {\n-                                ty: ref_closure_ty,\n-                                temp_lifetime: temp_lifetime,\n-                                span: expr.span,\n-                                kind: ExprKind::SelfRef\n-                            }.to_ref()\n-                        }\n+                                    ty: ref_closure_ty,\n+                                    temp_lifetime: temp_lifetime,\n+                                    span: expr.span,\n+                                    kind: ExprKind::SelfRef,\n+                                }\n+                                .to_ref(),\n+                        },\n                     }\n                 }\n                 ty::ClosureKind::FnMut => {\n-                    let ref_closure_ty =\n-                        cx.tcx.mk_ref(region,\n-                                   ty::TypeAndMut { ty: closure_ty,\n-                                                    mutbl: hir::MutMutable });\n+                    let ref_closure_ty = cx.tcx.mk_ref(region,\n+                                                       ty::TypeAndMut {\n+                                                           ty: closure_ty,\n+                                                           mutbl: hir::MutMutable,\n+                                                       });\n                     Expr {\n                         ty: closure_ty,\n                         temp_lifetime: temp_lifetime,\n                         span: expr.span,\n                         kind: ExprKind::Deref {\n                             arg: Expr {\n-                                ty: ref_closure_ty,\n-                                temp_lifetime: temp_lifetime,\n-                                span: expr.span,\n-                                kind: ExprKind::SelfRef\n-                            }.to_ref()\n-                        }\n+                                    ty: ref_closure_ty,\n+                                    temp_lifetime: temp_lifetime,\n+                                    span: expr.span,\n+                                    kind: ExprKind::SelfRef,\n+                                }\n+                                .to_ref(),\n+                        },\n                     }\n                 }\n                 ty::ClosureKind::FnOnce => {\n@@ -823,26 +871,24 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let upvar_capture = match cx.tcx.tables().upvar_capture(upvar_id) {\n                 Some(c) => c,\n                 None => {\n-                    span_bug!(\n-                        expr.span,\n-                        \"no upvar_capture for {:?}\",\n-                        upvar_id);\n+                    span_bug!(expr.span, \"no upvar_capture for {:?}\", upvar_id);\n                 }\n             };\n             match upvar_capture {\n                 ty::UpvarCapture::ByValue => field_kind,\n                 ty::UpvarCapture::ByRef(borrow) => {\n                     ExprKind::Deref {\n                         arg: Expr {\n-                            temp_lifetime: temp_lifetime,\n-                            ty: cx.tcx.mk_ref(borrow.region,\n-                                ty::TypeAndMut {\n-                                    ty: var_ty,\n-                                    mutbl: borrow.kind.to_mutbl_lossy()\n-                                }),\n-                            span: expr.span,\n-                            kind: field_kind,\n-                        }.to_ref()\n+                                temp_lifetime: temp_lifetime,\n+                                ty: cx.tcx.mk_ref(borrow.region,\n+                                                  ty::TypeAndMut {\n+                                                      ty: var_ty,\n+                                                      mutbl: borrow.kind.to_mutbl_lossy(),\n+                                                  }),\n+                                span: expr.span,\n+                                kind: field_kind,\n+                            }\n+                            .to_ref(),\n                     }\n                 }\n             }\n@@ -894,30 +940,31 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // the arguments, unfortunately, do not, so if this is a ByRef\n     // operator, we have to gin up the autorefs (but by value is easy)\n     match pass_args {\n-        PassArgs::ByValue => {\n-            argrefs.extend(args.iter().map(|arg| arg.to_ref()))\n-        }\n+        PassArgs::ByValue => argrefs.extend(args.iter().map(|arg| arg.to_ref())),\n \n         PassArgs::ByRef => {\n             let region = cx.tcx.node_scope_region(expr.id);\n             let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n-            argrefs.extend(\n-                args.iter()\n-                    .map(|arg| {\n-                        let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n-                        let adjusted_ty =\n-                            cx.tcx.mk_ref(region,\n-                                       ty::TypeAndMut { ty: arg_ty,\n-                                                        mutbl: hir::MutImmutable });\n-                        Expr {\n+            argrefs.extend(args.iter()\n+                .map(|arg| {\n+                    let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n+                    let adjusted_ty = cx.tcx.mk_ref(region,\n+                                                    ty::TypeAndMut {\n+                                                        ty: arg_ty,\n+                                                        mutbl: hir::MutImmutable,\n+                                                    });\n+                    Expr {\n                             temp_lifetime: temp_lifetime,\n                             ty: adjusted_ty,\n                             span: expr.span,\n-                            kind: ExprKind::Borrow { region: region,\n-                                                     borrow_kind: BorrowKind::Shared,\n-                                                     arg: arg.to_ref() }\n-                        }.to_ref()\n-                    }))\n+                            kind: ExprKind::Borrow {\n+                                region: region,\n+                                borrow_kind: BorrowKind::Shared,\n+                                arg: arg.to_ref(),\n+                            },\n+                        }\n+                        .to_ref()\n+                }))\n         }\n     }\n \n@@ -981,36 +1028,38 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         kind: convert_var(cx, closure_expr, freevar.def),\n     };\n     match upvar_capture {\n-        ty::UpvarCapture::ByValue => {\n-            captured_var.to_ref()\n-        }\n+        ty::UpvarCapture::ByValue => captured_var.to_ref(),\n         ty::UpvarCapture::ByRef(upvar_borrow) => {\n             let borrow_kind = match upvar_borrow.kind {\n                 ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n                 ty::BorrowKind::UniqueImmBorrow => BorrowKind::Unique,\n                 ty::BorrowKind::MutBorrow => BorrowKind::Mut,\n             };\n             Expr {\n-                temp_lifetime: temp_lifetime,\n-                ty: freevar_ty,\n-                span: closure_expr.span,\n-                kind: ExprKind::Borrow { region: upvar_borrow.region,\n-                                         borrow_kind: borrow_kind,\n-                                         arg: captured_var.to_ref() }\n-            }.to_ref()\n+                    temp_lifetime: temp_lifetime,\n+                    ty: freevar_ty,\n+                    span: closure_expr.span,\n+                    kind: ExprKind::Borrow {\n+                        region: upvar_borrow.region,\n+                        borrow_kind: borrow_kind,\n+                        arg: captured_var.to_ref(),\n+                    },\n+                }\n+                .to_ref()\n         }\n     }\n }\n \n /// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n fn field_refs<'tcx>(variant: &'tcx VariantDef,\n                     fields: &'tcx [hir::Field])\n-                    -> Vec<FieldExprRef<'tcx>>\n-{\n+                    -> Vec<FieldExprRef<'tcx>> {\n     fields.iter()\n-          .map(|field| FieldExprRef {\n-              name: Field::new(variant.index_of_field_named(field.name.node).unwrap()),\n-              expr: field.expr.to_ref(),\n-          })\n-          .collect()\n+        .map(|field| {\n+            FieldExprRef {\n+                name: Field::new(variant.index_of_field_named(field.name.node).unwrap()),\n+                expr: field.expr.to_ref(),\n+            }\n+        })\n+        .collect()\n }"}, {"sha": "7d111fccd0056c5801671605153d863ed33918d7", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * This module contains the code to convert from the wacky tcx data\n- * structures into the hair. The `builder` is generally ignorant of\n- * the tcx etc, and instead goes through the `Cx` for most of its\n- * work.\n- */\n+//! This module contains the code to convert from the wacky tcx data\n+//! structures into the hair. The `builder` is generally ignorant of\n+//! the tcx etc, and instead goes through the `Cx` for most of its\n+//! work.\n+//!\n \n use hair::*;\n use rustc::mir::transform::MirSource;\n@@ -32,27 +31,25 @@ use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n \n #[derive(Copy, Clone)]\n-pub struct Cx<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     constness: hir::Constness,\n \n     /// True if this constant/function needs overflow checks.\n-    check_overflow: bool\n+    check_overflow: bool,\n }\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               src: MirSource)\n-               -> Cx<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, src: MirSource) -> Cx<'a, 'gcx, 'tcx> {\n         let constness = match src {\n             MirSource::Const(_) |\n             MirSource::Static(..) => hir::Constness::Const,\n             MirSource::Fn(id) => {\n                 let fn_like = FnLikeNode::from_node(infcx.tcx.map.get(id));\n                 fn_like.map_or(hir::Constness::NotConst, |f| f.constness())\n             }\n-            MirSource::Promoted(..) => bug!()\n+            MirSource::Promoted(..) => bug!(),\n         };\n \n         let src_node_id = src.item_id();\n@@ -70,13 +67,16 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are translated in.\n-        let mut check_overflow = attrs.iter().any(|item| {\n-            item.check_name(\"rustc_inherit_overflow_checks\")\n-        });\n+        let mut check_overflow = attrs.iter()\n+            .any(|item| item.check_name(\"rustc_inherit_overflow_checks\"));\n \n         // Respect -Z force-overflow-checks=on and -C debug-assertions.\n-        check_overflow |= infcx.tcx.sess.opts.debugging_opts.force_overflow_checks\n-               .unwrap_or(infcx.tcx.sess.opts.debug_assertions);\n+        check_overflow |= infcx.tcx\n+            .sess\n+            .opts\n+            .debugging_opts\n+            .force_overflow_checks\n+            .unwrap_or(infcx.tcx.sess.opts.debug_assertions);\n \n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n@@ -85,7 +85,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             tcx: infcx.tcx,\n             infcx: infcx,\n             constness: constness,\n-            check_overflow: check_overflow\n+            check_overflow: check_overflow,\n         }\n     }\n }\n@@ -102,7 +102,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n         match ConstUsize::new(value, self.tcx.sess.target.uint_type) {\n-            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val))},\n+            Ok(val) => Literal::Value { value: ConstVal::Integral(ConstInt::Usize(val)) },\n             Err(_) => bug!(\"usize literal out of range for target\"),\n         }\n     }\n@@ -128,9 +128,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n-        Literal::Value {\n-            value: const_eval::eval_const_expr(self.tcx.global_tcx(), e)\n-        }\n+        Literal::Value { value: const_eval::eval_const_expr(self.tcx.global_tcx(), e) }\n     }\n \n     pub fn trait_method(&mut self,\n@@ -145,10 +143,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n                 let method_ty = self.tcx.item_type(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n-                return (method_ty, Literal::Item {\n-                    def_id: item.def_id,\n-                    substs: substs,\n-                });\n+                return (method_ty,\n+                        Literal::Item {\n+                            def_id: item.def_id,\n+                            substs: substs,\n+                        });\n             }\n         }\n \n@@ -168,7 +167,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n         let ty = self.tcx.lift_to_global(&ty).unwrap_or_else(|| {\n             bug!(\"MIR: Cx::needs_drop({}) got \\\n-                  type with inference types/regions\", ty);\n+                  type with inference types/regions\",\n+                 ty);\n         });\n         self.tcx.type_needs_drop_given_env(ty, &self.infcx.parameter_environment)\n     }"}, {"sha": "6930a959d6515ce2365e26e1a47574e15794b857", "filename": "src/librustc_mir/hair/cx/to_ref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -18,32 +18,32 @@ pub trait ToRef {\n     fn to_ref(self) -> Self::Output;\n }\n \n-impl<'a,'tcx:'a> ToRef for &'tcx hir::Expr {\n+impl<'a, 'tcx: 'a> ToRef for &'tcx hir::Expr {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(self)\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef for &'tcx P<hir::Expr> {\n+impl<'a, 'tcx: 'a> ToRef for &'tcx P<hir::Expr> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Hair(&**self)\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef for Expr<'tcx> {\n+impl<'a, 'tcx: 'a> ToRef for Expr<'tcx> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n         ExprRef::Mirror(Box::new(self))\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef for &'tcx Option<T>\n-    where &'tcx T: ToRef<Output=U>\n+impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx Option<T>\n+    where &'tcx T: ToRef<Output = U>\n {\n     type Output = Option<U>;\n \n@@ -52,8 +52,8 @@ impl<'a,'tcx:'a,T,U> ToRef for &'tcx Option<T>\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef for &'tcx Vec<T>\n-    where &'tcx T: ToRef<Output=U>\n+impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx Vec<T>\n+    where &'tcx T: ToRef<Output = U>\n {\n     type Output = Vec<U>;\n \n@@ -62,8 +62,8 @@ impl<'a,'tcx:'a,T,U> ToRef for &'tcx Vec<T>\n     }\n }\n \n-impl<'a,'tcx:'a,T,U> ToRef for &'tcx P<[T]>\n-    where &'tcx T: ToRef<Output=U>\n+impl<'a, 'tcx: 'a, T, U> ToRef for &'tcx P<[T]>\n+    where &'tcx T: ToRef<Output = U>\n {\n     type Output = Vec<U>;\n "}, {"sha": "3cbf8573ba97fdf67a25b36a708eca03b0e24b4a", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -30,7 +30,7 @@\n //! future.\n \n use def_use::DefUseAnalysis;\n-use rustc::mir::{Constant, Local, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n+use rustc::mir::{Constant, Local, LocalKind, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n@@ -122,7 +122,7 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                                 local == dest_local => {\n                             let maybe_action = match *operand {\n                                 Operand::Consume(ref src_lvalue) => {\n-                                    Action::local_copy(&def_use_analysis, src_lvalue)\n+                                    Action::local_copy(&mir, &def_use_analysis, src_lvalue)\n                                 }\n                                 Operand::Constant(ref src_constant) => {\n                                     Action::constant(src_constant)\n@@ -159,7 +159,7 @@ enum Action<'tcx> {\n }\n \n impl<'tcx> Action<'tcx> {\n-    fn local_copy(def_use_analysis: &DefUseAnalysis, src_lvalue: &Lvalue<'tcx>)\n+    fn local_copy(mir: &Mir<'tcx>, def_use_analysis: &DefUseAnalysis, src_lvalue: &Lvalue<'tcx>)\n                   -> Option<Action<'tcx>> {\n         // The source must be a local.\n         let src_local = if let Lvalue::Local(local) = *src_lvalue {\n@@ -195,7 +195,9 @@ impl<'tcx> Action<'tcx> {\n         //     SRC = X;\n         //     USE(SRC);\n         let src_def_count = src_use_info.def_count_not_including_drop();\n-        if src_def_count != 1 {\n+        // allow function arguments to be propagated\n+        if src_def_count > 1 ||\n+            (src_def_count == 0 && mir.local_kind(src_local) != LocalKind::Arg) {\n             debug!(\"  Can't copy-propagate local: {} defs of src\",\n                    src_use_info.def_count_not_including_drop());\n             return None"}, {"sha": "862345fd46eb6ce743ab50bfa07f398b993adaeb", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -48,7 +48,7 @@ use rustc::session::config::CrateType::CrateTypeExecutable;\n use rustc::ty::{self, TyCtxt};\n \n use std::env;\n-use std::fs::{self, File};\n+use std::fs::File;\n use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n@@ -832,7 +832,7 @@ pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n         },\n     };\n \n-    if let Err(e) = fs::create_dir_all(&root_path) {\n+    if let Err(e) = rustc::util::fs::create_dir_racy(&root_path) {\n         tcx.sess.err(&format!(\"Could not create directory {}: {}\",\n                               root_path.display(),\n                               e));"}, {"sha": "6435b20eeaa006f164b1a02b9df55a271a42d451", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -971,7 +971,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         let mut name = String::with_capacity(prefix.len() + 6);\n         name.push_str(prefix);\n         name.push_str(\".\");\n-        base_n::push_str(idx as u64, base_n::MAX_BASE, &mut name);\n+        base_n::push_str(idx as u64, base_n::ALPHANUMERIC_ONLY, &mut name);\n         name\n     }\n }"}, {"sha": "5022e0750e38ef00db79519fbfdc293dc9cdbeb3", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -1763,6 +1763,10 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n     let var_name = CString::new(var_name).unwrap();\n     let linkage_name = CString::new(linkage_name).unwrap();\n+\n+    let ty = cx.tcx().item_type(node_def_id);\n+    let global_align = type_of::align_of(cx, ty);\n+\n     unsafe {\n         llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(cx),\n                                                     var_scope,\n@@ -1773,7 +1777,9 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                                     type_metadata,\n                                                     is_local_to_unit,\n                                                     global,\n-                                                    ptr::null_mut());\n+                                                    ptr::null_mut(),\n+                                                    global_align as u64,\n+        );\n     }\n }\n "}, {"sha": "4e511c05840d1aeb1ac09e9cdd355c26c351ce24", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -462,6 +462,7 @@ pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         LocalVariable    |\n         CapturedVariable => (0, DW_TAG_auto_variable)\n     };\n+    let align = ::type_of::align_of(cx, variable_type);\n \n     let name = CString::new(variable_name.as_str().as_bytes()).unwrap();\n     match (variable_access, &[][..]) {\n@@ -478,7 +479,9 @@ pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     type_metadata,\n                     cx.sess().opts.optimize != config::OptLevel::No,\n                     DIFlags::FlagZero,\n-                    argument_index)\n+                    argument_index,\n+                    align as u64,\n+                )\n             };\n             source_loc::set_debug_location(cx, None,\n                 InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));"}, {"sha": "ac336fe45e54a2621a46ef8b2044b845c3369a4f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -1468,6 +1468,13 @@ impl<'a> Item<'a> {\n                 return None;\n             }\n         } else {\n+            // Macros from other libraries get special filenames which we can\n+            // safely ignore.\n+            if self.item.source.filename.starts_with(\"<\") &&\n+               self.item.source.filename.ends_with(\"macros>\") {\n+                return None;\n+            }\n+\n             let (krate, src_root) = match cache.extern_locations.get(&self.item.def_id.krate) {\n                 Some(&(ref name, ref src, Local)) => (name, src),\n                 Some(&(ref name, ref src, Remote(ref s))) => {"}, {"sha": "15912b41d59c061d9db61318a0ad1e486ec7c50c", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -52,13 +52,15 @@\n \tfont-family: 'Source Code Pro';\n \tfont-style: normal;\n \tfont-weight: 400;\n-\tsrc: local('Source Code Pro'), url(\"SourceCodePro-Regular.woff\") format('woff');\n+\t/* Avoid using locally installed font because bad versions are in circulation:\n+\t * see https://github.com/rust-lang/rust/issues/24355 */\n+\tsrc: url(\"SourceCodePro-Regular.woff\") format('woff');\n }\n @font-face {\n \tfont-family: 'Source Code Pro';\n \tfont-style: normal;\n \tfont-weight: 600;\n-\tsrc: local('Source Code Pro Semibold'), url(\"SourceCodePro-Semibold.woff\") format('woff');\n+\tsrc: url(\"SourceCodePro-Semibold.woff\") format('woff');\n }\n \n * {"}, {"sha": "174118db93e0b1ff55c6b38f0406a9871eaa9de0", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -54,6 +54,9 @@ extern crate serialize as rustc_serialize; // used by deriving\n use std::collections::{BTreeMap, BTreeSet};\n use std::default::Default;\n use std::env;\n+use std::fmt::Display;\n+use std::io;\n+use std::io::Write;\n use std::path::PathBuf;\n use std::process;\n use std::sync::mpsc::channel;\n@@ -183,7 +186,7 @@ pub fn main_args(args: &[String]) -> isize {\n     let matches = match getopts::getopts(&args[1..], &all_groups) {\n         Ok(m) => m,\n         Err(err) => {\n-            println!(\"{}\", err);\n+            print_error(err);\n             return 1;\n         }\n     };\n@@ -211,11 +214,11 @@ pub fn main_args(args: &[String]) -> isize {\n     }\n \n     if matches.free.is_empty() {\n-        println!(\"expected an input file to act on\");\n+        print_error(\"missing file operand\");\n         return 1;\n     }\n     if matches.free.len() > 1 {\n-        println!(\"only one input file may be specified\");\n+        print_error(\"too many file operands\");\n         return 1;\n     }\n     let input = &matches.free[0];\n@@ -227,7 +230,7 @@ pub fn main_args(args: &[String]) -> isize {\n     let externs = match parse_externs(&matches) {\n         Ok(ex) => ex,\n         Err(err) => {\n-            println!(\"{}\", err);\n+            print_error(err);\n             return 1;\n         }\n     };\n@@ -247,14 +250,16 @@ pub fn main_args(args: &[String]) -> isize {\n \n     if let Some(ref p) = css_file_extension {\n         if !p.is_file() {\n-            println!(\"{}\", \"--extend-css option must take a css file as input\");\n+            writeln!(\n+                &mut io::stderr(),\n+                \"rustdoc: option --extend-css argument must be a file.\"\n+            ).unwrap();\n             return 1;\n         }\n     }\n \n     let external_html = match ExternalHtml::load(\n-            &matches.opt_strs(\"html-in-header\"),\n-            &matches.opt_strs(\"html-before-content\"),\n+            &matches.opt_strs(\"html-in-header\"), &matches.opt_strs(\"html-before-content\"),\n             &matches.opt_strs(\"html-after-content\")) {\n         Some(eh) => eh,\n         None => return 3\n@@ -291,17 +296,26 @@ pub fn main_args(args: &[String]) -> isize {\n                 0\n             }\n             Some(s) => {\n-                println!(\"unknown output format: {}\", s);\n+                print_error(format!(\"unknown output format: {}\", s));\n                 1\n             }\n         }\n     });\n     res.unwrap_or_else(|s| {\n-        println!(\"input error: {}\", s);\n+        print_error(format!(\"input error: {}\", s));\n         1\n     })\n }\n \n+/// Prints an uniformised error message on the standard error output\n+fn print_error<T>(error_message: T) where T: Display {\n+    writeln!(\n+        &mut io::stderr(),\n+        \"rustdoc: {}\\nTry 'rustdoc --help' for more information.\",\n+        error_message\n+    ).unwrap();\n+}\n+\n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n fn acquire_input<R, F>(input: &str,"}, {"sha": "9dbc9d30e606b48851c59384b1d3ff93b5fc2bb9", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -71,7 +71,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     let mut out = match File::create(&output) {\n         Err(e) => {\n             let _ = writeln!(&mut io::stderr(),\n-                             \"error opening `{}` for writing: {}\",\n+                             \"rustdoc: {}: {}\",\n                              output.display(), e);\n             return 4;\n         }\n@@ -80,8 +80,10 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n \n     let (metadata, text) = extract_leading_metadata(&input_str);\n     if metadata.is_empty() {\n-        let _ = writeln!(&mut io::stderr(),\n-                         \"invalid markdown file: expecting initial line with `% ...TITLE...`\");\n+        let _ = writeln!(\n+            &mut io::stderr(),\n+            \"rustdoc: invalid markdown file: expecting initial line with `% ...TITLE...`\"\n+        );\n         return 5;\n     }\n     let title = metadata[0];\n@@ -132,7 +134,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     match err {\n         Err(e) => {\n             let _ = writeln!(&mut io::stderr(),\n-                             \"error writing to `{}`: {}\",\n+                             \"rustdoc: cannot write to `{}`: {}\",\n                              output.display(), e);\n             6\n         }"}, {"sha": "f8a5ec0b3791e87ab377330077d7c5fb9d11bad8", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -499,6 +499,19 @@ impl UdpSocket {\n     /// This will retrieve the stored error in the underlying socket, clearing\n     /// the field in the process. This can be useful for checking errors between\n     /// calls.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// match socket.take_error() {\n+    ///     Ok(Some(error)) => println!(\"UdpSocket error: {:?}\", error),\n+    ///     Ok(None) => println!(\"No error\"),\n+    ///     Err(error) => println!(\"UdpSocket.take_error failed: {:?}\", error),\n+    /// }\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -507,15 +520,36 @@ impl UdpSocket {\n     /// Connects this UDP socket to a remote address, allowing the `send` and\n     /// `recv` syscalls to be used to send data and also applies filters to only\n     /// receive data from the specified address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {\n         super::each_addr(addr, |addr| self.0.connect(addr))\n     }\n \n     /// Sends data on the socket to the remote address to which it is connected.\n     ///\n-    /// The `connect` method will connect this socket to a remote address. This\n+    /// The [`connect()`] method will connect this socket to a remote address. This\n     /// method will fail if the socket is not connected.\n+    ///\n+    /// [`connect()`]: #method.connect\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n+    /// socket.send(&[0, 1, 2]).expect(\"couldn't send message\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.send(buf)\n@@ -526,6 +560,20 @@ impl UdpSocket {\n     ///\n     /// The `connect` method will connect this socket to a remote address. This\n     /// method will fail if the socket is not connected.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n+    /// let mut buf = [0; 10];\n+    /// match socket.recv(&mut buf) {\n+    ///     Ok(received) => println!(\"received {} bytes\", received),\n+    ///     Err(e) => println!(\"recv function failed: {:?}\", e),\n+    /// }\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.0.recv(buf)\n@@ -535,6 +583,15 @@ impl UdpSocket {\n     ///\n     /// On Unix this corresponds to calling fcntl, and on Windows this\n     /// corresponds to calling ioctlsocket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::UdpSocket;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// socket.set_nonblocking(true).expect(\"set_nonblocking call failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)"}, {"sha": "9f51d3e87f3f74fc8a44a2ec3ba363645db6f5b6", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -454,10 +454,16 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n }\n \n /// Creates a new asynchronous channel, returning the sender/receiver halves.\n-///\n /// All data sent on the sender will become available on the receiver, and no\n /// send will block the calling thread (this channel has an \"infinite buffer\").\n ///\n+/// If the [`Receiver`] is disconnected while trying to [`send()`] with the\n+/// [`Sender`], the [`send()`] method will return an error.\n+///\n+/// [`send()`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+/// [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n+/// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n+///\n /// # Examples\n ///\n /// ```\n@@ -487,18 +493,23 @@ pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n \n /// Creates a new synchronous, bounded channel.\n ///\n-/// Like asynchronous channels, the `Receiver` will block until a message\n+/// Like asynchronous channels, the [`Receiver`] will block until a message\n /// becomes available. These channels differ greatly in the semantics of the\n /// sender from asynchronous channels, however.\n ///\n-/// This channel has an internal buffer on which messages will be queued. `bound`\n-/// specifies the buffer size. When the internal buffer becomes full, future sends\n-/// will *block* waiting for the buffer to open up. Note that a buffer size of 0\n-/// is valid, in which case this becomes  \"rendezvous channel\" where each send will\n-/// not return until a recv is paired with it.\n+/// This channel has an internal buffer on which messages will be queued.\n+/// `bound` specifies the buffer size. When the internal buffer becomes full,\n+/// future sends will *block* waiting for the buffer to open up. Note that a\n+/// buffer size of 0 is valid, in which case this becomes \"rendezvous channel\"\n+/// where each [`send()`] will not return until a recv is paired with it.\n+///\n+/// Like asynchronous channels, if the [`Receiver`] is disconnected while\n+/// trying to [`send()`] with the [`SyncSender`], the [`send()`] method will\n+/// return an error.\n ///\n-/// As with asynchronous channels, all senders will panic in `send` if the\n-/// `Receiver` has been destroyed.\n+/// [`send()`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n+/// [`SyncSender`]: ../../../std/sync/mpsc/struct.SyncSender.html\n+/// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n ///\n /// # Examples\n ///"}, {"sha": "5749459a0541ed158518f993cfbaaee2f8b7d0b6", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 90, "deletions": 2, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -301,6 +301,7 @@ pub enum ColorConfig {\n \n pub struct TestOpts {\n     pub filter: Option<String>,\n+    pub filter_exact: bool,\n     pub run_ignored: bool,\n     pub run_tests: bool,\n     pub bench_benchmarks: bool,\n@@ -317,6 +318,7 @@ impl TestOpts {\n     fn new() -> TestOpts {\n         TestOpts {\n             filter: None,\n+            filter_exact: false,\n             run_ignored: false,\n             run_tests: false,\n             bench_benchmarks: false,\n@@ -348,6 +350,7 @@ fn optgroups() -> Vec<getopts::OptGroup> {\n       getopts::optmulti(\"\", \"skip\", \"Skip tests whose names contain FILTER (this flag can \\\n                                      be used multiple times)\",\"FILTER\"),\n       getopts::optflag(\"q\", \"quiet\", \"Display one character per test instead of one line\"),\n+      getopts::optflag(\"\", \"exact\", \"Exactly match filters rather than by substring\"),\n       getopts::optopt(\"\", \"color\", \"Configure coloring of output:\n             auto   = colorize if stdout is a tty and tests are run on serially (default);\n             always = always colorize output;\n@@ -407,6 +410,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n \n     let run_ignored = matches.opt_present(\"ignored\");\n     let quiet = matches.opt_present(\"quiet\");\n+    let exact = matches.opt_present(\"exact\");\n \n     let logfile = matches.opt_str(\"logfile\");\n     let logfile = logfile.map(|s| PathBuf::from(&s));\n@@ -448,6 +452,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n \n     let test_opts = TestOpts {\n         filter: filter,\n+        filter_exact: exact,\n         run_ignored: run_ignored,\n         run_tests: run_tests,\n         bench_benchmarks: bench_benchmarks,\n@@ -1118,14 +1123,26 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n         None => filtered,\n         Some(ref filter) => {\n             filtered.into_iter()\n-                    .filter(|test| test.desc.name.as_slice().contains(&filter[..]))\n+                    .filter(|test| {\n+                        if opts.filter_exact {\n+                            test.desc.name.as_slice() == &filter[..]\n+                        } else {\n+                            test.desc.name.as_slice().contains(&filter[..])\n+                        }\n+                    })\n                     .collect()\n         }\n     };\n \n     // Skip tests that match any of the skip filters\n     filtered = filtered.into_iter()\n-        .filter(|t| !opts.skip.iter().any(|sf| t.desc.name.as_slice().contains(&sf[..])))\n+        .filter(|t| !opts.skip.iter().any(|sf| {\n+                if opts.filter_exact {\n+                    t.desc.name.as_slice() == &sf[..]\n+                } else {\n+                    t.desc.name.as_slice().contains(&sf[..])\n+                }\n+            }))\n         .collect();\n \n     // Maybe pull out the ignored test and unignore them\n@@ -1654,6 +1671,77 @@ mod tests {\n         assert!(!filtered[0].desc.ignore);\n     }\n \n+    #[test]\n+    pub fn exact_filter_match() {\n+        fn tests() -> Vec<TestDescAndFn> {\n+            vec![\"base\",\n+                 \"base::test\",\n+                 \"base::test1\",\n+                 \"base::test2\",\n+            ].into_iter()\n+            .map(|name| TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(name),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                },\n+                testfn: DynTestFn(Box::new(move |()| {}))\n+            })\n+            .collect()\n+        }\n+\n+        let substr = filter_tests(&TestOpts {\n+                filter: Some(\"base\".into()),\n+                ..TestOpts::new()\n+            }, tests());\n+        assert_eq!(substr.len(), 4);\n+\n+        let substr = filter_tests(&TestOpts {\n+                filter: Some(\"bas\".into()),\n+                ..TestOpts::new()\n+            }, tests());\n+        assert_eq!(substr.len(), 4);\n+\n+        let substr = filter_tests(&TestOpts {\n+                filter: Some(\"::test\".into()),\n+                ..TestOpts::new()\n+            }, tests());\n+        assert_eq!(substr.len(), 3);\n+\n+        let substr = filter_tests(&TestOpts {\n+                filter: Some(\"base::test\".into()),\n+                ..TestOpts::new()\n+            }, tests());\n+        assert_eq!(substr.len(), 3);\n+\n+        let exact = filter_tests(&TestOpts {\n+                filter: Some(\"base\".into()),\n+                filter_exact: true, ..TestOpts::new()\n+            }, tests());\n+        assert_eq!(exact.len(), 1);\n+\n+        let exact = filter_tests(&TestOpts {\n+                filter: Some(\"bas\".into()),\n+                filter_exact: true,\n+                ..TestOpts::new()\n+            }, tests());\n+        assert_eq!(exact.len(), 0);\n+\n+        let exact = filter_tests(&TestOpts {\n+                filter: Some(\"::test\".into()),\n+                filter_exact: true,\n+                ..TestOpts::new()\n+            }, tests());\n+        assert_eq!(exact.len(), 0);\n+\n+        let exact = filter_tests(&TestOpts {\n+                filter: Some(\"base::test\".into()),\n+                filter_exact: true,\n+                ..TestOpts::new()\n+            }, tests());\n+        assert_eq!(exact.len(), 1);\n+    }\n+\n     #[test]\n     pub fn sort_tests() {\n         let mut opts = TestOpts::new();"}, {"sha": "85749d883d2f303ed3330a02ad3acac98416493e", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -552,8 +552,13 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateBasicType(\n     uint64_t AlignInBits,\n     unsigned Encoding) {\n     return wrap(Builder->createBasicType(\n-        Name, SizeInBits,\n-        AlignInBits, Encoding));\n+        Name,\n+        SizeInBits,\n+#if LLVM_VERSION_LE(3, 9)\n+        AlignInBits,\n+#endif\n+        Encoding\n+    ));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreatePointerType(\n@@ -645,16 +650,23 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n     LLVMRustMetadataRef Ty,\n     bool isLocalToUnit,\n     LLVMValueRef Val,\n-    LLVMRustMetadataRef Decl = NULL) {\n-    return wrap(Builder->createGlobalVariable(unwrapDI<DIDescriptor>(Context),\n+    LLVMRustMetadataRef Decl = NULL,\n+    uint64_t AlignInBits = 0)\n+{\n+    return wrap(Builder->createGlobalVariable(\n+        unwrapDI<DIDescriptor>(Context),\n         Name,\n         LinkageName,\n         unwrapDI<DIFile>(File),\n         LineNo,\n         unwrapDI<DIType>(Ty),\n         isLocalToUnit,\n         cast<Constant>(unwrap(Val)),\n-        unwrapDIptr<MDNode>(Decl)));\n+        unwrapDIptr<MDNode>(Decl)\n+#if LLVM_VERSION_GE(4, 0)\n+        , AlignInBits\n+#endif\n+    ));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(\n@@ -667,14 +679,23 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(\n     LLVMRustMetadataRef Ty,\n     bool AlwaysPreserve,\n     LLVMRustDIFlags Flags,\n-    unsigned ArgNo) {\n+    unsigned ArgNo,\n+    uint64_t AlignInBits)\n+{\n #if LLVM_VERSION_GE(3, 8)\n     if (Tag == 0x100) { // DW_TAG_auto_variable\n         return wrap(Builder->createAutoVariable(\n-            unwrapDI<DIDescriptor>(Scope), Name,\n+            unwrapDI<DIDescriptor>(Scope),\n+            Name,\n             unwrapDI<DIFile>(File),\n             LineNo,\n-            unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags)));\n+            unwrapDI<DIType>(Ty),\n+            AlwaysPreserve,\n+            from_rust(Flags)\n+#if LLVM_VERSION_GE(4,0)\n+            , AlignInBits\n+#endif\n+        ));\n     } else {\n         return wrap(Builder->createParameterVariable(\n             unwrapDI<DIDescriptor>(Scope), Name, ArgNo,"}, {"sha": "38fe5cdffebd0a7f2bc0c15aa6ca8768c9dae688", "filename": "src/test/incremental/hashes/closure_expressions.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -0,0 +1,144 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for closure expression.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change closure body ---------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_closure_body() {\n+    let _ = || 1u32;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_closure_body() {\n+    let _ = || 3u32;\n+}\n+\n+\n+\n+// Add parameter ---------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_parameter() {\n+    let x = 0u32;\n+    let _ = || x + 1;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_parameter() {\n+    let x = 0u32;\n+    let _ = |x: u32| x + 1;\n+}\n+\n+\n+\n+// Change parameter pattern ----------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_parameter_pattern() {\n+    let _ = |x: &u32| x;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_parameter_pattern() {\n+    let _ = |&x: &u32| x;\n+}\n+\n+\n+\n+// Add `move` to closure -------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_move() {\n+    let _ = || 1;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_move() {\n+    let _ = move || 1;\n+}\n+\n+\n+\n+// Add type ascription to parameter --------------------------------------------\n+#[cfg(cfail1)]\n+fn add_type_ascription_to_parameter() {\n+    let closure = |x| x + 1u32;\n+    let _: u32 = closure(1);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_type_ascription_to_parameter() {\n+    let closure = |x: u32| x + 1u32;\n+    let _: u32 = closure(1);\n+}\n+\n+\n+\n+// Change parameter type -------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_parameter_type() {\n+    let closure = |x: u32| (x as u64) + 1;\n+    let _ = closure(1);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_parameter_type() {\n+    let closure = |x: u16| (x as u64) + 1;\n+    let _ = closure(1);\n+}"}, {"sha": "7f991b30fc4924d98f91b1de001333d5834c8c5f", "filename": "src/test/incremental/hashes/enum_constructors.rs", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -0,0 +1,387 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for struct constructor expressions.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+enum Enum {\n+    Struct {\n+        x: i32,\n+        y: i64,\n+        z: i16,\n+    },\n+    Tuple(i32, i64, i16)\n+}\n+\n+// Change field value (struct-like) -----------------------------------------\n+#[cfg(cfail1)]\n+fn change_field_value_struct_like() -> Enum {\n+    Enum::Struct {\n+        x: 0,\n+        y: 1,\n+        z: 2,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_field_value_struct_like() -> Enum {\n+    Enum::Struct {\n+        x: 0,\n+        y: 2,\n+        z: 2,\n+    }\n+}\n+\n+\n+\n+// Change field order (struct-like) -----------------------------------------\n+#[cfg(cfail1)]\n+fn change_field_order_struct_like() -> Enum {\n+    Enum::Struct {\n+        x: 3,\n+        y: 4,\n+        z: 5,\n+    }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_field_order_struct_like() -> Enum {\n+    Enum::Struct {\n+        y: 4,\n+        x: 3,\n+        z: 5,\n+    }\n+}\n+\n+\n+enum Enum2 {\n+    Struct {\n+        x: i8,\n+        y: i8,\n+        z: i8,\n+    },\n+    Struct2 {\n+        x: i8,\n+        y: i8,\n+        z: i8,\n+    },\n+    Tuple(u16, u16, u16),\n+    Tuple2(u64, u64, u64),\n+}\n+\n+// Change constructor path (struct-like) ------------------------------------\n+#[cfg(cfail1)]\n+fn change_constructor_path_struct_like() {\n+    let _ = Enum::Struct {\n+        x: 0,\n+        y: 1,\n+        z: 2,\n+    };\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_constructor_path_struct_like() {\n+    let _ = Enum2::Struct {\n+        x: 0,\n+        y: 1,\n+        z: 2,\n+    };\n+}\n+\n+\n+\n+// Change variant (regular struct) ------------------------------------\n+#[cfg(cfail1)]\n+fn change_constructor_variant_struct_like() {\n+    let _ = Enum2::Struct {\n+        x: 0,\n+        y: 1,\n+        z: 2,\n+    };\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_constructor_variant_struct_like() {\n+    let _ = Enum2::Struct2 {\n+        x: 0,\n+        y: 1,\n+        z: 2,\n+    };\n+}\n+\n+\n+// Change constructor path indirectly (struct-like) -------------------------\n+mod change_constructor_path_indirectly_struct_like {\n+    #[cfg(cfail1)]\n+    use super::Enum as TheEnum;\n+    #[cfg(not(cfail1))]\n+    use super::Enum2 as TheEnum;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn function() -> TheEnum {\n+        TheEnum::Struct {\n+            x: 0,\n+            y: 1,\n+            z: 2,\n+        }\n+    }\n+}\n+\n+\n+// Change constructor variant indirectly (struct-like) ---------------------------\n+mod change_constructor_variant_indirectly_struct_like {\n+    use super::Enum2;\n+    #[cfg(cfail1)]\n+    use super::Enum2::Struct as Variant;\n+    #[cfg(not(cfail1))]\n+    use super::Enum2::Struct2 as Variant;\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn function() -> Enum2 {\n+        Variant {\n+            x: 0,\n+            y: 1,\n+            z: 2,\n+        }\n+    }\n+}\n+\n+\n+// Change field value (tuple-like) -------------------------------------------\n+#[cfg(cfail1)]\n+fn change_field_value_tuple_like() -> Enum {\n+    Enum::Tuple(0, 1, 2)\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_field_value_tuple_like() -> Enum {\n+    Enum::Tuple(0, 1, 3)\n+}\n+\n+\n+\n+// Change constructor path (tuple-like) --------------------------------------\n+#[cfg(cfail1)]\n+fn change_constructor_path_tuple_like() {\n+    let _ = Enum::Tuple(0, 1, 2);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_constructor_path_tuple_like() {\n+    let _ = Enum2::Tuple(0, 1, 2);\n+}\n+\n+\n+\n+// Change constructor variant (tuple-like) --------------------------------------\n+#[cfg(cfail1)]\n+fn change_constructor_variant_tuple_like() {\n+    let _ = Enum2::Tuple(0, 1, 2);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_constructor_variant_tuple_like() {\n+    let _ = Enum2::Tuple2(0, 1, 2);\n+}\n+\n+\n+// Change constructor path indirectly (tuple-like) ---------------------------\n+mod change_constructor_path_indirectly_tuple_like {\n+    #[cfg(cfail1)]\n+    use super::Enum as TheEnum;\n+    #[cfg(not(cfail1))]\n+    use super::Enum2 as TheEnum;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn function() -> TheEnum {\n+        TheEnum::Tuple(0, 1, 2)\n+    }\n+}\n+\n+\n+\n+// Change constructor variant indirectly (tuple-like) ---------------------------\n+mod change_constructor_variant_indirectly_tuple_like {\n+    use super::Enum2;\n+    #[cfg(cfail1)]\n+    use super::Enum2::Tuple as Variant;\n+    #[cfg(not(cfail1))]\n+    use super::Enum2::Tuple2 as Variant;\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn function() -> Enum2 {\n+        Variant(0, 1, 2)\n+    }\n+}\n+\n+\n+enum Clike {\n+    A,\n+    B,\n+    C\n+}\n+\n+enum Clike2 {\n+    B,\n+    C,\n+    D\n+}\n+\n+// Change constructor path (C-like) --------------------------------------\n+#[cfg(cfail1)]\n+fn change_constructor_path_c_like() {\n+    let _ = Clike::B;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_constructor_path_c_like() {\n+    let _ = Clike2::B;\n+}\n+\n+\n+\n+// Change constructor variant (C-like) --------------------------------------\n+#[cfg(cfail1)]\n+fn change_constructor_variant_c_like() {\n+    let _ = Clike::A;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_constructor_variant_c_like() {\n+    let _ = Clike::C;\n+}\n+\n+\n+// Change constructor path indirectly (C-like) ---------------------------\n+mod change_constructor_path_indirectly_c_like {\n+    #[cfg(cfail1)]\n+    use super::Clike as TheEnum;\n+    #[cfg(not(cfail1))]\n+    use super::Clike2 as TheEnum;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn function() -> TheEnum {\n+        TheEnum::B\n+    }\n+}\n+\n+\n+\n+// Change constructor variant indirectly (C-like) ---------------------------\n+mod change_constructor_variant_indirectly_c_like {\n+    use super::Clike;\n+    #[cfg(cfail1)]\n+    use super::Clike::A as Variant;\n+    #[cfg(not(cfail1))]\n+    use super::Clike::B as Variant;\n+\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn function() -> Clike {\n+        Variant\n+    }\n+}"}, {"sha": "082badacc6ccd6143429d77a7164afe9c21b8479", "filename": "src/test/incremental/hashes/exported_vs_not.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftest%2Fincremental%2Fhashes%2Fexported_vs_not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftest%2Fincremental%2Fhashes%2Fexported_vs_not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fexported_vs_not.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -0,0 +1,86 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+// Case 1: The function body is not exported to metadata. If the body changes,\n+//         the hash of the HirBody node should change, but not the hash of\n+//         either the Hir or the Metadata node.\n+\n+#[cfg(cfail1)]\n+pub fn body_not_exported_to_metadata() -> u32 {\n+    1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn body_not_exported_to_metadata() -> u32 {\n+    2\n+}\n+\n+\n+\n+// Case 2: The function body *is* exported to metadata because the function is\n+//         marked as #[inline]. Only the hash of the Hir depnode should be\n+//         unaffected by a change to the body.\n+\n+#[cfg(cfail1)]\n+#[inline]\n+pub fn body_exported_to_metadata_because_of_inline() -> u32 {\n+    1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[inline]\n+pub fn body_exported_to_metadata_because_of_inline() -> u32 {\n+    2\n+}\n+\n+\n+\n+// Case 2: The function body *is* exported to metadata because the function is\n+//         generic. Only the hash of the Hir depnode should be\n+//         unaffected by a change to the body.\n+\n+#[cfg(cfail1)]\n+#[inline]\n+pub fn body_exported_to_metadata_because_of_generic() -> u32 {\n+    1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[inline]\n+pub fn body_exported_to_metadata_because_of_generic() -> u32 {\n+    2\n+}\n+"}, {"sha": "bb31982d93f2139f5c5fc608452d02a50f290690", "filename": "src/test/incremental/hashes/indexing_expressions.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for closure expression.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+#![feature(inclusive_range_syntax)]\n+\n+// Change simple index ---------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_simple_index(slice: &[u32]) -> u32 {\n+    slice[3]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_simple_index(slice: &[u32]) -> u32 {\n+    slice[4]\n+}\n+\n+\n+\n+// Change lower bound ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_lower_bound(slice: &[u32]) -> &[u32] {\n+    &slice[3..5]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_lower_bound(slice: &[u32]) -> &[u32] {\n+    &slice[2..5]\n+}\n+\n+\n+\n+// Change upper bound ----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_upper_bound(slice: &[u32]) -> &[u32] {\n+    &slice[3..5]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_upper_bound(slice: &[u32]) -> &[u32] {\n+    &slice[3..7]\n+}\n+\n+\n+\n+// Add lower bound -------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_lower_bound(slice: &[u32]) -> &[u32] {\n+    &slice[..4]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_lower_bound(slice: &[u32]) -> &[u32] {\n+    &slice[3..4]\n+}\n+\n+\n+\n+// Add upper bound -------------------------------------------------------------\n+#[cfg(cfail1)]\n+fn add_upper_bound(slice: &[u32]) -> &[u32] {\n+    &slice[3..]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn add_upper_bound(slice: &[u32]) -> &[u32] {\n+    &slice[3..7]\n+}\n+\n+\n+\n+// Change mutability -----------------------------------------------------------\n+#[cfg(cfail1)]\n+fn change_mutability(slice: &mut [u32]) -> u32 {\n+    (&mut slice[3..5])[0]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn change_mutability(slice: &mut [u32]) -> u32 {\n+    (&slice[3..5])[0]\n+}\n+\n+\n+\n+// Exclusive to inclusive range ------------------------------------------------\n+#[cfg(cfail1)]\n+fn exclusive_to_inclusive_range(slice: &[u32]) -> &[u32] {\n+    &slice[3..7]\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+fn exclusive_to_inclusive_range(slice: &[u32]) -> &[u32] {\n+    &slice[3...7]\n+}"}, {"sha": "0e23d953baf2de48d86e6dbca9d8eb4dfd9544a1", "filename": "src/test/incremental/hashes/struct_constructors.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -202,6 +202,12 @@ mod change_constructor_path_indirectly_regular_struct {\n     #[cfg(not(cfail1))]\n     use super::RegularStruct2 as Struct;\n \n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn function() -> Struct {\n         Struct {\n             x: 0,\n@@ -262,6 +268,12 @@ mod change_constructor_path_indirectly_tuple_struct {\n     #[cfg(not(cfail1))]\n     use super::TupleStruct2 as Struct;\n \n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn function() -> Struct {\n         Struct(0, 1, 2)\n     }"}, {"sha": "26b042d0343f049d803778886ebfec4a8e7cc03d", "filename": "src/test/mir-opt/copy_propagation.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftest%2Fmir-opt%2Fcopy_propagation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftest%2Fmir-opt%2Fcopy_propagation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn test(x: u32) -> u32 {\n+    let y = x;\n+    y\n+}\n+\n+fn main() { }\n+\n+// END RUST SOURCE\n+// START rustc.node4.CopyPropagation.before.mir\n+//  bb0: {\n+//      _2 = _1;\n+//      _4 = _2;\n+//      _3 = _4;\n+//      _5 = _3;\n+//      _0 = _5;\n+//      return;\n+//  }\n+// END rustc.node4.CopyPropagation.before.mir\n+// START rustc.node4.CopyPropagation.after.mir\n+//  bb0: {\n+//      _0 = _1;\n+//      return;\n+//  }\n+// END rustc.node4.CopyPropagation.after.mir"}, {"sha": "1aeb76c0a0ecedebe8a3d50ba6317fa2bab68868", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -127,6 +127,9 @@ pub struct Config {\n     // Only run tests that match this filter\n     pub filter: Option<String>,\n \n+    // Exactly match the filter, rather than a substring\n+    pub filter_exact: bool,\n+\n     // Write out a parseable log of tests that were run\n     pub logfile: Option<PathBuf>,\n "}, {"sha": "cbdf75eda26d2dc073395371aa9cbed0908cfba4", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -89,6 +89,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n                  \"(compile-fail|parse-fail|run-fail|run-pass|\\\n                   run-pass-valgrind|pretty|debug-info|incremental|mir-opt)\"),\n           optflag(\"\", \"ignored\", \"run tests marked as ignored\"),\n+          optflag(\"\", \"exact\", \"filters match exactly\"),\n           optopt(\"\", \"runtool\", \"supervisor program to run tests under \\\n                                  (eg. emulator, valgrind)\", \"PROGRAM\"),\n           optopt(\"\", \"host-rustcflags\", \"flags to pass to rustc for host\", \"FLAGS\"),\n@@ -167,6 +168,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         mode: matches.opt_str(\"mode\").unwrap().parse().ok().expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter: matches.free.first().cloned(),\n+        filter_exact: matches.opt_present(\"exact\"),\n         logfile: matches.opt_str(\"logfile\").map(|s| PathBuf::from(&s)),\n         runtool: matches.opt_str(\"runtool\"),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n@@ -216,6 +218,7 @@ pub fn log_config(config: &Config) {\n                     opt_str(&config.filter\n                                    .as_ref()\n                                    .map(|re| re.to_owned()))));\n+    logv(c, format!(\"filter_exact: {}\", config.filter_exact));\n     logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n     logv(c, format!(\"host-rustcflags: {}\",\n                     opt_str(&config.host_rustcflags)));\n@@ -309,6 +312,7 @@ pub fn run_tests(config: &Config) {\n pub fn test_opts(config: &Config) -> test::TestOpts {\n     test::TestOpts {\n         filter: config.filter.clone(),\n+        filter_exact: config.filter_exact,\n         run_ignored: config.run_ignored,\n         quiet: config.quiet,\n         logfile: config.logfile.clone(),"}, {"sha": "e85f4b2181357350e038b5142d739f400349c923", "filename": "src/vendor/gcc/.cargo-checksum.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fvendor%2Fgcc%2F.cargo-checksum.json", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fvendor%2Fgcc%2F.cargo-checksum.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2F.cargo-checksum.json?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -1 +1 @@\n-{\"files\":{\".cargo-ok\":\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\".gitignore\":\"f9b1ca6ae27d1c18215265024629a8960c31379f206d9ed20f64e0b2dcf79805\",\".travis.yml\":\"5cee7774cf6d876246a0ae0f8362cceeecec5924b751049c945faac9342565ff\",\"Cargo.toml\":\"2634dedd87889b33a794e31b41a8d8d4713ef40382be3d464229707679bd83da\",\"LICENSE-APACHE\":\"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2\",\"LICENSE-MIT\":\"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397\",\"README.md\":\"ecb2d93f4c81edbd48d8742ff7887dc0a4530a5890967839090bbc972d49bebe\",\"appveyor.yml\":\"46c77d913eaa45871296942c2cd96ef092c9dcaf19201cb5c500a5107faeb06f\",\"src/bin/gcc-shim.rs\":\"11edfe1fc6f932bd42ffffda5145833302bc163e0b87dc0d54f4bd0997ad4708\",\"src/lib.rs\":\"5eb0e311367226ed0420f5e2dac10cc35fc0a3be639a612b6e8ea6d24f646634\",\"src/registry.rs\":\"3e2a42581ebb82e325dd5600c6571cef937b35003b2927dc618967f5238a2058\",\"src/windows_registry.rs\":\"906653c020ffe9d572e435f3fc3a8892d9e0a13240ba297db01ce0a288e08cdb\",\"tests/cc_env.rs\":\"d92c5e3d3d43ac244e63b2cd2c93a521fcf124bf1ccf8d4c6bfa7f8333d88976\",\"tests/support/mod.rs\":\"d11ed0db4dda5ecf5fb970c9b0c56428cd47421a2742f07032e2cc6b0a0f07e2\",\"tests/test.rs\":\"164220f11be2eebc20315826513999970660a82feff8cc4b15b4e9d73d98324e\"},\"package\":\"553f11439bdefe755bf366b264820f1da70f3aaf3924e594b886beb9c831bcf5\"}\n\\ No newline at end of file\n+{\"files\":{\".cargo-ok\":\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\".gitignore\":\"f9b1ca6ae27d1c18215265024629a8960c31379f206d9ed20f64e0b2dcf79805\",\".travis.yml\":\"675ffe583db77282d010306f29e6d81e5070ab081deddd0300137dfbd2cb83de\",\"Cargo.toml\":\"19bb617b74de761515ef5d087fd0e30912fda1d7c22fd04fa211236dab99a509\",\"LICENSE-APACHE\":\"a60eea817514531668d7e00765731449fe14d059d3249e0bc93b36de45f759f2\",\"LICENSE-MIT\":\"378f5840b258e2779c39418f3f2d7b2ba96f1c7917dd6be0713f88305dbda397\",\"README.md\":\"ecb2d93f4c81edbd48d8742ff7887dc0a4530a5890967839090bbc972d49bebe\",\"appveyor.yml\":\"46c77d913eaa45871296942c2cd96ef092c9dcaf19201cb5c500a5107faeb06f\",\"src/bin/gcc-shim.rs\":\"11edfe1fc6f932bd42ffffda5145833302bc163e0b87dc0d54f4bd0997ad4708\",\"src/lib.rs\":\"7e7c60beccfdd145e876da81bb07dd09c5248dab0b26d93190bab4242799d51a\",\"src/registry.rs\":\"3e2a42581ebb82e325dd5600c6571cef937b35003b2927dc618967f5238a2058\",\"src/windows_registry.rs\":\"1f4211caec5a192b5f05c8a47efb27aa6a0ab976c659b9318a0cf603a28d6746\",\"tests/cc_env.rs\":\"d92c5e3d3d43ac244e63b2cd2c93a521fcf124bf1ccf8d4c6bfa7f8333d88976\",\"tests/support/mod.rs\":\"f4dad5a8133c3dd6678d9a3de057b82e624ef547b9b3e4ac9508a48962fc387b\",\"tests/test.rs\":\"164220f11be2eebc20315826513999970660a82feff8cc4b15b4e9d73d98324e\"},\"package\":\"872db9e59486ef2b14f8e8c10e9ef02de2bccef6363d7f34835dedb386b3d950\"}\n\\ No newline at end of file"}, {"sha": "bf55f49173dcc894eae82fa48fc7f4ade5a2f513", "filename": "src/vendor/gcc/.travis.yml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fvendor%2Fgcc%2F.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fvendor%2Fgcc%2F.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2F.travis.yml?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -19,12 +19,14 @@ script:\n   - cargo test --manifest-path gcc-test/Cargo.toml --target $TARGET --features parallel\n   - cargo test --manifest-path gcc-test/Cargo.toml --target $TARGET --release\n   - cargo doc\n+  - cargo clean && cargo build\n   - rustdoc --test README.md -L target/debug -L target/debug/deps\n after_success:\n   - travis-cargo --only nightly doc-upload\n env:\n   global:\n-    secure: ilbcq9zX+UaiBcwqkBGldeanbEQus9npLsi0/nF1PUxKbQsoWSVtVOehAD8Hy92D3hX2npIRyNL8GxBn85XEcBYc1h7DiWUhLcXfZie79v8Ly/qboHCfZLXlB1ofbypbyQfouEdOE9zHf0ZILYVpAgUkliv6KuVShsrKNlbn4QE=\n+    secure: \"CBtqrudgE0PS8x3kTr44jKbC2D4nfnmdYVecooNm0qnER4B4TSvZpZSQoCgKK6k4BYQuOSyFTOwYx6M79w39ZMOgyCP9ytB+tyMWL0/+ZuUQL04yVg4M5vd3oJMkOaXbvG56ncgPyFrseY+FPDg+mXAzvJk/nily37YXjkQj2D0=\"\n+\n   matrix:\n     - ARCH=x86_64\n     - ARCH=i686"}, {"sha": "7efdbf9b4b3808ef6ce3593deced1e07e7cdf22e", "filename": "src/vendor/gcc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fvendor%2Fgcc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fvendor%2Fgcc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2FCargo.toml?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -1,7 +1,7 @@\n [package]\n \n name = \"gcc\"\n-version = \"0.3.38\"\n+version = \"0.3.40\"\n authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n license = \"MIT/Apache-2.0\"\n repository = \"https://github.com/alexcrichton/gcc-rs\""}, {"sha": "43cc371117f018564c6d124564156d5e3feed388", "filename": "src/vendor/gcc/src/lib.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fvendor%2Fgcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fvendor%2Fgcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Fsrc%2Flib.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -353,6 +353,23 @@ impl Config {\n         self.compile_objects(&src_dst);\n         self.assemble(lib_name, &dst.join(output), &objects);\n \n+        if self.get_target().contains(\"msvc\") {\n+            let compiler = self.get_base_compiler();\n+            let atlmfc_lib = compiler.env().iter().find(|&&(ref var, _)| {\n+                var == OsStr::new(\"LIB\")\n+            }).and_then(|&(_, ref lib_paths)| {\n+                env::split_paths(lib_paths).find(|path| {\n+                    let sub = Path::new(\"atlmfc/lib\");\n+                    path.ends_with(sub) || path.parent().map_or(false, |p| p.ends_with(sub))\n+                })\n+            });\n+\n+            if let Some(atlmfc_lib) = atlmfc_lib {\n+                self.print(&format!(\"cargo:rustc-link-search=native={}\",\n+                                    atlmfc_lib.display()));\n+            }\n+        }\n+\n         self.print(&format!(\"cargo:rustc-link-lib=static={}\",\n                             &output[3..output.len() - 2]));\n         self.print(&format!(\"cargo:rustc-link-search=native={}\", dst.display()));\n@@ -446,17 +463,20 @@ impl Config {\n \n         if msvc {\n             cmd.args.push(\"/nologo\".into());\n-            cmd.args.push(\"/MD\".into()); // link against msvcrt.dll for now\n+            let features = env::var(\"CARGO_CFG_TARGET_FEATURE\")\n+                              .unwrap_or(String::new());\n+            if features.contains(\"crt-static\") {\n+                cmd.args.push(\"/MT\".into());\n+            } else {\n+                cmd.args.push(\"/MD\".into());\n+            }\n             match &opt_level[..] {\n                 \"z\" | \"s\" => cmd.args.push(\"/Os\".into()),\n                 \"2\" => cmd.args.push(\"/O2\".into()),\n                 \"1\" => cmd.args.push(\"/O1\".into()),\n                 _ => {}\n             }\n-            if target.contains(\"i686\") {\n-                cmd.args.push(\"/SAFESEH\".into());\n-            } else if target.contains(\"i586\") {\n-                cmd.args.push(\"/SAFESEH\".into());\n+            if target.contains(\"i586\") {\n                 cmd.args.push(\"/ARCH:IA32\".into());\n             }\n         } else if nvcc {\n@@ -489,27 +509,48 @@ impl Config {\n                 cmd.args.push(\"-Xcompiler\".into());\n                 cmd.args.push(\"\\'-fPIC\\'\".into());\n             }\n+\n             if target.contains(\"musl\") {\n                 cmd.args.push(\"-static\".into());\n             }\n \n+            // armv7 targets get to use armv7 instructions\n             if target.starts_with(\"armv7-unknown-linux-\") {\n                 cmd.args.push(\"-march=armv7-a\".into());\n             }\n+\n+            // On android we can guarantee some extra float instructions\n+            // (specified in the android spec online)\n             if target.starts_with(\"armv7-linux-androideabi\") {\n                 cmd.args.push(\"-march=armv7-a\".into());\n                 cmd.args.push(\"-mfpu=vfpv3-d16\".into());\n             }\n+\n+            // For us arm == armv6 by default\n             if target.starts_with(\"arm-unknown-linux-\") {\n                 cmd.args.push(\"-march=armv6\".into());\n                 cmd.args.push(\"-marm\".into());\n             }\n+\n+            // Turn codegen down on i586 to avoid some instructions.\n             if target.starts_with(\"i586-unknown-linux-\") {\n                 cmd.args.push(\"-march=pentium\".into());\n             }\n+\n+            // Set codegen level for i686 correctly\n             if target.starts_with(\"i686-unknown-linux-\") {\n                 cmd.args.push(\"-march=i686\".into());\n             }\n+\n+            // Looks like `musl-gcc` makes is hard for `-m32` to make its way\n+            // all the way to the linker, so we need to actually instruct the\n+            // linker that we're generating 32-bit executables as well. This'll\n+            // typically only be used for build scripts which transitively use\n+            // these flags that try to compile executables.\n+            if target == \"i686-unknown-linux-musl\" {\n+                cmd.args.push(\"-Wl,-melf_i386\".into());\n+            }\n+\n             if target.starts_with(\"thumb\") {\n                 cmd.args.push(\"-mthumb\".into());\n \n@@ -518,10 +559,14 @@ impl Config {\n                 }\n             }\n             if target.starts_with(\"thumbv6m\") {\n-                cmd.args.push(\"-march=armv6-m\".into());\n+                cmd.args.push(\"-march=armv6s-m\".into());\n             }\n             if target.starts_with(\"thumbv7em\") {\n                 cmd.args.push(\"-march=armv7e-m\".into());\n+\n+                if target.ends_with(\"eabihf\") {\n+                    cmd.args.push(\"-mfpu=fpv4-sp-d16\".into())\n+                }\n             }\n             if target.starts_with(\"thumbv7m\") {\n                 cmd.args.push(\"-march=armv7-m\".into());\n@@ -739,6 +784,7 @@ impl Config {\n                     \"powerpc64-unknown-linux-gnu\" => Some(\"powerpc-linux-gnu\"),\n                     \"powerpc64le-unknown-linux-gnu\" => Some(\"powerpc64le-linux-gnu\"),\n                     \"s390x-unknown-linux-gnu\" => Some(\"s390x-linux-gnu\"),\n+                    \"sparc64-unknown-netbsd\" => Some(\"sparc64--netbsd\"),\n                     \"thumbv6m-none-eabi\" => Some(\"arm-none-eabi\"),\n                     \"thumbv7em-none-eabi\" => Some(\"arm-none-eabi\"),\n                     \"thumbv7em-none-eabihf\" => Some(\"arm-none-eabi\"),\n@@ -805,6 +851,8 @@ impl Config {\n                 None\n             } else if target.contains(\"darwin\") {\n                 Some(\"c++\".to_string())\n+            } else if target.contains(\"freebsd\") {\n+                Some(\"c++\".to_string())\n             } else {\n                 Some(\"stdc++\".to_string())\n             }"}, {"sha": "e16a33f24647884b6559990a1ab73d4fc7328b87", "filename": "src/vendor/gcc/src/windows_registry.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fvendor%2Fgcc%2Fsrc%2Fwindows_registry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fvendor%2Fgcc%2Fsrc%2Fwindows_registry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Fsrc%2Fwindows_registry.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -211,6 +211,11 @@ pub fn find_tool(target: &str, tool: &str) -> Option<Tool> {\n             let sub = otry!(vc_lib_subdir(target));\n             tool.libs.push(path.join(\"lib\").join(sub));\n             tool.include.push(path.join(\"include\"));\n+            let atlmfc_path = path.join(\"atlmfc\");\n+            if atlmfc_path.exists() {\n+                tool.libs.push(atlmfc_path.join(\"lib\").join(sub));\n+                tool.include.push(atlmfc_path.join(\"include\"));\n+            }\n             Some(tool)\n         }).next()\n     }"}, {"sha": "5c40984eb6a0999f27ba3195f7827324620957b4", "filename": "src/vendor/gcc/tests/support/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fvendor%2Fgcc%2Ftests%2Fsupport%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/src%2Fvendor%2Fgcc%2Ftests%2Fsupport%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvendor%2Fgcc%2Ftests%2Fsupport%2Fmod.rs?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -23,6 +23,9 @@ impl Test {\n     pub fn new() -> Test {\n         let mut gcc = PathBuf::from(env::current_exe().unwrap());\n         gcc.pop();\n+        if gcc.ends_with(\"deps\") {\n+            gcc.pop();\n+        }\n         gcc.push(format!(\"gcc-shim{}\", env::consts::EXE_SUFFIX));\n         Test {\n             td: TempDir::new(\"gcc-test\").unwrap(),"}, {"sha": "d281a6abc93e37ef7321bf83110ec54846e3df5a", "filename": "x.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e15dc108c66891da04aa8c3f77162746fab4277/x.py", "raw_url": "https://github.com/rust-lang/rust/raw/3e15dc108c66891da04aa8c3f77162746fab4277/x.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/x.py?ref=3e15dc108c66891da04aa8c3f77162746fab4277", "patch": "@@ -16,4 +16,7 @@\n \n import bootstrap\n \n-bootstrap.main()\n+try:\n+    bootstrap.main()\n+except KeyboardInterrupt:\n+    sys.exit()"}]}