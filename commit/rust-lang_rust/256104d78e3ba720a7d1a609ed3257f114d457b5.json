{"sha": "256104d78e3ba720a7d1a609ed3257f114d457b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NjEwNGQ3OGUzYmE3MjBhN2QxYTYwOWVkMzI1N2YxMTRkNDU3YjU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-12T16:11:36Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-13T16:58:37Z"}, "message": "Extract ImportAssets out of auto_import", "tree": {"sha": "c8667c6354031c4cd71eaa31e884ece7817e8cac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8667c6354031c4cd71eaa31e884ece7817e8cac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/256104d78e3ba720a7d1a609ed3257f114d457b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/256104d78e3ba720a7d1a609ed3257f114d457b5", "html_url": "https://github.com/rust-lang/rust/commit/256104d78e3ba720a7d1a609ed3257f114d457b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/256104d78e3ba720a7d1a609ed3257f114d457b5/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d13939260f565fe6fb176b15e23201aafc2d11e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d13939260f565fe6fb176b15e23201aafc2d11e", "html_url": "https://github.com/rust-lang/rust/commit/3d13939260f565fe6fb176b15e23201aafc2d11e"}], "stats": {"total": 514, "additions": 273, "deletions": 241}, "files": [{"sha": "0fd2f94fa40ea7fe3ef323bfe6cc72cd186f92d3", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 18, "deletions": 241, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/256104d78e3ba720a7d1a609ed3257f114d457b5/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/256104d78e3ba720a7d1a609ed3257f114d457b5/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=256104d78e3ba720a7d1a609ed3257f114d457b5", "patch": "@@ -1,21 +1,7 @@\n-use std::collections::BTreeSet;\n-\n-use either::Either;\n-use hir::{\n-    AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution, Semantics, Trait,\n-    Type,\n-};\n-use ide_db::{imports_locator, RootDatabase};\n-use insert_use::ImportScope;\n-use rustc_hash::FxHashSet;\n-use syntax::{\n-    ast::{self, AstNode},\n-    SyntaxNode,\n-};\n-\n use crate::{\n-    utils::insert_use, utils::mod_path_to_ast, AssistContext, AssistId, AssistKind, Assists,\n-    GroupLabel,\n+    utils::import_assets::{ImportAssets, ImportCandidate},\n+    utils::{insert_use, mod_path_to_ast, ImportScope},\n+    AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n };\n \n // Assist: auto_import\n@@ -38,16 +24,16 @@ use crate::{\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let auto_import_assets = AutoImportAssets::new(ctx)?;\n-    let proposed_imports = auto_import_assets.search_for_imports(ctx);\n+    let auto_import_assets = ImportAssets::new(&ctx)?;\n+    let proposed_imports = auto_import_assets.search_for_imports(&ctx.sema, &ctx.config.insert_use);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n \n-    let range = ctx.sema.original_range(&auto_import_assets.syntax_under_caret).range;\n-    let group = auto_import_assets.get_import_group_message();\n+    let range = ctx.sema.original_range(auto_import_assets.syntax_under_caret()).range;\n+    let group = import_group_message(auto_import_assets.import_candidate());\n     let scope =\n-        ImportScope::find_insert_use_container(&auto_import_assets.syntax_under_caret, ctx)?;\n+        ImportScope::find_insert_use_container(auto_import_assets.syntax_under_caret(), ctx)?;\n     let syntax = scope.as_syntax_node();\n     for import in proposed_imports {\n         acc.add_group(\n@@ -65,227 +51,18 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     Some(())\n }\n \n-#[derive(Debug)]\n-struct AutoImportAssets {\n-    import_candidate: ImportCandidate,\n-    module_with_name_to_import: Module,\n-    syntax_under_caret: SyntaxNode,\n-}\n-\n-impl AutoImportAssets {\n-    fn new(ctx: &AssistContext) -> Option<Self> {\n-        if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n-            Self::for_regular_path(path_under_caret, &ctx)\n-        } else {\n-            Self::for_method_call(ctx.find_node_at_offset_with_descend()?, &ctx)\n+fn import_group_message(import_candidate: &ImportCandidate) -> GroupLabel {\n+    let name = match import_candidate {\n+        ImportCandidate::UnqualifiedName(name) => format!(\"Import {}\", name),\n+        ImportCandidate::QualifierStart(qualifier_start) => format!(\"Import {}\", qualifier_start),\n+        ImportCandidate::TraitAssocItem(_, trait_assoc_item_name) => {\n+            format!(\"Import a trait for item {}\", trait_assoc_item_name)\n         }\n-    }\n-\n-    fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistContext) -> Option<Self> {\n-        let syntax_under_caret = method_call.syntax().to_owned();\n-        let module_with_name_to_import = ctx.sema.scope(&syntax_under_caret).module()?;\n-        Some(Self {\n-            import_candidate: ImportCandidate::for_method_call(&ctx.sema, &method_call)?,\n-            module_with_name_to_import,\n-            syntax_under_caret,\n-        })\n-    }\n-\n-    fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistContext) -> Option<Self> {\n-        let syntax_under_caret = path_under_caret.syntax().to_owned();\n-        if syntax_under_caret.ancestors().find_map(ast::Use::cast).is_some() {\n-            return None;\n+        ImportCandidate::TraitMethod(_, trait_method_name) => {\n+            format!(\"Import a trait for method {}\", trait_method_name)\n         }\n-\n-        let module_with_name_to_import = ctx.sema.scope(&syntax_under_caret).module()?;\n-        Some(Self {\n-            import_candidate: ImportCandidate::for_regular_path(&ctx.sema, &path_under_caret)?,\n-            module_with_name_to_import,\n-            syntax_under_caret,\n-        })\n-    }\n-\n-    fn get_search_query(&self) -> &str {\n-        match &self.import_candidate {\n-            ImportCandidate::UnqualifiedName(name) => name,\n-            ImportCandidate::QualifierStart(qualifier_start) => qualifier_start,\n-            ImportCandidate::TraitAssocItem(_, trait_assoc_item_name) => trait_assoc_item_name,\n-            ImportCandidate::TraitMethod(_, trait_method_name) => trait_method_name,\n-        }\n-    }\n-\n-    fn get_import_group_message(&self) -> GroupLabel {\n-        let name = match &self.import_candidate {\n-            ImportCandidate::UnqualifiedName(name) => format!(\"Import {}\", name),\n-            ImportCandidate::QualifierStart(qualifier_start) => {\n-                format!(\"Import {}\", qualifier_start)\n-            }\n-            ImportCandidate::TraitAssocItem(_, trait_assoc_item_name) => {\n-                format!(\"Import a trait for item {}\", trait_assoc_item_name)\n-            }\n-            ImportCandidate::TraitMethod(_, trait_method_name) => {\n-                format!(\"Import a trait for method {}\", trait_method_name)\n-            }\n-        };\n-        GroupLabel(name)\n-    }\n-\n-    fn search_for_imports(&self, ctx: &AssistContext) -> BTreeSet<ModPath> {\n-        let _p = profile::span(\"auto_import::search_for_imports\");\n-        let db = ctx.db();\n-        let current_crate = self.module_with_name_to_import.krate();\n-        imports_locator::find_imports(&ctx.sema, current_crate, &self.get_search_query())\n-            .into_iter()\n-            .filter_map(|candidate| match &self.import_candidate {\n-                ImportCandidate::TraitAssocItem(assoc_item_type, _) => {\n-                    let located_assoc_item = match candidate {\n-                        Either::Left(ModuleDef::Function(located_function)) => located_function\n-                            .as_assoc_item(db)\n-                            .map(|assoc| assoc.container(db))\n-                            .and_then(Self::assoc_to_trait),\n-                        Either::Left(ModuleDef::Const(located_const)) => located_const\n-                            .as_assoc_item(db)\n-                            .map(|assoc| assoc.container(db))\n-                            .and_then(Self::assoc_to_trait),\n-                        _ => None,\n-                    }?;\n-\n-                    let mut trait_candidates = FxHashSet::default();\n-                    trait_candidates.insert(located_assoc_item.into());\n-\n-                    assoc_item_type\n-                        .iterate_path_candidates(\n-                            db,\n-                            current_crate,\n-                            &trait_candidates,\n-                            None,\n-                            |_, assoc| Self::assoc_to_trait(assoc.container(db)),\n-                        )\n-                        .map(ModuleDef::from)\n-                        .map(Either::Left)\n-                }\n-                ImportCandidate::TraitMethod(function_callee, _) => {\n-                    let located_assoc_item =\n-                        if let Either::Left(ModuleDef::Function(located_function)) = candidate {\n-                            located_function\n-                                .as_assoc_item(db)\n-                                .map(|assoc| assoc.container(db))\n-                                .and_then(Self::assoc_to_trait)\n-                        } else {\n-                            None\n-                        }?;\n-\n-                    let mut trait_candidates = FxHashSet::default();\n-                    trait_candidates.insert(located_assoc_item.into());\n-\n-                    function_callee\n-                        .iterate_method_candidates(\n-                            db,\n-                            current_crate,\n-                            &trait_candidates,\n-                            None,\n-                            |_, function| {\n-                                Self::assoc_to_trait(function.as_assoc_item(db)?.container(db))\n-                            },\n-                        )\n-                        .map(ModuleDef::from)\n-                        .map(Either::Left)\n-                }\n-                _ => Some(candidate),\n-            })\n-            .filter_map(|candidate| match candidate {\n-                Either::Left(module_def) => self.module_with_name_to_import.find_use_path_prefixed(\n-                    db,\n-                    module_def,\n-                    ctx.config.insert_use.prefix_kind,\n-                ),\n-                Either::Right(macro_def) => self.module_with_name_to_import.find_use_path_prefixed(\n-                    db,\n-                    macro_def,\n-                    ctx.config.insert_use.prefix_kind,\n-                ),\n-            })\n-            .filter(|use_path| !use_path.segments.is_empty())\n-            .take(20)\n-            .collect::<BTreeSet<_>>()\n-    }\n-\n-    fn assoc_to_trait(assoc: AssocItemContainer) -> Option<Trait> {\n-        if let AssocItemContainer::Trait(extracted_trait) = assoc {\n-            Some(extracted_trait)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-enum ImportCandidate {\n-    /// Simple name like 'HashMap'\n-    UnqualifiedName(String),\n-    /// First part of the qualified name.\n-    /// For 'std::collections::HashMap', that will be 'std'.\n-    QualifierStart(String),\n-    /// A trait associated function (with no self parameter) or associated constant.\n-    /// For 'test_mod::TestEnum::test_function', `Type` is the `test_mod::TestEnum` expression type\n-    /// and `String` is the `test_function`\n-    TraitAssocItem(Type, String),\n-    /// A trait method with self parameter.\n-    /// For 'test_enum.test_method()', `Type` is the `test_enum` expression type\n-    /// and `String` is the `test_method`\n-    TraitMethod(Type, String),\n-}\n-\n-impl ImportCandidate {\n-    fn for_method_call(\n-        sema: &Semantics<RootDatabase>,\n-        method_call: &ast::MethodCallExpr,\n-    ) -> Option<Self> {\n-        if sema.resolve_method_call(method_call).is_some() {\n-            return None;\n-        }\n-        Some(Self::TraitMethod(\n-            sema.type_of_expr(&method_call.receiver()?)?,\n-            method_call.name_ref()?.syntax().to_string(),\n-        ))\n-    }\n-\n-    fn for_regular_path(\n-        sema: &Semantics<RootDatabase>,\n-        path_under_caret: &ast::Path,\n-    ) -> Option<Self> {\n-        if sema.resolve_path(path_under_caret).is_some() {\n-            return None;\n-        }\n-\n-        let segment = path_under_caret.segment()?;\n-        if let Some(qualifier) = path_under_caret.qualifier() {\n-            let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n-            let qualifier_start_path =\n-                qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n-            if let Some(qualifier_start_resolution) = sema.resolve_path(&qualifier_start_path) {\n-                let qualifier_resolution = if qualifier_start_path == qualifier {\n-                    qualifier_start_resolution\n-                } else {\n-                    sema.resolve_path(&qualifier)?\n-                };\n-                if let PathResolution::Def(ModuleDef::Adt(assoc_item_path)) = qualifier_resolution {\n-                    Some(ImportCandidate::TraitAssocItem(\n-                        assoc_item_path.ty(sema.db),\n-                        segment.syntax().to_string(),\n-                    ))\n-                } else {\n-                    None\n-                }\n-            } else {\n-                Some(ImportCandidate::QualifierStart(qualifier_start.syntax().to_string()))\n-            }\n-        } else {\n-            Some(ImportCandidate::UnqualifiedName(\n-                segment.syntax().descendants().find_map(ast::NameRef::cast)?.syntax().to_string(),\n-            ))\n-        }\n-    }\n+    };\n+    GroupLabel(name)\n }\n \n #[cfg(test)]"}, {"sha": "b37b0d2b68c345b8050d17ed5f14833fe6404ebc", "filename": "crates/assists/src/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/256104d78e3ba720a7d1a609ed3257f114d457b5/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/256104d78e3ba720a7d1a609ed3257f114d457b5/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=256104d78e3ba720a7d1a609ed3257f114d457b5", "patch": "@@ -1,5 +1,6 @@\n //! Assorted functions shared by several assists.\n pub(crate) mod insert_use;\n+pub(crate) mod import_assets;\n \n use std::{iter, ops};\n "}, {"sha": "ce5986db71c24057fc3439dd02523b7d1699c0da", "filename": "crates/assists/src/utils/import_assets.rs", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/256104d78e3ba720a7d1a609ed3257f114d457b5/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/256104d78e3ba720a7d1a609ed3257f114d457b5/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Fimport_assets.rs?ref=256104d78e3ba720a7d1a609ed3257f114d457b5", "patch": "@@ -0,0 +1,254 @@\n+//! Look up accessible paths for items.\n+use std::collections::BTreeSet;\n+\n+use either::Either;\n+use hir::{AsAssocItem, AssocItemContainer, ModuleDef, Semantics};\n+use ide_db::{imports_locator, RootDatabase};\n+use rustc_hash::FxHashSet;\n+use syntax::{ast, AstNode, SyntaxNode};\n+\n+use crate::assist_config::InsertUseConfig;\n+\n+#[derive(Debug)]\n+pub(crate) struct ImportAssets {\n+    import_candidate: ImportCandidate,\n+    module_with_name_to_import: hir::Module,\n+    syntax_under_caret: SyntaxNode,\n+}\n+\n+impl ImportAssets {\n+    pub(crate) fn new(ctx: &crate::assist_context::AssistContext) -> Option<Self> {\n+        if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n+            Self::for_regular_path(path_under_caret, &ctx.sema)\n+        } else {\n+            Self::for_method_call(ctx.find_node_at_offset_with_descend()?, &ctx.sema)\n+        }\n+    }\n+\n+    pub(crate) fn syntax_under_caret(&self) -> &SyntaxNode {\n+        &self.syntax_under_caret\n+    }\n+\n+    pub(crate) fn import_candidate(&self) -> &ImportCandidate {\n+        &self.import_candidate\n+    }\n+\n+    fn for_method_call(\n+        method_call: ast::MethodCallExpr,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> Option<Self> {\n+        let syntax_under_caret = method_call.syntax().to_owned();\n+        let module_with_name_to_import = sema.scope(&syntax_under_caret).module()?;\n+        Some(Self {\n+            import_candidate: ImportCandidate::for_method_call(sema, &method_call)?,\n+            module_with_name_to_import,\n+            syntax_under_caret,\n+        })\n+    }\n+\n+    fn for_regular_path(\n+        path_under_caret: ast::Path,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> Option<Self> {\n+        let syntax_under_caret = path_under_caret.syntax().to_owned();\n+        if syntax_under_caret.ancestors().find_map(ast::Use::cast).is_some() {\n+            return None;\n+        }\n+\n+        let module_with_name_to_import = sema.scope(&syntax_under_caret).module()?;\n+        Some(Self {\n+            import_candidate: ImportCandidate::for_regular_path(sema, &path_under_caret)?,\n+            module_with_name_to_import,\n+            syntax_under_caret,\n+        })\n+    }\n+\n+    fn get_search_query(&self) -> &str {\n+        match &self.import_candidate {\n+            ImportCandidate::UnqualifiedName(name) => name,\n+            ImportCandidate::QualifierStart(qualifier_start) => qualifier_start,\n+            ImportCandidate::TraitAssocItem(_, trait_assoc_item_name) => trait_assoc_item_name,\n+            ImportCandidate::TraitMethod(_, trait_method_name) => trait_method_name,\n+        }\n+    }\n+\n+    pub(crate) fn search_for_imports(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        config: &InsertUseConfig,\n+    ) -> BTreeSet<hir::ModPath> {\n+        let _p = profile::span(\"import_assists::search_for_imports\");\n+        self.search_for(sema, Some(config.prefix_kind))\n+    }\n+\n+    /// This may return non-absolute paths if a part of the returned path is already imported into scope.\n+    #[allow(dead_code)]\n+    pub(crate) fn search_for_relative_paths(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> BTreeSet<hir::ModPath> {\n+        let _p = profile::span(\"import_assists::search_for_relative_paths\");\n+        self.search_for(sema, None)\n+    }\n+\n+    fn search_for(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        prefixed: Option<hir::PrefixKind>,\n+    ) -> BTreeSet<hir::ModPath> {\n+        let db = sema.db;\n+        let current_crate = self.module_with_name_to_import.krate();\n+        imports_locator::find_imports(sema, current_crate, &self.get_search_query())\n+            .into_iter()\n+            .filter_map(|candidate| match &self.import_candidate {\n+                ImportCandidate::TraitAssocItem(assoc_item_type, _) => {\n+                    let located_assoc_item = match candidate {\n+                        Either::Left(ModuleDef::Function(located_function)) => located_function\n+                            .as_assoc_item(db)\n+                            .map(|assoc| assoc.container(db))\n+                            .and_then(Self::assoc_to_trait),\n+                        Either::Left(ModuleDef::Const(located_const)) => located_const\n+                            .as_assoc_item(db)\n+                            .map(|assoc| assoc.container(db))\n+                            .and_then(Self::assoc_to_trait),\n+                        _ => None,\n+                    }?;\n+\n+                    let mut trait_candidates = FxHashSet::default();\n+                    trait_candidates.insert(located_assoc_item.into());\n+\n+                    assoc_item_type\n+                        .iterate_path_candidates(\n+                            db,\n+                            current_crate,\n+                            &trait_candidates,\n+                            None,\n+                            |_, assoc| Self::assoc_to_trait(assoc.container(db)),\n+                        )\n+                        .map(ModuleDef::from)\n+                        .map(Either::Left)\n+                }\n+                ImportCandidate::TraitMethod(function_callee, _) => {\n+                    let located_assoc_item =\n+                        if let Either::Left(ModuleDef::Function(located_function)) = candidate {\n+                            located_function\n+                                .as_assoc_item(db)\n+                                .map(|assoc| assoc.container(db))\n+                                .and_then(Self::assoc_to_trait)\n+                        } else {\n+                            None\n+                        }?;\n+\n+                    let mut trait_candidates = FxHashSet::default();\n+                    trait_candidates.insert(located_assoc_item.into());\n+\n+                    function_callee\n+                        .iterate_method_candidates(\n+                            db,\n+                            current_crate,\n+                            &trait_candidates,\n+                            None,\n+                            |_, function| {\n+                                Self::assoc_to_trait(function.as_assoc_item(db)?.container(db))\n+                            },\n+                        )\n+                        .map(ModuleDef::from)\n+                        .map(Either::Left)\n+                }\n+                _ => Some(candidate),\n+            })\n+            .filter_map(|candidate| {\n+                let item: hir::ItemInNs = match candidate {\n+                    Either::Left(module_def) => module_def.into(),\n+                    Either::Right(macro_def) => macro_def.into(),\n+                };\n+                if let Some(prefix_kind) = prefixed {\n+                    self.module_with_name_to_import.find_use_path_prefixed(db, item, prefix_kind)\n+                } else {\n+                    self.module_with_name_to_import.find_use_path(db, item)\n+                }\n+            })\n+            .filter(|use_path| !use_path.segments.is_empty())\n+            .take(20)\n+            .collect::<BTreeSet<_>>()\n+    }\n+\n+    fn assoc_to_trait(assoc: AssocItemContainer) -> Option<hir::Trait> {\n+        if let AssocItemContainer::Trait(extracted_trait) = assoc {\n+            Some(extracted_trait)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) enum ImportCandidate {\n+    /// Simple name like 'HashMap'\n+    UnqualifiedName(String),\n+    /// First part of the qualified name.\n+    /// For 'std::collections::HashMap', that will be 'std'.\n+    QualifierStart(String),\n+    /// A trait associated function (with no self parameter) or associated constant.\n+    /// For 'test_mod::TestEnum::test_function', `Type` is the `test_mod::TestEnum` expression type\n+    /// and `String` is the `test_function`\n+    TraitAssocItem(hir::Type, String),\n+    /// A trait method with self parameter.\n+    /// For 'test_enum.test_method()', `Type` is the `test_enum` expression type\n+    /// and `String` is the `test_method`\n+    TraitMethod(hir::Type, String),\n+}\n+\n+impl ImportCandidate {\n+    pub(crate) fn for_method_call(\n+        sema: &Semantics<RootDatabase>,\n+        method_call: &ast::MethodCallExpr,\n+    ) -> Option<Self> {\n+        if sema.resolve_method_call(method_call).is_some() {\n+            return None;\n+        }\n+        Some(Self::TraitMethod(\n+            sema.type_of_expr(&method_call.receiver()?)?,\n+            method_call.name_ref()?.syntax().to_string(),\n+        ))\n+    }\n+\n+    pub(crate) fn for_regular_path(\n+        sema: &Semantics<RootDatabase>,\n+        path_under_caret: &ast::Path,\n+    ) -> Option<Self> {\n+        if sema.resolve_path(path_under_caret).is_some() {\n+            return None;\n+        }\n+\n+        let segment = path_under_caret.segment()?;\n+        if let Some(qualifier) = path_under_caret.qualifier() {\n+            let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n+            let qualifier_start_path =\n+                qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n+            if let Some(qualifier_start_resolution) = sema.resolve_path(&qualifier_start_path) {\n+                let qualifier_resolution = if qualifier_start_path == qualifier {\n+                    qualifier_start_resolution\n+                } else {\n+                    sema.resolve_path(&qualifier)?\n+                };\n+                if let hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) =\n+                    qualifier_resolution\n+                {\n+                    Some(ImportCandidate::TraitAssocItem(\n+                        assoc_item_path.ty(sema.db),\n+                        segment.syntax().to_string(),\n+                    ))\n+                } else {\n+                    None\n+                }\n+            } else {\n+                Some(ImportCandidate::QualifierStart(qualifier_start.syntax().to_string()))\n+            }\n+        } else {\n+            Some(ImportCandidate::UnqualifiedName(\n+                segment.syntax().descendants().find_map(ast::NameRef::cast)?.syntax().to_string(),\n+            ))\n+        }\n+    }\n+}"}]}