{"sha": "7796d519f95305fca9cec9d92d361e3df0dd999c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3OTZkNTE5Zjk1MzA1ZmNhOWNlYzlkOTJkMzYxZTNkZjBkZDk5OWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-30T00:46:33Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-09-24T01:23:19Z"}, "message": "librustc: Don't use garbage-collected closures to store cleanups.", "tree": {"sha": "0a87d2e3366678b653aed1550a67852c0603ff33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a87d2e3366678b653aed1550a67852c0603ff33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7796d519f95305fca9cec9d92d361e3df0dd999c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7796d519f95305fca9cec9d92d361e3df0dd999c", "html_url": "https://github.com/rust-lang/rust/commit/7796d519f95305fca9cec9d92d361e3df0dd999c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7796d519f95305fca9cec9d92d361e3df0dd999c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16e87cb5279cd85ac11eb31de8a0087b08d831eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/16e87cb5279cd85ac11eb31de8a0087b08d831eb", "html_url": "https://github.com/rust-lang/rust/commit/16e87cb5279cd85ac11eb31de8a0087b08d831eb"}], "stats": {"total": 145, "additions": 121, "deletions": 24}, "files": [{"sha": "0de01bced1f7ca4ecc7a9c995c32eeeccf40c814", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7796d519f95305fca9cec9d92d361e3df0dd999c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7796d519f95305fca9cec9d92d361e3df0dd999c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=7796d519f95305fca9cec9d92d361e3df0dd999c", "patch": "@@ -1191,7 +1191,7 @@ trait CustomFailureHandler {\n \n struct DynamicFailureHandler {\n     bcx: @mut Block,\n-    sp: span,\n+    sp: Span,\n     msg: @str,\n     finished: @mut Option<BasicBlockRef>,\n }"}, {"sha": "67aee43bc46b472cec2e3fe4bb622e460e009df3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7796d519f95305fca9cec9d92d361e3df0dd999c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7796d519f95305fca9cec9d92d361e3df0dd999c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7796d519f95305fca9cec9d92d361e3df0dd999c", "patch": "@@ -1320,7 +1320,7 @@ pub fn trans_block_cleanups_(bcx: @mut Block,\n                 // Some types don't need to be cleaned up during\n                 // landing pads because they can be freed en mass later\n                 if cleanup_type == normal_exit_and_unwind || !is_lpad {\n-                    bcx = cfn(bcx);\n+                    bcx = cfn.clean(bcx);\n                 }\n             }\n         }"}, {"sha": "377144b38e78cd1efb6ececcf8a7f084d4ce08da", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 119, "deletions": 22, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/7796d519f95305fca9cec9d92d361e3df0dd999c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7796d519f95305fca9cec9d92d361e3df0dd999c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=7796d519f95305fca9cec9d92d361e3df0dd999c", "patch": "@@ -294,9 +294,85 @@ pub enum cleantype {\n     normal_exit_and_unwind\n }\n \n+// Cleanup functions\n+\n+/// A cleanup function: a built-in destructor.\n+pub trait CleanupFunction {\n+    fn clean(&self, block: @mut Block) -> @mut Block;\n+}\n+\n+/// A cleanup function that calls the \"drop glue\" (destructor function) on\n+/// a typed value.\n+pub struct TypeDroppingCleanupFunction {\n+    val: ValueRef,\n+    t: ty::t,\n+}\n+\n+impl CleanupFunction for TypeDroppingCleanupFunction {\n+    fn clean(&self, block: @mut Block) -> @mut Block {\n+        glue::drop_ty(block, self.val, self.t)\n+    }\n+}\n+\n+/// A cleanup function that calls the \"drop glue\" (destructor function) on\n+/// an immediate typed value.\n+pub struct ImmediateTypeDroppingCleanupFunction {\n+    val: ValueRef,\n+    t: ty::t,\n+}\n+\n+impl CleanupFunction for ImmediateTypeDroppingCleanupFunction {\n+    fn clean(&self, block: @mut Block) -> @mut Block {\n+        glue::drop_ty_immediate(block, self.val, self.t)\n+    }\n+}\n+\n+/// A cleanup function that releases a write guard, returning a value to\n+/// mutable status.\n+pub struct WriteGuardReleasingCleanupFunction {\n+    root_key: root_map_key,\n+    frozen_val_ref: ValueRef,\n+    bits_val_ref: ValueRef,\n+    filename_val: ValueRef,\n+    line_val: ValueRef,\n+}\n+\n+impl CleanupFunction for WriteGuardReleasingCleanupFunction {\n+    fn clean(&self, bcx: @mut Block) -> @mut Block {\n+        write_guard::return_to_mut(bcx,\n+                                   self.root_key,\n+                                   self.frozen_val_ref,\n+                                   self.bits_val_ref,\n+                                   self.filename_val,\n+                                   self.line_val)\n+    }\n+}\n+\n+/// A cleanup function that frees some memory in the garbage-collected heap.\n+pub struct GCHeapFreeingCleanupFunction {\n+    ptr: ValueRef,\n+}\n+\n+impl CleanupFunction for GCHeapFreeingCleanupFunction {\n+    fn clean(&self, bcx: @mut Block) -> @mut Block {\n+        glue::trans_free(bcx, self.ptr)\n+    }\n+}\n+\n+/// A cleanup function that frees some memory in the exchange heap.\n+pub struct ExchangeHeapFreeingCleanupFunction {\n+    ptr: ValueRef,\n+}\n+\n+impl CleanupFunction for ExchangeHeapFreeingCleanupFunction {\n+    fn clean(&self, bcx: @mut Block) -> @mut Block {\n+        glue::trans_exchange_free(bcx, self.ptr)\n+    }\n+}\n+\n pub enum cleanup {\n-    clean(@fn(@mut Block) -> @mut Block, cleantype),\n-    clean_temp(ValueRef, @fn(@mut Block) -> @mut Block, cleantype),\n+    clean(@CleanupFunction, cleantype),\n+    clean_temp(ValueRef, @CleanupFunction, cleantype),\n }\n \n // Can't use deriving(Clone) because of the managed closure.\n@@ -337,13 +413,19 @@ pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n }\n \n pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n-    if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n+    if !ty::type_needs_drop(bcx.tcx(), t) {\n+        return\n+    }\n \n     debug!(\"add_clean(%s, %s, %s)\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n \n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx, None) |scope_info| {\n-        scope_info.cleanups.push(clean(|a| glue::drop_ty(a, val, t), cleanup_type));\n+        scope_info.cleanups.push(clean(@TypeDroppingCleanupFunction {\n+            val: val,\n+            t: t,\n+        } as @CleanupFunction,\n+        cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n@@ -355,9 +437,12 @@ pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n            ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     do in_scope_cx(cx, None) |scope_info| {\n-        scope_info.cleanups.push(\n-            clean_temp(val, |a| glue::drop_ty_immediate(a, val, ty),\n-                       cleanup_type));\n+        scope_info.cleanups.push(clean_temp(val,\n+            @ImmediateTypeDroppingCleanupFunction {\n+                val: val,\n+                t: ty,\n+            } as @CleanupFunction,\n+            cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n@@ -381,7 +466,12 @@ pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::NodeI\n            t.repr(bcx.tcx()));\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx, scope_id) |scope_info| {\n-        scope_info.cleanups.push(clean_temp(val, |a| glue::drop_ty(a, val, t), cleanup_type));\n+        scope_info.cleanups.push(clean_temp(val,\n+            @TypeDroppingCleanupFunction {\n+                val: val,\n+                t: t,\n+            } as @CleanupFunction,\n+            cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n@@ -405,29 +495,36 @@ pub fn add_clean_return_to_mut(bcx: @mut Block,\n            bcx.val_to_str(frozen_val_ref),\n            bcx.val_to_str(bits_val_ref));\n     do in_scope_cx(bcx, Some(scope_id)) |scope_info| {\n-        scope_info.cleanups.push(\n-            clean_temp(\n+        scope_info.cleanups.push(clean_temp(\n                 frozen_val_ref,\n-                |bcx| write_guard::return_to_mut(bcx, root_key, frozen_val_ref, bits_val_ref,\n-                                                 filename_val, line_val),\n+                @WriteGuardReleasingCleanupFunction {\n+                    root_key: root_key,\n+                    frozen_val_ref: frozen_val_ref,\n+                    bits_val_ref: bits_val_ref,\n+                    filename_val: filename_val,\n+                    line_val: line_val,\n+                } as @CleanupFunction,\n                 normal_exit_only));\n         grow_scope_clean(scope_info);\n     }\n }\n pub fn add_clean_free(cx: @mut Block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n-      heap_managed | heap_managed_unique => {\n-        let f: @fn(@mut Block) -> @mut Block = |a| glue::trans_free(a, ptr);\n-        f\n-      }\n-      heap_exchange | heap_exchange_closure => {\n-        let f: @fn(@mut Block) -> @mut Block = |a| glue::trans_exchange_free(a, ptr);\n-        f\n-      }\n+        heap_managed | heap_managed_unique => {\n+            @GCHeapFreeingCleanupFunction {\n+                ptr: ptr,\n+            } as @CleanupFunction\n+        }\n+        heap_exchange | heap_exchange_closure => {\n+            @ExchangeHeapFreeingCleanupFunction {\n+                ptr: ptr,\n+            } as @CleanupFunction\n+        }\n     };\n     do in_scope_cx(cx, None) |scope_info| {\n-        scope_info.cleanups.push(clean_temp(ptr, free_fn,\n-                                      normal_exit_and_unwind));\n+        scope_info.cleanups.push(clean_temp(ptr,\n+                                            free_fn,\n+                                            normal_exit_and_unwind));\n         grow_scope_clean(scope_info);\n     }\n }"}]}