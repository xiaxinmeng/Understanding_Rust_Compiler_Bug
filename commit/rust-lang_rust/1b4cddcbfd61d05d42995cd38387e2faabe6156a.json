{"sha": "1b4cddcbfd61d05d42995cd38387e2faabe6156a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNGNkZGNiZmQ2MWQwNWQ0Mjk5NWNkMzgzODdlMmZhYWJlNjE1NmE=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-03-15T00:48:34Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-04-05T16:52:57Z"}, "message": "Implemented remaining string pattern iterators.\n\n- Added missing reverse versions of methods\n- Added [r]matches()\n- Generated the string pattern iterators with a macro\n- Added where bounds to the methods returning reverse iterators\n  for better error messages.", "tree": {"sha": "3408c21657729fdd36fb706a12257fd62a897bc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3408c21657729fdd36fb706a12257fd62a897bc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b4cddcbfd61d05d42995cd38387e2faabe6156a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b4cddcbfd61d05d42995cd38387e2faabe6156a", "html_url": "https://github.com/rust-lang/rust/commit/1b4cddcbfd61d05d42995cd38387e2faabe6156a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b4cddcbfd61d05d42995cd38387e2faabe6156a/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf00fc4da984481a75229ce1e40f339f292d2166", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf00fc4da984481a75229ce1e40f339f292d2166", "html_url": "https://github.com/rust-lang/rust/commit/cf00fc4da984481a75229ce1e40f339f292d2166"}], "stats": {"total": 1142, "additions": 753, "deletions": 389}, "files": [{"sha": "08af7879688aa9de15252f920f16055bebaf3723", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 275, "deletions": 45, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/1b4cddcbfd61d05d42995cd38387e2faabe6156a/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4cddcbfd61d05d42995cd38387e2faabe6156a/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=1b4cddcbfd61d05d42995cd38387e2faabe6156a", "patch": "@@ -69,9 +69,12 @@ use vec::Vec;\n use slice::SliceConcatExt;\n \n pub use core::str::{FromStr, Utf8Error, Str};\n-pub use core::str::{Lines, LinesAny, MatchIndices, CharRange};\n-pub use core::str::{Split, SplitTerminator, SplitN};\n-pub use core::str::{RSplit, RSplitN};\n+pub use core::str::{Lines, LinesAny, CharRange};\n+pub use core::str::{Split, RSplit};\n+pub use core::str::{SplitN, RSplitN};\n+pub use core::str::{SplitTerminator, RSplitTerminator};\n+pub use core::str::{Matches, RMatches};\n+pub use core::str::{MatchIndices, RMatchIndices};\n pub use core::str::{from_utf8, Chars, CharIndices, Bytes};\n pub use core::str::{from_utf8_unchecked, ParseBoolError};\n pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n@@ -581,19 +584,35 @@ impl str {\n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by a pattern.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines\n+    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n     /// the split.\n+    /// Additional libraries might provide more complex patterns like regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be double ended if the pattern allows a reverse search\n+    /// and forward/reverse search yields the same elements. This is true for, eg, `char` but not\n+    /// for `&str`.\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, `rsplit()` can be used.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n     /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n     /// let v: Vec<&str> = \"\".split('X').collect();\n     /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n@@ -602,69 +621,92 @@ impl str {\n     /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(|c: char| c.is_uppercase()).collect();\n+    /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n         core_str::StrExt::split(&self[..], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters matched\n-    /// by a pattern, returning most `count` items.\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern and yielded in reverse order.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines\n+    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n     /// the split.\n+    /// Additional libraries might provide more complex patterns like regular expressions.\n     ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// string.\n+    /// # Iterator behavior\n     ///\n-    /// # Examples\n+    /// The returned iterator requires that the pattern supports a reverse search,\n+    /// and it will be double ended if a forward/reverse search yields the same elements.\n     ///\n-    /// Simple `&str` patterns:\n+    /// For iterating from the front, `split()` can be used.\n     ///\n-    /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had a little lambda\"]);\n+    /// # Examples\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n-    /// assert_eq!(v, [\"lion\", \"XtigerXleopard\"]);\n+    /// Simple patterns:\n     ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, [\"abcXdef\"]);\n+    /// ```rust\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     ///\n-    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n+    /// let v: Vec<&str> = \"\".rsplit('X').collect();\n     /// assert_eq!(v, [\"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n     ///\n-    /// ```\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(2, |c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, [\"abc\", \"def2ghi\"]);\n+    /// ```rust\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplit(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXtigerXleopard\".rsplit(|c: char| c.is_uppercase()).collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n-        core_str::StrExt::splitn(&self[..], count, pat)\n+    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplit(&self[..], pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by a pattern.\n     ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n+    /// the split.\n+    /// Additional libraries might provide more complex patterns like regular expressions.\n+    ///\n     /// Equivalent to `split`, except that the trailing substring is skipped if empty.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines\n-    /// the split.\n+    /// This method can be used for string data that is _terminated_, rather than\n+    /// _seperated_ by some string.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be double ended if the pattern allows a reverse search\n+    /// and forward/reverse search yields the same elements. This is true for, eg, `char` but not\n+    /// for `&str`.\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, `rsplit_terminator()` can be used.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n     /// assert_eq!(v, [\"A\", \"B\"]);\n     ///\n-    /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n+    /// let v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\n     /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n     /// ```\n     ///\n@@ -679,32 +721,93 @@ impl str {\n         core_str::StrExt::split_terminator(&self[..], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by a pattern,\n-    /// starting from the end of the string.\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern and yielded in reverse order.\n+    ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n+    /// the split.\n+    /// Additional libraries might provide more complex patterns like regular expressions.\n+    ///\n+    /// Equivalent to `split`, except that the trailing substring is skipped if empty.\n+    ///\n+    /// This method can be used for string data that is _terminated_, rather than\n+    /// _seperated_ by some string.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse search,\n+    /// and it will be double ended if a forward/reverse search yields the same elements.\n+    ///\n+    /// For iterating from the front, `split_terminator()` can be used.\n     ///\n     /// # Examples\n     ///\n     /// Simple patterns:\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n-    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    /// let v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\n+    /// assert_eq!(v, [\"B\", \"A\"]);\n     ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n+    /// let v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\n+    /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplit(|c: char| c.is_numeric()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi3\".rsplit_terminator(|c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+    pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        core_str::StrExt::rsplit(&self[..], pat)\n+        core_str::StrExt::rsplit_terminator(&self[..], pat)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by a pattern,\n+    /// restricted to returning\n+    /// at most `count` items.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// string.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n+    /// the split.\n+    /// Additional libraries might provide more complex patterns like regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is not efficient to support.\n+    ///\n+    /// If the pattern allows a reverse search, `rsplitn()` can be used.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"abcXdef\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(2, |c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"abc\", \"def2ghi\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n+        core_str::StrExt::splitn(&self[..], count, pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by a pattern,\n@@ -714,6 +817,16 @@ impl str {\n     /// The last element returned, if any, will contain the remainder of the\n     /// string.\n     ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n+    /// the split.\n+    /// Additional libraries might provide more complex patterns like regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will not be double ended, because it is not efficient to support.\n+    ///\n+    /// `splitn()` can be used for splitting from the front.\n+    ///\n     /// # Examples\n     ///\n     /// Simple patterns:\n@@ -722,6 +835,9 @@ impl str {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n     /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n+    ///\n     /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n     /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n     /// ```\n@@ -739,13 +855,87 @@ impl str {\n         core_str::StrExt::rsplitn(&self[..], count, pat)\n     }\n \n-    /// An iterator over the start and end indices of the disjoint matches of a `&str` within\n+    /// An iterator over the matches of a pattern within `self`.\n+    ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n+    /// the split.\n+    /// Additional libraries might provide more complex patterns like regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be double ended if the pattern allows a reverse search\n+    /// and forward/reverse search yields the same elements. This is true for, eg, `char` but not\n+    /// for `&str`.\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, `rmatches()` can be used.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections)]\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abc2abc3\".matches(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"method got recently added\")]\n+    pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n+        core_str::StrExt::matches(&self[..], pat)\n+    }\n+\n+    /// An iterator over the matches of a pattern within `self`, yielded in reverse order.\n+    ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n+    /// the split.\n+    /// Additional libraries might provide more complex patterns like regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse search,\n+    /// and it will be double ended if a forward/reverse search yields the same elements.\n+    ///\n+    /// For iterating from the front, `matches()` can be used.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections)]\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n+    /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abc2abc3\".rmatches(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"method got recently added\")]\n+    pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rmatches(&self[..], pat)\n+    }\n+\n+    /// An iterator over the start and end indices of the disjoint matches of a pattern within\n     /// `self`.\n     ///\n-    /// That is, each returned value `(start, end)` satisfies `self.slice(start, end) == sep`. For\n-    /// matches of `sep` within `self` that overlap, only the indices corresponding to the first\n+    /// For matches of `pat` within `self` that overlap, only the indices corresponding to the first\n     /// match are returned.\n     ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n+    /// the split.\n+    /// Additional libraries might provide more complex patterns like regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator will be double ended if the pattern allows a reverse search\n+    /// and forward/reverse search yields the same elements. This is true for, eg, `char` but not\n+    /// for `&str`.\n+    ///\n+    /// If the pattern allows a reverse search but its results might differ\n+    /// from a forward search, `rmatch_indices()` can be used.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -761,12 +951,52 @@ impl str {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"might have its iterator type changed\")]\n-    // NB: Right now MatchIndices yields `(usize, usize)`,\n-    // but it would be more consistent and useful to return `(usize, &str)`\n+    // NB: Right now MatchIndices yields `(usize, usize)`, but it would\n+    // be more consistent with `matches` and `char_indices` to return `(usize, &str)`\n     pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n         core_str::StrExt::match_indices(&self[..], pat)\n     }\n \n+    /// An iterator over the start and end indices of the disjoint matches of a pattern within\n+    /// `self`, yielded in reverse order.\n+    ///\n+    /// For matches of `pat` within `self` that overlap, only the indices corresponding to the last\n+    /// match are returned.\n+    ///\n+    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n+    /// the split.\n+    /// Additional libraries might provide more complex patterns like regular expressions.\n+    ///\n+    /// # Iterator behavior\n+    ///\n+    /// The returned iterator requires that the pattern supports a reverse search,\n+    /// and it will be double ended if a forward/reverse search yields the same elements.\n+    ///\n+    /// For iterating from the front, `match_indices()` can be used.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections)]\n+    /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(12,15), (6,9), (0,3)]);\n+    ///\n+    /// let v: Vec<(usize, usize)> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(4,7), (1,4)]);\n+    ///\n+    /// let v: Vec<(usize, usize)> = \"ababa\".rmatch_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(2, 5)]); // only the last `aba`\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"might have its iterator type changed\")]\n+    // NB: Right now RMatchIndices yields `(usize, usize)`, but it would\n+    // be more consistent with `rmatches` and `char_indices` to return `(usize, &str)`\n+    pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rmatch_indices(&self[..], pat)\n+    }\n+\n     /// An iterator over the lines of a string, separated by `\\n`.\n     ///\n     /// This does not include the empty string after a trailing `\\n`."}, {"sha": "99284036fd2214c3ff70bb0d49523e9d99c4a16d", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 365, "deletions": 274, "changes": 639, "blob_url": "https://github.com/rust-lang/rust/blob/1b4cddcbfd61d05d42995cd38387e2faabe6156a/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4cddcbfd61d05d42995cd38387e2faabe6156a/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=1b4cddcbfd61d05d42995cd38387e2faabe6156a", "patch": "@@ -39,96 +39,6 @@ pub use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher, SearchSt\n \n mod pattern;\n \n-macro_rules! delegate_iter {\n-    (exact $te:ty : $ti:ty) => {\n-        delegate_iter!{$te : $ti}\n-        impl<'a> ExactSizeIterator for $ti {\n-            #[inline]\n-            fn len(&self) -> usize {\n-                self.0.len()\n-            }\n-        }\n-    };\n-    ($te:ty : $ti:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a> Iterator for $ti {\n-            type Item = $te;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$te> {\n-                self.0.next()\n-            }\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                self.0.size_hint()\n-            }\n-        }\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a> DoubleEndedIterator for $ti {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$te> {\n-                self.0.next_back()\n-            }\n-        }\n-    };\n-    (pattern $te:ty : $ti:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, P: Pattern<'a>> Iterator for $ti {\n-            type Item = $te;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$te> {\n-                self.0.next()\n-            }\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                self.0.size_hint()\n-            }\n-        }\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, P: Pattern<'a>> DoubleEndedIterator for $ti\n-        where P::Searcher: DoubleEndedSearcher<'a> {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$te> {\n-                self.0.next_back()\n-            }\n-        }\n-    };\n-    (pattern forward $te:ty : $ti:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, P: Pattern<'a>> Iterator for $ti\n-        where P::Searcher: DoubleEndedSearcher<'a> {\n-            type Item = $te;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$te> {\n-                self.0.next()\n-            }\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                self.0.size_hint()\n-            }\n-        }\n-    };\n-    (pattern reverse $te:ty : $ti:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, P: Pattern<'a>> Iterator for $ti\n-            where P::Searcher: ReverseSearcher<'a>\n-        {\n-            type Item = $te;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$te> {\n-                self.0.next()\n-            }\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                self.0.size_hint()\n-            }\n-        }\n-    };\n-}\n-\n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -444,11 +354,9 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Bytes<'a>(Map<slice::Iter<'a, u8>, BytesDeref>);\n-delegate_iter!{exact u8 : Bytes<'a>}\n \n-/// A temporary fn new type that ensures that the `Bytes` iterator\n-/// is cloneable.\n-#[derive(Copy, Clone)]\n+/// A nameable, clonable fn type\n+#[derive(Clone)]\n struct BytesDeref;\n \n impl<'a> Fn<(&'a u8,)> for BytesDeref {\n@@ -474,58 +382,173 @@ impl<'a> FnOnce<(&'a u8,)> for BytesDeref {\n     }\n }\n \n-/// An iterator over the substrings of a string, separated by `sep`.\n-struct CharSplits<'a, P: Pattern<'a>> {\n-    /// The slice remaining to be iterated\n-    start: usize,\n-    end: usize,\n-    matcher: P::Searcher,\n-    /// Whether an empty string at the end is allowed\n-    allow_trailing_empty: bool,\n-    finished: bool,\n-}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Iterator for Bytes<'a> {\n+    type Item = u8;\n \n-/// An iterator over the substrings of a string, separated by `sep`,\n-/// splitting at most `count` times.\n-struct CharSplitsN<'a, P: Pattern<'a>> {\n-    iter: CharSplits<'a, P>,\n-    /// The number of items remaining\n-    count: usize,\n-}\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> {\n+        self.0.next()\n+    }\n \n-/// An iterator over the substrings of a string, separated by a\n-/// pattern, in reverse order.\n-struct RCharSplits<'a, P: Pattern<'a>> {\n-    /// The slice remaining to be iterated\n-    start: usize,\n-    end: usize,\n-    matcher: P::Searcher,\n-    /// Whether an empty string at the end of iteration is allowed\n-    allow_final_empty: bool,\n-    finished: bool,\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n }\n \n-/// An iterator over the substrings of a string, separated by a\n-/// pattern, splitting at most `count` times, in reverse order.\n-struct RCharSplitsN<'a, P: Pattern<'a>> {\n-    iter: RCharSplits<'a, P>,\n-    /// The number of splits remaining\n-    count: usize,\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> DoubleEndedIterator for Bytes<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<u8> {\n+        self.0.next_back()\n+    }\n }\n \n-/// An iterator over the lines of a string, separated by `\\n`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Lines<'a> {\n-    inner: CharSplits<'a, char>,\n+impl<'a> ExactSizeIterator for Bytes<'a> {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.0.len()\n+    }\n }\n \n-/// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct LinesAny<'a> {\n-    inner: Map<Lines<'a>, fn(&str) -> &str>,\n+/// This macro generates two public iterator structs\n+/// wrapping an private internal one that makes use of the `Pattern` API.\n+///\n+/// For all patterns `P: Pattern<'a>` the following items will be\n+/// generated (generics ommitted):\n+///\n+/// struct $forward_iterator($internal_iterator);\n+/// struct $reverse_iterator($internal_iterator);\n+///\n+/// impl Iterator for $forward_iterator\n+/// { /* internal ends up calling Searcher::next_match() */ }\n+///\n+/// impl DoubleEndedIterator for $forward_iterator\n+///       where P::Searcher: DoubleEndedSearcher\n+/// { /* internal ends up calling Searcher::next_match_back() */ }\n+///\n+/// impl Iterator for $reverse_iterator\n+///       where P::Searcher: ReverseSearcher\n+/// { /* internal ends up calling Searcher::next_match_back() */ }\n+///\n+/// impl DoubleEndedIterator for $reverse_iterator\n+///       where P::Searcher: DoubleEndedSearcher\n+/// { /* internal ends up calling Searcher::next_match() */ }\n+///\n+/// The internal one is defined outside the macro, and has almost the same\n+/// semantic as a DoubleEndedIterator by delegating to `pattern::Searcher` and\n+/// `pattern::ReverseSearcher` for both forward and reverse iteration.\n+///\n+/// \"Almost\", because a `Searcher` and a `ReverseSearcher` for a given\n+/// `Pattern` might not return the same elements, so actually implementing\n+/// `DoubleEndedIterator` for it would be incorrect.\n+/// (See the docs in `str::pattern` for more details)\n+///\n+/// However, the internal struct still represents a single ended iterator from\n+/// either end, and depending on pattern is also a valid double ended iterator,\n+/// so the two wrapper structs implement `Iterator`\n+/// and `DoubleEndedIterator` depending on the concrete pattern type, leading\n+/// to the complex impls seen above.\n+macro_rules! generate_pattern_iterators {\n+    {\n+        // Forward iterator\n+        forward:\n+            $(#[$forward_iterator_attribute:meta])*\n+            struct $forward_iterator:ident;\n+\n+        // Reverse iterator\n+        reverse:\n+            $(#[$reverse_iterator_attribute:meta])*\n+            struct $reverse_iterator:ident;\n+\n+        // Stability of all generated items\n+        stability:\n+            $(#[$common_stability_attribute:meta])*\n+\n+        // Internal almost-iterator that is being delegated to\n+        internal:\n+            $internal_iterator:ident yielding ($iterty:ty);\n+\n+        // Kind of delgation - either single ended or double ended\n+        delegate $($t:tt)*\n+    } => {\n+        $(#[$forward_iterator_attribute])*\n+        $(#[$common_stability_attribute])*\n+        pub struct $forward_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> Iterator for $forward_iterator<'a, P> {\n+            type Item = $iterty;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$iterty> {\n+                self.0.next()\n+            }\n+        }\n+\n+        $(#[$reverse_iterator_attribute])*\n+        $(#[$common_stability_attribute])*\n+        pub struct $reverse_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> Iterator for $reverse_iterator<'a, P>\n+            where P::Searcher: ReverseSearcher<'a>\n+        {\n+            type Item = $iterty;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$iterty> {\n+                self.0.next_back()\n+            }\n+        }\n+\n+        generate_pattern_iterators!($($t)* with $(#[$common_stability_attribute])*,\n+                                                $forward_iterator,\n+                                                $reverse_iterator, $iterty);\n+    };\n+    {\n+        double ended; with $(#[$common_stability_attribute:meta])*,\n+                           $forward_iterator:ident,\n+                           $reverse_iterator:ident, $iterty:ty\n+    } => {\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> DoubleEndedIterator for $forward_iterator<'a, P>\n+            where P::Searcher: DoubleEndedSearcher<'a>\n+        {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$iterty> {\n+                self.0.next_back()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> DoubleEndedIterator for $reverse_iterator<'a, P>\n+            where P::Searcher: DoubleEndedSearcher<'a>\n+        {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$iterty> {\n+                self.0.next()\n+            }\n+        }\n+    };\n+    {\n+        single ended; with $(#[$common_stability_attribute:meta])*,\n+                           $forward_iterator:ident,\n+                           $reverse_iterator:ident, $iterty:ty\n+    } => {}\n+}\n+\n+struct SplitInternal<'a, P: Pattern<'a>> {\n+    start: usize,\n+    end: usize,\n+    matcher: P::Searcher,\n+    allow_trailing_empty: bool,\n+    finished: bool,\n }\n \n-impl<'a, P: Pattern<'a>> CharSplits<'a, P> {\n+impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n     #[inline]\n     fn get_end(&mut self) -> Option<&'a str> {\n         if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n@@ -538,11 +561,6 @@ impl<'a, P: Pattern<'a>> CharSplits<'a, P> {\n             None\n         }\n     }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for CharSplits<'a, P> {\n-    type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n@@ -558,13 +576,11 @@ impl<'a, P: Pattern<'a>> Iterator for CharSplits<'a, P> {\n             None => self.get_end(),\n         }\n     }\n-}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> DoubleEndedIterator for CharSplits<'a, P>\n-where P::Searcher: DoubleEndedSearcher<'a> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n+    fn next_back(&mut self) -> Option<&'a str>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         if self.finished { return None }\n \n         if !self.allow_trailing_empty {\n@@ -590,10 +606,41 @@ where P::Searcher: DoubleEndedSearcher<'a> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P> {\n-    type Item = &'a str;\n+generate_pattern_iterators! {\n+    forward:\n+        /// Return type of `str::split()`\n+        struct Split;\n+    reverse:\n+        /// Return type of `str::rsplit()`\n+        struct RSplit;\n+    stability:\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    internal:\n+        SplitInternal yielding (&'a str);\n+    delegate double ended;\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Return type of `str::split_terminator()`\n+        struct SplitTerminator;\n+    reverse:\n+        /// Return type of `str::rsplit_terminator()`\n+        struct RSplitTerminator;\n+    stability:\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    internal:\n+        SplitInternal yielding (&'a str);\n+    delegate double ended;\n+}\n+\n+struct SplitNInternal<'a, P: Pattern<'a>> {\n+    iter: SplitInternal<'a, P>,\n+    /// The number of splits remaining\n+    count: usize,\n+}\n \n+impl<'a, P: Pattern<'a>> SplitNInternal<'a, P> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         match self.count {\n@@ -602,58 +649,151 @@ impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P> {\n             _ => { self.count -= 1; self.iter.next() }\n         }\n     }\n-}\n \n-impl<'a, P: Pattern<'a>> RCharSplits<'a, P> {\n     #[inline]\n-    fn get_remainder(&mut self) -> Option<&'a str> {\n-        if !self.finished && (self.allow_final_empty || self.end - self.start > 0) {\n-            self.finished = true;\n-            unsafe {\n-                let string = self.matcher.haystack().slice_unchecked(self.start, self.end);\n-                Some(string)\n-            }\n-        } else {\n-            None\n+    fn next_back(&mut self) -> Option<&'a str>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        match self.count {\n+            0 => None,\n+            1 => { self.count = 0; self.iter.get_end() }\n+            _ => { self.count -= 1; self.iter.next_back() }\n         }\n     }\n }\n \n+generate_pattern_iterators! {\n+    forward:\n+        /// Return type of `str::splitn()`\n+        struct SplitN;\n+    reverse:\n+        /// Return type of `str::rsplitn()`\n+        struct RSplitN;\n+    stability:\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    internal:\n+        SplitNInternal yielding (&'a str);\n+    delegate single ended;\n+}\n+\n+struct MatchIndicesInternal<'a, P: Pattern<'a>>(P::Searcher);\n+\n+impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, usize)> {\n+        self.0.next_match()\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, usize)>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        self.0.next_match_back()\n+    }\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Return type of `str::match_indices()`\n+        struct MatchIndices;\n+    reverse:\n+        /// Return type of `str::rmatch_indices()`\n+        struct RMatchIndices;\n+    stability:\n+        #[unstable(feature = \"core\",\n+                   reason = \"type may be removed or have its iterator impl changed\")]\n+    internal:\n+        MatchIndicesInternal yielding ((usize, usize));\n+    delegate double ended;\n+}\n+\n+struct MatchesInternal<'a, P: Pattern<'a>>(P::Searcher);\n+\n+impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next_match().map(|(a, b)| unsafe {\n+            // Indices are known to be on utf8 boundaries\n+            self.0.haystack().slice_unchecked(a, b)\n+        })\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        self.0.next_match_back().map(|(a, b)| unsafe {\n+            // Indices are known to be on utf8 boundaries\n+            self.0.haystack().slice_unchecked(a, b)\n+        })\n+    }\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Return type of `str::matches()`\n+        struct Matches;\n+    reverse:\n+        /// Return type of `str::rmatches()`\n+        struct RMatches;\n+    stability:\n+        #[unstable(feature = \"core\", reason = \"type got recently added\")]\n+    internal:\n+        MatchesInternal yielding (&'a str);\n+    delegate double ended;\n+}\n+\n+/// Return type of `str::lines()`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Lines<'a>(SplitTerminator<'a, char>);\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for RCharSplits<'a, P>\n-    where P::Searcher: ReverseSearcher<'a>\n-{\n+impl<'a> Iterator for Lines<'a> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n-        if self.finished { return None }\n+        self.0.next()\n+    }\n \n-        let haystack = self.matcher.haystack();\n-        match self.matcher.next_match_back() {\n-            Some((a, b)) => unsafe {\n-                let elt = haystack.slice_unchecked(b, self.end);\n-                self.end = a;\n-                Some(elt)\n-            },\n-            None => self.get_remainder(),\n-        }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> DoubleEndedIterator for Lines<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back()\n     }\n }\n \n+/// Return type of `str::lines_any()`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct LinesAny<'a>(Map<Lines<'a>, fn(&str) -> &str>);\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for RCharSplitsN<'a, P>\n-    where P::Searcher: ReverseSearcher<'a>\n-{\n+impl<'a> Iterator for LinesAny<'a> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n-        match self.count {\n-            0 => None,\n-            1 => { self.count -= 1; self.iter.get_remainder() }\n-            _ => { self.count -= 1; self.iter.next() }\n-        }\n+        self.0.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> DoubleEndedIterator for LinesAny<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back()\n     }\n }\n \n@@ -939,22 +1079,6 @@ struct OldMatchIndices<'a, 'b> {\n     searcher: OldSearcher\n }\n \n-// FIXME: #21637 Prevents a Clone impl\n-/// An iterator over the start and end indices of the matches of a\n-/// substring within a larger string\n-#[unstable(feature = \"core\", reason = \"type may be removed\")]\n-pub struct MatchIndices<'a, P: Pattern<'a>>(P::Searcher);\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for MatchIndices<'a, P> {\n-    type Item = (usize, usize);\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<(usize, usize)> {\n-        self.0.next_match()\n-    }\n-}\n-\n impl<'a, 'b>  OldMatchIndices<'a, 'b> {\n     #[inline]\n     #[allow(dead_code)]\n@@ -1292,31 +1416,6 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n     fn as_slice(&self) -> &str { Str::as_slice(*self) }\n }\n \n-/// Return type of `str::split`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Split<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n-delegate_iter!{pattern &'a str : Split<'a, P>}\n-\n-/// Return type of `str::split_terminator`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SplitTerminator<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n-delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n-\n-/// Return type of `str::splitn`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n-delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n-\n-/// Return type of `str::rsplit`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RSplit<'a, P: Pattern<'a>>(RCharSplits<'a, P>);\n-delegate_iter!{pattern reverse &'a str : RSplit<'a, P>}\n-\n-/// Return type of `str::rsplitn`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RSplitN<'a, P: Pattern<'a>>(RCharSplitsN<'a, P>);\n-delegate_iter!{pattern reverse &'a str : RSplitN<'a, P>}\n-\n /// Methods for string slices\n #[allow(missing_docs)]\n pub trait StrExt {\n@@ -1329,13 +1428,20 @@ pub trait StrExt {\n     fn bytes<'a>(&'a self) -> Bytes<'a>;\n     fn char_indices<'a>(&'a self) -> CharIndices<'a>;\n     fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P>;\n-    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n-    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n     fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n         where P::Searcher: ReverseSearcher<'a>;\n+    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n     fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n         where P::Searcher: ReverseSearcher<'a>;\n+    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n+    fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>;\n+    fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P>;\n+    fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>;\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n+    fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>;\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n     fn char_len(&self) -> usize;\n@@ -1402,7 +1508,7 @@ impl StrExt for str {\n \n     #[inline]\n     fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n-        Split(CharSplits {\n+        Split(SplitInternal {\n             start: 0,\n             end: self.len(),\n             matcher: pat.into_searcher(self),\n@@ -1411,55 +1517,72 @@ impl StrExt for str {\n         })\n     }\n \n+    #[inline]\n+    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        RSplit(self.split(pat).0)\n+    }\n+\n     #[inline]\n     fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n-        SplitN(CharSplitsN {\n+        SplitN(SplitNInternal {\n             iter: self.split(pat).0,\n             count: count,\n         })\n     }\n \n+    #[inline]\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        RSplitN(self.splitn(count, pat).0)\n+    }\n+\n     #[inline]\n     fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n-        SplitTerminator(CharSplits {\n+        SplitTerminator(SplitInternal {\n             allow_trailing_empty: false,\n             ..self.split(pat).0\n         })\n     }\n \n     #[inline]\n-    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+    fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        RSplit(RCharSplits {\n-            start: 0,\n-            end: self.len(),\n-            matcher: pat.into_searcher(self),\n-            allow_final_empty: true,\n-            finished: false,\n-        })\n+        RSplitTerminator(self.split_terminator(pat).0)\n     }\n \n     #[inline]\n-    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+    fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n+        Matches(MatchesInternal(pat.into_searcher(self)))\n+    }\n+\n+    #[inline]\n+    fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        RSplitN(RCharSplitsN {\n-            iter: self.rsplit(pat).0,\n-            count: count,\n-        })\n+        RMatches(self.matches(pat).0)\n     }\n \n     #[inline]\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n-        MatchIndices(pat.into_searcher(self))\n+        MatchIndices(MatchIndicesInternal(pat.into_searcher(self)))\n     }\n \n+    #[inline]\n+    fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        RMatchIndices(self.match_indices(pat).0)\n+    }\n     #[inline]\n     fn lines(&self) -> Lines {\n-        Lines { inner: self.split_terminator('\\n').0 }\n+        Lines(self.split_terminator('\\n'))\n     }\n \n+    #[inline]\n     fn lines_any(&self) -> LinesAny {\n         fn f(line: &str) -> &str {\n             let l = line.len();\n@@ -1468,7 +1591,7 @@ impl StrExt for str {\n         }\n \n         let f: fn(&str) -> &str = f; // coerce to fn pointer\n-        LinesAny { inner: self.lines().map(f) }\n+        LinesAny(self.lines().map(f))\n     }\n \n     #[inline]\n@@ -1709,35 +1832,3 @@ impl<'a> Default for &'a str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> &'a str { \"\" }\n }\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for Lines<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> DoubleEndedIterator for Lines<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for LinesAny<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> DoubleEndedIterator for LinesAny<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n-}"}, {"sha": "0c2a58f3ca7c329ecef55c7c0c9161ecb1ef734b", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 113, "deletions": 70, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/1b4cddcbfd61d05d42995cd38387e2faabe6156a/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4cddcbfd61d05d42995cd38387e2faabe6156a/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=1b4cddcbfd61d05d42995cd38387e2faabe6156a", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! The string Pattern API.\n+//!\n+//! For more details, see the traits `Pattern`, `Searcher`,\n+//! `ReverseSearcher` and `DoubleEndedSearcher`.\n+\n use prelude::*;\n \n // Pattern\n@@ -223,7 +228,9 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n /// `\"[aa]a\"` or `\"a[aa]\"`, depending from which side it is searched.\n pub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}\n \n+/////////////////////////////////////////////////////////////////////////////\n // Impl for a CharEq wrapper\n+/////////////////////////////////////////////////////////////////////////////\n \n #[doc(hidden)]\n trait CharEq {\n@@ -261,6 +268,7 @@ impl<'a> CharEq for &'a [char] {\n \n struct CharEqPattern<C: CharEq>(C);\n \n+#[derive(Clone)]\n struct CharEqSearcher<'a, C: CharEq> {\n     char_eq: C,\n     haystack: &'a str,\n@@ -330,12 +338,15 @@ unsafe impl<'a, C: CharEq> ReverseSearcher<'a> for CharEqSearcher<'a, C> {\n \n impl<'a, C: CharEq> DoubleEndedSearcher<'a> for CharEqSearcher<'a, C> {}\n \n+/////////////////////////////////////////////////////////////////////////////\n // Impl for &str\n+/////////////////////////////////////////////////////////////////////////////\n \n // Todo: Optimize the naive implementation here\n \n+/// Associated type for `<&str as Pattern<'a>>::Searcher`.\n #[derive(Clone)]\n-struct StrSearcher<'a, 'b> {\n+pub struct StrSearcher<'a, 'b> {\n     haystack: &'a str,\n     needle: &'b str,\n     start: usize,\n@@ -456,116 +467,148 @@ fn str_search_step<F, G>(mut m: &mut StrSearcher,\n     }\n }\n \n-macro_rules! char_eq_pattern_impl {\n-    ($wrapper:ty, $wrapper_ident:ident) => {\n-        fn into_searcher(self, haystack: &'a str) -> $wrapper {\n-            $wrapper_ident(CharEqPattern(self).into_searcher(haystack))\n+/////////////////////////////////////////////////////////////////////////////\n+\n+macro_rules! pattern_methods {\n+    ($t:ty, $pmap:expr, $smap:expr) => {\n+        // FIXME: #22463\n+        //type Searcher = $t;\n+\n+        #[inline]\n+        fn into_searcher(self, haystack: &'a str) -> $t {\n+            $smap($pmap(self).into_searcher(haystack))\n         }\n+\n         #[inline]\n         fn is_contained_in(self, haystack: &'a str) -> bool {\n-            CharEqPattern(self).is_contained_in(haystack)\n+            $pmap(self).is_contained_in(haystack)\n         }\n+\n         #[inline]\n         fn is_prefix_of(self, haystack: &'a str) -> bool {\n-            CharEqPattern(self).is_prefix_of(haystack)\n+            $pmap(self).is_prefix_of(haystack)\n         }\n+\n         #[inline]\n         fn is_suffix_of(self, haystack: &'a str) -> bool\n-            where $wrapper: ReverseSearcher<'a>\n+            where $t: ReverseSearcher<'a>\n         {\n-            CharEqPattern(self).is_suffix_of(haystack)\n+            $pmap(self).is_suffix_of(haystack)\n         }\n     }\n }\n \n-// Pattern for char\n-\n-impl<'a> Pattern<'a> for char {\n-    type Searcher = CharSearcher<'a>;\n-    char_eq_pattern_impl!(CharSearcher<'a>, CharSearcher);\n+macro_rules! searcher_methods {\n+    (forward) => {\n+        #[inline]\n+        fn haystack(&self) -> &'a str {\n+            self.0.haystack()\n+        }\n+        #[inline]\n+        fn next(&mut self) -> SearchStep {\n+            self.0.next()\n+        }\n+        #[inline]\n+        fn next_match(&mut self) -> Option<(usize, usize)> {\n+            self.0.next_match()\n+        }\n+        #[inline]\n+        fn next_reject(&mut self) -> Option<(usize, usize)> {\n+            self.0.next_reject()\n+        }\n+    };\n+    (reverse) => {\n+        #[inline]\n+        fn next_back(&mut self) -> SearchStep {\n+            self.0.next_back()\n+        }\n+        #[inline]\n+        fn next_match_back(&mut self) -> Option<(usize, usize)> {\n+            self.0.next_match_back()\n+        }\n+        #[inline]\n+        fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n+            self.0.next_reject_back()\n+        }\n+    }\n }\n \n-pub struct CharSearcher<'a>(CharEqSearcher<'a, char>);\n+/////////////////////////////////////////////////////////////////////////////\n+// Impl for char\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Associated type for `<char as Pattern<'a>>::Searcher`.\n+#[derive(Clone)]\n+pub struct CharSearcher<'a>(<CharEqPattern<char> as Pattern<'a>>::Searcher);\n \n unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n-    #[inline]\n-    fn haystack(&self) -> &'a str { self.0.haystack() }\n-    #[inline]\n-    fn next(&mut self) -> SearchStep { self.0.next() }\n+    searcher_methods!(forward);\n }\n+\n unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> SearchStep { self.0.next_back() }\n+    searcher_methods!(reverse);\n }\n-impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n \n-// Pattern for &[char]\n+impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n \n-impl<'a, 'b> Pattern<'a> for &'b [char] {\n-    type Searcher = CharSliceSearcher<'a, 'b>;\n-    char_eq_pattern_impl!(CharSliceSearcher<'a, 'b>, CharSliceSearcher);\n+/// Searches for chars that are equal to a given char\n+impl<'a> Pattern<'a> for char {\n+    type Searcher =  CharSearcher<'a>;\n+    pattern_methods!(CharSearcher<'a>, CharEqPattern, CharSearcher);\n }\n \n-pub struct CharSliceSearcher<'a, 'b>(CharEqSearcher<'a, &'b [char]>);\n+/////////////////////////////////////////////////////////////////////////////\n+// Impl for &[char]\n+/////////////////////////////////////////////////////////////////////////////\n+\n+// Todo: Change / Remove due to ambiguity in meaning.\n+\n+/// Associated type for `<&[char] as Pattern<'a>>::Searcher`.\n+#[derive(Clone)]\n+pub struct CharSliceSearcher<'a, 'b>(<CharEqPattern<&'b [char]> as Pattern<'a>>::Searcher);\n \n unsafe impl<'a, 'b> Searcher<'a> for CharSliceSearcher<'a, 'b> {\n-    #[inline]\n-    fn haystack(&self) -> &'a str { self.0.haystack() }\n-    #[inline]\n-    fn next(&mut self) -> SearchStep { self.0.next() }\n+    searcher_methods!(forward);\n }\n+\n unsafe impl<'a, 'b> ReverseSearcher<'a> for CharSliceSearcher<'a, 'b> {\n-    #[inline]\n-    fn next_back(&mut self) -> SearchStep { self.0.next_back() }\n+    searcher_methods!(reverse);\n }\n-impl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}\n \n-// Pattern for predicates\n+impl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}\n \n-impl<'a, F: FnMut(char) -> bool> Pattern<'a> for F {\n-    type Searcher = CharPredSearcher<'a, F>;\n-    char_eq_pattern_impl!(CharPredSearcher<'a, F>, CharPredSearcher);\n+/// Searches for chars that are equal to any of the chars in the array\n+impl<'a, 'b> Pattern<'a> for &'b [char] {\n+    type Searcher =  CharSliceSearcher<'a, 'b>;\n+    pattern_methods!(CharSliceSearcher<'a, 'b>, CharEqPattern, CharSliceSearcher);\n }\n \n-pub struct CharPredSearcher<'a, F: FnMut(char) -> bool>(CharEqSearcher<'a, F>);\n+/////////////////////////////////////////////////////////////////////////////\n+// Impl for F: FnMut(char) -> bool\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Associated type for `<F as Pattern<'a>>::Searcher`.\n+#[derive(Clone)]\n+pub struct CharPredicateSearcher<'a, F>(<CharEqPattern<F> as Pattern<'a>>::Searcher)\n+    where F: FnMut(char) -> bool;\n \n-unsafe impl<'a, F> Searcher<'a> for CharPredSearcher<'a, F>\n+unsafe impl<'a, F> Searcher<'a> for CharPredicateSearcher<'a, F>\n     where F: FnMut(char) -> bool\n {\n-    #[inline]\n-    fn haystack(&self) -> &'a str { self.0.haystack() }\n-    #[inline]\n-    fn next(&mut self) -> SearchStep { self.0.next() }\n+    searcher_methods!(forward);\n }\n-unsafe impl<'a, F> ReverseSearcher<'a> for CharPredSearcher<'a, F>\n+\n+unsafe impl<'a, F> ReverseSearcher<'a> for CharPredicateSearcher<'a, F>\n     where F: FnMut(char) -> bool\n {\n-    #[inline]\n-    fn next_back(&mut self) -> SearchStep { self.0.next_back() }\n+    searcher_methods!(reverse);\n }\n-impl<'a, F> DoubleEndedSearcher<'a> for CharPredSearcher<'a, F>\n-    where F: FnMut(char) -> bool\n-{}\n \n-// Pattern for &&str\n+impl<'a, F> DoubleEndedSearcher<'a> for CharPredicateSearcher<'a, F>\n+    where F: FnMut(char) -> bool {}\n \n-impl<'a, 'b> Pattern<'a> for &'b &'b str {\n-    type Searcher = <&'b str as Pattern<'a>>::Searcher;\n-    #[inline]\n-    fn into_searcher(self, haystack: &'a str)\n-                     -> <&'b str as Pattern<'a>>::Searcher {\n-        (*self).into_searcher(haystack)\n-    }\n-    #[inline]\n-    fn is_contained_in(self, haystack: &'a str) -> bool {\n-        (*self).is_contained_in(haystack)\n-    }\n-    #[inline]\n-    fn is_prefix_of(self, haystack: &'a str) -> bool {\n-        (*self).is_prefix_of(haystack)\n-    }\n-    #[inline]\n-    fn is_suffix_of(self, haystack: &'a str) -> bool {\n-        (*self).is_suffix_of(haystack)\n-    }\n+/// Searches for chars that match the given predicate\n+impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n+    type Searcher =  CharPredicateSearcher<'a, F>;\n+    pattern_methods!(CharPredicateSearcher<'a, F>, CharEqPattern, CharPredicateSearcher);\n }"}]}