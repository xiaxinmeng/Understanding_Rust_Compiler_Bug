{"sha": "46366faf613685eeeacf896ee9d284b28d4a3046", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2MzY2ZmFmNjEzNjg1ZWVlYWNmODk2ZWU5ZDI4NGIyOGQ0YTMwNDY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-16T20:57:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-19T02:25:55Z"}, "message": "rustc_resolve: De-indent by breaking out of match\n\nHelps reduce some rightward drift", "tree": {"sha": "12f1d95596a0eb6fbe15e659071777bdd0413ec5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12f1d95596a0eb6fbe15e659071777bdd0413ec5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46366faf613685eeeacf896ee9d284b28d4a3046", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46366faf613685eeeacf896ee9d284b28d4a3046", "html_url": "https://github.com/rust-lang/rust/commit/46366faf613685eeeacf896ee9d284b28d4a3046", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46366faf613685eeeacf896ee9d284b28d4a3046/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcaeb6aa23ecba2dc2af870668a9239136d20fa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcaeb6aa23ecba2dc2af870668a9239136d20fa3", "html_url": "https://github.com/rust-lang/rust/commit/dcaeb6aa23ecba2dc2af870668a9239136d20fa3"}], "stats": {"total": 202, "additions": 101, "deletions": 101}, "files": [{"sha": "56b05f9e726f7e7c93d29f0a99181e052036031f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/46366faf613685eeeacf896ee9d284b28d4a3046/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46366faf613685eeeacf896ee9d284b28d4a3046/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=46366faf613685eeeacf896ee9d284b28d4a3046", "patch": "@@ -412,118 +412,118 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     }\n                 };\n \n-                match mod_name {\n+                let mod_name = match mod_name {\n+                    Some(mod_name) => mod_name,\n                     None => {\n                         self.resolve_error(ty.span,\n                                            \"inherent implementations may \\\n                                             only be implemented in the same \\\n                                             module as the type they are \\\n-                                            implemented for\")\n+                                            implemented for\");\n+                        return parent.clone();\n                     }\n-                    Some(mod_name) => {\n-                        // Create the module and add all methods.\n-                        let parent_opt = parent.children.borrow().get(&mod_name).cloned();\n-                        let new_parent = match parent_opt {\n-                            // It already exists\n-                            Some(ref child) if child.get_module_if_available()\n-                                .is_some() &&\n-                                (child.get_module().kind.get() == ImplModuleKind ||\n-                                 child.get_module().kind.get() == TraitModuleKind) => {\n-                                    child.get_module()\n-                                }\n-                            Some(ref child) if child.get_module_if_available()\n-                                .is_some() &&\n-                                child.get_module().kind.get() ==\n-                                EnumModuleKind => child.get_module(),\n-                            // Create the module\n-                            _ => {\n-                                let name_bindings =\n-                                    self.add_child(mod_name, parent, ForbidDuplicateModules, sp);\n-\n-                                let parent_link = self.get_parent_link(parent, name);\n-                                let def_id = local_def(item.id);\n-                                let ns = TypeNS;\n-                                let is_public =\n-                                    !name_bindings.defined_in_namespace(ns) ||\n-                                    name_bindings.defined_in_public_namespace(ns);\n-\n-                                name_bindings.define_module(parent_link,\n-                                                            Some(def_id),\n-                                                            ImplModuleKind,\n-                                                            false,\n-                                                            is_public,\n-                                                            sp);\n-\n-                                name_bindings.get_module()\n-                            }\n-                        };\n+                };\n \n-                        // For each implementation item...\n-                        for impl_item in impl_items.iter() {\n-                            match *impl_item {\n-                                MethodImplItem(ref method) => {\n-                                    // Add the method to the module.\n-                                    let name = method.pe_ident().name;\n-                                    let method_name_bindings =\n-                                        self.add_child(name,\n-                                                       &new_parent,\n-                                                       ForbidDuplicateValues,\n-                                                       method.span);\n-                                    let def = match method.pe_explicit_self()\n-                                        .node {\n-                                            SelfStatic => {\n-                                                // Static methods become\n-                                                // `DefStaticMethod`s.\n-                                                DefStaticMethod(local_def(method.id),\n-                                                                FromImpl(local_def(item.id)))\n-                                            }\n-                                            _ => {\n-                                                // Non-static methods become\n-                                                // `DefMethod`s.\n-                                                DefMethod(local_def(method.id),\n-                                                          None,\n-                                                          FromImpl(local_def(item.id)))\n-                                            }\n-                                        };\n+                // Create the module and add all methods.\n+                let parent_opt = parent.children.borrow().get(&mod_name).cloned();\n+                let new_parent = match parent_opt {\n+                    // It already exists\n+                    Some(ref child) if child.get_module_if_available()\n+                        .is_some() &&\n+                        (child.get_module().kind.get() == ImplModuleKind ||\n+                         child.get_module().kind.get() == TraitModuleKind) => {\n+                            child.get_module()\n+                        }\n+                    Some(ref child) if child.get_module_if_available()\n+                        .is_some() &&\n+                        child.get_module().kind.get() ==\n+                        EnumModuleKind => child.get_module(),\n+                    // Create the module\n+                    _ => {\n+                        let name_bindings =\n+                            self.add_child(mod_name, parent, ForbidDuplicateModules, sp);\n+\n+                        let parent_link = self.get_parent_link(parent, name);\n+                        let def_id = local_def(item.id);\n+                        let ns = TypeNS;\n+                        let is_public =\n+                            !name_bindings.defined_in_namespace(ns) ||\n+                            name_bindings.defined_in_public_namespace(ns);\n+\n+                        name_bindings.define_module(parent_link,\n+                                                    Some(def_id),\n+                                                    ImplModuleKind,\n+                                                    false,\n+                                                    is_public,\n+                                                    sp);\n \n-                                    // NB: not IMPORTABLE\n-                                    let modifiers = if method.pe_vis() == ast::Public {\n-                                        PUBLIC\n-                                    } else {\n-                                        DefModifiers::empty()\n-                                    };\n-                                    method_name_bindings.define_value(\n-                                        def,\n-                                        method.span,\n-                                        modifiers);\n-                                }\n-                                TypeImplItem(ref typedef) => {\n-                                    // Add the typedef to the module.\n-                                    let name = typedef.ident.name;\n-                                    let typedef_name_bindings =\n-                                        self.add_child(\n-                                            name,\n-                                            &new_parent,\n-                                            ForbidDuplicateTypesAndModules,\n-                                            typedef.span);\n-                                    let def = DefAssociatedTy(local_def(\n-                                        typedef.id));\n-                                    // NB: not IMPORTABLE\n-                                    let modifiers = if typedef.vis == ast::Public {\n-                                        PUBLIC\n-                                    } else {\n-                                        DefModifiers::empty()\n-                                    };\n-                                    typedef_name_bindings.define_type(\n-                                        def,\n-                                        typedef.span,\n-                                        modifiers);\n-                                }\n-                            }\n+                        name_bindings.get_module()\n+                    }\n+                };\n+\n+                // For each implementation item...\n+                for impl_item in impl_items.iter() {\n+                    match *impl_item {\n+                        MethodImplItem(ref method) => {\n+                            // Add the method to the module.\n+                            let name = method.pe_ident().name;\n+                            let method_name_bindings =\n+                                self.add_child(name,\n+                                               &new_parent,\n+                                               ForbidDuplicateValues,\n+                                               method.span);\n+                            let def = match method.pe_explicit_self()\n+                                .node {\n+                                    SelfStatic => {\n+                                        // Static methods become\n+                                        // `DefStaticMethod`s.\n+                                        DefStaticMethod(local_def(method.id),\n+                                                        FromImpl(local_def(item.id)))\n+                                    }\n+                                    _ => {\n+                                        // Non-static methods become\n+                                        // `DefMethod`s.\n+                                        DefMethod(local_def(method.id),\n+                                                  None,\n+                                                  FromImpl(local_def(item.id)))\n+                                    }\n+                                };\n+\n+                            // NB: not IMPORTABLE\n+                            let modifiers = if method.pe_vis() == ast::Public {\n+                                PUBLIC\n+                            } else {\n+                                DefModifiers::empty()\n+                            };\n+                            method_name_bindings.define_value(\n+                                def,\n+                                method.span,\n+                                modifiers);\n+                        }\n+                        TypeImplItem(ref typedef) => {\n+                            // Add the typedef to the module.\n+                            let name = typedef.ident.name;\n+                            let typedef_name_bindings =\n+                                self.add_child(\n+                                    name,\n+                                    &new_parent,\n+                                    ForbidDuplicateTypesAndModules,\n+                                    typedef.span);\n+                            let def = DefAssociatedTy(local_def(\n+                                typedef.id));\n+                            // NB: not IMPORTABLE\n+                            let modifiers = if typedef.vis == ast::Public {\n+                                PUBLIC\n+                            } else {\n+                                DefModifiers::empty()\n+                            };\n+                            typedef_name_bindings.define_type(\n+                                def,\n+                                typedef.span,\n+                                modifiers);\n                         }\n                     }\n                 }\n-\n                 parent.clone()\n             }\n "}]}