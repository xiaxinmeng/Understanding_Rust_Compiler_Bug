{"sha": "97f870a1fc24ecf3a432170c7040863d0399eb85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3Zjg3MGExZmMyNGVjZjNhNDMyMTcwYzcwNDA4NjNkMDM5OWViODU=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-05T21:02:28Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-05T22:22:18Z"}, "message": "unignore and fix doctests in guide and reference", "tree": {"sha": "8b3f04e64ec9bc8160fe7c4c82407bfd9b504a90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b3f04e64ec9bc8160fe7c4c82407bfd9b504a90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97f870a1fc24ecf3a432170c7040863d0399eb85", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97f870a1fc24ecf3a432170c7040863d0399eb85", "html_url": "https://github.com/rust-lang/rust/commit/97f870a1fc24ecf3a432170c7040863d0399eb85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97f870a1fc24ecf3a432170c7040863d0399eb85/comments", "author": null, "committer": null, "parents": [{"sha": "a55011e788e3523cc37c1fca47fc334a74682369", "url": "https://api.github.com/repos/rust-lang/rust/commits/a55011e788e3523cc37c1fca47fc334a74682369", "html_url": "https://github.com/rust-lang/rust/commit/a55011e788e3523cc37c1fca47fc334a74682369"}], "stats": {"total": 82, "additions": 42, "deletions": 40}, "files": [{"sha": "4606a1ba846ff82e7a6c1af6bd4b4314849657c1", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97f870a1fc24ecf3a432170c7040863d0399eb85/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/97f870a1fc24ecf3a432170c7040863d0399eb85/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=97f870a1fc24ecf3a432170c7040863d0399eb85", "patch": "@@ -536,8 +536,9 @@ optimizer to consider the result used and ensures it cannot remove the\n computation entirely. This could be done for the example above by adjusting the\n `b.iter` call to\n \n-```{rust,ignore}\n-# struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let b = X;\n+```rust\n+# struct X;\n+# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n b.iter(|| {\n     // note lack of `;` (could also use an explicit `return`).\n     range(0u, 1000).fold(0, |old, new| old ^ new)\n@@ -548,11 +549,12 @@ Or, the other option is to call the generic `test::black_box` function, which\n is an opaque \"black box\" to the optimizer and so forces it to consider any\n argument as used.\n \n-```{rust,ignore}\n+```rust\n extern crate test;\n \n # fn main() {\n-# struct X; impl X { fn iter<T>(&self, _: || -> T) {} } let b = X;\n+# struct X;\n+# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n b.iter(|| {\n     test::black_box(range(0u, 1000).fold(0, |old, new| old ^ new));\n });"}, {"sha": "e60740db353bca191d1fcd7b588af5be5c654407", "filename": "src/doc/guide.md", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/97f870a1fc24ecf3a432170c7040863d0399eb85/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/97f870a1fc24ecf3a432170c7040863d0399eb85/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=97f870a1fc24ecf3a432170c7040863d0399eb85", "patch": "@@ -4231,8 +4231,8 @@ arguments, really powerful things are possible.\n \n Let's make a closure:\n \n-```{rust,ignore}\n-let add_one = |x| { 1 + x };\n+```{rust}\n+let add_one = |&: x| { 1 + x };\n \n println!(\"The sum of 5 plus 1 is {}.\", add_one(5));\n ```\n@@ -4243,9 +4243,9 @@ binding name and two parentheses, just like we would for a named function.\n \n Let's compare syntax. The two are pretty close:\n \n-```{rust,ignore}\n-let add_one = |x: i32| -> i32 { 1 + x };\n-fn  add_one   (x: i32) -> i32 { 1 + x }\n+```{rust}\n+let add_one = |&: x: i32| -> i32 { 1 + x };\n+fn  add_one      (x: i32) -> i32 { 1 + x }\n ```\n \n As you may have noticed, closures infer their argument and return types, so you\n@@ -4256,11 +4256,11 @@ There's one big difference between a closure and named functions, and it's in\n the name: a closure \"closes over its environment.\" What does that mean? It means\n this:\n \n-```{rust,ignore}\n+```{rust}\n fn main() {\n-    let x = 5;\n+    let x: i32 = 5;\n \n-    let printer = || { println!(\"x is: {}\", x); };\n+    let printer = |&:| { println!(\"x is: {}\", x); };\n \n     printer(); // prints \"x is: 5\"\n }\n@@ -4276,7 +4276,7 @@ defined. The closure borrows any variables it uses, so this will error:\n fn main() {\n     let mut x = 5;\n \n-    let printer = || { println!(\"x is: {}\", x); };\n+    let printer = |&:| { println!(\"x is: {}\", x); };\n \n     x = 6; // error: cannot assign to `x` because it is borrowed\n }\n@@ -4297,30 +4297,30 @@ now. We'll talk about them more in the \"Threads\" section of the guide.\n \n Closures are most useful as an argument to another function. Here's an example:\n \n-```{rust,ignore}\n-fn twice(x: i32, f: |i32| -> i32) -> i32 {\n+```{rust}\n+fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n     f(x) + f(x)\n }\n \n fn main() {\n-    let square = |x: i32| { x * x };\n+    let square = |&: x: i32| { x * x };\n \n     twice(5, square); // evaluates to 50\n }\n ```\n \n Let's break the example down, starting with `main`:\n \n-```{rust,ignore}\n-let square = |x: i32| { x * x };\n+```{rust}\n+let square = |&: x: i32| { x * x };\n ```\n \n We've seen this before. We make a closure that takes an integer, and returns\n its square.\n \n-```{rust,ignore}\n-# fn twice(x: i32, f: |i32| -> i32) -> i32 { f(x) + f(x) }\n-# let square = |x: i32| { x * x };\n+```{rust}\n+# fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 { f(x) + f(x) }\n+# let square = |&: x: i32| { x * x };\n twice(5, square); // evaluates to 50\n ```\n \n@@ -4342,9 +4342,9 @@ though, and that function takes an `i32` and returns an `i32`. Notice\n how the `|i32| -> i32` syntax looks a lot like our definition of `square`\n above, if we added the return type in:\n \n-```{rust,ignore}\n-let square = |x: i32| -> i32 { x * x };\n-//           |i32|    -> i32\n+```{rust}\n+let square = |&: x: i32| -> i32 { x * x };\n+//           |i32|       -> i32\n ```\n \n This function takes an `i32` and returns an `i32`.\n@@ -4357,8 +4357,8 @@ Finally, `twice` returns an `i32` as well.\n \n Okay, let's look at the body of `twice`:\n \n-```{rust,ignore}\n-fn twice(x: i32, f: |i32| -> i32) -> i32 {\n+```{rust}\n+fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n   f(x) + f(x)\n }\n ```\n@@ -4375,8 +4375,8 @@ this technique a lot.\n If we didn't want to give `square` a name, we could just define it inline.\n This example is the same as the previous one:\n \n-```{rust,ignore}\n-fn twice(x: i32, f: |i32| -> i32) -> i32 {\n+```{rust}\n+fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n     f(x) + f(x)\n }\n \n@@ -4388,8 +4388,8 @@ fn main() {\n A named function's name can be used wherever you'd use a closure. Another\n way of writing the previous example:\n \n-```{rust,ignore}\n-fn twice(x: i32, f: |i32| -> i32) -> i32 {\n+```{rust}\n+fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n     f(x) + f(x)\n }\n "}, {"sha": "5c00993d918d72a9a0d0d56997d4ba64c2eccbaf", "filename": "src/doc/reference.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/97f870a1fc24ecf3a432170c7040863d0399eb85/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/97f870a1fc24ecf3a432170c7040863d0399eb85/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=97f870a1fc24ecf3a432170c7040863d0399eb85", "patch": "@@ -1559,11 +1559,11 @@ Type parameters can be specified for a trait to make it generic. These appear\n after the trait name, using the same syntax used in [generic\n functions](#generic-functions).\n \n-``` ignore\n+```\n trait Seq<T> {\n    fn len(&self) -> uint;\n    fn elt_at(&self, n: uint) -> T;\n-   fn iter(&self, |T|);\n+   fn iter<F>(&self, F) where F: Fn(T);\n }\n ```\n \n@@ -3217,8 +3217,8 @@ expression's captured environment.\n In this example, we define a function `ten_times` that takes a higher-order\n function argument, and call it with a lambda expression as an argument.\n \n-``` ignore\n-fn ten_times(f: |int|) {\n+```\n+fn ten_times<F>(f: F) where F: Fn(int) {\n     let mut i = 0;\n     while i < 10 {\n         f(i);\n@@ -3821,14 +3821,14 @@ or `extern`), a sequence of input types and an output type.\n \n An example of a `fn` type:\n \n-``` ignore\n+```\n fn add(x: int, y: int) -> int {\n   return x + y;\n }\n \n let mut x = add(5,7);\n \n-type Binop<'a> = |int,int|: 'a -> int;\n+type Binop = fn(int, int) -> int;\n let bo: Binop = add;\n x = bo(5,7);\n ```\n@@ -3849,17 +3849,17 @@ The type of a closure mapping an input of type `A` to an output of type `B` is\n \n An example of creating and calling a closure:\n \n-``` ignore\n+```rust\n let captured_var = 10i;\n \n-let closure_no_args = || println!(\"captured_var={}\", captured_var);\n+let closure_no_args = |&:| println!(\"captured_var={}\", captured_var);\n \n-let closure_args = |arg: int| -> int {\n+let closure_args = |&: arg: int| -> int {\n   println!(\"captured_var={}, arg={}\", captured_var, arg);\n   arg // Note lack of semicolon after 'arg'\n };\n \n-fn call_closure(c1: ||, c2: |int| -> int) {\n+fn call_closure<F: Fn(), G: Fn(int) -> int>(c1: F, c2: G) {\n   c1();\n   c2(2);\n }"}]}