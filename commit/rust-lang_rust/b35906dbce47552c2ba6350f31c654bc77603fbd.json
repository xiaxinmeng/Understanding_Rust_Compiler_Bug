{"sha": "b35906dbce47552c2ba6350f31c654bc77603fbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNTkwNmRiY2U0NzU1MmMyYmE2MzUwZjMxYzY1NGJjNzc2MDNmYmQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-02-21T01:43:43Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-02-21T03:35:05Z"}, "message": "WIP", "tree": {"sha": "793818f31eff2b6083cc391b2aa227293a0e837f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/793818f31eff2b6083cc391b2aa227293a0e837f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b35906dbce47552c2ba6350f31c654bc77603fbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b35906dbce47552c2ba6350f31c654bc77603fbd", "html_url": "https://github.com/rust-lang/rust/commit/b35906dbce47552c2ba6350f31c654bc77603fbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b35906dbce47552c2ba6350f31c654bc77603fbd/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f939ddf0c9344da646367d46810eb1ac92c5780", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f939ddf0c9344da646367d46810eb1ac92c5780", "html_url": "https://github.com/rust-lang/rust/commit/4f939ddf0c9344da646367d46810eb1ac92c5780"}], "stats": {"total": 718, "additions": 382, "deletions": 336}, "files": [{"sha": "f3cd2ab8f013b0aa1ba54185a17b46b77c1ca07a", "filename": "src/chains.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=b35906dbce47552c2ba6350f31c654bc77603fbd", "patch": "@@ -93,6 +93,7 @@ use syntax::{ast, ptr};\n use syntax::codemap::{mk_sp, Span};\n \n pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    debug!(\"rewrite_chain {:?}\", shape);\n     let total_span = expr.span;\n     let (parent, subexpr_list) = make_subexpr_list(expr, context);\n \n@@ -103,42 +104,45 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     }\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n-    let parent_block_indent = chain_base_indent(context, shape.indent);\n-    let parent_context = &RewriteContext { block_indent: parent_block_indent, ..*context };\n-    let parent_rewrite = try_opt!(parent.rewrite(parent_context, shape));\n+    let mut parent_shape = shape;\n+    if is_block_expr(&parent, \"\\n\") {\n+        parent_shape = chain_base_indent(context, shape);\n+    }\n+    let parent_rewrite = try_opt!(parent.rewrite(context, parent_shape));\n \n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n-    let (indent, extend) = if !parent_rewrite.contains('\\n') && is_continuable(&parent) ||\n-                              parent_rewrite.len() <= context.config.tab_spaces {\n-\n-        let indent = if let ast::ExprKind::Try(..) = subexpr_list.last().unwrap().node {\n-            parent_block_indent.block_indent(context.config)\n+    let (nested_shape, extend) = if !parent_rewrite.contains('\\n') && is_continuable(&parent) {\n+        let nested_shape = if let ast::ExprKind::Try(..) = subexpr_list.last().unwrap().node {\n+            parent_shape.block_indent(context.config.tab_spaces)\n         } else {\n-            chain_indent(context, shape.indent + Indent::new(0, parent_rewrite.len()))\n+            chain_indent(context, shape.add_offset(parent_rewrite.len()))\n         };\n-        (indent, true)\n+        (nested_shape, true)\n     } else if is_block_expr(&parent, &parent_rewrite) {\n         // The parent is a block, so align the rest of the chain with the closing\n         // brace.\n-        (parent_block_indent, false)\n+        (parent_shape, false)\n     } else if parent_rewrite.contains('\\n') {\n-        (chain_indent(context, parent_block_indent.block_indent(context.config)), false)\n+        (chain_indent(context, parent_shape.block_indent(context.config.tab_spaces)), false)\n     } else {\n-        (chain_indent_newline(context, shape.indent + Indent::new(0, parent_rewrite.len())), false)\n+        (chain_indent_newline(context, shape.add_offset(parent_rewrite.len())), false)\n     };\n \n-    let max_width = try_opt!((shape.width + shape.indent.width()).checked_sub(indent.width()));\n+    let max_width = try_opt!((shape.width + shape.indent.width() + shape.offset).checked_sub(nested_shape.indent.width() + nested_shape.offset));\n+    // The alignement in the shape is only used if we start the item on a new\n+    // line, so we don't need to preserve the offset.\n+    let child_shape = Shape { width: max_width, ..nested_shape };\n+    debug!(\"child_shape {:?}\", child_shape);\n     let mut rewrites = try_opt!(subexpr_list.iter()\n         .rev()\n-        .map(|e| rewrite_chain_subexpr(e, total_span, context, Shape::legacy(max_width, indent)))\n+        .map(|e| rewrite_chain_subexpr(e, total_span, context, child_shape))\n         .collect::<Option<Vec<_>>>());\n \n     // Total of all items excluding the last.\n     let almost_total = rewrites[..rewrites.len() - 1]\n         .iter()\n         .fold(0, |a, b| a + first_line_width(b)) + parent_rewrite.len();\n-    let total_width = almost_total + first_line_width(rewrites.last().unwrap());\n \n     let veto_single_line = if context.config.take_source_hints && subexpr_list.len() > 1 {\n         // Look at the source code. Unless all chain elements start on the same\n@@ -152,7 +156,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         false\n     };\n \n-    let mut fits_single_line = !veto_single_line && total_width <= shape.width;\n+    let mut fits_single_line = !veto_single_line && almost_total <= shape.width;\n     if fits_single_line {\n         let len = rewrites.len();\n         let (init, last) = rewrites.split_at_mut(len - 1);\n@@ -178,7 +182,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         String::new()\n     } else {\n         // Use new lines.\n-        format!(\"\\n{}\", indent.to_string(context.config))\n+        format!(\"\\n{}\", nested_shape.indent.to_string(context.config))\n     };\n \n     let first_connector = if extend || subexpr_list.is_empty() {\n@@ -211,7 +215,7 @@ pub fn rewrite_try(expr: &ast::Expr,\n                    context: &RewriteContext,\n                    shape: Shape)\n                    -> Option<String> {\n-    let sub_expr = try_opt!(expr.rewrite(context, shape.sub_width(try_count)));\n+    let sub_expr = try_opt!(expr.rewrite(context, try_opt!(shape.sub_width(try_count))));\n     Some(format!(\"{}{}\",\n                  sub_expr,\n                  iter::repeat(\"?\").take(try_count).collect::<String>()))\n@@ -268,29 +272,29 @@ fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> (ast::Expr,\n     (parent, subexpr_list)\n }\n \n-fn chain_base_indent(context: &RewriteContext, offset: Indent) -> Indent {\n+fn chain_base_indent(context: &RewriteContext, shape: Shape) -> Shape {\n     match context.config.chain_base_indent {\n-        BlockIndentStyle::Visual => offset,\n-        BlockIndentStyle::Inherit => context.block_indent,\n-        BlockIndentStyle::Tabbed => context.block_indent.block_indent(context.config),\n+        BlockIndentStyle::Visual => shape,\n+        BlockIndentStyle::Inherit => shape.block_indent(0),\n+        BlockIndentStyle::Tabbed => shape.block_indent(context.config.tab_spaces),\n     }\n }\n \n-fn chain_indent(context: &RewriteContext, offset: Indent) -> Indent {\n+fn chain_indent(context: &RewriteContext, shape: Shape) -> Shape {\n     match context.config.chain_indent {\n-        BlockIndentStyle::Visual => offset,\n-        BlockIndentStyle::Inherit => context.block_indent,\n-        BlockIndentStyle::Tabbed => context.block_indent.block_indent(context.config),\n+        BlockIndentStyle::Visual => shape,\n+        BlockIndentStyle::Inherit => shape.block_indent(0),\n+        BlockIndentStyle::Tabbed => shape.block_indent(context.config.tab_spaces),\n     }\n }\n \n // Ignores visual indenting because this function should be called where it is\n // not possible to use visual indentation because we are starting on a newline.\n-fn chain_indent_newline(context: &RewriteContext, _offset: Indent) -> Indent {\n+fn chain_indent_newline(context: &RewriteContext, shape: Shape) -> Shape {\n     match context.config.chain_indent {\n-        BlockIndentStyle::Inherit => context.block_indent,\n+        BlockIndentStyle::Inherit => shape.block_indent(0),\n         BlockIndentStyle::Visual | BlockIndentStyle::Tabbed => {\n-            context.block_indent.block_indent(context.config)\n+            shape.block_indent(context.config.tab_spaces)\n         }\n     }\n }\n@@ -303,7 +307,7 @@ fn rewrite_method_call_with_overflow(expr_kind: &ast::ExprKind,\n                                      shape: Shape)\n                                      -> bool {\n     if let &ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) = expr_kind {\n-        let budget = match shape.width.checked_sub(almost_total) {\n+        let shape = match shape.shrink_left(almost_total) {\n             Some(b) => b,\n             None => return false,\n         };\n@@ -312,8 +316,7 @@ fn rewrite_method_call_with_overflow(expr_kind: &ast::ExprKind,\n                                                    expressions,\n                                                    total_span,\n                                                    context,\n-                                                   Shape::legacy(budget,\n-                                                                 shape.indent + almost_total));\n+                                                   shape);\n \n         if let Some(ref mut s) = last_rewrite {\n             ::std::mem::swap(s, last);\n@@ -362,8 +365,7 @@ fn rewrite_chain_subexpr(expr: &ast::Expr,\n                          -> Option<String> {\n     match expr.node {\n         ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) => {\n-            let inner = &RewriteContext { block_indent: shape.indent, ..*context };\n-            rewrite_method_call(method_name.node, types, expressions, span, inner, shape)\n+            rewrite_method_call(method_name.node, types, expressions, span, context, shape)\n         }\n         ast::ExprKind::Field(_, ref field) => {\n             let s = format!(\".{}\", field.node);"}, {"sha": "4f069ba7804371374646d0b9a69008e27d3cf54d", "filename": "src/expr.rs", "status": "modified", "additions": 190, "deletions": 221, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=b35906dbce47552c2ba6350f31c654bc77603fbd", "patch": "@@ -253,21 +253,20 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n     where LHS: Rewrite,\n           RHS: Rewrite\n {\n-    let lhs_budget = try_opt!(shape.width.checked_sub(prefix.len() + infix.len()));\n-    let rhs_budget = try_opt!(shape.width.checked_sub(suffix.len()));\n-\n     // Get \"full width\" rhs and see if it fits on the current line. This\n     // usually works fairly well since it tends to place operands of\n     // operations with high precendence close together.\n     // Note that this is non-conservative, but its just to see if it's even\n     // worth trying to put everything on one line.\n-    let rhs_result = rhs.rewrite(context, Shape::legacy(rhs_budget, shape.indent));\n+    let rhs_shape = try_opt!(shape.sub_width(suffix.len()));\n+    let rhs_result = rhs.rewrite(context, rhs_shape);\n \n     if let Some(rhs_result) = rhs_result {\n         // This is needed in case of line break not caused by a\n         // shortage of space, but by end-of-line comments, for example.\n         if !rhs_result.contains('\\n') {\n-            let lhs_result = lhs.rewrite(context, Shape::legacy(lhs_budget, shape.indent));\n+            let lhs_shape = try_opt!(shape.sub_width(prefix.len() + infix.len()));\n+            let lhs_result = lhs.rewrite(context, lhs_shape);\n             if let Some(lhs_result) = lhs_result {\n                 let mut result = format!(\"{}{}{}\", prefix, lhs_result, infix);\n \n@@ -281,14 +280,15 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n                 }\n \n                 // Try rewriting the rhs into the remaining space.\n-                let rhs_budget = try_opt!(remaining_width.checked_sub(suffix.len()));\n-                if let Some(rhs_result) = rhs.rewrite(context,\n-                                                      Shape::legacy(rhs_budget,\n-                                                                    shape.indent + result.len())) {\n-                    if rhs_result.len() <= remaining_width {\n-                        result.push_str(&rhs_result);\n-                        result.push_str(suffix);\n-                        return Some(result);\n+                let rhs_shape = shape.shrink_left(last_line_width(&result) + suffix.len());\n+                if let Some(rhs_shape) = rhs_shape {\n+                    if let Some(rhs_result) = rhs.rewrite(context, rhs_shape) {\n+                        // FIXME this should always hold.\n+                        if rhs_result.len() <= remaining_width {\n+                            result.push_str(&rhs_result);\n+                            result.push_str(suffix);\n+                            return Some(result);\n+                        }\n                     }\n                 }\n             }\n@@ -301,17 +301,16 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n     let infix = infix.trim_right();\n     let lhs_budget = try_opt!(context.config\n         .max_width\n-        .checked_sub(shape.indent.width() + prefix.len() + infix.len()));\n-    let rhs_budget = try_opt!(rhs_budget.checked_sub(prefix.len()));\n-    let rhs_offset = shape.indent + prefix.len();\n+        .checked_sub(shape.used_width() + prefix.len() + infix.len()));\n+    let rhs_shape = try_opt!(shape.sub_width(suffix.len() + prefix.len())).visual_indent(prefix.len());\n \n-    let rhs_result = try_opt!(rhs.rewrite(context, Shape::legacy(rhs_budget, rhs_offset)));\n-    let lhs_result = try_opt!(lhs.rewrite(context, Shape::legacy(lhs_budget, shape.indent)));\n+    let rhs_result = try_opt!(rhs.rewrite(context, rhs_shape));\n+    let lhs_result = try_opt!(lhs.rewrite(context, Shape { width: lhs_budget, ..shape }));\n     Some(format!(\"{}{}{}\\n{}{}{}\",\n                  prefix,\n                  lhs_result,\n                  infix,\n-                 rhs_offset.to_string(context.config),\n+                 rhs_shape.indent.to_string(context.config),\n                  rhs_result,\n                  suffix))\n }\n@@ -328,16 +327,14 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n     } else {\n         1 // \"[\"\n     };\n-    let offset = shape.indent + bracket_size;\n-    let inner_context = &RewriteContext { block_indent: offset, ..*context };\n-    let max_item_width = try_opt!(shape.width.checked_sub(bracket_size * 2));\n+    let nested_shape = try_opt!(shape.visual_indent(bracket_size).sub_width(bracket_size * 2));\n     let items =\n         itemize_list(context.codemap,\n                      expr_iter,\n                      \"]\",\n                      |item| item.span.lo,\n                      |item| item.span.hi,\n-                     |item| item.rewrite(inner_context, Shape::legacy(max_item_width, offset)),\n+                     |item| item.rewrite(context, nested_shape),\n                      span.lo,\n                      span.hi)\n             .collect::<Vec<_>>();\n@@ -347,7 +344,7 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n         .fold(Some(false), |acc, x| acc.and_then(|y| x.map(|x| x || y))));\n \n     let tactic = if has_long_item || items.iter().any(ListItem::is_multiline) {\n-        definitive_tactic(&items, ListTactic::HorizontalVertical, max_item_width)\n+        definitive_tactic(&items, ListTactic::HorizontalVertical, nested_shape.width)\n     } else {\n         DefinitiveListTactic::Mixed\n     };\n@@ -356,7 +353,7 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n-        shape: Shape::legacy(max_item_width, offset),\n+        shape: nested_shape,\n         ends_with_newline: false,\n         config: context.config,\n     };\n@@ -390,39 +387,38 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     } else {\n         \"\"\n     };\n-    let offset = shape.indent + mover.len();\n-\n     // 4 = \"|| {\".len(), which is overconservative when the closure consists of\n     // a single expression.\n-    let budget = try_opt!(shape.width.checked_sub(4 + mover.len()));\n-    // 1 = |\n-    let argument_offset = offset + 1;\n-    let ret_str = try_opt!(fn_decl.output.rewrite(context, Shape::legacy(budget, argument_offset)));\n+    let nested_shape = try_opt!(try_opt!(shape.shrink_left(mover.len())).sub_width(4));\n \n-    // 1 = space between arguments and return type.\n-    let horizontal_budget = budget.checked_sub(ret_str.len() + 1).unwrap_or(0);\n+    // 1 = |\n+    let argument_offset = nested_shape.indent + 1;\n+    let arg_shape = try_opt!(nested_shape.shrink_left(1)).visual_indent(0);\n+    let ret_str = try_opt!(fn_decl.output.rewrite(context, arg_shape));\n \n     let arg_items =\n         itemize_list(context.codemap,\n                      fn_decl.inputs.iter(),\n                      \"|\",\n                      |arg| span_lo_for_arg(arg),\n                      |arg| span_hi_for_arg(arg),\n-                     |arg| arg.rewrite(context, Shape::legacy(budget, argument_offset)),\n+                     |arg| arg.rewrite(context, arg_shape),\n                      context.codemap.span_after(span, \"|\"),\n                      body.span.lo);\n     let item_vec = arg_items.collect::<Vec<_>>();\n+    // 1 = space between arguments and return type.\n+    let horizontal_budget = nested_shape.width.checked_sub(ret_str.len() + 1).unwrap_or(0);\n     let tactic = definitive_tactic(&item_vec, ListTactic::HorizontalVertical, horizontal_budget);\n-    let budget = match tactic {\n-        DefinitiveListTactic::Horizontal => horizontal_budget,\n-        _ => budget,\n+    let arg_shape = match tactic {\n+        DefinitiveListTactic::Horizontal => try_opt!(arg_shape.sub_width(ret_str.len() + 1)),\n+        _ => arg_shape,\n     };\n \n     let fmt = ListFormatting {\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n-        shape: Shape::legacy(budget, argument_offset),\n+        shape: arg_shape,\n         ends_with_newline: false,\n         config: context.config,\n     };\n@@ -440,12 +436,11 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     }\n \n     // 1 = space between `|...|` and body.\n-    let extra_offset = extra_offset(&prefix, offset) + 1;\n-    let budget = try_opt!(shape.width.checked_sub(extra_offset));\n-    let total_offset = offset + extra_offset;\n+    let extra_offset = extra_offset(&prefix, shape) + 1;\n+    let body_shape = try_opt!(shape.sub_width(extra_offset)).add_offset(extra_offset);\n \n     if let ast::ExprKind::Block(ref block) = body.node {\n-        // The body of the closure is a block.\n+        // The body of the closure is an empty block.\n         if block.stmts.is_empty() && !block_contains_comment(block, context.codemap) {\n             return Some(format!(\"{} {{}}\", prefix));\n         }\n@@ -461,7 +456,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n                 if let Some(rw) = rewrite_closure_expr(expr,\n                                                        &prefix,\n                                                        context,\n-                                                       Shape::legacy(budget, total_offset)) {\n+                                                       body_shape) {\n                     return Some(rw);\n                 }\n             }\n@@ -472,8 +467,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n             let stmt = &block.stmts[0];\n             // 4 = braces and spaces.\n             let mut rewrite = stmt.rewrite(context,\n-                                           Shape::legacy(try_opt!(budget.checked_sub(4)),\n-                                                         total_offset));\n+                                           try_opt!(body_shape.sub_width(4)));\n \n             // Checks if rewrite succeeded and fits on a single line.\n             rewrite = and_one_line(rewrite);\n@@ -484,13 +478,14 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         }\n \n         // Either we require a block, or tried without and failed.\n-        return rewrite_closure_block(&block, prefix, context, budget);\n+        let body_shape = shape.block();\n+        return rewrite_closure_block(&block, prefix, context, body_shape);\n     }\n \n     if let Some(rw) = rewrite_closure_expr(body,\n                                            &prefix,\n                                            context,\n-                                           Shape::legacy(budget, total_offset)) {\n+                                           body_shape) {\n         return Some(rw);\n     }\n \n@@ -506,7 +501,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         rules: ast::BlockCheckMode::Default,\n         span: body.span,\n     };\n-    return rewrite_closure_block(&block, prefix, context, budget);\n+    return rewrite_closure_block(&block, prefix, context, body_shape.block());\n \n     fn rewrite_closure_expr(expr: &ast::Expr,\n                             prefix: &str,\n@@ -523,11 +518,11 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     fn rewrite_closure_block(block: &ast::Block,\n                              prefix: String,\n                              context: &RewriteContext,\n-                             budget: usize)\n+                             shape: Shape)\n                              -> Option<String> {\n         // Start with visual indent, then fall back to block indent if the\n         // closure is large.\n-        let rewrite = try_opt!(block.rewrite(&context, Shape::legacy(budget, Indent::empty())));\n+        let rewrite = try_opt!(block.rewrite(&context, shape));\n \n         let block_threshold = context.config.closure_block_indent_threshold;\n         if block_threshold < 0 || rewrite.matches('\\n').count() <= block_threshold as usize {\n@@ -536,9 +531,8 @@ fn rewrite_closure(capture: ast::CaptureBy,\n \n         // The body of the closure is big enough to be block indented, that\n         // means we must re-format.\n-        let mut context = context.clone();\n-        context.block_indent.alignment = 0;\n-        let rewrite = try_opt!(block.rewrite(&context, Shape::legacy(budget, Indent::empty())));\n+        let block_shape = shape.block();\n+        let rewrite = try_opt!(block.rewrite(&context, block_shape));\n         Some(format!(\"{} {}\", prefix, rewrite))\n     }\n }\n@@ -581,7 +575,7 @@ impl Rewrite for ast::Block {\n         }\n \n         let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n-        visitor.block_indent = context.block_indent;\n+        visitor.block_indent = shape.indent;\n \n         let prefix = match self.rules {\n             ast::BlockCheckMode::Unsafe(..) => {\n@@ -648,9 +642,7 @@ impl Rewrite for ast::Stmt {\n                                 _ => unreachable!(),\n                             },\n                             context,\n-                            Shape::legacy(context.config.max_width - shape.indent.width() -\n-                                          suffix.len(),\n-                                          shape.indent))\n+                            try_opt!(shape.sub_width(suffix.len())))\n                     .map(|s| s + suffix)\n             }\n             ast::StmtKind::Mac(..) |\n@@ -815,32 +807,32 @@ impl<'a> ControlFlow<'a> {\n impl<'a> Rewrite for ControlFlow<'a> {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         debug!(\"ControlFlow::rewrite {:?} {:?}\", self, shape);\n-        let (budget, indent) = if self.nested_if {\n+        let constr_shape = if self.nested_if {\n             // We are part of an if-elseif-else chain. Our constraints are tightened.\n             // 7 = \"} else \" .len()\n-            (try_opt!(shape.width.checked_sub(7)), shape.indent + 7)\n+            try_opt!(shape.shrink_left(7))\n         } else {\n-            (shape.width, shape.indent)\n+            shape\n         };\n \n         let label_string = rewrite_label(self.label);\n         // 1 = space after keyword.\n-        let inner_offset = indent + self.keyword.len() + label_string.len() + 1;\n-        let mut inner_width =\n-            try_opt!(budget.checked_sub(self.keyword.len() + label_string.len() + 1));\n-        if context.config.control_brace_style != ControlBraceStyle::AlwaysNextLine {\n-            // 2 = \" {\".len()\n-            inner_width = try_opt!(inner_width.checked_sub(2));\n-        }\n+        let add_offset = self.keyword.len() + label_string.len() + 1;\n \n         let pat_expr_string = match self.cond {\n             Some(cond) => {\n+                let mut cond_shape = try_opt!(constr_shape.shrink_left(add_offset));\n+                if context.config.control_brace_style != ControlBraceStyle::AlwaysNextLine {\n+                    // 2 = \" {\".len()\n+                    cond_shape = try_opt!(cond_shape.sub_width(2));\n+                }\n+\n                 try_opt!(rewrite_pat_expr(context,\n                                           self.pat,\n                                           cond,\n                                           self.matcher,\n                                           self.connector,\n-                                          Shape::legacy(inner_width, inner_offset)))\n+                                          cond_shape))\n             }\n             None => String::new(),\n         };\n@@ -855,21 +847,24 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             }\n         }\n \n+        let used_width = if pat_expr_string.contains('\\n') {\n+            last_line_width(&pat_expr_string)\n+        } else {\n+            // 2 = spaces after keyword and condition.\n+            label_string.len() + self.keyword.len() + pat_expr_string.len() + 2\n+        };\n+        let block_width = try_opt!(shape.width.checked_sub(used_width));\n         // This is used only for the empty block case: `{}`. So, we use 1 if we know\n         // we should avoid the single line case.\n-        // 2 = spaces after keyword and condition.\n-        let block_width = try_opt!(shape.width\n-            .checked_sub(label_string.len() + self.keyword.len() +\n-                         extra_offset(&pat_expr_string, inner_offset) +\n-                         2));\n         let block_width = if self.else_block.is_some() || self.nested_if {\n             min(1, block_width)\n         } else {\n             block_width\n         };\n \n-        let block_str = try_opt!(self.block\n-            .rewrite(context, Shape::legacy(block_width, shape.indent)));\n+        // TODO this .block() - not what we want if we are actually visually indented\n+        let block_shape = Shape { width: block_width, ..shape };\n+        let block_str = try_opt!(self.block.rewrite(context, block_shape));\n \n         let cond_span = if let Some(cond) = self.cond {\n             cond.span\n@@ -891,7 +886,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n         let after_cond_comment =\n             extract_comment(mk_sp(cond_span.hi, self.block.span.lo), context, shape);\n \n-        let alt_block_sep = String::from(\"\\n\") + &context.block_indent.to_string(context.config);\n+        let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n         let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n             \"\"\n         } else if context.config.control_brace_style ==\n@@ -913,14 +908,8 @@ impl<'a> Rewrite for ControlFlow<'a> {\n \n         if let Some(else_block) = self.else_block {\n             // Since this is an else block, we should not indent for the assignment preceding\n-            // the original if, so set shape.indent.alignment to 0.\n-            let shape = Shape {\n-                width: shape.width,\n-                indent: Indent {\n-                    block_indent: shape.indent.block_indent,\n-                    alignment: 0,\n-                },\n-            };\n+            // the original if, so set shape.offset to 0.\n+            let shape = Shape { offset: 0, ..shape };\n             let mut last_in_chain = false;\n             let rewrite = match else_block.node {\n                 // If the else expression is another if-else expression, prevent it\n@@ -935,7 +924,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                                         false,\n                                         true,\n                                         mk_sp(else_block.span.lo, self.span.hi))\n-                        .rewrite(context, shape)\n+                        .rewrite(context, shape.visual_indent(0))\n                 }\n                 ast::ExprKind::If(ref cond, ref if_block, ref next_else_block) => {\n                     ControlFlow::new_if(cond,\n@@ -945,13 +934,14 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                                         false,\n                                         true,\n                                         mk_sp(else_block.span.lo, self.span.hi))\n-                        .rewrite(context, shape)\n+                        .rewrite(context, shape.visual_indent(0))\n                 }\n                 _ => {\n                     last_in_chain = true;\n                     // When rewriting a block, the width is only used for single line\n                     // blocks, passing 1 lets us avoid that.\n-                    else_block.rewrite(context, Shape::legacy(min(1, shape.width), shape.indent))\n+                    let else_shape = Shape { width: min(1, shape.width), ..shape };\n+                    else_block.rewrite(context, else_shape)\n                 }\n             };\n \n@@ -1097,16 +1087,15 @@ fn rewrite_match(context: &RewriteContext,\n     // `match `cond` {`\n     let cond_budget = try_opt!(shape.width.checked_sub(8));\n     let cond_str = try_opt!(cond.rewrite(context, Shape::legacy(cond_budget, shape.indent + 6)));\n-    let alt_block_sep = String::from(\"\\n\") + &context.block_indent.to_string(context.config);\n+    let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n     let block_sep = match context.config.control_brace_style {\n         ControlBraceStyle::AlwaysSameLine => \" \",\n         _ => alt_block_sep.as_str(),\n     };\n     let mut result = format!(\"match {}{}{{\", cond_str, block_sep);\n \n-    let nested_context = context.nested_context();\n-    let arm_indent = nested_context.block_indent;\n-    let arm_indent_str = arm_indent.to_string(context.config);\n+    let arm_shape = shape.block_indent(context.config.tab_spaces);\n+    let arm_indent_str = arm_shape.indent.to_string(context.config);\n \n     let open_brace_pos = context.codemap\n         .span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])), \"{\");\n@@ -1120,15 +1109,14 @@ fn rewrite_match(context: &RewriteContext,\n         };\n         let comment = try_opt!(rewrite_match_arm_comment(context,\n                                                          &missed_str,\n-                                                         Shape::legacy(shape.width, arm_indent),\n+                                                         arm_shape,\n                                                          &arm_indent_str));\n         result.push_str(&comment);\n         result.push('\\n');\n         result.push_str(&arm_indent_str);\n \n-        let arm_str = arm.rewrite(&nested_context,\n-                                  Shape::legacy(context.config.max_width - arm_indent.width(),\n-                                                arm_indent));\n+        let arm_str = arm.rewrite(&context,\n+                                  Shape { width: context.config.max_width - arm_shape.indent.width(), .. arm_shape });\n         if let Some(ref arm_str) = arm_str {\n             result.push_str(arm_str);\n         } else {\n@@ -1143,11 +1131,11 @@ fn rewrite_match(context: &RewriteContext,\n     let last_comment = context.snippet(last_span);\n     let comment = try_opt!(rewrite_match_arm_comment(context,\n                                                      &last_comment,\n-                                                     Shape::legacy(shape.width, arm_indent),\n+                                                     arm_shape,\n                                                      &arm_indent_str));\n     result.push_str(&comment);\n     result.push('\\n');\n-    result.push_str(&context.block_indent.to_string(context.config));\n+    result.push_str(&shape.indent.to_string(context.config));\n     result.push('}');\n     Some(result)\n }\n@@ -1197,7 +1185,7 @@ impl Rewrite for ast::Arm {\n             // We only use this visitor for the attributes, should we use it for\n             // more?\n             let mut attr_visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n-            attr_visitor.block_indent = context.block_indent;\n+            attr_visitor.block_indent = shape.indent.block_only();\n             attr_visitor.last_pos = attrs[0].span.lo;\n             if attr_visitor.visit_attrs(attrs) {\n                 // Attributes included a skip instruction.\n@@ -1211,9 +1199,10 @@ impl Rewrite for ast::Arm {\n \n         // Patterns\n         // 5 = ` => {`\n-        let pat_budget = try_opt!(shape.width.checked_sub(5));\n+        let pat_shape = try_opt!(shape.sub_width(5));\n+\n         let pat_strs = try_opt!(pats.iter()\n-            .map(|p| p.rewrite(context, Shape::legacy(pat_budget, shape.indent)))\n+            .map(|p| p.rewrite(context, pat_shape))\n             .collect::<Option<Vec<_>>>());\n \n         let all_simple = pat_strs.iter().all(|p| pat_is_simple(p));\n@@ -1226,29 +1215,26 @@ impl Rewrite for ast::Arm {\n             },\n             separator: \" |\",\n             trailing_separator: SeparatorTactic::Never,\n-            shape: Shape::legacy(pat_budget, shape.indent),\n+            shape: pat_shape,\n             ends_with_newline: false,\n             config: context.config,\n         };\n         let pats_str = try_opt!(write_list(items, &fmt));\n \n-        let budget = if pats_str.contains('\\n') {\n-            context.config.max_width - shape.indent.width()\n+        let guard_shape = if pats_str.contains('\\n') {\n+            Shape { width: context.config.max_width - shape.indent.width(), ..shape }\n         } else {\n-            shape.width\n+            shape\n         };\n \n         let guard_str = try_opt!(rewrite_guard(context,\n                                                guard,\n-                                               Shape::legacy(budget, shape.indent),\n+                                               guard_shape,\n                                                trimmed_last_line_width(&pats_str)));\n \n         let pats_str = format!(\"{}{}\", pats_str, guard_str);\n         // Where the next text can start.\n-        let mut line_start = last_line_width(&pats_str);\n-        if !pats_str.contains('\\n') {\n-            line_start += shape.indent.width();\n-        }\n+        let mut line_start = trimmed_last_line_width(&pats_str);\n \n         let body = match body.node {\n             ast::ExprKind::Block(ref block) if !is_unsafe_block(block) &&\n@@ -1264,16 +1250,17 @@ impl Rewrite for ast::Arm {\n         };\n \n         let comma = arm_comma(&context.config, self, body);\n-        let alt_block_sep = String::from(\"\\n\") + &context.block_indent.to_string(context.config);\n+        let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n \n         // Let's try and get the arm body on the same line as the condition.\n         // 4 = ` => `.len()\n-        if context.config.max_width > line_start + comma.len() + 4 {\n-            let budget = context.config.max_width - line_start - comma.len() - 4;\n-            let offset = Indent::new(shape.indent.block_indent,\n-                                     line_start + 4 - shape.indent.block_indent);\n-            let rewrite = nop_block_collapse(body.rewrite(context, Shape::legacy(budget, offset)),\n-                                             budget);\n+        if shape.width > line_start + comma.len() + 4 {\n+            let arm_shape = shape.shrink_left(line_start + 4).unwrap().sub_width(comma.len()).unwrap().block();\n+            // TODO\n+            // let offset = Indent::new(shape.indent.block_indent,\n+            //                          line_start + 4 - shape.indent.block_indent);\n+            let rewrite = nop_block_collapse(body.rewrite(context, arm_shape),\n+                                             arm_shape.width);\n             let is_block = if let ast::ExprKind::Block(..) = body.node {\n                 true\n             } else {\n@@ -1301,13 +1288,12 @@ impl Rewrite for ast::Arm {\n \n         // FIXME: we're doing a second rewrite of the expr; This may not be\n         // necessary.\n-        let body_budget = try_opt!(shape.width.checked_sub(context.config.tab_spaces));\n-        let indent = context.block_indent.block_indent(context.config);\n-        let inner_context = &RewriteContext { block_indent: indent, ..*context };\n-        let next_line_body = try_opt!(nop_block_collapse(body.rewrite(inner_context,\n-                                                                      Shape::legacy(body_budget,\n-                                                                                    indent)),\n-                                                         body_budget));\n+        // TODO\n+        // let body_budget = try_opt!(shape.width.checked_sub(context.config.tab_spaces));\n+        // let indent = shape.indent.block_only().block_indent(context.config);\n+        let body_shape = try_opt!(shape.sub_width(context.config.tab_spaces)).block_indent(context.config.tab_spaces);\n+        let next_line_body = try_opt!(nop_block_collapse(body.rewrite(context, body_shape),\n+                                                         body_shape.width));\n         let indent_str = shape.indent.block_indent(context.config).to_string(context.config);\n         let (body_prefix, body_suffix) = if context.config.wrap_match_arms {\n             if context.config.match_block_trailing_comma {\n@@ -1394,33 +1380,30 @@ fn rewrite_pat_expr(context: &RewriteContext,\n                     connector: &str,\n                     shape: Shape)\n                     -> Option<String> {\n+    debug!(\"rewrite_pat_expr {:?}\", shape);\n     let mut result = match pat {\n         Some(pat) => {\n             let matcher = if matcher.is_empty() {\n                 matcher.to_owned()\n             } else {\n                 format!(\"{} \", matcher)\n             };\n-            let pat_budget = try_opt!(shape.width.checked_sub(connector.len() + matcher.len()));\n-            let pat_offset = shape.indent + matcher.len();\n-            let pat_string = try_opt!(pat.rewrite(context, Shape::legacy(pat_budget, pat_offset)));\n+            let pat_shape = try_opt!(try_opt!(shape.shrink_left(matcher.len())).sub_width(connector.len()));\n+            let pat_string = try_opt!(pat.rewrite(context, pat_shape));\n             format!(\"{}{}{}\", matcher, pat_string, connector)\n         }\n         None => String::new(),\n     };\n \n     // Consider only the last line of the pat string.\n-    let extra_offset = extra_offset(&result, shape.indent);\n+    let extra_offset = extra_offset(&result, shape);\n \n-    // The expression may (partionally) fit on the current line.\n+    // The expression may (partially) fit on the current line.\n     if shape.width > extra_offset + 1 {\n         let spacer = if pat.is_some() { \" \" } else { \"\" };\n \n-        let expr_rewrite = expr.rewrite(context,\n-                                        Shape::legacy(try_opt!(shape.width\n-                                                          .checked_sub(extra_offset +\n-                                                                       spacer.len())),\n-                                                      shape.indent + extra_offset + spacer.len()));\n+        let expr_shape = try_opt!(shape.sub_width(extra_offset + spacer.len())).add_offset(extra_offset + spacer.len());\n+        let expr_rewrite = expr.rewrite(context, expr_shape);\n \n         if let Some(expr_string) = expr_rewrite {\n             let pat_simple = pat.and_then(|p| {\n@@ -1437,17 +1420,17 @@ fn rewrite_pat_expr(context: &RewriteContext,\n         }\n     }\n \n-    let nested = context.nested_context();\n+    let nested_indent = shape.indent.block_only().block_indent(context.config);\n \n     // The expression won't fit on the current line, jump to next.\n     result.push('\\n');\n-    result.push_str(&nested.block_indent.to_string(context.config));\n+    result.push_str(&nested_indent.to_string(context.config));\n \n-    let expr_rewrite = expr.rewrite(&nested,\n+    let expr_rewrite = expr.rewrite(&context,\n                                     Shape::legacy(try_opt!(context.config\n                                                       .max_width\n-                                                      .checked_sub(nested.block_indent.width())),\n-                                                  nested.block_indent));\n+                                                      .checked_sub(nested_indent.width())),\n+                                                  nested_indent));\n     result.push_str(&try_opt!(expr_rewrite));\n \n     Some(result)\n@@ -1533,7 +1516,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     let callee = callee.borrow();\n     // FIXME using byte lens instead of char lens (and probably all over the\n     // place too)\n-    let callee_str = match callee.rewrite(context, Shape::legacy(max_callee_width, shape.indent)) {\n+    let callee_str = match callee.rewrite(context, Shape { width: max_callee_width, ..shape }) {\n         Some(string) => {\n             if !string.contains('\\n') && string.len() > max_callee_width {\n                 panic!(\"{:?} {}\", string, max_callee_width);\n@@ -1547,28 +1530,23 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     let span_lo = context.codemap.span_after(span, \"(\");\n     let span = mk_sp(span_lo, span.hi);\n \n-    let extra_offset = extra_offset(&callee_str, shape.indent);\n+    let used_width = extra_offset(&callee_str, shape);\n     // 2 is for parens.\n-    let remaining_width = match shape.width.checked_sub(extra_offset + 2) {\n-        Some(str) => str,\n+    let remaining_width = match shape.width.checked_sub(used_width + 2) {\n+        Some(s) => s,\n         None => return Err(Ordering::Greater),\n     };\n-    let offset = shape.indent + extra_offset + 1;\n+    // 1 = (\n+    let nested_shape = shape.visual_indent(used_width + 1);\n     let arg_count = args.len();\n-    let block_indent = if arg_count == 1 {\n-        context.block_indent\n-    } else {\n-        offset\n-    };\n-    let inner_context = &RewriteContext { block_indent: block_indent, ..*context };\n \n     let items =\n         itemize_list(context.codemap,\n                      args.iter(),\n                      \")\",\n                      |item| item.span.lo,\n                      |item| item.span.hi,\n-                     |item| item.rewrite(inner_context, Shape::legacy(remaining_width, offset)),\n+                     |item| item.rewrite(context, Shape { width: remaining_width, ..nested_shape }),\n                      span.lo,\n                      span.hi);\n     let mut item_vec: Vec<_> = items.collect();\n@@ -1588,9 +1566,12 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     // Replace the last item with its first line to see if it fits with\n     // first arguments.\n     if overflow_last {\n-        let inner_context = &RewriteContext { block_indent: context.block_indent, ..*context };\n-        let rewrite =\n-            args.last().unwrap().rewrite(inner_context, Shape::legacy(remaining_width, offset));\n+        let nested_shape = Shape {\n+            width: remaining_width,\n+            indent: nested_shape.indent.block_only(),\n+            ..nested_shape\n+        };\n+        let rewrite = args.last().unwrap().rewrite(context, nested_shape);\n \n         if let Some(rewrite) = rewrite {\n             let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n@@ -1622,7 +1603,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n-        shape: Shape::legacy(shape.width, offset),\n+        shape: nested_shape,\n         ends_with_newline: false,\n         config: context.config,\n     };\n@@ -1643,9 +1624,8 @@ fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, shape: Shape) ->\n     debug!(\"rewrite_paren, shape: {:?}\", shape);\n     // 1 is for opening paren, 2 is for opening+closing, we want to keep the closing\n     // paren on the same line as the subexpr.\n-    let subexpr_str = subexpr.rewrite(context,\n-                                      Shape::legacy(try_opt!(shape.width.checked_sub(2)),\n-                                                    shape.indent + 1));\n+    let sub_shape = try_opt!(shape.sub_width(2)).visual_indent(1);\n+    let subexpr_str = subexpr.rewrite(context, sub_shape);\n     debug!(\"rewrite_paren, subexpr_str: `{:?}`\", subexpr_str);\n \n     subexpr_str.map(|s| if context.config.spaces_within_parens && s.len() > 0 {\n@@ -1699,33 +1679,27 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     }\n \n     // 2 = \" {\".len()\n-    let path_budget = try_opt!(shape.width.checked_sub(2));\n+    let path_shape = try_opt!(shape.sub_width(2));\n     let path_str = try_opt!(rewrite_path(context,\n                                          PathContext::Expr,\n                                          None,\n                                          path,\n-                                         Shape::legacy(path_budget, shape.indent)));\n+                                         path_shape));\n \n     // Foo { a: Foo } - indent is +3, width is -5.\n-    let h_budget = shape.width.checked_sub(path_str.len() + 5).unwrap_or(0);\n-    // The 1 taken from the v_budget is for the comma.\n-    let (indent, v_budget) = match context.config.struct_lit_style {\n-        StructLitStyle::Visual => (shape.indent + path_str.len() + 3, h_budget),\n+    let h_shape = shape.sub_width(path_str.len() + 5);\n+    let v_shape = match context.config.struct_lit_style {\n+        StructLitStyle::Visual => try_opt!(try_opt!(shape.shrink_left(path_str.len() + 3)).sub_width(2)),\n         StructLitStyle::Block => {\n-            // If we are all on one line, then we'll ignore the indent, and we\n-            // have a smaller budget.\n-            let indent = context.block_indent.block_indent(context.config);\n-            let v_budget = context.config.max_width.checked_sub(indent.width()).unwrap_or(0);\n-            (indent, v_budget)\n+            let shape = shape.block_indent(context.config.tab_spaces);\n+            Shape { width: try_opt!(context.config.max_width.checked_sub(shape.indent.width())), ..shape }\n         }\n     };\n \n     let field_iter = fields.into_iter()\n         .map(StructLitField::Regular)\n         .chain(base.into_iter().map(StructLitField::Base));\n \n-    let inner_context = &RewriteContext { block_indent: indent, ..*context };\n-\n     let items = itemize_list(context.codemap,\n                              field_iter,\n                              \"}\",\n@@ -1747,14 +1721,15 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                              |item| {\n         match *item {\n             StructLitField::Regular(field) => {\n-                rewrite_field(inner_context,\n+                // The 1 taken from the v_budget is for the comma.\n+                rewrite_field(context,\n                               field,\n-                              Shape::legacy(v_budget.checked_sub(1).unwrap_or(0), indent))\n+                              try_opt!(v_shape.sub_width(1)))\n             }\n             StructLitField::Base(expr) => {\n                 // 2 = ..\n-                expr.rewrite(inner_context,\n-                             Shape::legacy(try_opt!(v_budget.checked_sub(2)), indent + 2))\n+                expr.rewrite(context,\n+                             try_opt!(v_shape.shrink_left(2)))\n                     .map(|s| format!(\"..{}\", s))\n             }\n         }\n@@ -1763,7 +1738,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                              span.hi);\n     let item_vec = items.collect::<Vec<_>>();\n \n-    let tactic = {\n+    let tactic = if let Some(h_shape) = h_shape {\n         let mut prelim_tactic = match (context.config.struct_lit_style, fields.len()) {\n             (StructLitStyle::Visual, 1) => ListTactic::HorizontalVertical,\n             _ => context.config.struct_lit_multiline_style.to_list_tactic(),\n@@ -1773,12 +1748,14 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n             prelim_tactic = ListTactic::LimitedHorizontalVertical(context.config.struct_lit_width);\n         }\n \n-        definitive_tactic(&item_vec, prelim_tactic, h_budget)\n+        definitive_tactic(&item_vec, prelim_tactic, h_shape.width)\n+    } else {\n+        DefinitiveListTactic::Vertical\n     };\n \n-    let budget = match tactic {\n-        DefinitiveListTactic::Horizontal => h_budget,\n-        _ => v_budget,\n+    let nested_shape = match tactic {\n+        DefinitiveListTactic::Horizontal => h_shape.unwrap(),\n+        _ => v_shape,\n     };\n \n     let ends_with_newline = context.config.struct_lit_style != StructLitStyle::Visual &&\n@@ -1792,36 +1769,33 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         } else {\n             context.config.struct_lit_trailing_comma\n         },\n-        shape: Shape::legacy(budget, indent),\n+        shape: nested_shape,\n         ends_with_newline: ends_with_newline,\n         config: context.config,\n     };\n     let fields_str = try_opt!(write_list(&item_vec, &fmt));\n \n+    // Empty struct.\n     if fields_str.is_empty() {\n         return Some(format!(\"{} {{}}\", path_str));\n     }\n \n-    let format_on_newline = || {\n-        let inner_indent = context.block_indent\n-            .block_indent(context.config)\n-            .to_string(context.config);\n-        let outer_indent = context.block_indent.to_string(context.config);\n-        Some(format!(\"{} {{\\n{}{}\\n{}}}\",\n-                     path_str,\n-                     inner_indent,\n-                     fields_str,\n-                     outer_indent))\n-    };\n-\n-    match (context.config.struct_lit_style, context.config.struct_lit_multiline_style) {\n-        (StructLitStyle::Block, _) if fields_str.contains('\\n') || fields_str.len() > h_budget => {\n-            format_on_newline()\n-        }\n-        (StructLitStyle::Block, MultilineStyle::ForceMulti) => format_on_newline(),\n-        _ => Some(format!(\"{} {{ {} }}\", path_str, fields_str)),\n+    // One liner or visual indent.\n+    if context.config.struct_lit_style == StructLitStyle::Visual ||\n+       (context.config.struct_lit_multiline_style != MultilineStyle::ForceMulti &&\n+        !fields_str.contains('\\n') &&\n+        fields_str.len() <= h_shape.map(|s| s.width).unwrap_or(0)) {\n+        return Some(format!(\"{} {{ {} }}\", path_str, fields_str));\n     }\n \n+    // Multiple lines.\n+    let inner_indent = v_shape.indent.to_string(context.config);\n+    let outer_indent = shape.indent.to_string(context.config);\n+    Some(format!(\"{} {{\\n{}{}\\n{}}}\",\n+                 path_str,\n+                 inner_indent,\n+                 fields_str,\n+                 outer_indent))\n     // FIXME if context.config.struct_lit_style == Visual, but we run out\n     // of space, we should fall back to BlockIndent.\n }\n@@ -1842,9 +1816,9 @@ fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) ->\n     } else {\n         let separator = type_annotation_separator(context.config);\n         let overhead = name.len() + separator.len();\n-        let expr = field.expr.rewrite(context,\n-                                      Shape::legacy(try_opt!(shape.width.checked_sub(overhead)),\n-                                                    shape.indent + overhead));\n+        let mut expr_shape = try_opt!(shape.sub_width(overhead));\n+        expr_shape.offset += overhead;\n+        let expr = field.expr.rewrite(context, expr_shape);\n \n         match expr {\n             Some(e) => Some(format!(\"{}{}{}\", name, separator, e)),\n@@ -1871,16 +1845,14 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n           <I as Iterator>::Item: Deref,\n           <I::Item as Deref>::Target: Rewrite + Spanned + 'a\n {\n-    let indent = shape.indent + 1;\n-    let aligned = RewriteContext { block_indent: indent, ..context.clone() };\n-\n+    debug!(\"rewrite_tuple {:?}\", shape);\n     // In case of length 1, need a trailing comma\n     if items.len() == 1 {\n         // 3 = \"(\" + \",)\"\n-        let budget = try_opt!(shape.width.checked_sub(3));\n+        let nested_shape = try_opt!(shape.sub_width(3)).visual_indent(1);\n         return items.next()\n             .unwrap()\n-            .rewrite(&aligned, Shape::legacy(budget, indent))\n+            .rewrite(context, nested_shape)\n             .map(|s| if context.config.spaces_within_parens {\n                 format!(\"( {}, )\", s)\n             } else {\n@@ -1889,16 +1861,16 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n     }\n \n     let list_lo = context.codemap.span_after(span, \"(\");\n-    let budget = try_opt!(shape.width.checked_sub(2));\n+    let nested_shape = try_opt!(shape.sub_width(2)).visual_indent(1);\n     let items = itemize_list(context.codemap,\n                              items,\n                              \")\",\n                              |item| item.span().lo,\n                              |item| item.span().hi,\n-                             |item| item.rewrite(&aligned, Shape::legacy(budget, indent)),\n+                             |item| item.rewrite(context, nested_shape),\n                              list_lo,\n                              span.hi - BytePos(1));\n-    let list_str = try_opt!(format_item_list(items, Shape::legacy(budget, indent), context.config));\n+    let list_str = try_opt!(format_item_list(items, nested_shape, context.config));\n \n     if context.config.spaces_within_parens && list_str.len() > 0 {\n         Some(format!(\"( {} )\", list_str))\n@@ -1912,10 +1884,8 @@ pub fn rewrite_unary_prefix<R: Rewrite>(context: &RewriteContext,\n                                         rewrite: &R,\n                                         shape: Shape)\n                                         -> Option<String> {\n-    rewrite.rewrite(context,\n-                 Shape::legacy(try_opt!(shape.width.checked_sub(prefix.len())),\n-                               shape.indent + prefix.len()))\n-        .map(|r| format!(\"{}{}\", prefix, r))\n+    let shape = try_opt!(shape.shrink_left(prefix.len())).visual_indent(0);\n+    rewrite.rewrite(context, shape).map(|r| format!(\"{}{}\", prefix, r))\n }\n \n // FIXME: this is probably not correct for multi-line Rewrites. we should\n@@ -1925,9 +1895,7 @@ pub fn rewrite_unary_suffix<R: Rewrite>(context: &RewriteContext,\n                                         rewrite: &R,\n                                         shape: Shape)\n                                         -> Option<String> {\n-    rewrite.rewrite(context,\n-                 Shape::legacy(try_opt!(shape.width.checked_sub(suffix.len())),\n-                               shape.indent))\n+    rewrite.rewrite(context, try_opt!(shape.sub_width(suffix.len())))\n         .map(|mut r| {\n             r.push_str(suffix);\n             r\n@@ -1960,9 +1928,9 @@ fn rewrite_assignment(context: &RewriteContext,\n     };\n \n     // 1 = space between lhs and operator.\n-    let max_width = try_opt!(shape.width.checked_sub(operator_str.len() + 1));\n+    let lhs_shape = try_opt!(shape.sub_width(operator_str.len() + 1));\n     let lhs_str = format!(\"{} {}\",\n-                          try_opt!(lhs.rewrite(context, Shape::legacy(max_width, shape.indent))),\n+                          try_opt!(lhs.rewrite(context, lhs_shape)),\n                           operator_str);\n \n     rewrite_assign_rhs(context, lhs_str, rhs, shape)\n@@ -1985,7 +1953,9 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n     // 1 = space between operator and rhs.\n     let max_width = try_opt!(shape.width.checked_sub(last_line_width + 1));\n     let rhs = ex.rewrite(context,\n-                         Shape::legacy(max_width, shape.indent + last_line_width + 1));\n+                         Shape::offset(max_width,\n+                                       shape.indent.block_only(),\n+                                       shape.indent.alignment + last_line_width + 1));\n \n     fn count_line_breaks(src: &str) -> usize {\n         src.chars().filter(|&x| x == '\\n').count()\n@@ -2003,8 +1973,7 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n             let new_offset = shape.indent.block_indent(context.config);\n             let max_width = try_opt!((shape.width + shape.indent.width())\n                 .checked_sub(new_offset.width()));\n-            let inner_context = context.nested_context();\n-            let new_rhs = ex.rewrite(&inner_context, Shape::legacy(max_width, new_offset));\n+            let new_rhs = ex.rewrite(context, Shape::legacy(max_width, new_offset));\n \n             // FIXME: DRY!\n             match (rhs, new_rhs) {"}, {"sha": "1a27b5bfbc95a79146636782dfc16d0e82d8edfb", "filename": "src/items.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=b35906dbce47552c2ba6350f31c654bc77603fbd", "patch": "@@ -70,12 +70,12 @@ impl Rewrite for ast::Local {\n \n         if let Some(ref ex) = self.init {\n             // 1 = trailing semicolon;\n-            let budget = try_opt!(shape.width.checked_sub(context.block_indent.width() + 1));\n+            let budget = try_opt!(shape.width.checked_sub(shape.indent.block_only().width() + 1));\n \n             result = try_opt!(rewrite_assign_rhs(&context,\n                                                  result,\n                                                  ex,\n-                                                 Shape::legacy(budget, context.block_indent)));\n+                                                 Shape::legacy(budget, shape.indent.block_only())));\n         }\n \n         result.push(';');\n@@ -520,7 +520,7 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n                                                              context.config,\n                                                              context.config.item_brace_style,\n                                                              Shape::legacy(where_budget,\n-                                                                           context.block_indent),\n+                                                                           offset.block_only()),\n                                                              context.config.where_density,\n                                                              \"{\",\n                                                              true,\n@@ -539,7 +539,7 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n \n         if !where_clause_str.is_empty() && !where_clause_str.contains('\\n') {\n             result.push('\\n');\n-            let width = context.block_indent.width() + context.config.tab_spaces - 1;\n+            let width = offset.block_indent + context.config.tab_spaces - 1;\n             let where_indent = Indent::new(0, width);\n             result.push_str(&where_indent.to_string(context.config));\n         }\n@@ -568,7 +568,7 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n \n         if !items.is_empty() || contains_comment(&snippet[open_pos..]) {\n             let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n-            visitor.block_indent = context.block_indent.block_indent(context.config);\n+            visitor.block_indent = offset.block_only().block_indent(context.config);\n             visitor.last_pos = item.span.lo + BytePos(open_pos as u32);\n \n             for item in items {\n@@ -578,7 +578,7 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n             visitor.format_missing(item.span.hi - BytePos(1));\n \n             let inner_indent_str = visitor.block_indent.to_string(context.config);\n-            let outer_indent_str = context.block_indent.to_string(context.config);\n+            let outer_indent_str = offset.block_only().to_string(context.config);\n \n             result.push('\\n');\n             result.push_str(&inner_indent_str);\n@@ -654,7 +654,7 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n                 result.push('\\n');\n \n                 // Add indentation of one additional tab.\n-                let width = context.block_indent.width() + context.config.tab_spaces;\n+                let width = offset.block_indent + context.config.tab_spaces;\n                 let for_indent = Indent::new(0, width);\n                 result.push_str(&for_indent.to_string(context.config));\n \n@@ -762,7 +762,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         if offset.width() + last_line_width(&result) + trait_bound_str.len() >\n            context.config.ideal_width {\n             result.push('\\n');\n-            let trait_indent = context.block_indent.block_indent(context.config);\n+            let trait_indent = offset.block_only().block_indent(context.config);\n             result.push_str(&trait_indent.to_string(context.config));\n         }\n         result.push_str(&trait_bound_str);\n@@ -789,7 +789,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                                                              context.config,\n                                                              context.config.item_brace_style,\n                                                              Shape::legacy(where_budget,\n-                                                                           context.block_indent),\n+                                                                           offset.block_only()),\n                                                              where_density,\n                                                              \"{\",\n                                                              has_body,\n@@ -800,7 +800,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n            last_line_width(&result) + where_clause_str.len() + offset.width() >\n            context.config.ideal_width {\n             result.push('\\n');\n-            let width = context.block_indent.width() + context.config.tab_spaces - 1;\n+            let width = offset.block_indent + context.config.tab_spaces - 1;\n             let where_indent = Indent::new(0, width);\n             result.push_str(&where_indent.to_string(context.config));\n         }\n@@ -829,7 +829,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n         if !trait_items.is_empty() || contains_comment(&snippet[open_pos..]) {\n             let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n-            visitor.block_indent = context.block_indent.block_indent(context.config);\n+            visitor.block_indent = offset.block_only().block_indent(context.config);\n             visitor.last_pos = item.span.lo + BytePos(open_pos as u32);\n \n             for item in trait_items {\n@@ -839,7 +839,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             visitor.format_missing(item.span.hi - BytePos(1));\n \n             let inner_indent_str = visitor.block_indent.to_string(context.config);\n-            let outer_indent_str = context.block_indent.to_string(context.config);\n+            let outer_indent_str = offset.block_only().to_string(context.config);\n \n             result.push('\\n');\n             result.push_str(&inner_indent_str);\n@@ -892,7 +892,7 @@ fn format_struct_struct(context: &RewriteContext,\n         }\n         None => {\n             if context.config.item_brace_style == BraceStyle::AlwaysNextLine && !fields.is_empty() {\n-                format!(\"\\n{}{{\", context.block_indent.to_string(context.config))\n+                format!(\"\\n{}{{\", offset.block_only().to_string(context.config))\n             } else {\n                 \" {\".to_owned()\n             }\n@@ -1004,7 +1004,7 @@ fn format_tuple_struct(context: &RewriteContext,\n                                           &generics.where_clause,\n                                           context.config,\n                                           context.config.item_brace_style,\n-                                          Shape::legacy(where_budget, context.block_indent),\n+                                          Shape::legacy(where_budget, offset.block_only()),\n                                           Density::Compressed,\n                                           \";\",\n                                           false,\n@@ -1014,7 +1014,7 @@ fn format_tuple_struct(context: &RewriteContext,\n     };\n     result.push('(');\n \n-    let item_indent = context.block_indent + result.len();\n+    let item_indent = offset.block_only() + result.len();\n     // 2 = \");\"\n     let item_budget = try_opt!(context.config.max_width.checked_sub(item_indent.width() + 2));\n \n@@ -1052,12 +1052,12 @@ fn format_tuple_struct(context: &RewriteContext,\n \n     if !where_clause_str.is_empty() && !where_clause_str.contains('\\n') &&\n        (result.contains('\\n') ||\n-        context.block_indent.width() + result.len() + where_clause_str.len() + 1 >\n+        offset.block_indent + result.len() + where_clause_str.len() + 1 >\n         context.config.max_width) {\n         // We need to put the where clause on a new line, but we didn'to_string\n         // know that earlier, so the where clause will not be indented properly.\n         result.push('\\n');\n-        result.push_str(&(context.block_indent + (context.config.tab_spaces - 1))\n+        result.push_str(&(offset.block_only() + (context.config.tab_spaces - 1))\n             .to_string(context.config));\n     }\n     result.push_str(&where_clause_str);\n@@ -1192,6 +1192,7 @@ pub fn rewrite_static(prefix: &str,\n                       ty: &ast::Ty,\n                       mutability: ast::Mutability,\n                       expr_opt: Option<&ptr::P<ast::Expr>>,\n+                      offset: Indent,\n                       context: &RewriteContext)\n                       -> Option<String> {\n     let type_annotation_spacing = type_annotation_spacing(context.config);\n@@ -1205,19 +1206,19 @@ pub fn rewrite_static(prefix: &str,\n     // 2 = \" =\".len()\n     let ty_str = try_opt!(ty.rewrite(context,\n                                      Shape::legacy(context.config.max_width -\n-                                                   context.block_indent.width() -\n+                                                   offset.block_indent -\n                                                    prefix.len() -\n                                                    2,\n-                                                   context.block_indent)));\n+                                                   offset.block_only())));\n \n     if let Some(expr) = expr_opt {\n         let lhs = format!(\"{}{} =\", prefix, ty_str);\n         // 1 = ;\n-        let remaining_width = context.config.max_width - context.block_indent.width() - 1;\n+        let remaining_width = context.config.max_width - offset.block_indent - 1;\n         rewrite_assign_rhs(context,\n                            lhs,\n                            expr,\n-                           Shape::legacy(remaining_width, context.block_indent))\n+                           Shape::legacy(remaining_width, offset.block_only()))\n             .map(|s| s + \";\")\n     } else {\n         let lhs = format!(\"{}{};\", prefix, ty_str);\n@@ -1253,10 +1254,10 @@ pub fn rewrite_associated_type(ident: ast::Ident,\n     if let Some(ty) = ty_opt {\n         let ty_str = try_opt!(ty.rewrite(context,\n                                          Shape::legacy(context.config.max_width -\n-                                                       context.block_indent.width() -\n+                                                       indent.block_indent -\n                                                        prefix.len() -\n                                                        2,\n-                                                       context.block_indent)));\n+                                                       indent.block_only())));\n         Some(format!(\"{} = {};\", prefix, ty_str))\n     } else {\n         Some(format!(\"{}{};\", prefix, type_bounds_str))\n@@ -1473,7 +1474,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n         multi_line_budget = context.config.max_width - arg_indent.width();\n     }\n \n-    debug!(\"rewrite_fn: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n+    debug!(\"rewrite_fn_base: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n            one_line_budget,\n            multi_line_budget,\n            arg_indent);\n@@ -2020,7 +2021,7 @@ fn format_generics(context: &RewriteContext,\n                                                              context.config,\n                                                              brace_style,\n                                                              Shape::legacy(budget,\n-                                                                           context.block_indent),\n+                                                                           offset.block_only()),\n                                                              Density::Tall,\n                                                              terminator,\n                                                              true,\n@@ -2029,15 +2030,15 @@ fn format_generics(context: &RewriteContext,\n         if !force_same_line_brace &&\n            (brace_style == BraceStyle::SameLineWhere || brace_style == BraceStyle::AlwaysNextLine) {\n             result.push('\\n');\n-            result.push_str(&context.block_indent.to_string(context.config));\n+            result.push_str(&offset.block_only().to_string(context.config));\n         } else {\n             result.push(' ');\n         }\n         result.push_str(opener);\n     } else {\n         if !force_same_line_brace && brace_style == BraceStyle::AlwaysNextLine {\n             result.push('\\n');\n-            result.push_str(&context.block_indent.to_string(context.config));\n+            result.push_str(&offset.block_only().to_string(context.config));\n         } else {\n             result.push(' ');\n         }"}, {"sha": "43054698b2d5aad625a91b231a417cf31368c39d", "filename": "src/lib.rs", "status": "modified", "additions": 93, "deletions": 3, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b35906dbce47552c2ba6350f31c654bc77603fbd", "patch": "@@ -133,6 +133,13 @@ impl Indent {\n         Indent::new(0, 0)\n     }\n \n+    pub fn block_only(&self) -> Indent {\n+        Indent {\n+            block_indent: self.block_indent,\n+            alignment: 0,\n+        }\n+    }\n+\n     pub fn block_indent(mut self, config: &Config) -> Indent {\n         self.block_indent += config.tab_spaces;\n         self\n@@ -204,14 +211,19 @@ impl Sub<usize> for Indent {\n #[derive(Copy, Clone, Debug)]\n pub struct Shape {\n     pub width: usize,\n+    // The current indentation of code.\n     pub indent: Indent,\n+    // Indentation + any already emitted text on the first line of the current\n+    // statement.\n+    pub offset: usize,\n }\n \n impl Shape {\n     pub fn indented(indent: Indent, config: &Config) -> Shape {\n         Shape {\n             width: config.max_width,\n             indent: indent,\n+            offset: indent.width(),\n         }\n     }\n \n@@ -234,15 +246,93 @@ impl Shape {\n         Shape {\n             width: width,\n             indent: indent,\n+            offset: indent.alignment,\n         }\n     }\n \n-    pub fn sub_width(self, width: usize) -> Shape {\n+    pub fn offset(width: usize, indent: Indent, offset: usize) -> Shape {\n         Shape {\n-            width: self.width - width,\n-            indent: self.indent,\n+            width: width,\n+            indent: indent,\n+            offset: offset,\n+        }\n+    }    \n+\n+    pub fn visual_indent(&self, extra_width: usize) -> Shape {\n+        let alignment = self.offset + extra_width;\n+        Shape {\n+            width: self.width,\n+            indent: Indent {\n+                block_indent: self.indent.block_indent,\n+                alignment: alignment,\n+            },\n+            offset: alignment,\n+        }\n+    }\n+\n+    pub fn block_indent(&self, extra_width: usize) -> Shape {\n+        if self.indent.alignment == 0 {\n+            Shape {\n+                width: self.width,\n+                indent: Indent {\n+                    block_indent: self.indent.block_indent + extra_width,\n+                    alignment: 0,\n+                },\n+                offset: 0,\n+            }\n+        } else {\n+            Shape {\n+                width: self.width,\n+                indent: Indent {\n+                    block_indent: self.indent.block_indent,\n+                    alignment: self.indent.alignment + extra_width,\n+                },\n+                offset: self.indent.alignment + extra_width,\n+            }\n         }\n     }\n+\n+    pub fn add_offset(&self, extra_width: usize) -> Shape {\n+        Shape {\n+            width: self.width,\n+            indent: Indent {\n+                block_indent: self.indent.block_indent,\n+                alignment: self.indent.alignment,\n+            },\n+            offset: self.offset + extra_width,\n+        }\n+    }\n+\n+    pub fn block(&self) -> Shape {\n+        Shape {\n+            width: self.width,\n+            indent: Indent {\n+                block_indent: self.indent.block_indent,\n+                alignment: 0,\n+            },\n+            offset: self.offset,\n+        }\n+    }\n+\n+    pub fn sub_width(&self, width: usize) -> Option<Shape> {\n+        Some(Shape {\n+            width: try_opt!(self.width.checked_sub(width)),\n+            indent: self.indent,\n+            offset: self.offset,\n+        })\n+    }\n+\n+    pub fn shrink_left(&self, width: usize) -> Option<Shape> {\n+        Some(Shape {\n+            width: try_opt!(self.width.checked_sub(width)),\n+            indent: self.indent + width,\n+            offset: self.offset + width,\n+        })        \n+    }\n+\n+    pub fn used_width(&self) -> usize {\n+        self.indent.block_indent + self.offset\n+    }\n }\n \n pub enum ErrorKind {"}, {"sha": "97c60adb6841f74353bb61f4de08f43d49d4dd85", "filename": "src/macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=b35906dbce47552c2ba6350f31c654bc77603fbd", "patch": "@@ -155,15 +155,14 @@ pub fn rewrite_macro(mac: &ast::Mac,\n         MacroStyle::Brackets => {\n             // Format macro invocation as array literal.\n             let extra_offset = macro_name.len();\n+            let shape = try_opt!(shape.shrink_left(extra_offset));\n             let rewrite = try_opt!(rewrite_array(expr_vec.iter().map(|x| &**x),\n                                                  mk_sp(context.codemap\n                                                            .span_after(mac.span,\n                                                                        original_style.opener()),\n                                                        mac.span.hi - BytePos(1)),\n                                                  context,\n-                                                 Shape::legacy(try_opt!(shape.width\n-                                                                   .checked_sub(extra_offset)),\n-                                                               shape.indent + extra_offset)));\n+                                                 shape));\n \n             Some(format!(\"{}{}\", macro_name, rewrite))\n         }"}, {"sha": "73b54a666268b0bca7f89f826de9a1cfbfa43aea", "filename": "src/patterns.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=b35906dbce47552c2ba6350f31c654bc77603fbd", "patch": "@@ -220,16 +220,16 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n \n         let path_len = path_str.as_ref().map(|p| p.len()).unwrap_or(0);\n         // 2 = \"()\".len(), 3 = \"(,)\".len()\n-        let width = try_opt!(shape.width.checked_sub(path_len + if add_comma { 3 } else { 2 }));\n+        let nested_shape = try_opt!(shape.sub_width(path_len + if add_comma { 3 } else { 2 }));\n         // 1 = \"(\".len()\n-        let offset = shape.indent + path_len + 1;\n+        let nested_shape = nested_shape.visual_indent(path_len + 1);\n         let mut items: Vec<_> =\n             itemize_list(context.codemap,\n                          pat_vec.iter(),\n                          if add_comma { \",)\" } else { \")\" },\n                          |item| item.span().lo,\n                          |item| item.span().hi,\n-                         |item| item.rewrite(context, Shape::legacy(width, offset)),\n+                         |item| item.rewrite(context, nested_shape),\n                          context.codemap.span_after(span, \"(\"),\n                          span.hi - BytePos(1))\n                 .collect();\n@@ -242,10 +242,10 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n             items[new_item_count - 1].item = Some(\"..\".to_owned());\n \n             let da_iter = items.into_iter().take(new_item_count);\n-            try_opt!(format_item_list(da_iter, Shape::legacy(width, offset), context.config))\n+            try_opt!(format_item_list(da_iter, nested_shape, context.config))\n         } else {\n             try_opt!(format_item_list(items.into_iter(),\n-                                      Shape::legacy(width, offset),\n+                                      nested_shape,\n                                       context.config))\n         };\n "}, {"sha": "bb75a6f4db7992a0faa13ded075dadb712cb4af9", "filename": "src/rewrite.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=b35906dbce47552c2ba6350f31c654bc77603fbd", "patch": "@@ -13,7 +13,7 @@\n use syntax::codemap::{CodeMap, Span};\n use syntax::parse::ParseSess;\n \n-use {Indent, Shape};\n+use Shape;\n use config::Config;\n \n pub trait Rewrite {\n@@ -26,20 +26,9 @@ pub struct RewriteContext<'a> {\n     pub parse_session: &'a ParseSess,\n     pub codemap: &'a CodeMap,\n     pub config: &'a Config,\n-    // Indentation due to nesting of blocks.\n-    pub block_indent: Indent,\n }\n \n impl<'a> RewriteContext<'a> {\n-    pub fn nested_context(&self) -> RewriteContext<'a> {\n-        RewriteContext {\n-            parse_session: self.parse_session,\n-            codemap: self.codemap,\n-            config: self.config,\n-            block_indent: self.block_indent.block_indent(self.config),\n-        }\n-    }\n-\n     pub fn snippet(&self, span: Span) -> String {\n         self.codemap.span_to_snippet(span).unwrap()\n     }"}, {"sha": "7fd6bb78e61cd18823b2d8fee16dd89a5066e2a9", "filename": "src/string.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=b35906dbce47552c2ba6350f31c654bc77603fbd", "patch": "@@ -36,7 +36,8 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     let stripped_str = re.replace_all(orig, \"$1\");\n \n     let graphemes = UnicodeSegmentation::graphemes(&*stripped_str, false).collect::<Vec<&str>>();\n-    let indent = fmt.shape.indent.to_string(fmt.config);\n+    let shape = fmt.shape.visual_indent(0);\n+    let indent = shape.indent.to_string(fmt.config);\n     let punctuation = \":,;.\";\n \n     // `cur_start` is the position in `orig` of the start of the current line.\n@@ -49,7 +50,7 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     let ender_length = fmt.line_end.len();\n     // If we cannot put at least a single character per line, the rewrite won't\n     // succeed.\n-    let max_chars = try_opt!(fmt.shape.width.checked_sub(fmt.opener.len() + ender_length + 1)) + 1;\n+    let max_chars = try_opt!(shape.width.checked_sub(fmt.opener.len() + ender_length + 1)) + 1;\n \n     // Snip a line at a time from `orig` until it is used up. Push the snippet\n     // onto result."}, {"sha": "d636f6e587a3ccddd72240e0633ea547cac76c80", "filename": "src/types.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=b35906dbce47552c2ba6350f31c654bc77603fbd", "patch": "@@ -66,18 +66,17 @@ pub fn rewrite_path(context: &RewriteContext,\n                 result.push_str(\"::\");\n             }\n \n-            let extra_offset = extra_offset(&result, shape.indent);\n+            let extra_offset = extra_offset(&result, shape);\n             // 3 = \">::\".len()\n-            let budget = try_opt!(shape.width.checked_sub(extra_offset + 3));\n+            let shape = try_opt!(try_opt!(shape.shrink_left(extra_offset)).sub_width(3));\n \n             result = try_opt!(rewrite_path_segments(PathContext::Type,\n                                                     result,\n                                                     path.segments.iter().take(skip_count),\n                                                     span_lo,\n                                                     path.span.hi,\n                                                     context,\n-                                                    Shape::legacy(budget,\n-                                                                  shape.indent + extra_offset)));\n+                                                    shape));\n         }\n \n         if context.config.spaces_within_angle_brackets {\n@@ -88,15 +87,15 @@ pub fn rewrite_path(context: &RewriteContext,\n         span_lo = qself.ty.span.hi + BytePos(1);\n     }\n \n-    let extra_offset = extra_offset(&result, shape.indent);\n-    let budget = try_opt!(shape.width.checked_sub(extra_offset));\n+    let extra_offset = extra_offset(&result, shape);\n+    let shape = try_opt!(shape.shrink_left(extra_offset));\n     rewrite_path_segments(path_context,\n                           result,\n                           path.segments.iter().skip(skip_count),\n                           span_lo,\n                           path.span.hi,\n                           context,\n-                          Shape::legacy(budget, shape.indent + extra_offset))\n+                          shape)\n }\n \n fn rewrite_path_segments<'a, I>(path_context: PathContext,\n@@ -110,6 +109,7 @@ fn rewrite_path_segments<'a, I>(path_context: PathContext,\n     where I: Iterator<Item = &'a ast::PathSegment>\n {\n     let mut first = true;\n+    let shape = shape.visual_indent(0);\n \n     for segment in iter {\n         // Indicates a global path, shouldn't be rendered.\n@@ -122,15 +122,14 @@ fn rewrite_path_segments<'a, I>(path_context: PathContext,\n             buffer.push_str(\"::\");\n         }\n \n-        let extra_offset = extra_offset(&buffer, shape.indent);\n-        let remaining_width = try_opt!(shape.width.checked_sub(extra_offset));\n-        let new_offset = shape.indent + extra_offset;\n+        let extra_offset = extra_offset(&buffer, shape);\n+        let new_shape = try_opt!(shape.shrink_left(extra_offset));\n         let segment_string = try_opt!(rewrite_segment(path_context,\n                                                       segment,\n                                                       &mut span_lo,\n                                                       span_hi,\n                                                       context,\n-                                                      Shape::legacy(remaining_width, new_offset)));\n+                                                      new_shape));\n \n         buffer.push_str(&segment_string);\n     }\n@@ -190,8 +189,7 @@ fn rewrite_segment(path_context: PathContext,\n                    shape: Shape)\n                    -> Option<String> {\n     let ident_len = segment.identifier.to_string().len();\n-    let width = try_opt!(shape.width.checked_sub(ident_len));\n-    let offset = shape.indent + ident_len;\n+    let shape = try_opt!(shape.shrink_left(ident_len));\n \n     let params = if let Some(ref params) = segment.parameters {\n         match **params {\n@@ -216,24 +214,18 @@ fn rewrite_segment(path_context: PathContext,\n                 // 1 for <\n                 let extra_offset = 1 + separator.len();\n                 // 1 for >\n-                let list_width = try_opt!(width.checked_sub(extra_offset + 1));\n+                // TODO bad visual indent\n+                let list_shape = try_opt!(try_opt!(shape.shrink_left(extra_offset)).sub_width(1)).visual_indent(0);\n \n                 let items = itemize_list(context.codemap,\n                                          param_list.into_iter(),\n                                          \">\",\n                                          |param| param.get_span().lo,\n                                          |param| param.get_span().hi,\n-                                         |seg| {\n-                                             seg.rewrite(context,\n-                                                         Shape::legacy(list_width,\n-                                                                       offset + extra_offset))\n-                                         },\n+                                         |seg| seg.rewrite(context, list_shape),\n                                          list_lo,\n                                          span_hi);\n-                let list_str = try_opt!(format_item_list(items,\n-                                                         Shape::legacy(list_width,\n-                                                                       offset + extra_offset),\n-                                                         context.config));\n+                let list_str = try_opt!(format_item_list(items, list_shape, context.config));\n \n                 // Update position of last bracket.\n                 *span_lo = next_span_lo;\n@@ -254,7 +246,7 @@ fn rewrite_segment(path_context: PathContext,\n                                               false,\n                                               data.span,\n                                               context,\n-                                              Shape::legacy(width, offset)))\n+                                              shape))\n             }\n             _ => String::new(),\n         }"}, {"sha": "da48831e672e12301876b199ee23ee47f2314919", "filename": "src/utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=b35906dbce47552c2ba6350f31c654bc77603fbd", "patch": "@@ -18,16 +18,16 @@ use syntax::ast::{self, Visibility, Attribute, MetaItem, MetaItemKind, NestedMet\n use syntax::codemap::BytePos;\n use syntax::abi;\n \n-use {Indent, Shape};\n+use Shape;\n use rewrite::{Rewrite, RewriteContext};\n \n use SKIP_ANNOTATION;\n \n // Computes the length of a string's last line, minus offset.\n-pub fn extra_offset(text: &str, offset: Indent) -> usize {\n+pub fn extra_offset(text: &str, shape: Shape) -> usize {\n     match text.rfind('\\n') {\n         // 1 for newline character\n-        Some(idx) => text.len().checked_sub(idx + 1 + offset.width()).unwrap_or(0),\n+        Some(idx) => text.len().checked_sub(idx + 1 + shape.used_width()).unwrap_or(0),\n         None => text.len(),\n     }\n }"}, {"sha": "e7fd3beda2f98de9f88bae47e886e5ce32b6c0d3", "filename": "src/visitor.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b35906dbce47552c2ba6350f31c654bc77603fbd/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=b35906dbce47552c2ba6350f31c654bc77603fbd", "patch": "@@ -294,6 +294,7 @@ impl<'a> FmtVisitor<'a> {\n                                              ty,\n                                              mutability,\n                                              Some(expr),\n+                                             self.block_indent,\n                                              &self.get_context());\n                 self.push_rewrite(item.span, rewrite);\n             }\n@@ -304,6 +305,7 @@ impl<'a> FmtVisitor<'a> {\n                                              ty,\n                                              ast::Mutability::Immutable,\n                                              Some(expr),\n+                                             self.block_indent,\n                                              &self.get_context());\n                 self.push_rewrite(item.span, rewrite);\n             }\n@@ -353,6 +355,7 @@ impl<'a> FmtVisitor<'a> {\n                                              ty,\n                                              ast::Mutability::Immutable,\n                                              expr_opt.as_ref(),\n+                                             self.block_indent,\n                                              &self.get_context());\n                 self.push_rewrite(ti.span, rewrite);\n             }\n@@ -403,6 +406,7 @@ impl<'a> FmtVisitor<'a> {\n                                              ty,\n                                              ast::Mutability::Immutable,\n                                              Some(expr),\n+                                             self.block_indent,\n                                              &self.get_context());\n                 self.push_rewrite(ii.span, rewrite);\n             }\n@@ -560,7 +564,6 @@ impl<'a> FmtVisitor<'a> {\n             parse_session: self.parse_session,\n             codemap: self.codemap,\n             config: self.config,\n-            block_indent: self.block_indent,\n         }\n     }\n }"}]}