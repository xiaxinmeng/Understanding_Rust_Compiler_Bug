{"sha": "be7a17062b103b31798afcd525c51a9642038465", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlN2ExNzA2MmIxMDNiMzE3OThhZmNkNTI1YzUxYTk2NDIwMzg0NjU=", "commit": {"author": {"name": "Valerii Hiora", "email": "valerii.hiora@gmail.com", "date": "2014-07-09T14:48:17Z"}, "committer": {"name": "Valerii Hiora", "email": "valerii.hiora@gmail.com", "date": "2014-07-09T15:23:39Z"}, "message": "TreeMap: find enhancements\n\nfind_with/find_mut_with which use provided closure for navigating tree\nand searching as flexible as possible", "tree": {"sha": "f9e55fc7142aad4798ec44c6f0639018167150a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9e55fc7142aad4798ec44c6f0639018167150a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be7a17062b103b31798afcd525c51a9642038465", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be7a17062b103b31798afcd525c51a9642038465", "html_url": "https://github.com/rust-lang/rust/commit/be7a17062b103b31798afcd525c51a9642038465", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be7a17062b103b31798afcd525c51a9642038465/comments", "author": {"login": "vhbit", "id": 140199, "node_id": "MDQ6VXNlcjE0MDE5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/140199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vhbit", "html_url": "https://github.com/vhbit", "followers_url": "https://api.github.com/users/vhbit/followers", "following_url": "https://api.github.com/users/vhbit/following{/other_user}", "gists_url": "https://api.github.com/users/vhbit/gists{/gist_id}", "starred_url": "https://api.github.com/users/vhbit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vhbit/subscriptions", "organizations_url": "https://api.github.com/users/vhbit/orgs", "repos_url": "https://api.github.com/users/vhbit/repos", "events_url": "https://api.github.com/users/vhbit/events{/privacy}", "received_events_url": "https://api.github.com/users/vhbit/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vhbit", "id": 140199, "node_id": "MDQ6VXNlcjE0MDE5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/140199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vhbit", "html_url": "https://github.com/vhbit", "followers_url": "https://api.github.com/users/vhbit/followers", "following_url": "https://api.github.com/users/vhbit/following{/other_user}", "gists_url": "https://api.github.com/users/vhbit/gists{/gist_id}", "starred_url": "https://api.github.com/users/vhbit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vhbit/subscriptions", "organizations_url": "https://api.github.com/users/vhbit/orgs", "repos_url": "https://api.github.com/users/vhbit/repos", "events_url": "https://api.github.com/users/vhbit/events{/privacy}", "received_events_url": "https://api.github.com/users/vhbit/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ddd286ea4ba4384a0dc9eae393ed515460a986e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ddd286ea4ba4384a0dc9eae393ed515460a986e", "html_url": "https://github.com/rust-lang/rust/commit/8ddd286ea4ba4384a0dc9eae393ed515460a986e"}], "stats": {"total": 163, "additions": 136, "deletions": 27}, "files": [{"sha": "e0242af3c9973c327dd6e1b4fcc3db3ea39ec2f1", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 136, "deletions": 27, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/be7a17062b103b31798afcd525c51a9642038465/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7a17062b103b31798afcd525c51a9642038465/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=be7a17062b103b31798afcd525c51a9642038465", "patch": "@@ -88,40 +88,18 @@ impl<K: Ord, V> Mutable for TreeMap<K, V> {\n }\n \n impl<K: Ord, V> Map<K, V> for TreeMap<K, V> {\n+    // See comments on tree_find_with\n+    #[inline]\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n-        let mut current = &self.root;\n-        loop {\n-            match *current {\n-              Some(ref r) => {\n-                match key.cmp(&r.key) {\n-                  Less => current = &r.left,\n-                  Greater => current = &r.right,\n-                  Equal => return Some(&r.value)\n-                }\n-              }\n-              None => return None\n-            }\n-        }\n+        tree_find_with(&self.root, |k2| key.cmp(k2))\n     }\n }\n \n impl<K: Ord, V> MutableMap<K, V> for TreeMap<K, V> {\n+    // See comments on def_tree_find_mut_with\n     #[inline]\n     fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n-        let mut current = &mut self.root;\n-        loop {\n-            let temp = current; // hack to appease borrowck\n-            match *temp {\n-              Some(ref mut r) => {\n-                match key.cmp(&r.key) {\n-                  Less => current = &mut r.left,\n-                  Greater => current = &mut r.right,\n-                  Equal => return Some(&mut r.value)\n-                }\n-              }\n-              None => return None\n-            }\n-        }\n+        tree_find_mut_with(&mut self.root, |x| key.cmp(x))\n     }\n \n     fn swap(&mut self, key: K, value: V) -> Option<V> {\n@@ -194,6 +172,55 @@ impl<K: Ord, V> TreeMap<K, V> {\n     }\n }\n \n+impl<K, V> TreeMap<K, V> {\n+    /// Return the value for which f(key) returns Equal. f is invoked\n+    /// with current key and helps to navigate the tree\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::ascii::StrAsciiExt;\n+    ///\n+    /// let mut t = collections::treemap::TreeMap::new();\n+    /// t.insert(\"Content-Type\", \"application/xml\");\n+    /// t.insert(\"User-Agent\", \"Curl-Rust/0.1\");\n+    ///\n+    /// let ua_key = \"user-agent\";\n+    /// let ua = t.find_with(|&k| {\n+    ///    ua_key.cmp(&k.to_ascii_lower().as_slice())\n+    /// });\n+    ///\n+    /// assert_eq!(*ua.unwrap(), \"Curl-Rust/0.1\");\n+    /// ```\n+    #[inline]\n+    pub fn find_with<'a>(&'a self, f:|&K| -> Ordering) -> Option<&'a V> {\n+        tree_find_with(&self.root, f)\n+    }\n+\n+    /// Return the value for which f(key) returns Equal. f is invoked\n+    /// with current key and helps to navigate the tree\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut t = collections::treemap::TreeMap::new();\n+    /// t.insert(\"Content-Type\", \"application/xml\");\n+    /// t.insert(\"User-Agent\", \"Curl-Rust/0.1\");\n+    ///\n+    /// let new_ua = \"Safari/156.0\";\n+    /// match t.find_mut_with(|k| \"User-Agent\".cmp(k)) {\n+    ///    Some(x) => *x = new_ua,\n+    ///    None => fail!(),\n+    /// }\n+    ///\n+    /// assert_eq!(t.find(&\"User-Agent\"), Some(&new_ua));\n+    /// ```\n+    #[inline]\n+    pub fn find_mut_with<'a>(&'a mut self, f:|&K| -> Ordering) -> Option<&'a mut V> {\n+        tree_find_mut_with(&mut self.root, f)\n+    }\n+}\n+\n // range iterators.\n \n macro_rules! bound_setup {\n@@ -853,6 +880,51 @@ fn split<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n     }\n }\n \n+// Next 2 functions have the same conventions\n+//\n+// The only difference is that non-mutable version uses loop instead\n+// of recursion (performance considerations)\n+// It seems to be impossible to avoid recursion with mutability\n+//\n+// So convention is that comparator is gets at input current key\n+// and returns search_key cmp cur_key (i.e. search_key.cmp(cur_key))\n+fn tree_find_with<'r, K, V>(node: &'r Option<Box<TreeNode<K, V>>>,\n+                            f: |&K| -> Ordering) -> Option<&'r V> {\n+    let mut current: &'r Option<Box<TreeNode<K, V>>> = node;\n+    loop {\n+        match *current {\n+            Some(ref r) => {\n+                match f(&r.key) {\n+                    Less => current = &r.left,\n+                    Greater => current = &r.right,\n+                    Equal => return Some(&r.value)\n+                }\n+            }\n+            None => return None\n+        }\n+    }\n+}\n+\n+// See comments above tree_find_with\n+fn tree_find_mut_with<'r, K, V>(node: &'r mut Option<Box<TreeNode<K, V>>>,\n+                                f: |&K| -> Ordering) -> Option<&'r mut V> {\n+\n+    let mut current = node;\n+    loop {\n+        let temp = current; // hack to appease borrowck\n+        match *temp {\n+            Some(ref mut r) => {\n+                match f(&r.key) {\n+                    Less => current = &mut r.left,\n+                    Greater => current = &mut r.right,\n+                    Equal => return Some(&mut r.value)\n+                }\n+            }\n+            None => return None\n+        }\n+    }\n+}\n+\n fn insert<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n                           key: K, value: V) -> Option<V> {\n     match *node {\n@@ -1024,6 +1096,30 @@ mod test_treemap {\n         assert_eq!(m.find(&2), None);\n     }\n \n+    #[test]\n+    fn find_with_empty() {\n+        let m: TreeMap<&'static str,int> = TreeMap::new();\n+        assert!(m.find_with(|k| \"test\".cmp(k)) == None);\n+    }\n+\n+    #[test]\n+    fn find_with_not_found() {\n+        let mut m = TreeMap::new();\n+        assert!(m.insert(\"test1\", 2i));\n+        assert!(m.insert(\"test2\", 3i));\n+        assert!(m.insert(\"test3\", 3i));\n+        assert_eq!(m.find_with(|k| \"test4\".cmp(k)), None);\n+    }\n+\n+    #[test]\n+    fn find_with_found() {\n+        let mut m = TreeMap::new();\n+        assert!(m.insert(\"test1\", 2i));\n+        assert!(m.insert(\"test2\", 3i));\n+        assert!(m.insert(\"test3\", 4i));\n+        assert_eq!(m.find_with(|k| \"test2\".cmp(k)), Some(&3i));\n+    }\n+\n     #[test]\n     fn test_find_mut() {\n         let mut m = TreeMap::new();\n@@ -1037,6 +1133,19 @@ mod test_treemap {\n         assert_eq!(m.find(&5), Some(&new));\n     }\n \n+    #[test]\n+    fn test_find_with_mut() {\n+        let mut m = TreeMap::new();\n+        assert!(m.insert(\"t1\", 12i));\n+        assert!(m.insert(\"t2\", 8));\n+        assert!(m.insert(\"t5\", 14));\n+        let new = 100;\n+        match m.find_mut_with(|k| \"t5\".cmp(k)) {\n+          None => fail!(), Some(x) => *x = new\n+        }\n+        assert_eq!(m.find_with(|k| \"t5\".cmp(k)), Some(&new));\n+    }\n+\n     #[test]\n     fn insert_replace() {\n         let mut m = TreeMap::new();"}]}