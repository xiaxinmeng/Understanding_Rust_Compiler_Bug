{"sha": "8231f46a8f72cc56c92f258bd434fa6234daf3f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMzFmNDZhOGY3MmNjNTZjOTJmMjU4YmQ0MzRmYTYyMzRkYWYzZjU=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-10-09T06:52:08Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-10-09T06:52:08Z"}, "message": "Resolve divergency with master", "tree": {"sha": "914689a29c6ebb40977f70a9bf53895414eaf94d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/914689a29c6ebb40977f70a9bf53895414eaf94d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8231f46a8f72cc56c92f258bd434fa6234daf3f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8231f46a8f72cc56c92f258bd434fa6234daf3f5", "html_url": "https://github.com/rust-lang/rust/commit/8231f46a8f72cc56c92f258bd434fa6234daf3f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8231f46a8f72cc56c92f258bd434fa6234daf3f5/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2b84788fb01ffec92d3b6eac5908bd892fc1576", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b84788fb01ffec92d3b6eac5908bd892fc1576", "html_url": "https://github.com/rust-lang/rust/commit/f2b84788fb01ffec92d3b6eac5908bd892fc1576"}], "stats": {"total": 80, "additions": 54, "deletions": 26}, "files": [{"sha": "c303c19952265c04ad5cb48c5594ab16de1c60bc", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8231f46a8f72cc56c92f258bd434fa6234daf3f5/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8231f46a8f72cc56c92f258bd434fa6234daf3f5/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=8231f46a8f72cc56c92f258bd434fa6234daf3f5", "patch": "@@ -1731,14 +1731,14 @@ pub fn run_test(\n     }\n \n     struct TestRunOpts {\n+        pub strategy: RunStrategy,\n         pub nocapture: bool,\n         pub concurrency: Concurrent,\n         pub time: Option<TestTimeOptions>,\n     }\n \n     fn run_test_inner(\n         desc: TestDesc,\n-        strategy: RunStrategy,\n         monitor_ch: Sender<MonitorMsg>,\n         testfn: Box<dyn FnOnce() + Send>,\n         opts: TestRunOpts,\n@@ -1747,10 +1747,10 @@ pub fn run_test(\n         let name = desc.name.clone();\n \n         let runtest = move || {\n-            match strategy {\n+            match opts.strategy {\n                 RunStrategy::InProcess =>\n-                    run_test_in_process(desc, nocapture, report_time, testfn, monitor_ch),\n-                RunStrategy::SpawnPrimary => spawn_test_subprocess(desc, report_time, monitor_ch),\n+                    run_test_in_process(desc, opts.nocapture, opts.time.is_some(), testfn, monitor_ch, opts.time),\n+                RunStrategy::SpawnPrimary => spawn_test_subprocess(desc, opts.time.is_some(), monitor_ch, opts.time),\n             }\n         };\n \n@@ -1767,6 +1767,7 @@ pub fn run_test(\n     }\n \n     let test_run_opts = TestRunOpts {\n+        strategy,\n         nocapture: opts.nocapture,\n         concurrency,\n         time: opts.time_options\n@@ -1792,15 +1793,13 @@ pub fn run_test(\n             };\n             run_test_inner(\n                 desc,\n-                strategy,\n                 monitor_ch,\n                 Box::new(move || __rust_begin_short_backtrace(f)),\n-                concurrency\n+                test_run_opts,\n             );\n         }\n         StaticTestFn(f) => run_test_inner(\n             desc,\n-            strategy,\n             monitor_ch,\n             Box::new(move || __rust_begin_short_backtrace(f)),\n             test_run_opts,\n@@ -1816,10 +1815,10 @@ fn __rust_begin_short_backtrace<F: FnOnce()>(f: F) {\n \n fn calc_result<'a>(\n     desc: &TestDesc,\n-    task_result: Result<(), &'a (dyn Any + 'static + Send)>)\n+    task_result: Result<(), &'a (dyn Any + 'static + Send)>,\n     time_opts: &Option<TestTimeOptions>,\n-    exec_time: &Option<TestExecTime>)\n--> TestResult {\n+    exec_time: &Option<TestExecTime>\n+) -> TestResult {\n     let result = match (&desc.should_panic, task_result) {\n         (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TrOk,\n         (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n@@ -1844,7 +1843,6 @@ fn calc_result<'a>(\n         _ => TrFailed,\n     };\n \n-\n     // If test is already failed (or allowed to fail), do not change the result.\n     if result != TrOk {\n         return result;\n@@ -1860,20 +1858,42 @@ fn calc_result<'a>(\n     result\n }\n \n-fn get_result_from_exit_code(desc: &TestDesc, code: i32) -> TestResult {\n-    match (desc.allow_fail, code) {\n+fn get_result_from_exit_code(\n+    desc: &TestDesc,\n+    code: i32,\n+    time_opts: &Option<TestTimeOptions>,\n+    exec_time: &Option<TestExecTime>,\n+) -> TestResult {\n+    let result = match (desc.allow_fail, code) {\n         (_, TR_OK) => TrOk,\n         (true, TR_FAILED) => TrAllowedFail,\n         (false, TR_FAILED) => TrFailed,\n         (_, _) => TrFailedMsg(format!(\"got unexpected return code {}\", code)),\n+    };\n+\n+    // If test is already failed (or allowed to fail), do not change the result.\n+    if result != TrOk {\n+        return result;\n+    }\n+\n+    // Check if test is failed due to timeout.\n+    if let (Some(opts), Some(time)) = (time_opts, exec_time) {\n+        if opts.error_on_excess && opts.is_critical(desc, time) {\n+            return TrTimedFail;\n+        }\n     }\n+\n+    result\n }\n \n-fn run_test_in_process(desc: TestDesc,\n-                       nocapture: bool,\n-                       report_time: bool,\n-                       testfn: Box<dyn FnOnce() + Send>,\n-                       monitor_ch: Sender<MonitorMsg>) {\n+fn run_test_in_process(\n+    desc: TestDesc,\n+    nocapture: bool,\n+    report_time: bool,\n+    testfn: Box<dyn FnOnce() + Send>,\n+    monitor_ch: Sender<MonitorMsg>,\n+    time_opts: Option<TestTimeOptions>,\n+) {\n     // Buffer for capturing standard I/O\n     let data = Arc::new(Mutex::new(Vec::new()));\n \n@@ -1903,14 +1923,19 @@ fn run_test_in_process(desc: TestDesc,\n     }\n \n     let test_result = match result {\n-        Ok(()) => calc_result(&desc, Ok(())),\n-        Err(e) => calc_result(&desc, Err(e.as_ref())),\n+        Ok(()) => calc_result(&desc, Ok(()), &time_opts, &exec_time),\n+        Err(e) => calc_result(&desc, Err(e.as_ref()), &time_opts, &exec_time),\n     };\n     let stdout = data.lock().unwrap().to_vec();\n     monitor_ch.send((desc.clone(), test_result, exec_time, stdout)).unwrap();\n }\n \n-fn spawn_test_subprocess(desc: TestDesc, report_time: bool, monitor_ch: Sender<MonitorMsg>) {\n+fn spawn_test_subprocess(\n+    desc: TestDesc,\n+    report_time: bool,\n+    monitor_ch: Sender<MonitorMsg>,\n+    time_opts: Option<TestTimeOptions>,\n+) {\n     let (result, test_output, exec_time) = (|| {\n         let args = env::args().collect::<Vec<_>>();\n         let current_exe = &args[0];\n@@ -1941,7 +1966,7 @@ fn spawn_test_subprocess(desc: TestDesc, report_time: bool, monitor_ch: Sender<M\n \n         let result = match (|| -> Result<TestResult, String> {\n             let exit_code = get_exit_code(status)?;\n-            Ok(get_result_from_exit_code(&desc, exit_code))\n+            Ok(get_result_from_exit_code(&desc, exit_code, &time_opts, &exec_time))\n         })() {\n             Ok(r) => r,\n             Err(e) => {\n@@ -1956,12 +1981,15 @@ fn spawn_test_subprocess(desc: TestDesc, report_time: bool, monitor_ch: Sender<M\n     monitor_ch.send((desc.clone(), result, exec_time, test_output)).unwrap();\n }\n \n-fn run_test_in_spawned_subprocess(desc: TestDesc, testfn: Box<dyn FnOnce() + Send>) -> ! {\n+fn run_test_in_spawned_subprocess(\n+    desc: TestDesc,\n+    testfn: Box<dyn FnOnce() + Send>,\n+) -> ! {\n     let builtin_panic_hook = panic::take_hook();\n     let record_result = Arc::new(move |panic_info: Option<&'_ PanicInfo<'_>>| {\n         let test_result = match panic_info {\n-            Some(info) => calc_result(&desc, Err(info.payload())),\n-            None => calc_result(&desc, Ok(())),\n+            Some(info) => calc_result(&desc, Err(info.payload()), &None, &None),\n+            None => calc_result(&desc, Ok(()), &None, &None),\n         };\n \n         // We don't support serializing TrFailedMsg, so just"}, {"sha": "880d02a28ff06e9ff5da36ae9c08f37d3dbc53d0", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8231f46a8f72cc56c92f258bd434fa6234daf3f5/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8231f46a8f72cc56c92f258bd434fa6234daf3f5/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=8231f46a8f72cc56c92f258bd434fa6234daf3f5", "patch": "@@ -240,7 +240,7 @@ fn time_test_failure_template(test_type: TestType) -> TestResult {\n         ..TestOpts::new()\n     };\n     let (tx, rx) = channel();\n-    run_test(&test_opts, false, desc, tx, Concurrent::No);\n+    run_test(&test_opts, false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, result, _, _) = rx.recv().unwrap();\n \n     result"}]}