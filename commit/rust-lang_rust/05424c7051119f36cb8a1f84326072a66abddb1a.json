{"sha": "05424c7051119f36cb8a1f84326072a66abddb1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NDI0YzcwNTExMTlmMzZjYjhhMWY4NDMyNjA3MmE2NmFiZGRiMWE=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-11-24T16:49:19Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-11-25T13:22:12Z"}, "message": "Improve docs for std::char\n\nPart of #29428", "tree": {"sha": "5a7e0b1a0de4a9261259f95b9024b8ba96418705", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a7e0b1a0de4a9261259f95b9024b8ba96418705"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05424c7051119f36cb8a1f84326072a66abddb1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05424c7051119f36cb8a1f84326072a66abddb1a", "html_url": "https://github.com/rust-lang/rust/commit/05424c7051119f36cb8a1f84326072a66abddb1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05424c7051119f36cb8a1f84326072a66abddb1a/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edf2198f5fdc4488b354824f6d6947353ae80bcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/edf2198f5fdc4488b354824f6d6947353ae80bcc", "html_url": "https://github.com/rust-lang/rust/commit/edf2198f5fdc4488b354824f6d6947353ae80bcc"}], "stats": {"total": 205, "additions": 169, "deletions": 36}, "files": [{"sha": "5e13df432808fe35b032daef4837a95bb2745772", "filename": "src/libcore/char.rs", "status": "modified", "additions": 142, "deletions": 16, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/05424c7051119f36cb8a1f84326072a66abddb1a/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05424c7051119f36cb8a1f84326072a66abddb1a/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=05424c7051119f36cb8a1f84326072a66abddb1a", "patch": "@@ -63,19 +63,63 @@ const MAX_THREE_B: u32 =  0x10000;\n     Cn  Unassigned              a reserved unassigned code point or a noncharacter\n */\n \n-/// The highest valid code point\n+/// The highest valid code point a `char` can have.\n+///\n+/// A [`char`] is a [Unicode Scalar Value], which means that it is a [Code\n+/// Point], but only ones within a certain range. `MAX` is the highest valid\n+/// code point that's a valid [Unicode Scalar Value].\n+///\n+/// [`char`]: primitive.char.html\n+/// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n+/// [Code Point]: http://www.unicode.org/glossary/#code_point\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: char = '\\u{10ffff}';\n \n-/// Converts a `u32` to an `Option<char>`.\n+/// Converts a `u32` to a `char`.\n+///\n+/// Note that all [`char`]s are valid [`u32`]s, and can be casted to one with\n+/// [`as`]:\n+///\n+/// ```\n+/// let c = '\ud83d\udcaf';\n+/// let i = c as u32;\n+///\n+/// assert_eq!(128175, i);\n+/// ```\n+///\n+/// However, the reverse is not true: not all valid [`u32`]s are valid\n+/// [`char`]s. `from_u32()` will return `None` if the input is not a valid value\n+/// for a [`char`].\n+///\n+/// [`char`]: primitive.char.html\n+/// [`u32`]: primitive.u32.html\n+/// [`as`]: ../book/casting-between-types.html#as\n+///\n+/// For an unsafe version of this function which ignores these checks, see\n+/// [`from_u32_unchecked()`].\n+///\n+/// [`from_u32_unchecked()`]: fn.from_u32_unchecked.html\n ///\n /// # Examples\n ///\n+/// Basic usage:\n+///\n /// ```\n /// use std::char;\n ///\n-/// assert_eq!(char::from_u32(0x2764), Some('\u2764'));\n-/// assert_eq!(char::from_u32(0x110000), None); // invalid character\n+/// let c = char::from_u32(0x2764);\n+///\n+/// assert_eq!(Some('\u2764'), c);\n+/// ```\n+///\n+/// Returning `None` when the input is not a valid [`char`]:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_u32(0x110000);\n+///\n+/// assert_eq!(None, c);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -88,33 +132,104 @@ pub fn from_u32(i: u32) -> Option<char> {\n     }\n }\n \n-/// Converts a `u32` to an `char`, not checking whether it is a valid unicode\n-/// codepoint.\n+/// Converts a `u32` to a `char`, ignoring validity.\n+///\n+/// Note that all [`char`]s are valid [`u32`]s, and can be casted to one with\n+/// [`as`]:\n+///\n+/// ```\n+/// let c = '\ud83d\udcaf';\n+/// let i = c as u32;\n+///\n+/// assert_eq!(128175, i);\n+/// ```\n+///\n+/// However, the reverse is not true: not all valid [`u32`]s are valid\n+/// [`char`]s. `from_u32_unchecked()` will ignore this, and blindly cast to\n+/// [`char`], possibly creating an invalid one.\n+///\n+/// [`char`]: primitive.char.html\n+/// [`u32`]: primitive.u32.html\n+/// [`as`]: ../book/casting-between-types.html#as\n+///\n+/// # Safety\n+///\n+/// This function is unsafe, as it may construct invalid `char` values.\n+///\n+/// For a safe version of this function, see the [`from_u32()`] function.\n+///\n+/// [`from_u32()`]: fn.from_u32.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = unsafe { char::from_u32_unchecked(0x2764) };\n+///\n+/// assert_eq!('\u2764', c);\n+/// ```\n #[inline]\n #[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n pub unsafe fn from_u32_unchecked(i: u32) -> char {\n     transmute(i)\n }\n \n-/// Converts a number to the character representing it.\n+/// Converts a digit in the given radix to a `char`.\n ///\n-/// # Return value\n+/// A 'radix' here is sometimes also called a 'base'. A radix of two\n+/// indicates a binary number, a radix of ten, decimal, and a radix of\n+/// sixteen, hexicdecimal, to give some common values. Arbitrary\n+/// radicum are supported.\n ///\n-/// Returns `Some(char)` if `num` represents one digit under `radix`,\n-/// using one character of `0-9` or `a-z`, or `None` if it doesn't.\n+/// `from_digit()` will return `None` if the input is not a digit in\n+/// the given radix.\n ///\n /// # Panics\n ///\n-/// Panics if given an `radix` > 36.\n+/// Panics if given a radix larger than 36.\n ///\n /// # Examples\n ///\n+/// Basic usage:\n+///\n /// ```\n /// use std::char;\n ///\n /// let c = char::from_digit(4, 10);\n ///\n-/// assert_eq!(c, Some('4'));\n+/// assert_eq!(Some('4'), c);\n+///\n+/// // Decimal 11 is a single digit in base 16\n+/// let c = char::from_digit(11, 16);\n+///\n+/// assert_eq!(Some('b'), c);\n+/// ```\n+///\n+/// Returning `None` when the input is not a digit:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_digit(20, 10);\n+///\n+/// assert_eq!(None, c);\n+/// ```\n+///\n+/// Passing a large radix, causing a panic:\n+///\n+/// ```\n+/// use std::thread;\n+/// use std::char;\n+///\n+/// let result = thread::spawn(|| {\n+///     // this panics\n+///     let c = char::from_digit(1, 37);\n+/// }).join();\n+///\n+/// assert!(result.is_err());\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -287,8 +402,14 @@ pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> {\n     }\n }\n \n-/// An iterator over the characters that represent a `char`, as escaped by\n-/// Rust's unicode escaping rules.\n+/// Returns an iterator that yields the hexadecimal Unicode escape of a\n+/// character, as `char`s.\n+///\n+/// This `struct` is created by the [`escape_unicode()`] method on [`char`]. See\n+/// its documentation for more.\n+///\n+/// [`escape_unicode()`]: primitive.char.html#method.escape_unicode\n+/// [`char`]: primitive.char.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeUnicode {\n@@ -362,8 +483,13 @@ impl Iterator for EscapeUnicode {\n     }\n }\n \n-/// An iterator over the characters that represent a `char`, escaped\n-/// for maximum portability.\n+/// An iterator that yields the literal escape code of a `char`.\n+///\n+/// This `struct` is created by the [`escape_default()`] method on [`char`]. See\n+/// its documentation for more.\n+///\n+/// [`escape_default()`]: primitive.char.html#method.escape_default\n+/// [`char`]: primitive.char.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeDefault {"}, {"sha": "3824dd0e4368c7eef2e820582a3adcb60451d158", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/05424c7051119f36cb8a1f84326072a66abddb1a/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05424c7051119f36cb8a1f84326072a66abddb1a/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=05424c7051119f36cb8a1f84326072a66abddb1a", "patch": "@@ -8,24 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Unicode scalar values\n+//! A character type.\n //!\n-//! This module provides the `CharExt` trait, as well as its\n-//! implementation for the primitive `char` type, in order to allow\n-//! basic character manipulation.\n+//! The `char` type represents a single character. More specifically, since\n+//! 'character' isn't a well-defined concept in Unicode, `char` is a '[Unicode\n+//! scalar value]', which is similar to, but not the same as, a '[Unicode code\n+//! point]'.\n //!\n-//! A `char` represents a\n-//! *[Unicode scalar\n-//! value](http://www.unicode.org/glossary/#unicode_scalar_value)*, as it can\n-//! contain any Unicode code point except high-surrogate and low-surrogate code\n-//! points.\n+//! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n+//! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n //!\n-//! As such, only values in the ranges \\[0x0,0xD7FF\\] and \\[0xE000,0x10FFFF\\]\n-//! (inclusive) are allowed. A `char` can always be safely cast to a `u32`;\n-//! however the converse is not always true due to the above range limits\n-//! and, as such, should be performed via the `from_u32` function.\n+//! This module exists for technical reasons, the primary documentation for\n+//! `char` is directly on [the `char` primitive type](../primitive.char.html)\n+//! itself.\n //!\n-//! *[See also the `char` primitive type](../primitive.char.html).*\n+//! This module is the home of the iterator implementations for the iterators\n+//! implemented on `char`, as well as some useful constants and conversion\n+//! functions that convert various types to `char`.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -42,9 +41,13 @@ pub use core::char::{MAX, from_u32, from_u32_unchecked, from_digit, EscapeUnicod\n #[unstable(feature = \"unicode\", issue = \"27783\")]\n pub use tables::UNICODE_VERSION;\n \n-/// An iterator over the lowercase mapping of a given character, returned from\n-/// the [`to_lowercase` method](../primitive.char.html#method.to_lowercase) on\n-/// characters.\n+/// Returns an iterator that yields the lowercase equivalent of a `char`.\n+///\n+/// This `struct` is created by the [`to_lowercase()`] method on [`char`]. See\n+/// its documentation for more.\n+///\n+/// [`to_lowercase()`]: primitive.char.html#method.escape_to_lowercase\n+/// [`char`]: primitive.char.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ToLowercase(CaseMappingIter);\n \n@@ -56,9 +59,13 @@ impl Iterator for ToLowercase {\n     }\n }\n \n-/// An iterator over the uppercase mapping of a given character, returned from\n-/// the [`to_uppercase` method](../primitive.char.html#method.to_uppercase) on\n-/// characters.\n+/// Returns an iterator that yields the uppercase equivalent of a `char`.\n+///\n+/// This `struct` is created by the [`to_uppercase()`] method on [`char`]. See\n+/// its documentation for more.\n+///\n+/// [`to_uppercase()`]: primitive.char.html#method.escape_to_uppercase\n+/// [`char`]: primitive.char.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ToUppercase(CaseMappingIter);\n "}]}