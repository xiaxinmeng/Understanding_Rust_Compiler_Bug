{"sha": "a24df1397ec136a91df54f09baa4957bde9597a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNGRmMTM5N2VjMTM2YTkxZGY1NGYwOWJhYTQ5NTdiZGU5NTk3YTk=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-07-24T03:50:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-24T03:50:49Z"}, "message": "Merge pull request #2838 from nrc/chains\n\nRefactor chain formatting and fix some bugs", "tree": {"sha": "1873f3b349943c1f287e465914c886ebcf5fb9b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1873f3b349943c1f287e465914c886ebcf5fb9b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a24df1397ec136a91df54f09baa4957bde9597a9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbVqIZCRBK7hj4Ov3rIwAAdHIIAKbnxvmk+YiXQS4t8YBkHWB0\nCJUdbliIWCjryM4XhwJ6hzpwxNdOYUI+YTRi/wIbRnfniEG8ZkcuN3cOPAzZTAUw\nZYyqIMXT+lLiLT7Gbq0St8oD9jRxR6ofv5IhVAOepkxtRgmHfO2QURHkcmp2Bupe\nqV9q8VkW7iioduQ1ReqQpqKCpnLyQyaAaFuOII6NOvA1zbKuwElGNwI9hUpkzBr2\n2hh5R4LTyhi34dFo/yPA1KDI42cqIZVIGwn6qOkb17G0unCN7aDjXlcyjkC+mwkG\nGBEnkXCDy3+jlJTBbQCtPAw0GyNjsXZAZRtDS5tldeNkexocQ9XfQJeiyoxvchg=\n=I14m\n-----END PGP SIGNATURE-----\n", "payload": "tree 1873f3b349943c1f287e465914c886ebcf5fb9b7\nparent d3288841ea86b7ebcff57c840b9a4855f9033ece\nparent df4fb8a05b95f770304dae63c0bd90bb7408a232\nauthor Nick Cameron <nrc@ncameron.org> 1532404249 +1200\ncommitter GitHub <noreply@github.com> 1532404249 +1200\n\nMerge pull request #2838 from nrc/chains\n\nRefactor chain formatting and fix some bugs"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a24df1397ec136a91df54f09baa4957bde9597a9", "html_url": "https://github.com/rust-lang/rust/commit/a24df1397ec136a91df54f09baa4957bde9597a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a24df1397ec136a91df54f09baa4957bde9597a9/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3288841ea86b7ebcff57c840b9a4855f9033ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3288841ea86b7ebcff57c840b9a4855f9033ece", "html_url": "https://github.com/rust-lang/rust/commit/d3288841ea86b7ebcff57c840b9a4855f9033ece"}, {"sha": "df4fb8a05b95f770304dae63c0bd90bb7408a232", "url": "https://api.github.com/repos/rust-lang/rust/commits/df4fb8a05b95f770304dae63c0bd90bb7408a232", "html_url": "https://github.com/rust-lang/rust/commit/df4fb8a05b95f770304dae63c0bd90bb7408a232"}], "stats": {"total": 1164, "additions": 705, "deletions": 459}, "files": [{"sha": "7767ea847646081bb62b78725611bf90c831200a", "filename": "src/bin/main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmain.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -422,8 +422,7 @@ fn determine_operation(matches: &Matches) -> Result<Operation, ErrorKind> {\n             // we will do comparison later, so here tries to canonicalize first\n             // to get the expected behavior.\n             p.canonicalize().unwrap_or(p)\n-        })\n-        .collect();\n+        }).collect();\n \n     Ok(Operation::Format {\n         files,"}, {"sha": "2d8234ef41e39a50e9dae1d79cbed67a40e6bd62", "filename": "src/cargo-fmt/main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fcargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fcargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo-fmt%2Fmain.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -163,8 +163,7 @@ fn format_crate(\n             if verbosity == Verbosity::Verbose {\n                 println!(\"[{}] {:?}\", t.kind, t.path)\n             }\n-        })\n-        .map(|t| t.path)\n+        }).map(|t| t.path)\n         .collect();\n \n     run_rustfmt(&files, &rustfmt_args, verbosity)"}, {"sha": "7acb9b9126f471daae475e447f2d75fc7b8fa935", "filename": "src/chains.rs", "status": "modified", "additions": 533, "deletions": 333, "changes": 866, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -84,107 +84,277 @@ use syntax::codemap::Span;\n use syntax::{ast, ptr};\n \n pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    debug!(\"rewrite_chain {:?}\", shape);\n-    let total_span = expr.span;\n-    let (parent, subexpr_list) = make_subexpr_list(expr, context);\n-\n-    // Bail out if the chain is just try sugar, i.e., an expression followed by\n-    // any number of `?`s.\n-    if chain_only_try(&subexpr_list) {\n-        return rewrite_try(&parent, subexpr_list.len(), context, shape);\n+    let chain = Chain::from_ast(expr, context);\n+    debug!(\"rewrite_chain {:?} {:?}\", chain, shape);\n+\n+    // If this is just an expression with some `?`s, then format it trivially and\n+    // return early.\n+    if chain.children.is_empty() {\n+        return chain.parent.rewrite(context, shape);\n     }\n-    let suffix_try_num = subexpr_list.iter().take_while(|e| is_try(e)).count();\n-    let prefix_try_num = subexpr_list.iter().rev().take_while(|e| is_try(e)).count();\n \n-    // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n-    let parent_shape = if is_block_expr(context, &parent, \"\\n\") {\n-        match context.config.indent_style() {\n-            IndentStyle::Visual => shape.visual_indent(0),\n-            IndentStyle::Block => shape,\n+    chain.rewrite(context, shape)\n+}\n+\n+// An expression plus trailing `?`s to be formatted together.\n+#[derive(Debug)]\n+struct ChainItem {\n+    // FIXME: we can't use a reference here because to convert `try!` to `?` we\n+    // synthesise the AST node. However, I think we could use `Cow` and that\n+    // would remove a lot of cloning.\n+    expr: ast::Expr,\n+    tries: usize,\n+}\n+\n+impl Rewrite for ChainItem {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        let rewrite = self.expr.rewrite(context, shape.sub_width(self.tries)?)?;\n+        Some(format!(\"{}{}\", rewrite, \"?\".repeat(self.tries)))\n+    }\n+}\n+\n+impl ChainItem {\n+    // Rewrite the last element in the chain `expr`. E.g., given `a.b.c` we rewrite\n+    // `.c` and any trailing `?`s.\n+    fn rewrite_postfix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        let shape = shape.sub_width(self.tries)?;\n+        let mut rewrite = match self.expr.node {\n+            ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n+                let types = match segment.args {\n+                    Some(ref params) => match **params {\n+                        ast::GenericArgs::AngleBracketed(ref data) => &data.args[..],\n+                        _ => &[],\n+                    },\n+                    _ => &[],\n+                };\n+                Self::rewrite_method_call(\n+                    segment.ident,\n+                    types,\n+                    expressions,\n+                    self.expr.span,\n+                    context,\n+                    shape,\n+                )?\n+            }\n+            ast::ExprKind::Field(ref nested, ref field) => {\n+                let space =\n+                    if Self::is_tup_field_access(&self.expr) && Self::is_tup_field_access(nested) {\n+                        \" \"\n+                    } else {\n+                        \"\"\n+                    };\n+                let result = format!(\"{}.{}\", space, field.name);\n+                if result.len() <= shape.width {\n+                    result\n+                } else {\n+                    return None;\n+                }\n+            }\n+            _ => unreachable!(),\n+        };\n+        rewrite.push_str(&\"?\".repeat(self.tries));\n+        Some(rewrite)\n+    }\n+\n+    fn is_tup_field_access(expr: &ast::Expr) -> bool {\n+        match expr.node {\n+            ast::ExprKind::Field(_, ref field) => {\n+                field.name.to_string().chars().all(|c| c.is_digit(10))\n+            }\n+            _ => false,\n         }\n-    } else {\n-        shape\n-    };\n-    let parent_rewrite = parent\n-        .rewrite(context, parent_shape)\n-        .map(|parent_rw| parent_rw + &\"?\".repeat(prefix_try_num))?;\n-    let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n-    let is_small_parent = shape.offset + parent_rewrite.len() <= context.config.tab_spaces();\n-\n-    // Decide how to layout the rest of the chain. `extend` is true if we can\n-    // put the first non-parent item on the same line as the parent.\n-    let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n-        (\n-            chain_indent(context, shape.add_offset(parent_rewrite.len())),\n-            context.config.indent_style() == IndentStyle::Visual || is_small_parent,\n-        )\n-    } else if is_block_expr(context, &parent, &parent_rewrite) {\n-        match context.config.indent_style() {\n-            // Try to put the first child on the same line with parent's last line\n-            IndentStyle::Block => (parent_shape.block_indent(context.config.tab_spaces()), true),\n-            // The parent is a block, so align the rest of the chain with the closing\n-            // brace.\n-            IndentStyle::Visual => (parent_shape, false),\n+    }\n+\n+    fn rewrite_method_call(\n+        method_name: ast::Ident,\n+        types: &[ast::GenericArg],\n+        args: &[ptr::P<ast::Expr>],\n+        span: Span,\n+        context: &RewriteContext,\n+        shape: Shape,\n+    ) -> Option<String> {\n+        let (lo, type_str) = if types.is_empty() {\n+            (args[0].span.hi(), String::new())\n+        } else {\n+            let type_list = types\n+                .iter()\n+                .map(|ty| ty.rewrite(context, shape))\n+                .collect::<Option<Vec<_>>>()?;\n+\n+            let type_str = format!(\"::<{}>\", type_list.join(\", \"));\n+\n+            (types.last().unwrap().span().hi(), type_str)\n+        };\n+\n+        let callee_str = format!(\".{}{}\", method_name, type_str);\n+        let span = mk_sp(lo, span.hi());\n+\n+        rewrite_call(context, &callee_str, &args[1..], span, shape)\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct Chain {\n+    parent: ChainItem,\n+    children: Vec<ChainItem>,\n+}\n+\n+impl Chain {\n+    fn from_ast(expr: &ast::Expr, context: &RewriteContext) -> Chain {\n+        let subexpr_list = Self::make_subexpr_list(expr, context);\n+\n+        // Un-parse the expression tree into ChainItems\n+        let mut children = vec![];\n+        let mut sub_tries = 0;\n+        for subexpr in subexpr_list {\n+            match subexpr.node {\n+                ast::ExprKind::Try(_) => sub_tries += 1,\n+                _ => {\n+                    children.push(ChainItem {\n+                        expr: subexpr,\n+                        tries: sub_tries,\n+                    });\n+                    sub_tries = 0;\n+                }\n+            }\n         }\n-    } else {\n-        (\n-            chain_indent(context, shape.add_offset(parent_rewrite.len())),\n-            false,\n-        )\n-    };\n \n-    let other_child_shape = nested_shape.with_max_width(context.config);\n+        Chain {\n+            parent: children.pop().unwrap(),\n+            children,\n+        }\n+    }\n+\n+    // Returns a Vec of the prefixes of the chain.\n+    // E.g., for input `a.b.c` we return [`a.b.c`, `a.b`, 'a']\n+    fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> Vec<ast::Expr> {\n+        let mut subexpr_list = vec![expr.clone()];\n \n-    let first_child_shape = if extend {\n-        let overhead = last_line_width(&parent_rewrite);\n-        let offset = trimmed_last_line_width(&parent_rewrite) + prefix_try_num;\n-        match context.config.indent_style() {\n-            IndentStyle::Visual => parent_shape.offset_left(overhead)?,\n-            IndentStyle::Block => parent_shape.offset_left(offset)?,\n+        while let Some(subexpr) = Self::pop_expr_chain(subexpr_list.last().unwrap(), context) {\n+            subexpr_list.push(subexpr.clone());\n         }\n-    } else {\n-        other_child_shape\n-    };\n-    debug!(\n-        \"child_shapes {:?} {:?}\",\n-        first_child_shape, other_child_shape\n-    );\n-\n-    let child_shape_iter = Some(first_child_shape)\n-        .into_iter()\n-        .chain(iter::repeat(other_child_shape));\n-    let subexpr_num = subexpr_list.len();\n-    let last_subexpr = &subexpr_list[suffix_try_num];\n-    let subexpr_list = &subexpr_list[suffix_try_num..subexpr_num - prefix_try_num];\n-    let iter = subexpr_list.iter().skip(1).rev().zip(child_shape_iter);\n-    let mut rewrites = iter\n-        .map(|(e, shape)| rewrite_chain_subexpr(e, total_span, context, shape))\n-        .collect::<Option<Vec<_>>>()?;\n-\n-    // Total of all items excluding the last.\n-    let extend_last_subexpr = if is_small_parent {\n-        rewrites.len() == 1 && last_line_extendable(&rewrites[0])\n-    } else {\n-        rewrites.is_empty() && last_line_extendable(&parent_rewrite)\n-    };\n-    let almost_total = if extend_last_subexpr {\n-        last_line_width(&parent_rewrite)\n-    } else {\n-        rewrites.iter().fold(0, |a, b| a + b.len()) + parent_rewrite.len()\n-    } + suffix_try_num;\n-    let one_line_budget = if rewrites.is_empty() {\n-        shape.width\n-    } else {\n-        min(shape.width, context.config.width_heuristics().chain_width)\n-    };\n-    let all_in_one_line = !parent_rewrite_contains_newline\n-        && rewrites.iter().all(|s| !s.contains('\\n'))\n-        && almost_total < one_line_budget;\n-    let last_shape = if rewrites.is_empty() {\n-        first_child_shape\n-    } else {\n-        other_child_shape\n-    }.sub_width(shape.rhs_overhead(context.config) + suffix_try_num)?;\n+\n+        subexpr_list\n+    }\n+\n+    // Returns the expression's subexpression, if it exists. When the subexpr\n+    // is a try! macro, we'll convert it to shorthand when the option is set.\n+    fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext) -> Option<ast::Expr> {\n+        match expr.node {\n+            ast::ExprKind::MethodCall(_, ref expressions) => {\n+                Some(Self::convert_try(&expressions[0], context))\n+            }\n+            ast::ExprKind::Field(ref subexpr, _) | ast::ExprKind::Try(ref subexpr) => {\n+                Some(Self::convert_try(subexpr, context))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn convert_try(expr: &ast::Expr, context: &RewriteContext) -> ast::Expr {\n+        match expr.node {\n+            ast::ExprKind::Mac(ref mac) if context.config.use_try_shorthand() => {\n+                if let Some(subexpr) = convert_try_mac(mac, context) {\n+                    subexpr\n+                } else {\n+                    expr.clone()\n+                }\n+            }\n+            _ => expr.clone(),\n+        }\n+    }\n+}\n+\n+impl Rewrite for Chain {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        debug!(\"rewrite chain {:?} {:?}\", self, shape);\n+\n+        let mut formatter = match context.config.indent_style() {\n+            IndentStyle::Block => Box::new(ChainFormatterBlock::new(self)) as Box<ChainFormatter>,\n+            IndentStyle::Visual => Box::new(ChainFormatterVisual::new(self)) as Box<ChainFormatter>,\n+        };\n+\n+        formatter.format_root(&self.parent, context, shape)?;\n+        if let Some(result) = formatter.pure_root() {\n+            return wrap_str(result, context.config.max_width(), shape);\n+        }\n+\n+        // Decide how to layout the rest of the chain.\n+        let child_shape = formatter.child_shape(context, shape)?;\n+\n+        formatter.format_children(context, child_shape)?;\n+        formatter.format_last_child(context, shape, child_shape)?;\n+\n+        let result = formatter.join_rewrites(context, child_shape)?;\n+        wrap_str(result, context.config.max_width(), shape)\n+    }\n+}\n+\n+// There are a few types for formatting chains. This is because there is a lot\n+// in common between formatting with block vs visual indent, but they are\n+// different enough that branching on the indent all over the place gets ugly.\n+// Anything that can format a chain is a ChainFormatter.\n+trait ChainFormatter {\n+    // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n+    // Root is the parent plus any other chain items placed on the first line to\n+    // avoid an orphan. E.g.,\n+    // ```\n+    // foo.bar\n+    //     .baz()\n+    // ```\n+    // If `bar` were not part of the root, then foo would be orphaned and 'float'.\n+    fn format_root(\n+        &mut self,\n+        parent: &ChainItem,\n+        context: &RewriteContext,\n+        shape: Shape,\n+    ) -> Option<()>;\n+    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Option<Shape>;\n+    fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()>;\n+    fn format_last_child(\n+        &mut self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        child_shape: Shape,\n+    ) -> Option<()>;\n+    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String>;\n+    // Returns `Some` if the chain is only a root, None otherwise.\n+    fn pure_root(&mut self) -> Option<String>;\n+}\n+\n+// Data and behaviour that is shared by both chain formatters. The concrete\n+// formatters can delegate much behaviour to `ChainFormatterShared`.\n+struct ChainFormatterShared<'a> {\n+    // The current working set of child items.\n+    children: &'a [ChainItem],\n+    // The current rewrites of items (includes trailing `?`s, but not any way to\n+    // connect the rewrites together).\n+    rewrites: Vec<String>,\n+    // Whether the chain can fit on one line.\n+    fits_single_line: bool,\n+    // The number of children in the chain. This is not equal to `self.children.len()`\n+    // because `self.children` will change size as we process the chain.\n+    child_count: usize,\n+}\n+\n+impl<'a> ChainFormatterShared<'a> {\n+    fn new(chain: &'a Chain) -> ChainFormatterShared<'a> {\n+        ChainFormatterShared {\n+            children: &chain.children,\n+            rewrites: Vec::with_capacity(chain.children.len() + 1),\n+            fits_single_line: false,\n+            child_count: chain.children.len(),\n+        }\n+    }\n+\n+    fn pure_root(&mut self) -> Option<String> {\n+        if self.children.is_empty() {\n+            assert_eq!(self.rewrites.len(), 1);\n+            Some(self.rewrites.pop().unwrap())\n+        } else {\n+            None\n+        }\n+    }\n \n     // Rewrite the last child. The last child of a chain requires special treatment. We need to\n     // know whether 'overflowing' the last child make a better formatting:\n@@ -218,294 +388,324 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     //     result\n     // })\n     // ```\n+    fn format_last_child(\n+        &mut self,\n+        may_extend: bool,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        child_shape: Shape,\n+    ) -> Option<()> {\n+        let last = &self.children[0];\n+        let extendable =\n+            may_extend && last_line_extendable(&self.rewrites[self.rewrites.len() - 1]);\n+        let prev_last_line_width = last_line_width(&self.rewrites[self.rewrites.len() - 1]);\n+\n+        // Total of all items excluding the last.\n+        let almost_total = if extendable {\n+            prev_last_line_width\n+        } else {\n+            self.rewrites.iter().fold(0, |a, b| a + b.len())\n+        } + last.tries;\n+        let one_line_budget = if self.child_count == 1 {\n+            shape.width\n+        } else {\n+            min(shape.width, context.config.width_heuristics().chain_width)\n+        }.saturating_sub(almost_total);\n+\n+        let all_in_one_line =\n+            self.rewrites.iter().all(|s| !s.contains('\\n')) && one_line_budget > 0;\n+        let last_shape = if all_in_one_line {\n+            shape.sub_width(last.tries)?\n+        } else if extendable {\n+            child_shape.sub_width(last.tries)?\n+        } else {\n+            child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?\n+        };\n \n-    // `rewrite_last` rewrites the last child on its own line. We use a closure here instead of\n-    // directly calling `rewrite_chain_subexpr()` to avoid exponential blowup.\n-    let rewrite_last = || rewrite_chain_subexpr(last_subexpr, total_span, context, last_shape);\n-    let (last_subexpr_str, fits_single_line) = if all_in_one_line || extend_last_subexpr {\n-        // First we try to 'overflow' the last child and see if it looks better than using\n-        // vertical layout.\n-        parent_shape.offset_left(almost_total).map(|shape| {\n-            if let Some(rw) = rewrite_chain_subexpr(last_subexpr, total_span, context, shape) {\n-                // We allow overflowing here only if both of the following conditions match:\n-                // 1. The entire chain fits in a single line expect the last child.\n-                // 2. `last_child_str.lines().count() >= 5`.\n-                let line_count = rw.lines().count();\n-                let fits_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n-                if fits_single_line && line_count >= 5 {\n-                    (Some(rw), true)\n-                } else {\n-                    // We could not know whether overflowing is better than using vertical layout,\n-                    // just by looking at the overflowed rewrite. Now we rewrite the last child\n-                    // on its own line, and compare two rewrites to choose which is better.\n-                    match rewrite_last() {\n-                        Some(ref new_rw) if !fits_single_line => (Some(new_rw.clone()), false),\n-                        Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n-                            (Some(rw), fits_single_line)\n+        let mut last_subexpr_str = None;\n+        if all_in_one_line || extendable {\n+            // First we try to 'overflow' the last child and see if it looks better than using\n+            // vertical layout.\n+            if let Some(one_line_shape) = last_shape.offset_left(almost_total) {\n+                if let Some(rw) = last.rewrite_postfix(context, one_line_shape) {\n+                    // We allow overflowing here only if both of the following conditions match:\n+                    // 1. The entire chain fits in a single line except the last child.\n+                    // 2. `last_child_str.lines().count() >= 5`.\n+                    let line_count = rw.lines().count();\n+                    let could_fit_single_line = first_line_width(&rw) <= one_line_budget;\n+                    if could_fit_single_line && line_count >= 5 {\n+                        last_subexpr_str = Some(rw);\n+                        self.fits_single_line = all_in_one_line;\n+                    } else {\n+                        // We could not know whether overflowing is better than using vertical\n+                        // layout, just by looking at the overflowed rewrite. Now we rewrite the\n+                        // last child on its own line, and compare two rewrites to choose which is\n+                        // better.\n+                        let last_shape = child_shape\n+                            .sub_width(shape.rhs_overhead(context.config) + last.tries)?;\n+                        match last.rewrite_postfix(context, last_shape) {\n+                            Some(ref new_rw) if !could_fit_single_line => {\n+                                last_subexpr_str = Some(new_rw.clone());\n+                            }\n+                            Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n+                                last_subexpr_str = Some(rw);\n+                                self.fits_single_line = could_fit_single_line && all_in_one_line;\n+                            }\n+                            new_rw @ Some(..) => {\n+                                last_subexpr_str = new_rw;\n+                            }\n+                            _ => {\n+                                last_subexpr_str = Some(rw);\n+                                self.fits_single_line = could_fit_single_line && all_in_one_line;\n+                            }\n                         }\n-                        new_rw @ Some(..) => (new_rw, false),\n-                        _ => (Some(rw), fits_single_line),\n                     }\n                 }\n-            } else {\n-                (rewrite_last(), false)\n             }\n-        })?\n-    } else {\n-        (rewrite_last(), false)\n-    };\n-    rewrites.push(last_subexpr_str?);\n-\n-    let connector = if fits_single_line && !parent_rewrite_contains_newline {\n-        // Yay, we can put everything on one line.\n-        Cow::from(\"\")\n-    } else {\n-        // Use new lines.\n-        if *context.force_one_line_chain.borrow() {\n-            return None;\n         }\n-        nested_shape.indent.to_string_with_newline(context.config)\n-    };\n-\n-    let first_connector = if is_small_parent\n-        || fits_single_line\n-        || last_line_extendable(&parent_rewrite)\n-        || context.config.indent_style() == IndentStyle::Visual\n-    {\n-        \"\"\n-    } else {\n-        &connector\n-    };\n-\n-    let result = if is_small_parent && rewrites.len() > 1 {\n-        let second_connector = if fits_single_line\n-            || rewrites[1] == \"?\"\n-            || last_line_extendable(&rewrites[0])\n-            || context.config.indent_style() == IndentStyle::Visual\n-        {\n-            \"\"\n+\n+        last_subexpr_str = last_subexpr_str.or_else(|| last.rewrite_postfix(context, last_shape));\n+        self.rewrites.push(last_subexpr_str?);\n+        Some(())\n+    }\n+\n+    fn join_rewrites(\n+        &self,\n+        context: &RewriteContext,\n+        child_shape: Shape,\n+        block_like_iter: impl Iterator<Item = bool>,\n+    ) -> Option<String> {\n+        let connector = if self.fits_single_line {\n+            // Yay, we can put everything on one line.\n+            Cow::from(\"\")\n         } else {\n-            &connector\n+            // Use new lines.\n+            if *context.force_one_line_chain.borrow() {\n+                return None;\n+            }\n+            child_shape.to_string_with_newline(context.config)\n         };\n-        format!(\n-            \"{}{}{}{}{}\",\n-            parent_rewrite,\n-            first_connector,\n-            rewrites[0],\n-            second_connector,\n-            join_rewrites(&rewrites[1..], &connector)\n-        )\n-    } else {\n-        format!(\n-            \"{}{}{}\",\n-            parent_rewrite,\n-            first_connector,\n-            join_rewrites(&rewrites, &connector)\n-        )\n-    };\n-    let result = format!(\"{}{}\", result, \"?\".repeat(suffix_try_num));\n-    if context.config.indent_style() == IndentStyle::Visual {\n-        wrap_str(result, context.config.max_width(), shape)\n-    } else {\n+\n+        let mut rewrite_iter = self.rewrites.iter();\n+        let mut result = rewrite_iter.next().unwrap().clone();\n+\n+        for (rewrite, prev_is_block_like) in rewrite_iter.zip(block_like_iter) {\n+            if !prev_is_block_like {\n+                result.push_str(&connector);\n+            }\n+            result.push_str(&rewrite);\n+        }\n+\n         Some(result)\n     }\n }\n \n-// True if the chain is only `?`s.\n-fn chain_only_try(exprs: &[ast::Expr]) -> bool {\n-    exprs.iter().all(|e| {\n-        if let ast::ExprKind::Try(_) = e.node {\n-            true\n-        } else {\n-            false\n-        }\n-    })\n+// Formats a chain using block indent.\n+struct ChainFormatterBlock<'a> {\n+    shared: ChainFormatterShared<'a>,\n+    // For each rewrite, whether the corresponding item is block-like.\n+    is_block_like: Vec<bool>,\n }\n \n-fn rewrite_try(\n-    expr: &ast::Expr,\n-    try_count: usize,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> Option<String> {\n-    let sub_expr = expr.rewrite(context, shape.sub_width(try_count)?)?;\n-    Some(format!(\"{}{}\", sub_expr, \"?\".repeat(try_count)))\n+impl<'a> ChainFormatterBlock<'a> {\n+    fn new(chain: &'a Chain) -> ChainFormatterBlock<'a> {\n+        ChainFormatterBlock {\n+            shared: ChainFormatterShared::new(chain),\n+            is_block_like: Vec::with_capacity(chain.children.len() + 1),\n+        }\n+    }\n }\n \n-fn join_rewrites(rewrites: &[String], connector: &str) -> String {\n-    let mut rewrite_iter = rewrites.iter();\n-    let mut result = rewrite_iter.next().unwrap().clone();\n+impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n+    fn format_root(\n+        &mut self,\n+        parent: &ChainItem,\n+        context: &RewriteContext,\n+        shape: Shape,\n+    ) -> Option<()> {\n+        let mut root_rewrite: String = parent.rewrite(context, shape)?;\n+\n+        let mut root_ends_with_block = is_block_expr(context, &parent.expr, &root_rewrite);\n+        let tab_width = context.config.tab_spaces().saturating_sub(shape.offset);\n+\n+        while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n+            let item = &self.shared.children[self.shared.children.len() - 1];\n+            let shape = shape.offset_left(root_rewrite.len())?;\n+            match &item.rewrite_postfix(context, shape) {\n+                Some(rewrite) => root_rewrite.push_str(rewrite),\n+                None => break,\n+            }\n+\n+            root_ends_with_block = is_block_expr(context, &item.expr, &root_rewrite);\n \n-    for rewrite in rewrite_iter {\n-        if rewrite != \"?\" {\n-            result.push_str(connector);\n+            self.shared.children = &self.shared.children[..self.shared.children.len() - 1];\n+            if self.shared.children.is_empty() {\n+                break;\n+            }\n         }\n-        result.push_str(&rewrite);\n+        self.is_block_like.push(root_ends_with_block);\n+        self.shared.rewrites.push(root_rewrite);\n+        Some(())\n     }\n \n-    result\n-}\n+    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Option<Shape> {\n+        Some(\n+            if self.is_block_like[0] {\n+                shape.block_indent(0)\n+            } else {\n+                shape.block_indent(context.config.tab_spaces())\n+            }.with_max_width(context.config),\n+        )\n+    }\n \n-// States whether an expression's last line exclusively consists of closing\n-// parens, braces, and brackets in its idiomatic formatting.\n-fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool {\n-    match expr.node {\n-        ast::ExprKind::Mac(..) | ast::ExprKind::Call(..) => {\n-            context.use_block_indent() && repr.contains('\\n')\n+    fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n+        for item in self.shared.children[1..].iter().rev() {\n+            let rewrite = item.rewrite_postfix(context, child_shape)?;\n+            self.is_block_like\n+                .push(is_block_expr(context, &item.expr, &rewrite));\n+            self.shared.rewrites.push(rewrite);\n         }\n-        ast::ExprKind::Struct(..)\n-        | ast::ExprKind::While(..)\n-        | ast::ExprKind::WhileLet(..)\n-        | ast::ExprKind::If(..)\n-        | ast::ExprKind::IfLet(..)\n-        | ast::ExprKind::Block(..)\n-        | ast::ExprKind::Loop(..)\n-        | ast::ExprKind::ForLoop(..)\n-        | ast::ExprKind::Match(..) => repr.contains('\\n'),\n-        ast::ExprKind::Paren(ref expr)\n-        | ast::ExprKind::Binary(_, _, ref expr)\n-        | ast::ExprKind::Index(_, ref expr)\n-        | ast::ExprKind::Unary(_, ref expr) => is_block_expr(context, expr, repr),\n-        _ => false,\n+        Some(())\n     }\n-}\n \n-// Returns the root of the chain and a Vec of the prefixes of the rest of the chain.\n-// E.g., for input `a.b.c` we return (`a`, [`a.b.c`, `a.b`])\n-fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> (ast::Expr, Vec<ast::Expr>) {\n-    let mut subexpr_list = vec![expr.clone()];\n+    fn format_last_child(\n+        &mut self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        child_shape: Shape,\n+    ) -> Option<()> {\n+        self.shared\n+            .format_last_child(true, context, shape, child_shape)\n+    }\n \n-    while let Some(subexpr) = pop_expr_chain(subexpr_list.last().unwrap(), context) {\n-        subexpr_list.push(subexpr.clone());\n+    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String> {\n+        self.shared\n+            .join_rewrites(context, child_shape, self.is_block_like.iter().cloned())\n     }\n \n-    let parent = subexpr_list.pop().unwrap();\n-    (parent, subexpr_list)\n+    fn pure_root(&mut self) -> Option<String> {\n+        self.shared.pure_root()\n+    }\n }\n \n-fn chain_indent(context: &RewriteContext, shape: Shape) -> Shape {\n-    match context.config.indent_style() {\n-        IndentStyle::Visual => shape.visual_indent(0),\n-        IndentStyle::Block => shape\n-            .block_indent(context.config.tab_spaces())\n-            .with_max_width(context.config),\n-    }\n+// Format a chain using visual indent.\n+struct ChainFormatterVisual<'a> {\n+    shared: ChainFormatterShared<'a>,\n+    // The extra offset from the chain's shape to the position of the `.`\n+    offset: usize,\n }\n \n-// Returns the expression's subexpression, if it exists. When the subexpr\n-// is a try! macro, we'll convert it to shorthand when the option is set.\n-fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext) -> Option<ast::Expr> {\n-    match expr.node {\n-        ast::ExprKind::MethodCall(_, ref expressions) => {\n-            Some(convert_try(&expressions[0], context))\n+impl<'a> ChainFormatterVisual<'a> {\n+    fn new(chain: &'a Chain) -> ChainFormatterVisual<'a> {\n+        ChainFormatterVisual {\n+            shared: ChainFormatterShared::new(chain),\n+            offset: 0,\n         }\n-        ast::ExprKind::Field(ref subexpr, _) | ast::ExprKind::Try(ref subexpr) => {\n-            Some(convert_try(subexpr, context))\n-        }\n-        _ => None,\n     }\n }\n \n-fn convert_try(expr: &ast::Expr, context: &RewriteContext) -> ast::Expr {\n-    match expr.node {\n-        ast::ExprKind::Mac(ref mac) if context.config.use_try_shorthand() => {\n-            if let Some(subexpr) = convert_try_mac(mac, context) {\n-                subexpr\n-            } else {\n-                expr.clone()\n+impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n+    fn format_root(\n+        &mut self,\n+        parent: &ChainItem,\n+        context: &RewriteContext,\n+        shape: Shape,\n+    ) -> Option<()> {\n+        let parent_shape = shape.visual_indent(0);\n+        let mut root_rewrite = parent.rewrite(context, parent_shape)?;\n+        let multiline = root_rewrite.contains('\\n');\n+        self.offset = if multiline {\n+            last_line_width(&root_rewrite).saturating_sub(shape.used_width())\n+        } else {\n+            trimmed_last_line_width(&root_rewrite)\n+        };\n+\n+        if !multiline || is_block_expr(context, &parent.expr, &root_rewrite) {\n+            let item = &self.shared.children[self.shared.children.len() - 1];\n+            let child_shape = parent_shape\n+                .visual_indent(self.offset)\n+                .sub_width(self.offset)?;\n+            let rewrite = item.rewrite_postfix(context, child_shape)?;\n+            match wrap_str(rewrite, context.config.max_width(), shape) {\n+                Some(rewrite) => root_rewrite.push_str(&rewrite),\n+                None => {\n+                    // We couldn't fit in at the visual indent, try the last\n+                    // indent.\n+                    let rewrite = item.rewrite_postfix(context, parent_shape)?;\n+                    root_rewrite.push_str(&rewrite);\n+                    self.offset = 0;\n+                }\n             }\n+\n+            self.shared.children = &self.shared.children[..self.shared.children.len() - 1];\n         }\n-        _ => expr.clone(),\n+\n+        self.shared.rewrites.push(root_rewrite);\n+        Some(())\n     }\n-}\n \n-// Rewrite the last element in the chain `expr`. E.g., given `a.b.c` we rewrite\n-// `.c`.\n-fn rewrite_chain_subexpr(\n-    expr: &ast::Expr,\n-    span: Span,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> Option<String> {\n-    let rewrite_element = |expr_str: String| {\n-        if expr_str.len() <= shape.width {\n-            Some(expr_str)\n-        } else {\n-            None\n-        }\n-    };\n+    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Option<Shape> {\n+        shape\n+            .with_max_width(context.config)\n+            .offset_left(self.offset)\n+            .map(|s| s.visual_indent(0))\n+    }\n \n-    match expr.node {\n-        ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n-            let types = match segment.args {\n-                Some(ref params) => match **params {\n-                    ast::GenericArgs::AngleBracketed(ref data) => &data.args[..],\n-                    _ => &[],\n-                },\n-                _ => &[],\n-            };\n-            rewrite_method_call(segment.ident, types, expressions, span, context, shape)\n-        }\n-        ast::ExprKind::Field(ref nested, ref field) => {\n-            let space = if is_tup_field_access(expr) && is_tup_field_access(nested) {\n-                \" \"\n-            } else {\n-                \"\"\n-            };\n-            rewrite_element(format!(\"{}.{}\", space, field.name))\n+    fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n+        for item in self.shared.children[1..].iter().rev() {\n+            let rewrite = item.rewrite_postfix(context, child_shape)?;\n+            self.shared.rewrites.push(rewrite);\n         }\n-        ast::ExprKind::Try(_) => rewrite_element(String::from(\"?\")),\n-        _ => unreachable!(),\n+        Some(())\n     }\n-}\n \n-fn is_tup_field_access(expr: &ast::Expr) -> bool {\n-    match expr.node {\n-        ast::ExprKind::Field(_, ref field) => {\n-            field.name.to_string().chars().all(|c| c.is_digit(10))\n-        }\n-        _ => false,\n+    fn format_last_child(\n+        &mut self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        child_shape: Shape,\n+    ) -> Option<()> {\n+        self.shared\n+            .format_last_child(false, context, shape, child_shape)\n     }\n-}\n \n-// Determines if we can continue formatting a given expression on the same line.\n-fn is_continuable(expr: &ast::Expr) -> bool {\n-    match expr.node {\n-        ast::ExprKind::Path(..) => true,\n-        _ => false,\n+    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String> {\n+        self.shared\n+            .join_rewrites(context, child_shape, iter::repeat(false))\n+    }\n+\n+    fn pure_root(&mut self) -> Option<String> {\n+        self.shared.pure_root()\n     }\n }\n \n-fn is_try(expr: &ast::Expr) -> bool {\n+// States whether an expression's last line exclusively consists of closing\n+// parens, braces, and brackets in its idiomatic formatting.\n+fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool {\n     match expr.node {\n-        ast::ExprKind::Try(..) => true,\n+        ast::ExprKind::Mac(..)\n+        | ast::ExprKind::Call(..)\n+        | ast::ExprKind::MethodCall(..)\n+        | ast::ExprKind::Struct(..)\n+        | ast::ExprKind::While(..)\n+        | ast::ExprKind::WhileLet(..)\n+        | ast::ExprKind::If(..)\n+        | ast::ExprKind::IfLet(..)\n+        | ast::ExprKind::Block(..)\n+        | ast::ExprKind::Loop(..)\n+        | ast::ExprKind::ForLoop(..)\n+        | ast::ExprKind::Match(..) => repr.contains('\\n'),\n+        ast::ExprKind::Paren(ref expr)\n+        | ast::ExprKind::Binary(_, _, ref expr)\n+        | ast::ExprKind::Index(_, ref expr)\n+        | ast::ExprKind::Unary(_, ref expr)\n+        | ast::ExprKind::Closure(_, _, _, _, ref expr, _)\n+        | ast::ExprKind::Try(ref expr)\n+        | ast::ExprKind::Yield(Some(ref expr)) => is_block_expr(context, expr, repr),\n+        // This can only be a string lit\n+        ast::ExprKind::Lit(_) => {\n+            repr.contains('\\n') && trimmed_last_line_width(repr) <= context.config.tab_spaces()\n+        }\n         _ => false,\n     }\n }\n-\n-fn rewrite_method_call(\n-    method_name: ast::Ident,\n-    types: &[ast::GenericArg],\n-    args: &[ptr::P<ast::Expr>],\n-    span: Span,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> Option<String> {\n-    let (lo, type_str) = if types.is_empty() {\n-        (args[0].span.hi(), String::new())\n-    } else {\n-        let type_list = types\n-            .iter()\n-            .map(|ty| ty.rewrite(context, shape))\n-            .collect::<Option<Vec<_>>>()?;\n-\n-        let type_str = format!(\"::<{}>\", type_list.join(\", \"));\n-\n-        (types.last().unwrap().span().hi(), type_str)\n-    };\n-\n-    let callee_str = format!(\".{}{}\", method_name, type_str);\n-    let span = mk_sp(lo, span.hi());\n-\n-    rewrite_call(context, &callee_str, &args[1..], span, shape)\n-}"}, {"sha": "c03c8e6b6065616a86273d1eb1ee6003d02849b8", "filename": "src/closures.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -198,8 +198,7 @@ fn rewrite_closure_expr(\n             } else {\n                 Some(rw)\n             }\n-        })\n-        .map(|rw| format!(\"{} {}\", prefix, rw))\n+        }).map(|rw| format!(\"{} {}\", prefix, rw))\n }\n \n // Rewrite closure whose body is block.\n@@ -376,10 +375,8 @@ where\n                 .map(|e| match e.node {\n                     ast::ExprKind::Closure(..) => true,\n                     _ => false,\n-                })\n-                .unwrap_or(false)\n-        })\n-        .count()\n+                }).unwrap_or(false)\n+        }).count()\n         > 1\n }\n "}, {"sha": "ed83a3925b005ebe30fe35b24db76651fce81ab7", "filename": "src/comment.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -348,8 +348,7 @@ fn rewrite_comment_inner(\n             }\n \n             line\n-        })\n-        .map(|s| left_trim_comment_line(s, &style))\n+        }).map(|s| left_trim_comment_line(s, &style))\n         .map(|(line, has_leading_whitespace)| {\n             if orig.starts_with(\"/*\") && line_breaks == 0 {\n                 (\n@@ -517,8 +516,7 @@ fn trim_custom_comment_prefix(s: &str) -> String {\n             } else {\n                 line\n             }\n-        })\n-        .collect::<Vec<_>>()\n+        }).collect::<Vec<_>>()\n         .join(\"\\n\")\n }\n \n@@ -606,8 +604,7 @@ fn light_rewrite_comment(\n             };\n             // Preserve markdown's double-space line break syntax in doc comment.\n             trim_right_unless_two_whitespaces(left_trimmed, is_doc_comment)\n-        })\n-        .collect();\n+        }).collect();\n     Some(lines.join(&format!(\"\\n{}\", offset.to_string(config))))\n }\n \n@@ -1341,8 +1338,7 @@ mod test {\n             .filter_map(|(s, c)| match s {\n                 FullCodeCharKind::Normal | FullCodeCharKind::InString => Some(c),\n                 _ => None,\n-            })\n-            .collect()\n+            }).collect()\n     }\n \n     #[test]"}, {"sha": "c48f9a4d72728e46eb15af8e00824b9c19652640", "filename": "src/config/options.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Foptions.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -322,8 +322,7 @@ impl IgnoreList {\n                     path.push(s);\n                     path\n                 }\n-            })\n-            .collect();\n+            }).collect();\n     }\n \n     fn skip_file_inner(&self, file: &Path) -> bool {"}, {"sha": "6814b91e0532ebb7592bc644eb38034fdd18265d", "filename": "src/expr.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -39,9 +39,9 @@ use spanned::Spanned;\n use string::{rewrite_string, StringFormat};\n use types::{can_be_overflowed_type, rewrite_path, PathContext};\n use utils::{\n-    colon_spaces, contains_skip, count_newlines, first_line_width, inner_attributes,\n-    last_line_extendable, last_line_width, mk_sp, outer_attributes, ptr_vec_to_ref_vec,\n-    semicolon_for_stmt, wrap_str,\n+    colon_spaces, contains_skip, count_newlines, first_line_ends_with, first_line_width,\n+    inner_attributes, last_line_extendable, last_line_width, mk_sp, outer_attributes,\n+    ptr_vec_to_ref_vec, semicolon_for_stmt, wrap_str,\n };\n use vertical::rewrite_with_alignment;\n use visitor::FmtVisitor;\n@@ -1212,8 +1212,7 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n                             new_indent.to_string(context.config),\n                             line.trim_left()\n                         )\n-                    })\n-                    .collect::<Vec<_>>()\n+                    }).collect::<Vec<_>>()\n                     .join(\"\\n\")\n                     .trim_left(),\n             );\n@@ -1953,6 +1952,9 @@ pub fn prefer_next_line(orig_rhs: &str, next_line_rhs: &str, rhs_tactics: RhsTac\n     rhs_tactics == RhsTactics::ForceNextLineWithoutIndent\n         || !next_line_rhs.contains('\\n')\n         || count_newlines(orig_rhs) > count_newlines(next_line_rhs) + 1\n+        || first_line_ends_with(orig_rhs, '(') && !first_line_ends_with(next_line_rhs, '(')\n+        || first_line_ends_with(orig_rhs, '{') && !first_line_ends_with(next_line_rhs, '{')\n+        || first_line_ends_with(orig_rhs, '[') && !first_line_ends_with(next_line_rhs, '[')\n }\n \n fn rewrite_expr_addrof("}, {"sha": "42ab4e89c3bc6b3f45172b6265535023598d9f43", "filename": "src/formatting.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -246,8 +246,7 @@ impl FormattingError {\n                     fl.file\n                         .get_line(fl.lines[0].line_index)\n                         .map(|l| l.into_owned())\n-                })\n-                .unwrap_or_else(|| String::new()),\n+                }).unwrap_or_else(|| String::new()),\n         }\n     }\n "}, {"sha": "d47827ab55e158da279a45217f88029661670ba9", "filename": "src/git-rustfmt/main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fgit-rustfmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fgit-rustfmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgit-rustfmt%2Fmain.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -46,8 +46,7 @@ fn prune_files(files: Vec<&str>) -> Vec<&str> {\n                 return true;\n             }\n             pruned_prefixes.iter().all(|pp| !f.starts_with(pp))\n-        })\n-        .collect()\n+        }).collect()\n }\n \n fn git_diff(commits: &str) -> String {"}, {"sha": "93f2ac8867a0c9a64162f9a386df9d9205c2af25", "filename": "src/imports.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -344,8 +344,7 @@ impl UseTree {\n                         .zip(items.into_iter())\n                         .map(|(t, list_item)| {\n                             Self::from_ast(context, &t.0, Some(list_item), None, None, None)\n-                        })\n-                        .collect(),\n+                        }).collect(),\n                 ));\n             }\n             UseTreeKind::Simple(ref rename, ..) => {"}, {"sha": "23338435d9ac9bd9afb541ddea272f062b4a589c", "filename": "src/items.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -1669,7 +1669,7 @@ fn rewrite_static(\n             &**expr,\n             Shape::legacy(remaining_width, offset.block_only()),\n         ).and_then(|res| recover_comment_removed(res, static_parts.span, context))\n-            .map(|s| if s.ends_with(';') { s } else { s + \";\" })\n+        .map(|s| if s.ends_with(';') { s } else { s + \";\" })\n     } else {\n         Some(format!(\"{}{};\", prefix, ty_str))\n     }\n@@ -2783,17 +2783,15 @@ impl Rewrite for ast::ForeignItem {\n         let span = mk_sp(self.span.lo(), self.span.hi() - BytePos(1));\n \n         let item_str = match self.node {\n-            ast::ForeignItemKind::Fn(ref fn_decl, ref generics) => {\n-                rewrite_fn_base(\n-                    context,\n-                    shape.indent,\n-                    self.ident,\n-                    &FnSig::new(fn_decl, generics, self.vis.clone()),\n-                    span,\n-                    false,\n-                    false,\n-                ).map(|(s, _)| format!(\"{};\", s))\n-            }\n+            ast::ForeignItemKind::Fn(ref fn_decl, ref generics) => rewrite_fn_base(\n+                context,\n+                shape.indent,\n+                self.ident,\n+                &FnSig::new(fn_decl, generics, self.vis.clone()),\n+                span,\n+                false,\n+                false,\n+            ).map(|(s, _)| format!(\"{};\", s)),\n             ast::ForeignItemKind::Static(ref ty, is_mutable) => {\n                 // FIXME(#21): we're dropping potential comments in between the\n                 // function keywords here."}, {"sha": "b55375b949c19ef1e48b72a62d2ef93c2d287697", "filename": "src/macros.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -1115,8 +1115,7 @@ fn indent_macro_snippet(\n             };\n             trimmed_lines.push((trimmed, line, prefix_space_width));\n             prefix_space_width\n-        })\n-        .min()?;\n+        }).min()?;\n \n     Some(\n         first_line + \"\\n\" + &trimmed_lines\n@@ -1132,8 +1131,7 @@ fn indent_macro_snippet(\n                     }\n                     None => String::new(),\n                 },\n-            )\n-            .collect::<Vec<_>>()\n+            ).collect::<Vec<_>>()\n             .join(\"\\n\"),\n     )\n }\n@@ -1296,8 +1294,7 @@ impl MacroBranch {\n                     }\n                     (s + l + \"\\n\", !kind.is_string() || l.ends_with('\\\\'))\n                 },\n-            )\n-            .0;\n+            ).0;\n \n         // Undo our replacement of macro variables.\n         // FIXME: this could be *much* more efficient."}, {"sha": "17b869750226c05967892dea4304edb7005d267d", "filename": "src/pairs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fpairs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fpairs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpairs.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -125,7 +125,7 @@ fn rewrite_pairs_multiline<T: Rewrite>(\n         IndentStyle::Visual => shape.visual_indent(0),\n         IndentStyle::Block => shape.block_indent(context.config.tab_spaces()),\n     }).with_max_width(&context.config)\n-        .sub_width(rhs_offset)?;\n+    .sub_width(rhs_offset)?;\n \n     let indent_str = nested_shape.indent.to_string_with_newline(context.config);\n     let mut result = String::new();"}, {"sha": "48ddd116337993e4f3608b6233dbecc15365c5b8", "filename": "src/reorder.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -151,8 +151,7 @@ fn rewrite_reorderable_items(\n                 .map(|use_tree| ListItem {\n                     item: use_tree.rewrite_top_level(context, nested_shape),\n                     ..use_tree.list_item.unwrap_or_else(ListItem::empty)\n-                })\n-                .collect();\n+                }).collect();\n \n             wrap_reorderable_items(context, &item_vec, nested_shape)\n         }\n@@ -249,8 +248,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                         last = current;\n                         in_same_group\n                     })\n-            })\n-            .count();\n+            }).count();\n         let items = &items[..item_length];\n \n         let at_least_one_in_file_lines = items"}, {"sha": "2a331eec19aef4a651b72a9b1d2fb147a7332f44", "filename": "src/rustfmt_diff.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Frustfmt_diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Frustfmt_diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustfmt_diff.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -193,13 +193,15 @@ where\n     W: Write,\n {\n     for mismatch in diff {\n-        let (num_removed, num_added) = mismatch.lines.iter().fold((0, 0), |(rem, add), line| {\n-            match *line {\n-                DiffLine::Context(_) => panic!(\"No Context expected\"),\n-                DiffLine::Expected(_) => (rem, add + 1),\n-                DiffLine::Resulting(_) => (rem + 1, add),\n-            }\n-        });\n+        let (num_removed, num_added) =\n+            mismatch\n+                .lines\n+                .iter()\n+                .fold((0, 0), |(rem, add), line| match *line {\n+                    DiffLine::Context(_) => panic!(\"No Context expected\"),\n+                    DiffLine::Expected(_) => (rem, add + 1),\n+                    DiffLine::Resulting(_) => (rem + 1, add),\n+                });\n         // Write a header with enough information to separate the modified lines.\n         writeln!(\n             out,"}, {"sha": "12a911a19315a583d9a62e733758567725cf7ad9", "filename": "src/shape.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshape.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -274,6 +274,12 @@ impl Shape {\n         );\n         Shape { width, ..*self }\n     }\n+\n+    pub fn to_string_with_newline(&self, config: &Config) -> Cow<'static, str> {\n+        let mut offset_indent = self.indent;\n+        offset_indent.alignment = self.offset;\n+        offset_indent.to_string_inner(config, 0)\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "ba4607be37ce34532a45f3379ec666c632e06a4e", "filename": "src/test/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -514,8 +514,7 @@ fn read_significant_comments(file_name: &Path) -> HashMap<String, String> {\n                         .to_owned(),\n                 )\n             })\n-        })\n-        .collect()\n+        }).collect()\n }\n \n // Compare output to input.\n@@ -884,8 +883,8 @@ fn configuration_snippet_tests() {\n             fs::File::open(Path::new(CONFIGURATIONS_FILE_NAME))\n                 .expect(&format!(\"Couldn't read file {}\", CONFIGURATIONS_FILE_NAME)),\n         ).lines()\n-            .map(|l| l.unwrap())\n-            .enumerate();\n+        .map(|l| l.unwrap())\n+        .enumerate();\n         let mut code_blocks: Vec<ConfigCodeBlock> = Vec::new();\n         let mut hash_set = Config::hash_set();\n \n@@ -961,5 +960,5 @@ fn verify_check_works() {\n         \"--check\",\n         temp_file.path.to_str().unwrap(),\n     ]).succeeds()\n-        .unwrap();\n+    .unwrap();\n }"}, {"sha": "d6e4001eacfcb5aaef4c010874f07b53890702ec", "filename": "src/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -548,7 +548,8 @@ impl Rewrite for ast::GenericParam {\n             };\n             result.push_str(eq_str);\n             let budget = shape.width.checked_sub(result.len())?;\n-            let rewrite = def.rewrite(context, Shape::legacy(budget, shape.indent + result.len()))?;\n+            let rewrite =\n+                def.rewrite(context, Shape::legacy(budget, shape.indent + result.len()))?;\n             result.push_str(&rewrite);\n         }\n \n@@ -793,8 +794,7 @@ fn rewrite_lifetime_param(\n         .filter(|p| match p.kind {\n             ast::GenericParamKind::Lifetime => true,\n             _ => false,\n-        })\n-        .map(|lt| lt.rewrite(context, shape))\n+        }).map(|lt| lt.rewrite(context, shape))\n         .collect::<Option<Vec<_>>>()?\n         .join(\", \");\n     if result.is_empty() {"}, {"sha": "b8474792cd3040117398a402512288736d5e97be", "filename": "src/utils.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -382,6 +382,7 @@ pub fn colon_spaces(before: bool, after: bool) -> &'static str {\n     }\n }\n \n+#[inline]\n pub fn left_most_sub_expr(e: &ast::Expr) -> &ast::Expr {\n     match e.node {\n         ast::ExprKind::Call(ref e, _)\n@@ -398,6 +399,12 @@ pub fn left_most_sub_expr(e: &ast::Expr) -> &ast::Expr {\n     }\n }\n \n+#[inline]\n pub fn starts_with_newline(s: &str) -> bool {\n     s.starts_with('\\n') || s.starts_with(\"\\r\\n\")\n }\n+\n+#[inline]\n+pub fn first_line_ends_with(s: &str, c: char) -> bool {\n+    s.lines().next().map_or(false, |l| l.ends_with(c))\n+}"}, {"sha": "ead5719f61f887bb03ce1963ea7fdae3ce4ab3a2", "filename": "src/vertical.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -200,14 +200,12 @@ fn struct_field_prefix_max_min_width<T: AlignedItem>(\n                     Some(field_str.len())\n                 }\n             })\n-        })\n-        .fold(Some((0, ::std::usize::MAX)), |acc, len| match (acc, len) {\n+        }).fold(Some((0, ::std::usize::MAX)), |acc, len| match (acc, len) {\n             (Some((max_len, min_len)), Some(len)) => {\n                 Some((cmp::max(max_len, len), cmp::min(min_len, len)))\n             }\n             _ => None,\n-        })\n-        .unwrap_or((0, 0))\n+        }).unwrap_or((0, 0))\n }\n \n fn rewrite_aligned_items_inner<T: AlignedItem>("}, {"sha": "52a077e435f522b75c92c435eea58d28d2661b42", "filename": "tests/source/chains.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Fsource%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Fsource%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -228,3 +228,34 @@ fn issue2415() {\n     })()\n         .unwrap_or_else(|_: Box<::std::error::Error>| String::from(\"\"));\n }\n+\n+impl issue_2786 {\n+    fn thing(&self) {\n+        foo(|a| {\n+            println!(\"a\");\n+            println!(\"b\");\n+        }).bar(|c| {\n+            println!(\"a\");\n+            println!(\"b\");\n+        })\n+            .baz(|c| {\n+                println!(\"a\");\n+                println!(\"b\");\n+            })\n+    }\n+}\n+\n+fn issue_2773() {\n+    let bar = Some(0);\n+    bar.or_else(|| {\n+        // do stuff\n+        None\n+    }).or_else(|| {\n+            // do other stuff\n+            None\n+        })\n+        .and_then(|val| {\n+            // do this stuff\n+            None\n+        });\n+}"}, {"sha": "ab49096e55ab8d52a4d501e95ff08673055063ab", "filename": "tests/target/chains-visual.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fchains-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fchains-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-visual.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -15,16 +15,16 @@ fn main() {\n     // Test case where first chain element isn't a path, but is shorter than\n     // the size of a tab.\n     x().y(|| match cond() {\n-        true => (),\n-        false => (),\n-    });\n+           true => (),\n+           false => (),\n+       });\n \n     loong_func().quux(move || if true { 1 } else { 2 });\n \n     some_fuuuuuuuuunction().method_call_a(aaaaa, bbbbb, |c| {\n-        let x = c;\n-        x\n-    });\n+                               let x = c;\n+                               x\n+                           });\n \n     some_fuuuuuuuuunction().method_call_a(aaaaa, bbbbb, |c| {\n                                let x = c;\n@@ -59,7 +59,7 @@ fn floaters() {\n \n     let x = Foo { field1: val1,\n                   field2: val2, }.method_call()\n-            .method_call();\n+                                 .method_call();\n \n     let y = if cond { val1 } else { val2 }.method_call();\n \n@@ -80,7 +80,7 @@ fn floaters() {\n     } else {\n         none();\n     }.bar()\n-    .baz();\n+     .baz();\n \n     Foo { x: val }.baz(|| {\n                            force();\n@@ -90,10 +90,10 @@ fn floaters() {\n \n     Foo { y: i_am_multi_line,\n           z: ok, }.baz(|| {\n-             force();\n-             multiline();\n-         })\n-    .quux();\n+                           force();\n+                           multiline();\n+                       })\n+                  .quux();\n \n     a + match x {\n             true => \"yay!\",\n@@ -137,9 +137,9 @@ fn issue1434() {\n     for _ in 0..100 {\n         let prototype_id =\n             PrototypeIdData::from_reader::<_, B>(&mut self.file_cursor).chain_err(|| {\n-                format!(\"could not read prototype ID at offset {:#010x}\",\n-                        current_offset)\n-            })?;\n+                           format!(\"could not read prototype ID at offset {:#010x}\",\n+                                   current_offset)\n+                       })?;\n     }\n }\n "}, {"sha": "2d945e3c390d04e04d0947319fe41bfda1a3d168", "filename": "tests/target/chains.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -38,8 +38,7 @@ fn main() {\n         .method_call_a(aaaaa, bbbbb, |c| {\n             let x = c;\n             x\n-        })\n-        .method_call_b(aaaaa, bbbbb, |c| {\n+        }).method_call_b(aaaaa, bbbbb, |c| {\n             let x = c;\n             x\n         });\n@@ -65,8 +64,7 @@ fn main() {\n         .map(|x| {\n             x += 1;\n             x\n-        })\n-        .filter(some_mod::some_filter)\n+        }).filter(some_mod::some_filter)\n }\n \n fn floaters() {\n@@ -79,7 +77,7 @@ fn floaters() {\n         field1: val1,\n         field2: val2,\n     }.method_call()\n-        .method_call();\n+    .method_call();\n \n     let y = if cond {\n         val1\n@@ -106,24 +104,22 @@ fn floaters() {\n     } else {\n         none();\n     }.bar()\n-        .baz();\n+    .baz();\n \n     Foo {\n         x: val,\n     }.baz(|| {\n         force();\n         multiline();\n-    })\n-        .quux();\n+    }).quux();\n \n     Foo {\n         y: i_am_multi_line,\n         z: ok,\n     }.baz(|| {\n         force();\n         multiline();\n-    })\n-        .quux();\n+    }).quux();\n \n     a + match x {\n         true => \"yay!\",\n@@ -238,8 +234,7 @@ impl Foo {\n                         }\n                     }\n                 })\n-            })\n-            .collect();\n+            }).collect();\n     }\n }\n \n@@ -255,3 +250,32 @@ fn issue2415() {\n         })().ok_or(\"\")?)\n     })().unwrap_or_else(|_: Box<::std::error::Error>| String::from(\"\"));\n }\n+\n+impl issue_2786 {\n+    fn thing(&self) {\n+        foo(|a| {\n+            println!(\"a\");\n+            println!(\"b\");\n+        }).bar(|c| {\n+            println!(\"a\");\n+            println!(\"b\");\n+        }).baz(|c| {\n+            println!(\"a\");\n+            println!(\"b\");\n+        })\n+    }\n+}\n+\n+fn issue_2773() {\n+    let bar = Some(0);\n+    bar.or_else(|| {\n+        // do stuff\n+        None\n+    }).or_else(|| {\n+        // do other stuff\n+        None\n+    }).and_then(|val| {\n+        // do this stuff\n+        None\n+    });\n+}"}, {"sha": "2360ccfbd2fdc96de30e8126670cf478b5e00240", "filename": "tests/target/closure.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -138,18 +138,20 @@ fn issue470() {\n     {\n         {\n             {\n-                let explicit_arg_decls = explicit_arguments.into_iter().enumerate().map(\n-                    |(index, (ty, pattern))| {\n-                        let lvalue = Lvalue::Arg(index as u32);\n-                        block = this.pattern(\n-                            block,\n-                            argument_extent,\n-                            hair::PatternRef::Hair(pattern),\n-                            &lvalue,\n-                        );\n-                        ArgDecl { ty: ty }\n-                    },\n-                );\n+                let explicit_arg_decls =\n+                    explicit_arguments\n+                        .into_iter()\n+                        .enumerate()\n+                        .map(|(index, (ty, pattern))| {\n+                            let lvalue = Lvalue::Arg(index as u32);\n+                            block = this.pattern(\n+                                block,\n+                                argument_extent,\n+                                hair::PatternRef::Hair(pattern),\n+                                &lvalue,\n+                            );\n+                            ArgDecl { ty: ty }\n+                        });\n             }\n         }\n     }\n@@ -169,8 +171,7 @@ fn issue1329() {\n         .map(|x| {\n             x += 1;\n             x\n-        })\n-        .filter\n+        }).filter\n }\n \n fn issue325() {"}, {"sha": "19a45cb9f74e5f01db0be49f311c147273ad519b", "filename": "tests/target/configs/indent_style/block_call.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fconfigs%2Findent_style%2Fblock_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fconfigs%2Findent_style%2Fblock_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs%2Findent_style%2Fblock_call.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -117,8 +117,7 @@ impl Cursor {\n                     debug_assert_eq!(n, -1);\n                     None\n                 }\n-            })\n-            .or_else(|| {\n+            }).or_else(|| {\n                 let canonical = self.canonical();\n                 if canonical != *self {\n                     canonical.num_template_args()"}, {"sha": "501ee3eaea04bcdca20ff8becfbfb3cca02c0e62", "filename": "tests/target/expr-block.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr-block.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -141,8 +141,7 @@ fn issue_1450() {\n             Relaxed,\n             Release,\n             Relaxed,\n-        )\n-        .is_ok()\n+        ).is_ok()\n     {\n         return;\n     }"}, {"sha": "1c63b105b98807858e6e7d0ce5c6f7d01db08275", "filename": "tests/target/file-lines-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Ffile-lines-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Ffile-lines-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffile-lines-1.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -5,7 +5,7 @@ fn floaters() {\n         field1: val1,\n         field2: val2,\n     }.method_call()\n-        .method_call();\n+    .method_call();\n \n     let y = if cond {\n                 val1"}, {"sha": "9aba967e29dd3cdeafe0b329207bd50ca32f0651", "filename": "tests/target/file-lines-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Ffile-lines-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Ffile-lines-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffile-lines-3.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -5,7 +5,7 @@ fn floaters() {\n         field1: val1,\n         field2: val2,\n     }.method_call()\n-        .method_call();\n+    .method_call();\n \n     let y = if cond { val1 } else { val2 }.method_call();\n "}, {"sha": "4441b140386ed0459caef777a81c50b1d3be75d9", "filename": "tests/target/issue-2759.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fissue-2759.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fissue-2759.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-2759.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -56,8 +56,8 @@ fn bar() {}\n ///                 .boxed(),\n ///         ]\n ///     }).bind(\"127.0.0.1:8080\")\n-///         .unwrap()\n-///         .run()\n+///     .unwrap()\n+///     .run()\n ///     # });\n /// }\n /// ```"}, {"sha": "ac076615f99a13b108c7cb1e049b8ea70fb554b9", "filename": "tests/target/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmacros.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -183,8 +183,7 @@ fn issue_1885() {\n             chan_select! {\n                 rx.recv() => {}\n             }\n-        })\n-        .collect::<Vec<_>>();\n+        }).collect::<Vec<_>>();\n }\n \n fn issue_1917() {"}, {"sha": "e0774ef011ca8a9e9e6a129f82a67566f7acf253", "filename": "tests/target/match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df1397ec136a91df54f09baa4957bde9597a9/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=a24df1397ec136a91df54f09baa4957bde9597a9", "patch": "@@ -381,8 +381,7 @@ fn issue1456() {\n                     .iter()\n                     .map(|node| {\n                         XPathNodeReader::new(node, &context).and_then(|r| ArtistRef::from_xml(&r))\n-                    })\n-                    .collect();\n+                    }).collect();\n                 res?\n             }\n             _ => Vec::new(),"}]}