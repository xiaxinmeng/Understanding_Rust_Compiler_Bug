{"sha": "26bd43355f839f6005910056e89b2364b7fec06a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YmQ0MzM1NWY4MzlmNjAwNTkxMDA1NmU4OWIyMzY0YjdmZWMwNmE=", "commit": {"author": {"name": "Valentin Tolmer", "email": "valentin.tolmer@gmail.com", "date": "2019-02-08T13:14:15Z"}, "committer": {"name": "Valentin Tolmer", "email": "valentin.tolmer@gmail.com", "date": "2019-02-13T12:31:11Z"}, "message": "Move the intrinsics into a submodule", "tree": {"sha": "d9dde8405351dc1aa0392291dc9a3e91cc49b710", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9dde8405351dc1aa0392291dc9a3e91cc49b710"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26bd43355f839f6005910056e89b2364b7fec06a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26bd43355f839f6005910056e89b2364b7fec06a", "html_url": "https://github.com/rust-lang/rust/commit/26bd43355f839f6005910056e89b2364b7fec06a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26bd43355f839f6005910056e89b2364b7fec06a/comments", "author": {"login": "nitnelave", "id": 796633, "node_id": "MDQ6VXNlcjc5NjYzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/796633?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nitnelave", "html_url": "https://github.com/nitnelave", "followers_url": "https://api.github.com/users/nitnelave/followers", "following_url": "https://api.github.com/users/nitnelave/following{/other_user}", "gists_url": "https://api.github.com/users/nitnelave/gists{/gist_id}", "starred_url": "https://api.github.com/users/nitnelave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nitnelave/subscriptions", "organizations_url": "https://api.github.com/users/nitnelave/orgs", "repos_url": "https://api.github.com/users/nitnelave/repos", "events_url": "https://api.github.com/users/nitnelave/events{/privacy}", "received_events_url": "https://api.github.com/users/nitnelave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nitnelave", "id": 796633, "node_id": "MDQ6VXNlcjc5NjYzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/796633?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nitnelave", "html_url": "https://github.com/nitnelave", "followers_url": "https://api.github.com/users/nitnelave/followers", "following_url": "https://api.github.com/users/nitnelave/following{/other_user}", "gists_url": "https://api.github.com/users/nitnelave/gists{/gist_id}", "starred_url": "https://api.github.com/users/nitnelave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nitnelave/subscriptions", "organizations_url": "https://api.github.com/users/nitnelave/orgs", "repos_url": "https://api.github.com/users/nitnelave/repos", "events_url": "https://api.github.com/users/nitnelave/events{/privacy}", "received_events_url": "https://api.github.com/users/nitnelave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccd23b95e5077a89a2ce35d09cbd4141ccc94f58", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd23b95e5077a89a2ce35d09cbd4141ccc94f58", "html_url": "https://github.com/rust-lang/rust/commit/ccd23b95e5077a89a2ce35d09cbd4141ccc94f58"}], "stats": {"total": 464, "additions": 249, "deletions": 215}, "files": [{"sha": "e6098b1b24cc0b9a3d6ce9b9fd3b13d4573b589c", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 249, "deletions": 215, "changes": 464, "blob_url": "https://github.com/rust-lang/rust/blob/26bd43355f839f6005910056e89b2364b7fec06a/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bd43355f839f6005910056e89b2364b7fec06a/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=26bd43355f839f6005910056e89b2364b7fec06a", "patch": "@@ -962,221 +962,6 @@ extern \"rust-intrinsic\" {\n     /// value is not necessarily valid to be used to actually access memory.\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n-    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n-    /// and destination must *not* overlap.\n-    ///\n-    /// For regions of memory which might overlap, use [`copy`] instead.\n-    ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n-    /// with the argument order swapped.\n-    ///\n-    /// [`copy`]: ./fn.copy.html\n-    /// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n-    ///\n-    /// # Safety\n-    ///\n-    /// Behavior is undefined if any of the following conditions are violated:\n-    ///\n-    /// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n-    ///\n-    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n-    ///\n-    /// * Both `src` and `dst` must be properly aligned.\n-    ///\n-    /// * The region of memory beginning at `src` with a size of `count *\n-    ///   size_of::<T>()` bytes must *not* overlap with the region of memory\n-    ///   beginning at `dst` with the same size.\n-    ///\n-    /// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n-    /// in the region beginning at `*src` and the region beginning at `*dst` can\n-    /// [violate memory safety][read-ownership].\n-    ///\n-    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n-    /// `0`, the pointers must be non-NULL and properly aligned.\n-    ///\n-    /// [`Copy`]: ../marker/trait.Copy.html\n-    /// [`read`]: ../ptr/fn.read.html\n-    /// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n-    /// [valid]: ../ptr/index.html#safety\n-    ///\n-    /// # Examples\n-    ///\n-    /// Manually implement [`Vec::append`]:\n-    ///\n-    /// ```\n-    /// use std::ptr;\n-    ///\n-    /// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n-    /// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n-    ///     let src_len = src.len();\n-    ///     let dst_len = dst.len();\n-    ///\n-    ///     // Ensure that `dst` has enough capacity to hold all of `src`.\n-    ///     dst.reserve(src_len);\n-    ///\n-    ///     unsafe {\n-    ///         // The call to offset is always safe because `Vec` will never\n-    ///         // allocate more than `isize::MAX` bytes.\n-    ///         let dst_ptr = dst.as_mut_ptr().offset(dst_len as isize);\n-    ///         let src_ptr = src.as_ptr();\n-    ///\n-    ///         // Truncate `src` without dropping its contents. We do this first,\n-    ///         // to avoid problems in case something further down panics.\n-    ///         src.set_len(0);\n-    ///\n-    ///         // The two regions cannot overlap because mutable references do\n-    ///         // not alias, and two different vectors cannot own the same\n-    ///         // memory.\n-    ///         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n-    ///\n-    ///         // Notify `dst` that it now holds the contents of `src`.\n-    ///         dst.set_len(dst_len + src_len);\n-    ///     }\n-    /// }\n-    ///\n-    /// let mut a = vec!['r'];\n-    /// let mut b = vec!['u', 's', 't'];\n-    ///\n-    /// append(&mut a, &mut b);\n-    ///\n-    /// assert_eq!(a, &['r', 'u', 's', 't']);\n-    /// assert!(b.is_empty());\n-    /// ```\n-    ///\n-    /// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n-\n-    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n-    /// and destination may overlap.\n-    ///\n-    /// If the source and destination will *never* overlap,\n-    /// [`copy_nonoverlapping`] can be used instead.\n-    ///\n-    /// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n-    /// order swapped. Copying takes place as if the bytes were copied from `src`\n-    /// to a temporary array and then copied from the array to `dst`.\n-    ///\n-    /// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n-    /// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n-    ///\n-    /// # Safety\n-    ///\n-    /// Behavior is undefined if any of the following conditions are violated:\n-    ///\n-    /// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n-    ///\n-    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n-    ///\n-    /// * Both `src` and `dst` must be properly aligned.\n-    ///\n-    /// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n-    /// in the region beginning at `*src` and the region beginning at `*dst` can\n-    /// [violate memory safety][read-ownership].\n-    ///\n-    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n-    /// `0`, the pointers must be non-NULL and properly aligned.\n-    ///\n-    /// [`Copy`]: ../marker/trait.Copy.html\n-    /// [`read`]: ../ptr/fn.read.html\n-    /// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n-    /// [valid]: ../ptr/index.html#safety\n-    ///\n-    /// # Examples\n-    ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n-    ///\n-    /// ```\n-    /// use std::ptr;\n-    ///\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n-    ///     dst\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n-\n-    /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n-    /// `val`.\n-    ///\n-    /// `write_bytes` is similar to C's [`memset`], but sets `count *\n-    /// size_of::<T>()` bytes to `val`.\n-    ///\n-    /// [`memset`]: https://en.cppreference.com/w/c/string/byte/memset\n-    ///\n-    /// # Safety\n-    ///\n-    /// Behavior is undefined if any of the following conditions are violated:\n-    ///\n-    /// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n-    ///\n-    /// * `dst` must be properly aligned.\n-    ///\n-    /// Additionally, the caller must ensure that writing `count *\n-    /// size_of::<T>()` bytes to the given region of memory results in a valid\n-    /// value of `T`. Using a region of memory typed as a `T` that contains an\n-    /// invalid value of `T` is undefined behavior.\n-    ///\n-    /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n-    /// `0`, the pointer must be non-NULL and properly aligned.\n-    ///\n-    /// [valid]: ../ptr/index.html#safety\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::ptr;\n-    ///\n-    /// let mut vec = vec![0u32; 4];\n-    /// unsafe {\n-    ///     let vec_ptr = vec.as_mut_ptr();\n-    ///     ptr::write_bytes(vec_ptr, 0xfe, 2);\n-    /// }\n-    /// assert_eq!(vec, [0xfefefefe, 0xfefefefe, 0, 0]);\n-    /// ```\n-    ///\n-    /// Creating an invalid value:\n-    ///\n-    /// ```\n-    /// use std::ptr;\n-    ///\n-    /// let mut v = Box::new(0i32);\n-    ///\n-    /// unsafe {\n-    ///     // Leaks the previously held value by overwriting the `Box<T>` with\n-    ///     // a null pointer.\n-    ///     ptr::write_bytes(&mut v as *mut Box<i32>, 0, 1);\n-    /// }\n-    ///\n-    /// // At this point, using or dropping `v` results in undefined behavior.\n-    /// // drop(v); // ERROR\n-    ///\n-    /// // Even leaking `v` \"uses\" it, and hence is undefined behavior.\n-    /// // mem::forget(v); // ERROR\n-    ///\n-    /// // In fact, `v` is invalid according to basic type layout invariants, so *any*\n-    /// // operation touching it is undefined behavior.\n-    /// // let v2 = v; // ERROR\n-    ///\n-    /// unsafe {\n-    ///     // Let us instead put in a valid value\n-    ///     ptr::write(&mut v as *mut Box<i32>, Box::new(42i32));\n-    /// }\n-    ///\n-    /// // Now the box is fine\n-    /// assert_eq!(*v, 42);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n-\n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n@@ -1524,3 +1309,252 @@ extern \"rust-intrinsic\" {\n     /// Probably will never become stable.\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n }\n+\n+mod real_intrinsics {\n+  extern \"rust-intrinsic\" {\n+    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+    /// and destination must *not* overlap.\n+    /// For the full docs, see the stabilized wrapper [`copy_nonoverlapping`].\n+    ///\n+    /// [`copy_nonoverlapping`]: ../../std/ptr/fn.copy_nonoverlapping.html\n+    pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+\n+    /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+    /// and destination may overlap.\n+    /// For the full docs, see the stabilized wrapper [`copy`].\n+    ///\n+    /// [`copy`]: ../../std/ptr/fn.copy.html\n+    pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n+\n+    /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n+    /// `val`.\n+    /// For the full docs, see the stabilized wrapper [`write_bytes`].\n+    ///\n+    /// [`write_bytes`]: ../../std/ptr/fn.write_bytes.html\n+    pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n+  }\n+}\n+\n+/// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+/// and destination must *not* overlap.\n+///\n+/// For regions of memory which might overlap, use [`copy`] instead.\n+///\n+/// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n+/// with the argument order swapped.\n+///\n+/// [`copy`]: ./fn.copy.html\n+/// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n+///\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n+///\n+/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n+///\n+/// * Both `src` and `dst` must be properly aligned.\n+///\n+/// * The region of memory beginning at `src` with a size of `count *\n+///   size_of::<T>()` bytes must *not* overlap with the region of memory\n+///   beginning at `dst` with the same size.\n+///\n+/// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n+/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n+/// in the region beginning at `*src` and the region beginning at `*dst` can\n+/// [violate memory safety][read-ownership].\n+///\n+/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+/// `0`, the pointers must be non-NULL and properly aligned.\n+///\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`read`]: ../ptr/fn.read.html\n+/// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n+/// [valid]: ../ptr/index.html#safety\n+///\n+/// # Examples\n+///\n+/// Manually implement [`Vec::append`]:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n+/// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n+///     let src_len = src.len();\n+///     let dst_len = dst.len();\n+///\n+///     // Ensure that `dst` has enough capacity to hold all of `src`.\n+///     dst.reserve(src_len);\n+///\n+///     unsafe {\n+///         // The call to offset is always safe because `Vec` will never\n+///         // allocate more than `isize::MAX` bytes.\n+///         let dst_ptr = dst.as_mut_ptr().offset(dst_len as isize);\n+///         let src_ptr = src.as_ptr();\n+///\n+///         // Truncate `src` without dropping its contents. We do this first,\n+///         // to avoid problems in case something further down panics.\n+///         src.set_len(0);\n+///\n+///         // The two regions cannot overlap because mutable references do\n+///         // not alias, and two different vectors cannot own the same\n+///         // memory.\n+///         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n+///\n+///         // Notify `dst` that it now holds the contents of `src`.\n+///         dst.set_len(dst_len + src_len);\n+///     }\n+/// }\n+///\n+/// let mut a = vec!['r'];\n+/// let mut b = vec!['u', 's', 't'];\n+///\n+/// append(&mut a, &mut b);\n+///\n+/// assert_eq!(a, &['r', 'u', 's', 't']);\n+/// assert!(b.is_empty());\n+/// ```\n+///\n+/// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[inline]\n+pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n+    real_intrinsics::copy_nonoverlapping(src, dst, count);\n+}\n+\n+/// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n+/// and destination may overlap.\n+///\n+/// If the source and destination will *never* overlap,\n+/// [`copy_nonoverlapping`] can be used instead.\n+///\n+/// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n+/// order swapped. Copying takes place as if the bytes were copied from `src`\n+/// to a temporary array and then copied from the array to `dst`.\n+///\n+/// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n+/// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n+///\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n+///\n+/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n+///\n+/// * Both `src` and `dst` must be properly aligned.\n+///\n+/// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n+/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n+/// in the region beginning at `*src` and the region beginning at `*dst` can\n+/// [violate memory safety][read-ownership].\n+///\n+/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+/// `0`, the pointers must be non-NULL and properly aligned.\n+///\n+/// [`Copy`]: ../marker/trait.Copy.html\n+/// [`read`]: ../ptr/fn.read.html\n+/// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n+/// [valid]: ../ptr/index.html#safety\n+///\n+/// # Examples\n+///\n+/// Efficiently create a Rust vector from an unsafe buffer:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// # #[allow(dead_code)]\n+/// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n+///     let mut dst = Vec::with_capacity(elts);\n+///     dst.set_len(elts);\n+///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n+///     dst\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[inline]\n+pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n+    real_intrinsics::copy(src, dst, count)\n+}\n+\n+/// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n+/// `val`.\n+///\n+/// `write_bytes` is similar to C's [`memset`], but sets `count *\n+/// size_of::<T>()` bytes to `val`.\n+///\n+/// [`memset`]: https://en.cppreference.com/w/c/string/byte/memset\n+///\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n+///\n+/// * `dst` must be properly aligned.\n+///\n+/// Additionally, the caller must ensure that writing `count *\n+/// size_of::<T>()` bytes to the given region of memory results in a valid\n+/// value of `T`. Using a region of memory typed as a `T` that contains an\n+/// invalid value of `T` is undefined behavior.\n+///\n+/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n+/// `0`, the pointer must be non-NULL and properly aligned.\n+///\n+/// [valid]: ../ptr/index.html#safety\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let mut vec = vec![0u32; 4];\n+/// unsafe {\n+///     let vec_ptr = vec.as_mut_ptr();\n+///     ptr::write_bytes(vec_ptr, 0xfe, 2);\n+/// }\n+/// assert_eq!(vec, [0xfefefefe, 0xfefefefe, 0, 0]);\n+/// ```\n+///\n+/// Creating an invalid value:\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let mut v = Box::new(0i32);\n+///\n+/// unsafe {\n+///     // Leaks the previously held value by overwriting the `Box<T>` with\n+///     // a null pointer.\n+///     ptr::write_bytes(&mut v as *mut Box<i32>, 0, 1);\n+/// }\n+///\n+/// // At this point, using or dropping `v` results in undefined behavior.\n+/// // drop(v); // ERROR\n+///\n+/// // Even leaking `v` \"uses\" it, and hence is undefined behavior.\n+/// // mem::forget(v); // ERROR\n+///\n+/// // In fact, `v` is invalid according to basic type layout invariants, so *any*\n+/// // operation touching it is undefined behavior.\n+/// // let v2 = v; // ERROR\n+///\n+/// unsafe {\n+///     // Let us instead put in a valid value\n+///     ptr::write(&mut v as *mut Box<i32>, Box::new(42i32));\n+/// }\n+///\n+/// // Now the box is fine\n+/// assert_eq!(*v, 42);\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[inline]\n+pub unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n+    real_intrinsics::write_bytes(dst, val, count)\n+}"}]}