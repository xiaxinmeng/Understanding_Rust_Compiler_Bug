{"sha": "066be2a72d22d8512aea3d8a4d7601a64d6e7ad4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NmJlMmE3MmQyMmQ4NTEyYWVhM2Q4YTRkNzYwMWE2NGQ2ZTdhZDQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-30T00:36:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-30T00:36:32Z"}, "message": "rollup merge of #20266: nick29581/dxr-use\n\nr? @huonw", "tree": {"sha": "ddeb44849e7de1c1bc0572e9f4e501e2b2d1d72a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddeb44849e7de1c1bc0572e9f4e501e2b2d1d72a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/066be2a72d22d8512aea3d8a4d7601a64d6e7ad4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/066be2a72d22d8512aea3d8a4d7601a64d6e7ad4", "html_url": "https://github.com/rust-lang/rust/commit/066be2a72d22d8512aea3d8a4d7601a64d6e7ad4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/066be2a72d22d8512aea3d8a4d7601a64d6e7ad4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1dec37561972c3e9e4026a8339722ebbef7384f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1dec37561972c3e9e4026a8339722ebbef7384f", "html_url": "https://github.com/rust-lang/rust/commit/b1dec37561972c3e9e4026a8339722ebbef7384f"}, {"sha": "4c4eabfd6c7e39e2b01851af2e58d38d898aac39", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c4eabfd6c7e39e2b01851af2e58d38d898aac39", "html_url": "https://github.com/rust-lang/rust/commit/4c4eabfd6c7e39e2b01851af2e58d38d898aac39"}], "stats": {"total": 133, "additions": 70, "deletions": 63}, "files": [{"sha": "51ea0af8e10eaa3ccccdfed1883069cf6c16bebc", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 63, "deletions": 57, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/066be2a72d22d8512aea3d8a4d7601a64d6e7ad4/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066be2a72d22d8512aea3d8a4d7601a64d6e7ad4/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=066be2a72d22d8512aea3d8a4d7601a64d6e7ad4", "patch": "@@ -636,7 +636,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         item.id);\n \n                     for field in struct_def.fields.iter() {\n-                        self.process_struct_field_def(field, enum_name[], variant.node.id);\n+                        self.process_struct_field_def(field, qualname[], variant.node.id);\n                         self.visit_ty(&*field.node.ty);\n                     }\n                 }\n@@ -763,37 +763,38 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     fn process_path(&mut self,\n-                    ex: &ast::Expr,\n-                    path: &ast::Path) {\n+                    id: NodeId,\n+                    span: Span,\n+                    path: &ast::Path,\n+                    ref_kind: Option<recorder::Row>) {\n         if generated_code(path.span) {\n             return\n         }\n \n         let def_map = self.analysis.ty_cx.def_map.borrow();\n-        if !def_map.contains_key(&ex.id) {\n-            self.sess.span_bug(ex.span,\n-                               format!(\"def_map has no key for {} in visit_expr\",\n-                                       ex.id)[]);\n+        if !def_map.contains_key(&id) {\n+            self.sess.span_bug(span,\n+                               format!(\"def_map has no key for {} in visit_expr\", id)[]);\n         }\n-        let def = &(*def_map)[ex.id];\n-        let sub_span = self.span.span_for_last_ident(ex.span);\n+        let def = &(*def_map)[id];\n+        let sub_span = self.span.span_for_last_ident(span);\n         match *def {\n             def::DefUpvar(..) |\n             def::DefLocal(..) |\n             def::DefStatic(..) |\n             def::DefConst(..) |\n-            def::DefVariant(..) => self.fmt.ref_str(recorder::VarRef,\n-                                                    ex.span,\n+            def::DefVariant(..) => self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n+                                                    span,\n                                                     sub_span,\n                                                     def.def_id(),\n                                                     self.cur_scope),\n             def::DefStruct(def_id) => self.fmt.ref_str(recorder::StructRef,\n-                                                       ex.span,\n+                                                       span,\n                                                        sub_span,\n                                                        def_id,\n-                                                        self.cur_scope),\n+                                                       self.cur_scope),\n             def::DefStaticMethod(declid, provenence) => {\n-                let sub_span = self.span.sub_span_for_meth_name(ex.span);\n+                let sub_span = self.span.sub_span_for_meth_name(span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n                     let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n                                                     declid);\n@@ -828,34 +829,31 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 } else {\n                     None\n                 };\n-                self.fmt.meth_call_str(ex.span,\n+                self.fmt.meth_call_str(span,\n                                        sub_span,\n                                        defid,\n                                        Some(declid),\n                                        self.cur_scope);\n             },\n-            def::DefFn(def_id, _) => self.fmt.fn_call_str(ex.span,\n-                                                             sub_span,\n-                                                             def_id,\n-                                                             self.cur_scope),\n-            _ => self.sess.span_bug(ex.span,\n+            def::DefFn(def_id, _) => self.fmt.fn_call_str(span,\n+                                                          sub_span,\n+                                                          def_id,\n+                                                          self.cur_scope),\n+            _ => self.sess.span_bug(span,\n                                     format!(\"Unexpected def kind while looking up path in '{}'\",\n-                                            self.span.snippet(ex.span))[]),\n+                                            self.span.snippet(span))[]),\n         }\n         // modules or types in the path prefix\n         match *def {\n-            def::DefStaticMethod(..) => {\n-                self.write_sub_path_trait_truncated(path);\n-            },\n+            def::DefStaticMethod(..) => self.write_sub_path_trait_truncated(path),\n             def::DefLocal(_) |\n             def::DefStatic(_,_) |\n             def::DefConst(..) |\n             def::DefStruct(_) |\n+            def::DefVariant(..) |\n             def::DefFn(..) => self.write_sub_paths_truncated(path),\n             _ => {},\n         }\n-\n-        visit::walk_path(self, path);\n     }\n \n     fn process_struct_lit(&mut self,\n@@ -982,18 +980,19 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     }\n                 };\n                 for &Spanned { node: ref field, span } in fields.iter() {\n-                    self.visit_pat(&*field.pat);\n+                    let sub_span = self.span.span_for_first_ident(span);\n                     let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, struct_def);\n                     for f in fields.iter() {\n                         if f.name == field.ident.name {\n                             self.fmt.ref_str(recorder::VarRef,\n-                                             p.span,\n-                                             Some(span),\n+                                             span,\n+                                             sub_span,\n                                              f.id,\n                                              self.cur_scope);\n                             break;\n                         }\n                     }\n+                    self.visit_pat(&*field.pat);\n                 }\n             }\n             ast::PatEnum(ref path, _) => {\n@@ -1162,8 +1161,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match i.node {\n-            ast::ViewItemUse(ref path) => {\n-                match path.node {\n+            ast::ViewItemUse(ref item) => {\n+                match item.node {\n                     ast::ViewPathSimple(ident, ref path, id) => {\n                         let sub_span = self.span.span_for_last_ident(path.span);\n                         let mod_id = match self.lookup_type_ref(id) {\n@@ -1184,7 +1183,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         // 'use' always introduces an alias, if there is not an explicit\n                         // one, there is an implicit one.\n                         let sub_span =\n-                            match self.span.sub_span_before_token(path.span, token::Eq) {\n+                            match self.span.sub_span_after_keyword(item.span, keywords::As) {\n                                 Some(sub_span) => Some(sub_span),\n                                 None => sub_span,\n                             };\n@@ -1308,7 +1307,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 // because just walking the callee path does what we want.\n                 visit::walk_expr(self, ex);\n             },\n-            ast::ExprPath(ref path) => self.process_path(ex, path),\n+            ast::ExprPath(ref path) => {\n+                self.process_path(ex.id, ex.span, path, None);\n+                visit::walk_path(self, path);\n+            }\n             ast::ExprStruct(ref path, ref fields, ref base) =>\n                 self.process_struct_lit(ex, path, fields, base),\n             ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n@@ -1405,46 +1407,50 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n     fn visit_arm(&mut self, arm: &ast::Arm) {\n         assert!(self.collected_paths.len() == 0 && !self.collecting);\n         self.collecting = true;\n-\n         for pattern in arm.pats.iter() {\n             // collect paths from the arm's patterns\n             self.visit_pat(&**pattern);\n         }\n-        self.collecting = false;\n+\n+        // This is to get around borrow checking, because we need mut self to call process_path.\n+        let mut paths_to_process = vec![];\n         // process collected paths\n         for &(id, ref p, ref immut, ref_kind) in self.collected_paths.iter() {\n-            let value = if *immut {\n-                self.span.snippet(p.span).to_string()\n-            } else {\n-                \"<mutable>\".to_string()\n-            };\n-            let sub_span = self.span.span_for_first_ident(p.span);\n             let def_map = self.analysis.ty_cx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n-                                   format!(\"def_map has no key for {} in visit_arm\",\n-                                           id)[]);\n+                                   format!(\"def_map has no key for {} in visit_arm\", id)[]);\n             }\n             let def = &(*def_map)[id];\n             match *def {\n-                def::DefLocal(id)  => self.fmt.variable_str(p.span,\n-                                                            sub_span,\n-                                                            id,\n-                                                            path_to_string(p)[],\n-                                                            value[],\n-                                                            \"\"),\n-                def::DefVariant(_,id,_) => self.fmt.ref_str(ref_kind,\n-                                                            p.span,\n-                                                            sub_span,\n-                                                            id,\n-                                                            self.cur_scope),\n-                // FIXME(nrc) what is this doing here?\n+                def::DefLocal(id)  => {\n+                    let value = if *immut {\n+                        self.span.snippet(p.span).to_string()\n+                    } else {\n+                        \"<mutable>\".to_string()\n+                    };\n+\n+                    assert!(p.segments.len() == 1, \"qualified path for local variable def in arm\");\n+                    self.fmt.variable_str(p.span,\n+                                          Some(p.span),\n+                                          id,\n+                                          path_to_string(p)[],\n+                                          value[],\n+                                          \"\")\n+                }\n+                def::DefVariant(..) => {\n+                    paths_to_process.push((id, p.span, p.clone(), Some(ref_kind)))\n+                }\n+                // FIXME(nrc) what are these doing here?\n                 def::DefStatic(_, _) => {}\n                 def::DefConst(..) => {}\n-                _ => error!(\"unexpected definition kind when processing collected paths: {}\",\n-                            *def)\n+                _ => error!(\"unexpected definition kind when processing collected paths: {}\", *def)\n             }\n         }\n+        for &(id, span, ref path, ref_kind) in paths_to_process.iter() {\n+            self.process_path(id, span, path, ref_kind);\n+        }\n+        self.collecting = false;\n         self.collected_paths.clear();\n         visit::walk_expr_opt(self, &arm.guard);\n         self.visit_expr(&*arm.body);"}, {"sha": "f62073e54e6d963e4345d811c0d4c1dc060e4191", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/066be2a72d22d8512aea3d8a4d7601a64d6e7ad4/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066be2a72d22d8512aea3d8a4d7601a64d6e7ad4/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=066be2a72d22d8512aea3d8a4d7601a64d6e7ad4", "patch": "@@ -61,7 +61,7 @@ macro_rules! svec {\n     })\n }\n \n-#[deriving(Copy)]\n+#[deriving(Copy,Show)]\n pub enum Row {\n     Variable,\n     Enum,"}, {"sha": "244d0476832bdb7545699a8cc436dd1ca03cdb64", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/066be2a72d22d8512aea3d8a4d7601a64d6e7ad4/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066be2a72d22d8512aea3d8a4d7601a64d6e7ad4/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=066be2a72d22d8512aea3d8a4d7601a64d6e7ad4", "patch": "@@ -294,8 +294,8 @@ impl<'a> SpanUtils<'a> {\n     }\n \n     pub fn sub_span_after_keyword(&self,\n-                              span: Span,\n-                              keyword: keywords::Keyword) -> Option<Span> {\n+                                  span: Span,\n+                                  keyword: keywords::Keyword) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {\n             let ts = toks.real_token();"}, {"sha": "e88aabb044cc66a9296294b7deb4a1ac14869908", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/066be2a72d22d8512aea3d8a4d7601a64d6e7ad4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066be2a72d22d8512aea3d8a4d7601a64d6e7ad4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=066be2a72d22d8512aea3d8a4d7601a64d6e7ad4", "patch": "@@ -5977,7 +5977,7 @@ impl<'a> Parser<'a> {\n     }\n \n \n-    /// Matches view_path : MOD? IDENT EQ non_global_path\n+    /// Matches view_path : MOD? non_global_path as IDENT\n     /// | MOD? non_global_path MOD_SEP LBRACE RBRACE\n     /// | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n     /// | MOD? non_global_path MOD_SEP STAR\n@@ -6089,7 +6089,7 @@ impl<'a> Parser<'a> {\n         }\n         let mut rename_to = path[path.len() - 1u];\n         let path = ast::Path {\n-            span: mk_sp(lo, self.span.hi),\n+            span: mk_sp(lo, self.last_span.hi),\n             global: false,\n             segments: path.into_iter().map(|identifier| {\n                 ast::PathSegment {\n@@ -6101,7 +6101,8 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::As) {\n             rename_to = self.parse_ident()\n         }\n-        P(spanned(lo, self.last_span.hi,\n+        P(spanned(lo,\n+                  self.last_span.hi,\n                   ViewPathSimple(rename_to, path, ast::DUMMY_NODE_ID)))\n     }\n "}]}