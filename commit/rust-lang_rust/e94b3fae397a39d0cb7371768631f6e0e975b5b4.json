{"sha": "e94b3fae397a39d0cb7371768631f6e0e975b5b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NGIzZmFlMzk3YTM5ZDBjYjczNzE3Njg2MzFmNmUwZTk3NWI1YjQ=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-09-25T23:18:50Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-09-26T02:44:36Z"}, "message": "Moved StrSlice doc comments from impl to trait.\nMoved OwnedStr doc comments from impl to trait.\nAdded a few #[inline] hints.\n\nThe doc comment changes make the source a bit harder to read, as\ndocumentation and implementation no longer live right next to each\nother. But this way they at least appear in the docs.", "tree": {"sha": "d827297fa095f3e0e03dab1ca8aa192e2f6c72bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d827297fa095f3e0e03dab1ca8aa192e2f6c72bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e94b3fae397a39d0cb7371768631f6e0e975b5b4", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e94b3fae397a39d0cb7371768631f6e0e975b5b4", "html_url": "https://github.com/rust-lang/rust/commit/e94b3fae397a39d0cb7371768631f6e0e975b5b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e94b3fae397a39d0cb7371768631f6e0e975b5b4/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41826c48eddfb964b830229dff6f0480ac649827", "url": "https://api.github.com/repos/rust-lang/rust/commits/41826c48eddfb964b830229dff6f0480ac649827", "html_url": "https://github.com/rust-lang/rust/commit/41826c48eddfb964b830229dff6f0480ac649827"}], "stats": {"total": 990, "additions": 532, "deletions": 458}, "files": [{"sha": "9562346c70d8a12d37757f5a1a3cc757d5565b6b", "filename": "src/libstd/str.rs", "status": "modified", "additions": 532, "deletions": 458, "changes": 990, "blob_url": "https://github.com/rust-lang/rust/blob/e94b3fae397a39d0cb7371768631f6e0e975b5b4/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e94b3fae397a39d0cb7371768631f6e0e975b5b4/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=e94b3fae397a39d0cb7371768631f6e0e975b5b4", "patch": "@@ -246,14 +246,16 @@ pub fn push_str(lhs: &mut ~str, rhs: &str) {\n     lhs.push_str(rhs)\n }\n \n-#[allow(missing_doc)]\n+/// Methods for vectors of strings\n pub trait StrVector {\n+    /// Concatenate a vector of strings.\n     fn concat(&self) -> ~str;\n+\n+    /// Concatenate a vector of strings, placing a given separator between each.\n     fn connect(&self, sep: &str) -> ~str;\n }\n \n impl<'self, S: Str> StrVector for &'self [S] {\n-    /// Concatenate a vector of strings.\n     fn concat(&self) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n@@ -268,7 +270,6 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         result\n     }\n \n-    /// Concatenate a vector of strings, placing a given separator between each.\n     fn connect(&self, sep: &str) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n@@ -990,9 +991,15 @@ pub fn utf8_char_width(b: u8) -> uint {\n     return UTF8_CHAR_WIDTH[b] as uint;\n }\n \n-#[allow(missing_doc)]\n+/// Struct that contains a `char` and\n+/// the index of the first byte of the next `char` in a string.\n+/// This is being used as a datastructure for iterating over\n+/// the utf8 bytes of a string.\n pub struct CharRange {\n+    /// Current `char`\n     ch: char,\n+\n+    /// Index of the first byte of the next `char`\n     next: uint\n }\n \n@@ -1417,96 +1424,21 @@ impl Mutable for ~str {\n     }\n }\n \n-#[allow(missing_doc)]\n+/// Methods for string slices\n pub trait StrSlice<'self> {\n-    fn contains<'a>(&self, needle: &'a str) -> bool;\n-    fn contains_char(&self, needle: char) -> bool;\n-    fn iter(&self) -> CharIterator<'self>;\n-    fn rev_iter(&self) -> CharRevIterator<'self>;\n-    fn byte_iter(&self) -> ByteIterator<'self>;\n-    fn byte_rev_iter(&self) -> ByteRevIterator<'self>;\n-    fn char_offset_iter(&self) -> CharOffsetIterator<'self>;\n-    fn char_offset_rev_iter(&self) -> CharOffsetRevIterator<'self>;\n-    fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n-    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n-    fn split_terminator_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n-    fn rsplit_iter<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep>;\n-    fn rsplitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n-    fn matches_index_iter(&self, sep: &'self str) -> MatchesIndexIterator<'self>;\n-    fn split_str_iter(&self, &'self str) -> StrSplitIterator<'self>;\n-    fn line_iter(&self) -> CharSplitIterator<'self, char>;\n-    fn any_line_iter(&self) -> AnyLineIterator<'self>;\n-    fn word_iter(&self) -> WordIterator<'self>;\n-    fn nfd_iter(&self) -> NormalizationIterator<'self>;\n-    fn nfkd_iter(&self) -> NormalizationIterator<'self>;\n-    fn ends_with(&self, needle: &str) -> bool;\n-    fn is_whitespace(&self) -> bool;\n-    fn is_alphanumeric(&self) -> bool;\n-    fn char_len(&self) -> uint;\n-\n-    fn slice(&self, begin: uint, end: uint) -> &'self str;\n-    fn slice_from(&self, begin: uint) -> &'self str;\n-    fn slice_to(&self, end: uint) -> &'self str;\n-\n-    fn slice_chars(&self, begin: uint, end: uint) -> &'self str;\n-\n-    fn starts_with(&self, needle: &str) -> bool;\n-    fn escape_default(&self) -> ~str;\n-    fn escape_unicode(&self) -> ~str;\n-    fn trim(&self) -> &'self str;\n-    fn trim_left(&self) -> &'self str;\n-    fn trim_right(&self) -> &'self str;\n-    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n-    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n-    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n-    fn replace(&self, from: &str, to: &str) -> ~str;\n-    fn to_owned(&self) -> ~str;\n-    fn to_managed(&self) -> @str;\n-    fn to_utf16(&self) -> ~[u16];\n-    fn to_send_str(&self) -> SendStr;\n-    fn is_char_boundary(&self, index: uint) -> bool;\n-    fn char_range_at(&self, start: uint) -> CharRange;\n-    fn char_at(&self, i: uint) -> char;\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange;\n-    fn char_at_reverse(&self, i: uint) -> char;\n-    fn as_bytes(&self) -> &'self [u8];\n-\n-    fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n-    fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n-    fn find_str(&self, &str) -> Option<uint>;\n-\n-    fn repeat(&self, nn: uint) -> ~str;\n-\n-    fn slice_shift_char(&self) -> (char, &'self str);\n-\n-    fn lev_distance(&self, t: &str) -> uint;\n-\n-    fn subslice_offset(&self, inner: &str) -> uint;\n-\n-    fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T;\n-}\n-\n-/// Extension methods for strings\n-impl<'self> StrSlice<'self> for &'self str {\n     /// Returns true if one string contains another\n     ///\n     /// # Arguments\n     ///\n-    /// * needle - The string to look for\n-    #[inline]\n-    fn contains<'a>(&self, needle: &'a str) -> bool {\n-        self.find_str(needle).is_some()\n-    }\n+    /// - needle - The string to look for\n+    fn contains<'a>(&self, needle: &'a str) -> bool;\n \n     /// Returns true if a string contains a char.\n     ///\n     /// # Arguments\n     ///\n-    /// * needle - The char to look for\n-    #[inline]\n-    fn contains_char(&self, needle: char) -> bool {\n-        self.find(needle).is_some()\n-    }\n+    /// - needle - The char to look for\n+    fn contains_char(&self, needle: char) -> bool;\n \n     /// An iterator over the characters of `self`. Note, this iterates\n     /// over unicode code-points, not unicode graphemes.\n@@ -1517,41 +1449,23 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".iter().collect();\n     /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n-    #[inline]\n-    fn iter(&self) -> CharIterator<'self> {\n-        CharIterator{string: *self}\n-    }\n+    fn iter(&self) -> CharIterator<'self>;\n \n     /// An iterator over the characters of `self`, in reverse order.\n-    #[inline]\n-    fn rev_iter(&self) -> CharRevIterator<'self> {\n-        self.iter().invert()\n-    }\n+    fn rev_iter(&self) -> CharRevIterator<'self>;\n \n     /// An iterator over the bytes of `self`\n-    #[inline]\n-    fn byte_iter(&self) -> ByteIterator<'self> {\n-        self.as_bytes().iter().map(|&b| b)\n-    }\n+    fn byte_iter(&self) -> ByteIterator<'self>;\n \n     /// An iterator over the bytes of `self`, in reverse order\n-    #[inline]\n-    fn byte_rev_iter(&self) -> ByteRevIterator<'self> {\n-        self.byte_iter().invert()\n-    }\n+    fn byte_rev_iter(&self) -> ByteRevIterator<'self>;\n \n     /// An iterator over the characters of `self` and their byte offsets.\n-    #[inline]\n-    fn char_offset_iter(&self) -> CharOffsetIterator<'self> {\n-        CharOffsetIterator{string: *self, iter: self.iter()}\n-    }\n+    fn char_offset_iter(&self) -> CharOffsetIterator<'self>;\n \n     /// An iterator over the characters of `self` and their byte offsets,\n     /// in reverse order.\n-    #[inline]\n-    fn char_offset_rev_iter(&self) -> CharOffsetRevIterator<'self> {\n-        self.char_offset_iter().invert()\n-    }\n+    fn char_offset_rev_iter(&self) -> CharOffsetRevIterator<'self>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n@@ -1565,29 +1479,12 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// let v: ~[&str] = \"abc1def2ghi\".split_iter(|c: char| c.is_digit()).collect();\n     /// assert_eq!(v, ~[\"abc\", \"def\", \"ghi\"]);\n     /// ```\n-    #[inline]\n-    fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep> {\n-        CharSplitIterator {\n-            string: *self,\n-            only_ascii: sep.only_ascii(),\n-            sep: sep,\n-            allow_trailing_empty: true,\n-            finished: false,\n-        }\n-    }\n+    fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, restricted to splitting at most `count`\n     /// times.\n-    #[inline]\n-    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint)\n-        -> CharSplitNIterator<'self, Sep> {\n-        CharSplitNIterator {\n-            iter: self.split_iter(sep),\n-            count: count,\n-            invert: false,\n-        }\n-    }\n+    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n@@ -1601,14 +1498,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// let v: ~[&str] = \"A.B.\".split_terminator_iter('.').collect();\n     /// assert_eq!(v, ~[\"A\", \"B\"]);\n     /// ```\n-    #[inline]\n-    fn split_terminator_iter<Sep: CharEq>(&self, sep: Sep)\n-        -> CharSplitIterator<'self, Sep> {\n-        CharSplitIterator {\n-            allow_trailing_empty: false,\n-            ..self.split_iter(sep)\n-        }\n-    }\n+    fn split_terminator_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, in reverse order\n@@ -1619,37 +1509,16 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// let v: ~[&str] = \"Mary had a little lamb\".rsplit_iter(' ').collect();\n     /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     /// ```\n-    #[inline]\n-    fn rsplit_iter<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep> {\n-        self.split_iter(sep).invert()\n-    }\n+    fn rsplit_iter<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, starting from the end of the string.\n     /// Restricted to splitting at most `count` times.\n-    #[inline]\n-    fn rsplitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint)\n-        -> CharSplitNIterator<'self, Sep> {\n-        CharSplitNIterator {\n-            iter: self.split_iter(sep),\n-            count: count,\n-            invert: true,\n-        }\n-    }\n-\n-\n+    fn rsplitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n \n     /// An iterator over the start and end indices of each match of\n     /// `sep` within `self`.\n-    #[inline]\n-    fn matches_index_iter(&self, sep: &'self str) -> MatchesIndexIterator<'self> {\n-        assert!(!sep.is_empty())\n-        MatchesIndexIterator {\n-            haystack: *self,\n-            needle: sep,\n-            position: 0\n-        }\n-    }\n+    fn matches_index_iter(&self, sep: &'self str) -> MatchesIndexIterator<'self>;\n \n     /// An iterator over the substrings of `self` separated by `sep`.\n     ///\n@@ -1659,125 +1528,475 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str_iter(\"abc\").collect()\n     /// assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n     /// ```\n-    #[inline]\n-    fn split_str_iter(&self, sep: &'self str) -> StrSplitIterator<'self> {\n-        StrSplitIterator {\n-            it: self.matches_index_iter(sep),\n-            last_end: 0,\n-            finished: false\n-        }\n-    }\n+    fn split_str_iter(&self, &'self str) -> StrSplitIterator<'self>;\n \n     /// An iterator over the lines of a string (subsequences separated\n     /// by `\\n`).\n-    #[inline]\n-    fn line_iter(&self) -> CharSplitIterator<'self, char> {\n-        self.split_terminator_iter('\\n')\n-    }\n+    fn line_iter(&self) -> CharSplitIterator<'self, char>;\n \n     /// An iterator over the lines of a string, separated by either\n     /// `\\n` or (`\\r\\n`).\n-    fn any_line_iter(&self) -> AnyLineIterator<'self> {\n-        do self.line_iter().map |line| {\n-            let l = line.len();\n-            if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n-            else { line }\n-        }\n-    }\n+    fn any_line_iter(&self) -> AnyLineIterator<'self>;\n \n     /// An iterator over the words of a string (subsequences separated\n     /// by any sequence of whitespace).\n-    #[inline]\n-    fn word_iter(&self) -> WordIterator<'self> {\n-        self.split_iter(char::is_whitespace).filter(|s| !s.is_empty())\n-    }\n+    fn word_iter(&self) -> WordIterator<'self>;\n \n-    /// Returns the string in Unicode Normalization Form D (canonical decomposition)\n-    fn nfd_iter(&self) -> NormalizationIterator<'self> {\n-        NormalizationIterator {\n-            iter: self.iter(),\n-            buffer: ~[],\n-            sorted: false,\n-            kind: NFD\n-        }\n-    }\n+    /// An Iterator over the string in Unicode Normalization Form D (canonical decomposition)\n+    fn nfd_iter(&self) -> NormalizationIterator<'self>;\n \n-    /// Returns the string in Unicode Normalization Form KD (compatibility decomposition)\n-    fn nfkd_iter(&self) -> NormalizationIterator<'self> {\n-        NormalizationIterator {\n-            iter: self.iter(),\n-            buffer: ~[],\n-            sorted: false,\n-            kind: NFKD\n-        }\n-    }\n+    /// An Iterator over the string in Unicode Normalization Form KD (compatibility decomposition)\n+    fn nfkd_iter(&self) -> NormalizationIterator<'self>;\n \n     /// Returns true if the string contains only whitespace\n     ///\n     /// Whitespace characters are determined by `char::is_whitespace`\n-    #[inline]\n-    fn is_whitespace(&self) -> bool { self.iter().all(char::is_whitespace) }\n+    fn is_whitespace(&self) -> bool;\n \n     /// Returns true if the string contains only alphanumerics\n     ///\n     /// Alphanumeric characters are determined by `char::is_alphanumeric`\n-    #[inline]\n-    fn is_alphanumeric(&self) -> bool { self.iter().all(char::is_alphanumeric) }\n+    fn is_alphanumeric(&self) -> bool;\n \n     /// Returns the number of characters that a string holds\n-    #[inline]\n-    fn char_len(&self) -> uint { self.iter().len() }\n+    fn char_len(&self) -> uint;\n \n     /// Returns a slice of the given string from the byte range\n     /// [`begin`..`end`)\n     ///\n     /// Fails when `begin` and `end` do not point to valid characters or\n     /// beyond the last character of the string\n-    #[inline]\n-    fn slice(&self, begin: uint, end: uint) -> &'self str {\n-        assert!(self.is_char_boundary(begin) && self.is_char_boundary(end));\n-        unsafe { raw::slice_bytes(*self, begin, end) }\n-    }\n+    fn slice(&self, begin: uint, end: uint) -> &'self str;\n \n     /// Returns a slice of the string from `begin` to its end.\n     ///\n     /// Fails when `begin` does not point to a valid character, or is\n     /// out of bounds.\n-    #[inline]\n-    fn slice_from(&self, begin: uint) -> &'self str {\n-        self.slice(begin, self.len())\n-    }\n+    fn slice_from(&self, begin: uint) -> &'self str;\n \n     /// Returns a slice of the string from the beginning to byte\n     /// `end`.\n     ///\n     /// Fails when `end` does not point to a valid character, or is\n     /// out of bounds.\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &'self str {\n-        assert!(self.is_char_boundary(end));\n-        unsafe { raw::slice_bytes(*self, 0, end) }\n-    }\n+    fn slice_to(&self, end: uint) -> &'self str;\n \n     /// Returns a slice of the string from the char range\n     /// [`begin`..`end`).\n     ///\n     /// Fails if `begin` > `end` or the either `begin` or `end` are\n     /// beyond the last character of the string.\n-    fn slice_chars(&self, begin: uint, end: uint) -> &'self str {\n-        assert!(begin <= end);\n-        let mut count = 0;\n-        let mut begin_byte = None;\n-        let mut end_byte = None;\n+    fn slice_chars(&self, begin: uint, end: uint) -> &'self str;\n \n-        // This could be even more efficient by not decoding,\n-        // only finding the char boundaries\n-        for (idx, _) in self.char_offset_iter() {\n-            if count == begin { begin_byte = Some(idx); }\n-            if count == end { end_byte = Some(idx); break; }\n-            count += 1;\n-        }\n-        if begin_byte.is_none() && count == begin { begin_byte = Some(self.len()) }\n+    /// Returns true if `needle` is a prefix of the string.\n+    fn starts_with(&self, needle: &str) -> bool;\n+\n+    /// Returns true if `needle` is a suffix of the string.\n+    fn ends_with(&self, needle: &str) -> bool;\n+\n+    /// Escape each char in `s` with char::escape_default.\n+    fn escape_default(&self) -> ~str;\n+\n+    /// Escape each char in `s` with char::escape_unicode.\n+    fn escape_unicode(&self) -> ~str;\n+\n+    /// Returns a string with leading and trailing whitespace removed\n+    fn trim(&self) -> &'self str;\n+\n+    /// Returns a string with leading whitespace removed\n+    fn trim_left(&self) -> &'self str;\n+\n+    /// Returns a string with trailing whitespace removed\n+    fn trim_right(&self) -> &'self str;\n+\n+    /// Returns a string with characters that match `to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\")\n+    /// ```\n+    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n+\n+    /// Returns a string with leading `chars_to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\")\n+    /// assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\")\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\")\n+    /// ```\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n+\n+    /// Returns a string with trailing `chars_to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\")\n+    /// ```\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n+\n+    /// Replace all occurrences of one string with another\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * from - The string to replace\n+    /// * to - The replacement string\n+    ///\n+    /// # Return value\n+    ///\n+    /// The original string with all occurances of `from` replaced with `to`\n+    fn replace(&self, from: &str, to: &str) -> ~str;\n+\n+    /// Copy a slice into a new owned str\n+    fn to_owned(&self) -> ~str;\n+\n+    /// Copy a slice into a new managed str\n+    fn to_managed(&self) -> @str;\n+\n+    /// Converts to a vector of `u16` encoded as UTF-16.\n+    fn to_utf16(&self) -> ~[u16];\n+\n+    /// Copy a slice into a new `SendStr`\n+    fn to_send_str(&self) -> SendStr;\n+\n+    /// Returns false if the index points into the middle of a multi-byte\n+    /// character sequence.\n+    fn is_char_boundary(&self, index: uint) -> bool;\n+\n+    /// Pluck a character out of a string and return the index of the next\n+    /// character.\n+    ///\n+    /// This function can be used to iterate over the unicode characters of a\n+    /// string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let i = 0u;\n+    /// while i < s.len() {\n+    ///     let CharRange {ch, next} = s.char_range_at(i);\n+    ///     printfln!(\"%u: %c\", i, ch);\n+    ///     i = next;\n+    /// }\n+    /// ```\n+    ///\n+    /// # Example output\n+    ///\n+    /// ```\n+    /// 0: \u4e2d\n+    /// 3: \u534e\n+    /// 6: V\n+    /// 7: i\n+    /// 8: \u1ec7\n+    /// 11: t\n+    /// 12:\n+    /// 13: N\n+    /// 14: a\n+    /// 15: m\n+    /// ```\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - The string\n+    /// * i - The byte offset of the char to extract\n+    ///\n+    /// # Return value\n+    ///\n+    /// A record {ch: char, next: uint} containing the char value and the byte\n+    /// index of the next unicode character.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    fn char_range_at(&self, start: uint) -> CharRange;\n+\n+    /// Given a byte position and a str, return the previous char and its position.\n+    ///\n+    /// This function can be used to iterate over a unicode string in reverse.\n+    ///\n+    /// Returns 0 for next index if called on start index 0.\n+    fn char_range_at_reverse(&self, start: uint) -> CharRange;\n+\n+    /// Plucks the character starting at the `i`th byte of a string\n+    fn char_at(&self, i: uint) -> char;\n+\n+    /// Plucks the character ending at the `i`th byte of a string\n+    fn char_at_reverse(&self, i: uint) -> char;\n+\n+    /// Work with the byte buffer of a string as a byte slice.\n+    fn as_bytes(&self) -> &'self [u8];\n+\n+    /// Returns the byte index of the first character of `self` that matches `search`\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the last matching character\n+    /// or `None` if there is no match\n+    fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n+\n+    /// Returns the byte index of the last character of `self` that matches `search`\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the last matching character\n+    /// or `None` if there is no match\n+    fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n+\n+    /// Returns the byte index of the first matching substring\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `needle` - The string to search for\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the first matching substring\n+    /// or `None` if there is no match\n+    fn find_str(&self, &str) -> Option<uint>;\n+\n+    /// Given a string, make a new string with repeated copies of it.\n+    fn repeat(&self, nn: uint) -> ~str;\n+\n+    /// Retrieves the first character from a string slice and returns\n+    /// it. This does not allocate a new string; instead, it returns a\n+    /// slice that point one character beyond the character that was\n+    /// shifted.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If the string does not contain any characters\n+    fn slice_shift_char(&self) -> (char, &'self str);\n+\n+    /// Levenshtein Distance between two strings.\n+    fn lev_distance(&self, t: &str) -> uint;\n+\n+    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n+    ///\n+    /// Fails if `inner` is not a direct slice contained within self.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let string = \"a\\nb\\nc\";\n+    /// let mut lines = ~[];\n+    /// for line in string.line_iter() { lines.push(line) }\n+    ///\n+    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n+    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n+    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n+    /// ```\n+    fn subslice_offset(&self, inner: &str) -> uint;\n+\n+    /// Work with the byte buffer and length of a slice.\n+    ///\n+    /// The buffer does not have a null terminator.\n+    fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T;\n+}\n+\n+impl<'self> StrSlice<'self> for &'self str {\n+    #[inline]\n+    fn contains<'a>(&self, needle: &'a str) -> bool {\n+        self.find_str(needle).is_some()\n+    }\n+\n+    #[inline]\n+    fn contains_char(&self, needle: char) -> bool {\n+        self.find(needle).is_some()\n+    }\n+\n+    #[inline]\n+    fn iter(&self) -> CharIterator<'self> {\n+        CharIterator{string: *self}\n+    }\n+\n+    #[inline]\n+    fn rev_iter(&self) -> CharRevIterator<'self> {\n+        self.iter().invert()\n+    }\n+\n+    #[inline]\n+    fn byte_iter(&self) -> ByteIterator<'self> {\n+        self.as_bytes().iter().map(|&b| b)\n+    }\n+\n+    #[inline]\n+    fn byte_rev_iter(&self) -> ByteRevIterator<'self> {\n+        self.byte_iter().invert()\n+    }\n+\n+    #[inline]\n+    fn char_offset_iter(&self) -> CharOffsetIterator<'self> {\n+        CharOffsetIterator{string: *self, iter: self.iter()}\n+    }\n+\n+    #[inline]\n+    fn char_offset_rev_iter(&self) -> CharOffsetRevIterator<'self> {\n+        self.char_offset_iter().invert()\n+    }\n+\n+    #[inline]\n+    fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep> {\n+        CharSplitIterator {\n+            string: *self,\n+            only_ascii: sep.only_ascii(),\n+            sep: sep,\n+            allow_trailing_empty: true,\n+            finished: false,\n+        }\n+    }\n+\n+    #[inline]\n+    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint)\n+        -> CharSplitNIterator<'self, Sep> {\n+        CharSplitNIterator {\n+            iter: self.split_iter(sep),\n+            count: count,\n+            invert: false,\n+        }\n+    }\n+\n+    #[inline]\n+    fn split_terminator_iter<Sep: CharEq>(&self, sep: Sep)\n+        -> CharSplitIterator<'self, Sep> {\n+        CharSplitIterator {\n+            allow_trailing_empty: false,\n+            ..self.split_iter(sep)\n+        }\n+    }\n+\n+    #[inline]\n+    fn rsplit_iter<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep> {\n+        self.split_iter(sep).invert()\n+    }\n+\n+    #[inline]\n+    fn rsplitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint)\n+        -> CharSplitNIterator<'self, Sep> {\n+        CharSplitNIterator {\n+            iter: self.split_iter(sep),\n+            count: count,\n+            invert: true,\n+        }\n+    }\n+\n+    #[inline]\n+    fn matches_index_iter(&self, sep: &'self str) -> MatchesIndexIterator<'self> {\n+        assert!(!sep.is_empty())\n+        MatchesIndexIterator {\n+            haystack: *self,\n+            needle: sep,\n+            position: 0\n+        }\n+    }\n+\n+    #[inline]\n+    fn split_str_iter(&self, sep: &'self str) -> StrSplitIterator<'self> {\n+        StrSplitIterator {\n+            it: self.matches_index_iter(sep),\n+            last_end: 0,\n+            finished: false\n+        }\n+    }\n+\n+    #[inline]\n+    fn line_iter(&self) -> CharSplitIterator<'self, char> {\n+        self.split_terminator_iter('\\n')\n+    }\n+\n+    fn any_line_iter(&self) -> AnyLineIterator<'self> {\n+        do self.line_iter().map |line| {\n+            let l = line.len();\n+            if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n+            else { line }\n+        }\n+    }\n+\n+    #[inline]\n+    fn word_iter(&self) -> WordIterator<'self> {\n+        self.split_iter(char::is_whitespace).filter(|s| !s.is_empty())\n+    }\n+\n+    #[inline]\n+    fn nfd_iter(&self) -> NormalizationIterator<'self> {\n+        NormalizationIterator {\n+            iter: self.iter(),\n+            buffer: ~[],\n+            sorted: false,\n+            kind: NFD\n+        }\n+    }\n+\n+    #[inline]\n+    fn nfkd_iter(&self) -> NormalizationIterator<'self> {\n+        NormalizationIterator {\n+            iter: self.iter(),\n+            buffer: ~[],\n+            sorted: false,\n+            kind: NFKD\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_whitespace(&self) -> bool { self.iter().all(char::is_whitespace) }\n+\n+    #[inline]\n+    fn is_alphanumeric(&self) -> bool { self.iter().all(char::is_alphanumeric) }\n+\n+    #[inline]\n+    fn char_len(&self) -> uint { self.iter().len() }\n+\n+    #[inline]\n+    fn slice(&self, begin: uint, end: uint) -> &'self str {\n+        assert!(self.is_char_boundary(begin) && self.is_char_boundary(end));\n+        unsafe { raw::slice_bytes(*self, begin, end) }\n+    }\n+\n+    #[inline]\n+    fn slice_from(&self, begin: uint) -> &'self str {\n+        self.slice(begin, self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to(&self, end: uint) -> &'self str {\n+        assert!(self.is_char_boundary(end));\n+        unsafe { raw::slice_bytes(*self, 0, end) }\n+    }\n+\n+    fn slice_chars(&self, begin: uint, end: uint) -> &'self str {\n+        assert!(begin <= end);\n+        let mut count = 0;\n+        let mut begin_byte = None;\n+        let mut end_byte = None;\n+\n+        // This could be even more efficient by not decoding,\n+        // only finding the char boundaries\n+        for (idx, _) in self.char_offset_iter() {\n+            if count == begin { begin_byte = Some(idx); }\n+            if count == end { end_byte = Some(idx); break; }\n+            count += 1;\n+        }\n+        if begin_byte.is_none() && count == begin { begin_byte = Some(self.len()) }\n         if end_byte.is_none() && count == end { end_byte = Some(self.len()) }\n \n         match (begin_byte, end_byte) {\n@@ -1787,23 +2006,20 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /// Returns true if `needle` is a prefix of the string.\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {\n         let (self_len, needle_len) = (self.len(), needle.len());\n         if needle_len == 0u { true }\n         else if needle_len > self_len { false }\n         else { match_at(*self, needle, 0u) }\n     }\n \n-    /// Returns true if `needle` is a suffix of the string.\n     fn ends_with(&self, needle: &str) -> bool {\n         let (self_len, needle_len) = (self.len(), needle.len());\n         if needle_len == 0u { true }\n         else if needle_len > self_len { false }\n         else { match_at(*self, needle, self_len - needle_len) }\n     }\n \n-    /// Escape each char in `s` with char::escape_default.\n     fn escape_default(&self) -> ~str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n@@ -1815,7 +2031,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         out\n     }\n \n-    /// Escape each char in `s` with char::escape_unicode.\n     fn escape_unicode(&self) -> ~str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n@@ -1827,55 +2042,26 @@ impl<'self> StrSlice<'self> for &'self str {\n         out\n     }\n \n-    /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n     fn trim(&self) -> &'self str {\n         self.trim_left().trim_right()\n     }\n \n-    /// Returns a string with leading whitespace removed\n     #[inline]\n     fn trim_left(&self) -> &'self str {\n         self.trim_left_chars(&char::is_whitespace)\n     }\n \n-    /// Returns a string with trailing whitespace removed\n     #[inline]\n     fn trim_right(&self) -> &'self str {\n         self.trim_right_chars(&char::is_whitespace)\n-    }\n-\n-    /// Returns a string with characters that match `to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\")\n-    /// ```\n-    #[inline]\n-    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n-        self.trim_left_chars(to_trim).trim_right_chars(to_trim)\n-    }\n-\n-    /// Returns a string with leading `chars_to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\")\n-    /// assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\")\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\")\n-    /// ```\n+    }\n+\n+    #[inline]\n+    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n+        self.trim_left_chars(to_trim).trim_right_chars(to_trim)\n+    }\n+\n     #[inline]\n     fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n         match self.find(|c: char| !to_trim.matches(c)) {\n@@ -1884,19 +2070,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /// Returns a string with trailing `chars_to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\")\n-    /// ```\n     #[inline]\n     fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n         match self.rfind(|c: char| !to_trim.matches(c)) {\n@@ -1908,16 +2081,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /// Replace all occurrences of one string with another\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * from - The string to replace\n-    /// * to - The replacement string\n-    ///\n-    /// # Return value\n-    ///\n-    /// The original string with all occurances of `from` replaced with `to`\n     fn replace(&self, from: &str, to: &str) -> ~str {\n         let mut result = ~\"\";\n         let mut last_end = 0;\n@@ -1930,7 +2093,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         result\n     }\n \n-    /// Copy a slice into a new unique str\n     #[inline]\n     fn to_owned(&self) -> ~str {\n         do self.as_imm_buf |src, len| {\n@@ -1954,7 +2116,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /// Converts to a vector of `u16` encoded as UTF-16.\n     fn to_utf16(&self) -> ~[u16] {\n         let mut u = ~[];\n         for ch in self.iter() {\n@@ -1983,62 +2144,13 @@ impl<'self> StrSlice<'self> for &'self str {\n         SendStrOwned(self.to_owned())\n     }\n \n-    /// Returns false if the index points into the middle of a multi-byte\n-    /// character sequence.\n     #[inline]\n     fn is_char_boundary(&self, index: uint) -> bool {\n         if index == self.len() { return true; }\n         let b = self[index];\n         return b < 128u8 || b >= 192u8;\n     }\n \n-    /// Pluck a character out of a string and return the index of the next\n-    /// character.\n-    ///\n-    /// This function can be used to iterate over the unicode characters of a\n-    /// string.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-    /// let i = 0u;\n-    /// while i < s.len() {\n-    ///     let CharRange {ch, next} = s.char_range_at(i);\n-    ///     printfln!(\"%u: %c\", i, ch);\n-    ///     i = next;\n-    /// }\n-    /// ```\n-    ///\n-    /// # Example output\n-    ///\n-    /// ```\n-    /// 0: \u4e2d\n-    /// 3: \u534e\n-    /// 6: V\n-    /// 7: i\n-    /// 8: \u1ec7\n-    /// 11: t\n-    /// 12:\n-    /// 13: N\n-    /// 14: a\n-    /// 15: m\n-    /// ```\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - The string\n-    /// * i - The byte offset of the char to extract\n-    ///\n-    /// # Return value\n-    ///\n-    /// A record {ch: char, next: uint} containing the char value and the byte\n-    /// index of the next unicode character.\n-    ///\n-    /// # Failure\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[inline]\n     fn char_range_at(&self, i: uint) -> CharRange {\n         if (self[i] < 128u8) {\n@@ -2062,15 +2174,9 @@ impl<'self> StrSlice<'self> for &'self str {\n         return multibyte_char_range_at(*self, i);\n     }\n \n-    /// Plucks the character starting at the `i`th byte of a string\n     #[inline]\n     fn char_at(&self, i: uint) -> char { self.char_range_at(i).ch }\n \n-    /// Given a byte position and a str, return the previous char and its position.\n-    ///\n-    /// This function can be used to iterate over a unicode string in reverse.\n-    ///\n-    /// Returns 0 for next index if called on start index 0.\n     #[inline]\n     fn char_range_at_reverse(&self, start: uint) -> CharRange {\n         let mut prev = start;\n@@ -2079,7 +2185,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         if self[prev] < 128 { return CharRange{ch: self[prev] as char, next: prev} }\n \n         // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n-        fn multibyte_char_range_at_rev(s: &str, mut i: uint) -> CharRange {\n+        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n             // while there is a previous byte == 10......\n             while i > 0 && s[i] & 192u8 == TAG_CONT_U8 {\n                 i -= 1u;\n@@ -2097,26 +2203,24 @@ impl<'self> StrSlice<'self> for &'self str {\n             return CharRange {ch: unsafe { transmute(val as u32) }, next: i};\n         }\n \n-        return multibyte_char_range_at_rev(*self, prev);\n+        return multibyte_char_range_at_reverse(*self, prev);\n+    }\n+\n+    #[inline]\n+    fn char_at(&self, i: uint) -> char {\n+        self.char_range_at(i).ch\n     }\n \n-    /// Plucks the character ending at the `i`th byte of a string\n     #[inline]\n     fn char_at_reverse(&self, i: uint) -> char {\n         self.char_range_at_reverse(i).ch\n     }\n \n-    /// Work with the byte buffer of a string as a byte slice.\n+    #[inline]\n     fn as_bytes(&self) -> &'self [u8] {\n         unsafe { cast::transmute(*self) }\n     }\n \n-    /// Returns the byte index of the first character of `self` that matches `search`\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match\n     fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n         if search.only_ascii() {\n             self.byte_iter().position(|b| search.matches(b as char))\n@@ -2128,12 +2232,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /// Returns the byte index of the last character of `self` that matches `search`\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match\n     fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n         if search.only_ascii() {\n             self.byte_iter().rposition(|b| search.matches(b as char))\n@@ -2145,16 +2243,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /// Returns the byte index of the first matching substring\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * `needle` - The string to search for\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the first matching substring\n-    /// or `None` if there is no match\n     fn find_str(&self, needle: &str) -> Option<uint> {\n         if needle.is_empty() {\n             Some(0)\n@@ -2165,7 +2253,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /// Given a string, make a new string with repeated copies of it.\n     fn repeat(&self, nn: uint) -> ~str {\n         let mut ret = with_capacity(nn * self.len());\n         for _ in range(0, nn) {\n@@ -2174,22 +2261,13 @@ impl<'self> StrSlice<'self> for &'self str {\n         ret\n     }\n \n-    /// Retrieves the first character from a string slice and returns\n-    /// it. This does not allocate a new string; instead, it returns a\n-    /// slice that point one character beyond the character that was\n-    /// shifted.\n-    ///\n-    /// # Failure\n-    ///\n-    /// If the string does not contain any characters\n     #[inline]\n     fn slice_shift_char(&self) -> (char, &'self str) {\n         let CharRange {ch, next} = self.char_range_at(0u);\n         let next_s = unsafe { raw::slice_bytes(*self, next, self.len()) };\n         return (ch, next_s);\n     }\n \n-    /// Levenshtein Distance between two strings.\n     fn lev_distance(&self, t: &str) -> uint {\n         let slen = self.len();\n         let tlen = t.len();\n@@ -2222,22 +2300,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         return dcol[tlen];\n     }\n \n-    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n-    ///\n-    /// Fails if `inner` is not a direct slice contained within self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let string = \"a\\nb\\nc\";\n-    /// let mut lines = ~[];\n-    /// for line in string.line_iter() { lines.push(line) }\n-    ///\n-    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n-    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n-    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n-    /// ```\n-    #[inline]\n     fn subslice_offset(&self, inner: &str) -> uint {\n         do self.as_imm_buf |a, a_len| {\n             do inner.as_imm_buf |b, b_len| {\n@@ -2256,29 +2318,86 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    /// Work with the byte buffer and length of a slice.\n-    ///\n-    /// The buffer does not have a null terminator.\n     #[inline]\n     fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T {\n         let v: &[u8] = unsafe { cast::transmute(*self) };\n         v.as_imm_buf(f)\n     }\n }\n \n-#[allow(missing_doc)]\n+/// Methods for owned strings\n pub trait OwnedStr {\n+    /// Appends a string slice to the back of a string, without overallocating\n     fn push_str_no_overallocate(&mut self, rhs: &str);\n+\n+    /// Appends a string slice to the back of a string\n     fn push_str(&mut self, rhs: &str);\n+\n+    /// Appends a character to the back of a string\n     fn push_char(&mut self, c: char);\n+\n+    /// Remove the final character from a string and return it\n+    ///\n+    /// # Failure\n+    ///\n+    /// If the string does not contain any characters\n     fn pop_char(&mut self) -> char;\n+\n+    /// Remove the first character from a string and return it\n+    ///\n+    /// # Failure\n+    ///\n+    /// If the string does not contain any characters\n     fn shift_char(&mut self) -> char;\n+\n+    /// Prepend a char to a string\n     fn unshift_char(&mut self, ch: char);\n+\n+    /// Concatenate two strings together.\n     fn append(self, rhs: &str) -> ~str;\n+\n+    /// Reserves capacity for exactly `n` bytes in the given string.\n+    ///\n+    /// Assuming single-byte characters, the resulting string will be large\n+    /// enough to hold a string of length `n`.\n+    ///\n+    /// If the capacity for `s` is already equal to or greater than the requested\n+    /// capacity, then no action is taken.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - A string\n+    /// * n - The number of bytes to reserve space for\n     fn reserve(&mut self, n: uint);\n+\n+    /// Reserves capacity for at least `n` bytes in the given string.\n+    ///\n+    /// Assuming single-byte characters, the resulting string will be large\n+    /// enough to hold a string of length `n`.\n+    ///\n+    /// This function will over-allocate in order to amortize the allocation costs\n+    /// in scenarios where the caller may need to repeatedly reserve additional\n+    /// space.\n+    ///\n+    /// If the capacity for `s` is already equal to or greater than the requested\n+    /// capacity, then no action is taken.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - A string\n+    /// * n - The number of bytes to reserve space for\n     fn reserve_at_least(&mut self, n: uint);\n+\n+    /// Returns the number of single-byte characters the string can hold without\n+    /// reallocating\n     fn capacity(&self) -> uint;\n+\n+    /// Shorten a string to the specified length (which must be <= the current length)\n     fn truncate(&mut self, len: uint);\n+\n+    /// Consumes the string, returning the underlying byte buffer.\n+    ///\n+    /// The buffer does not have a null terminator.\n     fn into_bytes(self) -> ~[u8];\n \n     /// Work with the mutable byte buffer and length of a slice.\n@@ -2291,23 +2410,20 @@ pub trait OwnedStr {\n }\n \n impl OwnedStr for ~str {\n-    /// Appends a string slice to the back of a string, without overallocating\n     #[inline]\n     fn push_str_no_overallocate(&mut self, rhs: &str) {\n         let new_cap = self.len() + rhs.len();\n         self.reserve(new_cap);\n         self.push_str(rhs);\n     }\n \n-    /// Appends a string slice to the back of a string\n     #[inline]\n     fn push_str(&mut self, rhs: &str) {\n         unsafe {\n             raw::push_bytes(self, rhs.as_bytes());\n         }\n     }\n \n-    /// Appends a character to the back of a string\n     #[inline]\n     fn push_char(&mut self, c: char) {\n         let cur_len = self.len();\n@@ -2326,11 +2442,7 @@ impl OwnedStr for ~str {\n         }\n     }\n \n-    /// Remove the final character from a string and return it\n-    ///\n-    /// # Failure\n-    ///\n-    /// If the string does not contain any characters\n+    #[inline]\n     fn pop_char(&mut self) -> char {\n         let end = self.len();\n         assert!(end > 0u);\n@@ -2339,18 +2451,14 @@ impl OwnedStr for ~str {\n         return ch;\n     }\n \n-    /// Remove the first character from a string and return it\n-    ///\n-    /// # Failure\n-    ///\n-    /// If the string does not contain any characters\n+    #[inline]\n     fn shift_char(&mut self) -> char {\n         let CharRange {ch, next} = self.char_range_at(0u);\n         *self = self.slice(next, self.len()).to_owned();\n         return ch;\n     }\n \n-    /// Prepend a char to a string\n+    #[inline]\n     fn unshift_char(&mut self, ch: char) {\n         // This could be more efficient.\n         let mut new_str = ~\"\";\n@@ -2359,74 +2467,40 @@ impl OwnedStr for ~str {\n         *self = new_str;\n     }\n \n-    /// Concatenate two strings together.\n     #[inline]\n     fn append(self, rhs: &str) -> ~str {\n         let mut new_str = self;\n         new_str.push_str_no_overallocate(rhs);\n         new_str\n     }\n \n-    /// Reserves capacity for exactly `n` bytes in the given string.\n-    ///\n-    /// Assuming single-byte characters, the resulting string will be large\n-    /// enough to hold a string of length `n`.\n-    ///\n-    /// If the capacity for `s` is already equal to or greater than the requested\n-    /// capacity, then no action is taken.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - A string\n-    /// * n - The number of bytes to reserve space for\n     #[inline]\n     fn reserve(&mut self, n: uint) {\n         unsafe {\n             raw::as_owned_vec(self).reserve(n)\n         }\n     }\n \n-    /// Reserves capacity for at least `n` bytes in the given string.\n-    ///\n-    /// Assuming single-byte characters, the resulting string will be large\n-    /// enough to hold a string of length `n`.\n-    ///\n-    /// This function will over-allocate in order to amortize the allocation costs\n-    /// in scenarios where the caller may need to repeatedly reserve additional\n-    /// space.\n-    ///\n-    /// If the capacity for `s` is already equal to or greater than the requested\n-    /// capacity, then no action is taken.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - A string\n-    /// * n - The number of bytes to reserve space for\n     #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n         self.reserve(uint::next_power_of_two_opt(n).unwrap_or(n))\n     }\n \n-    /// Returns the number of single-byte characters the string can hold without\n-    /// reallocating\n+    #[inline]\n     fn capacity(&self) -> uint {\n         unsafe {\n             let buf: &~[u8] = cast::transmute(self);\n             buf.capacity()\n         }\n     }\n \n-    /// Shorten a string to the specified length (which must be <= the current length)\n     #[inline]\n     fn truncate(&mut self, len: uint) {\n         assert!(len <= self.len());\n         assert!(self.is_char_boundary(len));\n         unsafe { raw::set_len(self, len); }\n     }\n \n-    /// Consumes the string, returning the underlying byte buffer.\n-    ///\n-    /// The buffer does not have a null terminator.\n     #[inline]\n     fn into_bytes(self) -> ~[u8] {\n         unsafe { cast::transmute(self) }"}]}