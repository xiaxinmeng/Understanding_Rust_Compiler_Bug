{"sha": "394f6846b80240480f8d7ce4b3d5d4c42ba85201", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NGY2ODQ2YjgwMjQwNDgwZjhkN2NlNGIzZDVkNGM0MmJhODUyMDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-26T15:07:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-14T09:21:56Z"}, "message": "Rewrite WorkItem not to use `proc()`.", "tree": {"sha": "9310da2049a28e2ddfc917df4e41c8ba090f7b87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9310da2049a28e2ddfc917df4e41c8ba090f7b87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/394f6846b80240480f8d7ce4b3d5d4c42ba85201", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/394f6846b80240480f8d7ce4b3d5d4c42ba85201", "html_url": "https://github.com/rust-lang/rust/commit/394f6846b80240480f8d7ce4b3d5d4c42ba85201", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/394f6846b80240480f8d7ce4b3d5d4c42ba85201/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8e51ea0e2e0c7d363a4202c0ae395f320a19f3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8e51ea0e2e0c7d363a4202c0ae395f320a19f3d", "html_url": "https://github.com/rust-lang/rust/commit/d8e51ea0e2e0c7d363a4202c0ae395f320a19f3d"}], "stats": {"total": 27, "additions": 20, "deletions": 7}, "files": [{"sha": "24dfe600f2a56f2320bc5e665eac6d360789d153", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/394f6846b80240480f8d7ce4b3d5d4c42ba85201/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/394f6846b80240480f8d7ce4b3d5d4c42ba85201/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=394f6846b80240480f8d7ce4b3d5d4c42ba85201", "patch": "@@ -842,18 +842,31 @@ pub fn run_passes(sess: &Session,\n     //if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n }\n \n-type WorkItem = proc(&CodegenContext):Send;\n+struct WorkItem {\n+    mtrans: ModuleTranslation,\n+    config: ModuleConfig,\n+    output_names: OutputFilenames,\n+    name_extra: String\n+}\n \n fn build_work_item(sess: &Session,\n                    mtrans: ModuleTranslation,\n                    config: ModuleConfig,\n                    output_names: OutputFilenames,\n-                   name_extra: String) -> WorkItem {\n+                   name_extra: String)\n+                   -> WorkItem\n+{\n     let mut config = config;\n     config.tm = create_target_machine(sess);\n+    WorkItem { mtrans: mtrans, config: config, output_names: output_names,\n+               name_extra: name_extra }\n+}\n \n-    proc(cgcx) unsafe {\n-        optimize_and_codegen(cgcx, mtrans, config, name_extra, output_names);\n+fn execute_work_item(cgcx: &CodegenContext,\n+                     work_item: WorkItem) {\n+    unsafe {\n+        optimize_and_codegen(cgcx, work_item.mtrans, work_item.config,\n+                             work_item.name_extra, work_item.output_names);\n     }\n }\n \n@@ -866,7 +879,7 @@ fn run_work_singlethreaded(sess: &Session,\n     // Since we're running single-threaded, we can pass the session to\n     // the proc, allowing `optimize_and_codegen` to perform LTO.\n     for work in Unfold::new((), |_| work_items.pop()) {\n-        work(&cgcx);\n+        execute_work_item(&cgcx, work);\n     }\n }\n \n@@ -883,7 +896,7 @@ fn run_work_multithreaded(sess: &Session,\n         let diag_emitter = diag_emitter.clone();\n         let remark = sess.opts.cg.remark.clone();\n \n-        let future = TaskBuilder::new().named(format!(\"codegen-{}\", i)).try_future(proc() {\n+        let future = TaskBuilder::new().named(format!(\"codegen-{}\", i)).try_future(move |:| {\n             let diag_handler = mk_handler(box diag_emitter);\n \n             // Must construct cgcx inside the proc because it has non-Send\n@@ -899,7 +912,7 @@ fn run_work_multithreaded(sess: &Session,\n                 let maybe_work = work_items_arc.lock().pop();\n                 match maybe_work {\n                     Some(work) => {\n-                        work(&cgcx);\n+                        execute_work_item(&cgcx, work);\n \n                         // Make sure to fail the worker so the main thread can\n                         // tell that there were errors."}]}