{"sha": "963d37e821590b470f7a1fc9cfcda5a5ceceeee4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2M2QzN2U4MjE1OTBiNDcwZjdhMWZjOWNmY2RhNWE1Y2VjZWVlZTQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-31T23:48:38Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-01T21:07:31Z"}, "message": "Temporary workaround to prevent taskgroup cleanup code from failing without an exception handler.", "tree": {"sha": "0f3fb8984b6e0dc76dad4d64014e8aff2eebb348", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f3fb8984b6e0dc76dad4d64014e8aff2eebb348"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/963d37e821590b470f7a1fc9cfcda5a5ceceeee4", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/963d37e821590b470f7a1fc9cfcda5a5ceceeee4", "html_url": "https://github.com/rust-lang/rust/commit/963d37e821590b470f7a1fc9cfcda5a5ceceeee4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/963d37e821590b470f7a1fc9cfcda5a5ceceeee4/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeaed77301397c6ab0c4f5413dbd4b7f0d5b5c9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeaed77301397c6ab0c4f5413dbd4b7f0d5b5c9a", "html_url": "https://github.com/rust-lang/rust/commit/aeaed77301397c6ab0c4f5413dbd4b7f0d5b5c9a"}], "stats": {"total": 16, "additions": 13, "deletions": 3}, "files": [{"sha": "696f4a8c35515083457f44a63de9a28ed705c932", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/963d37e821590b470f7a1fc9cfcda5a5ceceeee4/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963d37e821590b470f7a1fc9cfcda5a5ceceeee4/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=963d37e821590b470f7a1fc9cfcda5a5ceceeee4", "patch": "@@ -72,6 +72,7 @@ use either::{Either, Left, Right};\n use option::{Option, Some, None};\n use prelude::*;\n use rt::task::Task;\n+use task::spawn::Taskgroup;\n use to_bytes::IterBytes;\n use unstable::atomics::{AtomicUint, Relaxed};\n use unstable::sync::{UnsafeAtomicRcBox, LittleLock};\n@@ -474,7 +475,7 @@ impl Death {\n     }\n \n     /// Collect failure exit codes from children and propagate them to a parent.\n-    pub fn collect_failure(&mut self, mut success: bool) {\n+    pub fn collect_failure(&mut self, mut success: bool, group: Option<Taskgroup>) {\n         // This may run after the task has already failed, so even though the\n         // task appears to need to be killed, the scheduler should not fail us\n         // when we block to unwrap.\n@@ -484,6 +485,10 @@ impl Death {\n         rtassert!(self.unkillable == 0);\n         self.unkillable = 1;\n \n+        // FIXME(#7544): See corresponding fixme at the callsite in task.rs.\n+        // NB(#8192): Doesn't work with \"let _ = ...\"\n+        { use util; util::ignore(group); }\n+\n         // Step 1. Decide if we need to collect child failures synchronously.\n         do self.on_exit.take_map |on_exit| {\n             if success {"}, {"sha": "f7f1b10e58c763c70aa25268aa0ecc31f846cb51", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/963d37e821590b470f7a1fc9cfcda5a5ceceeee4/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963d37e821590b470f7a1fc9cfcda5a5ceceeee4/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=963d37e821590b470f7a1fc9cfcda5a5ceceeee4", "patch": "@@ -129,8 +129,13 @@ impl Task {\n         }\n \n         self.unwinder.try(f);\n-        { let _ = self.taskgroup.take(); }\n-        self.death.collect_failure(!self.unwinder.unwinding);\n+        // FIXME(#7544): We pass the taskgroup into death so that it can be\n+        // dropped while the unkillable counter is set. This should not be\n+        // necessary except for an extraneous clone() in task/spawn.rs that\n+        // causes a killhandle to get dropped, which mustn't receive a kill\n+        // signal since we're outside of the unwinder's try() scope.\n+        // { let _ = self.taskgroup.take(); }\n+        self.death.collect_failure(!self.unwinder.unwinding, self.taskgroup.take());\n         self.destroy();\n     }\n "}]}