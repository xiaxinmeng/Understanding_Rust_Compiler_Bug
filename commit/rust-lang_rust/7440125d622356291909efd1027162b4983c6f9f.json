{"sha": "7440125d622356291909efd1027162b4983c6f9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NDAxMjVkNjIyMzU2MjkxOTA5ZWZkMTAyNzE2MmI0OTgzYzZmOWY=", "commit": {"author": {"name": "Tristan Burgess", "email": "tburgessdev@gmail.com", "date": "2018-08-22T04:24:03Z"}, "committer": {"name": "Tristan Burgess", "email": "tburgessdev@gmail.com", "date": "2018-08-22T22:57:10Z"}, "message": "52985: formatting PR files", "tree": {"sha": "499d0a009b3d92ad2d40030409b57d4cabee020f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/499d0a009b3d92ad2d40030409b57d4cabee020f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7440125d622356291909efd1027162b4983c6f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7440125d622356291909efd1027162b4983c6f9f", "html_url": "https://github.com/rust-lang/rust/commit/7440125d622356291909efd1027162b4983c6f9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7440125d622356291909efd1027162b4983c6f9f/comments", "author": {"login": "tristanburgess", "id": 3913590, "node_id": "MDQ6VXNlcjM5MTM1OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/3913590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tristanburgess", "html_url": "https://github.com/tristanburgess", "followers_url": "https://api.github.com/users/tristanburgess/followers", "following_url": "https://api.github.com/users/tristanburgess/following{/other_user}", "gists_url": "https://api.github.com/users/tristanburgess/gists{/gist_id}", "starred_url": "https://api.github.com/users/tristanburgess/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tristanburgess/subscriptions", "organizations_url": "https://api.github.com/users/tristanburgess/orgs", "repos_url": "https://api.github.com/users/tristanburgess/repos", "events_url": "https://api.github.com/users/tristanburgess/events{/privacy}", "received_events_url": "https://api.github.com/users/tristanburgess/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tristanburgess", "id": 3913590, "node_id": "MDQ6VXNlcjM5MTM1OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/3913590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tristanburgess", "html_url": "https://github.com/tristanburgess", "followers_url": "https://api.github.com/users/tristanburgess/followers", "following_url": "https://api.github.com/users/tristanburgess/following{/other_user}", "gists_url": "https://api.github.com/users/tristanburgess/gists{/gist_id}", "starred_url": "https://api.github.com/users/tristanburgess/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tristanburgess/subscriptions", "organizations_url": "https://api.github.com/users/tristanburgess/orgs", "repos_url": "https://api.github.com/users/tristanburgess/repos", "events_url": "https://api.github.com/users/tristanburgess/events{/privacy}", "received_events_url": "https://api.github.com/users/tristanburgess/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3045ffa512db4fd9745278e43c8e775db2d0d19d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3045ffa512db4fd9745278e43c8e775db2d0d19d", "html_url": "https://github.com/rust-lang/rust/commit/3045ffa512db4fd9745278e43c8e775db2d0d19d"}], "stats": {"total": 104, "additions": 58, "deletions": 46}, "files": [{"sha": "821d3229fdc66e3ed2e0510db02862a9f50e4420", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7440125d622356291909efd1027162b4983c6f9f/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7440125d622356291909efd1027162b4983c6f9f/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=7440125d622356291909efd1027162b4983c6f9f", "patch": "@@ -12,15 +12,15 @@\n //! which folds deeply, invoking the underlying\n //! `normalize_projection_ty` query when it encounters projections.\n \n-use infer::{InferCtxt, InferOk};\n use infer::at::At;\n-use mir::interpret::{GlobalId, ConstValue};\n+use infer::{InferCtxt, InferOk};\n+use mir::interpret::{ConstValue, GlobalId};\n use rustc_data_structures::small_vec::SmallVec;\n-use traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use traits::project::Normalized;\n-use ty::{self, Ty, TyCtxt};\n+use traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use ty::fold::{TypeFoldable, TypeFolder};\n use ty::subst::{Subst, Substs};\n+use ty::{self, Ty, TyCtxt};\n \n use super::NoSolution;\n \n@@ -121,9 +121,14 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                         let concrete_ty = generic_ty.subst(self.tcx(), substs);\n                         self.anon_depth += 1;\n                         if concrete_ty == ty {\n-                            bug!(\"infinite recursion generic_ty: {:#?}, substs: {:#?}, \\\n-                                  concrete_ty: {:#?}, ty: {:#?}\", generic_ty, substs, concrete_ty,\n-                                  ty);\n+                            bug!(\n+                                \"infinite recursion generic_ty: {:#?}, substs: {:#?}, \\\n+                                 concrete_ty: {:#?}, ty: {:#?}\",\n+                                generic_ty,\n+                                substs,\n+                                concrete_ty,\n+                                ty\n+                            );\n                         }\n                         let folded_ty = self.fold_ty(concrete_ty);\n                         self.anon_depth -= 1;\n@@ -149,8 +154,8 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                 let gcx = self.infcx.tcx.global_tcx();\n \n                 let mut orig_values = SmallVec::new();\n-                let c_data =\n-                    self.infcx.canonicalize_query(&self.param_env.and(*data), &mut orig_values);\n+                let c_data = self.infcx\n+                    .canonicalize_query(&self.param_env.and(*data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n                 match gcx.normalize_projection_ty(c_data) {"}, {"sha": "319de51713b93abcb8bec52bbbbcc9059aecd185", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7440125d622356291909efd1027162b4983c6f9f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7440125d622356291909efd1027162b4983c6f9f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=7440125d622356291909efd1027162b4983c6f9f", "patch": "@@ -17,15 +17,15 @@ use rustc::hir;\n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::infer::InferCtxt;\n+use rustc::ty::adjustment::{Adjust, Adjustment};\n+use rustc::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::adjustment::{Adjust, Adjustment};\n-use rustc::ty::fold::{TypeFoldable, TypeFolder, BottomUpFolder};\n use rustc::util::nodemap::DefIdSet;\n+use rustc_data_structures::sync::Lrc;\n+use std::mem;\n use syntax::ast;\n use syntax_pos::Span;\n-use std::mem;\n-use rustc_data_structures::sync::Lrc;\n \n ///////////////////////////////////////////////////////////////////////////\n // Entry point\n@@ -55,17 +55,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n         debug!(\n             \"used_trait_imports({:?}) = {:?}\",\n-            item_def_id,\n-            used_trait_imports\n+            item_def_id, used_trait_imports\n         );\n         wbcx.tables.used_trait_imports = used_trait_imports;\n \n         wbcx.tables.tainted_by_errors = self.is_tainted_by_errors();\n \n         debug!(\n             \"writeback: tables for {:?} are {:#?}\",\n-            item_def_id,\n-            wbcx.tables\n+            item_def_id, wbcx.tables\n         );\n \n         self.tcx.alloc_tables(wbcx.tables)\n@@ -118,8 +116,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     // operating on scalars, we clear the overload.\n     fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n-            hir::ExprKind::Unary(hir::UnNeg, ref inner) |\n-            hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n+            hir::ExprKind::Unary(hir::UnNeg, ref inner)\n+            | hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n                 let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n \n@@ -178,8 +176,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     let index_ty = tables.expr_ty_adjusted(&index);\n                     let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n \n-                    if base_ty.builtin_index().is_some()\n-                        && index_ty == self.fcx.tcx.types.usize {\n+                    if base_ty.builtin_index().is_some() && index_ty == self.fcx.tcx.types.usize {\n                         // Remove the method call record\n                         tables.type_dependent_defs_mut().remove(e.hir_id);\n                         tables.node_substs_mut().remove(e.hir_id);\n@@ -191,24 +188,26 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                 // of size information - we need to get rid of it\n                                 // Since this is \"after\" the other adjustment to be\n                                 // discarded, we do an extra `pop()`\n-                                Some(Adjustment { kind: Adjust::Unsize, .. }) => {\n+                                Some(Adjustment {\n+                                    kind: Adjust::Unsize,\n+                                    ..\n+                                }) => {\n                                     // So the borrow discard actually happens here\n                                     a.pop();\n-                                },\n+                                }\n                                 _ => {}\n                             }\n                         });\n                     }\n-                },\n+                }\n                 // Might encounter non-valid indexes at this point, so there\n                 // has to be a fall-through\n-                _ => {},\n+                _ => {}\n             }\n         }\n     }\n }\n \n-\n ///////////////////////////////////////////////////////////////////////////\n // Impl of Visitor for Resolver\n //\n@@ -262,7 +261,9 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n                 if let Some(&bm) = self.fcx.tables.borrow().pat_binding_modes().get(p.hir_id) {\n                     self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n                 } else {\n-                    self.tcx().sess.delay_span_bug(p.span, \"missing binding mode\");\n+                    self.tcx()\n+                        .sess\n+                        .delay_span_bug(p.span, \"missing binding mode\");\n                 }\n             }\n             hir::PatKind::Struct(_, ref fields, _) => {\n@@ -310,8 +311,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             };\n             debug!(\n                 \"Upvar capture for {:?} resolved to {:?}\",\n-                upvar_id,\n-                new_upvar_capture\n+                upvar_id, new_upvar_capture\n             );\n             self.tables\n                 .upvar_capture_map\n@@ -425,8 +425,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                     if subst == ty {\n                                         // found it in the substitution list, replace with the\n                                         // parameter from the existential type\n-                                        return self\n-                                            .tcx()\n+                                        return self.tcx()\n                                             .global_tcx()\n                                             .mk_ty_param(param.index, param.name);\n                                     }\n@@ -464,14 +463,16 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                                 name: p.name,\n                                             };\n                                             trace!(\"replace {:?} with {:?}\", region, reg);\n-                                            return self.tcx().global_tcx()\n+                                            return self.tcx()\n+                                                .global_tcx()\n                                                 .mk_region(ty::ReEarlyBound(reg));\n                                         }\n                                     }\n                                 }\n                                 trace!(\"anon_defn: {:#?}\", anon_defn);\n                                 trace!(\"generics: {:#?}\", generics);\n-                                self.tcx().sess\n+                                self.tcx()\n+                                    .sess\n                                     .struct_span_err(\n                                         span,\n                                         \"non-defining existential type use in defining scope\",\n@@ -480,33 +481,35 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                         span,\n                                         format!(\n                                             \"lifetime `{}` is part of concrete type but not used \\\n-                                            in parameter list of existential type\",\n+                                             in parameter list of existential type\",\n                                             region,\n                                         ),\n                                     )\n                                     .emit();\n                                 self.tcx().global_tcx().mk_region(ty::ReStatic)\n                             }\n                         }\n-                    }\n+                    },\n                 })\n             };\n \n             if let ty::Anon(defin_ty_def_id, _substs) = definition_ty.sty {\n                 if def_id == defin_ty_def_id {\n-                  // Concrete type resolved to the existential type itself\n-                  // Force a cycle error\n-                  self.tcx().at(span).type_of(defin_ty_def_id);\n+                    // Concrete type resolved to the existential type itself\n+                    // Force a cycle error\n+                    self.tcx().at(span).type_of(defin_ty_def_id);\n                 }\n             }\n \n-            let old = self.tables.concrete_existential_types.insert(def_id, definition_ty);\n+            let old = self.tables\n+                .concrete_existential_types\n+                .insert(def_id, definition_ty);\n             if let Some(old) = old {\n                 if old != definition_ty {\n                     span_bug!(\n                         span,\n                         \"visit_anon_types tried to write \\\n-                        different types for the same existential type: {:?}, {:?}, {:?}\",\n+                         different types for the same existential type: {:?}, {:?}, {:?}\",\n                         def_id,\n                         definition_ty,\n                         old,\n@@ -518,7 +521,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_field_id(&mut self, node_id: ast::NodeId) {\n         let hir_id = self.tcx().hir.node_to_hir_id(node_id);\n-        if let Some(index) = self.fcx.tables.borrow_mut().field_indices_mut().remove(hir_id) {\n+        if let Some(index) = self.fcx\n+            .tables\n+            .borrow_mut()\n+            .field_indices_mut()\n+            .remove(hir_id)\n+        {\n             self.tables.field_indices_mut().insert(hir_id, index);\n         }\n     }\n@@ -567,8 +575,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n                 debug!(\n                     \"Adjustments for node {:?}: {:?}\",\n-                    hir_id,\n-                    resolved_adjustment\n+                    hir_id, resolved_adjustment\n                 );\n                 self.tables\n                     .adjustments_mut()\n@@ -592,8 +599,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n                 debug!(\n                     \"pat_adjustments for node {:?}: {:?}\",\n-                    hir_id,\n-                    resolved_adjustment\n+                    hir_id, resolved_adjustment\n                 );\n                 self.tables\n                     .pat_adjustments_mut()\n@@ -709,7 +715,8 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n     fn report_error(&self, t: Ty<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n             self.infcx\n-                .need_type_info_err(Some(self.body.id()), self.span.to_span(&self.tcx), t).emit();\n+                .need_type_info_err(Some(self.body.id()), self.span.to_span(&self.tcx), t)\n+                .emit();\n         }\n     }\n }"}]}