{"sha": "48a69d2100622df88e3f1014eff00227401bf079", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4YTY5ZDIxMDA2MjJkZjg4ZTNmMTAxNGVmZjAwMjI3NDAxYmYwNzk=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-07-03T09:48:08Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-07-03T09:48:08Z"}, "message": "Eliminate all direct calls to option::get() from typeck\n\nThis means fewer mysterious error messages.", "tree": {"sha": "9aa6f69db27f9ab88ba2948e790f99dfb14a28ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9aa6f69db27f9ab88ba2948e790f99dfb14a28ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48a69d2100622df88e3f1014eff00227401bf079", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48a69d2100622df88e3f1014eff00227401bf079", "html_url": "https://github.com/rust-lang/rust/commit/48a69d2100622df88e3f1014eff00227401bf079", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48a69d2100622df88e3f1014eff00227401bf079/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c425a422ed8aec799532ba96e6f274ef83a0b759", "url": "https://api.github.com/repos/rust-lang/rust/commits/c425a422ed8aec799532ba96e6f274ef83a0b759", "html_url": "https://github.com/rust-lang/rust/commit/c425a422ed8aec799532ba96e6f274ef83a0b759"}], "stats": {"total": 76, "additions": 55, "deletions": 21}, "files": [{"sha": "41c3ff993ee2970dc7efc391d2f35fd998f962c4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/48a69d2100622df88e3f1014eff00227401bf079/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a69d2100622df88e3f1014eff00227401bf079/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=48a69d2100622df88e3f1014eff00227401bf079", "patch": "@@ -69,24 +69,44 @@ type fn_ctxt =\n // Used for ast_ty_to_ty() below.\n type ty_getter = fn(&ast::def_id) -> ty::ty_param_count_and_ty ;\n \n+fn lookup_local(&@fn_ctxt fcx, &span sp, ast::node_id id) -> int {\n+    alt (fcx.locals.find(id)) {\n+        case (some(?x)) { x }\n+        case (_) {\n+            fcx.ccx.tcx.sess.span_fatal(sp, \"internal error looking up a \\\n+              local var\")\n+        }\n+    }\n+}\n+\n+fn lookup_def(&@fn_ctxt fcx, &span sp, ast::node_id id) -> ast::def {\n+    alt (fcx.ccx.tcx.def_map.find(id)) {\n+        case (some(?x)) { x }\n+        case (_) {\n+            fcx.ccx.tcx.sess.span_fatal(sp, \"internal error looking up \\\n+              a definition\")\n+        }\n+    }\n+}\n \n // Returns the type parameter count and the type for the given definition.\n fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn) ->\n    ty_param_count_and_ty {\n     alt (defn) {\n         case (ast::def_arg(?id)) {\n             assert (fcx.locals.contains_key(id._1));\n-            auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id._1));\n+            auto typ = ty::mk_var(fcx.ccx.tcx, \n+                                  lookup_local(fcx, sp, id._1));\n             ret tup(0u, typ);\n         }\n         case (ast::def_local(?id)) {\n             assert (fcx.locals.contains_key(id._1));\n-            auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id._1));\n+            auto typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id._1));\n             ret tup(0u, typ);\n         }\n         case (ast::def_obj_field(?id)) {\n             assert (fcx.locals.contains_key(id._1));\n-            auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id._1));\n+            auto typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id._1));\n             ret tup(0u, typ);\n         }\n         case (ast::def_fn(?id, _)) {\n@@ -103,7 +123,7 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn) ->\n         }\n         case (ast::def_binding(?id)) {\n             assert (fcx.locals.contains_key(id._1));\n-            auto typ = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(id._1));\n+            auto typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id._1));\n             ret tup(0u, typ);\n         }\n         case (ast::def_mod(_)) {\n@@ -320,18 +340,24 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             typ = ty::mk_fn(tcx, proto, i, out_ty, cf, out_constrs);\n         }\n         case (ast::ty_path(?path, ?id)) {\n-            alt (tcx.def_map.get(id)) {\n-                case (ast::def_ty(?id)) {\n+            alt (tcx.def_map.find(id)) {\n+                case (some(ast::def_ty(?id))) {\n                     typ =\n                         instantiate(tcx, ast_ty.span, getter, id,\n                                     path.node.types);\n                 }\n-                case (ast::def_native_ty(?id)) { typ = getter(id)._1; }\n-                case (ast::def_ty_arg(?id)) { typ = ty::mk_param(tcx, id); }\n-                case (_) {\n+                case (some(ast::def_native_ty(?id))) { typ = getter(id)._1; }\n+                case (some(ast::def_ty_arg(?id))) {\n+                    typ = ty::mk_param(tcx, id);\n+                }\n+                case (some(_)) {\n                     tcx.sess.span_fatal(ast_ty.span,\n                                       \"found type name used as a variable\");\n                 }\n+                case (_) {\n+                    tcx.sess.span_fatal(ast_ty.span,\n+                                       \"internal error in instantiate\");\n+                }\n             }\n             cname = some(path_to_str(path));\n         }\n@@ -499,14 +525,20 @@ mod collect {\n \n             ret decoder::get_type(cx.tcx, id);\n         }\n-        auto it = cx.tcx.items.get(id._1);\n+        auto it = cx.tcx.items.find(id._1);\n         auto tpt;\n         alt (it) {\n-            case (ast_map::node_item(?item)) { tpt = ty_of_item(cx, item); }\n-            case (ast_map::node_native_item(?native_item)) {\n+            case (some(ast_map::node_item(?item))) {\n+                tpt = ty_of_item(cx, item);\n+            }\n+            case (some(ast_map::node_native_item(?native_item))) {\n                 tpt = ty_of_native_item(cx, native_item,\n                                         ast::native_abi_cdecl);\n             }\n+            case (_) {\n+                cx.tcx.sess.fatal(\"internal error \" +\n+                                  util::common::istr(id._1));\n+            }\n         }\n         ret tpt;\n     }\n@@ -1027,7 +1059,7 @@ mod writeback {\n         resolve_type_vars_for_node(fcx, p.span, ty::pat_node_id(p));\n     }\n     fn visit_local_pre(@fn_ctxt fcx, &@ast::local l) {\n-        auto var_id = fcx.locals.get(l.node.id);\n+        auto var_id = lookup_local(fcx, l.span, l.node.id);\n         auto fix_rslt =\n             ty::unify::resolve_type_var(fcx.ccx.tcx, fcx.var_bindings,\n                                         var_id);\n@@ -1226,15 +1258,15 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n             write::ty_only_fixup(fcx, id, typ);\n         }\n         case (ast::pat_bind(?name, ?id)) {\n-            auto vid = fcx.locals.get(id);\n+            auto vid = lookup_local(fcx, pat.span, id);\n             auto typ = ty::mk_var(fcx.ccx.tcx, vid);\n             typ = demand::simple(fcx, pat.span, expected, typ);\n             write::ty_only_fixup(fcx, id, typ);\n         }\n         case (ast::pat_tag(?path, ?subpats, ?id)) {\n             // Typecheck the path.\n \n-            auto v_def = fcx.ccx.tcx.def_map.get(id);\n+            auto v_def = lookup_def(fcx, path.span, id);\n             auto v_def_ids = ast::variant_def_ids(v_def);\n             auto tag_tpt = ty::lookup_item_type(fcx.ccx.tcx, v_def_ids._0);\n             auto path_tpot = instantiate_path(fcx, path, tag_tpt, pat.span);\n@@ -1329,8 +1361,8 @@ fn require_pure_call(@crate_ctxt ccx, &ast::purity caller_purity,\n     alt (caller_purity) {\n         case (ast::impure_fn) { ret; }\n         case (ast::pure_fn) {\n-            alt (ccx.tcx.def_map.get(callee.id)) {\n-                case (ast::def_fn(_, ast::pure_fn)) {\n+            alt (ccx.tcx.def_map.find(callee.id)) {\n+                case (some(ast::def_fn(_, ast::pure_fn))) {\n                     ret;\n                 }\n                 case (_) {\n@@ -1458,8 +1490,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (ast::expr_call(?operator, ?operands)) {\n                     alt (operator.node) {\n                         case (ast::expr_path(?oper_name)) {\n-                            alt (fcx.ccx.tcx.def_map.get(operator.id)) {\n-                                case (ast::def_fn(?_d_id, ast::pure_fn)) { \n+                            alt (fcx.ccx.tcx.def_map.find(operator.id)) {\n+                                case (some(ast::def_fn(?_d_id,\n+                                                       ast::pure_fn))) { \n                                     // do nothing\n                                 }\n                                 case (_) {\n@@ -1600,7 +1633,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             write::ty_only_fixup(fcx, id, oper_t);\n         }\n         case (ast::expr_path(?pth)) {\n-            auto defn = fcx.ccx.tcx.def_map.get(id);\n+            auto defn = lookup_def(fcx, pth.span, id);\n             auto tpt = ty_param_count_and_ty_for_def(fcx, expr.span, defn);\n             if (ty::def_has_ty_params(defn)) {\n                 auto path_tpot = instantiate_path(fcx, pth, tpt, expr.span);\n@@ -2287,7 +2320,8 @@ fn ast_constr_to_constr(ty::ctxt tcx, &@ast::constr c)\n fn check_decl_initializer(&@fn_ctxt fcx, ast::node_id nid,\n                           &ast::initializer init) {\n     check_expr(fcx, init.expr);\n-    auto lty = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(nid));\n+    auto lty = ty::mk_var(fcx.ccx.tcx,\n+                          lookup_local(fcx, init.expr.span, nid));\n     alt (init.op) {\n         case (ast::init_assign) {\n             demand::simple(fcx, init.expr.span, lty,"}]}