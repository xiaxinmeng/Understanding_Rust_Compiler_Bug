{"sha": "7803488a43eb24864105506b3825f605bc87d693", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MDM0ODhhNDNlYjI0ODY0MTA1NTA2YjM4MjVmNjA1YmM4N2Q2OTM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-05T01:05:34Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-05T01:06:59Z"}, "message": "Implement stack-only variants of int/uint str conversion and output.", "tree": {"sha": "0d7c8fb13116959dba91aef625a0f563c8733d22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d7c8fb13116959dba91aef625a0f563c8733d22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7803488a43eb24864105506b3825f605bc87d693", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7803488a43eb24864105506b3825f605bc87d693", "html_url": "https://github.com/rust-lang/rust/commit/7803488a43eb24864105506b3825f605bc87d693", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7803488a43eb24864105506b3825f605bc87d693/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "903033bb03d05b66cbbf79a58fc9989887e35b65", "url": "https://api.github.com/repos/rust-lang/rust/commits/903033bb03d05b66cbbf79a58fc9989887e35b65", "html_url": "https://github.com/rust-lang/rust/commit/903033bb03d05b66cbbf79a58fc9989887e35b65"}], "stats": {"total": 113, "additions": 84, "deletions": 29}, "files": [{"sha": "c937c88145d52b2935eef99897685d34fa4c3766", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7803488a43eb24864105506b3825f605bc87d693/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7803488a43eb24864105506b3825f605bc87d693/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=7803488a43eb24864105506b3825f605bc87d693", "patch": "@@ -9,7 +9,7 @@ export is_nonpositive, is_nonnegative;\n export range;\n export compl;\n export abs;\n-export parse_buf, from_str, to_str, str;\n+export parse_buf, from_str, to_str, to_str_bytes, str;\n \n const min_value: T = -1 as T << (inst::bits - 1 as T);\n const max_value: T = min_value - 1 as T;\n@@ -96,6 +96,14 @@ fn to_str(n: T, radix: uint) -> str {\n         } else { uint::to_str(n as uint, radix) };\n }\n \n+fn to_str_bytes<U>(n: T, radix: uint, f: fn([u8]/&) -> U) -> U {\n+    if n < 0 as T {\n+        uint::to_str_bytes(true, -n as uint, radix, f)\n+    } else {\n+        uint::to_str_bytes(false, n as uint, radix, f)\n+    }\n+}\n+\n #[doc = \"Convert to a string\"]\n fn str(i: T) -> str { ret to_str(i, 10u); }\n "}, {"sha": "d65836f34b358a37c6c75e8a25127c3925882ac9", "filename": "src/libcore/io.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7803488a43eb24864105506b3825f605bc87d693/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7803488a43eb24864105506b3825f605bc87d693/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=7803488a43eb24864105506b3825f605bc87d693", "patch": "@@ -503,7 +503,7 @@ fn u64_from_be_bytes(data: [u8], start: uint, size: uint) -> u64 {\n impl writer_util for writer {\n     fn write_char(ch: char) {\n         if ch as uint < 128u {\n-            self.write([ch as u8]);\n+            self.write([ch as u8]/&);\n         } else {\n             self.write_str(str::from_char(ch));\n         }\n@@ -513,9 +513,12 @@ impl writer_util for writer {\n         self.write_str(s);\n         self.write_str(\"\\n\"/&);\n     }\n-    fn write_int(n: int) { self.write_str(int::to_str(n, 10u)); }\n-    fn write_uint(n: uint) { self.write_str(uint::to_str(n, 10u)); }\n-\n+    fn write_int(n: int) {\n+        int::to_str_bytes(n, 10u) {|buf| self.write(buf) }\n+    }\n+    fn write_uint(n: uint) {\n+        uint::to_str_bytes(false, n, 10u) {|buf| self.write(buf) }\n+    }\n     fn write_le_uint(n: uint, size: uint) {\n         u64_to_le_bytes(n as u64, size) {|v| self.write(v); }\n     }"}, {"sha": "a63d01e6e8e08c45ffdb1b7954ec2cbc38678321", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 68, "deletions": 24, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7803488a43eb24864105506b3825f605bc87d693/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7803488a43eb24864105506b3825f605bc87d693/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=7803488a43eb24864105506b3825f605bc87d693", "patch": "@@ -8,7 +8,8 @@ export is_positive, is_negative;\n export is_nonpositive, is_nonnegative;\n export range;\n export compl;\n-export to_str, from_str, from_str_radix, str, parse_buf;\n+export to_str, to_str_bytes;\n+export from_str, from_str_radix, str, parse_buf;\n \n const min_value: T = 0 as T;\n const max_value: T = 0 as T - 1 as T;\n@@ -102,10 +103,19 @@ Convert to a string in a given base\n \n Fails if `radix` < 2 or `radix` > 16\n \"]\n-fn to_str(num: T, radix: uint) -> str {\n-    assert (1u < radix && radix <= 16u);\n-    let mut n = num;\n-    let radix = radix as T;\n+fn to_str(num: T, radix: uint) -> str unsafe {\n+    to_str_bytes(false, num, radix) {|slice|\n+        vec::unpack_slice(slice) {|p, len|\n+            str::unsafe::from_buf_len(p, len)\n+        }\n+    }\n+}\n+\n+#[doc = \"Low-level helper routine for string conversion.\"]\n+fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n+                   f: fn([u8]/&) -> U) -> U unsafe {\n+\n+    #[inline(always)]\n     fn digit(n: T) -> u8 {\n         if n <= 9u as T {\n             n as u8 + '0' as u8\n@@ -115,36 +125,70 @@ fn to_str(num: T, radix: uint) -> str {\n             fail;\n         }\n     }\n-    if n == 0u as T { ret \"0\"; }\n \n-    let mut buf: [mut u8] = [mut];\n-    vec::reserve(buf, 20u); // Enough room to hold any number\n+    assert (1u < radix && radix <= 16u);\n \n-    while n != 0u as T {\n-        buf += [digit(n % radix)];\n-        n /= radix;\n-    }\n+    // Enough room to hold any number in any radix.\n+    // Worst case: 64-bit number, binary-radix, with\n+    // a leading negative sign = 65 bytes.\n+    let buf : [mut u8]/65 =\n+        [mut\n+         0u8,0u8,0u8,0u8,0u8, 0u8,0u8,0u8,0u8,0u8,\n+         0u8,0u8,0u8,0u8,0u8, 0u8,0u8,0u8,0u8,0u8,\n+\n+         0u8,0u8,0u8,0u8,0u8, 0u8,0u8,0u8,0u8,0u8,\n+         0u8,0u8,0u8,0u8,0u8, 0u8,0u8,0u8,0u8,0u8,\n+\n+         0u8,0u8,0u8,0u8,0u8, 0u8,0u8,0u8,0u8,0u8,\n+         0u8,0u8,0u8,0u8,0u8, 0u8,0u8,0u8,0u8,0u8,\n+\n+         0u8,0u8,0u8,0u8,0u8\n+         ]/65;\n+\n+    // FIXME: post-snapshot, you can do this without\n+    // the raw pointers and unsafe bits, and the\n+    // codegen will prove it's all in-bounds, no\n+    // extra cost.\n+\n+    vec::unpack_slice(buf) {|p, len|\n+        let mp = p as *mut u8;\n+        let mut i = len;\n+        let mut n = num;\n+        let radix = radix as T;\n+        loop {\n+            i -= 1u;\n+            assert 0u < i && i < len;\n+            *ptr::mut_offset(mp, i) = digit(n % radix);\n+            n /= radix;\n+            if n == 0 as T { break; }\n+        }\n \n-    buf += [0u8];\n+        assert 0u < i && i < len;\n \n-    let mut start_idx = 0u;\n-    let mut end_idx = buf.len() - 2u;\n-    while start_idx < end_idx {\n-        vec::swap(buf, start_idx, end_idx);\n-        start_idx += 1u;\n-        end_idx -= 1u;\n-    }\n+        if neg {\n+            i -= 1u;\n+            *ptr::mut_offset(mp, i) = '-' as u8;\n+        }\n \n-    unsafe {\n-        let s = unsafe::reinterpret_cast(buf);\n-        unsafe::forget(buf);\n-        ret s;\n+        vec::unsafe::form_slice(ptr::offset(p, i),\n+                                len - i, f)\n     }\n }\n \n #[doc = \"Convert to a string\"]\n fn str(i: T) -> str { ret to_str(i, 10u); }\n \n+#[test]\n+fn test_to_str() {\n+    assert to_str(0 as T, 10u) == \"0\";\n+    assert to_str(1 as T, 10u) == \"1\";\n+    assert to_str(2 as T, 10u) == \"2\";\n+    assert to_str(11 as T, 10u) == \"11\";\n+    assert to_str(11 as T, 16u) == \"b\";\n+    assert to_str(255 as T, 16u) == \"ff\";\n+    assert to_str(0xff as T, 10u) == \"255\";\n+}\n+\n #[test]\n #[ignore]\n fn test_from_str() {"}]}