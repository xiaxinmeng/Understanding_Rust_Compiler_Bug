{"sha": "69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "node_id": "C_kwDOAAsO6NoAKDY5ZGYwZjJjMmY2NjVkN2Y0ZTM4YTM1NzlhODFkNGVmYzBkODEwMzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-28T10:39:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-28T10:39:47Z"}, "message": "Auto merge of #102991 - Sp00ph:master, r=scottmcm\n\nUpdate VecDeque implementation to use head+len instead of head+tail\n\n(See #99805)\n\nThis changes `alloc::collections::VecDeque`'s internal representation from using head and tail indices to using a head index and a length field. It has a few advantages over the current design:\n* It allows the buffer to be of length 0, which means the `VecDeque::new` new longer has to allocate and could be changed to a `const fn`\n* It allows the `VecDeque` to fill the buffer completely, unlike the old implementation, which always had to leave a free space\n* It removes the restriction for the size to be a power of two, allowing it to properly `shrink_to_fit`, unlike the old `VecDeque`\n* The above points also combine to allow the `Vec<T> -> VecDeque<T>` conversion to be very cheap and guaranteed O(1). I mention this in the `From<Vec<T>>` impl, but it's not a strong guarantee just yet, as that would likely need some form of API change proposal.\n\nAll the tests seem to pass for the new `VecDeque`, with some slight adjustments.\n\nr? `@scottmcm`", "tree": {"sha": "199e0c08da4797bc751be3c286ff9937fa64e52b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/199e0c08da4797bc751be3c286ff9937fa64e52b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "html_url": "https://github.com/rust-lang/rust/commit/69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd12cd6dc631b5e964d541d370ca863c2242376c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd12cd6dc631b5e964d541d370ca863c2242376c", "html_url": "https://github.com/rust-lang/rust/commit/dd12cd6dc631b5e964d541d370ca863c2242376c"}, {"sha": "b1c3c6380f5293b57cd2073908c84f2e270238ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1c3c6380f5293b57cd2073908c84f2e270238ca", "html_url": "https://github.com/rust-lang/rust/commit/b1c3c6380f5293b57cd2073908c84f2e270238ca"}], "stats": {"total": 2256, "additions": 948, "deletions": 1308}, "files": [{"sha": "89feb361ddc116d2885e7c948ced45a27af6a211", "filename": "library/alloc/src/collections/vec_deque/drain.rs", "status": "modified", "additions": 128, "deletions": 65, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -1,12 +1,12 @@\n-use core::fmt;\n use core::iter::FusedIterator;\n use core::marker::PhantomData;\n-use core::mem::{self, MaybeUninit};\n-use core::ptr::{self, NonNull};\n+use core::mem::{self, SizedTypeProperties};\n+use core::ptr::NonNull;\n+use core::{fmt, ptr};\n \n use crate::alloc::{Allocator, Global};\n \n-use super::{count, wrap_index, VecDeque};\n+use super::VecDeque;\n \n /// A draining iterator over the elements of a `VecDeque`.\n ///\n@@ -20,38 +20,81 @@ pub struct Drain<\n     T: 'a,\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n > {\n-    after_tail: usize,\n-    after_head: usize,\n-    ring: NonNull<[T]>,\n-    tail: usize,\n-    head: usize,\n+    // We can't just use a &mut VecDeque<T, A>, as that would make Drain invariant over T\n+    // and we want it to be covariant instead\n     deque: NonNull<VecDeque<T, A>>,\n-    _phantom: PhantomData<&'a T>,\n+    // drain_start is stored in deque.len\n+    drain_len: usize,\n+    // index into the logical array, not the physical one (always lies in [0..deque.len))\n+    idx: usize,\n+    // number of elements after the drain range\n+    tail_len: usize,\n+    remaining: usize,\n+    // Needed to make Drain covariant over T\n+    _marker: PhantomData<&'a T>,\n }\n \n impl<'a, T, A: Allocator> Drain<'a, T, A> {\n     pub(super) unsafe fn new(\n-        after_tail: usize,\n-        after_head: usize,\n-        ring: &'a [MaybeUninit<T>],\n-        tail: usize,\n-        head: usize,\n-        deque: NonNull<VecDeque<T, A>>,\n+        deque: &'a mut VecDeque<T, A>,\n+        drain_start: usize,\n+        drain_len: usize,\n     ) -> Self {\n-        let ring = unsafe { NonNull::new_unchecked(ring as *const [MaybeUninit<T>] as *mut _) };\n-        Drain { after_tail, after_head, ring, tail, head, deque, _phantom: PhantomData }\n+        let orig_len = mem::replace(&mut deque.len, drain_start);\n+        let tail_len = orig_len - drain_start - drain_len;\n+        Drain {\n+            deque: NonNull::from(deque),\n+            drain_len,\n+            idx: drain_start,\n+            tail_len,\n+            remaining: drain_len,\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    // Only returns pointers to the slices, as that's\n+    // all we need to drop them. May only be called if `self.remaining != 0`.\n+    unsafe fn as_slices(&self) -> (*mut [T], *mut [T]) {\n+        unsafe {\n+            let deque = self.deque.as_ref();\n+            // FIXME: This is doing almost exactly the same thing as the else branch in `VecDeque::slice_ranges`.\n+            // Unfortunately, we can't just call `slice_ranges` here, as the deque's `len` is currently\n+            // just `drain_start`, so the range check would (almost) always panic. Between temporarily\n+            // adjusting the deques `len` to call `slice_ranges`, and just copy pasting the `slice_ranges`\n+            // implementation, this seemed like the less hacky solution, though it might be good to\n+            // find a better one in the future.\n+\n+            // because `self.remaining != 0`, we know that `self.idx < deque.original_len`, so it's a valid\n+            // logical index.\n+            let wrapped_start = deque.to_physical_idx(self.idx);\n+\n+            let head_len = deque.capacity() - wrapped_start;\n+\n+            let (a_range, b_range) = if head_len >= self.remaining {\n+                (wrapped_start..wrapped_start + self.remaining, 0..0)\n+            } else {\n+                let tail_len = self.remaining - head_len;\n+                (wrapped_start..deque.capacity(), 0..tail_len)\n+            };\n+\n+            // SAFETY: the range `self.idx..self.idx+self.remaining` lies strictly inside\n+            // the range `0..deque.original_len`. because of this, and because of the fact\n+            // that we acquire `a_range` and `b_range` exactly like `slice_ranges` would,\n+            // it's guaranteed that `a_range` and `b_range` represent valid ranges into\n+            // the deques buffer.\n+            (deque.buffer_range(a_range), deque.buffer_range(b_range))\n+        }\n     }\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Drain\")\n-            .field(&self.after_tail)\n-            .field(&self.after_head)\n-            .field(&self.ring)\n-            .field(&self.tail)\n-            .field(&self.head)\n+            .field(&self.drain_len)\n+            .field(&self.idx)\n+            .field(&self.tail_len)\n+            .field(&self.remaining)\n             .finish()\n     }\n }\n@@ -68,57 +111,81 @@ impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n \n         impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n             fn drop(&mut self) {\n-                self.0.for_each(drop);\n+                if self.0.remaining != 0 {\n+                    unsafe {\n+                        // SAFETY: We just checked that `self.remaining != 0`.\n+                        let (front, back) = self.0.as_slices();\n+                        ptr::drop_in_place(front);\n+                        ptr::drop_in_place(back);\n+                    }\n+                }\n \n                 let source_deque = unsafe { self.0.deque.as_mut() };\n \n-                // T = source_deque_tail; H = source_deque_head; t = drain_tail; h = drain_head\n-                //\n-                //        T   t   h   H\n-                // [. . . o o x x o o . . .]\n-                //\n-                let orig_tail = source_deque.tail;\n-                let drain_tail = source_deque.head;\n-                let drain_head = self.0.after_tail;\n-                let orig_head = self.0.after_head;\n+                let drain_start = source_deque.len();\n+                let drain_len = self.0.drain_len;\n+                let drain_end = drain_start + drain_len;\n+\n+                let orig_len = self.0.tail_len + drain_end;\n \n-                let tail_len = count(orig_tail, drain_tail, source_deque.cap());\n-                let head_len = count(drain_head, orig_head, source_deque.cap());\n+                if T::IS_ZST {\n+                    // no need to copy around any memory if T is a ZST\n+                    source_deque.len = orig_len - drain_len;\n+                    return;\n+                }\n \n-                // Restore the original head value\n-                source_deque.head = orig_head;\n+                let head_len = drain_start;\n+                let tail_len = self.0.tail_len;\n \n-                match (tail_len, head_len) {\n+                match (head_len, tail_len) {\n                     (0, 0) => {\n                         source_deque.head = 0;\n-                        source_deque.tail = 0;\n+                        source_deque.len = 0;\n                     }\n                     (0, _) => {\n-                        source_deque.tail = drain_head;\n+                        source_deque.head = source_deque.to_physical_idx(drain_len);\n+                        source_deque.len = orig_len - drain_len;\n                     }\n                     (_, 0) => {\n-                        source_deque.head = drain_tail;\n+                        source_deque.len = orig_len - drain_len;\n                     }\n                     _ => unsafe {\n-                        if tail_len <= head_len {\n-                            source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n-                            source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n+                        if head_len <= tail_len {\n+                            source_deque.wrap_copy(\n+                                source_deque.head,\n+                                source_deque.to_physical_idx(drain_len),\n+                                head_len,\n+                            );\n+                            source_deque.head = source_deque.to_physical_idx(drain_len);\n+                            source_deque.len = orig_len - drain_len;\n                         } else {\n-                            source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n-                            source_deque.wrap_copy(drain_tail, drain_head, head_len);\n+                            source_deque.wrap_copy(\n+                                source_deque.to_physical_idx(head_len + drain_len),\n+                                source_deque.to_physical_idx(head_len),\n+                                tail_len,\n+                            );\n+                            source_deque.len = orig_len - drain_len;\n                         }\n                     },\n                 }\n             }\n         }\n \n-        while let Some(item) = self.next() {\n-            let guard = DropGuard(self);\n-            drop(item);\n-            mem::forget(guard);\n+        let guard = DropGuard(self);\n+        if guard.0.remaining != 0 {\n+            unsafe {\n+                // SAFETY: We just checked that `self.remaining != 0`.\n+                let (front, back) = guard.0.as_slices();\n+                // since idx is a logical index, we don't need to worry about wrapping.\n+                guard.0.idx += front.len();\n+                guard.0.remaining -= front.len();\n+                ptr::drop_in_place(front);\n+                guard.0.remaining = 0;\n+                ptr::drop_in_place(back);\n+            }\n         }\n \n-        DropGuard(self);\n+        // Dropping `guard` handles moving the remaining elements into place.\n     }\n }\n \n@@ -128,20 +195,18 @@ impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        if self.tail == self.head {\n+        if self.remaining == 0 {\n             return None;\n         }\n-        let tail = self.tail;\n-        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n-        // Safety:\n-        // - `self.tail` in a ring buffer is always a valid index.\n-        // - `self.head` and `self.tail` equality is checked above.\n-        unsafe { Some(ptr::read(self.ring.as_ptr().get_unchecked_mut(tail))) }\n+        let wrapped_idx = unsafe { self.deque.as_ref().to_physical_idx(self.idx) };\n+        self.idx += 1;\n+        self.remaining -= 1;\n+        Some(unsafe { self.deque.as_mut().buffer_read(wrapped_idx) })\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = count(self.tail, self.head, self.ring.len());\n+        let len = self.remaining;\n         (len, Some(len))\n     }\n }\n@@ -150,14 +215,12 @@ impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n-        if self.tail == self.head {\n+        if self.remaining == 0 {\n             return None;\n         }\n-        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n-        // Safety:\n-        // - `self.head` in a ring buffer is always a valid index.\n-        // - `self.head` and `self.tail` equality is checked above.\n-        unsafe { Some(ptr::read(self.ring.as_ptr().get_unchecked_mut(self.head))) }\n+        self.remaining -= 1;\n+        let wrapped_idx = unsafe { self.deque.as_ref().to_physical_idx(self.idx + self.remaining) };\n+        Some(unsafe { self.deque.as_mut().buffer_read(wrapped_idx) })\n     }\n }\n "}, {"sha": "d9f3937144d04c0c9d51ba7c3e9f2b1729679f86", "filename": "library/alloc/src/collections/vec_deque/iter.rs", "status": "modified", "additions": 70, "deletions": 108, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter.rs?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -1,9 +1,6 @@\n-use core::fmt;\n use core::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n-use core::mem::MaybeUninit;\n use core::ops::Try;\n-\n-use super::{count, wrap_index, RingSlices};\n+use core::{fmt, mem, slice};\n \n /// An iterator over the elements of a `VecDeque`.\n ///\n@@ -13,38 +10,28 @@ use super::{count, wrap_index, RingSlices};\n /// [`iter`]: super::VecDeque::iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    ring: &'a [MaybeUninit<T>],\n-    tail: usize,\n-    head: usize,\n+    i1: slice::Iter<'a, T>,\n+    i2: slice::Iter<'a, T>,\n }\n \n impl<'a, T> Iter<'a, T> {\n-    pub(super) fn new(ring: &'a [MaybeUninit<T>], tail: usize, head: usize) -> Self {\n-        Iter { ring, tail, head }\n+    pub(super) fn new(i1: slice::Iter<'a, T>, i2: slice::Iter<'a, T>) -> Self {\n+        Self { i1, i2 }\n     }\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // Safety:\n-        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            f.debug_tuple(\"Iter\")\n-                .field(&MaybeUninit::slice_assume_init_ref(front))\n-                .field(&MaybeUninit::slice_assume_init_ref(back))\n-                .finish()\n-        }\n+        f.debug_tuple(\"Iter\").field(&self.i1.as_slice()).field(&self.i2.as_slice()).finish()\n     }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Iter<'_, T> {\n     fn clone(&self) -> Self {\n-        Iter { ring: self.ring, tail: self.tail, head: self.head }\n+        Iter { i1: self.i1.clone(), i2: self.i2.clone() }\n     }\n }\n \n@@ -54,72 +41,50 @@ impl<'a, T> Iterator for Iter<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n-        if self.tail == self.head {\n-            return None;\n+        match self.i1.next() {\n+            Some(val) => Some(val),\n+            None => {\n+                // most of the time, the iterator will either always\n+                // call next(), or always call next_back(). By swapping\n+                // the iterators once the first one is empty, we ensure\n+                // that the first branch is taken as often as possible,\n+                // without sacrificing correctness, as i1 is empty anyways\n+                mem::swap(&mut self.i1, &mut self.i2);\n+                self.i1.next()\n+            }\n         }\n-        let tail = self.tail;\n-        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n-        // Safety:\n-        // - `self.tail` in a ring buffer is always a valid index.\n-        // - `self.head` and `self.tail` equality is checked above.\n-        unsafe { Some(self.ring.get_unchecked(tail).assume_init_ref()) }\n+    }\n+\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let m = match self.i1.advance_by(n) {\n+            Ok(_) => return Ok(()),\n+            Err(m) => m,\n+        };\n+        mem::swap(&mut self.i1, &mut self.i2);\n+        self.i1.advance_by(n - m).map_err(|o| o + m)\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = count(self.tail, self.head, self.ring.len());\n+        let len = self.len();\n         (len, Some(len))\n     }\n \n-    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, accum: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // Safety:\n-        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            accum = MaybeUninit::slice_assume_init_ref(front).iter().fold(accum, &mut f);\n-            MaybeUninit::slice_assume_init_ref(back).iter().fold(accum, &mut f)\n-        }\n+        let accum = self.i1.fold(accum, &mut f);\n+        self.i2.fold(accum, &mut f)\n     }\n \n     fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n     where\n-        Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n-        let (mut iter, final_res);\n-        if self.tail <= self.head {\n-            // Safety: single slice self.ring[self.tail..self.head] is initialized.\n-            iter = unsafe { MaybeUninit::slice_assume_init_ref(&self.ring[self.tail..self.head]) }\n-                .iter();\n-            final_res = iter.try_fold(init, &mut f);\n-        } else {\n-            // Safety: two slices: self.ring[self.tail..], self.ring[..self.head] both are initialized.\n-            let (front, back) = self.ring.split_at(self.tail);\n-\n-            let mut back_iter = unsafe { MaybeUninit::slice_assume_init_ref(back).iter() };\n-            let res = back_iter.try_fold(init, &mut f);\n-            let len = self.ring.len();\n-            self.tail = (self.ring.len() - back_iter.len()) & (len - 1);\n-            iter = unsafe { MaybeUninit::slice_assume_init_ref(&front[..self.head]).iter() };\n-            final_res = iter.try_fold(res?, &mut f);\n-        }\n-        self.tail = self.head - iter.len();\n-        final_res\n-    }\n-\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        if n >= count(self.tail, self.head, self.ring.len()) {\n-            self.tail = self.head;\n-            None\n-        } else {\n-            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n-            self.next()\n-        }\n+        let acc = self.i1.try_fold(init, &mut f)?;\n+        self.i2.try_fold(acc, &mut f)\n     }\n \n     #[inline]\n@@ -132,8 +97,12 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         // Safety: The TrustedRandomAccess contract requires that callers only pass an index\n         // that is in bounds.\n         unsafe {\n-            let idx = wrap_index(self.tail.wrapping_add(idx), self.ring.len());\n-            self.ring.get_unchecked(idx).assume_init_ref()\n+            let i1_len = self.i1.len();\n+            if idx < i1_len {\n+                self.i1.__iterator_get_unchecked(idx)\n+            } else {\n+                self.i2.__iterator_get_unchecked(idx - i1_len)\n+            }\n         }\n     }\n }\n@@ -142,63 +111,56 @@ impl<'a, T> Iterator for Iter<'a, T> {\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n-        if self.tail == self.head {\n-            return None;\n+        match self.i2.next_back() {\n+            Some(val) => Some(val),\n+            None => {\n+                // most of the time, the iterator will either always\n+                // call next(), or always call next_back(). By swapping\n+                // the iterators once the second one is empty, we ensure\n+                // that the first branch is taken as often as possible,\n+                // without sacrificing correctness, as i2 is empty anyways\n+                mem::swap(&mut self.i1, &mut self.i2);\n+                self.i2.next_back()\n+            }\n         }\n-        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n-        // Safety:\n-        // - `self.head` in a ring buffer is always a valid index.\n-        // - `self.head` and `self.tail` equality is checked above.\n-        unsafe { Some(self.ring.get_unchecked(self.head).assume_init_ref()) }\n     }\n \n-    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let m = match self.i2.advance_back_by(n) {\n+            Ok(_) => return Ok(()),\n+            Err(m) => m,\n+        };\n+\n+        mem::swap(&mut self.i1, &mut self.i2);\n+        self.i2.advance_back_by(n - m).map_err(|o| m + o)\n+    }\n+\n+    fn rfold<Acc, F>(self, accum: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // Safety:\n-        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            accum = MaybeUninit::slice_assume_init_ref(back).iter().rfold(accum, &mut f);\n-            MaybeUninit::slice_assume_init_ref(front).iter().rfold(accum, &mut f)\n-        }\n+        let accum = self.i2.rfold(accum, &mut f);\n+        self.i1.rfold(accum, &mut f)\n     }\n \n     fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n     where\n-        Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n-        let (mut iter, final_res);\n-        if self.tail <= self.head {\n-            // Safety: single slice self.ring[self.tail..self.head] is initialized.\n-            iter = unsafe {\n-                MaybeUninit::slice_assume_init_ref(&self.ring[self.tail..self.head]).iter()\n-            };\n-            final_res = iter.try_rfold(init, &mut f);\n-        } else {\n-            // Safety: two slices: self.ring[self.tail..], self.ring[..self.head] both are initialized.\n-            let (front, back) = self.ring.split_at(self.tail);\n-\n-            let mut front_iter =\n-                unsafe { MaybeUninit::slice_assume_init_ref(&front[..self.head]).iter() };\n-            let res = front_iter.try_rfold(init, &mut f);\n-            self.head = front_iter.len();\n-            iter = unsafe { MaybeUninit::slice_assume_init_ref(back).iter() };\n-            final_res = iter.try_rfold(res?, &mut f);\n-        }\n-        self.head = self.tail + iter.len();\n-        final_res\n+        let acc = self.i2.try_rfold(init, &mut f)?;\n+        self.i1.try_rfold(acc, &mut f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for Iter<'_, T> {\n+    fn len(&self) -> usize {\n+        self.i1.len() + self.i2.len()\n+    }\n+\n     fn is_empty(&self) -> bool {\n-        self.head == self.tail\n+        self.i1.is_empty() && self.i2.is_empty()\n     }\n }\n "}, {"sha": "2c59d95cd53e9360101d312f477ea452dcd24e75", "filename": "library/alloc/src/collections/vec_deque/iter_mut.rs", "status": "modified", "additions": 80, "deletions": 69, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fiter_mut.rs?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -1,8 +1,6 @@\n-use core::fmt;\n use core::iter::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedRandomAccessNoCoerce};\n-use core::marker::PhantomData;\n-\n-use super::{count, wrap_index, RingSlices};\n+use core::ops::Try;\n+use core::{fmt, mem, slice};\n \n /// A mutable iterator over the elements of a `VecDeque`.\n ///\n@@ -12,39 +10,20 @@ use super::{count, wrap_index, RingSlices};\n /// [`iter_mut`]: super::VecDeque::iter_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n-    // Internal safety invariant: the entire slice is dereferenceable.\n-    ring: *mut [T],\n-    tail: usize,\n-    head: usize,\n-    phantom: PhantomData<&'a mut [T]>,\n+    i1: slice::IterMut<'a, T>,\n+    i2: slice::IterMut<'a, T>,\n }\n \n impl<'a, T> IterMut<'a, T> {\n-    pub(super) unsafe fn new(\n-        ring: *mut [T],\n-        tail: usize,\n-        head: usize,\n-        phantom: PhantomData<&'a mut [T]>,\n-    ) -> Self {\n-        IterMut { ring, tail, head, phantom }\n+    pub(super) fn new(i1: slice::IterMut<'a, T>, i2: slice::IterMut<'a, T>) -> Self {\n+        Self { i1, i2 }\n     }\n }\n \n-// SAFETY: we do nothing thread-local and there is no interior mutability,\n-// so the usual structural `Send`/`Sync` apply.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for IterMut<'_, T> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n-\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n-        // The `IterMut` invariant also ensures everything is dereferenceable.\n-        let (front, back) = unsafe { (&*front, &*back) };\n-        f.debug_tuple(\"IterMut\").field(&front).field(&back).finish()\n+        f.debug_tuple(\"IterMut\").field(&self.i1.as_slice()).field(&self.i2.as_slice()).finish()\n     }\n }\n \n@@ -54,44 +33,50 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> {\n-        if self.tail == self.head {\n-            return None;\n+        match self.i1.next() {\n+            Some(val) => Some(val),\n+            None => {\n+                // most of the time, the iterator will either always\n+                // call next(), or always call next_back(). By swapping\n+                // the iterators once the first one is empty, we ensure\n+                // that the first branch is taken as often as possible,\n+                // without sacrificing correctness, as i1 is empty anyways\n+                mem::swap(&mut self.i1, &mut self.i2);\n+                self.i1.next()\n+            }\n         }\n-        let tail = self.tail;\n-        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n+    }\n \n-        unsafe {\n-            let elem = self.ring.get_unchecked_mut(tail);\n-            Some(&mut *elem)\n-        }\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let m = match self.i1.advance_by(n) {\n+            Ok(_) => return Ok(()),\n+            Err(m) => m,\n+        };\n+        mem::swap(&mut self.i1, &mut self.i2);\n+        self.i1.advance_by(n - m).map_err(|o| o + m)\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = count(self.tail, self.head, self.ring.len());\n+        let len = self.len();\n         (len, Some(len))\n     }\n \n-    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, accum: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n-        // The `IterMut` invariant also ensures everything is dereferenceable.\n-        let (front, back) = unsafe { (&mut *front, &mut *back) };\n-        accum = front.iter_mut().fold(accum, &mut f);\n-        back.iter_mut().fold(accum, &mut f)\n+        let accum = self.i1.fold(accum, &mut f);\n+        self.i2.fold(accum, &mut f)\n     }\n \n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        if n >= count(self.tail, self.head, self.ring.len()) {\n-            self.tail = self.head;\n-            None\n-        } else {\n-            self.tail = wrap_index(self.tail.wrapping_add(n), self.ring.len());\n-            self.next()\n-        }\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        let acc = self.i1.try_fold(init, &mut f)?;\n+        self.i2.try_fold(acc, &mut f)\n     }\n \n     #[inline]\n@@ -104,8 +89,12 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         // Safety: The TrustedRandomAccess contract requires that callers only pass an index\n         // that is in bounds.\n         unsafe {\n-            let idx = wrap_index(self.tail.wrapping_add(idx), self.ring.len());\n-            &mut *self.ring.get_unchecked_mut(idx)\n+            let i1_len = self.i1.len();\n+            if idx < i1_len {\n+                self.i1.__iterator_get_unchecked(idx)\n+            } else {\n+                self.i2.__iterator_get_unchecked(idx - i1_len)\n+            }\n         }\n     }\n }\n@@ -114,34 +103,56 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n-        if self.tail == self.head {\n-            return None;\n+        match self.i2.next_back() {\n+            Some(val) => Some(val),\n+            None => {\n+                // most of the time, the iterator will either always\n+                // call next(), or always call next_back(). By swapping\n+                // the iterators once the first one is empty, we ensure\n+                // that the first branch is taken as often as possible,\n+                // without sacrificing correctness, as i2 is empty anyways\n+                mem::swap(&mut self.i1, &mut self.i2);\n+                self.i2.next_back()\n+            }\n         }\n-        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n+    }\n \n-        unsafe {\n-            let elem = self.ring.get_unchecked_mut(self.head);\n-            Some(&mut *elem)\n-        }\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let m = match self.i2.advance_back_by(n) {\n+            Ok(_) => return Ok(()),\n+            Err(m) => m,\n+        };\n+\n+        mem::swap(&mut self.i1, &mut self.i2);\n+        self.i2.advance_back_by(n - m).map_err(|o| m + o)\n     }\n \n-    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+    fn rfold<Acc, F>(self, accum: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n-        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n-        // The `IterMut` invariant also ensures everything is dereferenceable.\n-        let (front, back) = unsafe { (&mut *front, &mut *back) };\n-        accum = back.iter_mut().rfold(accum, &mut f);\n-        front.iter_mut().rfold(accum, &mut f)\n+        let accum = self.i2.rfold(accum, &mut f);\n+        self.i1.rfold(accum, &mut f)\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        let acc = self.i2.try_rfold(init, &mut f)?;\n+        self.i1.try_rfold(acc, &mut f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IterMut<'_, T> {\n+    fn len(&self) -> usize {\n+        self.i1.len() + self.i2.len()\n+    }\n+\n     fn is_empty(&self) -> bool {\n-        self.head == self.tail\n+        self.i1.is_empty() && self.i2.is_empty()\n     }\n }\n "}, {"sha": "86d77182bccee7800cf0875f1436c68eab4d226b", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 492, "deletions": 766, "changes": 1258, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -10,11 +10,10 @@\n use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::iter::{repeat_n, repeat_with, FromIterator};\n-use core::marker::PhantomData;\n-use core::mem::{ManuallyDrop, MaybeUninit, SizedTypeProperties};\n+use core::iter::{repeat_n, repeat_with, ByRefSized, FromIterator};\n+use core::mem::{ManuallyDrop, SizedTypeProperties};\n use core::ops::{Index, IndexMut, Range, RangeBounds};\n-use core::ptr::{self, NonNull};\n+use core::ptr;\n use core::slice;\n \n // This is used in a bunch of intra-doc links.\n@@ -52,26 +51,13 @@ pub use self::iter::Iter;\n \n mod iter;\n \n-use self::pair_slices::PairSlices;\n-\n-mod pair_slices;\n-\n-use self::ring_slices::RingSlices;\n-\n-mod ring_slices;\n-\n use self::spec_extend::SpecExtend;\n \n mod spec_extend;\n \n #[cfg(test)]\n mod tests;\n \n-const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n-const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n-\n-const MAXIMUM_ZST_CAPACITY: usize = 1 << (usize::BITS - 1); // Largest possible power of two\n-\n /// A double-ended queue implemented with a growable ring buffer.\n ///\n /// The \"default\" usage of this type as a queue is to use [`push_back`] to add to\n@@ -105,13 +91,13 @@ pub struct VecDeque<\n     T,\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n > {\n-    // tail and head are pointers into the buffer. Tail always points\n-    // to the first element that could be read, Head always points\n-    // to where data should be written.\n-    // If tail == head the buffer is empty. The length of the ringbuffer\n-    // is defined as the distance between the two.\n-    tail: usize,\n+    // `self[0]`, if it exists, is `buf[head]`.\n+    // `head < buf.capacity()`, unless `buf.capacity() == 0` when `head == 0`.\n     head: usize,\n+    // the number of initialized elements, starting from the one at `head` and potentially wrapping around.\n+    // if `len == 0`, the exact value of `head` is unimportant.\n+    // if `T` is zero-Sized, then `self.len <= usize::MAX`, otherwise `self.len <= isize::MAX as usize`.\n+    len: usize,\n     buf: RawVec<T, A>,\n }\n \n@@ -124,18 +110,8 @@ impl<T: Clone, A: Allocator + Clone> Clone for VecDeque<T, A> {\n     }\n \n     fn clone_from(&mut self, other: &Self) {\n-        self.truncate(other.len());\n-\n-        let mut iter = PairSlices::from(self, other);\n-        while let Some((dst, src)) = iter.next() {\n-            dst.clone_from_slice(&src);\n-        }\n-\n-        if iter.has_remainder() {\n-            for remainder in iter.remainder() {\n-                self.extend(remainder.iter().cloned());\n-            }\n-        }\n+        self.clear();\n+        self.extend(other.iter().cloned());\n     }\n }\n \n@@ -180,41 +156,6 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.buf.ptr()\n     }\n \n-    /// Marginally more convenient\n-    #[inline]\n-    fn cap(&self) -> usize {\n-        if T::IS_ZST {\n-            // For zero sized types, we are always at maximum capacity\n-            MAXIMUM_ZST_CAPACITY\n-        } else {\n-            self.buf.capacity()\n-        }\n-    }\n-\n-    /// Turn ptr into a slice, since the elements of the backing buffer may be uninitialized,\n-    /// we will return a slice of [`MaybeUninit<T>`].\n-    ///\n-    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and\n-    /// incorrect usage of this method.\n-    ///\n-    /// [zeroed]: mem::MaybeUninit::zeroed\n-    #[inline]\n-    unsafe fn buffer_as_slice(&self) -> &[MaybeUninit<T>] {\n-        unsafe { slice::from_raw_parts(self.ptr() as *mut MaybeUninit<T>, self.cap()) }\n-    }\n-\n-    /// Turn ptr into a mut slice, since the elements of the backing buffer may be uninitialized,\n-    /// we will return a slice of [`MaybeUninit<T>`].\n-    ///\n-    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and\n-    /// incorrect usage of this method.\n-    ///\n-    /// [zeroed]: mem::MaybeUninit::zeroed\n-    #[inline]\n-    unsafe fn buffer_as_mut_slice(&mut self) -> &mut [MaybeUninit<T>] {\n-        unsafe { slice::from_raw_parts_mut(self.ptr() as *mut MaybeUninit<T>, self.cap()) }\n-    }\n-\n     /// Moves an element out of the buffer\n     #[inline]\n     unsafe fn buffer_read(&mut self, off: usize) -> T {\n@@ -229,51 +170,58 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Returns `true` if the buffer is at full capacity.\n+    /// Returns a slice pointer into the buffer.\n+    /// `range` must lie inside `0..self.capacity()`.\n     #[inline]\n-    fn is_full(&self) -> bool {\n-        self.cap() - self.len() == 1\n+    unsafe fn buffer_range(&self, range: Range<usize>) -> *mut [T] {\n+        unsafe {\n+            ptr::slice_from_raw_parts_mut(self.ptr().add(range.start), range.end - range.start)\n+        }\n     }\n \n-    /// Returns the index in the underlying buffer for a given logical element\n-    /// index.\n+    /// Returns `true` if the buffer is at full capacity.\n     #[inline]\n-    fn wrap_index(&self, idx: usize) -> usize {\n-        wrap_index(idx, self.cap())\n+    fn is_full(&self) -> bool {\n+        self.len == self.capacity()\n     }\n \n     /// Returns the index in the underlying buffer for a given logical element\n     /// index + addend.\n     #[inline]\n     fn wrap_add(&self, idx: usize, addend: usize) -> usize {\n-        wrap_index(idx.wrapping_add(addend), self.cap())\n+        wrap_index(idx.wrapping_add(addend), self.capacity())\n+    }\n+\n+    #[inline]\n+    fn to_physical_idx(&self, idx: usize) -> usize {\n+        self.wrap_add(self.head, idx)\n     }\n \n     /// Returns the index in the underlying buffer for a given logical element\n     /// index - subtrahend.\n     #[inline]\n     fn wrap_sub(&self, idx: usize, subtrahend: usize) -> usize {\n-        wrap_index(idx.wrapping_sub(subtrahend), self.cap())\n+        wrap_index(idx.wrapping_sub(subtrahend).wrapping_add(self.capacity()), self.capacity())\n     }\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n-    unsafe fn copy(&self, dst: usize, src: usize, len: usize) {\n+    unsafe fn copy(&mut self, src: usize, dst: usize, len: usize) {\n         debug_assert!(\n-            dst + len <= self.cap(),\n+            dst + len <= self.capacity(),\n             \"cpy dst={} src={} len={} cap={}\",\n             dst,\n             src,\n             len,\n-            self.cap()\n+            self.capacity()\n         );\n         debug_assert!(\n-            src + len <= self.cap(),\n+            src + len <= self.capacity(),\n             \"cpy dst={} src={} len={} cap={}\",\n             dst,\n             src,\n             len,\n-            self.cap()\n+            self.capacity()\n         );\n         unsafe {\n             ptr::copy(self.ptr().add(src), self.ptr().add(dst), len);\n@@ -282,53 +230,51 @@ impl<T, A: Allocator> VecDeque<T, A> {\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n-    unsafe fn copy_nonoverlapping(&self, dst: usize, src: usize, len: usize) {\n+    unsafe fn copy_nonoverlapping(&mut self, src: usize, dst: usize, len: usize) {\n         debug_assert!(\n-            dst + len <= self.cap(),\n+            dst + len <= self.capacity(),\n             \"cno dst={} src={} len={} cap={}\",\n             dst,\n             src,\n             len,\n-            self.cap()\n+            self.capacity()\n         );\n         debug_assert!(\n-            src + len <= self.cap(),\n+            src + len <= self.capacity(),\n             \"cno dst={} src={} len={} cap={}\",\n             dst,\n             src,\n             len,\n-            self.cap()\n+            self.capacity()\n         );\n         unsafe {\n             ptr::copy_nonoverlapping(self.ptr().add(src), self.ptr().add(dst), len);\n         }\n     }\n \n     /// Copies a potentially wrapping block of memory len long from src to dest.\n-    /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n+    /// (abs(dst - src) + len) must be no larger than capacity() (There must be at\n     /// most one continuous overlapping region between src and dest).\n-    unsafe fn wrap_copy(&self, dst: usize, src: usize, len: usize) {\n-        #[allow(dead_code)]\n-        fn diff(a: usize, b: usize) -> usize {\n-            if a <= b { b - a } else { a - b }\n-        }\n+    unsafe fn wrap_copy(&mut self, src: usize, dst: usize, len: usize) {\n         debug_assert!(\n-            cmp::min(diff(dst, src), self.cap() - diff(dst, src)) + len <= self.cap(),\n+            cmp::min(src.abs_diff(dst), self.capacity() - src.abs_diff(dst)) + len\n+                <= self.capacity(),\n             \"wrc dst={} src={} len={} cap={}\",\n             dst,\n             src,\n             len,\n-            self.cap()\n+            self.capacity()\n         );\n \n-        if src == dst || len == 0 {\n+        // If T is a ZST, don't do any copying.\n+        if T::IS_ZST || src == dst || len == 0 {\n             return;\n         }\n \n         let dst_after_src = self.wrap_sub(dst, src) < len;\n \n-        let src_pre_wrap_len = self.cap() - src;\n-        let dst_pre_wrap_len = self.cap() - dst;\n+        let src_pre_wrap_len = self.capacity() - src;\n+        let dst_pre_wrap_len = self.capacity() - dst;\n         let src_wraps = src_pre_wrap_len < len;\n         let dst_wraps = dst_pre_wrap_len < len;\n \n@@ -342,7 +288,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 //            D . . .\n                 //\n                 unsafe {\n-                    self.copy(dst, src, len);\n+                    self.copy(src, dst, len);\n                 }\n             }\n             (false, false, true) => {\n@@ -355,8 +301,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 //    . .           D .\n                 //\n                 unsafe {\n-                    self.copy(dst, src, dst_pre_wrap_len);\n-                    self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n+                    self.copy(src, dst, dst_pre_wrap_len);\n+                    self.copy(src + dst_pre_wrap_len, 0, len - dst_pre_wrap_len);\n                 }\n             }\n             (true, false, true) => {\n@@ -369,8 +315,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 //    . .           D .\n                 //\n                 unsafe {\n-                    self.copy(0, src + dst_pre_wrap_len, len - dst_pre_wrap_len);\n-                    self.copy(dst, src, dst_pre_wrap_len);\n+                    self.copy(src + dst_pre_wrap_len, 0, len - dst_pre_wrap_len);\n+                    self.copy(src, dst, dst_pre_wrap_len);\n                 }\n             }\n             (false, true, false) => {\n@@ -383,8 +329,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 //              D . . .\n                 //\n                 unsafe {\n-                    self.copy(dst, src, src_pre_wrap_len);\n-                    self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n+                    self.copy(src, dst, src_pre_wrap_len);\n+                    self.copy(0, dst + src_pre_wrap_len, len - src_pre_wrap_len);\n                 }\n             }\n             (true, true, false) => {\n@@ -397,8 +343,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 //    D . . .\n                 //\n                 unsafe {\n-                    self.copy(dst + src_pre_wrap_len, 0, len - src_pre_wrap_len);\n-                    self.copy(dst, src, src_pre_wrap_len);\n+                    self.copy(0, dst + src_pre_wrap_len, len - src_pre_wrap_len);\n+                    self.copy(src, dst, src_pre_wrap_len);\n                 }\n             }\n             (false, true, true) => {\n@@ -414,9 +360,9 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 debug_assert!(dst_pre_wrap_len > src_pre_wrap_len);\n                 let delta = dst_pre_wrap_len - src_pre_wrap_len;\n                 unsafe {\n-                    self.copy(dst, src, src_pre_wrap_len);\n-                    self.copy(dst + src_pre_wrap_len, 0, delta);\n-                    self.copy(0, delta, len - dst_pre_wrap_len);\n+                    self.copy(src, dst, src_pre_wrap_len);\n+                    self.copy(0, dst + src_pre_wrap_len, delta);\n+                    self.copy(delta, 0, len - dst_pre_wrap_len);\n                 }\n             }\n             (true, true, true) => {\n@@ -432,9 +378,9 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                 debug_assert!(src_pre_wrap_len > dst_pre_wrap_len);\n                 let delta = src_pre_wrap_len - dst_pre_wrap_len;\n                 unsafe {\n-                    self.copy(delta, 0, len - src_pre_wrap_len);\n-                    self.copy(0, self.cap() - delta, delta);\n-                    self.copy(dst, src, dst_pre_wrap_len);\n+                    self.copy(0, delta, len - src_pre_wrap_len);\n+                    self.copy(self.capacity() - delta, 0, delta);\n+                    self.copy(src, dst, dst_pre_wrap_len);\n                 }\n             }\n         }\n@@ -444,8 +390,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// Assumes capacity is sufficient.\n     #[inline]\n     unsafe fn copy_slice(&mut self, dst: usize, src: &[T]) {\n-        debug_assert!(src.len() <= self.cap());\n-        let head_room = self.cap() - dst;\n+        debug_assert!(src.len() <= self.capacity());\n+        let head_room = self.capacity() - dst;\n         if src.len() <= head_room {\n             unsafe {\n                 ptr::copy_nonoverlapping(src.as_ptr(), self.ptr().add(dst), src.len());\n@@ -478,48 +424,100 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         });\n     }\n \n+    /// Writes all values from `iter` to `dst`, wrapping\n+    /// at the end of the buffer and returns the number\n+    /// of written values.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Assumes that `iter` yields at most `len` items.\n+    /// Assumes capacity is sufficient.\n+    unsafe fn write_iter_wrapping(\n+        &mut self,\n+        dst: usize,\n+        mut iter: impl Iterator<Item = T>,\n+        len: usize,\n+    ) -> usize {\n+        struct Guard<'a, T, A: Allocator> {\n+            deque: &'a mut VecDeque<T, A>,\n+            written: usize,\n+        }\n+\n+        impl<'a, T, A: Allocator> Drop for Guard<'a, T, A> {\n+            fn drop(&mut self) {\n+                self.deque.len += self.written;\n+            }\n+        }\n+\n+        let head_room = self.capacity() - dst;\n+\n+        let mut guard = Guard { deque: self, written: 0 };\n+\n+        if head_room >= len {\n+            unsafe { guard.deque.write_iter(dst, iter, &mut guard.written) };\n+        } else {\n+            unsafe {\n+                guard.deque.write_iter(\n+                    dst,\n+                    ByRefSized(&mut iter).take(head_room),\n+                    &mut guard.written,\n+                );\n+                guard.deque.write_iter(0, iter, &mut guard.written)\n+            };\n+        }\n+\n+        guard.written\n+    }\n+\n     /// Frobs the head and tail sections around to handle the fact that we\n     /// just reallocated. Unsafe because it trusts old_capacity.\n     #[inline]\n     unsafe fn handle_capacity_increase(&mut self, old_capacity: usize) {\n-        let new_capacity = self.cap();\n+        let new_capacity = self.capacity();\n+        debug_assert!(new_capacity >= old_capacity);\n \n         // Move the shortest contiguous section of the ring buffer\n-        //    T             H\n+        //\n+        // H := head\n+        // L := last element (`self.to_physical_idx(self.len - 1)`)\n+        //\n+        //    H           L\n         //   [o o o o o o o . ]\n-        //    T             H\n+        //    H           L\n         // A [o o o o o o o . . . . . . . . . ]\n-        //        H T\n-        //   [o o . o o o o o ]\n-        //          T             H\n+        //        L H\n+        //   [o o o o o o o o ]\n+        //          H           L\n         // B [. . . o o o o o o o . . . . . . ]\n-        //              H T\n-        //   [o o o o o . o o ]\n-        //              H                 T\n+        //              L H\n+        //   [o o o o o o o o ]\n+        //            L                   H\n         // C [o o o o o . . . . . . . . . o o ]\n \n-        if self.tail <= self.head {\n+        // can't use is_contiguous() because the capacity is already updated.\n+        if self.head <= old_capacity - self.len {\n             // A\n             // Nop\n-        } else if self.head < old_capacity - self.tail {\n-            // B\n-            unsafe {\n-                self.copy_nonoverlapping(old_capacity, 0, self.head);\n-            }\n-            self.head += old_capacity;\n-            debug_assert!(self.head > self.tail);\n         } else {\n-            // C\n-            let new_tail = new_capacity - (old_capacity - self.tail);\n-            unsafe {\n-                self.copy_nonoverlapping(new_tail, self.tail, old_capacity - self.tail);\n+            let head_len = old_capacity - self.head;\n+            let tail_len = self.len - head_len;\n+            if head_len > tail_len && new_capacity - old_capacity >= tail_len {\n+                // B\n+                unsafe {\n+                    self.copy_nonoverlapping(0, old_capacity, tail_len);\n+                }\n+            } else {\n+                // C\n+                let new_head = new_capacity - head_len;\n+                unsafe {\n+                    // can't use copy_nonoverlapping here, because if e.g. head_len = 2\n+                    // and new_capacity = old_capacity + 1, then the heads overlap.\n+                    self.copy(self.head, new_head, head_len);\n+                }\n+                self.head = new_head;\n             }\n-            self.tail = new_tail;\n-            debug_assert!(self.head < self.tail);\n         }\n-        debug_assert!(self.head < self.cap());\n-        debug_assert!(self.tail < self.cap());\n-        debug_assert!(self.cap().count_ones() == 1);\n+        debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n     }\n }\n \n@@ -533,6 +531,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// let deque: VecDeque<u32> = VecDeque::new();\n     /// ```\n+    // FIXME: This should probably be const\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n@@ -567,10 +566,11 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     ///\n     /// let deque: VecDeque<u32> = VecDeque::new();\n     /// ```\n+    // FIXME: This should probably be const\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub fn new_in(alloc: A) -> VecDeque<T, A> {\n-        VecDeque::with_capacity_in(INITIAL_CAPACITY, alloc)\n+        VecDeque { head: 0, len: 0, buf: RawVec::new_in(alloc) }\n     }\n \n     /// Creates an empty deque with space for at least `capacity` elements.\n@@ -584,11 +584,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub fn with_capacity_in(capacity: usize, alloc: A) -> VecDeque<T, A> {\n-        assert!(capacity < 1_usize << usize::BITS - 1, \"capacity overflow\");\n-        // +1 since the ringbuffer always leaves one space empty\n-        let cap = cmp::max(capacity + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n-\n-        VecDeque { tail: 0, head: 0, buf: RawVec::with_capacity_in(cap, alloc) }\n+        VecDeque { head: 0, len: 0, buf: RawVec::with_capacity_in(capacity, alloc) }\n     }\n \n     /// Provides a reference to the element at the given index.\n@@ -608,8 +604,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, index: usize) -> Option<&T> {\n-        if index < self.len() {\n-            let idx = self.wrap_add(self.tail, index);\n+        if index < self.len {\n+            let idx = self.to_physical_idx(index);\n             unsafe { Some(&*self.ptr().add(idx)) }\n         } else {\n             None\n@@ -637,8 +633,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n-        if index < self.len() {\n-            let idx = self.wrap_add(self.tail, index);\n+        if index < self.len {\n+            let idx = self.to_physical_idx(index);\n             unsafe { Some(&mut *self.ptr().add(idx)) }\n         } else {\n             None\n@@ -672,8 +668,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     pub fn swap(&mut self, i: usize, j: usize) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n-        let ri = self.wrap_add(self.tail, i);\n-        let rj = self.wrap_add(self.tail, j);\n+        let ri = self.to_physical_idx(i);\n+        let rj = self.to_physical_idx(j);\n         unsafe { ptr::swap(self.ptr().add(ri), self.ptr().add(rj)) }\n     }\n \n@@ -691,7 +687,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.cap() - 1\n+        if T::IS_ZST { usize::MAX } else { self.buf.capacity() }\n     }\n \n     /// Reserves the minimum capacity for at least `additional` more elements to be inserted in the\n@@ -718,7 +714,15 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// [`reserve`]: VecDeque::reserve\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: usize) {\n-        self.reserve(additional);\n+        let new_cap = self.len.checked_add(additional).expect(\"capacity overflow\");\n+        let old_cap = self.capacity();\n+\n+        if new_cap > old_cap {\n+            self.buf.reserve_exact(self.len, additional);\n+            unsafe {\n+                self.handle_capacity_increase(old_cap);\n+            }\n+        }\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted in the given\n@@ -739,15 +743,13 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n-        let old_cap = self.cap();\n-        let used_cap = self.len() + 1;\n-        let new_cap = used_cap\n-            .checked_add(additional)\n-            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-            .expect(\"capacity overflow\");\n+        let new_cap = self.len.checked_add(additional).expect(\"capacity overflow\");\n+        let old_cap = self.capacity();\n \n         if new_cap > old_cap {\n-            self.buf.reserve_exact(used_cap, new_cap - used_cap);\n+            // we don't need to reserve_exact(), as the size doesn't have\n+            // to be a power of 2.\n+            self.buf.reserve(self.len, additional);\n             unsafe {\n                 self.handle_capacity_increase(old_cap);\n             }\n@@ -793,7 +795,17 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"try_reserve\", since = \"1.57.0\")]\n     pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n-        self.try_reserve(additional)\n+        let new_cap =\n+            self.len.checked_add(additional).ok_or(TryReserveErrorKind::CapacityOverflow)?;\n+        let old_cap = self.capacity();\n+\n+        if new_cap > old_cap {\n+            self.buf.try_reserve_exact(self.len, additional)?;\n+            unsafe {\n+                self.handle_capacity_increase(old_cap);\n+            }\n+        }\n+        Ok(())\n     }\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n@@ -831,15 +843,12 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"try_reserve\", since = \"1.57.0\")]\n     pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n-        let old_cap = self.cap();\n-        let used_cap = self.len() + 1;\n-        let new_cap = used_cap\n-            .checked_add(additional)\n-            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-            .ok_or(TryReserveErrorKind::CapacityOverflow)?;\n+        let new_cap =\n+            self.len.checked_add(additional).ok_or(TryReserveErrorKind::CapacityOverflow)?;\n+        let old_cap = self.capacity();\n \n         if new_cap > old_cap {\n-            self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;\n+            self.buf.try_reserve(self.len, additional)?;\n             unsafe {\n                 self.handle_capacity_increase(old_cap);\n             }\n@@ -890,13 +899,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"shrink_to\", since = \"1.56.0\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n-        let min_capacity = cmp::min(min_capacity, self.capacity());\n-        // We don't have to worry about an overflow as neither `self.len()` nor `self.capacity()`\n-        // can ever be `usize::MAX`. +1 as the ringbuffer always leaves one space empty.\n-        let target_cap = cmp::max(cmp::max(min_capacity, self.len()) + 1, MINIMUM_CAPACITY + 1)\n-            .next_power_of_two();\n+        let target_cap = min_capacity.max(self.len);\n \n-        if target_cap < self.cap() {\n+        // never shrink ZSTs\n+        if T::IS_ZST || self.capacity() <= target_cap {\n+            return;\n+        }\n+\n+        if target_cap < self.capacity() {\n             // There are three cases of interest:\n             //   All elements are out of desired bounds\n             //   Elements are contiguous, and head is out of desired bounds\n@@ -905,49 +915,55 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             // At all other times, element positions are unaffected.\n             //\n             // Indicates that elements at the head should be moved.\n-            let head_outside = self.head == 0 || self.head >= target_cap;\n+\n+            let tail_outside = (target_cap + 1..=self.capacity()).contains(&(self.head + self.len));\n             // Move elements from out of desired bounds (positions after target_cap)\n-            if self.tail >= target_cap && head_outside {\n-                //                    T             H\n+            if self.len == 0 {\n+                self.head = 0;\n+            } else if self.head >= target_cap && tail_outside {\n+                //  H := head\n+                //  L := last element\n+                //                    H           L\n                 //   [. . . . . . . . o o o o o o o . ]\n-                //    T             H\n+                //    H           L\n                 //   [o o o o o o o . ]\n                 unsafe {\n-                    self.copy_nonoverlapping(0, self.tail, self.len());\n+                    // nonoverlapping because self.head >= target_cap >= self.len\n+                    self.copy_nonoverlapping(self.head, 0, self.len);\n                 }\n-                self.head = self.len();\n-                self.tail = 0;\n-            } else if self.tail != 0 && self.tail < target_cap && head_outside {\n-                //          T             H\n+                self.head = 0;\n+            } else if self.head < target_cap && tail_outside {\n+                //  H := head\n+                //  L := last element\n+                //          H           L\n                 //   [. . . o o o o o o o . . . . . . ]\n-                //        H T\n+                //      L   H\n                 //   [o o . o o o o o ]\n-                let len = self.wrap_sub(self.head, target_cap);\n+                let len = self.head + self.len - target_cap;\n                 unsafe {\n-                    self.copy_nonoverlapping(0, target_cap, len);\n+                    self.copy_nonoverlapping(target_cap, 0, len);\n                 }\n-                self.head = len;\n-                debug_assert!(self.head < self.tail);\n-            } else if self.tail >= target_cap {\n-                //              H                 T\n+            } else if self.head >= target_cap {\n+                //  H := head\n+                //  L := last element\n+                //            L                   H\n                 //   [o o o o o . . . . . . . . . o o ]\n-                //              H T\n+                //            L   H\n                 //   [o o o o o . o o ]\n-                debug_assert!(self.wrap_sub(self.head, 1) < target_cap);\n-                let len = self.cap() - self.tail;\n-                let new_tail = target_cap - len;\n+                let len = self.capacity() - self.head;\n+                let new_head = target_cap - len;\n                 unsafe {\n-                    self.copy_nonoverlapping(new_tail, self.tail, len);\n+                    // can't use copy_nonoverlapping here for the same reason\n+                    // as in `handle_capacity_increase()`\n+                    self.copy(self.head, new_head, len);\n                 }\n-                self.tail = new_tail;\n-                debug_assert!(self.head < self.tail);\n+                self.head = new_head;\n             }\n \n             self.buf.shrink_to_fit(target_cap);\n \n-            debug_assert!(self.head < self.cap());\n-            debug_assert!(self.tail < self.cap());\n-            debug_assert!(self.cap().count_ones() == 1);\n+            debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n+            debug_assert!(self.len <= self.capacity());\n         }\n     }\n \n@@ -992,20 +1008,20 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         // * The head of the VecDeque is moved before calling `drop_in_place`,\n         //   so no value is dropped twice if `drop_in_place` panics\n         unsafe {\n-            if len > self.len() {\n+            if len >= self.len {\n                 return;\n             }\n-            let num_dropped = self.len() - len;\n+\n             let (front, back) = self.as_mut_slices();\n             if len > front.len() {\n                 let begin = len - front.len();\n                 let drop_back = back.get_unchecked_mut(begin..) as *mut _;\n-                self.head = self.wrap_sub(self.head, num_dropped);\n+                self.len = len;\n                 ptr::drop_in_place(drop_back);\n             } else {\n                 let drop_back = back as *mut _;\n                 let drop_front = front.get_unchecked_mut(len..) as *mut _;\n-                self.head = self.wrap_sub(self.head, num_dropped);\n+                self.len = len;\n \n                 // Make sure the second half is dropped even when a destructor\n                 // in the first one panics.\n@@ -1039,7 +1055,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, T> {\n-        Iter::new(unsafe { self.buffer_as_slice() }, self.tail, self.head)\n+        let (a, b) = self.as_slices();\n+        Iter::new(a.iter(), b.iter())\n     }\n \n     /// Returns a front-to-back iterator that returns mutable references.\n@@ -1061,11 +1078,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n-        // SAFETY: The internal `IterMut` safety invariant is established because the\n-        // `ring` we create is a dereferenceable slice for lifetime '_.\n-        let ring = ptr::slice_from_raw_parts_mut(self.ptr(), self.cap());\n-\n-        unsafe { IterMut::new(ring, self.tail, self.head, PhantomData) }\n+        let (a, b) = self.as_mut_slices();\n+        IterMut::new(a.iter_mut(), b.iter_mut())\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n@@ -1097,14 +1111,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n-        // Safety:\n-        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            let buf = self.buffer_as_slice();\n-            let (front, back) = RingSlices::ring_slices(buf, self.head, self.tail);\n-            (MaybeUninit::slice_assume_init_ref(front), MaybeUninit::slice_assume_init_ref(back))\n-        }\n+        let (a_range, b_range) = self.slice_ranges(..);\n+        // SAFETY: `slice_ranges` always returns valid ranges into\n+        // the physical buffer.\n+        unsafe { (&*self.buffer_range(a_range), &*self.buffer_range(b_range)) }\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n@@ -1135,16 +1145,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n-        // Safety:\n-        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            let head = self.head;\n-            let tail = self.tail;\n-            let buf = self.buffer_as_mut_slice();\n-            let (front, back) = RingSlices::ring_slices(buf, head, tail);\n-            (MaybeUninit::slice_assume_init_mut(front), MaybeUninit::slice_assume_init_mut(back))\n-        }\n+        let (a_range, b_range) = self.slice_ranges(..);\n+        // SAFETY: `slice_ranges` always returns valid ranges into\n+        // the physical buffer.\n+        unsafe { (&mut *self.buffer_range(a_range), &mut *self.buffer_range(b_range)) }\n     }\n \n     /// Returns the number of elements in the deque.\n@@ -1161,7 +1165,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n-        count(self.tail, self.head, self.cap())\n+        self.len\n     }\n \n     /// Returns `true` if the deque is empty.\n@@ -1178,17 +1182,41 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.tail == self.head\n+        self.len == 0\n     }\n \n-    fn range_tail_head<R>(&self, range: R) -> (usize, usize)\n+    /// Given a range into the logical buffer of the deque, this function\n+    /// return two ranges into the physical buffer that correspond to\n+    /// the given range.\n+    fn slice_ranges<R>(&self, range: R) -> (Range<usize>, Range<usize>)\n     where\n         R: RangeBounds<usize>,\n     {\n-        let Range { start, end } = slice::range(range, ..self.len());\n-        let tail = self.wrap_add(self.tail, start);\n-        let head = self.wrap_add(self.tail, end);\n-        (tail, head)\n+        let Range { start, end } = slice::range(range, ..self.len);\n+        let len = end - start;\n+\n+        if len == 0 {\n+            (0..0, 0..0)\n+        } else {\n+            // `slice::range` guarantees that `start <= end <= self.len`.\n+            // because `len != 0`, we know that `start < end`, so `start < self.len`\n+            // and the indexing is valid.\n+            let wrapped_start = self.to_physical_idx(start);\n+\n+            // this subtraction can never overflow because `wrapped_start` is\n+            // at most `self.capacity()` (and if `self.capacity != 0`, then `wrapped_start` is strictly less\n+            // than `self.capacity`).\n+            let head_len = self.capacity() - wrapped_start;\n+\n+            if head_len >= len {\n+                // we know that `len + wrapped_start <= self.capacity <= usize::MAX`, so this addition can't overflow\n+                (wrapped_start..wrapped_start + len, 0..0)\n+            } else {\n+                // can't overflow because of the if condition\n+                let tail_len = len - head_len;\n+                (wrapped_start..self.capacity(), 0..tail_len)\n+            }\n+        }\n     }\n \n     /// Creates an iterator that covers the specified range in the deque.\n@@ -1217,9 +1245,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (tail, head) = self.range_tail_head(range);\n-        // The shared reference we have in &self is maintained in the '_ of Iter.\n-        Iter::new(unsafe { self.buffer_as_slice() }, tail, head)\n+        let (a_range, b_range) = self.slice_ranges(range);\n+        // SAFETY: The ranges returned by `slice_ranges`\n+        // are valid ranges into the physical buffer, so\n+        // it's ok to pass them to `buffer_range` and\n+        // dereference the result.\n+        let a = unsafe { &*self.buffer_range(a_range) };\n+        let b = unsafe { &*self.buffer_range(b_range) };\n+        Iter::new(a.iter(), b.iter())\n     }\n \n     /// Creates an iterator that covers the specified mutable range in the deque.\n@@ -1252,13 +1285,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (tail, head) = self.range_tail_head(range);\n-\n-        // SAFETY: The internal `IterMut` safety invariant is established because the\n-        // `ring` we create is a dereferenceable slice for lifetime '_.\n-        let ring = ptr::slice_from_raw_parts_mut(self.ptr(), self.cap());\n-\n-        unsafe { IterMut::new(ring, tail, head, PhantomData) }\n+        let (a_range, b_range) = self.slice_ranges(range);\n+        // SAFETY: The ranges returned by `slice_ranges`\n+        // are valid ranges into the physical buffer, so\n+        // it's ok to pass them to `buffer_range` and\n+        // dereference the result.\n+        let a = unsafe { &mut *self.buffer_range(a_range) };\n+        let b = unsafe { &mut *self.buffer_range(b_range) };\n+        IterMut::new(a.iter_mut(), b.iter_mut())\n     }\n \n     /// Removes the specified range from the deque in bulk, returning all\n@@ -1310,39 +1344,30 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         // When finished, the remaining data will be copied back to cover the hole,\n         // and the head/tail values will be restored correctly.\n         //\n-        let (drain_tail, drain_head) = self.range_tail_head(range);\n+        let Range { start, end } = slice::range(range, ..self.len);\n+        let drain_start = start;\n+        let drain_len = end - start;\n \n         // The deque's elements are parted into three segments:\n-        // * self.tail  -> drain_tail\n-        // * drain_tail -> drain_head\n-        // * drain_head -> self.head\n+        // * 0  -> drain_start\n+        // * drain_start -> drain_start+drain_len\n+        // * drain_start+drain_len -> self.len\n         //\n-        // T = self.tail; H = self.head; t = drain_tail; h = drain_head\n+        // H = self.head; T = self.head+self.len; t = drain_start+drain_len; h = drain_head\n         //\n-        // We store drain_tail as self.head, and drain_head and self.head as\n-        // after_tail and after_head respectively on the Drain. This also\n+        // We store drain_start as self.len, and drain_len and self.len as\n+        // drain_len and orig_len respectively on the Drain. This also\n         // truncates the effective array such that if the Drain is leaked, we\n         // have forgotten about the potentially moved values after the start of\n         // the drain.\n         //\n-        //        T   t   h   H\n+        //        H   h   t   T\n         // [. . . o o x x o o . . .]\n         //\n-        let head = self.head;\n-\n         // \"forget\" about the values after the start of the drain until after\n         // the drain is complete and the Drain destructor is run.\n-        self.head = drain_tail;\n \n-        let deque = NonNull::from(&mut *self);\n-        unsafe {\n-            // Crucially, we only create shared references from `self` here and read from\n-            // it.  We do not write to `self` nor reborrow to a mutable reference.\n-            // Hence the raw pointer we created above, for `deque`, remains valid.\n-            let ring = self.buffer_as_slice();\n-\n-            Drain::new(drain_head, head, ring, drain_tail, drain_head, deque)\n-        }\n+        unsafe { Drain::new(self, drain_start, drain_len) }\n     }\n \n     /// Clears the deque, removing all values.\n@@ -1361,6 +1386,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     pub fn clear(&mut self) {\n         self.truncate(0);\n+        // Not strictly necessary, but leaves things in a more consistent/predictable state.\n+        self.head = 0;\n     }\n \n     /// Returns `true` if the deque contains an element equal to the\n@@ -1455,7 +1482,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        self.get(self.len().wrapping_sub(1))\n+        self.get(self.len.wrapping_sub(1))\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the\n@@ -1479,7 +1506,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        self.get_mut(self.len().wrapping_sub(1))\n+        self.get_mut(self.len.wrapping_sub(1))\n     }\n \n     /// Removes the first element and returns it, or `None` if the deque is\n@@ -1503,9 +1530,10 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         if self.is_empty() {\n             None\n         } else {\n-            let tail = self.tail;\n-            self.tail = self.wrap_add(self.tail, 1);\n-            unsafe { Some(self.buffer_read(tail)) }\n+            let old_head = self.head;\n+            self.head = self.to_physical_idx(1);\n+            self.len -= 1;\n+            Some(unsafe { self.buffer_read(old_head) })\n         }\n     }\n \n@@ -1528,9 +1556,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         if self.is_empty() {\n             None\n         } else {\n-            self.head = self.wrap_sub(self.head, 1);\n-            let head = self.head;\n-            unsafe { Some(self.buffer_read(head)) }\n+            self.len -= 1;\n+            Some(unsafe { self.buffer_read(self.to_physical_idx(self.len)) })\n         }\n     }\n \n@@ -1552,10 +1579,11 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             self.grow();\n         }\n \n-        self.tail = self.wrap_sub(self.tail, 1);\n-        let tail = self.tail;\n+        self.head = self.wrap_sub(self.head, 1);\n+        self.len += 1;\n+\n         unsafe {\n-            self.buffer_write(tail, value);\n+            self.buffer_write(self.head, value);\n         }\n     }\n \n@@ -1577,16 +1605,14 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             self.grow();\n         }\n \n-        let head = self.head;\n-        self.head = self.wrap_add(self.head, 1);\n-        unsafe { self.buffer_write(head, value) }\n+        unsafe { self.buffer_write(self.to_physical_idx(self.len), value) }\n+        self.len += 1;\n     }\n \n     #[inline]\n     fn is_contiguous(&self) -> bool {\n-        // FIXME: Should we consider `head == 0` to mean\n-        // that `self` is contiguous?\n-        self.tail <= self.head\n+        // Do the calculation like this to avoid overflowing if len + head > usize::MAX\n+        self.head <= self.capacity() - self.len\n     }\n \n     /// Removes an element from anywhere in the deque and returns it,\n@@ -1615,8 +1641,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n-        let length = self.len();\n-        if length > 0 && index < length && index != 0 {\n+        let length = self.len;\n+        if index < length && index != 0 {\n             self.swap(index, 0);\n         } else if index >= length {\n             return None;\n@@ -1650,7 +1676,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n-        let length = self.len();\n+        let length = self.len;\n         if length > 0 && index < length - 1 {\n             self.swap(index, length - 1);\n         } else if index >= length {\n@@ -1689,198 +1715,26 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             self.grow();\n         }\n \n-        // Move the least number of elements in the ring buffer and insert\n-        // the given object\n-        //\n-        // At most len/2 - 1 elements will be moved. O(min(n, n-i))\n-        //\n-        // There are three main cases:\n-        //  Elements are contiguous\n-        //      - special case when tail is 0\n-        //  Elements are discontiguous and the insert is in the tail section\n-        //  Elements are discontiguous and the insert is in the head section\n-        //\n-        // For each of those there are two more cases:\n-        //  Insert is closer to tail\n-        //  Insert is closer to head\n-        //\n-        // Key: H - self.head\n-        //      T - self.tail\n-        //      o - Valid element\n-        //      I - Insertion element\n-        //      A - The element that should be after the insertion point\n-        //      M - Indicates element was moved\n-\n-        let idx = self.wrap_add(self.tail, index);\n-\n-        let distance_to_tail = index;\n-        let distance_to_head = self.len() - index;\n-\n-        let contiguous = self.is_contiguous();\n-\n-        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n-            (true, true, _) if index == 0 => {\n-                // push_front\n-                //\n-                //       T\n-                //       I             H\n-                //      [A o o o o o o . . . . . . . . .]\n-                //\n-                //                       H         T\n-                //      [A o o o o o o o . . . . . I]\n-                //\n-\n-                self.tail = self.wrap_sub(self.tail, 1);\n-            }\n-            (true, true, _) => {\n-                unsafe {\n-                    // contiguous, insert closer to tail:\n-                    //\n-                    //             T   I         H\n-                    //      [. . . o o A o o o o . . . . . .]\n-                    //\n-                    //           T               H\n-                    //      [. . o o I A o o o o . . . . . .]\n-                    //           M M\n-                    //\n-                    // contiguous, insert closer to tail and tail is 0:\n-                    //\n-                    //\n-                    //       T   I         H\n-                    //      [o o A o o o o . . . . . . . . .]\n-                    //\n-                    //                       H             T\n-                    //      [o I A o o o o o . . . . . . . o]\n-                    //       M                             M\n-\n-                    let new_tail = self.wrap_sub(self.tail, 1);\n-\n-                    self.copy(new_tail, self.tail, 1);\n-                    // Already moved the tail, so we only copy `index - 1` elements.\n-                    self.copy(self.tail, self.tail + 1, index - 1);\n-\n-                    self.tail = new_tail;\n-                }\n-            }\n-            (true, false, _) => {\n-                unsafe {\n-                    //  contiguous, insert closer to head:\n-                    //\n-                    //             T       I     H\n-                    //      [. . . o o o o A o o . . . . . .]\n-                    //\n-                    //             T               H\n-                    //      [. . . o o o o I A o o . . . . .]\n-                    //                       M M M\n-\n-                    self.copy(idx + 1, idx, self.head - idx);\n-                    self.head = self.wrap_add(self.head, 1);\n-                }\n-            }\n-            (false, true, true) => {\n-                unsafe {\n-                    // discontiguous, insert closer to tail, tail section:\n-                    //\n-                    //                   H         T   I\n-                    //      [o o o o o o . . . . . o o A o o]\n-                    //\n-                    //                   H       T\n-                    //      [o o o o o o . . . . o o I A o o]\n-                    //                           M M\n-\n-                    self.copy(self.tail - 1, self.tail, index);\n-                    self.tail -= 1;\n-                }\n-            }\n-            (false, false, true) => {\n-                unsafe {\n-                    // discontiguous, insert closer to head, tail section:\n-                    //\n-                    //           H             T         I\n-                    //      [o o . . . . . . . o o o o o A o]\n-                    //\n-                    //             H           T\n-                    //      [o o o . . . . . . o o o o o I A]\n-                    //       M M M                         M\n-\n-                    // copy elements up to new head\n-                    self.copy(1, 0, self.head);\n-\n-                    // copy last element into empty spot at bottom of buffer\n-                    self.copy(0, self.cap() - 1, 1);\n-\n-                    // move elements from idx to end forward not including ^ element\n-                    self.copy(idx + 1, idx, self.cap() - 1 - idx);\n-\n-                    self.head += 1;\n-                }\n-            }\n-            (false, true, false) if idx == 0 => {\n-                unsafe {\n-                    // discontiguous, insert is closer to tail, head section,\n-                    // and is at index zero in the internal buffer:\n-                    //\n-                    //       I                   H     T\n-                    //      [A o o o o o o o o o . . . o o o]\n-                    //\n-                    //                           H   T\n-                    //      [A o o o o o o o o o . . o o o I]\n-                    //                               M M M\n-\n-                    // copy elements up to new tail\n-                    self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n-\n-                    // copy last element into empty spot at bottom of buffer\n-                    self.copy(self.cap() - 1, 0, 1);\n-\n-                    self.tail -= 1;\n-                }\n-            }\n-            (false, true, false) => {\n-                unsafe {\n-                    // discontiguous, insert closer to tail, head section:\n-                    //\n-                    //             I             H     T\n-                    //      [o o o A o o o o o o . . . o o o]\n-                    //\n-                    //                           H   T\n-                    //      [o o I A o o o o o o . . o o o o]\n-                    //       M M                     M M M M\n-\n-                    // copy elements up to new tail\n-                    self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n-\n-                    // copy last element into empty spot at bottom of buffer\n-                    self.copy(self.cap() - 1, 0, 1);\n-\n-                    // move elements from idx-1 to end forward not including ^ element\n-                    self.copy(0, 1, idx - 1);\n-\n-                    self.tail -= 1;\n-                }\n+        let k = self.len - index;\n+        if k < index {\n+            // `index + 1` can't overflow, because if index was usize::MAX, then either the\n+            // assert would've failed, or the deque would've tried to grow past usize::MAX\n+            // and panicked.\n+            unsafe {\n+                // see `remove()` for explanation why this wrap_copy() call is safe.\n+                self.wrap_copy(self.to_physical_idx(index), self.to_physical_idx(index + 1), k);\n+                self.buffer_write(self.to_physical_idx(index), value);\n+                self.len += 1;\n             }\n-            (false, false, false) => {\n-                unsafe {\n-                    // discontiguous, insert closer to head, head section:\n-                    //\n-                    //               I     H           T\n-                    //      [o o o o A o o . . . . . . o o o]\n-                    //\n-                    //                     H           T\n-                    //      [o o o o I A o o . . . . . o o o]\n-                    //                 M M M\n-\n-                    self.copy(idx + 1, idx, self.head - idx);\n-                    self.head += 1;\n-                }\n+        } else {\n+            let old_head = self.head;\n+            self.head = self.wrap_sub(self.head, 1);\n+            unsafe {\n+                self.wrap_copy(old_head, self.head, index);\n+                self.buffer_write(self.to_physical_idx(index), value);\n+                self.len += 1;\n             }\n         }\n-\n-        // tail might've been changed so we need to recalculate\n-        let new_idx = self.wrap_add(self.tail, index);\n-        unsafe {\n-            self.buffer_write(new_idx, value);\n-        }\n     }\n \n     /// Removes and returns the element at `index` from the deque.\n@@ -1906,156 +1760,26 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, index: usize) -> Option<T> {\n-        if self.is_empty() || self.len() <= index {\n+        if self.len <= index {\n             return None;\n         }\n \n-        // There are three main cases:\n-        //  Elements are contiguous\n-        //  Elements are discontiguous and the removal is in the tail section\n-        //  Elements are discontiguous and the removal is in the head section\n-        //      - special case when elements are technically contiguous,\n-        //        but self.head = 0\n-        //\n-        // For each of those there are two more cases:\n-        //  Insert is closer to tail\n-        //  Insert is closer to head\n-        //\n-        // Key: H - self.head\n-        //      T - self.tail\n-        //      o - Valid element\n-        //      x - Element marked for removal\n-        //      R - Indicates element that is being removed\n-        //      M - Indicates element was moved\n-\n-        let idx = self.wrap_add(self.tail, index);\n-\n-        let elem = unsafe { Some(self.buffer_read(idx)) };\n-\n-        let distance_to_tail = index;\n-        let distance_to_head = self.len() - index;\n+        let wrapped_idx = self.to_physical_idx(index);\n \n-        let contiguous = self.is_contiguous();\n+        let elem = unsafe { Some(self.buffer_read(wrapped_idx)) };\n \n-        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n-            (true, true, _) => {\n-                unsafe {\n-                    // contiguous, remove closer to tail:\n-                    //\n-                    //             T   R         H\n-                    //      [. . . o o x o o o o . . . . . .]\n-                    //\n-                    //               T           H\n-                    //      [. . . . o o o o o o . . . . . .]\n-                    //               M M\n-\n-                    self.copy(self.tail + 1, self.tail, index);\n-                    self.tail += 1;\n-                }\n-            }\n-            (true, false, _) => {\n-                unsafe {\n-                    // contiguous, remove closer to head:\n-                    //\n-                    //             T       R     H\n-                    //      [. . . o o o o x o o . . . . . .]\n-                    //\n-                    //             T           H\n-                    //      [. . . o o o o o o . . . . . . .]\n-                    //                     M M\n-\n-                    self.copy(idx, idx + 1, self.head - idx - 1);\n-                    self.head -= 1;\n-                }\n-            }\n-            (false, true, true) => {\n-                unsafe {\n-                    // discontiguous, remove closer to tail, tail section:\n-                    //\n-                    //                   H         T   R\n-                    //      [o o o o o o . . . . . o o x o o]\n-                    //\n-                    //                   H           T\n-                    //      [o o o o o o . . . . . . o o o o]\n-                    //                               M M\n-\n-                    self.copy(self.tail + 1, self.tail, index);\n-                    self.tail = self.wrap_add(self.tail, 1);\n-                }\n-            }\n-            (false, false, false) => {\n-                unsafe {\n-                    // discontiguous, remove closer to head, head section:\n-                    //\n-                    //               R     H           T\n-                    //      [o o o o x o o . . . . . . o o o]\n-                    //\n-                    //                   H             T\n-                    //      [o o o o o o . . . . . . . o o o]\n-                    //               M M\n-\n-                    self.copy(idx, idx + 1, self.head - idx - 1);\n-                    self.head -= 1;\n-                }\n-            }\n-            (false, false, true) => {\n-                unsafe {\n-                    // discontiguous, remove closer to head, tail section:\n-                    //\n-                    //             H           T         R\n-                    //      [o o o . . . . . . o o o o o x o]\n-                    //\n-                    //           H             T\n-                    //      [o o . . . . . . . o o o o o o o]\n-                    //       M M                         M M\n-                    //\n-                    // or quasi-discontiguous, remove next to head, tail section:\n-                    //\n-                    //       H                 T         R\n-                    //      [. . . . . . . . . o o o o o x o]\n-                    //\n-                    //                         T           H\n-                    //      [. . . . . . . . . o o o o o o .]\n-                    //                                   M\n-\n-                    // draw in elements in the tail section\n-                    self.copy(idx, idx + 1, self.cap() - idx - 1);\n-\n-                    // Prevents underflow.\n-                    if self.head != 0 {\n-                        // copy first element into empty spot\n-                        self.copy(self.cap() - 1, 0, 1);\n-\n-                        // move elements in the head section backwards\n-                        self.copy(0, 1, self.head - 1);\n-                    }\n-\n-                    self.head = self.wrap_sub(self.head, 1);\n-                }\n-            }\n-            (false, true, false) => {\n-                unsafe {\n-                    // discontiguous, remove closer to tail, head section:\n-                    //\n-                    //           R               H     T\n-                    //      [o o x o o o o o o o . . . o o o]\n-                    //\n-                    //                           H       T\n-                    //      [o o o o o o o o o o . . . . o o]\n-                    //       M M M                       M M\n-\n-                    // draw in elements up to idx\n-                    self.copy(1, 0, idx);\n-\n-                    // copy last element into empty spot\n-                    self.copy(0, self.cap() - 1, 1);\n-\n-                    // move elements from tail to end forward, excluding the last one\n-                    self.copy(self.tail + 1, self.tail, self.cap() - self.tail - 1);\n-\n-                    self.tail = self.wrap_add(self.tail, 1);\n-                }\n-            }\n+        let k = self.len - index - 1;\n+        // safety: due to the nature of the if-condition, whichever wrap_copy gets called,\n+        // its length argument will be at most `self.len / 2`, so there can't be more than\n+        // one overlapping area.\n+        if k < index {\n+            unsafe { self.wrap_copy(self.wrap_add(wrapped_idx, 1), wrapped_idx, k) };\n+            self.len -= 1;\n+        } else {\n+            let old_head = self.head;\n+            self.head = self.to_physical_idx(1);\n+            unsafe { self.wrap_copy(old_head, self.head, index) };\n+            self.len -= 1;\n         }\n \n         elem\n@@ -2091,7 +1815,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         A: Clone,\n     {\n-        let len = self.len();\n+        let len = self.len;\n         assert!(at <= len, \"`at` out of bounds\");\n \n         let other_len = len - at;\n@@ -2128,8 +1852,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n \n         // Cleanup where the ends of the buffers are\n-        self.head = self.wrap_sub(self.head, other_len);\n-        other.head = other.wrap_index(other_len);\n+        self.len = at;\n+        other.len = other_len;\n \n         other\n     }\n@@ -2154,17 +1878,26 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n-        self.reserve(other.len());\n+        if T::IS_ZST {\n+            self.len += other.len;\n+            other.len = 0;\n+            other.head = 0;\n+            return;\n+        }\n+\n+        self.reserve(other.len);\n         unsafe {\n             let (left, right) = other.as_slices();\n-            self.copy_slice(self.head, left);\n-            self.copy_slice(self.wrap_add(self.head, left.len()), right);\n+            self.copy_slice(self.to_physical_idx(self.len), left);\n+            // no overflow, because self.capacity() >= old_cap + left.len() >= self.len + left.len()\n+            self.copy_slice(self.to_physical_idx(self.len + left.len()), right);\n         }\n         // SAFETY: Update pointers after copying to avoid leaving doppelganger\n         // in case of panics.\n-        self.head = self.wrap_add(self.head, other.len());\n-        // Silently drop values in `other`.\n-        other.tail = other.head;\n+        self.len += other.len;\n+        // Now that we own its values, forget everything in `other`.\n+        other.len = 0;\n+        other.head = 0;\n     }\n \n     /// Retains only the elements specified by the predicate.\n@@ -2232,7 +1965,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         F: FnMut(&mut T) -> bool,\n     {\n-        let len = self.len();\n+        let len = self.len;\n         let mut idx = 0;\n         let mut cur = 0;\n \n@@ -2270,9 +2003,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         // Extend or possibly remove this assertion when valid use-cases for growing the\n         // buffer without it being full emerge\n         debug_assert!(self.is_full());\n-        let old_cap = self.cap();\n-        self.buf.reserve_exact(old_cap, old_cap);\n-        assert!(self.cap() == old_cap * 2);\n+        let old_cap = self.capacity();\n+        self.buf.reserve_for_push(old_cap);\n         unsafe {\n             self.handle_capacity_increase(old_cap);\n         }\n@@ -2306,7 +2038,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"vec_resize_with\", since = \"1.33.0\")]\n     pub fn resize_with(&mut self, new_len: usize, generator: impl FnMut() -> T) {\n-        let len = self.len();\n+        let len = self.len;\n \n         if new_len > len {\n             self.extend(repeat_with(generator).take(new_len - len))\n@@ -2372,110 +2104,129 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// ```\n     #[stable(feature = \"deque_make_contiguous\", since = \"1.48.0\")]\n     pub fn make_contiguous(&mut self) -> &mut [T] {\n+        if T::IS_ZST {\n+            self.head = 0;\n+        }\n+\n         if self.is_contiguous() {\n-            let tail = self.tail;\n-            let head = self.head;\n-            // Safety:\n-            // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-            // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-            return unsafe {\n-                MaybeUninit::slice_assume_init_mut(\n-                    RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0,\n-                )\n-            };\n+            unsafe { return slice::from_raw_parts_mut(self.ptr().add(self.head), self.len) }\n         }\n \n-        let buf = self.buf.ptr();\n-        let cap = self.cap();\n-        let len = self.len();\n+        let &mut Self { head, len, .. } = self;\n+        let ptr = self.ptr();\n+        let cap = self.capacity();\n \n-        let free = self.tail - self.head;\n-        let tail_len = cap - self.tail;\n+        let free = cap - len;\n+        let head_len = cap - head;\n+        let tail = len - head_len;\n+        let tail_len = tail;\n \n-        if free >= tail_len {\n-            // there is enough free space to copy the tail in one go,\n-            // this means that we first shift the head backwards, and then\n-            // copy the tail to the correct position.\n+        if free >= head_len {\n+            // there is enough free space to copy the head in one go,\n+            // this means that we first shift the tail backwards, and then\n+            // copy the head to the correct position.\n             //\n             // from: DEFGH....ABC\n             // to:   ABCDEFGH....\n             unsafe {\n-                ptr::copy(buf, buf.add(tail_len), self.head);\n+                self.copy(0, head_len, tail_len);\n                 // ...DEFGH.ABC\n-                ptr::copy_nonoverlapping(buf.add(self.tail), buf, tail_len);\n+                self.copy_nonoverlapping(head, 0, head_len);\n                 // ABCDEFGH....\n-\n-                self.tail = 0;\n-                self.head = len;\n             }\n-        } else if free > self.head {\n-            // FIXME: We currently do not consider ....ABCDEFGH\n-            // to be contiguous because `head` would be `0` in this\n-            // case. While we probably want to change this it\n-            // isn't trivial as a few places expect `is_contiguous`\n-            // to mean that we can just slice using `buf[tail..head]`.\n \n-            // there is enough free space to copy the head in one go,\n-            // this means that we first shift the tail forwards, and then\n-            // copy the head to the correct position.\n+            self.head = 0;\n+        } else if free >= tail_len {\n+            // there is enough free space to copy the tail in one go,\n+            // this means that we first shift the head forwards, and then\n+            // copy the tail to the correct position.\n             //\n             // from: FGH....ABCDE\n             // to:   ...ABCDEFGH.\n             unsafe {\n-                ptr::copy(buf.add(self.tail), buf.add(self.head), tail_len);\n+                self.copy(head, tail, head_len);\n                 // FGHABCDE....\n-                ptr::copy_nonoverlapping(buf, buf.add(self.head + tail_len), self.head);\n+                self.copy_nonoverlapping(0, tail + head_len, tail_len);\n                 // ...ABCDEFGH.\n-\n-                self.tail = self.head;\n-                self.head = self.wrap_add(self.tail, len);\n             }\n+\n+            self.head = tail;\n         } else {\n-            // free is smaller than both head and tail,\n-            // this means we have to slowly \"swap\" the tail and the head.\n+            // \u00b4free` is smaller than both `head_len` and `tail_len`.\n+            // the general algorithm for this first moves the slices\n+            // right next to each other and then uses `slice::rotate`\n+            // to rotate them into place:\n             //\n-            // from: EFGHI...ABCD or HIJK.ABCDEFG\n-            // to:   ABCDEFGHI... or ABCDEFGHIJK.\n-            let mut left_edge: usize = 0;\n-            let mut right_edge: usize = self.tail;\n-            unsafe {\n-                // The general problem looks like this\n-                // GHIJKLM...ABCDEF - before any swaps\n-                // ABCDEFM...GHIJKL - after 1 pass of swaps\n-                // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n-                //                  - then restart the algorithm with a new (smaller) store\n-                // Sometimes the temp store is reached when the right edge is at the end\n-                // of the buffer - this means we've hit the right order with fewer swaps!\n-                // E.g\n-                // EF..ABCD\n-                // ABCDEF.. - after four only swaps we've finished\n-                while left_edge < len && right_edge != cap {\n-                    let mut right_offset = 0;\n-                    for i in left_edge..right_edge {\n-                        right_offset = (i - left_edge) % (cap - right_edge);\n-                        let src = right_edge + right_offset;\n-                        ptr::swap(buf.add(i), buf.add(src));\n+            // initially:   HIJK..ABCDEFG\n+            // step 1:      ..HIJKABCDEFG\n+            // step 2:      ..ABCDEFGHIJK\n+            //\n+            // or:\n+            //\n+            // initially:   FGHIJK..ABCDE\n+            // step 1:      FGHIJKABCDE..\n+            // step 2:      ABCDEFGHIJK..\n+\n+            // pick the shorter of the 2 slices to reduce the amount\n+            // of memory that needs to be moved around.\n+            if head_len > tail_len {\n+                // tail is shorter, so:\n+                //  1. copy tail forwards\n+                //  2. rotate used part of the buffer\n+                //  3. update head to point to the new beginning (which is just `free`)\n+\n+                unsafe {\n+                    // if there is no free space in the buffer, then the slices are already\n+                    // right next to each other and we don't need to move any memory.\n+                    if free != 0 {\n+                        // because we only move the tail forward as much as there's free space\n+                        // behind it, we don't overwrite any elements of the head slice, and\n+                        // the slices end up right next to each other.\n+                        self.copy(0, free, tail_len);\n                     }\n-                    let n_ops = right_edge - left_edge;\n-                    left_edge += n_ops;\n-                    right_edge += right_offset + 1;\n+\n+                    // We just copied the tail right next to the head slice,\n+                    // so all of the elements in the range are initialized\n+                    let slice = &mut *self.buffer_range(free..self.capacity());\n+\n+                    // because the deque wasn't contiguous, we know that `tail_len < self.len == slice.len()`,\n+                    // so this will never panic.\n+                    slice.rotate_left(tail_len);\n+\n+                    // the used part of the buffer now is `free..self.capacity()`, so set\n+                    // `head` to the beginning of that range.\n+                    self.head = free;\n                 }\n+            } else {\n+                // head is shorter so:\n+                //  1. copy head backwards\n+                //  2. rotate used part of the buffer\n+                //  3. update head to point to the new beginning (which is the beginning of the buffer)\n+\n+                unsafe {\n+                    // if there is no free space in the buffer, then the slices are already\n+                    // right next to each other and we don't need to move any memory.\n+                    if free != 0 {\n+                        // copy the head slice to lie right behind the tail slice.\n+                        self.copy(self.head, tail_len, head_len);\n+                    }\n+\n+                    // because we copied the head slice so that both slices lie right\n+                    // next to each other, all the elements in the range are initialized.\n+                    let slice = &mut *self.buffer_range(0..self.len);\n \n-                self.tail = 0;\n-                self.head = len;\n+                    // because the deque wasn't contiguous, we know that `head_len < self.len == slice.len()`\n+                    // so this will never panic.\n+                    slice.rotate_right(head_len);\n+\n+                    // the used part of the buffer now is `0..self.len`, so set\n+                    // `head` to the beginning of that range.\n+                    self.head = 0;\n+                }\n             }\n         }\n \n-        let tail = self.tail;\n-        let head = self.head;\n-        // Safety:\n-        // - `self.head` and `self.tail` in a ring buffer are always valid indices.\n-        // - `RingSlices::ring_slices` guarantees that the slices split according to `self.head` and `self.tail` are initialized.\n-        unsafe {\n-            MaybeUninit::slice_assume_init_mut(\n-                RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0,\n-            )\n-        }\n+        unsafe { slice::from_raw_parts_mut(ptr.add(self.head), self.len) }\n     }\n \n     /// Rotates the double-ended queue `mid` places to the left.\n@@ -2513,7 +2264,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[stable(feature = \"vecdeque_rotate\", since = \"1.36.0\")]\n     pub fn rotate_left(&mut self, mid: usize) {\n         assert!(mid <= self.len());\n-        let k = self.len() - mid;\n+        let k = self.len - mid;\n         if mid <= k {\n             unsafe { self.rotate_left_inner(mid) }\n         } else {\n@@ -2556,7 +2307,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[stable(feature = \"vecdeque_rotate\", since = \"1.36.0\")]\n     pub fn rotate_right(&mut self, k: usize) {\n         assert!(k <= self.len());\n-        let mid = self.len() - k;\n+        let mid = self.len - k;\n         if k <= mid {\n             unsafe { self.rotate_right_inner(k) }\n         } else {\n@@ -2567,26 +2318,24 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     // SAFETY: the following two methods require that the rotation amount\n     // be less than half the length of the deque.\n     //\n-    // `wrap_copy` requires that `min(x, cap() - x) + copy_len <= cap()`,\n-    // but than `min` is never more than half the capacity, regardless of x,\n+    // `wrap_copy` requires that `min(x, capacity() - x) + copy_len <= capacity()`,\n+    // but then `min` is never more than half the capacity, regardless of x,\n     // so it's sound to call here because we're calling with something\n     // less than half the length, which is never above half the capacity.\n \n     unsafe fn rotate_left_inner(&mut self, mid: usize) {\n         debug_assert!(mid * 2 <= self.len());\n         unsafe {\n-            self.wrap_copy(self.head, self.tail, mid);\n+            self.wrap_copy(self.head, self.to_physical_idx(self.len), mid);\n         }\n-        self.head = self.wrap_add(self.head, mid);\n-        self.tail = self.wrap_add(self.tail, mid);\n+        self.head = self.to_physical_idx(mid);\n     }\n \n     unsafe fn rotate_right_inner(&mut self, k: usize) {\n         debug_assert!(k * 2 <= self.len());\n         self.head = self.wrap_sub(self.head, k);\n-        self.tail = self.wrap_sub(self.tail, k);\n         unsafe {\n-            self.wrap_copy(self.tail, self.head, k);\n+            self.wrap_copy(self.to_physical_idx(self.len), self.head, k);\n         }\n     }\n \n@@ -2844,23 +2593,19 @@ impl<T: Clone, A: Allocator> VecDeque<T, A> {\n \n /// Returns the index in the underlying buffer for a given logical element index.\n #[inline]\n-fn wrap_index(index: usize, size: usize) -> usize {\n-    // size is always a power of 2\n-    debug_assert!(size.is_power_of_two());\n-    index & (size - 1)\n-}\n-\n-/// Calculate the number of elements left to be read in the buffer\n-#[inline]\n-fn count(tail: usize, head: usize, size: usize) -> usize {\n-    // size is always a power of 2\n-    (head.wrapping_sub(tail)) & (size - 1)\n+fn wrap_index(logical_index: usize, capacity: usize) -> usize {\n+    debug_assert!(\n+        (logical_index == 0 && capacity == 0)\n+            || logical_index < capacity\n+            || (logical_index - capacity) < capacity\n+    );\n+    if logical_index >= capacity { logical_index - capacity } else { logical_index }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialEq, A: Allocator> PartialEq for VecDeque<T, A> {\n     fn eq(&self, other: &Self) -> bool {\n-        if self.len() != other.len() {\n+        if self.len != other.len() {\n             return false;\n         }\n         let (sa, sb) = self.as_slices();\n@@ -2924,7 +2669,7 @@ impl<T: Ord, A: Allocator> Ord for VecDeque<T, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Hash, A: Allocator> Hash for VecDeque<T, A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        state.write_length_prefix(self.len());\n+        state.write_length_prefix(self.len);\n         // It's not possible to use Hash::hash_slice on slices\n         // returned by as_slices method as their length can vary\n         // in otherwise identical deques.\n@@ -3033,7 +2778,7 @@ impl<'a, T: 'a + Copy, A: Allocator> Extend<&'a T> for VecDeque<T, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug, A: Allocator> fmt::Debug for VecDeque<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_list().entries(self).finish()\n+        f.debug_list().entries(self.iter()).finish()\n     }\n }\n \n@@ -3044,31 +2789,12 @@ impl<T, A: Allocator> From<Vec<T, A>> for VecDeque<T, A> {\n     /// [`Vec<T>`]: crate::vec::Vec\n     /// [`VecDeque<T>`]: crate::collections::VecDeque\n     ///\n-    /// This avoids reallocating where possible, but the conditions for that are\n-    /// strict, and subject to change, and so shouldn't be relied upon unless the\n-    /// `Vec<T>` came from `From<VecDeque<T>>` and hasn't been reallocated.\n-    fn from(mut other: Vec<T, A>) -> Self {\n-        let len = other.len();\n-        if T::IS_ZST {\n-            // There's no actual allocation for ZSTs to worry about capacity,\n-            // but `VecDeque` can't handle as much length as `Vec`.\n-            assert!(len < MAXIMUM_ZST_CAPACITY, \"capacity overflow\");\n-        } else {\n-            // We need to resize if the capacity is not a power of two, too small or\n-            // doesn't have at least one free space. We do this while it's still in\n-            // the `Vec` so the items will drop on panic.\n-            let min_cap = cmp::max(MINIMUM_CAPACITY, len) + 1;\n-            let cap = cmp::max(min_cap, other.capacity()).next_power_of_two();\n-            if other.capacity() != cap {\n-                other.reserve_exact(cap - len);\n-            }\n-        }\n-\n-        unsafe {\n-            let (other_buf, len, capacity, alloc) = other.into_raw_parts_with_alloc();\n-            let buf = RawVec::from_raw_parts_in(other_buf, capacity, alloc);\n-            VecDeque { tail: 0, head: len, buf }\n-        }\n+    /// In its current implementation, this is a very cheap\n+    /// conversion. This isn't yet a guarantee though, and\n+    /// shouldn't be relied on.\n+    fn from(other: Vec<T, A>) -> Self {\n+        let (ptr, len, cap, alloc) = other.into_raw_parts_with_alloc();\n+        Self { head: 0, len, buf: unsafe { RawVec::from_raw_parts_in(ptr, cap, alloc) } }\n     }\n }\n \n@@ -3110,11 +2836,11 @@ impl<T, A: Allocator> From<VecDeque<T, A>> for Vec<T, A> {\n             let other = ManuallyDrop::new(other);\n             let buf = other.buf.ptr();\n             let len = other.len();\n-            let cap = other.cap();\n+            let cap = other.capacity();\n             let alloc = ptr::read(other.allocator());\n \n-            if other.tail != 0 {\n-                ptr::copy(buf.add(other.tail), buf, len);\n+            if other.head != 0 {\n+                ptr::copy(buf.add(other.head), buf, len);\n             }\n             Vec::from_raw_parts_in(buf, len, cap, alloc)\n         }\n@@ -3141,8 +2867,8 @@ impl<T, const N: usize> From<[T; N]> for VecDeque<T> {\n                 ptr::copy_nonoverlapping(arr.as_ptr(), deq.ptr(), N);\n             }\n         }\n-        deq.tail = 0;\n-        deq.head = N;\n+        deq.head = 0;\n+        deq.len = N;\n         deq\n     }\n }"}, {"sha": "6735424a3ef33c1c04dd1094f0dcbe5e620fc06a", "filename": "library/alloc/src/collections/vec_deque/pair_slices.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/dd12cd6dc631b5e964d541d370ca863c2242376c/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd12cd6dc631b5e964d541d370ca863c2242376c/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fpair_slices.rs?ref=dd12cd6dc631b5e964d541d370ca863c2242376c", "patch": "@@ -1,67 +0,0 @@\n-use core::cmp::{self};\n-use core::mem::replace;\n-\n-use crate::alloc::Allocator;\n-\n-use super::VecDeque;\n-\n-/// PairSlices pairs up equal length slice parts of two deques\n-///\n-/// For example, given deques \"A\" and \"B\" with the following division into slices:\n-///\n-/// A: [0 1 2] [3 4 5]\n-/// B: [a b] [c d e]\n-///\n-/// It produces the following sequence of matching slices:\n-///\n-/// ([0 1], [a b])\n-/// (\\[2\\], \\[c\\])\n-/// ([3 4], [d e])\n-///\n-/// and the uneven remainder of either A or B is skipped.\n-pub struct PairSlices<'a, 'b, T> {\n-    a0: &'a mut [T],\n-    a1: &'a mut [T],\n-    b0: &'b [T],\n-    b1: &'b [T],\n-}\n-\n-impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n-    pub fn from<A: Allocator>(to: &'a mut VecDeque<T, A>, from: &'b VecDeque<T, A>) -> Self {\n-        let (a0, a1) = to.as_mut_slices();\n-        let (b0, b1) = from.as_slices();\n-        PairSlices { a0, a1, b0, b1 }\n-    }\n-\n-    pub fn has_remainder(&self) -> bool {\n-        !self.b0.is_empty()\n-    }\n-\n-    pub fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n-        IntoIterator::into_iter([self.b0, self.b1])\n-    }\n-}\n-\n-impl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T> {\n-    type Item = (&'a mut [T], &'b [T]);\n-    fn next(&mut self) -> Option<Self::Item> {\n-        // Get next part length\n-        let part = cmp::min(self.a0.len(), self.b0.len());\n-        if part == 0 {\n-            return None;\n-        }\n-        let (p0, p1) = replace(&mut self.a0, &mut []).split_at_mut(part);\n-        let (q0, q1) = self.b0.split_at(part);\n-\n-        // Move a1 into a0, if it's empty (and b1, b0 the same way).\n-        self.a0 = p1;\n-        self.b0 = q1;\n-        if self.a0.is_empty() {\n-            self.a0 = replace(&mut self.a1, &mut []);\n-        }\n-        if self.b0.is_empty() {\n-            self.b0 = replace(&mut self.b1, &[]);\n-        }\n-        Some((p0, q0))\n-    }\n-}"}, {"sha": "dd0fa7d6074c00cbfed25293c649745930f564e9", "filename": "library/alloc/src/collections/vec_deque/ring_slices.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dd12cd6dc631b5e964d541d370ca863c2242376c/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fring_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd12cd6dc631b5e964d541d370ca863c2242376c/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fring_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fring_slices.rs?ref=dd12cd6dc631b5e964d541d370ca863c2242376c", "patch": "@@ -1,56 +0,0 @@\n-use core::ptr::{self};\n-\n-/// Returns the two slices that cover the `VecDeque`'s valid range\n-pub trait RingSlices: Sized {\n-    fn slice(self, from: usize, to: usize) -> Self;\n-    fn split_at(self, i: usize) -> (Self, Self);\n-\n-    fn ring_slices(buf: Self, head: usize, tail: usize) -> (Self, Self) {\n-        let contiguous = tail <= head;\n-        if contiguous {\n-            let (empty, buf) = buf.split_at(0);\n-            (buf.slice(tail, head), empty)\n-        } else {\n-            let (mid, right) = buf.split_at(tail);\n-            let (left, _) = mid.split_at(head);\n-            (right, left)\n-        }\n-    }\n-}\n-\n-impl<T> RingSlices for &[T] {\n-    fn slice(self, from: usize, to: usize) -> Self {\n-        &self[from..to]\n-    }\n-    fn split_at(self, i: usize) -> (Self, Self) {\n-        (*self).split_at(i)\n-    }\n-}\n-\n-impl<T> RingSlices for &mut [T] {\n-    fn slice(self, from: usize, to: usize) -> Self {\n-        &mut self[from..to]\n-    }\n-    fn split_at(self, i: usize) -> (Self, Self) {\n-        (*self).split_at_mut(i)\n-    }\n-}\n-\n-impl<T> RingSlices for *mut [T] {\n-    fn slice(self, from: usize, to: usize) -> Self {\n-        assert!(from <= to && to < self.len());\n-        // Not using `get_unchecked_mut` to keep this a safe operation.\n-        let len = to - from;\n-        ptr::slice_from_raw_parts_mut(self.as_mut_ptr().wrapping_add(from), len)\n-    }\n-\n-    fn split_at(self, mid: usize) -> (Self, Self) {\n-        let len = self.len();\n-        let ptr = self.as_mut_ptr();\n-        assert!(mid <= len);\n-        (\n-            ptr::slice_from_raw_parts_mut(ptr, mid),\n-            ptr::slice_from_raw_parts_mut(ptr.wrapping_add(mid), len - mid),\n-        )\n-    }\n-}"}, {"sha": "dccf40ccb38aab69f0b3985120d8e9f8a168d1ca", "filename": "library/alloc/src/collections/vec_deque/spec_extend.rs", "status": "modified", "additions": 36, "deletions": 45, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -1,6 +1,6 @@\n use crate::alloc::Allocator;\n use crate::vec;\n-use core::iter::{ByRefSized, TrustedLen};\n+use core::iter::TrustedLen;\n use core::slice;\n \n use super::VecDeque;\n@@ -17,19 +17,33 @@ where\n     default fn spec_extend(&mut self, mut iter: I) {\n         // This function should be the moral equivalent of:\n         //\n-        //      for item in iter {\n-        //          self.push_back(item);\n-        //      }\n-        while let Some(element) = iter.next() {\n-            if self.len() == self.capacity() {\n-                let (lower, _) = iter.size_hint();\n-                self.reserve(lower.saturating_add(1));\n-            }\n+        // for item in iter {\n+        //     self.push_back(item);\n+        // }\n+\n+        // May only be called if `deque.len() < deque.capacity()`\n+        unsafe fn push_unchecked<T, A: Allocator>(deque: &mut VecDeque<T, A>, element: T) {\n+            // SAFETY: Because of the precondition, it's guaranteed that there is space\n+            // in the logical array after the last element.\n+            unsafe { deque.buffer_write(deque.to_physical_idx(deque.len), element) };\n+            // This can't overflow because `deque.len() < deque.capacity() <= usize::MAX`.\n+            deque.len += 1;\n+        }\n \n-            let head = self.head;\n-            self.head = self.wrap_add(self.head, 1);\n-            unsafe {\n-                self.buffer_write(head, element);\n+        while let Some(element) = iter.next() {\n+            let (lower, _) = iter.size_hint();\n+            self.reserve(lower.saturating_add(1));\n+\n+            // SAFETY: We just reserved space for at least one element.\n+            unsafe { push_unchecked(self, element) };\n+\n+            // Inner loop to avoid repeatedly calling `reserve`.\n+            while self.len < self.capacity() {\n+                let Some(element) = iter.next() else {\n+                    return;\n+                };\n+                // SAFETY: The loop condition guarantees that `self.len() < self.capacity()`.\n+                unsafe { push_unchecked(self, element) };\n             }\n         }\n     }\n@@ -39,7 +53,7 @@ impl<T, I, A: Allocator> SpecExtend<T, I> for VecDeque<T, A>\n where\n     I: TrustedLen<Item = T>,\n {\n-    default fn spec_extend(&mut self, mut iter: I) {\n+    default fn spec_extend(&mut self, iter: I) {\n         // This is the case for a TrustedLen iterator.\n         let (low, high) = iter.size_hint();\n         if let Some(additional) = high {\n@@ -51,35 +65,12 @@ where\n             );\n             self.reserve(additional);\n \n-            struct WrapAddOnDrop<'a, T, A: Allocator> {\n-                vec_deque: &'a mut VecDeque<T, A>,\n-                written: usize,\n-            }\n-\n-            impl<'a, T, A: Allocator> Drop for WrapAddOnDrop<'a, T, A> {\n-                fn drop(&mut self) {\n-                    self.vec_deque.head =\n-                        self.vec_deque.wrap_add(self.vec_deque.head, self.written);\n-                }\n-            }\n-\n-            let mut wrapper = WrapAddOnDrop { vec_deque: self, written: 0 };\n-\n-            let head_room = wrapper.vec_deque.cap() - wrapper.vec_deque.head;\n-            unsafe {\n-                wrapper.vec_deque.write_iter(\n-                    wrapper.vec_deque.head,\n-                    ByRefSized(&mut iter).take(head_room),\n-                    &mut wrapper.written,\n-                );\n-\n-                if additional > head_room {\n-                    wrapper.vec_deque.write_iter(0, iter, &mut wrapper.written);\n-                }\n-            }\n+            let written = unsafe {\n+                self.write_iter_wrapping(self.to_physical_idx(self.len), iter, additional)\n+            };\n \n             debug_assert_eq!(\n-                additional, wrapper.written,\n+                additional, written,\n                 \"The number of items written to VecDeque doesn't match the TrustedLen size hint\"\n             );\n         } else {\n@@ -99,8 +90,8 @@ impl<T, A: Allocator> SpecExtend<T, vec::IntoIter<T>> for VecDeque<T, A> {\n         self.reserve(slice.len());\n \n         unsafe {\n-            self.copy_slice(self.head, slice);\n-            self.head = self.wrap_add(self.head, slice.len());\n+            self.copy_slice(self.to_physical_idx(self.len), slice);\n+            self.len += slice.len();\n         }\n         iterator.forget_remaining_elements();\n     }\n@@ -125,8 +116,8 @@ where\n         self.reserve(slice.len());\n \n         unsafe {\n-            self.copy_slice(self.head, slice);\n-            self.head = self.wrap_add(self.head, slice.len());\n+            self.copy_slice(self.to_physical_idx(self.len), slice);\n+            self.len += slice.len();\n         }\n     }\n }"}, {"sha": "220ad71beabd43081f01769b53551fd16e3139ce", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 119, "deletions": 101, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -10,7 +10,7 @@ fn bench_push_back_100(b: &mut test::Bencher) {\n             deq.push_back(i);\n         }\n         deq.head = 0;\n-        deq.tail = 0;\n+        deq.len = 0;\n     })\n }\n \n@@ -22,7 +22,7 @@ fn bench_push_front_100(b: &mut test::Bencher) {\n             deq.push_front(i);\n         }\n         deq.head = 0;\n-        deq.tail = 0;\n+        deq.len = 0;\n     })\n }\n \n@@ -35,8 +35,8 @@ fn bench_pop_back_100(b: &mut test::Bencher) {\n     unsafe { deq.ptr().write_bytes(0u8, size + 1) };\n \n     b.iter(|| {\n-        deq.head = size;\n-        deq.tail = 0;\n+        deq.head = 0;\n+        deq.len = 100;\n         while !deq.is_empty() {\n             test::black_box(deq.pop_back());\n         }\n@@ -85,8 +85,8 @@ fn bench_pop_front_100(b: &mut test::Bencher) {\n     unsafe { deq.ptr().write_bytes(0u8, size + 1) };\n \n     b.iter(|| {\n-        deq.head = size;\n-        deq.tail = 0;\n+        deq.head = 0;\n+        deq.len = 100;\n         while !deq.is_empty() {\n             test::black_box(deq.pop_front());\n         }\n@@ -105,9 +105,9 @@ fn test_swap_front_back_remove() {\n         for len in 0..final_len {\n             let expected: VecDeque<_> =\n                 if back { (0..len).collect() } else { (0..len).rev().collect() };\n-            for tail_pos in 0..usable_cap {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n+            for head_pos in 0..usable_cap {\n+                tester.head = head_pos;\n+                tester.len = 0;\n                 if back {\n                     for i in 0..len * 2 {\n                         tester.push_front(i);\n@@ -124,8 +124,8 @@ fn test_swap_front_back_remove() {\n                         assert_eq!(tester.swap_remove_front(idx), Some(len * 2 - 1 - i));\n                     }\n                 }\n-                assert!(tester.tail < tester.cap());\n-                assert!(tester.head < tester.cap());\n+                assert!(tester.head <= tester.capacity());\n+                assert!(tester.len <= tester.capacity());\n                 assert_eq!(tester, expected);\n             }\n         }\n@@ -150,18 +150,18 @@ fn test_insert() {\n     for len in minlen..cap {\n         // 0, 1, 2, .., len - 1\n         let expected = (0..).take(len).collect::<VecDeque<_>>();\n-        for tail_pos in 0..cap {\n+        for head_pos in 0..cap {\n             for to_insert in 0..len {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n+                tester.head = head_pos;\n+                tester.len = 0;\n                 for i in 0..len {\n                     if i != to_insert {\n                         tester.push_back(i);\n                     }\n                 }\n                 tester.insert(to_insert, to_insert);\n-                assert!(tester.tail < tester.cap());\n-                assert!(tester.head < tester.cap());\n+                assert!(tester.head <= tester.capacity());\n+                assert!(tester.len <= tester.capacity());\n                 assert_eq!(tester, expected);\n             }\n         }\n@@ -257,13 +257,14 @@ fn test_swap_panic() {\n #[test]\n fn test_reserve_exact() {\n     let mut tester: VecDeque<i32> = VecDeque::with_capacity(1);\n-    assert!(tester.capacity() == 1);\n+    assert_eq!(tester.capacity(), 1);\n     tester.reserve_exact(50);\n-    assert!(tester.capacity() >= 51);\n+    assert_eq!(tester.capacity(), 50);\n     tester.reserve_exact(40);\n-    assert!(tester.capacity() >= 51);\n+    // reserving won't shrink the buffer\n+    assert_eq!(tester.capacity(), 50);\n     tester.reserve_exact(200);\n-    assert!(tester.capacity() >= 200);\n+    assert_eq!(tester.capacity(), 200);\n }\n \n #[test]\n@@ -323,6 +324,7 @@ fn test_contains() {\n #[test]\n fn test_rotate_left_right() {\n     let mut tester: VecDeque<_> = (1..=10).collect();\n+    tester.reserve(1);\n \n     assert_eq!(tester.len(), 10);\n \n@@ -463,7 +465,7 @@ fn test_binary_search_key() {\n }\n \n #[test]\n-fn make_contiguous_big_tail() {\n+fn make_contiguous_big_head() {\n     let mut tester = VecDeque::with_capacity(15);\n \n     for i in 0..3 {\n@@ -478,14 +480,14 @@ fn make_contiguous_big_tail() {\n     assert_eq!(tester.capacity(), 15);\n     assert_eq!((&[9, 8, 7, 6, 5, 4, 3] as &[_], &[0, 1, 2] as &[_]), tester.as_slices());\n \n-    let expected_start = tester.head;\n+    let expected_start = tester.as_slices().1.len();\n     tester.make_contiguous();\n-    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(tester.head, expected_start);\n     assert_eq!((&[9, 8, 7, 6, 5, 4, 3, 0, 1, 2] as &[_], &[] as &[_]), tester.as_slices());\n }\n \n #[test]\n-fn make_contiguous_big_head() {\n+fn make_contiguous_big_tail() {\n     let mut tester = VecDeque::with_capacity(15);\n \n     for i in 0..8 {\n@@ -499,44 +501,46 @@ fn make_contiguous_big_head() {\n     // 01234567......98\n     let expected_start = 0;\n     tester.make_contiguous();\n-    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(tester.head, expected_start);\n     assert_eq!((&[9, 8, 0, 1, 2, 3, 4, 5, 6, 7] as &[_], &[] as &[_]), tester.as_slices());\n }\n \n #[test]\n fn make_contiguous_small_free() {\n-    let mut tester = VecDeque::with_capacity(15);\n+    let mut tester = VecDeque::with_capacity(16);\n \n-    for i in 'A' as u8..'I' as u8 {\n+    for i in b'A'..b'I' {\n         tester.push_back(i as char);\n     }\n \n-    for i in 'I' as u8..'N' as u8 {\n+    for i in b'I'..b'N' {\n         tester.push_front(i as char);\n     }\n \n+    assert_eq!(tester, ['M', 'L', 'K', 'J', 'I', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']);\n+\n     // ABCDEFGH...MLKJI\n     let expected_start = 0;\n     tester.make_contiguous();\n-    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(tester.head, expected_start);\n     assert_eq!(\n         (&['M', 'L', 'K', 'J', 'I', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] as &[_], &[] as &[_]),\n         tester.as_slices()\n     );\n \n     tester.clear();\n-    for i in 'I' as u8..'N' as u8 {\n+    for i in b'I'..b'N' {\n         tester.push_back(i as char);\n     }\n \n-    for i in 'A' as u8..'I' as u8 {\n+    for i in b'A'..b'I' {\n         tester.push_front(i as char);\n     }\n \n     // IJKLM...HGFEDCBA\n-    let expected_start = 0;\n+    let expected_start = 3;\n     tester.make_contiguous();\n-    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(tester.head, expected_start);\n     assert_eq!(\n         (&['H', 'G', 'F', 'E', 'D', 'C', 'B', 'A', 'I', 'J', 'K', 'L', 'M'] as &[_], &[] as &[_]),\n         tester.as_slices()\n@@ -545,16 +549,55 @@ fn make_contiguous_small_free() {\n \n #[test]\n fn make_contiguous_head_to_end() {\n-    let mut dq = VecDeque::with_capacity(3);\n-    dq.push_front('B');\n-    dq.push_front('A');\n-    dq.push_back('C');\n-    dq.make_contiguous();\n-    let expected_tail = 0;\n-    let expected_head = 3;\n-    assert_eq!(expected_tail, dq.tail);\n-    assert_eq!(expected_head, dq.head);\n-    assert_eq!((&['A', 'B', 'C'] as &[_], &[] as &[_]), dq.as_slices());\n+    let mut tester = VecDeque::with_capacity(16);\n+\n+    for i in b'A'..b'L' {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in b'L'..b'Q' {\n+        tester.push_front(i as char);\n+    }\n+\n+    assert_eq!(\n+        tester,\n+        ['P', 'O', 'N', 'M', 'L', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']\n+    );\n+\n+    // ABCDEFGHIJKPONML\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.head, expected_start);\n+    assert_eq!(\n+        (\n+            &['P', 'O', 'N', 'M', 'L', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']\n+                as &[_],\n+            &[] as &[_]\n+        ),\n+        tester.as_slices()\n+    );\n+\n+    tester.clear();\n+    for i in b'L'..b'Q' {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in b'A'..b'L' {\n+        tester.push_front(i as char);\n+    }\n+\n+    // LMNOPKJIHGFEDCBA\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.head, expected_start);\n+    assert_eq!(\n+        (\n+            &['K', 'J', 'I', 'H', 'G', 'F', 'E', 'D', 'C', 'B', 'A', 'L', 'M', 'N', 'O', 'P']\n+                as &[_],\n+            &[] as &[_]\n+        ),\n+        tester.as_slices()\n+    );\n }\n \n #[test]\n@@ -588,10 +631,10 @@ fn test_remove() {\n     for len in minlen..cap - 1 {\n         // 0, 1, 2, .., len - 1\n         let expected = (0..).take(len).collect::<VecDeque<_>>();\n-        for tail_pos in 0..cap {\n+        for head_pos in 0..cap {\n             for to_remove in 0..=len {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n+                tester.head = head_pos;\n+                tester.len = 0;\n                 for i in 0..len {\n                     if i == to_remove {\n                         tester.push_back(1234);\n@@ -602,8 +645,8 @@ fn test_remove() {\n                     tester.push_back(1234);\n                 }\n                 tester.remove(to_remove);\n-                assert!(tester.tail < tester.cap());\n-                assert!(tester.head < tester.cap());\n+                assert!(tester.head <= tester.capacity());\n+                assert!(tester.len <= tester.capacity());\n                 assert_eq!(tester, expected);\n             }\n         }\n@@ -617,11 +660,11 @@ fn test_range() {\n     let cap = tester.capacity();\n     let minlen = if cfg!(miri) { cap - 1 } else { 0 }; // Miri is too slow\n     for len in minlen..=cap {\n-        for tail in 0..=cap {\n+        for head in 0..=cap {\n             for start in 0..=len {\n                 for end in start..=len {\n-                    tester.tail = tail;\n-                    tester.head = tail;\n+                    tester.head = head;\n+                    tester.len = 0;\n                     for i in 0..len {\n                         tester.push_back(i);\n                     }\n@@ -642,17 +685,17 @@ fn test_range_mut() {\n \n     let cap = tester.capacity();\n     for len in 0..=cap {\n-        for tail in 0..=cap {\n+        for head in 0..=cap {\n             for start in 0..=len {\n                 for end in start..=len {\n-                    tester.tail = tail;\n-                    tester.head = tail;\n+                    tester.head = head;\n+                    tester.len = 0;\n                     for i in 0..len {\n                         tester.push_back(i);\n                     }\n \n                     let head_was = tester.head;\n-                    let tail_was = tester.tail;\n+                    let len_was = tester.len;\n \n                     // Check that we iterate over the correct values\n                     let range: VecDeque<_> = tester.range_mut(start..end).map(|v| *v).collect();\n@@ -662,8 +705,8 @@ fn test_range_mut() {\n                     // We shouldn't have changed the capacity or made the\n                     // head or tail out of bounds\n                     assert_eq!(tester.capacity(), cap);\n-                    assert_eq!(tester.tail, tail_was);\n                     assert_eq!(tester.head, head_was);\n+                    assert_eq!(tester.len, len_was);\n                 }\n             }\n         }\n@@ -676,11 +719,11 @@ fn test_drain() {\n \n     let cap = tester.capacity();\n     for len in 0..=cap {\n-        for tail in 0..=cap {\n+        for head in 0..cap {\n             for drain_start in 0..=len {\n                 for drain_end in drain_start..=len {\n-                    tester.tail = tail;\n-                    tester.head = tail;\n+                    tester.head = head;\n+                    tester.len = 0;\n                     for i in 0..len {\n                         tester.push_back(i);\n                     }\n@@ -693,8 +736,8 @@ fn test_drain() {\n                     // We shouldn't have changed the capacity or made the\n                     // head or tail out of bounds\n                     assert_eq!(tester.capacity(), cap);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n+                    assert!(tester.head <= tester.capacity());\n+                    assert!(tester.len <= tester.capacity());\n \n                     // We should see the correct values in the VecDeque\n                     let expected: VecDeque<_> = (0..drain_start).chain(drain_end..len).collect();\n@@ -721,17 +764,18 @@ fn test_shrink_to_fit() {\n     for len in 0..=cap {\n         // 0, 1, 2, .., len - 1\n         let expected = (0..).take(len).collect::<VecDeque<_>>();\n-        for tail_pos in 0..=max_cap {\n-            tester.tail = tail_pos;\n-            tester.head = tail_pos;\n+        for head_pos in 0..=max_cap {\n+            tester.reserve(head_pos);\n+            tester.head = head_pos;\n+            tester.len = 0;\n             tester.reserve(63);\n             for i in 0..len {\n                 tester.push_back(i);\n             }\n             tester.shrink_to_fit();\n             assert!(tester.capacity() <= cap);\n-            assert!(tester.tail < tester.cap());\n-            assert!(tester.head < tester.cap());\n+            assert!(tester.head <= tester.capacity());\n+            assert!(tester.len <= tester.capacity());\n             assert_eq!(tester, expected);\n         }\n     }\n@@ -758,17 +802,17 @@ fn test_split_off() {\n             // at, at + 1, .., len - 1 (may be empty)\n             let expected_other = (at..).take(len - at).collect::<VecDeque<_>>();\n \n-            for tail_pos in 0..cap {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n+            for head_pos in 0..cap {\n+                tester.head = head_pos;\n+                tester.len = 0;\n                 for i in 0..len {\n                     tester.push_back(i);\n                 }\n                 let result = tester.split_off(at);\n-                assert!(tester.tail < tester.cap());\n-                assert!(tester.head < tester.cap());\n-                assert!(result.tail < result.cap());\n-                assert!(result.head < result.cap());\n+                assert!(tester.head <= tester.capacity());\n+                assert!(tester.len <= tester.capacity());\n+                assert!(result.head <= result.capacity());\n+                assert!(result.len <= result.capacity());\n                 assert_eq!(tester, expected_self);\n                 assert_eq!(result, expected_other);\n             }\n@@ -785,16 +829,10 @@ fn test_from_vec() {\n             vec.extend(0..len);\n \n             let vd = VecDeque::from(vec.clone());\n-            assert!(vd.cap().is_power_of_two());\n             assert_eq!(vd.len(), vec.len());\n             assert!(vd.into_iter().eq(vec));\n         }\n     }\n-\n-    let vec = Vec::from([(); MAXIMUM_ZST_CAPACITY - 1]);\n-    let vd = VecDeque::from(vec.clone());\n-    assert!(vd.cap().is_power_of_two());\n-    assert_eq!(vd.len(), vec.len());\n }\n \n #[test]\n@@ -846,10 +884,6 @@ fn test_extend_impl(trusted_len: bool) {\n             }\n \n             assert_eq!(self.test, self.expected);\n-            let (a1, b1) = self.test.as_slices();\n-            let (a2, b2) = self.expected.as_slices();\n-            assert_eq!(a1, a2);\n-            assert_eq!(b1, b2);\n         }\n \n         fn drain<R: RangeBounds<usize> + Clone>(&mut self, range: R) {\n@@ -872,15 +906,15 @@ fn test_extend_impl(trusted_len: bool) {\n     let mut tester = VecDequeTester::new(trusted_len);\n \n     // Initial capacity\n-    tester.test_extend(0..tester.remaining_capacity() - 1);\n+    tester.test_extend(0..tester.remaining_capacity());\n \n     // Grow\n     tester.test_extend(1024..2048);\n \n     // Wrap around\n     tester.drain(..128);\n \n-    tester.test_extend(0..tester.remaining_capacity() - 1);\n+    tester.test_extend(0..tester.remaining_capacity());\n \n     // Continue\n     tester.drain(256..);\n@@ -892,16 +926,6 @@ fn test_extend_impl(trusted_len: bool) {\n     tester.test_extend(0..32);\n }\n \n-#[test]\n-#[should_panic = \"capacity overflow\"]\n-fn test_from_vec_zst_overflow() {\n-    use crate::vec::Vec;\n-    let vec = Vec::from([(); MAXIMUM_ZST_CAPACITY]);\n-    let vd = VecDeque::from(vec.clone()); // no room for +1\n-    assert!(vd.cap().is_power_of_two());\n-    assert_eq!(vd.len(), vec.len());\n-}\n-\n #[test]\n fn test_from_array() {\n     fn test<const N: usize>() {\n@@ -917,19 +941,13 @@ fn test_from_array() {\n             assert_eq!(deq[i], i);\n         }\n \n-        assert!(deq.cap().is_power_of_two());\n         assert_eq!(deq.len(), N);\n     }\n     test::<0>();\n     test::<1>();\n     test::<2>();\n     test::<32>();\n     test::<35>();\n-\n-    let array = [(); MAXIMUM_ZST_CAPACITY - 1];\n-    let deq = VecDeque::from(array);\n-    assert!(deq.cap().is_power_of_two());\n-    assert_eq!(deq.len(), MAXIMUM_ZST_CAPACITY - 1);\n }\n \n #[test]"}, {"sha": "d04de5a074b7fafa3d186d6762a336141c133b2b", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -465,7 +465,6 @@ fn test_drain() {\n         for i in 6..9 {\n             d.push_front(i);\n         }\n-\n         assert_eq!(d.drain(..).collect::<Vec<_>>(), [8, 7, 6, 0, 1, 2, 3, 4]);\n         assert!(d.is_empty());\n     }\n@@ -1142,7 +1141,7 @@ fn test_reserve_exact_2() {\n     v.push_back(16);\n \n     v.reserve_exact(16);\n-    assert!(v.capacity() >= 48)\n+    assert!(v.capacity() >= 33)\n }\n \n #[test]\n@@ -1157,7 +1156,7 @@ fn test_try_reserve() {\n     // * overflow may trigger when adding `len` to `cap` (in number of elements)\n     // * overflow may trigger when multiplying `new_cap` by size_of::<T> (to get bytes)\n \n-    const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n+    const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n     {\n@@ -1248,7 +1247,7 @@ fn test_try_reserve_exact() {\n     // This is exactly the same as test_try_reserve with the method changed.\n     // See that test for comments.\n \n-    const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n+    const MAX_CAP: usize = isize::MAX as usize;\n     const MAX_USIZE: usize = usize::MAX;\n \n     {\n@@ -1391,7 +1390,8 @@ fn test_rotate_nop() {\n \n #[test]\n fn test_rotate_left_parts() {\n-    let mut v: VecDeque<_> = (1..=7).collect();\n+    let mut v: VecDeque<_> = VecDeque::with_capacity(8);\n+    v.extend(1..=7);\n     v.rotate_left(2);\n     assert_eq!(v.as_slices(), (&[3, 4, 5, 6, 7, 1][..], &[2][..]));\n     v.rotate_left(2);\n@@ -1410,7 +1410,8 @@ fn test_rotate_left_parts() {\n \n #[test]\n fn test_rotate_right_parts() {\n-    let mut v: VecDeque<_> = (1..=7).collect();\n+    let mut v: VecDeque<_> = VecDeque::with_capacity(8);\n+    v.extend(1..=7);\n     v.rotate_right(2);\n     assert_eq!(v.as_slices(), (&[6, 7][..], &[1, 2, 3, 4, 5][..]));\n     v.rotate_right(2);"}, {"sha": "32b8d8e24c65245efb100e6997948e1942aa3706", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -144,20 +144,16 @@ class StdVecDequeProvider:\n     def __init__(self, valobj):\n         self.valobj = valobj\n         self.head = int(valobj[\"head\"])\n-        self.tail = int(valobj[\"tail\"])\n+        self.size = int(valobj[\"len\"])\n         self.cap = int(valobj[\"buf\"][\"cap\"])\n         self.data_ptr = unwrap_unique_or_non_null(valobj[\"buf\"][\"ptr\"])\n-        if self.head >= self.tail:\n-            self.size = self.head - self.tail\n-        else:\n-            self.size = self.cap + self.head - self.tail\n \n     def to_string(self):\n         return \"VecDeque(size={})\".format(self.size)\n \n     def children(self):\n         return _enumerate_array_elements(\n-            (self.data_ptr + ((self.tail + index) % self.cap)) for index in xrange(self.size)\n+            (self.data_ptr + ((self.head + index) % self.cap)) for index in xrange(self.size)\n         )\n \n     @staticmethod"}, {"sha": "697ad4293c3f0bd1fc5a7ca3146cee1659e5a47e", "filename": "src/etc/lldb_providers.py", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Fetc%2Flldb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Fetc%2Flldb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_providers.py?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -356,7 +356,7 @@ def has_children(self):\n class StdVecDequeSyntheticProvider:\n     \"\"\"Pretty-printer for alloc::collections::vec_deque::VecDeque<T>\n \n-    struct VecDeque<T> { tail: usize, head: usize, buf: RawVec<T> }\n+    struct VecDeque<T> { head: usize, len: usize, buf: RawVec<T> }\n     \"\"\"\n \n     def __init__(self, valobj, dict):\n@@ -373,28 +373,24 @@ def num_children(self):\n     def get_child_index(self, name):\n         # type: (str) -> int\n         index = name.lstrip('[').rstrip(']')\n-        if index.isdigit() and self.tail <= index and (self.tail + index) % self.cap < self.head:\n+        if index.isdigit() and int(index) < self.size:\n             return int(index)\n         else:\n             return -1\n \n     def get_child_at_index(self, index):\n         # type: (int) -> SBValue\n         start = self.data_ptr.GetValueAsUnsigned()\n-        address = start + ((index + self.tail) % self.cap) * self.element_type_size\n+        address = start + ((index + self.head) % self.cap) * self.element_type_size\n         element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.element_type)\n         return element\n \n     def update(self):\n         # type: () -> None\n         self.head = self.valobj.GetChildMemberWithName(\"head\").GetValueAsUnsigned()\n-        self.tail = self.valobj.GetChildMemberWithName(\"tail\").GetValueAsUnsigned()\n+        self.size = self.valobj.GetChildMemberWithName(\"len\").GetValueAsUnsigned()\n         self.buf = self.valobj.GetChildMemberWithName(\"buf\")\n         self.cap = self.buf.GetChildMemberWithName(\"cap\").GetValueAsUnsigned()\n-        if self.head >= self.tail:\n-            self.size = self.head - self.tail\n-        else:\n-            self.size = self.cap + self.head - self.tail\n \n         self.data_ptr = unwrap_unique_or_non_null(self.buf.GetChildMemberWithName(\"ptr\"))\n "}, {"sha": "c4ad98ec1d3a99cf9b3ba9ebc36e0ea1715a17c8", "filename": "src/etc/natvis/liballoc.natvis", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fliballoc.natvis?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -12,20 +12,19 @@\n     </Expand>\n   </Type>\n   <Type Name=\"alloc::collections::vec_deque::VecDeque&lt;*&gt;\">\n-    <DisplayString>{{ len={tail &lt;= head ? head - tail : buf.cap - tail + head} }}</DisplayString>\n+    <DisplayString>{{ len={len} }}</DisplayString>\n     <Expand>\n-      <Item Name=\"[len]\" ExcludeView=\"simple\">tail &lt;= head ? head - tail : buf.cap - tail + head</Item>\n+      <Item Name=\"[len]\" ExcludeView=\"simple\">len</Item>\n       <Item Name=\"[capacity]\" ExcludeView=\"simple\">buf.cap</Item>\n       <CustomListItems>\n-        <Variable Name=\"i\" InitialValue=\"tail\" />\n-\n-        <Size>tail &lt;= head ? head - tail : buf.cap - tail + head</Size>\n+        <Variable Name=\"i\" InitialValue=\"0\" />\n+        <Size>len</Size>\n         <Loop>\n-          <If Condition=\"i == head\">\n+          <If Condition=\"i == len\">\n             <Break/>\n           </If>\n-          <Item>buf.ptr.pointer.pointer[i]</Item>\n-          <Exec>i = (i + 1 == buf.cap ? 0 : i + 1)</Exec>\n+          <Item>buf.ptr.pointer.pointer[(i + head) % buf.cap]</Item>\n+          <Exec>i = i + 1</Exec>\n         </Loop>\n       </CustomListItems>\n     </Expand>"}, {"sha": "7bb2810c2b2137e15d448295370c4b909eb2b6a6", "filename": "src/test/debuginfo/pretty-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -138,7 +138,7 @@\n // cdb-command: dx vecdeque\n // cdb-check:vecdeque         : { len=0x2 } [Type: alloc::collections::vec_deque::VecDeque<i32,alloc::alloc::Global>]\n // cdb-check:    [<Raw View>]     [Type: alloc::collections::vec_deque::VecDeque<i32,alloc::alloc::Global>]\n-// cdb-check:    [len]            : 0x2\n+// cdb-check:    [len]            : 0x2 [Type: unsigned [...]]\n // cdb-check:    [capacity]       : 0x8 [Type: unsigned [...]]\n // cdb-check:    [0x0]            : 90 [Type: int]\n // cdb-check:    [0x1]            : 20 [Type: int]\n@@ -175,7 +175,7 @@ fn main() {\n     linkedlist.push_front(128);\n \n     // VecDeque\n-    let mut vecdeque = VecDeque::new();\n+    let mut vecdeque = VecDeque::with_capacity(8);\n     vecdeque.push_back(20);\n     vecdeque.push_front(90);\n "}, {"sha": "0b23b1cc2f451c70900e7a0b1dee4215812b3a4e", "filename": "src/test/ui/hygiene/panic-location.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Ftest%2Fui%2Fhygiene%2Fpanic-location.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69df0f2c2f665d7f4e38a3579a81d4efc0d81034/src%2Ftest%2Fui%2Fhygiene%2Fpanic-location.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fpanic-location.run.stderr?ref=69df0f2c2f665d7f4e38a3579a81d4efc0d81034", "patch": "@@ -1,2 +1,2 @@\n-thread 'main' panicked at 'capacity overflow', $SRC_DIR/alloc/src/collections/vec_deque/mod.rs:LL:COL\n+thread 'main' panicked at 'capacity overflow', library/alloc/src/raw_vec.rs:518:5\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}]}