{"sha": "a4cdb68925e4cb3a2df74df61da333136afae582", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0Y2RiNjg5MjVlNGNiM2EyZGY3NGRmNjFkYTMzMzEzNmFmYWU1ODI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-06-30T07:53:06Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-12T09:37:28Z"}, "message": "Improve formatting of series of binop expressions\n\nThis commit changes the handling of binops (and potentially other pairs), where\nthe expressions are logically a list, e.g., `a + b + c`. It makes the single\nline vs multi-line approaches explicit and introduces a lowering step.\n\nThis improves formatting in a number of places, mostly improving consistency of\nformatting with very short sub-expressions, but also some weird indentation.\n\nCloses #2802", "tree": {"sha": "477d5c01dc31c038b7cd135fbac6dc52f9c972c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/477d5c01dc31c038b7cd135fbac6dc52f9c972c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4cdb68925e4cb3a2df74df61da333136afae582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4cdb68925e4cb3a2df74df61da333136afae582", "html_url": "https://github.com/rust-lang/rust/commit/a4cdb68925e4cb3a2df74df61da333136afae582", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4cdb68925e4cb3a2df74df61da333136afae582/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b68fd9e6bfd40802afc2a8379824fdcf541c9c1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d", "html_url": "https://github.com/rust-lang/rust/commit/b68fd9e6bfd40802afc2a8379824fdcf541c9c1d"}], "stats": {"total": 309, "additions": 221, "deletions": 88}, "files": [{"sha": "7f39e93b267d4f27c84ae11b03b06cef4b251ec4", "filename": "src/expr.rs", "status": "modified", "additions": 3, "deletions": 77, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a4cdb68925e4cb3a2df74df61da333136afae582/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cdb68925e4cb3a2df74df61da333136afae582/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=a4cdb68925e4cb3a2df74df61da333136afae582", "patch": "@@ -31,7 +31,7 @@ use lists::{\n use macros::{rewrite_macro, MacroArg, MacroPosition};\n use matches::rewrite_match;\n use overflow;\n-use pairs::{rewrite_pair, PairParts};\n+use pairs::{rewrite_all_pairs, rewrite_pair, PairParts};\n use patterns::{can_be_overflowed_pat, is_short_pattern, TuplePatField};\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n@@ -89,7 +89,7 @@ pub fn format_expr(\n         ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, shape, expr.span),\n         ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n             // FIXME: format comments between operands and operator\n-            rewrite_simple_binaries(context, expr, shape, op).or_else(|| {\n+            rewrite_all_pairs(expr, shape, context).or_else(|| {\n                 rewrite_pair(\n                     &**lhs,\n                     &**rhs,\n@@ -362,80 +362,6 @@ pub fn format_expr(\n         })\n }\n \n-/// Collect operands that appears in the given binary operator in the opposite order.\n-/// e.g. `collect_binary_items(e, ||)` for `a && b || c || d` returns `[d, c, a && b]`.\n-fn collect_binary_items<'a>(mut expr: &'a ast::Expr, binop: ast::BinOp) -> Vec<&'a ast::Expr> {\n-    let mut result = vec![];\n-    let mut prev_lhs = None;\n-    loop {\n-        match expr.node {\n-            ast::ExprKind::Binary(inner_binop, ref lhs, ref rhs)\n-                if inner_binop.node == binop.node =>\n-            {\n-                result.push(&**rhs);\n-                expr = lhs;\n-                prev_lhs = Some(lhs);\n-            }\n-            _ => {\n-                if let Some(lhs) = prev_lhs {\n-                    result.push(lhs);\n-                }\n-                break;\n-            }\n-        }\n-    }\n-    result\n-}\n-\n-/// Rewrites a binary expression whose operands fits within a single line.\n-fn rewrite_simple_binaries(\n-    context: &RewriteContext,\n-    expr: &ast::Expr,\n-    shape: Shape,\n-    op: ast::BinOp,\n-) -> Option<String> {\n-    let op_str = context.snippet(op.span);\n-\n-    // 2 = spaces around a binary operator.\n-    let sep_overhead = op_str.len() + 2;\n-    let nested_overhead = sep_overhead - 1;\n-\n-    let nested_shape = (match context.config.indent_style() {\n-        IndentStyle::Visual => shape.visual_indent(0),\n-        IndentStyle::Block => shape.block_indent(context.config.tab_spaces()),\n-    }).with_max_width(context.config);\n-    let nested_shape = match context.config.binop_separator() {\n-        SeparatorPlace::Back => nested_shape.sub_width(nested_overhead)?,\n-        SeparatorPlace::Front => nested_shape.offset_left(nested_overhead)?,\n-    };\n-\n-    let opt_rewrites: Option<Vec<_>> = collect_binary_items(expr, op)\n-        .iter()\n-        .rev()\n-        .map(|e| e.rewrite(context, nested_shape))\n-        .collect();\n-    if let Some(rewrites) = opt_rewrites {\n-        if rewrites.iter().all(|e| ::utils::is_single_line(e)) {\n-            let total_width = rewrites.iter().map(|s| s.len()).sum::<usize>()\n-                + sep_overhead * (rewrites.len() - 1);\n-\n-            let sep_str = if total_width <= shape.width {\n-                format!(\" {} \", op_str)\n-            } else {\n-                let indent_str = nested_shape.indent.to_string_with_newline(context.config);\n-                match context.config.binop_separator() {\n-                    SeparatorPlace::Back => format!(\" {}{}\", op_str.trim_right(), indent_str),\n-                    SeparatorPlace::Front => format!(\"{}{} \", indent_str, op_str.trim_left()),\n-                }\n-            };\n-\n-            return wrap_str(rewrites.join(&sep_str), context.config.max_width(), shape);\n-        }\n-    }\n-\n-    None\n-}\n-\n pub fn rewrite_array<T: Rewrite + Spanned + ToExpr>(\n     name: &str,\n     exprs: &[&T],\n@@ -2004,7 +1930,7 @@ fn choose_rhs<R: Rewrite>(\n                 }\n                 (None, Some(ref new_rhs)) => Some(format!(\"{}{}\", new_indent_str, new_rhs)),\n                 (None, None) => None,\n-                (Some(ref orig_rhs), _) => Some(format!(\" {}\", orig_rhs)),\n+                (Some(orig_rhs), _) => Some(format!(\" {}\", orig_rhs)),\n             }\n         }\n     }"}, {"sha": "3cd044d606e147c34bc4b998c4d0bdcc86404ded", "filename": "src/pairs.rs", "status": "modified", "additions": 218, "deletions": 11, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/a4cdb68925e4cb3a2df74df61da333136afae582/src%2Fpairs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cdb68925e4cb3a2df74df61da333136afae582/src%2Fpairs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpairs.rs?ref=a4cdb68925e4cb3a2df74df61da333136afae582", "patch": "@@ -8,23 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use config::lists::*;\n+use syntax::ast;\n \n+use config::lists::*;\n use config::IndentStyle;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n-use utils::{first_line_width, last_line_width};\n+use utils::{first_line_width, is_single_line, last_line_width, trimmed_last_line_width, wrap_str};\n \n /// Sigils that decorate a binop pair.\n #[derive(new, Clone, Copy)]\n-pub struct PairParts<'a> {\n+pub(crate) struct PairParts<'a> {\n     prefix: &'a str,\n     infix: &'a str,\n     suffix: &'a str,\n }\n \n impl<'a> PairParts<'a> {\n-    pub fn infix(infix: &'a str) -> PairParts<'a> {\n+    pub(crate) fn infix(infix: &'a str) -> PairParts<'a> {\n         PairParts {\n             prefix: \"\",\n             infix,\n@@ -33,7 +34,148 @@ impl<'a> PairParts<'a> {\n     }\n }\n \n-pub fn rewrite_pair<LHS, RHS>(\n+// Flattens a tree of pairs into a list and tries to rewrite them all at once.\n+// FIXME would be nice to reuse the lists API for this, but because each separator\n+// can be different, we can't.\n+pub(crate) fn rewrite_all_pairs(\n+    expr: &ast::Expr,\n+    shape: Shape,\n+    context: &RewriteContext,\n+) -> Option<String> {\n+    // First we try formatting on one line.\n+    if let Some(list) = expr.flatten(context, false) {\n+        if let Some(r) = rewrite_pairs_one_line(&list, shape, context) {\n+            return Some(r);\n+        }\n+    }\n+\n+    // We can't format on line, so try many. When we flatten here we make sure\n+    // to only flatten pairs with the same operator, that way we don't\n+    // necessarily need one line per sub-expression, but we don't do anything\n+    // too funny wrt precedence.\n+    expr.flatten(context, true)\n+        .and_then(|list| rewrite_pairs_multiline(list, shape, context))\n+}\n+\n+// This may return a multi-line result since we allow the last expression to go\n+// multiline in a 'single line' formatting.\n+fn rewrite_pairs_one_line<T: Rewrite>(\n+    list: &PairList<T>,\n+    shape: Shape,\n+    context: &RewriteContext,\n+) -> Option<String> {\n+    assert!(list.list.len() >= 2, \"Not a pair?\");\n+\n+    let mut result = String::new();\n+    let base_shape = shape.block();\n+\n+    for (e, s) in list.list[..list.list.len()]\n+        .iter()\n+        .zip(list.separators.iter())\n+    {\n+        let cur_shape = base_shape.offset_left(last_line_width(&result))?;\n+        let rewrite = e.rewrite(context, cur_shape)?;\n+\n+        if !is_single_line(&rewrite) || result.len() > shape.width {\n+            return None;\n+        }\n+\n+        result.push_str(&rewrite);\n+        result.push(' ');\n+        result.push_str(s);\n+        result.push(' ');\n+    }\n+\n+    let last = list.list.last().unwrap();\n+    let cur_shape = base_shape.offset_left(last_line_width(&result))?;\n+    let rewrite = last.rewrite(context, cur_shape)?;\n+    result.push_str(&rewrite);\n+\n+    if first_line_width(&result) > shape.width {\n+        return None;\n+    }\n+\n+    // Check the last expression in the list. We let this expression go over\n+    // multiple lines, but we check that if this is necessary, then we can't\n+    // do better using multi-line formatting.\n+    if !is_single_line(&result) {\n+        let multiline_shape = shape.offset_left(list.separators.last().unwrap().len() + 1)?;\n+        let multiline_list: PairList<T> = PairList {\n+            list: vec![last],\n+            separators: vec![],\n+            separator_place: list.separator_place,\n+        };\n+        // Format as if we were multi-line.\n+        if let Some(rewrite) = rewrite_pairs_multiline(multiline_list, multiline_shape, context) {\n+            // Also, don't let expressions surrounded by parens go multi-line,\n+            // this looks really bad.\n+            if rewrite.starts_with('(') || is_single_line(&rewrite) {\n+                return None;\n+            }\n+        }\n+    }\n+\n+    wrap_str(result, context.config.max_width(), shape)\n+}\n+\n+fn rewrite_pairs_multiline<T: Rewrite>(\n+    list: PairList<T>,\n+    shape: Shape,\n+    context: &RewriteContext,\n+) -> Option<String> {\n+    let rhs_offset = shape.rhs_overhead(&context.config);\n+    let nested_shape = (match context.config.indent_style() {\n+        IndentStyle::Visual => shape.visual_indent(0),\n+        IndentStyle::Block => shape.block_indent(context.config.tab_spaces()),\n+    }).with_max_width(&context.config)\n+        .sub_width(rhs_offset)?;\n+\n+    let indent_str = nested_shape.indent.to_string_with_newline(context.config);\n+    let mut result = String::new();\n+\n+    let rewrite = list.list[0].rewrite(context, shape)?;\n+    result.push_str(&rewrite);\n+\n+    for (e, s) in list.list[1..].iter().zip(list.separators.iter()) {\n+        if trimmed_last_line_width(&result) <= context.config.tab_spaces() {\n+            // We must snuggle the next line onto the previous line to avoid an orphan.\n+            if let Some(line_shape) =\n+                shape.offset_left(s.len() + 2 + trimmed_last_line_width(&result))\n+            {\n+                if let Some(rewrite) = e.rewrite(context, line_shape) {\n+                    result.push(' ');\n+                    result.push_str(s);\n+                    result.push(' ');\n+                    result.push_str(&rewrite);\n+                    continue;\n+                }\n+            }\n+        }\n+\n+        let nested_overhead = s.len() + 1;\n+        let line_shape = match context.config.binop_separator() {\n+            SeparatorPlace::Back => {\n+                result.push(' ');\n+                result.push_str(s);\n+                result.push_str(&indent_str);\n+                nested_shape.sub_width(nested_overhead)?\n+            }\n+            SeparatorPlace::Front => {\n+                result.push_str(&indent_str);\n+                result.push_str(s);\n+                result.push(' ');\n+                nested_shape.offset_left(nested_overhead)?\n+            }\n+        };\n+\n+        let rewrite = e.rewrite(context, line_shape)?;\n+        result.push_str(&rewrite);\n+    }\n+    Some(result)\n+}\n+\n+// Rewrites a single pair.\n+pub(crate) fn rewrite_pair<LHS, RHS>(\n     lhs: &LHS,\n     rhs: &RHS,\n     pp: PairParts,\n@@ -45,6 +187,7 @@ where\n     LHS: Rewrite,\n     RHS: Rewrite,\n {\n+    let tab_spaces = context.config.tab_spaces();\n     let lhs_overhead = match separator_place {\n         SeparatorPlace::Back => shape.used_width() + pp.prefix.len() + pp.infix.trim_right().len(),\n         SeparatorPlace::Front => shape.used_width(),\n@@ -66,12 +209,11 @@ where\n         // If the length of the lhs is equal to or shorter than the tab width or\n         // the rhs looks like block expression, we put the rhs on the same\n         // line with the lhs even if the rhs is multi-lined.\n-        let allow_same_line = lhs_result.len() <= context.config.tab_spaces()\n-            || rhs_result\n-                .lines()\n-                .next()\n-                .map(|first_line| first_line.ends_with('{'))\n-                .unwrap_or(false);\n+        let allow_same_line = lhs_result.len() <= tab_spaces || rhs_result\n+            .lines()\n+            .next()\n+            .map(|first_line| first_line.ends_with('{'))\n+            .unwrap_or(false);\n         if !rhs_result.contains('\\n') || allow_same_line {\n             let one_line_width = last_line_width(&lhs_result)\n                 + pp.infix.len()\n@@ -117,3 +259,68 @@ where\n         lhs_result, infix_with_sep, rhs_result, pp.suffix\n     ))\n }\n+\n+// A pair which forms a tree and can be flattened (e.g., binops).\n+trait FlattenPair: Rewrite + Sized {\n+    // If `_same_op` is `true`, then we only combine binops with the same\n+    // operator into the list. E.g,, if the source is `a * b + c`, if `_same_op`\n+    // is true, we make `[(a * b), c]` if `_same_op` is false, we make\n+    // `[a, b, c]`\n+    fn flatten(&self, _context: &RewriteContext, _same_op: bool) -> Option<PairList<Self>> {\n+        None\n+    }\n+}\n+\n+struct PairList<'a, 'b, T: Rewrite + 'b> {\n+    list: Vec<&'b T>,\n+    separators: Vec<&'a str>,\n+    separator_place: SeparatorPlace,\n+}\n+\n+impl FlattenPair for ast::Expr {\n+    fn flatten(&self, context: &RewriteContext, same_op: bool) -> Option<PairList<ast::Expr>> {\n+        let top_op = match self.node {\n+            ast::ExprKind::Binary(op, _, _) => op.node,\n+            _ => return None,\n+        };\n+\n+        // Turn a tree of binop expressions into a list using a depth-first,\n+        // in-order traversal.\n+        let mut stack = vec![];\n+        let mut list = vec![];\n+        let mut separators = vec![];\n+        let mut node = self;\n+        loop {\n+            match node.node {\n+                ast::ExprKind::Binary(op, ref lhs, _) if !same_op || op.node == top_op => {\n+                    stack.push(node);\n+                    node = lhs;\n+                }\n+                _ => {\n+                    list.push(node);\n+                    if let Some(pop) = stack.pop() {\n+                        match pop.node {\n+                            ast::ExprKind::Binary(op, _, ref rhs) => {\n+                                separators.push(op.node.to_string());\n+                                node = rhs;\n+                            }\n+                            _ => unreachable!(),\n+                        }\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        assert_eq!(list.len() - 1, separators.len());\n+        Some(PairList {\n+            list,\n+            separators,\n+            separator_place: context.config.binop_separator(),\n+        })\n+    }\n+}\n+\n+impl FlattenPair for ast::Ty {}\n+impl FlattenPair for ast::Pat {}"}]}