{"sha": "aac0281d30e3bf276422d215237c243047e5998b", "node_id": "C_kwDOAAsO6NoAKGFhYzAyODFkMzBlM2JmMjc2NDIyZDIxNTIzN2MyNDMwNDdlNTk5OGI", "commit": {"author": {"name": "Ibraheem Ahmed", "email": "ibrah1440@gmail.com", "date": "2021-10-11T21:41:25Z"}, "committer": {"name": "Ibraheem Ahmed", "email": "ibraheem@ibraheem.ca", "date": "2022-02-27T21:53:26Z"}, "message": "add `slice::{from_ptr_range, from_mut_ptr_range}`", "tree": {"sha": "2a805478a0d30c0c0d292de464e88bafeb1be2e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a805478a0d30c0c0d292de464e88bafeb1be2e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aac0281d30e3bf276422d215237c243047e5998b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aac0281d30e3bf276422d215237c243047e5998b", "html_url": "https://github.com/rust-lang/rust/commit/aac0281d30e3bf276422d215237c243047e5998b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aac0281d30e3bf276422d215237c243047e5998b/comments", "author": {"login": "ibraheemdev", "id": 34988408, "node_id": "MDQ6VXNlcjM0OTg4NDA4", "avatar_url": "https://avatars.githubusercontent.com/u/34988408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibraheemdev", "html_url": "https://github.com/ibraheemdev", "followers_url": "https://api.github.com/users/ibraheemdev/followers", "following_url": "https://api.github.com/users/ibraheemdev/following{/other_user}", "gists_url": "https://api.github.com/users/ibraheemdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibraheemdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibraheemdev/subscriptions", "organizations_url": "https://api.github.com/users/ibraheemdev/orgs", "repos_url": "https://api.github.com/users/ibraheemdev/repos", "events_url": "https://api.github.com/users/ibraheemdev/events{/privacy}", "received_events_url": "https://api.github.com/users/ibraheemdev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibraheemdev", "id": 34988408, "node_id": "MDQ6VXNlcjM0OTg4NDA4", "avatar_url": "https://avatars.githubusercontent.com/u/34988408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibraheemdev", "html_url": "https://github.com/ibraheemdev", "followers_url": "https://api.github.com/users/ibraheemdev/followers", "following_url": "https://api.github.com/users/ibraheemdev/following{/other_user}", "gists_url": "https://api.github.com/users/ibraheemdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibraheemdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibraheemdev/subscriptions", "organizations_url": "https://api.github.com/users/ibraheemdev/orgs", "repos_url": "https://api.github.com/users/ibraheemdev/repos", "events_url": "https://api.github.com/users/ibraheemdev/events{/privacy}", "received_events_url": "https://api.github.com/users/ibraheemdev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b043faba34ccc053a4d0110634c323f6c03765e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b043faba34ccc053a4d0110634c323f6c03765e", "html_url": "https://github.com/rust-lang/rust/commit/4b043faba34ccc053a4d0110634c323f6c03765e"}], "stats": {"total": 137, "additions": 137, "deletions": 0}, "files": [{"sha": "7d64a88cec67a8235c36ba7f42b54c6120ae94f1", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aac0281d30e3bf276422d215237c243047e5998b/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac0281d30e3bf276422d215237c243047e5998b/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=aac0281d30e3bf276422d215237c243047e5998b", "patch": "@@ -71,6 +71,9 @@ pub use raw::{from_raw_parts, from_raw_parts_mut};\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]\n pub use raw::{from_mut, from_ref};\n \n+#[unstable(feature = \"slice_from_ptr_range\", issue = \"89792\")]\n+pub use raw::{from_mut_ptr_range, from_ptr_range};\n+\n // This function is public only because there is no other way to unit test heapsort.\n #[unstable(feature = \"sort_internals\", reason = \"internal to sort module\", issue = \"none\")]\n pub use sort::heapsort;"}, {"sha": "39c8d68e4bf343dbfec4e20f9143b1b4bfd625b1", "filename": "library/core/src/slice/raw.rs", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/aac0281d30e3bf276422d215237c243047e5998b/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac0281d30e3bf276422d215237c243047e5998b/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs?ref=aac0281d30e3bf276422d215237c243047e5998b", "patch": "@@ -1,6 +1,7 @@\n //! Free functions to create `&[T]` and `&mut [T]`.\n \n use crate::array;\n+use crate::ops::Range;\n use crate::ptr;\n \n /// Forms a slice from a pointer and a length.\n@@ -177,3 +178,113 @@ pub const fn from_ref<T>(s: &T) -> &[T] {\n pub const fn from_mut<T>(s: &mut T) -> &mut [T] {\n     array::from_mut(s)\n }\n+\n+/// Forms a slice from a pointer range.\n+///\n+/// This function is useful for interacting with foreign interfaces which\n+/// use two pointers to refer to a range of elements in memory, as is\n+/// common in C++.\n+///\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * The `start` pointer of the range must be a [valid] and properly aligned pointer\n+///   to the first element of a slice.\n+///\n+/// * The `end` pointer must be a [valid] and properly aligned pointer to *one past*\n+///   the last element, such that the offset from the end to the start pointer is\n+///   the length of the slice.\n+///\n+/// * The range must contain `N` consecutive properly initialized values of type `T`:\n+///\n+///     * The entire memory range of this slice must be contained within a single allocated object!\n+///       Slices can never span across multiple allocated objects.\n+///\n+/// * The memory referenced by the returned slice must not be mutated for the duration\n+///   of lifetime `'a`, except inside an `UnsafeCell`.\n+///\n+/// * The total length of the range must be no larger than `isize::MAX`.\n+///   See the safety documentation of [`pointer::offset`].\n+///\n+/// Note that a range created from [`slice::as_ptr_range`] fulfills these requirements.\n+///\n+/// # Caveat\n+///\n+/// The lifetime for the returned slice is inferred from its usage. To\n+/// prevent accidental misuse, it's suggested to tie the lifetime to whichever\n+/// source lifetime is safe in the context, such as by providing a helper\n+/// function taking the lifetime of a host value for the slice, or by explicit\n+/// annotation.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(slice_from_ptr_range)]\n+///\n+/// use core::slice;\n+///\n+/// let x = [1, 2, 3];\n+/// let range = x.as_ptr_range();\n+///\n+/// unsafe {\n+///     assert_eq!(slice::from_ptr_range(range), &x);\n+/// }\n+/// ```\n+///\n+/// [valid]: ptr#safety\n+#[unstable(feature = \"slice_from_ptr_range\", issue = \"89792\")]\n+pub unsafe fn from_ptr_range<'a, T>(range: Range<*const T>) -> &'a [T] {\n+    // SAFETY: the caller must uphold the safety contract for `from_ptr_range`.\n+    unsafe { from_raw_parts(range.start, range.end.offset_from(range.start) as usize) }\n+}\n+\n+/// Performs the same functionality as [`from_ptr_range`], except that a\n+/// mutable slice is returned.\n+///\n+/// # Safety\n+///\n+/// Behavior is undefined if any of the following conditions are violated:\n+///\n+/// * The `start` pointer of the range must be a [valid] and properly aligned pointer\n+///   to the first element of a slice.\n+///\n+/// * The `end` pointer must be a [valid] and properly aligned pointer to *one past*\n+///   the last element, such that the offset from the end to the start pointer is\n+///   the length of the slice.\n+///\n+/// * The range must contain `N` consecutive properly initialized values of type `T`:\n+///\n+///     * The entire memory range of this slice must be contained within a single allocated object!\n+///       Slices can never span across multiple allocated objects.\n+///\n+/// * The memory referenced by the returned slice must not be accessed through any other pointer\n+///   (not derived from the return value) for the duration of lifetime `'a`.\n+///   Both read and write accesses are forbidden.\n+///\n+/// * The total length of the range must be no larger than `isize::MAX`.\n+///   See the safety documentation of [`pointer::offset`].\n+///\n+/// Note that a range created from [`slice::as_mut_ptr_range`] fulfills these requirements.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(slice_from_ptr_range)]\n+///\n+/// use core::slice;\n+///\n+/// let mut x = [1, 2, 3];\n+/// let range = x.as_mut_ptr_range();\n+///\n+/// unsafe {\n+///     assert_eq!(slice::from_mut_ptr_range(range), &mut [1, 2, 3]);\n+/// }\n+/// ```\n+///\n+/// [valid]: ptr#safety\n+#[unstable(feature = \"slice_from_ptr_range\", issue = \"89792\")]\n+pub unsafe fn from_mut_ptr_range<'a, T>(range: Range<*mut T>) -> &'a mut [T] {\n+    // SAFETY: the caller must uphold the safety contract for `from_mut_ptr_range`.\n+    unsafe { from_raw_parts_mut(range.start, range.end.offset_from(range.start) as usize) }\n+}"}, {"sha": "fb59bc2596f76435043bf6cfbdcd3c9ba9f1b8dc", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aac0281d30e3bf276422d215237c243047e5998b/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac0281d30e3bf276422d215237c243047e5998b/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=aac0281d30e3bf276422d215237c243047e5998b", "patch": "@@ -48,6 +48,7 @@\n #![feature(pin_macro)]\n #![feature(sort_internals)]\n #![feature(slice_take)]\n+#![feature(slice_from_ptr_range)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_array_assume_init)]\n #![feature(maybe_uninit_write_slice)]"}, {"sha": "06a30d7096c775d4ef306f7d89fbcbd6ae5274d7", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aac0281d30e3bf276422d215237c243047e5998b/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac0281d30e3bf276422d215237c243047e5998b/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=aac0281d30e3bf276422d215237c243047e5998b", "patch": "@@ -2,6 +2,7 @@ use core::cell::Cell;\n use core::cmp::Ordering;\n use core::mem::MaybeUninit;\n use core::result::Result::{Err, Ok};\n+use core::slice;\n \n #[test]\n fn test_position() {\n@@ -2480,3 +2481,24 @@ take_tests! {\n     (take_mut_oob_max_range_to_inclusive, (..=usize::MAX), None, empty_max_mut!()),\n     (take_mut_in_bounds_max_range_from, (usize::MAX..), Some(&mut [] as _), empty_max_mut!()),\n }\n+\n+#[test]\n+fn test_slice_from_ptr_range() {\n+    let arr = [\"foo\".to_owned(), \"bar\".to_owned()];\n+    let range = arr.as_ptr_range();\n+    unsafe {\n+        assert_eq!(slice::from_ptr_range(range), &arr);\n+    }\n+\n+    let mut arr = [1, 2, 3];\n+    let range = arr.as_mut_ptr_range();\n+    unsafe {\n+        assert_eq!(slice::from_mut_ptr_range(range), &mut [1, 2, 3]);\n+    }\n+\n+    let arr: [Vec<String>; 0] = [];\n+    let range = arr.as_ptr_range();\n+    unsafe {\n+        assert_eq!(slice::from_ptr_range(range), &arr);\n+    }\n+}"}]}