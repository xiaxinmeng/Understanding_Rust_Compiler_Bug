{"sha": "30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZTdlOWM1ZjBjZGQ1Y2UyZjI2M2U3OWYyZmU3ODIwMzMyZjAyZWQ=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-14T18:02:15Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-04-01T19:47:55Z"}, "message": "Support allocating iterators with arenas", "tree": {"sha": "85dc5ea50d1a1fab94f204e8e296f3d43b6da61b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85dc5ea50d1a1fab94f204e8e296f3d43b6da61b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed", "html_url": "https://github.com/rust-lang/rust/commit/30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ebf47851a357faa4cd97f4b1dc7835f6376e639", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ebf47851a357faa4cd97f4b1dc7835f6376e639", "html_url": "https://github.com/rust-lang/rust/commit/9ebf47851a357faa4cd97f4b1dc7835f6376e639"}], "stats": {"total": 146, "additions": 130, "deletions": 16}, "files": [{"sha": "b97fbe75b97c2627d1f3fe634895a2ff5341086b", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed", "patch": "@@ -54,6 +54,7 @@ name = \"arena\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_data_structures 0.0.0\",\n+ \"smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "aa1bf38b995976f2d26c424b697281384eb75474", "filename": "src/libarena/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed", "patch": "@@ -11,3 +11,4 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "343fcd2b703bdf009ba516be1c6ded256fd671d2", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 128, "deletions": 16, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=30e7e9c5f0cdd5ce2f263e79f2fe7820332f02ed", "patch": "@@ -23,7 +23,9 @@\n \n extern crate alloc;\n \n+use rustc_data_structures::cold_path;\n use rustc_data_structures::sync::MTLock;\n+use smallvec::SmallVec;\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n@@ -55,13 +57,16 @@ pub struct TypedArena<T> {\n struct TypedArenaChunk<T> {\n     /// The raw storage for the arena chunk.\n     storage: RawVec<T>,\n+    /// The number of valid entries in the chunk.\n+    entries: usize,\n }\n \n impl<T> TypedArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> TypedArenaChunk<T> {\n         TypedArenaChunk {\n             storage: RawVec::with_capacity(capacity),\n+            entries: 0,\n         }\n     }\n \n@@ -149,6 +154,27 @@ impl<T> TypedArena<T> {\n         }\n     }\n \n+    #[inline]\n+    fn can_allocate(&self, len: usize) -> bool {\n+        let available_capacity_bytes = self.end.get() as usize - self.ptr.get() as usize;\n+        let at_least_bytes = len.checked_mul(mem::size_of::<T>()).unwrap();\n+        available_capacity_bytes >= at_least_bytes\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_raw_slice(&self, len: usize) -> *mut T {\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(len != 0);\n+\n+        if !self.can_allocate(len) {\n+            self.grow(len);\n+        }\n+\n+        let start_ptr = self.ptr.get();\n+        self.ptr.set(start_ptr.add(len));\n+        start_ptr\n+    }\n+\n     /// Allocates a slice of objects that are copied into the `TypedArena`, returning a mutable\n     /// reference to it. Will panic if passed a zero-sized types.\n     ///\n@@ -161,21 +187,63 @@ impl<T> TypedArena<T> {\n     where\n         T: Copy,\n     {\n+        unsafe {\n+            let len = slice.len();\n+            let start_ptr = self.alloc_raw_slice(len);\n+            slice.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+            slice::from_raw_parts_mut(start_ptr, len)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn alloc_from_iter<I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n         assert!(mem::size_of::<T>() != 0);\n-        assert!(slice.len() != 0);\n+        let mut iter = iter.into_iter();\n+        let size_hint = iter.size_hint();\n \n-        let available_capacity_bytes = self.end.get() as usize - self.ptr.get() as usize;\n-        let at_least_bytes = slice.len() * mem::size_of::<T>();\n-        if available_capacity_bytes < at_least_bytes {\n-            self.grow(slice.len());\n-        }\n+        match size_hint {\n+            (min, Some(max)) if min == max => {\n+                if min == 0 {\n+                    return &mut [];\n+                }\n \n-        unsafe {\n-            let start_ptr = self.ptr.get();\n-            let arena_slice = slice::from_raw_parts_mut(start_ptr, slice.len());\n-            self.ptr.set(start_ptr.add(arena_slice.len()));\n-            arena_slice.copy_from_slice(slice);\n-            arena_slice\n+                if !self.can_allocate(min) {\n+                    self.grow(min);\n+                }\n+\n+                let slice = self.ptr.get();\n+\n+                unsafe {\n+                    let mut ptr = self.ptr.get();\n+                    for _ in 0..min {\n+                        // Write into uninitialized memory.\n+                        ptr::write(ptr, iter.next().unwrap());\n+                        // Advance the pointer.\n+                        ptr = ptr.offset(1);\n+                        // Update the pointer per iteration so if `iter.next()` panics\n+                        // we destroy the correct amount\n+                        self.ptr.set(ptr);\n+                    }\n+                    slice::from_raw_parts_mut(slice, min)\n+                }\n+            }\n+            _ => {\n+                cold_path(move || -> &mut [T] {\n+                    let mut vec: SmallVec<[_; 8]> = iter.collect();\n+                    if vec.is_empty() {\n+                        return &mut [];\n+                    }\n+                    // Move the content to the arena by copying it and then forgetting\n+                    // the content of the SmallVec\n+                    unsafe {\n+                        let len = vec.len();\n+                        let start_ptr = self.alloc_raw_slice(len);\n+                        vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+                        mem::forget(vec.drain());\n+                        slice::from_raw_parts_mut(start_ptr, len)\n+                    }\n+                })\n+            }\n         }\n     }\n \n@@ -189,6 +257,7 @@ impl<T> TypedArena<T> {\n             if let Some(last_chunk) = chunks.last_mut() {\n                 let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n                 let currently_used_cap = used_bytes / mem::size_of::<T>();\n+                last_chunk.entries = currently_used_cap;\n                 if last_chunk.storage.reserve_in_place(currently_used_cap, n) {\n                     self.end.set(last_chunk.end());\n                     return;\n@@ -222,8 +291,7 @@ impl<T> TypedArena<T> {\n                 let len = chunks_borrow.len();\n                 // If `T` is ZST, code below has no effect.\n                 for mut chunk in chunks_borrow.drain(..len-1) {\n-                    let cap = chunk.storage.cap();\n-                    chunk.destroy(cap);\n+                    chunk.destroy(chunk.entries);\n                 }\n             }\n         }\n@@ -265,8 +333,7 @@ unsafe impl<#[may_dangle] T> Drop for TypedArena<T> {\n                 self.clear_last_chunk(&mut last_chunk);\n                 // The last chunk will be dropped. Destroy all other chunks.\n                 for chunk in chunks_borrow.iter_mut() {\n-                    let cap = chunk.storage.cap();\n-                    chunk.destroy(cap);\n+                    chunk.destroy(chunk.entries);\n                 }\n             }\n             // RawVec handles deallocation of `last_chunk` and `self.chunks`.\n@@ -410,6 +477,51 @@ impl DroplessArena {\n             arena_slice\n         }\n     }\n+\n+    #[inline]\n+    pub fn alloc_from_iter<T, I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n+        let mut iter = iter.into_iter();\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(!mem::needs_drop::<T>());\n+\n+        let size_hint = iter.size_hint();\n+\n+        match size_hint {\n+            (min, Some(max)) if min == max => {\n+                if min == 0 {\n+                    return &mut []\n+                }\n+                let size = min.checked_mul(mem::size_of::<T>()).unwrap();\n+                let mem = self.alloc_raw(size, mem::align_of::<T>()) as *mut _ as *mut T;\n+                unsafe {\n+                    for i in 0..min {\n+                        ptr::write(mem.offset(i as isize), iter.next().unwrap())\n+                    }\n+                    slice::from_raw_parts_mut(mem, min)\n+                }\n+            }\n+            (_, _) => {\n+                cold_path(move || -> &mut [T] {\n+                    let mut vec: SmallVec<[_; 8]> = iter.collect();\n+                    if vec.is_empty() {\n+                        return &mut [];\n+                    }\n+                    // Move the content to the arena by copying it and then forgetting\n+                    // the content of the SmallVec\n+                    unsafe {\n+                        let len = vec.len();\n+                        let start_ptr = self.alloc_raw(\n+                            len * mem::size_of::<T>(),\n+                            mem::align_of::<T>()\n+                        ) as *mut _ as *mut T;\n+                        vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+                        mem::forget(vec.drain());\n+                        slice::from_raw_parts_mut(start_ptr, len)\n+                    }\n+                })\n+            }\n+        }\n+    }\n }\n \n #[derive(Default)]"}]}