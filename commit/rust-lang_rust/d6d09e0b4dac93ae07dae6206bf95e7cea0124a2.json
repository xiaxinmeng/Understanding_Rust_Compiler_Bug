{"sha": "d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZDA5ZTBiNGRhYzkzYWUwN2RhZTYyMDZiZjk1ZTdjZWEwMTI0YTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-21T22:52:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-21T22:52:19Z"}, "message": "Auto merge of #45879 - nikomatsakis:nll-kill-cyclic-closures, r=arielb1\n\nmove closure kind, signature into `ClosureSubsts`\n\nInstead of using side-tables, store the closure-kind and signature in the substitutions themselves. This has two key effects:\n\n- It means that the closure's type changes as inference finds out more things, which is very nice.\n    - As a result, it avoids the need for the `freshen_closure_like` code (though we still use it for generators).\n- It avoids cyclic closures calls.\n    - These were never meant to be supported, precisely because they make a lot of the fancy inference that we do much more complicated. However, due to an oversight, it was previously possible -- if challenging -- to create a setup where a closure *directly* called itself (see e.g. #21410).\n\nWe have to see what the effect of this change is, though. Needs a crater run. Marking as [WIP] until that has been assessed.\n\nr? @arielb1", "tree": {"sha": "245513cfdfc7bac11b0e7049ea60bf9908b01216", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/245513cfdfc7bac11b0e7049ea60bf9908b01216"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "html_url": "https://github.com/rust-lang/rust/commit/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63739ab7b210c1a8c890c2ea5238a3284877daa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/63739ab7b210c1a8c890c2ea5238a3284877daa3", "html_url": "https://github.com/rust-lang/rust/commit/63739ab7b210c1a8c890c2ea5238a3284877daa3"}, {"sha": "00732a31a0a9b00d4ffb333473ae95e66f8e1dfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/00732a31a0a9b00d4ffb333473ae95e66f8e1dfc", "html_url": "https://github.com/rust-lang/rust/commit/00732a31a0a9b00d4ffb333473ae95e66f8e1dfc"}], "stats": {"total": 1785, "additions": 1003, "deletions": 782}, "files": [{"sha": "db3aa9a1efa4b6fa1ff99f1e30978cf7b2729ff5", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -498,9 +498,7 @@ define_dep_nodes!( <'tcx>\n     [] IsAutoImpl(DefId),\n     [] ImplTraitRef(DefId),\n     [] ImplPolarity(DefId),\n-    [] ClosureKind(DefId),\n     [] FnSignature(DefId),\n-    [] GenSignature(DefId),\n     [] CoerceUnsizedInfo(DefId),\n \n     [] ItemVarianceConstraints(DefId),"}, {"sha": "cba1a66c17c42e231d12dc447c180ac03195eeaa", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -1969,8 +1969,39 @@ fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n ```\n \"##,\n \n+E0644: r##\"\n+A closure or generator was constructed that references its own type.\n+\n+Erroneous example:\n+\n+```compile-fail,E0644\n+fn fix<F>(f: &F)\n+  where F: Fn(&F)\n+{\n+  f(&f);\n }\n \n+fn main() {\n+  fix(&|y| {\n+    // Here, when `x` is called, the parameter `y` is equal to `x`.\n+  });\n+}\n+```\n+\n+Rust does not permit a closure to directly reference its own type,\n+either through an argument (as in the example above) or by capturing\n+itself through its environment. This restriction helps keep closure\n+inference tractable.\n+\n+The easiest fix is to rewrite your closure into a top-level function,\n+or into a method. In some cases, you may also be able to have your\n+closure call itself by capturing a `&Fn()` object or `fn()` pointer\n+that refers to itself. That is permitting, since the closure would be\n+invoking itself via a virtual call, and hence does not directly\n+reference its own *type*.\n+\n+\"##, }\n+\n \n register_diagnostics! {\n //  E0006 // merged with E0005"}, {"sha": "8f2ad98f85885bb1fb7db4c3a1eb2e59044ff95a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -236,8 +236,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Predicate<'gcx> {\n             ty::Predicate::ObjectSafe(def_id) => {\n                 def_id.hash_stable(hcx, hasher);\n             }\n-            ty::Predicate::ClosureKind(def_id, closure_kind) => {\n+            ty::Predicate::ClosureKind(def_id, closure_substs, closure_kind) => {\n                 def_id.hash_stable(hcx, hasher);\n+                closure_substs.hash_stable(hcx, hasher);\n                 closure_kind.hash_stable(hcx, hasher);\n             }\n             ty::Predicate::ConstEvaluatable(def_id, substs) => {"}, {"sha": "50a37e12531a76df5768e367655f6ad3bc144fd5", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -270,6 +270,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n             for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n             ambient_variance,\n             needs_wf: false,\n+            root_ty: ty,\n         };\n \n         let ty = generalize.relate(&ty, &ty)?;\n@@ -280,10 +281,23 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n \n struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+\n+    /// Span, used when creating new type variables and things.\n     span: Span,\n+\n+    /// The vid of the type variable that is in the process of being\n+    /// instantiated; if we find this within the type we are folding,\n+    /// that means we would have created a cyclic type.\n     for_vid_sub_root: ty::TyVid,\n+\n+    /// Track the variance as we descend into the type.\n     ambient_variance: ty::Variance,\n-    needs_wf: bool, // see the field `needs_wf` in `Generalization`\n+\n+    /// See the field `needs_wf` in `Generalization`.\n+    needs_wf: bool,\n+\n+    /// The root type that we are generalizing. Used when reporting cycles.\n+    root_ty: Ty<'tcx>,\n }\n \n /// Result from a generalization operation. This includes\n@@ -386,7 +400,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                 if sub_vid == self.for_vid_sub_root {\n                     // If sub-roots are equal, then `for_vid` and\n                     // `vid` are related via subtyping.\n-                    return Err(TypeError::CyclicTy);\n+                    return Err(TypeError::CyclicTy(self.root_ty));\n                 } else {\n                     match variables.probe_root(vid) {\n                         Some(u) => {"}, {"sha": "6fadafc7b97aec8d7681cd110870c3a3deac1e9a", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -689,9 +689,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                          diag: &mut DiagnosticBuilder<'tcx>,\n                          cause: &ObligationCause<'tcx>,\n                          secondary_span: Option<(Span, String)>,\n-                         values: Option<ValuePairs<'tcx>>,\n+                         mut values: Option<ValuePairs<'tcx>>,\n                          terr: &TypeError<'tcx>)\n     {\n+        // For some types of errors, expected-found does not make\n+        // sense, so just ignore the values we were given.\n+        match terr {\n+            TypeError::CyclicTy(_) => { values = None; }\n+            _ => { }\n+        }\n+\n         let (expected_found, exp_found, is_simple_error) = match values {\n             None => (None, None, false),\n             Some(values) => {\n@@ -780,17 +787,20 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                terr);\n \n         let span = trace.cause.span;\n-        let failure_str = trace.cause.as_failure_str();\n-        let mut diag = match trace.cause.code {\n-            ObligationCauseCode::IfExpressionWithNoElse => {\n+        let failure_code = trace.cause.as_failure_code(terr);\n+        let mut diag = match failure_code {\n+            FailureCode::Error0317(failure_str) => {\n                 struct_span_err!(self.tcx.sess, span, E0317, \"{}\", failure_str)\n             }\n-            ObligationCauseCode::MainFunctionType => {\n+            FailureCode::Error0580(failure_str) => {\n                 struct_span_err!(self.tcx.sess, span, E0580, \"{}\", failure_str)\n             }\n-            _ => {\n+            FailureCode::Error0308(failure_str) => {\n                 struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str)\n             }\n+            FailureCode::Error0644(failure_str) => {\n+                struct_span_err!(self.tcx.sess, span, E0644, \"{}\", failure_str)\n+            }\n         };\n         self.note_type_err(&mut diag, &trace.cause, None, Some(trace.values), terr);\n         diag\n@@ -1040,23 +1050,40 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n+enum FailureCode {\n+    Error0317(&'static str),\n+    Error0580(&'static str),\n+    Error0308(&'static str),\n+    Error0644(&'static str),\n+}\n+\n impl<'tcx> ObligationCause<'tcx> {\n-    fn as_failure_str(&self) -> &'static str {\n+    fn as_failure_code(&self, terr: &TypeError<'tcx>) -> FailureCode {\n+        use self::FailureCode::*;\n         use traits::ObligationCauseCode::*;\n         match self.code {\n-            CompareImplMethodObligation { .. } => \"method not compatible with trait\",\n-            MatchExpressionArm { source, .. } => match source {\n+            CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n+            MatchExpressionArm { source, .. } => Error0308(match source {\n                 hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have incompatible types\",\n                 _ => \"match arms have incompatible types\",\n-            },\n-            IfExpression => \"if and else have incompatible types\",\n-            IfExpressionWithNoElse => \"if may be missing an else clause\",\n-            EquatePredicate => \"equality predicate not satisfied\",\n-            MainFunctionType => \"main function has wrong type\",\n-            StartFunctionType => \"start function has wrong type\",\n-            IntrinsicType => \"intrinsic has wrong type\",\n-            MethodReceiver => \"mismatched method receiver\",\n-            _ => \"mismatched types\",\n+            }),\n+            IfExpression => Error0308(\"if and else have incompatible types\"),\n+            IfExpressionWithNoElse => Error0317(\"if may be missing an else clause\"),\n+            EquatePredicate => Error0308(\"equality predicate not satisfied\"),\n+            MainFunctionType => Error0580(\"main function has wrong type\"),\n+            StartFunctionType => Error0308(\"start function has wrong type\"),\n+            IntrinsicType => Error0308(\"intrinsic has wrong type\"),\n+            MethodReceiver => Error0308(\"mismatched method receiver\"),\n+\n+            // In the case where we have no more specific thing to\n+            // say, also take a look at the error code, maybe we can\n+            // tailor to that.\n+            _ => match terr {\n+                TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() =>\n+                    Error0644(\"closure/generator type that references itself\"),\n+                _ =>\n+                    Error0308(\"mismatched types\"),\n+            }\n         }\n     }\n "}, {"sha": "ea3c0a8ddb4507d9c9e3851f6643eab1bc134926", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -125,9 +125,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // ```\n             labels.clear();\n             labels.push((pattern.span, format!(\"consider giving this closure parameter a type\")));\n-        }\n-\n-        if let Some(pattern) = local_visitor.found_local_pattern {\n+        } else if let Some(pattern) = local_visitor.found_local_pattern {\n             if let Some(simple_name) = pattern.simple_name() {\n                 labels.push((pattern.span, format!(\"consider giving `{}` a type\", simple_name)));\n             } else {"}, {"sha": "426c61e9ac083eb66042352befedeb6299938c7f", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 131, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -43,9 +43,7 @@\n \n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeFolder;\n-use ty::subst::Substs;\n use util::nodemap::FxHashMap;\n-use hir::def_id::DefId;\n \n use std::collections::hash_map::Entry;\n \n@@ -56,7 +54,6 @@ pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     freshen_count: u32,\n     freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n-    closure_set: Vec<DefId>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n@@ -66,7 +63,6 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n             infcx,\n             freshen_count: 0,\n             freshen_map: FxHashMap(),\n-            closure_set: vec![],\n         }\n     }\n \n@@ -92,88 +88,6 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n-\n-    fn next_fresh<F>(&mut self,\n-                     freshener: F)\n-                     -> Ty<'tcx>\n-        where F: FnOnce(u32) -> ty::InferTy,\n-    {\n-        let index = self.freshen_count;\n-        self.freshen_count += 1;\n-        self.infcx.tcx.mk_infer(freshener(index))\n-    }\n-\n-    fn freshen_closure_like<M, C>(&mut self,\n-                                  def_id: DefId,\n-                                  substs: ty::ClosureSubsts<'tcx>,\n-                                  t: Ty<'tcx>,\n-                                  markers: M,\n-                                  combine: C)\n-                                  -> Ty<'tcx>\n-        where M: FnOnce(&mut Self) -> (Ty<'tcx>, Ty<'tcx>),\n-              C: FnOnce(&'tcx Substs<'tcx>) -> Ty<'tcx>\n-    {\n-        let tcx = self.infcx.tcx;\n-\n-        let closure_in_progress = self.infcx.in_progress_tables.map_or(false, |tables| {\n-            tcx.hir.as_local_node_id(def_id).map_or(false, |closure_id| {\n-                tables.borrow().local_id_root ==\n-                    Some(DefId::local(tcx.hir.node_to_hir_id(closure_id).owner))\n-            })\n-        });\n-\n-        if !closure_in_progress {\n-            // If this closure belongs to another infcx, its kind etc. were\n-            // fully inferred and its signature/kind are exactly what's listed\n-            // in its infcx. So we don't need to add the markers for them.\n-            return t.super_fold_with(self);\n-        }\n-\n-        // We are encoding a closure in progress. Because we want our freshening\n-        // key to contain all inference information needed to make sense of our\n-        // value, we need to encode the closure signature and kind. The way\n-        // we do that is to add them as 2 variables to the closure substs,\n-        // basically because it's there (and nobody cares about adding extra stuff\n-        // to substs).\n-        //\n-        // This means the \"freshened\" closure substs ends up looking like\n-        //     fresh_substs = [PARENT_SUBSTS* ; UPVARS* ; SIG_MARKER ; KIND_MARKER]\n-        let (marker_1, marker_2) = if self.closure_set.contains(&def_id) {\n-            // We found the closure def-id within its own signature. Just\n-            // leave a new freshened type - any matching operations would\n-            // have found and compared the exterior closure already to\n-            // get here.\n-            //\n-            // In that case, we already know what the signature would\n-            // be - the parent closure on the stack already contains a\n-            // \"copy\" of the signature, so there is no reason to encode\n-            // it again for injectivity. Just use a fresh type variable\n-            // to make everything comparable.\n-            //\n-            // For example (closure kinds omitted for clarity)\n-            //     t=[closure FOO sig=[closure BAR sig=[closure FOO ..]]]\n-            // Would get encoded to\n-            //     t=[closure FOO sig=[closure BAR sig=[closure FOO sig=$0]]]\n-            //\n-            // and we can decode by having\n-            //     $0=[closure BAR {sig doesn't exist in decode}]\n-            // and get\n-            //     t=[closure FOO]\n-            //     sig[FOO] = [closure BAR]\n-            //     sig[BAR] = [closure FOO]\n-            (self.next_fresh(ty::FreshTy), self.next_fresh(ty::FreshTy))\n-        } else {\n-            self.closure_set.push(def_id);\n-            let markers = markers(self);\n-            self.closure_set.pop();\n-            markers\n-        };\n-\n-        combine(tcx.mk_substs(\n-            substs.substs.iter().map(|k| k.fold_with(self)).chain(\n-                [marker_1, marker_2].iter().cloned().map(From::from)\n-                    )))\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n@@ -249,51 +163,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 t\n             }\n \n-            ty::TyClosure(def_id, substs) => {\n-                self.freshen_closure_like(\n-                    def_id, substs, t,\n-                    |this| {\n-                        // HACK: use a \"random\" integer type to mark the kind. Because\n-                        // different closure kinds shouldn't get unified during\n-                        // selection, the \"subtyping\" relationship (where any kind is\n-                        // better than no kind) shouldn't  matter here, just that the\n-                        // types are different.\n-                        let closure_kind = this.infcx.closure_kind(def_id);\n-                        let closure_kind_marker = match closure_kind {\n-                            None => tcx.types.i8,\n-                            Some(ty::ClosureKind::Fn) => tcx.types.i16,\n-                            Some(ty::ClosureKind::FnMut) => tcx.types.i32,\n-                            Some(ty::ClosureKind::FnOnce) => tcx.types.i64,\n-                        };\n-\n-                        let closure_sig = this.infcx.fn_sig(def_id);\n-                        (tcx.mk_fn_ptr(closure_sig.fold_with(this)),\n-                         closure_kind_marker)\n-                    },\n-                    |substs| tcx.mk_closure(def_id, substs)\n-                )\n-            }\n-\n-            ty::TyGenerator(def_id, substs, interior) => {\n-                self.freshen_closure_like(\n-                    def_id, substs, t,\n-                    |this| {\n-                        let gen_sig = this.infcx.generator_sig(def_id).unwrap();\n-                        // FIXME: want to revise this strategy when generator\n-                        // signatures can actually contain LBRs.\n-                        let sig = this.tcx().no_late_bound_regions(&gen_sig)\n-                            .unwrap_or_else(|| {\n-                                bug!(\"late-bound regions in signature of {:?}\",\n-                                     def_id)\n-                            });\n-                        (sig.yield_ty, sig.return_ty).fold_with(this)\n-                    },\n-                    |substs| {\n-                        tcx.mk_generator(def_id, ty::ClosureSubsts { substs }, interior)\n-                    }\n-                )\n-            }\n-\n+            ty::TyGenerator(..) |\n             ty::TyBool |\n             ty::TyChar |\n             ty::TyInt(..) |\n@@ -314,6 +184,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyProjection(..) |\n             ty::TyForeign(..) |\n             ty::TyParam(..) |\n+            ty::TyClosure(..) |\n             ty::TyAnon(..) => {\n                 t.super_fold_with(self)\n             }"}, {"sha": "7302bad0ca166f3d9af5cffe17727b9e8097df3f", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -1463,58 +1463,53 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         !traits::type_known_to_meet_bound(self, param_env, ty, copy_def_id, span)\n     }\n \n+    /// Obtains the latest type of the given closure; this may be a\n+    /// closure in the current function, in which case its\n+    /// `ClosureKind` may not yet be known.\n     pub fn closure_kind(&self,\n-                        def_id: DefId)\n+                        closure_def_id: DefId,\n+                        closure_substs: ty::ClosureSubsts<'tcx>)\n                         -> Option<ty::ClosureKind>\n     {\n-        if let Some(tables) = self.in_progress_tables {\n-            if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let hir_id = self.tcx.hir.node_to_hir_id(id);\n-                return tables.borrow()\n-                             .closure_kinds()\n-                             .get(hir_id)\n-                             .cloned()\n-                             .map(|(kind, _)| kind);\n-            }\n-        }\n-\n-        // During typeck, ALL closures are local. But afterwards,\n-        // during trans, we see closure ids from other traits.\n-        // That may require loading the closure data out of the\n-        // cstore.\n-        Some(self.tcx.closure_kind(def_id))\n+        let closure_kind_ty = closure_substs.closure_kind_ty(closure_def_id, self.tcx);\n+        let closure_kind_ty = self.shallow_resolve(&closure_kind_ty);\n+        closure_kind_ty.to_opt_closure_kind()\n     }\n \n     /// Obtain the signature of a function or closure.\n     /// For closures, unlike `tcx.fn_sig(def_id)`, this method will\n     /// work during the type-checking of the enclosing function and\n     /// return the closure signature in its partially inferred state.\n     pub fn fn_sig(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n+        // Do we have an in-progress set of tables we are inferring?\n         if let Some(tables) = self.in_progress_tables {\n+            // Is this a local item?\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let hir_id = self.tcx.hir.node_to_hir_id(id);\n-                if let Some(&ty) = tables.borrow().closure_tys().get(hir_id) {\n-                    return ty;\n+                // Is it a local *closure*?\n+                if self.tcx.is_closure(def_id) {\n+                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                    // Is this local closure contained within the tables we are inferring?\n+                    if tables.borrow().local_id_root == Some(DefId::local(hir_id.owner)) {\n+                        // if so, extract signature from there.\n+                        let closure_ty = tables.borrow().node_id_to_type(hir_id);\n+                        let (closure_def_id, closure_substs) = match closure_ty.sty {\n+                            ty::TyClosure(closure_def_id, closure_substs) =>\n+                                (closure_def_id, closure_substs),\n+                            _ =>\n+                                bug!(\"closure with non-closure type: {:?}\", closure_ty),\n+                        };\n+                        assert_eq!(def_id, closure_def_id);\n+                        let closure_sig_ty = closure_substs.closure_sig_ty(def_id, self.tcx);\n+                        let closure_sig_ty = self.shallow_resolve(&closure_sig_ty);\n+                        return closure_sig_ty.fn_sig(self.tcx);\n+                    }\n                 }\n             }\n         }\n \n         self.tcx.fn_sig(def_id)\n     }\n \n-    pub fn generator_sig(&self, def_id: DefId) -> Option<ty::PolyGenSig<'tcx>> {\n-        if let Some(tables) = self.in_progress_tables {\n-            if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let hir_id = self.tcx.hir.node_to_hir_id(id);\n-                if let Some(&ty) = tables.borrow().generator_sigs().get(hir_id) {\n-                    return ty.map(|t| ty::Binder(t));\n-                }\n-            }\n-        }\n-\n-        self.tcx.generator_sig(def_id)\n-    }\n-\n     /// Normalizes associated types in `value`, potentially returning\n     /// new obligations that must further be processed.\n     pub fn partially_normalize_associated_types_in<T>(&self,"}, {"sha": "6aa094d2cd6d7483c078142f42fec337c8d3d652", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -56,7 +56,10 @@ pub enum TypeVariableOrigin {\n     NormalizeProjectionType(Span),\n     TypeInference(Span),\n     TypeParameterDefinition(Span, ast::Name),\n-    TransformedUpvar(Span),\n+\n+    /// one of the upvars or closure kind parameters in a `ClosureSubsts`\n+    /// (before it has been determined)\n+    ClosureSynthetic(Span),\n     SubstitutionPlaceholder(Span),\n     AutoDeref(Span),\n     AdjustmentType(Span),"}, {"sha": "0d4429de22a84fe9ecd423fba36137d0b71e6673", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -750,10 +750,19 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         let kind = match self.node_ty(fn_hir_id)?.sty {\n             ty::TyGenerator(..) => ty::ClosureKind::FnOnce,\n-            ty::TyClosure(..) => {\n-                match self.tables.closure_kinds().get(fn_hir_id) {\n-                    Some(&(kind, _)) => kind,\n-                    None => span_bug!(span, \"missing closure kind\"),\n+            ty::TyClosure(closure_def_id, closure_substs) => {\n+                match self.infcx {\n+                    // During upvar inference we may not know the\n+                    // closure kind, just use the LATTICE_BOTTOM value.\n+                    Some(infcx) =>\n+                        infcx.closure_kind(closure_def_id, closure_substs)\n+                             .unwrap_or(ty::ClosureKind::LATTICE_BOTTOM),\n+\n+                    None =>\n+                        self.tcx.global_tcx()\n+                                .lift(&closure_substs)\n+                                .expect(\"no inference cx, but inference variables in closure ty\")\n+                                .closure_kind(closure_def_id, self.tcx.global_tcx()),\n                 }\n             }\n             ref t => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", t),"}, {"sha": "46ec2be4a1f9bf2765347cde135c60652d3fddb2", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -643,8 +643,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                             violations)\n                     }\n \n-                    ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                        let found_kind = self.closure_kind(closure_def_id).unwrap();\n+                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                        let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n                         let closure_span = self.tcx.hir.span_if_local(closure_def_id).unwrap();\n                         let node_id = self.tcx.hir.as_local_node_id(closure_def_id).unwrap();\n                         let mut err = struct_span_err!(\n@@ -663,14 +663,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         if let Some(tables) = self.in_progress_tables {\n                             let tables = tables.borrow();\n                             let closure_hir_id = self.tcx.hir.node_to_hir_id(node_id);\n-                            match tables.closure_kinds().get(closure_hir_id) {\n-                                Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) => {\n-                                    err.span_note(span, &format!(\n+                            match (found_kind, tables.closure_kind_origins().get(closure_hir_id)) {\n+                                (ty::ClosureKind::FnOnce, Some((span, name))) => {\n+                                    err.span_note(*span, &format!(\n                                         \"closure is `FnOnce` because it moves the \\\n                                          variable `{}` out of its environment\", name));\n                                 },\n-                                Some(&(ty::ClosureKind::FnMut, Some((span, name)))) => {\n-                                    err.span_note(span, &format!(\n+                                (ty::ClosureKind::FnMut, Some((span, name))) => {\n+                                    err.span_note(*span, &format!(\n                                         \"closure is `FnMut` because it mutates the \\\n                                          variable `{}` here\", name));\n                                 },"}, {"sha": "6b681322c9bf57f04d656589f0e4dbe16732986e", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -438,8 +438,8 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n             }\n         }\n \n-        ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-            match selcx.infcx().closure_kind(closure_def_id) {\n+        ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            match selcx.infcx().closure_kind(closure_def_id, closure_substs) {\n                 Some(closure_kind) => {\n                     if closure_kind.extends(kind) {\n                         Ok(Some(vec![]))"}, {"sha": "0cc755dc4272767be390cd7afd9455e4813cd08f", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -1264,8 +1264,7 @@ fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n     vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>)\n     -> Progress<'tcx>\n {\n-    let gen_sig = selcx.infcx().generator_sig(vtable.closure_def_id).unwrap()\n-        .subst(selcx.tcx(), vtable.substs.substs);\n+    let gen_sig = vtable.substs.generator_poly_sig(vtable.closure_def_id, selcx.tcx());\n     let Normalized {\n         value: gen_sig,\n         obligations"}, {"sha": "4bc3e2dd4d8d40e40096c2399ef707bea3a9827f", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -718,8 +718,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                match self.infcx.closure_kind(closure_def_id) {\n+            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                match self.infcx.closure_kind(closure_def_id, closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n                             EvaluatedToOk\n@@ -1593,10 +1593,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         match obligation.self_ty().skip_binder().sty {\n-            ty::TyClosure(closure_def_id, _) => {\n+            ty::TyClosure(closure_def_id, closure_substs) => {\n                 debug!(\"assemble_unboxed_candidates: kind={:?} obligation={:?}\",\n                        kind, obligation);\n-                match self.infcx.closure_kind(closure_def_id) {\n+                match self.infcx.closure_kind(closure_def_id, closure_substs) {\n                     Some(closure_kind) => {\n                         debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n                         if closure_kind.extends(kind) {\n@@ -2726,7 +2726,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligations.push(Obligation::new(\n             obligation.cause.clone(),\n             obligation.param_env,\n-            ty::Predicate::ClosureKind(closure_def_id, kind)));\n+            ty::Predicate::ClosureKind(closure_def_id, substs, kind)));\n \n         Ok(VtableClosureData {\n             closure_def_id,\n@@ -3184,8 +3184,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                       substs: ty::ClosureSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n-        let gen_sig = self.infcx.generator_sig(closure_def_id).unwrap()\n-            .subst(self.tcx(), substs.substs);\n+        let gen_sig = substs.generator_poly_sig(closure_def_id, self.tcx());\n         let ty::Binder((trait_ref, ..)) =\n             self.tcx().generator_trait_ref_and_outputs(obligation.predicate.def_id(),\n                                                        obligation.predicate.0.self_ty(), // (1)"}, {"sha": "898accb90215934e4006b3e81a982fa494e4bb75", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -43,8 +43,8 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::Predicate::ObjectSafe(data) =>\n             ty::Predicate::ObjectSafe(data),\n \n-        ty::Predicate::ClosureKind(closure_def_id, kind) =>\n-            ty::Predicate::ClosureKind(closure_def_id, kind),\n+        ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) =>\n+            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind),\n \n         ty::Predicate::Subtype(ref data) =>\n             ty::Predicate::Subtype(tcx.anonymize_late_bound_regions(data)),"}, {"sha": "b0dce1f6684912d991117d4e1330ad2791db7bf8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 13, "deletions": 84, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -356,16 +356,9 @@ pub struct TypeckTables<'tcx> {\n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n-    /// Records the type of each closure.\n-    closure_tys: ItemLocalMap<ty::PolyFnSig<'tcx>>,\n-\n-    /// Records the kind of each closure and the span and name of the variable\n-    /// that caused the closure to be this kind.\n-    closure_kinds: ItemLocalMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n-\n-    generator_sigs: ItemLocalMap<Option<ty::GenSig<'tcx>>>,\n-\n-    generator_interiors: ItemLocalMap<ty::GeneratorInterior<'tcx>>,\n+    /// Records the reasons that we picked the kind of each closure;\n+    /// not all closures are present in the map.\n+    closure_kind_origins: ItemLocalMap<(Span, ast::Name)>,\n \n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions\n@@ -411,10 +404,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             pat_binding_modes: ItemLocalMap(),\n             pat_adjustments: ItemLocalMap(),\n             upvar_capture_map: FxHashMap(),\n-            generator_sigs: ItemLocalMap(),\n-            generator_interiors: ItemLocalMap(),\n-            closure_tys: ItemLocalMap(),\n-            closure_kinds: ItemLocalMap(),\n+            closure_kind_origins: ItemLocalMap(),\n             liberated_fn_sigs: ItemLocalMap(),\n             fru_field_types: ItemLocalMap(),\n             cast_kinds: ItemLocalMap(),\n@@ -609,34 +599,17 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }\n \n-    pub fn closure_tys(&self) -> LocalTableInContext<ty::PolyFnSig<'tcx>> {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.closure_tys\n-        }\n-    }\n-\n-    pub fn closure_tys_mut(&mut self)\n-                           -> LocalTableInContextMut<ty::PolyFnSig<'tcx>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.closure_tys\n-        }\n-    }\n-\n-    pub fn closure_kinds(&self) -> LocalTableInContext<(ty::ClosureKind,\n-                                                        Option<(Span, ast::Name)>)> {\n+    pub fn closure_kind_origins(&self) -> LocalTableInContext<(Span, ast::Name)> {\n         LocalTableInContext {\n             local_id_root: self.local_id_root,\n-            data: &self.closure_kinds\n+            data: &self.closure_kind_origins\n         }\n     }\n \n-    pub fn closure_kinds_mut(&mut self)\n-            -> LocalTableInContextMut<(ty::ClosureKind, Option<(Span, ast::Name)>)> {\n+    pub fn closure_kind_origins_mut(&mut self) -> LocalTableInContextMut<(Span, ast::Name)> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n-            data: &mut self.closure_kinds\n+            data: &mut self.closure_kind_origins\n         }\n     }\n \n@@ -681,42 +654,6 @@ impl<'tcx> TypeckTables<'tcx> {\n             data: &mut self.cast_kinds\n         }\n     }\n-\n-    pub fn generator_sigs(&self)\n-        -> LocalTableInContext<Option<ty::GenSig<'tcx>>>\n-    {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.generator_sigs,\n-        }\n-    }\n-\n-    pub fn generator_sigs_mut(&mut self)\n-        -> LocalTableInContextMut<Option<ty::GenSig<'tcx>>>\n-    {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.generator_sigs,\n-        }\n-    }\n-\n-    pub fn generator_interiors(&self)\n-        -> LocalTableInContext<ty::GeneratorInterior<'tcx>>\n-    {\n-        LocalTableInContext {\n-            local_id_root: self.local_id_root,\n-            data: &self.generator_interiors,\n-        }\n-    }\n-\n-    pub fn generator_interiors_mut(&mut self)\n-        -> LocalTableInContextMut<ty::GeneratorInterior<'tcx>>\n-    {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.generator_interiors,\n-        }\n-    }\n }\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for TypeckTables<'gcx> {\n@@ -732,8 +669,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for TypeckTables<'gcx> {\n             ref pat_binding_modes,\n             ref pat_adjustments,\n             ref upvar_capture_map,\n-            ref closure_tys,\n-            ref closure_kinds,\n+            ref closure_kind_origins,\n             ref liberated_fn_sigs,\n             ref fru_field_types,\n \n@@ -742,8 +678,6 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for TypeckTables<'gcx> {\n             ref used_trait_imports,\n             tainted_by_errors,\n             ref free_region_map,\n-            ref generator_sigs,\n-            ref generator_interiors,\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n@@ -775,13 +709,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for TypeckTables<'gcx> {\n                  hcx.def_path_hash(closure_def_id))\n             });\n \n-            closure_tys.hash_stable(hcx, hasher);\n-            closure_kinds.hash_stable(hcx, hasher);\n+            closure_kind_origins.hash_stable(hcx, hasher);\n             liberated_fn_sigs.hash_stable(hcx, hasher);\n             fru_field_types.hash_stable(hcx, hasher);\n             cast_kinds.hash_stable(hcx, hasher);\n-            generator_sigs.hash_stable(hcx, hasher);\n-            generator_interiors.hash_stable(hcx, hasher);\n             used_trait_imports.hash_stable(hcx, hasher);\n             tainted_by_errors.hash_stable(hcx, hasher);\n             free_region_map.hash_stable(hcx, hasher);\n@@ -1981,11 +1912,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_closure(self,\n                       closure_id: DefId,\n-                      substs: &'tcx Substs<'tcx>)\n-        -> Ty<'tcx> {\n-        self.mk_closure_from_closure_substs(closure_id, ClosureSubsts {\n-            substs,\n-        })\n+                      substs: ClosureSubsts<'tcx>)\n+                      -> Ty<'tcx> {\n+        self.mk_closure_from_closure_substs(closure_id, substs)\n     }\n \n     pub fn mk_closure_from_closure_substs(self,"}, {"sha": "cb68e576e5af9903161ca0156fa5c2005c8b4bbb", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -49,7 +49,11 @@ pub enum TypeError<'tcx> {\n     FloatMismatch(ExpectedFound<ast::FloatTy>),\n     Traits(ExpectedFound<DefId>),\n     VariadicMismatch(ExpectedFound<bool>),\n-    CyclicTy,\n+\n+    /// Instantiating a type variable with the given type would have\n+    /// created a cycle (because it appears somewhere within that\n+    /// type).\n+    CyclicTy(Ty<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n     TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>),\n@@ -84,7 +88,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n         }\n \n         match *self {\n-            CyclicTy => write!(f, \"cyclic type of infinite size\"),\n+            CyclicTy(_) => write!(f, \"cyclic type of infinite size\"),\n             Mismatch => write!(f, \"types differ\"),\n             UnsafetyMismatch(values) => {\n                 write!(f, \"expected {} fn, found {} fn\",\n@@ -304,6 +308,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n                 self.note_and_explain_type_err(db, &err, sp);\n             }\n+            CyclicTy(ty) => {\n+                // Watch out for various cases of cyclic types and try to explain.\n+                if ty.is_closure() || ty.is_generator() {\n+                    db.note(\"closures cannot capture themselves or take themselves as argument;\\n\\\n+                             this error may be the result of a recent compiler bug-fix,\\n\\\n+                             see https://github.com/rust-lang/rust/issues/46062 for more details\");\n+                }\n+            }\n             _ => {}\n         }\n     }"}, {"sha": "70636f8b6fe9b452dd627d49bb0fa1d4f297d8a5", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -189,7 +189,7 @@ fn resolve_closure<'a, 'tcx>(\n                    requested_kind: ty::ClosureKind)\n -> Instance<'tcx>\n {\n-    let actual_kind = tcx.closure_kind(def_id);\n+    let actual_kind = substs.closure_kind(def_id, tcx);\n \n     match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n         Ok(true) => fn_once_adapter_instance(tcx, def_id, substs),"}, {"sha": "a477e779af9a6c2a5af0fbc5543a3e9134e13de2", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -166,20 +166,12 @@ define_maps! { <'tcx>\n     /// for trans. This is also the only query that can fetch non-local MIR, at present.\n     [] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n \n-    /// Type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    [] fn closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n-\n     /// The result of unsafety-checking this def-id.\n     [] fn unsafety_check_result: UnsafetyCheckResult(DefId) -> mir::UnsafetyCheckResult,\n \n     /// The signature of functions and closures.\n     [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n-    /// Records the signature of each generator. The def ID is the ID of the\n-    /// expression defining the closure.\n-    [] fn generator_sig: GenSignature(DefId) -> Option<ty::PolyGenSig<'tcx>>,\n-\n     /// Caches CoerceUnsized kinds for impls on custom types.\n     [] fn coerce_unsized_info: CoerceUnsizedInfo(DefId)\n         -> ty::adjustment::CoerceUnsizedInfo,"}, {"sha": "739537c7c3a71520dfc23541a8dd71fd02378f55", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -782,9 +782,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::IsAutoImpl => { force!(is_auto_impl, def_id!()); }\n         DepKind::ImplTraitRef => { force!(impl_trait_ref, def_id!()); }\n         DepKind::ImplPolarity => { force!(impl_polarity, def_id!()); }\n-        DepKind::ClosureKind => { force!(closure_kind, def_id!()); }\n         DepKind::FnSignature => { force!(fn_sig, def_id!()); }\n-        DepKind::GenSignature => { force!(generator_sig, def_id!()); }\n         DepKind::CoerceUnsizedInfo => { force!(coerce_unsized_info, def_id!()); }\n         DepKind::ItemVariances => { force!(variances_of, def_id!()); }\n         DepKind::IsConstFn => { force!(is_const_fn, def_id!()); }"}, {"sha": "583dcb46f000c228b25c9c8227608b62b779f001", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -896,7 +896,7 @@ pub enum Predicate<'tcx> {\n     /// No direct syntax. May be thought of as `where T : FnFoo<...>`\n     /// for some substitutions `...` and T being a closure type.\n     /// Satisfied (or refuted) once we know the closure's kind.\n-    ClosureKind(DefId, ClosureKind),\n+    ClosureKind(DefId, ClosureSubsts<'tcx>, ClosureKind),\n \n     /// `T1 <: T2`\n     Subtype(PolySubtypePredicate<'tcx>),\n@@ -999,8 +999,8 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n                 Predicate::WellFormed(data.subst(tcx, substs)),\n             Predicate::ObjectSafe(trait_def_id) =>\n                 Predicate::ObjectSafe(trait_def_id),\n-            Predicate::ClosureKind(closure_def_id, kind) =>\n-                Predicate::ClosureKind(closure_def_id, kind),\n+            Predicate::ClosureKind(closure_def_id, closure_substs, kind) =>\n+                Predicate::ClosureKind(closure_def_id, closure_substs.subst(tcx, substs), kind),\n             Predicate::ConstEvaluatable(def_id, const_substs) =>\n                 Predicate::ConstEvaluatable(def_id, const_substs.subst(tcx, substs)),\n         }\n@@ -1182,8 +1182,8 @@ impl<'tcx> Predicate<'tcx> {\n             ty::Predicate::ObjectSafe(_trait_def_id) => {\n                 vec![]\n             }\n-            ty::Predicate::ClosureKind(_closure_def_id, _kind) => {\n-                vec![]\n+            ty::Predicate::ClosureKind(_closure_def_id, closure_substs, _kind) => {\n+                closure_substs.substs.types().collect()\n             }\n             ty::Predicate::ConstEvaluatable(_, substs) => {\n                 substs.types().collect()\n@@ -1932,6 +1932,9 @@ pub enum ClosureKind {\n }\n \n impl<'a, 'tcx> ClosureKind {\n+    // This is the initial value used when doing upvar inference.\n+    pub const LATTICE_BOTTOM: ClosureKind = ClosureKind::Fn;\n+\n     pub fn trait_did(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> DefId {\n         match *self {\n             ClosureKind::Fn => tcx.require_lang_item(FnTraitLangItem),\n@@ -1957,6 +1960,16 @@ impl<'a, 'tcx> ClosureKind {\n             _ => false,\n         }\n     }\n+\n+    /// Returns the representative scalar type for this closure kind.\n+    /// See `TyS::to_opt_closure_kind` for more details.\n+    pub fn to_ty(self, tcx: TyCtxt<'_, '_, 'tcx>) -> Ty<'tcx> {\n+        match self {\n+            ty::ClosureKind::Fn => tcx.types.i8,\n+            ty::ClosureKind::FnMut => tcx.types.i16,\n+            ty::ClosureKind::FnOnce => tcx.types.i32,\n+        }\n+    }\n }\n \n impl<'tcx> TyS<'tcx> {"}, {"sha": "83207fbe3c3468c62a3e0d6454010ea30df22afd", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -211,8 +211,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n             ty::Predicate::WellFormed(ty) => {\n                 tcx.lift(&ty).map(ty::Predicate::WellFormed)\n             }\n-            ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                Some(ty::Predicate::ClosureKind(closure_def_id, kind))\n+            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                tcx.lift(&closure_substs)\n+                   .map(|closure_substs| ty::Predicate::ClosureKind(closure_def_id,\n+                                                                    closure_substs,\n+                                                                    kind))\n             }\n             ty::Predicate::ObjectSafe(trait_def_id) => {\n                 Some(ty::Predicate::ObjectSafe(trait_def_id))\n@@ -420,7 +423,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             FloatMismatch(x) => FloatMismatch(x),\n             Traits(x) => Traits(x),\n             VariadicMismatch(x) => VariadicMismatch(x),\n-            CyclicTy => CyclicTy,\n+            CyclicTy(t) => return tcx.lift(&t).map(|t| CyclicTy(t)),\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n             ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n \n@@ -966,8 +969,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n                 ty::Predicate::Projection(binder.fold_with(folder)),\n             ty::Predicate::WellFormed(data) =>\n                 ty::Predicate::WellFormed(data.fold_with(folder)),\n-            ty::Predicate::ClosureKind(closure_def_id, kind) =>\n-                ty::Predicate::ClosureKind(closure_def_id, kind),\n+            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) =>\n+                ty::Predicate::ClosureKind(closure_def_id, closure_substs.fold_with(folder), kind),\n             ty::Predicate::ObjectSafe(trait_def_id) =>\n                 ty::Predicate::ObjectSafe(trait_def_id),\n             ty::Predicate::ConstEvaluatable(def_id, substs) =>\n@@ -984,7 +987,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n             ty::Predicate::TypeOutlives(ref binder) => binder.visit_with(visitor),\n             ty::Predicate::Projection(ref binder) => binder.visit_with(visitor),\n             ty::Predicate::WellFormed(data) => data.visit_with(visitor),\n-            ty::Predicate::ClosureKind(_closure_def_id, _kind) => false,\n+            ty::Predicate::ClosureKind(_closure_def_id, closure_substs, _kind) =>\n+                closure_substs.visit_with(visitor),\n             ty::Predicate::ObjectSafe(_trait_def_id) => false,\n             ty::Predicate::ConstEvaluatable(_def_id, substs) => substs.visit_with(visitor),\n         }\n@@ -1169,7 +1173,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             FloatMismatch(x) => FloatMismatch(x),\n             Traits(x) => Traits(x),\n             VariadicMismatch(x) => VariadicMismatch(x),\n-            CyclicTy => CyclicTy,\n+            CyclicTy(t) => CyclicTy(t.fold_with(folder)),\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n             ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n             Sorts(x) => Sorts(x.fold_with(folder)),\n@@ -1196,6 +1200,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             OldStyleLUB(ref x) => x.visit_with(visitor),\n             TyParamDefaultMismatch(ref x) => x.visit_with(visitor),\n             ExistentialMismatch(x) => x.visit_with(visitor),\n+            CyclicTy(t) => t.visit_with(visitor),\n             Mismatch |\n             Mutability |\n             TupleSize(_) |\n@@ -1205,7 +1210,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             FloatMismatch(_) |\n             Traits(_) |\n             VariadicMismatch(_) |\n-            CyclicTy |\n             ProjectionMismatched(_) |\n             ProjectionBoundsLength(_) => false,\n         }"}, {"sha": "7406fbf820893ed2804ced1e142f08bcc1a0e475", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 152, "deletions": 10, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -174,16 +174,26 @@ pub enum TypeVariants<'tcx> {\n \n /// A closure can be modeled as a struct that looks like:\n ///\n-///     struct Closure<'l0...'li, T0...Tj, U0...Uk> {\n+///     struct Closure<'l0...'li, T0...Tj, CK, CS, U0...Uk> {\n ///         upvar0: U0,\n ///         ...\n ///         upvark: Uk\n ///     }\n ///\n-/// where 'l0...'li and T0...Tj are the lifetime and type parameters\n-/// in scope on the function that defined the closure, and U0...Uk are\n-/// type parameters representing the types of its upvars (borrowed, if\n-/// appropriate).\n+/// where:\n+///\n+/// - 'l0...'li and T0...Tj are the lifetime and type parameters\n+///   in scope on the function that defined the closure,\n+/// - CK represents the *closure kind* (Fn vs FnMut vs FnOnce). This\n+///   is rather hackily encoded via a scalar type. See\n+///   `TyS::to_opt_closure_kind` for details.\n+/// - CS represents the *closure signature*, representing as a `fn()`\n+///   type. For example, `fn(u32, u32) -> u32` would mean that the closure\n+///   implements `CK<(u32, u32), Output = u32>`, where `CK` is the trait\n+///   specified above.\n+/// - U0...Uk are type parameters representing the types of its upvars\n+///   (borrowed, if appropriate; that is, if Ui represents a by-ref upvar,\n+///    and the up-var has the type `Foo`, then `Ui = &Foo`).\n ///\n /// So, for example, given this function:\n ///\n@@ -246,6 +256,17 @@ pub enum TypeVariants<'tcx> {\n /// closure C wind up influencing the decisions we ought to make for\n /// closure C (which would then require fixed point iteration to\n /// handle). Plus it fixes an ICE. :P\n+///\n+/// ## Generators\n+///\n+/// Perhaps surprisingly, `ClosureSubsts` are also used for\n+/// generators.  In that case, what is written above is only half-true\n+/// -- the set of type parameters is similar, but the role of CK and\n+/// CS are different.  CK represents the \"yield type\" and CS\n+/// represents the \"return type\" of the generator.\n+///\n+/// It'd be nice to split this struct into ClosureSubsts and\n+/// GeneratorSubsts, I believe. -nmatsakis\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function,\n@@ -256,14 +277,97 @@ pub struct ClosureSubsts<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n }\n \n-impl<'a, 'gcx, 'acx, 'tcx> ClosureSubsts<'tcx> {\n+/// Struct returned by `split()`. Note that these are subslices of the\n+/// parent slice and not canonical substs themselves.\n+struct SplitClosureSubsts<'tcx> {\n+    closure_kind_ty: Ty<'tcx>,\n+    closure_sig_ty: Ty<'tcx>,\n+    upvar_kinds: &'tcx [Kind<'tcx>],\n+}\n+\n+impl<'tcx> ClosureSubsts<'tcx> {\n+    /// Divides the closure substs into their respective\n+    /// components. Single source of truth with respect to the\n+    /// ordering.\n+    fn split(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> SplitClosureSubsts<'tcx> {\n+        let generics = tcx.generics_of(def_id);\n+        let parent_len = generics.parent_count();\n+        SplitClosureSubsts {\n+            closure_kind_ty: self.substs[parent_len].as_type().expect(\"CK should be a type\"),\n+            closure_sig_ty: self.substs[parent_len + 1].as_type().expect(\"CS should be a type\"),\n+            upvar_kinds: &self.substs[parent_len + 2..],\n+        }\n+    }\n+\n     #[inline]\n-    pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'acx>) ->\n+    pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) ->\n         impl Iterator<Item=Ty<'tcx>> + 'tcx\n     {\n-        let generics = tcx.generics_of(def_id);\n-        self.substs[self.substs.len()-generics.own_count()..].iter().map(\n-            |t| t.as_type().expect(\"unexpected region in upvars\"))\n+        let SplitClosureSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n+        upvar_kinds.iter().map(|t| t.as_type().expect(\"upvar should be type\"))\n+    }\n+\n+    /// Returns the closure kind for this closure; may return a type\n+    /// variable during inference. To get the closure kind during\n+    /// inference, use `infcx.closure_kind(def_id, substs)`.\n+    pub fn closure_kind_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n+        self.split(def_id, tcx).closure_kind_ty\n+    }\n+\n+    /// Returns the type representing the closure signature for this\n+    /// closure; may contain type variables during inference. To get\n+    /// the closure signature during inference, use\n+    /// `infcx.fn_sig(def_id)`.\n+    pub fn closure_sig_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n+        self.split(def_id, tcx).closure_sig_ty\n+    }\n+\n+    /// Returns the type representing the yield type of the generator.\n+    pub fn generator_yield_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n+        self.closure_kind_ty(def_id, tcx)\n+    }\n+\n+    /// Returns the type representing the return type of the generator.\n+    pub fn generator_return_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n+        self.closure_sig_ty(def_id, tcx)\n+    }\n+\n+    /// Return the \"generator signature\", which consists of its yield\n+    /// and return types.\n+    ///\n+    /// NB. Some bits of the code prefers to see this wrapped in a\n+    /// binder, but it never contains bound regions. Probably this\n+    /// function should be removed.\n+    pub fn generator_poly_sig(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> PolyGenSig<'tcx> {\n+        ty::Binder(self.generator_sig(def_id, tcx))\n+    }\n+\n+    /// Return the \"generator signature\", which consists of its yield\n+    /// and return types.\n+    pub fn generator_sig(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> GenSig<'tcx> {\n+        ty::GenSig {\n+            yield_ty: self.generator_yield_ty(def_id, tcx),\n+            return_ty: self.generator_return_ty(def_id, tcx),\n+        }\n+    }\n+}\n+\n+impl<'tcx> ClosureSubsts<'tcx> {\n+    /// Returns the closure kind for this closure; only usable outside\n+    /// of an inference context, because in that context we know that\n+    /// there are no type variables.\n+    pub fn closure_kind(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::ClosureKind {\n+        self.split(def_id, tcx).closure_kind_ty.to_opt_closure_kind().unwrap()\n+    }\n+\n+    /// Extracts the signature from the closure; only usable outside\n+    /// of an inference context, because in that context we know that\n+    /// there are no type variables.\n+    pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n+        match self.closure_sig_ty(def_id, tcx).sty {\n+            ty::TyFnPtr(sig) => sig,\n+            ref t => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", t),\n+        }\n     }\n }\n \n@@ -1268,6 +1372,13 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    pub fn is_generator(&self) -> bool {\n+        match self.sty {\n+            TyGenerator(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_integral(&self) -> bool {\n         match self.sty {\n             TyInfer(IntVar(_)) | TyInt(_) | TyUint(_) => true,\n@@ -1442,6 +1553,37 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             }\n         }\n     }\n+\n+    /// When we create a closure, we record its kind (i.e., what trait\n+    /// it implements) into its `ClosureSubsts` using a type\n+    /// parameter. This is kind of a phantom type, except that the\n+    /// most convenient thing for us to are the integral types. This\n+    /// function converts such a special type into the closure\n+    /// kind. To go the other way, use\n+    /// `tcx.closure_kind_ty(closure_kind)`.\n+    ///\n+    /// Note that during type checking, we use an inference variable\n+    /// to represent the closure kind, because it has not yet been\n+    /// inferred. Once [upvar inference] is complete, that type varibale\n+    /// will be unified.\n+    ///\n+    /// [upvar inference]: src/librustc_typeck/check/upvar.rs\n+    pub fn to_opt_closure_kind(&self) -> Option<ty::ClosureKind> {\n+        match self.sty {\n+            TyInt(int_ty) => match int_ty {\n+                ast::IntTy::I8 => Some(ty::ClosureKind::Fn),\n+                ast::IntTy::I16 => Some(ty::ClosureKind::FnMut),\n+                ast::IntTy::I32 => Some(ty::ClosureKind::FnOnce),\n+                _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n+            },\n+\n+            TyInfer(_) => None,\n+\n+            TyError => Some(ty::ClosureKind::Fn),\n+\n+            _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n+        }\n+    }\n }\n \n /// Typed constant value."}, {"sha": "a851ccc34bfd6a2e61654aa26fe201a244427ae7", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -336,14 +336,50 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::TyGenerator(..) | ty::TyClosure(..) => {\n-                    // the types in a closure or generator are always the types of\n-                    // local variables (or possibly references to local\n-                    // variables), we'll walk those.\n+                ty::TyGenerator(..) => {\n+                    // Walk ALL the types in the generator: this will\n+                    // include the upvar types as well as the yield\n+                    // type. Note that this is mildly distinct from\n+                    // the closure case, where we have to be careful\n+                    // about the signature of the closure. We don't\n+                    // have the problem of implied bounds here since\n+                    // generators don't take arguments.\n+                }\n+\n+                ty::TyClosure(def_id, substs) => {\n+                    // Only check the upvar types for WF, not the rest\n+                    // of the types within. This is needed because we\n+                    // capture the signature and it may not be WF\n+                    // without the implied bounds. Consider a closure\n+                    // like `|x: &'a T|` -- it may be that `T: 'a` is\n+                    // not known to hold in the creator's context (and\n+                    // indeed the closure may not be invoked by its\n+                    // creator, but rather turned to someone who *can*\n+                    // verify that).\n+                    //\n+                    // The special treatment of closures here really\n+                    // ought not to be necessary either; the problem\n+                    // is related to #25860 -- there is no way for us\n+                    // to express a fn type complete with the implied\n+                    // bounds that it is assuming. I think in reality\n+                    // the WF rules around fn are a bit messed up, and\n+                    // that is the rot problem: `fn(&'a T)` should\n+                    // probably always be WF, because it should be\n+                    // shorthand for something like `where(T: 'a) {\n+                    // fn(&'a T) }`, as discussed in #25860.\n                     //\n-                    // (Though, local variables are probably not\n-                    // needed, as they are separately checked w/r/t\n-                    // WFedness.)\n+                    // Note that we are also skipping the generic\n+                    // types. This is consistent with the `outlives`\n+                    // code, but anyway doesn't matter: within the fn\n+                    // body where they are created, the generics will\n+                    // always be WF, and outside of that fn body we\n+                    // are not directly inspecting closure types\n+                    // anyway, except via auto trait matching (which\n+                    // only inspects the upvar types).\n+                    subtys.skip_current_subtree(); // subtree handled by compute_projection\n+                    for upvar_ty in substs.upvar_tys(def_id, self.infcx.tcx) {\n+                        self.compute(upvar_ty);\n+                    }\n                 }\n \n                 ty::TyFnDef(..) | ty::TyFnPtr(_) => {"}, {"sha": "2c3a32b2d159ee8a6403faf2c720169329bced7f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -1261,7 +1261,7 @@ define_print! {\n                     ty::tls::with(|tcx| {\n                         write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n                     }),\n-                ty::Predicate::ClosureKind(closure_def_id, kind) =>\n+                ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) =>\n                     ty::tls::with(|tcx| {\n                         write!(f, \"the closure `{}` implements the trait `{}`\",\n                                tcx.item_path_str(closure_def_id), kind)\n@@ -1285,8 +1285,8 @@ define_print! {\n                 ty::Predicate::ObjectSafe(trait_def_id) => {\n                     write!(f, \"ObjectSafe({:?})\", trait_def_id)\n                 }\n-                ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                    write!(f, \"ClosureKind({:?}, {:?})\", closure_def_id, kind)\n+                ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                    write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n                 }\n                 ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                     write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)"}, {"sha": "36b397bbbe5465002d26c68f70363e2ebaf9cacb", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -655,10 +655,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     ty::TypeVariants::TyClosure(id, _) => {\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n                         let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n-                        if let Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) =\n-                            self.tables.closure_kinds().get(hir_id)\n-                        {\n-                            err.span_note(span, &format!(\n+                        if let Some((span, name)) = self.tables.closure_kind_origins().get(hir_id) {\n+                            err.span_note(*span, &format!(\n                                 \"closure cannot be invoked more than once because \\\n                                 it moves the variable `{}` out of its environment\",\n                                 name"}, {"sha": "c8b71be86f862ef832dfaad95e23f51a39f82405", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -15,6 +15,7 @@\n \n #![allow(non_camel_case_types)]\n \n+#![feature(match_default_bindings)]\n #![feature(quote)]\n \n #[macro_use] extern crate log;"}, {"sha": "1f671adf4f8a432fe96627b5fa46527a8534454d", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -136,12 +136,10 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n         mir\n     }\n-    generator_sig => { cdata.generator_sig(def_id.index, tcx) }\n     mir_const_qualif => {\n         (cdata.mir_const_qualif(def_id.index), Rc::new(IdxSetBuf::new_empty(0)))\n     }\n     typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n-    closure_kind => { cdata.closure_kind(def_id.index) }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n     is_const_fn => { cdata.is_const_fn(def_id.index) }"}, {"sha": "633806d5ef56800d5bde0178f5612457f7955c3c", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -1020,13 +1020,6 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn closure_kind(&self, closure_id: DefIndex) -> ty::ClosureKind {\n-        match self.entry(closure_id).kind {\n-            EntryKind::Closure(data) => data.decode(self).kind,\n-            _ => bug!(),\n-        }\n-    }\n-\n     pub fn fn_sig(&self,\n                   id: DefIndex,\n                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n@@ -1043,23 +1036,6 @@ impl<'a, 'tcx> CrateMetadata {\n         sig.decode((self, tcx))\n     }\n \n-    fn get_generator_data(&self,\n-                      id: DefIndex,\n-                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                      -> Option<GeneratorData<'tcx>> {\n-        match self.entry(id).kind {\n-            EntryKind::Generator(data) => Some(data.decode((self, tcx))),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn generator_sig(&self,\n-                      id: DefIndex,\n-                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                      -> Option<ty::PolyGenSig<'tcx>> {\n-        self.get_generator_data(id, tcx).map(|d| d.sig)\n-    }\n-\n     #[inline]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n         self.def_path_table.def_key(index)"}, {"sha": "d82d50164cbb59c58e0d44cabea691ea583bc982", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -1205,19 +1205,25 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_closure({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let kind = if let Some(sig) = self.tcx.generator_sig(def_id) {\n-            let layout = self.tcx.generator_layout(def_id);\n-            let data = GeneratorData {\n-                sig,\n-                layout: layout.clone(),\n-            };\n-            EntryKind::Generator(self.lazy(&data))\n-        } else {\n-            let data = ClosureData {\n-                kind: tcx.closure_kind(def_id),\n-                sig: self.lazy(&tcx.fn_sig(def_id)),\n-            };\n-            EntryKind::Closure(self.lazy(&data))\n+        let tables = self.tcx.typeck_tables_of(def_id);\n+        let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        let kind = match tables.node_id_to_type(hir_id).sty {\n+            ty::TyGenerator(def_id, ..) => {\n+                let layout = self.tcx.generator_layout(def_id);\n+                let data = GeneratorData {\n+                    layout: layout.clone(),\n+                };\n+                EntryKind::Generator(self.lazy(&data))\n+            }\n+\n+            ty::TyClosure(def_id, substs) => {\n+                let sig = substs.closure_sig(def_id, self.tcx);\n+                let data = ClosureData { sig: self.lazy(&sig) };\n+                EntryKind::Closure(self.lazy(&data))\n+            }\n+\n+            _ => bug!(\"closure that is neither generator nor closure\")\n         };\n \n         Entry {"}, {"sha": "8ff327463917ac36db7c52841c289178c9dae36e", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -512,14 +512,12 @@ impl_stable_hash_for!(struct MethodData<'tcx> { fn_data, container, has_self });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ClosureData<'tcx> {\n-    pub kind: ty::ClosureKind,\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n-impl_stable_hash_for!(struct ClosureData<'tcx> { kind, sig });\n+impl_stable_hash_for!(struct ClosureData<'tcx> { sig });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct GeneratorData<'tcx> {\n-    pub sig: ty::PolyGenSig<'tcx>,\n     pub layout: mir::GeneratorLayout<'tcx>,\n }\n-impl_stable_hash_for!(struct GeneratorData<'tcx> { sig, layout });\n+impl_stable_hash_for!(struct GeneratorData<'tcx> { layout });"}, {"sha": "080cf4b47cf8701cf6fdfe98672b7b8fd0e757b2", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -103,7 +103,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                     Some((closure_self_ty(tcx, id, body_id), None))\n                 }\n                 ty::TyGenerator(..) => {\n-                    let gen_ty =  tcx.body_tables(body_id).node_id_to_type(fn_hir_id);\n+                    let gen_ty = tcx.body_tables(body_id).node_id_to_type(fn_hir_id);\n                     Some((gen_ty, None))\n                 }\n                 _ => None,\n@@ -127,7 +127,12 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n \n             let (yield_ty, return_ty) = if body.is_generator {\n-                let gen_sig = cx.tables().generator_sigs()[fn_hir_id].clone().unwrap();\n+                let gen_sig = match ty.sty {\n+                    ty::TyGenerator(gen_def_id, gen_substs, ..) =>\n+                        gen_substs.generator_sig(gen_def_id, tcx),\n+                    _ =>\n+                        span_bug!(tcx.hir.span(id), \"generator w/o generator type: {:?}\", ty),\n+                };\n                 (Some(gen_sig.yield_ty), gen_sig.return_ty)\n             } else {\n                 (None, fn_sig.output())\n@@ -248,14 +253,18 @@ pub fn closure_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     let closure_expr_hir_id = tcx.hir.node_to_hir_id(closure_expr_id);\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_hir_id);\n \n-    let closure_def_id = tcx.hir.local_def_id(closure_expr_id);\n+    let (closure_def_id, closure_substs) = match closure_ty.sty {\n+        ty::TyClosure(closure_def_id, closure_substs) => (closure_def_id, closure_substs),\n+        _ => bug!(\"closure expr does not have closure type: {:?}\", closure_ty)\n+    };\n+\n     let region = ty::ReFree(ty::FreeRegion {\n         scope: closure_def_id,\n         bound_region: ty::BoundRegion::BrEnv,\n     });\n     let region = tcx.mk_region(region);\n \n-    match tcx.closure_kind(closure_def_id) {\n+    match closure_substs.closure_kind_ty(closure_def_id, tcx).to_opt_closure_kind().unwrap() {\n         ty::ClosureKind::Fn =>\n             tcx.mk_ref(region,\n                        ty::TypeAndMut { ty: closure_ty,"}, {"sha": "00d7cdc0ff7a424c0035aba338e6d86293ca7646", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -713,8 +713,8 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             });\n             let region = cx.tcx.mk_region(region);\n \n-            let self_expr = if let ty::TyClosure(..) = closure_ty.sty {\n-                match cx.tcx.closure_kind(closure_def_id) {\n+            let self_expr = if let ty::TyClosure(_, closure_substs) = closure_ty.sty {\n+                match cx.infcx.closure_kind(closure_def_id, closure_substs).unwrap() {\n                     ty::ClosureKind::Fn => {\n                         let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                            ty::TypeAndMut {"}, {"sha": "43635bcb631b9efbdd39f802d5535babea53e101", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -767,7 +767,11 @@ impl MirPass for StateTransform {\n         let hir_id = tcx.hir.node_to_hir_id(node_id);\n \n         // Get the interior types which typeck computed\n-        let interior = *tcx.typeck_tables_of(def_id).generator_interiors().get(hir_id).unwrap();\n+        let tables = tcx.typeck_tables_of(def_id);\n+        let interior = match tables.node_id_to_type(hir_id).sty {\n+            ty::TyGenerator(_, _, interior) => interior,\n+            ref t => bug!(\"type of generator not a generator: {:?}\", t),\n+        };\n \n         // The first argument is the generator type passed by value\n         let gen_ty = mir.local_decls.raw[1].ty;"}, {"sha": "35cade25f77afa315705cd66338e74fbc43b4638", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -23,6 +23,7 @@ use rustc::ty::layout::LayoutOf;\n use rustc::ty::subst::{Subst,Substs};\n \n use std::collections::VecDeque;\n+use std::iter;\n use transform::{MirPass, MirSource};\n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n \n@@ -559,8 +560,29 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n     ) -> Vec<Operand<'tcx>> {\n         let tcx = self.tcx;\n \n-        // A closure is passed its self-type and a tuple like `(arg1, arg2, ...)`,\n-        // hence mappings to tuple fields are needed.\n+        // There is a bit of a mismatch between the *caller* of a closure and the *callee*.\n+        // The caller provides the arguments wrapped up in a tuple:\n+        //\n+        //     tuple_tmp = (a, b, c)\n+        //     Fn::call(closure_ref, tuple_tmp)\n+        //\n+        // meanwhile the closure body expects the arguments (here, `a`, `b`, and `c`)\n+        // as distinct arguments. (This is the \"rust-call\" ABI hack.) Normally, trans has\n+        // the job of unpacking this tuple. But here, we are trans. =) So we want to create\n+        // a vector like\n+        //\n+        //     [closure_ref, tuple_tmp.0, tuple_tmp.1, tuple_tmp.2]\n+        //\n+        // Except for one tiny wrinkle: we don't actually want `tuple_tmp.0`. It's more convenient\n+        // if we \"spill\" that into *another* temporary, so that we can map the argument\n+        // variable in the callee MIR directly to an argument variable on our side.\n+        // So we introduce temporaries like:\n+        //\n+        //     tmp0 = tuple_tmp.0\n+        //     tmp1 = tuple_tmp.1\n+        //     tmp2 = tuple_tmp.2\n+        //\n+        // and the vector is `[closure_ref, tmp0, tmp1, tmp2]`.\n         if tcx.is_closure(callsite.callee) {\n             let mut args = args.into_iter();\n             let self_ = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_mir);\n@@ -573,12 +595,21 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 bug!(\"Closure arguments are not passed as a tuple\");\n             };\n \n-            let mut res = Vec::with_capacity(1 + tuple_tys.len());\n-            res.push(Operand::Consume(self_));\n-            res.extend(tuple_tys.iter().enumerate().map(|(i, ty)| {\n-                Operand::Consume(tuple.clone().field(Field::new(i), ty))\n-            }));\n-            res\n+            // The `closure_ref` in our example above.\n+            let closure_ref_arg = iter::once(Operand::Consume(self_));\n+\n+            // The `tmp0`, `tmp1`, and `tmp2` in our example abonve.\n+            let tuple_tmp_args =\n+                tuple_tys.iter().enumerate().map(|(i, ty)| {\n+                    // This is e.g. `tuple_tmp.0` in our example above.\n+                    let tuple_field = Operand::Consume(tuple.clone().field(Field::new(i), ty));\n+\n+                    // Spill to a local to make e.g. `tmp0`.\n+                    let tmp = self.create_temp_if_necessary(tuple_field, callsite, caller_mir);\n+                    Operand::Consume(tmp)\n+                });\n+\n+            closure_ref_arg.chain(tuple_tmp_args).collect()\n         } else {\n             args.into_iter()\n                 .map(|a| Operand::Consume(self.create_temp_if_necessary(a, callsite, caller_mir)))"}, {"sha": "1f92c1067845ef30ea8d36ea164fcae0abd9bdbd", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -396,7 +396,7 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let sig = tcx.fn_sig(def_id).subst(tcx, substs.substs);\n \n             let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n-            let env_ty = match tcx.closure_kind(def_id) {\n+            let env_ty = match substs.closure_kind(def_id, tcx) {\n                 ty::ClosureKind::Fn => tcx.mk_imm_ref(tcx.mk_region(env_region), ty),\n                 ty::ClosureKind::FnMut => tcx.mk_mut_ref(tcx.mk_region(env_region), ty),\n                 ty::ClosureKind::FnOnce => ty,\n@@ -412,7 +412,7 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         ty::TyGenerator(def_id, substs, _) => {\n             let tcx = ccx.tcx();\n-            let sig = tcx.generator_sig(def_id).unwrap().subst(tcx, substs.substs);\n+            let sig = substs.generator_poly_sig(def_id, ccx.tcx());\n \n             let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n             let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);"}, {"sha": "66833a1a7c2f17ea6facd2b8db23305d6c92f12e", "filename": "src/librustc_trans_utils/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fmonomorphize.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -86,7 +86,7 @@ pub fn resolve_closure<'a, 'tcx> (\n     requested_kind: ty::ClosureKind)\n     -> Instance<'tcx>\n {\n-    let actual_kind = tcx.closure_kind(def_id);\n+    let actual_kind = substs.closure_kind(def_id, tcx);\n \n     match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n         Ok(true) => fn_once_adapter_instance(tcx, def_id, substs),"}, {"sha": "8f409b687526bc1fdb872ec1f9774230567c2ae7", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Check whether this is a call to a closure where we\n                 // haven't yet decided on whether the closure is fn vs\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n-                if self.closure_kind(def_id).is_none() {\n+                if self.closure_kind(def_id, substs).is_none() {\n                     let closure_ty = self.fn_sig(def_id).subst(self.tcx, substs.substs);\n                     let fn_sig = self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n                                                                    infer::FnCall,\n@@ -122,6 +122,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         adjustments,\n                         fn_sig,\n                         closure_def_id: def_id,\n+                        closure_substs: substs,\n                     });\n                     return Some(CallStep::DeferredClosure(fn_sig));\n                 }\n@@ -336,6 +337,7 @@ pub struct DeferredCallResolution<'gcx: 'tcx, 'tcx> {\n     adjustments: Vec<Adjustment<'tcx>>,\n     fn_sig: ty::FnSig<'tcx>,\n     closure_def_id: DefId,\n+    closure_substs: ty::ClosureSubsts<'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n@@ -344,7 +346,7 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n \n         // we should not be invoked until the closure kind has been\n         // determined by upvar inference\n-        assert!(fcx.closure_kind(self.closure_def_id).is_some());\n+        assert!(fcx.closure_kind(self.closure_def_id, self.closure_substs).is_some());\n \n         // We may now know enough to figure out fn vs fnmut etc.\n         match fcx.try_overloaded_call_traits(self.call_expr,"}, {"sha": "5b5d697bcf4351b2d386cff8b8610289ac17bd8d", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -10,7 +10,7 @@\n \n //! Code for type-checking closure expressions.\n \n-use super::{check_fn, Expectation, FnCtxt};\n+use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use astconv::AstConv;\n use rustc::hir::def_id::DefId;\n@@ -79,7 +79,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"check_closure: ty_of_closure returns {:?}\", liberated_sig);\n \n-        let interior = check_fn(\n+        let generator_types = check_fn(\n             self,\n             self.param_env,\n             liberated_sig,\n@@ -100,14 +100,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             |_, _| span_bug!(expr.span, \"closure has region param\"),\n             |_, _| {\n                 self.infcx\n-                    .next_ty_var(TypeVariableOrigin::TransformedUpvar(expr.span))\n+                    .next_ty_var(TypeVariableOrigin::ClosureSynthetic(expr.span))\n             },\n         );\n+        let substs = ty::ClosureSubsts { substs };\n         let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n \n-        if let Some(interior) = interior {\n-            let closure_substs = ty::ClosureSubsts { substs: substs };\n-            return self.tcx.mk_generator(expr_def_id, closure_substs, interior);\n+        if let Some(GeneratorTypes { yield_ty, interior }) = generator_types {\n+            self.demand_eqtype(expr.span,\n+                               yield_ty,\n+                               substs.generator_yield_ty(expr_def_id, self.tcx));\n+            self.demand_eqtype(expr.span,\n+                               liberated_sig.output(),\n+                               substs.generator_return_ty(expr_def_id, self.tcx));\n+            return self.tcx.mk_generator(expr_def_id, substs, interior);\n         }\n \n         debug!(\n@@ -135,15 +141,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             opt_kind\n         );\n \n-        {\n-            let mut tables = self.tables.borrow_mut();\n-            tables.closure_tys_mut().insert(expr.hir_id, sig);\n-            match opt_kind {\n-                Some(kind) => {\n-                    tables.closure_kinds_mut().insert(expr.hir_id, (kind, None));\n-                }\n-                None => {}\n-            }\n+        let sig_fn_ptr_ty = self.tcx.mk_fn_ptr(sig);\n+        self.demand_eqtype(expr.span,\n+                           sig_fn_ptr_ty,\n+                           substs.closure_sig_ty(expr_def_id, self.tcx));\n+\n+        if let Some(kind) = opt_kind {\n+            self.demand_eqtype(expr.span,\n+                               kind.to_ty(self.tcx),\n+                               substs.closure_kind_ty(expr_def_id, self.tcx));\n         }\n \n         closure_type"}, {"sha": "09dd334a62d8adabba72faa4d93a2f056e41b532", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -759,30 +759,12 @@ pub fn provide(providers: &mut Providers) {\n         typeck_item_bodies,\n         typeck_tables_of,\n         has_typeck_tables,\n-        closure_kind,\n-        generator_sig,\n         adt_destructor,\n         used_trait_imports,\n         ..*providers\n     };\n }\n \n-fn generator_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          def_id: DefId)\n-                          -> Option<ty::PolyGenSig<'tcx>> {\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let hir_id = tcx.hir.node_to_hir_id(node_id);\n-    tcx.typeck_tables_of(def_id).generator_sigs()[hir_id].map(|s| ty::Binder(s))\n-}\n-\n-fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          def_id: DefId)\n-                          -> ty::ClosureKind {\n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let hir_id = tcx.hir.node_to_hir_id(node_id);\n-    tcx.typeck_tables_of(def_id).closure_kinds()[hir_id].0\n-}\n-\n fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             def_id: DefId)\n                             -> Option<ty::Destructor> {\n@@ -1021,6 +1003,17 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n                 _: hir::BodyId, _: Span, _: ast::NodeId) { }\n }\n \n+/// When `check_fn` is invoked on a generator (i.e., a body that\n+/// includes yield), it returns back some information about the yield\n+/// points.\n+struct GeneratorTypes<'tcx> {\n+    /// Type of value that is yielded.\n+    yield_ty: ty::Ty<'tcx>,\n+\n+    /// Types that are captured (see `GeneratorInterior` for more).\n+    interior: ty::GeneratorInterior<'tcx>\n+}\n+\n /// Helper used for fns and closures. Does the grungy work of checking a function\n /// body and returns the function context used for that purpose, since in the case of a fn item\n /// there is still a bit more to do.\n@@ -1034,7 +1027,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             fn_id: ast::NodeId,\n                             body: &'gcx hir::Body,\n                             can_be_generator: bool)\n-                            -> (FnCtxt<'a, 'gcx, 'tcx>, Option<ty::GeneratorInterior<'tcx>>)\n+                            -> (FnCtxt<'a, 'gcx, 'tcx>, Option<GeneratorTypes<'tcx>>)\n {\n     let mut fn_sig = fn_sig.clone();\n \n@@ -1084,21 +1077,11 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     let fn_hir_id = fcx.tcx.hir.node_to_hir_id(fn_id);\n     let gen_ty = if can_be_generator && body.is_generator {\n-        let gen_sig = ty::GenSig {\n-            yield_ty: fcx.yield_ty.unwrap(),\n-            return_ty: ret_ty,\n-        };\n-        inherited.tables.borrow_mut().generator_sigs_mut().insert(fn_hir_id, Some(gen_sig));\n-\n         let witness = fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n         fcx.deferred_generator_interiors.borrow_mut().push((body.id(), witness));\n         let interior = ty::GeneratorInterior::new(witness);\n-\n-        inherited.tables.borrow_mut().generator_interiors_mut().insert(fn_hir_id, interior);\n-\n-        Some(interior)\n+        Some(GeneratorTypes { yield_ty: fcx.yield_ty.unwrap(), interior: interior })\n     } else {\n-        inherited.tables.borrow_mut().generator_sigs_mut().insert(fn_hir_id, None);\n         None\n     };\n     inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_hir_id, fn_sig);"}, {"sha": "2e0d0ddfc393614047cf04cc84771f449a8534ac", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 297, "deletions": 249, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -45,16 +45,14 @@ use super::FnCtxt;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n+use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::infer::UpvarRegion;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::def_id::LocalDefId;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::util::nodemap::FxHashMap;\n-\n-use std::collections::hash_map::Entry;\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_analyze(&self, body: &'gcx hir::Body) {\n@@ -65,7 +63,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct InferBorrowKindVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct InferBorrowKindVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n }\n \n@@ -79,50 +77,55 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n             hir::ExprClosure(cc, _, body_id, _, is_generator) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n-                self.fcx.analyze_closure((expr.id, expr.hir_id),\n-                                         expr.span,\n-                                         body,\n-                                         cc,\n-                                         is_generator);\n+                self.fcx\n+                    .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc, is_generator);\n             }\n \n-            _ => { }\n+            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);\n     }\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    fn analyze_closure(&self,\n-                       (closure_node_id, closure_hir_id): (ast::NodeId, hir::HirId),\n-                       span: Span,\n-                       body: &hir::Body,\n-                       capture_clause: hir::CaptureClause,\n-                       gen: bool) {\n+    fn analyze_closure(\n+        &self,\n+        closure_node_id: ast::NodeId,\n+        closure_hir_id: hir::HirId,\n+        span: Span,\n+        body: &hir::Body,\n+        capture_clause: hir::CaptureClause,\n+        is_generator: bool,\n+    ) {\n         /*!\n          * Analysis starting point.\n          */\n \n-        debug!(\"analyze_closure(id={:?}, body.id={:?})\", closure_node_id, body.id());\n+        debug!(\n+            \"analyze_closure(id={:?}, body.id={:?})\",\n+            closure_node_id,\n+            body.id()\n+        );\n \n-        let infer_kind = if gen {\n-            false\n-        } else {\n-            match self.tables\n-                      .borrow_mut()\n-                      .closure_kinds_mut()\n-                      .entry(closure_hir_id) {\n-                Entry::Occupied(_) => false,\n-                Entry::Vacant(entry) => {\n-                    debug!(\"check_closure: adding closure {:?} as Fn\", closure_node_id);\n-                    entry.insert((ty::ClosureKind::Fn, None));\n-                    true\n-                }\n+        // Extract the type of the closure.\n+        let (closure_def_id, closure_substs) = match self.node_ty(closure_hir_id).sty {\n+            ty::TyClosure(def_id, substs) | ty::TyGenerator(def_id, substs, _) => (def_id, substs),\n+            ref t => {\n+                span_bug!(\n+                    span,\n+                    \"type of closure expr {:?} is not a closure {:?}\",\n+                    closure_node_id,\n+                    t\n+                );\n             }\n         };\n \n-        let closure_def_id = self.tcx.hir.local_def_id(closure_node_id);\n+        let infer_kind = if is_generator {\n+            false\n+        } else {\n+            self.closure_kind(closure_def_id, closure_substs).is_none()\n+        };\n \n         self.tcx.with_freevars(closure_node_id, |freevars| {\n             for freevar in freevars {\n@@ -133,51 +136,63 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n \n                 let capture_kind = match capture_clause {\n-                    hir::CaptureByValue => {\n-                        ty::UpvarCapture::ByValue\n-                    }\n+                    hir::CaptureByValue => ty::UpvarCapture::ByValue,\n                     hir::CaptureByRef => {\n                         let origin = UpvarRegion(upvar_id, span);\n                         let freevar_region = self.next_region_var(origin);\n-                        let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n-                                                             region: freevar_region };\n+                        let upvar_borrow = ty::UpvarBorrow {\n+                            kind: ty::ImmBorrow,\n+                            region: freevar_region,\n+                        };\n                         ty::UpvarCapture::ByRef(upvar_borrow)\n                     }\n                 };\n \n-                self.tables.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n+                self.tables\n+                    .borrow_mut()\n+                    .upvar_capture_map\n+                    .insert(upvar_id, capture_kind);\n             }\n         });\n \n-        {\n-            let body_owner_def_id = self.tcx.hir.body_owner_def_id(body.id());\n-            let region_scope_tree = &self.tcx.region_scope_tree(body_owner_def_id);\n-            let mut delegate = InferBorrowKind {\n-                fcx: self,\n-                adjust_closure_kinds: FxHashMap(),\n-                adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n-            };\n-            euv::ExprUseVisitor::with_infer(&mut delegate,\n-                                            &self.infcx,\n-                                            self.param_env,\n-                                            region_scope_tree,\n-                                            &self.tables.borrow())\n-                .consume_body(body);\n-\n-            // Write the adjusted values back into the main tables.\n-            if infer_kind {\n-                if let Some(kind) = delegate.adjust_closure_kinds\n-                                            .remove(&closure_def_id.to_local()) {\n-                    self.tables\n-                        .borrow_mut()\n-                        .closure_kinds_mut()\n-                        .insert(closure_hir_id, kind);\n-                }\n+        let body_owner_def_id = self.tcx.hir.body_owner_def_id(body.id());\n+        let region_scope_tree = &self.tcx.region_scope_tree(body_owner_def_id);\n+        let mut delegate = InferBorrowKind {\n+            fcx: self,\n+            closure_def_id: closure_def_id,\n+            current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n+            current_origin: None,\n+            adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n+        };\n+        euv::ExprUseVisitor::with_infer(\n+            &mut delegate,\n+            &self.infcx,\n+            self.param_env,\n+            region_scope_tree,\n+            &self.tables.borrow(),\n+        ).consume_body(body);\n+\n+        if infer_kind {\n+            // Unify the (as yet unbound) type variable in the closure\n+            // substs with the kind we inferred.\n+            let inferred_kind = delegate.current_closure_kind;\n+            let closure_kind_ty = closure_substs.closure_kind_ty(closure_def_id, self.tcx);\n+            self.demand_eqtype(span, inferred_kind.to_ty(self.tcx), closure_kind_ty);\n+\n+            // If we have an origin, store it.\n+            if let Some(origin) = delegate.current_origin {\n+                self.tables\n+                    .borrow_mut()\n+                    .closure_kind_origins_mut()\n+                    .insert(closure_hir_id, origin);\n             }\n-            self.tables.borrow_mut().upvar_capture_map.extend(\n-                delegate.adjust_upvar_captures);\n         }\n \n+        self.tables\n+            .borrow_mut()\n+            .upvar_capture_map\n+            .extend(delegate.adjust_upvar_captures);\n+\n         // Now that we've analyzed the closure, we know how each\n         // variable is borrowed, and we know what traits the closure\n         // implements (Fn vs FnMut etc). We now have some updates to do\n@@ -190,36 +205,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // C, then the type would have infinite size (and the\n         // inference algorithm will reject it).\n \n-        // Extract the type variables UV0...UVn.\n-        let (def_id, closure_substs) = match self.node_ty(closure_hir_id).sty {\n-            ty::TyClosure(def_id, substs) |\n-            ty::TyGenerator(def_id, substs, _) => (def_id, substs),\n-            ref t => {\n-                span_bug!(\n-                    span,\n-                    \"type of closure expr {:?} is not a closure {:?}\",\n-                    closure_node_id, t);\n-            }\n-        };\n-\n-        // Equate the type variables with the actual types.\n+        // Equate the type variables for the upvars with the actual types.\n         let final_upvar_tys = self.final_upvar_tys(closure_node_id);\n-        debug!(\"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n-               closure_node_id, closure_substs, final_upvar_tys);\n-        for (upvar_ty, final_upvar_ty) in\n-            closure_substs.upvar_tys(def_id, self.tcx).zip(final_upvar_tys)\n+        debug!(\n+            \"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n+            closure_node_id,\n+            closure_substs,\n+            final_upvar_tys\n+        );\n+        for (upvar_ty, final_upvar_ty) in closure_substs\n+            .upvar_tys(closure_def_id, self.tcx)\n+            .zip(final_upvar_tys)\n         {\n             self.demand_eqtype(span, final_upvar_ty, upvar_ty);\n         }\n \n         // If we are also inferred the closure kind here,\n         // process any deferred resolutions.\n-        if infer_kind {\n-            let deferred_call_resolutions =\n-                self.remove_deferred_call_resolutions(closure_def_id);\n-            for deferred_call_resolution in deferred_call_resolutions {\n-                deferred_call_resolution.resolve(self);\n-            }\n+        let deferred_call_resolutions = self.remove_deferred_call_resolutions(closure_def_id);\n+        for deferred_call_resolution in deferred_call_resolutions {\n+            deferred_call_resolution.resolve(self);\n         }\n     }\n \n@@ -234,51 +239,78 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let closure_def_index = tcx.hir.local_def_id(closure_id);\n \n         tcx.with_freevars(closure_id, |freevars| {\n-            freevars.iter().map(|freevar| {\n-                let var_node_id = freevar.var_id();\n-                let var_hir_id = tcx.hir.node_to_hir_id(var_node_id);\n-                let freevar_ty = self.node_ty(var_hir_id);\n-                let upvar_id = ty::UpvarId {\n-                    var_id: var_hir_id,\n-                    closure_expr_id: LocalDefId::from_def_id(closure_def_index),\n-                };\n-                let capture = self.tables.borrow().upvar_capture(upvar_id);\n-\n-                debug!(\"var_id={:?} freevar_ty={:?} capture={:?}\",\n-                       var_node_id, freevar_ty, capture);\n-\n-                match capture {\n-                    ty::UpvarCapture::ByValue => freevar_ty,\n-                    ty::UpvarCapture::ByRef(borrow) =>\n-                        tcx.mk_ref(borrow.region,\n-                                    ty::TypeAndMut {\n-                                        ty: freevar_ty,\n-                                        mutbl: borrow.kind.to_mutbl_lossy(),\n-                                    }),\n-                }\n-            }).collect()\n+            freevars\n+                .iter()\n+                .map(|freevar| {\n+                    let var_node_id = freevar.var_id();\n+                    let var_hir_id = tcx.hir.node_to_hir_id(var_node_id);\n+                    let freevar_ty = self.node_ty(var_hir_id);\n+                    let upvar_id = ty::UpvarId {\n+                        var_id: var_hir_id,\n+                        closure_expr_id: LocalDefId::from_def_id(closure_def_index),\n+                    };\n+                    let capture = self.tables.borrow().upvar_capture(upvar_id);\n+\n+                    debug!(\n+                        \"var_id={:?} freevar_ty={:?} capture={:?}\",\n+                        var_node_id,\n+                        freevar_ty,\n+                        capture\n+                    );\n+\n+                    match capture {\n+                        ty::UpvarCapture::ByValue => freevar_ty,\n+                        ty::UpvarCapture::ByRef(borrow) => tcx.mk_ref(\n+                            borrow.region,\n+                            ty::TypeAndMut {\n+                                ty: freevar_ty,\n+                                mutbl: borrow.kind.to_mutbl_lossy(),\n+                            },\n+                        ),\n+                    }\n+                })\n+                .collect()\n         })\n     }\n }\n \n-struct InferBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct InferBorrowKind<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    adjust_closure_kinds: FxHashMap<LocalDefId, (ty::ClosureKind, Option<(Span, ast::Name)>)>,\n+\n+    // The def-id of the closure whose kind and upvar accesses are being inferred.\n+    closure_def_id: DefId,\n+\n+    // The kind that we have inferred that the current closure\n+    // requires. Note that we *always* infer a minimal kind, even if\n+    // we don't always *use* that in the final result (i.e., sometimes\n+    // we've taken the closure kind from the expectations instead, and\n+    // for generators we don't even implement the closure traits\n+    // really).\n+    current_closure_kind: ty::ClosureKind,\n+\n+    // If we modified `current_closure_kind`, this field contains a `Some()` with the\n+    // variable access that caused us to do so.\n+    current_origin: Option<(Span, ast::Name)>,\n+\n+    // For each upvar that we access, we track the minimal kind of\n+    // access we need (ref, ref mut, move, etc).\n     adjust_upvar_captures: ty::UpvarCaptureMap<'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n-    fn adjust_upvar_borrow_kind_for_consume(&mut self,\n-                                            cmt: mc::cmt<'tcx>,\n-                                            mode: euv::ConsumeMode)\n-    {\n-        debug!(\"adjust_upvar_borrow_kind_for_consume(cmt={:?}, mode={:?})\",\n-               cmt, mode);\n+    fn adjust_upvar_borrow_kind_for_consume(&mut self, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n+        debug!(\n+            \"adjust_upvar_borrow_kind_for_consume(cmt={:?}, mode={:?})\",\n+            cmt,\n+            mode\n+        );\n \n         // we only care about moves\n         match mode {\n-            euv::Copy => { return; }\n-            euv::Move(_) => { }\n+            euv::Copy => {\n+                return;\n+            }\n+            euv::Move(_) => {}\n         }\n \n         let tcx = self.fcx.tcx;\n@@ -287,28 +319,39 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n         // for that to be legal, the upvar would have to be borrowed\n         // by value instead\n         let guarantor = cmt.guarantor();\n-        debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor={:?}\",\n-               guarantor);\n-        debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor.cat={:?}\",\n-               guarantor.cat);\n+        debug!(\n+            \"adjust_upvar_borrow_kind_for_consume: guarantor={:?}\",\n+            guarantor\n+        );\n+        debug!(\n+            \"adjust_upvar_borrow_kind_for_consume: guarantor.cat={:?}\",\n+            guarantor.cat\n+        );\n         match guarantor.cat {\n             Categorization::Deref(_, mc::BorrowedPtr(..)) |\n             Categorization::Deref(_, mc::Implicit(..)) => {\n-                debug!(\"adjust_upvar_borrow_kind_for_consume: found deref with note {:?}\",\n-                       cmt.note);\n+                debug!(\n+                    \"adjust_upvar_borrow_kind_for_consume: found deref with note {:?}\",\n+                    cmt.note\n+                );\n                 match guarantor.note {\n                     mc::NoteUpvarRef(upvar_id) => {\n-                        debug!(\"adjust_upvar_borrow_kind_for_consume: \\\n-                                setting upvar_id={:?} to by value\",\n-                               upvar_id);\n+                        debug!(\n+                            \"adjust_upvar_borrow_kind_for_consume: \\\n+                             setting upvar_id={:?} to by value\",\n+                            upvar_id\n+                        );\n \n                         // to move out of an upvar, this must be a FnOnce closure\n-                        self.adjust_closure_kind(upvar_id.closure_expr_id,\n-                                                 ty::ClosureKind::FnOnce,\n-                                                 guarantor.span,\n-                                                 var_name(tcx, upvar_id.var_id));\n-\n-                        self.adjust_upvar_captures.insert(upvar_id, ty::UpvarCapture::ByValue);\n+                        self.adjust_closure_kind(\n+                            upvar_id.closure_expr_id,\n+                            ty::ClosureKind::FnOnce,\n+                            guarantor.span,\n+                            var_name(tcx, upvar_id.var_id),\n+                        );\n+\n+                        self.adjust_upvar_captures\n+                            .insert(upvar_id, ty::UpvarCapture::ByValue);\n                     }\n                     mc::NoteClosureEnv(upvar_id) => {\n                         // we get just a closureenv ref if this is a\n@@ -317,25 +360,25 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                         // must still adjust the kind of the closure\n                         // to be a FnOnce closure to permit moves out\n                         // of the environment.\n-                        self.adjust_closure_kind(upvar_id.closure_expr_id,\n-                                                 ty::ClosureKind::FnOnce,\n-                                                 guarantor.span,\n-                                                 var_name(tcx, upvar_id.var_id));\n-                    }\n-                    mc::NoteNone => {\n+                        self.adjust_closure_kind(\n+                            upvar_id.closure_expr_id,\n+                            ty::ClosureKind::FnOnce,\n+                            guarantor.span,\n+                            var_name(tcx, upvar_id.var_id),\n+                        );\n                     }\n+                    mc::NoteNone => {}\n                 }\n             }\n-            _ => { }\n+            _ => {}\n         }\n     }\n \n     /// Indicates that `cmt` is being directly mutated (e.g., assigned\n     /// to). If cmt contains any by-ref upvars, this implies that\n     /// those upvars must be borrowed using an `&mut` borrow.\n     fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: mc::cmt<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={:?})\",\n-               cmt);\n+        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n             Categorization::Deref(base, mc::Unique) |\n@@ -368,8 +411,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     }\n \n     fn adjust_upvar_borrow_kind_for_unique(&mut self, cmt: mc::cmt<'tcx>) {\n-        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\",\n-               cmt);\n+        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n             Categorization::Deref(base, mc::Unique) |\n@@ -393,16 +435,11 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n             Categorization::StaticItem |\n             Categorization::Rvalue(..) |\n             Categorization::Local(_) |\n-            Categorization::Upvar(..) => {\n-            }\n+            Categorization::Upvar(..) => {}\n         }\n     }\n \n-    fn try_adjust_upvar_deref(&mut self,\n-                              cmt: mc::cmt<'tcx>,\n-                              borrow_kind: ty::BorrowKind)\n-                              -> bool\n-    {\n+    fn try_adjust_upvar_deref(&mut self, cmt: mc::cmt<'tcx>, borrow_kind: ty::BorrowKind) -> bool {\n         assert!(match borrow_kind {\n             ty::MutBorrow => true,\n             ty::UniqueImmBorrow => true,\n@@ -422,27 +459,29 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 self.adjust_upvar_borrow_kind(upvar_id, borrow_kind);\n \n                 // also need to be in an FnMut closure since this is not an ImmBorrow\n-                self.adjust_closure_kind(upvar_id.closure_expr_id,\n-                                         ty::ClosureKind::FnMut,\n-                                         cmt.span,\n-                                         var_name(tcx, upvar_id.var_id));\n+                self.adjust_closure_kind(\n+                    upvar_id.closure_expr_id,\n+                    ty::ClosureKind::FnMut,\n+                    cmt.span,\n+                    var_name(tcx, upvar_id.var_id),\n+                );\n \n                 true\n             }\n             mc::NoteClosureEnv(upvar_id) => {\n                 // this kind of deref occurs in a `move` closure, or\n                 // for a by-value upvar; in either case, to mutate an\n                 // upvar, we need to be an FnMut closure\n-                self.adjust_closure_kind(upvar_id.closure_expr_id,\n-                                         ty::ClosureKind::FnMut,\n-                                         cmt.span,\n-                                         var_name(tcx, upvar_id.var_id));\n+                self.adjust_closure_kind(\n+                    upvar_id.closure_expr_id,\n+                    ty::ClosureKind::FnMut,\n+                    cmt.span,\n+                    var_name(tcx, upvar_id.var_id),\n+                );\n \n                 true\n             }\n-            mc::NoteNone => {\n-                false\n-            }\n+            mc::NoteNone => false,\n         }\n     }\n \n@@ -451,13 +490,17 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     /// moving from left to right as needed (but never right to left).\n     /// Here the argument `mutbl` is the borrow_kind that is required by\n     /// some particular use.\n-    fn adjust_upvar_borrow_kind(&mut self,\n-                                upvar_id: ty::UpvarId,\n-                                kind: ty::BorrowKind) {\n-        let upvar_capture = self.adjust_upvar_captures.get(&upvar_id).cloned()\n+    fn adjust_upvar_borrow_kind(&mut self, upvar_id: ty::UpvarId, kind: ty::BorrowKind) {\n+        let upvar_capture = self.adjust_upvar_captures\n+            .get(&upvar_id)\n+            .cloned()\n             .unwrap_or_else(|| self.fcx.tables.borrow().upvar_capture(upvar_id));\n-        debug!(\"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n-               upvar_id, upvar_capture, kind);\n+        debug!(\n+            \"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n+            upvar_id,\n+            upvar_capture,\n+            kind\n+        );\n \n         match upvar_capture {\n             ty::UpvarCapture::ByValue => {\n@@ -470,99 +513,107 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                     (ty::ImmBorrow, ty::MutBorrow) |\n                     (ty::UniqueImmBorrow, ty::MutBorrow) => {\n                         upvar_borrow.kind = kind;\n-                        self.adjust_upvar_captures.insert(upvar_id,\n-                            ty::UpvarCapture::ByRef(upvar_borrow));\n+                        self.adjust_upvar_captures\n+                            .insert(upvar_id, ty::UpvarCapture::ByRef(upvar_borrow));\n                     }\n                     // Take LHS:\n                     (ty::ImmBorrow, ty::ImmBorrow) |\n                     (ty::UniqueImmBorrow, ty::ImmBorrow) |\n                     (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n-                    (ty::MutBorrow, _) => {\n-                    }\n+                    (ty::MutBorrow, _) => {}\n                 }\n             }\n         }\n     }\n \n-    fn adjust_closure_kind(&mut self,\n-                           closure_id: LocalDefId,\n-                           new_kind: ty::ClosureKind,\n-                           upvar_span: Span,\n-                           var_name: ast::Name) {\n-        debug!(\"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n-               closure_id, new_kind, upvar_span, var_name);\n-\n-        let closure_kind = self.adjust_closure_kinds.get(&closure_id).cloned()\n-            .or_else(|| {\n-                let closure_id = self.fcx.tcx.hir.local_def_id_to_hir_id(closure_id);\n-                self.fcx.tables.borrow().closure_kinds().get(closure_id).cloned()\n-            });\n-\n-        if let Some((existing_kind, _)) = closure_kind {\n-            debug!(\"adjust_closure_kind: closure_id={:?}, existing_kind={:?}, new_kind={:?}\",\n-                   closure_id, existing_kind, new_kind);\n-\n-            match (existing_kind, new_kind) {\n-                (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-                (ty::ClosureKind::FnMut, ty::ClosureKind::Fn) |\n-                (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-                (ty::ClosureKind::FnOnce, _) => {\n-                    // no change needed\n-                }\n+    fn adjust_closure_kind(\n+        &mut self,\n+        closure_id: LocalDefId,\n+        new_kind: ty::ClosureKind,\n+        upvar_span: Span,\n+        var_name: ast::Name,\n+    ) {\n+        debug!(\n+            \"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n+            closure_id,\n+            new_kind,\n+            upvar_span,\n+            var_name\n+        );\n+\n+        // Is this the closure whose kind is currently being inferred?\n+        if closure_id.to_def_id() != self.closure_def_id {\n+            debug!(\"adjust_closure_kind: not current closure\");\n+            return;\n+        }\n \n-                (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) |\n-                (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-                (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-                    // new kind is stronger than the old kind\n-                    self.adjust_closure_kinds.insert(\n-                        closure_id,\n-                        (new_kind, Some((upvar_span, var_name)))\n-                    );\n-                }\n+        // closures start out as `Fn`.\n+        let existing_kind = self.current_closure_kind;\n+\n+        debug!(\n+            \"adjust_closure_kind: closure_id={:?}, existing_kind={:?}, new_kind={:?}\",\n+            closure_id,\n+            existing_kind,\n+            new_kind\n+        );\n+\n+        match (existing_kind, new_kind) {\n+            (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+            (ty::ClosureKind::FnMut, ty::ClosureKind::Fn) |\n+            (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+            (ty::ClosureKind::FnOnce, _) => {\n+                // no change needed\n+            }\n+\n+            (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) |\n+            (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+            (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+                // new kind is stronger than the old kind\n+                self.current_closure_kind = new_kind;\n+                self.current_origin = Some((upvar_span, var_name));\n             }\n         }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n-    fn consume(&mut self,\n-               _consume_id: ast::NodeId,\n-               _consume_span: Span,\n-               cmt: mc::cmt<'tcx>,\n-               mode: euv::ConsumeMode)\n-    {\n+    fn consume(\n+        &mut self,\n+        _consume_id: ast::NodeId,\n+        _consume_span: Span,\n+        cmt: mc::cmt<'tcx>,\n+        mode: euv::ConsumeMode,\n+    ) {\n         debug!(\"consume(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n-    fn matched_pat(&mut self,\n-                   _matched_pat: &hir::Pat,\n-                   _cmt: mc::cmt<'tcx>,\n-                   _mode: euv::MatchMode)\n-    {}\n-\n-    fn consume_pat(&mut self,\n-                   _consume_pat: &hir::Pat,\n-                   cmt: mc::cmt<'tcx>,\n-                   mode: euv::ConsumeMode)\n-    {\n+    fn matched_pat(&mut self, _matched_pat: &hir::Pat, _cmt: mc::cmt<'tcx>, _mode: euv::MatchMode) {\n+    }\n+\n+    fn consume_pat(&mut self, _consume_pat: &hir::Pat, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n-    fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n-              _borrow_span: Span,\n-              cmt: mc::cmt<'tcx>,\n-              _loan_region: ty::Region<'tcx>,\n-              bk: ty::BorrowKind,\n-              _loan_cause: euv::LoanCause)\n-    {\n-        debug!(\"borrow(borrow_id={}, cmt={:?}, bk={:?})\",\n-               borrow_id, cmt, bk);\n+    fn borrow(\n+        &mut self,\n+        borrow_id: ast::NodeId,\n+        _borrow_span: Span,\n+        cmt: mc::cmt<'tcx>,\n+        _loan_region: ty::Region<'tcx>,\n+        bk: ty::BorrowKind,\n+        _loan_cause: euv::LoanCause,\n+    ) {\n+        debug!(\n+            \"borrow(borrow_id={}, cmt={:?}, bk={:?})\",\n+            borrow_id,\n+            cmt,\n+            bk\n+        );\n \n         match bk {\n-            ty::ImmBorrow => { }\n+            ty::ImmBorrow => {}\n             ty::UniqueImmBorrow => {\n                 self.adjust_upvar_borrow_kind_for_unique(cmt);\n             }\n@@ -572,19 +623,16 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn decl_without_init(&mut self,\n-                         _id: ast::NodeId,\n-                         _span: Span)\n-    {}\n-\n-    fn mutate(&mut self,\n-              _assignment_id: ast::NodeId,\n-              _assignment_span: Span,\n-              assignee_cmt: mc::cmt<'tcx>,\n-              _mode: euv::MutateMode)\n-    {\n-        debug!(\"mutate(assignee_cmt={:?})\",\n-               assignee_cmt);\n+    fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) {}\n+\n+    fn mutate(\n+        &mut self,\n+        _assignment_id: ast::NodeId,\n+        _assignment_span: Span,\n+        assignee_cmt: mc::cmt<'tcx>,\n+        _mode: euv::MutateMode,\n+    ) {\n+        debug!(\"mutate(assignee_cmt={:?})\", assignee_cmt);\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);\n     }"}, {"sha": "f287d286656afb10c12345ac0a9ff4343b6836bb", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -47,8 +47,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_anon_types();\n         wbcx.visit_cast_types();\n         wbcx.visit_free_region_map();\n-        wbcx.visit_generator_sigs();\n-        wbcx.visit_generator_interiors();\n \n         let used_trait_imports = mem::replace(&mut self.tables.borrow_mut().used_trait_imports,\n                                               Rc::new(DefIdSet()));\n@@ -244,21 +242,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n         let common_local_id_root = fcx_tables.local_id_root.unwrap();\n \n-        for (&id, closure_ty) in fcx_tables.closure_tys().iter() {\n+        for (&id, &origin) in fcx_tables.closure_kind_origins().iter() {\n             let hir_id = hir::HirId {\n                 owner: common_local_id_root.index,\n                 local_id: id,\n             };\n-            let closure_ty = self.resolve(closure_ty, &hir_id);\n-            self.tables.closure_tys_mut().insert(hir_id, closure_ty);\n-        }\n-\n-        for (&id, &closure_kind) in fcx_tables.closure_kinds().iter() {\n-            let hir_id = hir::HirId {\n-                owner: common_local_id_root.index,\n-                local_id: id,\n-            };\n-            self.tables.closure_kinds_mut().insert(hir_id, closure_kind);\n+            self.tables.closure_kind_origins_mut().insert(hir_id, origin);\n         }\n     }\n \n@@ -418,33 +407,6 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_generator_interiors(&mut self) {\n-        let common_local_id_root = self.fcx.tables.borrow().local_id_root.unwrap();\n-        for (&id, interior) in self.fcx.tables.borrow().generator_interiors().iter() {\n-            let hir_id = hir::HirId {\n-                owner: common_local_id_root.index,\n-                local_id: id,\n-            };\n-            let interior = self.resolve(interior, &hir_id);\n-            self.tables.generator_interiors_mut().insert(hir_id, interior);\n-        }\n-    }\n-\n-    fn visit_generator_sigs(&mut self) {\n-        let common_local_id_root = self.fcx.tables.borrow().local_id_root.unwrap();\n-        for (&id, gen_sig) in self.fcx.tables.borrow().generator_sigs().iter() {\n-            let hir_id = hir::HirId {\n-                owner: common_local_id_root.index,\n-                local_id: id,\n-            };\n-            let gen_sig = gen_sig.map(|s| ty::GenSig {\n-                yield_ty: self.resolve(&s.yield_ty, &hir_id),\n-                return_ty: self.resolve(&s.return_ty, &hir_id),\n-            });\n-            self.tables.generator_sigs_mut().insert(hir_id, gen_sig);\n-        }\n-    }\n-\n     fn visit_liberated_fn_sigs(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);"}, {"sha": "4c6bad61b19ab961f4fcc189f92474271f8941b4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -1019,9 +1019,31 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // cares about anything but the length is instantiation,\n     // and we don't do that for closures.\n     if let NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) = node {\n+        // add a dummy parameter for the closure kind\n+        types.push(ty::TypeParameterDef {\n+            index: type_start,\n+            name: Symbol::intern(\"<closure_kind>\"),\n+            def_id,\n+            has_default: false,\n+            object_lifetime_default: rl::Set1::Empty,\n+            pure_wrt_drop: false,\n+            synthetic: None,\n+        });\n+\n+        // add a dummy parameter for the closure signature\n+        types.push(ty::TypeParameterDef {\n+            index: type_start + 1,\n+            name: Symbol::intern(\"<closure_signature>\"),\n+            def_id,\n+            has_default: false,\n+            object_lifetime_default: rl::Set1::Empty,\n+            pure_wrt_drop: false,\n+            synthetic: None,\n+        });\n+\n         tcx.with_freevars(node_id, |fv| {\n-            types.extend(fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n-                index: type_start + i as u32,\n+            types.extend(fv.iter().zip(2..).map(|(_, i)| ty::TypeParameterDef {\n+                index: type_start + i,\n                 name: Symbol::intern(\"<upvar>\"),\n                 def_id,\n                 has_default: false,\n@@ -1156,14 +1178,19 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 return tcx.typeck_tables_of(def_id).node_id_to_type(hir_id);\n             }\n \n-            tcx.mk_closure(def_id, Substs::for_item(\n-                tcx, def_id,\n-                |def, _| {\n-                    let region = def.to_early_bound_region_data();\n-                    tcx.mk_region(ty::ReEarlyBound(region))\n-                },\n-                |def, _| tcx.mk_param_from_def(def)\n-            ))\n+            let substs = ty::ClosureSubsts {\n+                substs: Substs::for_item(\n+                    tcx,\n+                    def_id,\n+                    |def, _| {\n+                        let region = def.to_early_bound_region_data();\n+                        tcx.mk_region(ty::ReEarlyBound(region))\n+                    },\n+                    |def, _| tcx.mk_param_from_def(def)\n+                )\n+            };\n+\n+            tcx.mk_closure(def_id, substs)\n         }\n \n         NodeExpr(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n@@ -1242,7 +1269,14 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         NodeExpr(&hir::Expr { node: hir::ExprClosure(..), hir_id, .. }) => {\n-            tcx.typeck_tables_of(def_id).closure_tys()[hir_id]\n+            let tables = tcx.typeck_tables_of(def_id);\n+            match tables.node_id_to_type(hir_id).sty {\n+                ty::TyClosure(closure_def_id, closure_substs) => {\n+                    assert_eq!(def_id, closure_def_id);\n+                    return closure_substs.closure_sig(closure_def_id, tcx);\n+                }\n+                ref t => bug!(\"closure with non-closure type: {:?}\", t),\n+            }\n         }\n \n         x => {"}, {"sha": "513a17e2ef2f4e1a1218da12ccadcddc65b5f5f9", "filename": "src/test/compile-fail/closure-bounds-static-cant-capture-borrowed.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -13,8 +13,7 @@ fn bar<F>(blk: F) where F: FnOnce() + 'static {\n \n fn foo(x: &()) {\n     bar(|| {\n-        //~^ ERROR cannot infer\n-        //~| ERROR does not fulfill\n+        //~^ ERROR does not fulfill\n         let _ = x;\n     })\n }"}, {"sha": "13abdf616b29b81b7a563044a0c546b7c73656bc", "filename": "src/test/compile-fail/generator-yielding-or-returning-itself.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fcompile-fail%2Fgenerator-yielding-or-returning-itself.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fcompile-fail%2Fgenerator-yielding-or-returning-itself.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgenerator-yielding-or-returning-itself.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generator_trait)]\n+#![feature(generators)]\n+\n+// Test that we cannot create a generator that returns a value of its\n+// own type.\n+\n+use std::ops::Generator;\n+\n+pub fn want_cyclic_generator_return<T>(_: T)\n+    where T: Generator<Yield = (), Return = T>\n+{\n+}\n+\n+fn supply_cyclic_generator_return() {\n+    want_cyclic_generator_return(|| {\n+        //~^ ERROR type mismatch\n+        if false { yield None.unwrap(); }\n+        None.unwrap()\n+    })\n+}\n+\n+pub fn want_cyclic_generator_yield<T>(_: T)\n+    where T: Generator<Yield = T, Return = ()>\n+{\n+}\n+\n+fn supply_cyclic_generator_yield() {\n+    want_cyclic_generator_yield(|| {\n+        //~^ ERROR type mismatch\n+        if false { yield None.unwrap(); }\n+        None.unwrap()\n+    })\n+}\n+\n+fn main() { }"}, {"sha": "1c534ebbd4350df425263279749196d4de581255", "filename": "src/test/compile-fail/issue-22638.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fcompile-fail%2Fissue-22638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fcompile-fail%2Fissue-22638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22638.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -19,7 +19,6 @@ struct A (B);\n \n impl A {\n     pub fn matches<F: Fn()>(&self, f: &F) {\n-        //~^ ERROR reached the recursion limit while instantiating `A::matches::<[closure\n         let &A(ref term) = self;\n         term.matches(f);\n     }\n@@ -59,6 +58,7 @@ struct D (Box<A>);\n \n impl D {\n     pub fn matches<F: Fn()>(&self, f: &F) {\n+        //~^ ERROR reached the type-length limit while instantiating `D::matches::<[closure\n         let &D(ref a) = self;\n         a.matches(f)\n     }"}, {"sha": "6e33fd5ae71a670d1353107fd1dcbaa2ea93b531", "filename": "src/test/compile-fail/issue-25439.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fcompile-fail%2Fissue-25439.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fcompile-fail%2Fissue-25439.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25439.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -15,5 +15,5 @@ fn fix<F>(f: F) -> i32 where F: Fn(Helper<F>, i32) -> i32 {\n }\n \n fn main() {\n-    fix(|_, x| x);\n+    fix(|_, x| x); //~ ERROR closure/generator type that references itself [E0644]\n }", "previous_filename": "src/test/run-pass/issue-25439.rs"}, {"sha": "5d162fe944ec84cea4cc8430a7a86ab1cd5cfd2b", "filename": "src/test/compile-fail/occurs-check-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -16,7 +16,5 @@ fn main() {\n     g = f;\n     f = box g;\n     //~^  ERROR mismatched types\n-    //~| expected type `_`\n-    //~| found type `std::boxed::Box<_>`\n     //~| cyclic type of infinite size\n }"}, {"sha": "2c784365ea989df361484c53b90b7848db718c32", "filename": "src/test/compile-fail/occurs-check.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -14,7 +14,5 @@ fn main() {\n     let f;\n     f = box f;\n     //~^ ERROR mismatched types\n-    //~| expected type `_`\n-    //~| found type `std::boxed::Box<_>`\n     //~| cyclic type of infinite size\n }"}, {"sha": "de7b38d5519567010beee75acc20adac18726c78", "filename": "src/test/mir-opt/inline-closure-borrows-arg.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z span_free_formats\n+\n+// Tests that MIR inliner can handle closure arguments,\n+// even when (#45894)\n+\n+fn main() {\n+    println!(\"{}\", foo(0, &14));\n+}\n+\n+fn foo<T: Copy>(_t: T, q: &i32) -> i32 {\n+    let x = |r: &i32, _s: &i32| {\n+        let variable = &*r;\n+        *variable\n+    };\n+    x(q, q)\n+}\n+\n+// END RUST SOURCE\n+// START rustc.foo.Inline.after.mir\n+// ...\n+// bb0: {\n+//     ...\n+//     _3 = [closure@NodeId(39)];\n+//     ...\n+//     _4 = &_3;\n+//     ...\n+//     _6 = &(*_2);\n+//     ...\n+//     _7 = &(*_2);\n+//     _5 = (_6, _7);\n+//     _9 = (_5.0: &i32);\n+//     _10 = (_5.1: &i32);\n+//     StorageLive(_8);\n+//     _8 = (*_9);\n+//     _0 = _8;\n+//     ...\n+//     return;\n+// }\n+// ...\n+// END rustc.foo.Inline.after.mir"}, {"sha": "9d3fb923f5b3a25bd9f33e4ec3c2db29d9659b14", "filename": "src/test/mir-opt/inline-closure.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -34,9 +34,11 @@ fn foo<T: Copy>(_t: T, q: i32) -> i32 {\n //     ...\n //     _7 = _2;\n //     _5 = (_6, _7);\n-//     _0 = (_5.0: i32);\n+//     _8 = (_5.0: i32);\n+//     _9 = (_5.1: i32);\n+//     _0 = _8;\n //     ...\n //     return;\n // }\n // ...\n-// END rustc.foo.Inline.after.mir\n\\ No newline at end of file\n+// END rustc.foo.Inline.after.mir"}, {"sha": "c3d5f21b0a51ead63e51e685b3b3233b928d9739", "filename": "src/test/ui/block-result/issue-3563.stderr", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -6,16 +6,5 @@ error[E0599]: no method named `b` found for type `&Self` in the current scope\n    |\n    = help: did you mean `a`?\n \n-error[E0308]: mismatched types\n-  --> $DIR/issue-3563.rs:13:9\n-   |\n-12 |     fn a(&self) {\n-   |                 - possibly return type missing here?\n-13 |         || self.b()\n-   |         ^^^^^^^^^^^ expected (), found closure\n-   |\n-   = note: expected type `()`\n-              found type `[closure@$DIR/issue-3563.rs:13:9: 13:20 self:_]`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "5bd6ef806b5a5941ead0b7f58f6676ce2eb869b1", "filename": "src/test/ui/span/coerce-suggestions.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -43,9 +43,6 @@ error[E0308]: mismatched types\n    |\n 41 |     f = box f;\n    |         ^^^^^ cyclic type of infinite size\n-   |\n-   = note: expected type `_`\n-              found type `std::boxed::Box<_>`\n \n error[E0308]: mismatched types\n   --> $DIR/coerce-suggestions.rs:48:9"}, {"sha": "78d119ef329d0ae4ec1a198acba226a3550e5403", "filename": "src/test/ui/unboxed-closure-no-cyclic-sig.rs", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fui%2Funboxed-closure-no-cyclic-sig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fui%2Funboxed-closure-no-cyclic-sig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closure-no-cyclic-sig.rs?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that unboxed closures cannot capture their own type.\n+//\n+// Also regression test for issue #21410.\n+\n fn g<F>(_: F) where F: FnOnce(Option<F>) {}\n \n fn main() {", "previous_filename": "src/test/run-pass/issue-21410.rs"}, {"sha": "a4279a2afac603ffe922d7a71aecfa16c71a3e40", "filename": "src/test/ui/unboxed-closure-no-cyclic-sig.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fui%2Funboxed-closure-no-cyclic-sig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6d09e0b4dac93ae07dae6206bf95e7cea0124a2/src%2Ftest%2Fui%2Funboxed-closure-no-cyclic-sig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closure-no-cyclic-sig.stderr?ref=d6d09e0b4dac93ae07dae6206bf95e7cea0124a2", "patch": "@@ -0,0 +1,12 @@\n+error[E0644]: closure/generator type that references itself\n+  --> $DIR/unboxed-closure-no-cyclic-sig.rs:18:7\n+   |\n+18 |     g(|_| {  });\n+   |       ^^^^^^^^ cyclic type of infinite size\n+   |\n+   = note: closures cannot capture themselves or take themselves as argument;\n+           this error may be the result of a recent compiler bug-fix,\n+           see https://github.com/rust-lang/rust/issues/46062 for more details\n+\n+error: aborting due to previous error\n+"}]}