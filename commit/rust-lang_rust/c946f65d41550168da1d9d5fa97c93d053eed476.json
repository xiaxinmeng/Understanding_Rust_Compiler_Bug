{"sha": "c946f65d41550168da1d9d5fa97c93d053eed476", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NDZmNjVkNDE1NTAxNjhkYTFkOWQ1ZmE5N2M5M2QwNTNlZWQ0NzY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-20T01:32:13Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-20T02:12:35Z"}, "message": "std: Mostly demode net::tcp", "tree": {"sha": "03f23d12f67d6a68a4419c2e751c0d1ed35c57ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03f23d12f67d6a68a4419c2e751c0d1ed35c57ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c946f65d41550168da1d9d5fa97c93d053eed476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c946f65d41550168da1d9d5fa97c93d053eed476", "html_url": "https://github.com/rust-lang/rust/commit/c946f65d41550168da1d9d5fa97c93d053eed476", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c946f65d41550168da1d9d5fa97c93d053eed476/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2792071bd24848da43f0daa008d661e8f06b8690", "url": "https://api.github.com/repos/rust-lang/rust/commits/2792071bd24848da43f0daa008d661e8f06b8690", "html_url": "https://github.com/rust-lang/rust/commit/2792071bd24848da43f0daa008d661e8f06b8690"}], "stats": {"total": 60, "additions": 30, "deletions": 30}, "files": [{"sha": "8e72e92be99b9730b916bc1254d19c7e18b26bad", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c946f65d41550168da1d9d5fa97c93d053eed476/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c946f65d41550168da1d9d5fa97c93d053eed476/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=c946f65d41550168da1d9d5fa97c93d053eed476", "patch": "@@ -128,7 +128,7 @@ enum TcpConnectErrData {\n  * the remote host. In the event of failure, a\n  * `net::tcp::tcp_connect_err_data` instance will be returned\n  */\n-fn connect(-input_ip: ip::IpAddr, port: uint,\n+fn connect(+input_ip: ip::IpAddr, port: uint,\n            iotask: IoTask)\n     -> result::Result<TcpSocket, TcpConnectErrData> unsafe {\n     let result_po = core::comm::Port::<ConnAttempt>();\n@@ -261,7 +261,7 @@ fn connect(-input_ip: ip::IpAddr, port: uint,\n  * A `result` object with a `nil` value as the `ok` variant, or a\n  * `tcp_err_data` value as the `err` variant\n  */\n-fn write(sock: TcpSocket, raw_write_data: ~[u8])\n+fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n     -> result::Result<(), TcpErrData> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n     write_common_impl(socket_data_ptr, raw_write_data)\n@@ -298,7 +298,7 @@ fn write(sock: TcpSocket, raw_write_data: ~[u8])\n  * `result` object with a `nil` value as the `ok` variant, or a `tcp_err_data`\n  * value as the `err` variant\n  */\n-fn write_future(sock: TcpSocket, raw_write_data: ~[u8])\n+fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n     -> future::Future<result::Result<(), TcpErrData>> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n     do future_spawn {\n@@ -322,7 +322,7 @@ fn write_future(sock: TcpSocket, raw_write_data: ~[u8])\n  * optionally, loop on) from until `read_stop` is called, or a\n  * `tcp_err_data` record\n  */\n-fn read_start(sock: TcpSocket)\n+fn read_start(sock: &TcpSocket)\n     -> result::Result<comm::Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> unsafe {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n@@ -336,8 +336,8 @@ fn read_start(sock: TcpSocket)\n  *\n  * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n  */\n-fn read_stop(sock: TcpSocket,\n-             -read_port: comm::Port<result::Result<~[u8], TcpErrData>>) ->\n+fn read_stop(sock: &TcpSocket,\n+             +read_port: comm::Port<result::Result<~[u8], TcpErrData>>) ->\n     result::Result<(), TcpErrData> unsafe {\n     log(debug, fmt!(\"taking the read_port out of commission %?\", read_port));\n     let socket_data = ptr::addr_of(*sock.socket_data);\n@@ -359,7 +359,7 @@ fn read_stop(sock: TcpSocket,\n  * * `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n-fn read(sock: TcpSocket, timeout_msecs: uint)\n+fn read(sock: &TcpSocket, timeout_msecs: uint)\n     -> result::Result<~[u8],TcpErrData> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     read_common_impl(socket_data, timeout_msecs)\n@@ -394,7 +394,7 @@ fn read(sock: TcpSocket, timeout_msecs: uint)\n  * * `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n-fn read_future(sock: TcpSocket, timeout_msecs: uint)\n+fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n     -> future::Future<result::Result<~[u8],TcpErrData>> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     do future_spawn {\n@@ -569,9 +569,9 @@ fn accept(new_conn: TcpNewConnection)\n  * successful/normal shutdown, and a `tcp_listen_err_data` enum in the event\n  * of listen exiting because of an error\n  */\n-fn listen(-host_ip: ip::IpAddr, port: uint, backlog: uint,\n+fn listen(+host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n-          on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n+          +on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n           +new_connect_cb: fn~(TcpNewConnection,\n                                comm::Chan<Option<TcpErrData>>))\n     -> result::Result<(), TcpListenErrData> unsafe {\n@@ -586,10 +586,10 @@ fn listen(-host_ip: ip::IpAddr, port: uint, backlog: uint,\n     }\n }\n \n-fn listen_common(-host_ip: ip::IpAddr, port: uint, backlog: uint,\n+fn listen_common(+host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n-          on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n-          -on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n+          +on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n+          +on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n     -> result::Result<(), TcpListenErrData> unsafe {\n     let stream_closed_po = core::comm::Port::<()>();\n     let kill_po = core::comm::Port::<Option<TcpErrData>>();\n@@ -726,36 +726,36 @@ fn listen_common(-host_ip: ip::IpAddr, port: uint, backlog: uint,\n  *\n  * A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n  */\n-fn socket_buf(-sock: TcpSocket) -> TcpSocketBuf {\n+fn socket_buf(+sock: TcpSocket) -> TcpSocketBuf {\n     TcpSocketBuf(@{ sock: move sock, mut buf: ~[] })\n }\n \n /// Convenience methods extending `net::tcp::tcp_socket`\n impl TcpSocket {\n     fn read_start() -> result::Result<comm::Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n-        read_start(self)\n+        read_start(&self)\n     }\n     fn read_stop(-read_port:\n                  comm::Port<result::Result<~[u8], TcpErrData>>) ->\n         result::Result<(), TcpErrData> {\n-        read_stop(self, move read_port)\n+        read_stop(&self, move read_port)\n     }\n     fn read(timeout_msecs: uint) ->\n         result::Result<~[u8], TcpErrData> {\n-        read(self, timeout_msecs)\n+        read(&self, timeout_msecs)\n     }\n     fn read_future(timeout_msecs: uint) ->\n         future::Future<result::Result<~[u8], TcpErrData>> {\n-        read_future(self, timeout_msecs)\n+        read_future(&self, timeout_msecs)\n     }\n     fn write(raw_write_data: ~[u8])\n         -> result::Result<(), TcpErrData> {\n-        write(self, raw_write_data)\n+        write(&self, raw_write_data)\n     }\n     fn write_future(raw_write_data: ~[u8])\n         -> future::Future<result::Result<(), TcpErrData>> {\n-        write_future(self, raw_write_data)\n+        write_future(&self, raw_write_data)\n     }\n }\n \n@@ -764,7 +764,7 @@ impl TcpSocketBuf: io::Reader {\n     fn read(buf: &[mut u8], len: uint) -> uint {\n         // Loop until our buffer has enough data in it for us to read from.\n         while self.data.buf.len() < len {\n-            let read_result = read(self.data.sock, 0u);\n+            let read_result = read(&self.data.sock, 0u);\n             if read_result.is_err() {\n                 let err_data = read_result.get_err();\n \n@@ -1112,7 +1112,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n }\n \n extern fn on_alloc_cb(handle: *libc::c_void,\n-                     ++suggested_size: size_t)\n+                      suggested_size: size_t)\n     -> uv::ll::uv_buf_t unsafe {\n     log(debug, ~\"tcp read on_alloc_cb!\");\n     let char_ptr = uv::ll::malloc_buf_base_of(suggested_size);\n@@ -1470,7 +1470,7 @@ mod test {\n         */\n     }\n \n-    fn buf_write<W:io::Writer>(+w: &W, val: ~str) {\n+    fn buf_write<W:io::Writer>(+w: &W, val: &str) {\n         log(debug, fmt!(\"BUF_WRITE: val len %?\", str::len(val)));\n         do str::byte_slice(val) |b_slice| {\n             log(debug, fmt!(\"BUF_WRITE: b_slice len %?\",\n@@ -1486,7 +1486,7 @@ mod test {\n         str::from_bytes(new_bytes)\n     }\n \n-    fn run_tcp_test_server(server_ip: ~str, server_port: uint, resp: ~str,\n+    fn run_tcp_test_server(server_ip: &str, server_port: uint, +resp: ~str,\n                           server_ch: comm::Chan<~str>,\n                           cont_ch: comm::Chan<()>,\n                           iotask: IoTask) -> ~str {\n@@ -1524,7 +1524,7 @@ mod test {\n                         let sock = result::unwrap(move accept_result);\n                         log(debug, ~\"SERVER: successfully accepted\"+\n                             ~\"connection!\");\n-                        let received_req_bytes = read(sock, 0u);\n+                        let received_req_bytes = read(&sock, 0u);\n                         match received_req_bytes {\n                           result::Ok(data) => {\n                             log(debug, ~\"SERVER: got REQ str::from_bytes..\");\n@@ -1533,7 +1533,7 @@ mod test {\n                             server_ch.send(\n                                 str::from_bytes(data));\n                             log(debug, ~\"SERVER: before write\");\n-                            tcp_write_single(sock, str::to_bytes(resp));\n+                            tcp_write_single(&sock, str::to_bytes(resp));\n                             log(debug, ~\"SERVER: after write.. die\");\n                             core::comm::send(kill_ch, None);\n                           }\n@@ -1572,7 +1572,7 @@ mod test {\n         ret_val\n     }\n \n-    fn run_tcp_test_server_fail(server_ip: ~str, server_port: uint,\n+    fn run_tcp_test_server_fail(server_ip: &str, server_port: uint,\n                           iotask: IoTask) -> TcpListenErrData {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(move server_ip_addr, server_port, 128,\n@@ -1595,7 +1595,7 @@ mod test {\n         }\n     }\n \n-    fn run_tcp_test_client(server_ip: ~str, server_port: uint, resp: ~str,\n+    fn run_tcp_test_client(server_ip: &str, server_port: uint, resp: &str,\n                           client_ch: comm::Chan<~str>,\n                           iotask: IoTask) -> result::Result<~str,\n                                                     TcpConnectErrData> {\n@@ -1612,7 +1612,7 @@ mod test {\n         else {\n             let sock = result::unwrap(move connect_result);\n             let resp_bytes = str::to_bytes(resp);\n-            tcp_write_single(sock, resp_bytes);\n+            tcp_write_single(&sock, resp_bytes);\n             let read_result = sock.read(0u);\n             if read_result.is_err() {\n                 log(debug, ~\"CLIENT: failure to read\");\n@@ -1628,7 +1628,7 @@ mod test {\n         }\n     }\n \n-    fn tcp_write_single(sock: TcpSocket, val: ~[u8]) {\n+    fn tcp_write_single(sock: &TcpSocket, val: ~[u8]) {\n         let write_result_future = sock.write_future(val);\n         let write_result = write_result_future.get();\n         if result::is_err(write_result) {"}]}