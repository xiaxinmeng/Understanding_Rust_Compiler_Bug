{"sha": "e1555f9b5628af2b6c6ed344cad621399cb7684d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNTU1ZjliNTYyOGFmMmI2YzZlZDM0NGNhZDYyMTM5OWNiNzY4NGQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-19T08:08:47Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-19T08:13:56Z"}, "message": "std::rt: Document and cleanup the run function", "tree": {"sha": "95d9ebe30d60f0152f9be05a6b595ae82ec9369f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95d9ebe30d60f0152f9be05a6b595ae82ec9369f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1555f9b5628af2b6c6ed344cad621399cb7684d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1555f9b5628af2b6c6ed344cad621399cb7684d", "html_url": "https://github.com/rust-lang/rust/commit/e1555f9b5628af2b6c6ed344cad621399cb7684d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1555f9b5628af2b6c6ed344cad621399cb7684d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5722c953e5180ae3e086b4354f65ee8b5fb8d868", "url": "https://api.github.com/repos/rust-lang/rust/commits/5722c953e5180ae3e086b4354f65ee8b5fb8d868", "html_url": "https://github.com/rust-lang/rust/commit/5722c953e5180ae3e086b4354f65ee8b5fb8d868"}], "stats": {"total": 40, "additions": 30, "deletions": 10}, "files": [{"sha": "dd4c71eca745958946d7ac4269757e1f22cb21e6", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e1555f9b5628af2b6c6ed344cad621399cb7684d/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1555f9b5628af2b6c6ed344cad621399cb7684d/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=e1555f9b5628af2b6c6ed344cad621399cb7684d", "patch": "@@ -63,11 +63,11 @@ use cell::Cell;\n use clone::Clone;\n use container::Container;\n use from_str::FromStr;\n+use iter::Times;\n use iterator::IteratorUtil;\n use option::{Some, None};\n use os;\n use ptr::RawPtr;\n-use uint;\n use rt::sched::{Scheduler, Coroutine, Shutdown};\n use rt::sleeper_list::SleeperList;\n use rt::task::Task;\n@@ -150,7 +150,7 @@ pub mod local_ptr;\n /// Bindings to pthread/windows thread-local storage.\n pub mod thread_local_storage;\n \n-/// A concurrent data structure with which parent tasks wait on child tasks.\n+/// For waiting on child tasks.\n pub mod join_latch;\n \n pub mod metrics;\n@@ -188,43 +188,58 @@ pub fn init(crate_map: *u8) {\n     logging::init(crate_map);\n }\n \n+/// One-time runtime cleanup.\n pub fn cleanup() {\n     global_heap::cleanup();\n }\n \n+/// Execute the main function in a scheduler.\n+///\n+/// Configures the runtime according to the environment, by default\n+/// using a task scheduler with the same number of threads as cores.\n+/// Returns a process exit code.\n pub fn run(main: ~fn()) -> int {\n+\n     static DEFAULT_ERROR_CODE: int = 101;\n \n     let nthreads = match os::getenv(\"RUST_THREADS\") {\n         Some(nstr) => FromStr::from_str(nstr).get(),\n         None => unsafe { util::num_cpus() }\n     };\n \n+    // The shared list of sleeping schedulers. Schedulers wake each other\n+    // occassionally to do new work.\n     let sleepers = SleeperList::new();\n+    // The shared work queue. Temporary until work stealing is implemented.\n     let work_queue = WorkQueue::new();\n \n-    let mut handles = ~[];\n+    // The schedulers.\n     let mut scheds = ~[];\n+    // Handles to the schedulers. When the main task ends these will be\n+    // sent the Shutdown message to terminate the schedulers.\n+    let mut handles = ~[];\n \n-    for uint::range(0, nthreads) |_| {\n+    for nthreads.times {\n+        // Every scheduler is driven by an I/O event loop.\n         let loop_ = ~UvEventLoop::new();\n         let mut sched = ~Scheduler::new(loop_, work_queue.clone(), sleepers.clone());\n         let handle = sched.make_handle();\n \n-        handles.push(handle);\n         scheds.push(sched);\n+        handles.push(handle);\n     }\n \n+    // Create a shared cell for transmitting the process exit\n+    // code from the main task to this function.\n     let exit_code = UnsafeAtomicRcBox::new(AtomicInt::new(0));\n     let exit_code_clone = exit_code.clone();\n \n-    let main_cell = Cell::new(main);\n+    // When the main task exits, after all the tasks in the main\n+    // task tree, shut down the schedulers and set the exit code.\n     let handles = Cell::new(handles);\n-    let mut new_task = ~Task::new_root();\n     let on_exit: ~fn(bool) = |exit_success| {\n \n         let mut handles = handles.take();\n-        // Tell schedulers to exit\n         for handles.mut_iter().advance |handle| {\n             handle.send(Shutdown);\n         }\n@@ -234,13 +249,17 @@ pub fn run(main: ~fn()) -> int {\n             (*exit_code_clone.get()).store(exit_code, SeqCst);\n         }\n     };\n+\n+    // Create and enqueue the main task.\n+    let main_cell = Cell::new(main);\n+    let mut new_task = ~Task::new_root();\n     new_task.on_exit = Some(on_exit);\n     let main_task = ~Coroutine::with_task(&mut scheds[0].stack_pool,\n                                           new_task, main_cell.take());\n     scheds[0].enqueue_task(main_task);\n \n+    // Run each scheduler in a thread.\n     let mut threads = ~[];\n-\n     while !scheds.is_empty() {\n         let sched = scheds.pop();\n         let sched_cell = Cell::new(sched);\n@@ -253,8 +272,9 @@ pub fn run(main: ~fn()) -> int {\n     }\n \n     // Wait for schedulers\n-    let _threads = threads;\n+    { let _threads = threads; }\n \n+    // Return the exit code\n     unsafe {\n         (*exit_code.get()).load(SeqCst)\n     }"}]}