{"sha": "a15dc3d373681f1e3e0c2286fdc264c81a296efb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNWRjM2QzNzM2ODFmMWUzZTBjMjI4NmZkYzI2NGM4MWEyOTZlZmI=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-11-20T05:13:03Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-11-20T05:13:03Z"}, "message": "Merge pull request #628 from kyeah/single-line-fn\n\nSingle-line Functions", "tree": {"sha": "906eaf8a32d738bbe7fc4cb1b15089d0fefa686a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/906eaf8a32d738bbe7fc4cb1b15089d0fefa686a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a15dc3d373681f1e3e0c2286fdc264c81a296efb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a15dc3d373681f1e3e0c2286fdc264c81a296efb", "html_url": "https://github.com/rust-lang/rust/commit/a15dc3d373681f1e3e0c2286fdc264c81a296efb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a15dc3d373681f1e3e0c2286fdc264c81a296efb/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7eabbeb424461ceafd511ed738c954c71cf3b661", "url": "https://api.github.com/repos/rust-lang/rust/commits/7eabbeb424461ceafd511ed738c954c71cf3b661", "html_url": "https://github.com/rust-lang/rust/commit/7eabbeb424461ceafd511ed738c954c71cf3b661"}, {"sha": "2e9b6dfab49411fd9a043f03c5f74fb32a0ed272", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e9b6dfab49411fd9a043f03c5f74fb32a0ed272", "html_url": "https://github.com/rust-lang/rust/commit/2e9b6dfab49411fd9a043f03c5f74fb32a0ed272"}], "stats": {"total": 417, "additions": 311, "deletions": 106}, "files": [{"sha": "295c1076b5fcb7c87391b242dfd9d155f26bf84f", "filename": "src/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -269,6 +269,8 @@ create_config! {\n     newline_style: NewlineStyle, NewlineStyle::Unix, \"Unix or Windows line endings\";\n     fn_brace_style: BraceStyle, BraceStyle::SameLineWhere, \"Brace style for functions\";\n     item_brace_style: BraceStyle, BraceStyle::SameLineWhere, \"Brace style for structs and enums\";\n+    fn_empty_single_line: bool, true, \"Put empty-body functions on a single line\";\n+    fn_single_line: bool, false, \"Put single-expression functions on a single line\";\n     fn_return_indent: ReturnIndent, ReturnIndent::WithArgs,\n         \"Location of return type in function declaration\";\n     fn_args_paren_newline: bool, true, \"If function argument parenthesis goes on a newline\";"}, {"sha": "b494cb08fccabb57fc0fc7dcd4d6005b00d3ee5f", "filename": "src/expr.rs", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -17,7 +17,8 @@ use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic,\n             DefinitiveListTactic, definitive_tactic, ListItem, format_fn_args};\n use string::{StringFormat, rewrite_string};\n-use utils::{span_after, extra_offset, last_line_width, wrap_str, binary_search, first_line_width};\n+use utils::{span_after, extra_offset, last_line_width, wrap_str, binary_search, first_line_width,\n+            semicolon_for_stmt};\n use visitor::FmtVisitor;\n use config::{StructLitStyle, MultilineStyle};\n use comment::{FindUncommented, rewrite_comment, contains_comment};\n@@ -475,6 +476,33 @@ impl Rewrite for ast::Block {\n     }\n }\n \n+impl Rewrite for ast::Stmt {\n+    fn rewrite(&self, context: &RewriteContext, _width: usize, offset: Indent) -> Option<String> {\n+        match self.node {\n+            ast::Stmt_::StmtDecl(ref decl, _) => {\n+                if let ast::Decl_::DeclLocal(ref local) = decl.node {\n+                    local.rewrite(context, context.config.max_width, offset)\n+                } else {\n+                    None\n+                }\n+            }\n+            ast::Stmt_::StmtExpr(ref ex, _) | ast::Stmt_::StmtSemi(ref ex, _) => {\n+                let suffix = if semicolon_for_stmt(self) {\n+                    \";\"\n+                } else {\n+                    \"\"\n+                };\n+\n+                ex.rewrite(context,\n+                           context.config.max_width - offset.width() - suffix.len(),\n+                           offset)\n+                  .map(|s| s + suffix)\n+            }\n+            ast::Stmt_::StmtMac(..) => None,\n+        }\n+    }\n+}\n+\n // Abstraction over for, while and loop expressions\n struct Loop<'a> {\n     cond: Option<&'a ast::Expr>,\n@@ -677,15 +705,25 @@ fn single_line_if_else(context: &RewriteContext,\n     None\n }\n \n+fn block_contains_comment(block: &ast::Block, codemap: &CodeMap) -> bool {\n+    let snippet = codemap.span_to_snippet(block.span).unwrap();\n+    contains_comment(&snippet)\n+}\n+\n // Checks that a block contains no statements, an expression and no comments.\n-fn is_simple_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n-    if !block.stmts.is_empty() || block.expr.is_none() {\n-        return false;\n-    }\n+pub fn is_simple_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n+    block.stmts.is_empty() && block.expr.is_some() && !block_contains_comment(block, codemap)\n+}\n \n-    let snippet = codemap.span_to_snippet(block.span).unwrap();\n+/// Checks whether a block contains at most one statement or expression, and no comments.\n+pub fn is_simple_block_stmt(block: &ast::Block, codemap: &CodeMap) -> bool {\n+    (block.stmts.is_empty() || (block.stmts.len() == 1 && block.expr.is_none())) &&\n+    !block_contains_comment(block, codemap)\n+}\n \n-    !contains_comment(&snippet)\n+/// Checks whether a block contains no statements, expressions, or comments.\n+pub fn is_empty_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n+    block.stmts.is_empty() && block.expr.is_none() && !block_contains_comment(block, codemap)\n }\n \n // inter-match-arm-comment-rules:"}, {"sha": "c7cfc732fc1be2145a996f3f0c1eac265faef66b", "filename": "src/items.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -12,10 +12,10 @@\n \n use Indent;\n use utils::{format_mutability, format_visibility, contains_skip, span_after, end_typaram,\n-            wrap_str, last_line_width};\n+            wrap_str, last_line_width, semicolon_for_expr};\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic,\n             DefinitiveListTactic, definitive_tactic, format_item_list};\n-use expr::rewrite_assign_rhs;\n+use expr::{is_empty_block, is_simple_block_stmt, rewrite_assign_rhs};\n use comment::FindUncommented;\n use visitor::FmtVisitor;\n use rewrite::{Rewrite, RewriteContext};\n@@ -177,7 +177,8 @@ impl<'a> FmtVisitor<'a> {\n                       constness: ast::Constness,\n                       abi: abi::Abi,\n                       vis: ast::Visibility,\n-                      span: Span)\n+                      span: Span,\n+                      block: &ast::Block)\n                       -> Option<String> {\n         let mut newline_brace = self.newline_for_brace(&generics.where_clause);\n \n@@ -212,7 +213,7 @@ impl<'a> FmtVisitor<'a> {\n             result.push(' ');\n         }\n \n-        Some(result)\n+        self.single_line_fn(&result, block).or_else(|| Some(result))\n     }\n \n     pub fn rewrite_required_fn(&mut self,\n@@ -447,6 +448,53 @@ impl<'a> FmtVisitor<'a> {\n         Some((result, force_new_line_for_brace))\n     }\n \n+    fn single_line_fn(&self, fn_str: &str, block: &ast::Block) -> Option<String> {\n+\n+        if fn_str.contains('\\n') {\n+            return None;\n+        }\n+\n+        let codemap = self.get_context().codemap;\n+\n+        if self.config.fn_empty_single_line && is_empty_block(block, codemap) &&\n+           self.block_indent.width() + fn_str.len() + 2 <= self.config.max_width {\n+            return Some(format!(\"{}{{}}\", fn_str));\n+        }\n+\n+        if self.config.fn_single_line && is_simple_block_stmt(block, codemap) {\n+            let rewrite = {\n+                if let Some(ref e) = block.expr {\n+                    let suffix = if semicolon_for_expr(e) {\n+                        \";\"\n+                    } else {\n+                        \"\"\n+                    };\n+\n+                    e.rewrite(&self.get_context(),\n+                              self.config.max_width - self.block_indent.width(),\n+                              self.block_indent)\n+                     .map(|s| s + suffix)\n+                     .or_else(|| Some(self.snippet(e.span)))\n+                } else if let Some(ref stmt) = block.stmts.first() {\n+                    stmt.rewrite(&self.get_context(),\n+                                 self.config.max_width - self.block_indent.width(),\n+                                 self.block_indent)\n+                } else {\n+                    None\n+                }\n+            };\n+\n+            if let Some(res) = rewrite {\n+                let width = self.block_indent.width() + fn_str.len() + res.len() + 4;\n+                if !res.contains('\\n') && width <= self.config.max_width {\n+                    return Some(format!(\"{}{{ {} }}\", fn_str, res));\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn rewrite_args(&self,\n                     args: &[ast::Arg],\n                     explicit_self: Option<&ast::ExplicitSelf>,"}, {"sha": "3965fc93c57bbad2f2f8eefacb83fb9d2432ec5a", "filename": "src/utils.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -102,6 +102,33 @@ pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n            .hi\n }\n \n+#[inline]\n+pub fn semicolon_for_expr(expr: &ast::Expr) -> bool {\n+    match expr.node {\n+        ast::Expr_::ExprRet(..) |\n+        ast::Expr_::ExprAgain(..) |\n+        ast::Expr_::ExprBreak(..) => true,\n+        _ => false,\n+    }\n+}\n+\n+#[inline]\n+pub fn semicolon_for_stmt(stmt: &ast::Stmt) -> bool {\n+    match stmt.node {\n+        ast::Stmt_::StmtSemi(ref expr, _) => {\n+            match expr.node {\n+                ast::Expr_::ExprWhile(..) |\n+                ast::Expr_::ExprWhileLet(..) |\n+                ast::Expr_::ExprLoop(..) |\n+                ast::Expr_::ExprForLoop(..) => false,\n+                _ => true,\n+            }\n+        }\n+        ast::Stmt_::StmtExpr(..) => false,\n+        _ => true,\n+    }\n+}\n+\n #[inline]\n #[cfg(target_pointer_width=\"64\")]\n // Based on the trick layed out at"}, {"sha": "fa51d70a853fa52b310a5b385fe1e3ffb312c62a", "filename": "src/visitor.rs", "status": "modified", "additions": 24, "deletions": 48, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -38,28 +38,21 @@ impl<'a> FmtVisitor<'a> {\n     fn visit_stmt(&mut self, stmt: &ast::Stmt) {\n         match stmt.node {\n             ast::Stmt_::StmtDecl(ref decl, _) => {\n-                match decl.node {\n-                    ast::Decl_::DeclLocal(ref local) => {\n-                        let rewrite = {\n-                            let context = self.get_context();\n-                            local.rewrite(&context, self.config.max_width, self.block_indent)\n-                        };\n-                        self.push_rewrite(stmt.span, rewrite);\n-                    }\n-                    ast::Decl_::DeclItem(ref item) => self.visit_item(item),\n+                if let ast::Decl_::DeclItem(ref item) = decl.node {\n+                    self.visit_item(item);\n+                } else {\n+                    let rewrite = stmt.rewrite(&self.get_context(),\n+                                               self.config.max_width - self.block_indent.width(),\n+                                               self.block_indent);\n+\n+                    self.push_rewrite(stmt.span, rewrite);\n                 }\n             }\n-            ast::Stmt_::StmtExpr(ref ex, _) | ast::Stmt_::StmtSemi(ref ex, _) => {\n-                let suffix = if semicolon_for_stmt(stmt) {\n-                    \";\"\n-                } else {\n-                    \"\"\n-                };\n-                let rewrite = ex.rewrite(&self.get_context(),\n-                                         self.config.max_width - self.block_indent.width() -\n-                                         suffix.len(),\n-                                         self.block_indent)\n-                                .map(|s| s + suffix);\n+            ast::Stmt_::StmtExpr(..) | ast::Stmt_::StmtSemi(..) => {\n+                let rewrite = stmt.rewrite(&self.get_context(),\n+                                           self.config.max_width - self.block_indent.width(),\n+                                           self.block_indent);\n+\n                 self.push_rewrite(stmt.span, rewrite);\n             }\n             ast::Stmt_::StmtMac(ref mac, _macro_style) => {\n@@ -101,7 +94,7 @@ impl<'a> FmtVisitor<'a> {\n             self.buffer.push_str(&rewrite);\n             self.last_pos = e.span.hi;\n \n-            if semicolon_for_expr(e) {\n+            if utils::semicolon_for_expr(e) {\n                 self.buffer.push_str(\";\");\n             }\n         }\n@@ -144,7 +137,8 @@ impl<'a> FmtVisitor<'a> {\n                                 constness,\n                                 abi,\n                                 vis,\n-                                codemap::mk_sp(s.lo, b.span.lo))\n+                                codemap::mk_sp(s.lo, b.span.lo),\n+                                &b)\n             }\n             visit::FnKind::Method(ident, ref sig, vis) => {\n                 self.rewrite_fn(indent,\n@@ -156,14 +150,21 @@ impl<'a> FmtVisitor<'a> {\n                                 sig.constness,\n                                 sig.abi,\n                                 vis.unwrap_or(ast::Visibility::Inherited),\n-                                codemap::mk_sp(s.lo, b.span.lo))\n+                                codemap::mk_sp(s.lo, b.span.lo),\n+                                &b)\n             }\n             visit::FnKind::Closure => None,\n         };\n \n         if let Some(fn_str) = rewrite {\n             self.format_missing_with_indent(s.lo);\n             self.buffer.push_str(&fn_str);\n+            if let Some(c) = fn_str.chars().last() {\n+                if c == '}' {\n+                    self.last_pos = b.span.hi;\n+                    return;\n+                }\n+            }\n         } else {\n             self.format_missing(b.span.lo);\n         }\n@@ -501,31 +502,6 @@ impl<'a> FmtVisitor<'a> {\n     }\n }\n \n-fn semicolon_for_stmt(stmt: &ast::Stmt) -> bool {\n-    match stmt.node {\n-        ast::Stmt_::StmtSemi(ref expr, _) => {\n-            match expr.node {\n-                ast::Expr_::ExprWhile(..) |\n-                ast::Expr_::ExprWhileLet(..) |\n-                ast::Expr_::ExprLoop(..) |\n-                ast::Expr_::ExprForLoop(..) => false,\n-                _ => true,\n-            }\n-        }\n-        ast::Stmt_::StmtExpr(..) => false,\n-        _ => true,\n-    }\n-}\n-\n-fn semicolon_for_expr(expr: &ast::Expr) -> bool {\n-    match expr.node {\n-        ast::Expr_::ExprRet(..) |\n-        ast::Expr_::ExprAgain(..) |\n-        ast::Expr_::ExprBreak(..) => true,\n-        _ => false,\n-    }\n-}\n-\n impl<'a> Rewrite for [ast::Attribute] {\n     fn rewrite(&self, context: &RewriteContext, _: usize, offset: Indent) -> Option<String> {\n         let mut result = String::new();"}, {"sha": "a34371f55ad2924b89b2491cce22a5381f2c75dd", "filename": "tests/source/fn-single-line.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Fsource%2Ffn-single-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Fsource%2Ffn-single-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ffn-single-line.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -0,0 +1,76 @@\n+// rustfmt-fn_single_line: true\n+// Test single-line functions.\n+\n+fn foo_expr() {\n+    1\n+}\n+\n+fn foo_stmt() {\n+    foo();\n+}\n+\n+fn foo_decl_local()  {\n+    let z = 5;\n+   }\n+\n+fn    foo_decl_item(x: &mut i32) {\n+    x = 3;\n+}\n+\n+   fn empty()     {\n+\n+}\n+\n+fn foo_return() -> String {\n+    \"yay\"\n+}\n+\n+fn foo_where() -> T where T: Sync {\n+    let x = 2;\n+}\n+\n+fn fooblock() {\n+    {\n+        \"inner-block\"\n+    }\n+}\n+\n+fn fooblock2(x: i32) {\n+    let z = match x {\n+        _ => 2,\n+    };\n+}\n+\n+fn comment() {\n+    // this is a test comment\n+    1\n+}\n+\n+fn comment2() {\n+    // multi-line comment\n+    let z = 2;\n+    1\n+}\n+\n+fn only_comment() {\n+    // Keep this here\n+}\n+\n+fn aaaaaaaaaaaaaaaaa_looooooooooooooooooooooong_name() {\n+    let z = \"aaaaaaawwwwwwwwwwwwwwwwwwwwwwwwwwww\";\n+}\n+\n+fn lots_of_space                      ()                                                           {\n+                           1                 \n+}\n+\n+fn mac() -> Vec<i32> { vec![] }\n+\n+trait CoolTypes {\n+    fn dummy(&self) {\n+    }\n+}\n+\n+trait CoolerTypes { fn dummy(&self) { \n+}\n+}"}, {"sha": "9317a83706571ad4f12fb86a9afea19ac6cc8dd3", "filename": "tests/target/attrib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fattrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fattrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fattrib.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -13,8 +13,7 @@ impl Bar {\n     /// Blah blah blooo.\n     /// Blah blah blooo.\n     #[an_attribute]\n-    fn foo(&mut self) -> isize {\n-    }\n+    fn foo(&mut self) -> isize {}\n \n     /// Blah blah bing.\n     /// Blah blah bing.\n@@ -28,8 +27,7 @@ impl Bar {\n     }\n \n     #[another_attribute]\n-    fn f3(self) -> Dog {\n-    }\n+    fn f3(self) -> Dog {}\n \n     /// Blah blah bing.\n     #[attrib1]\n@@ -38,6 +36,5 @@ impl Bar {\n     // Another comment that needs rewrite because it's tooooooooooooooooooooooooooooooo\n     // loooooooooooong.\n     /// Blah blah bing.\n-    fn f4(self) -> Cat {\n-    }\n+    fn f4(self) -> Cat {}\n }"}, {"sha": "2d90d83edb69b65d0e323d3093e4c1951bc697b8", "filename": "tests/target/comment.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -32,8 +32,7 @@ fn test() {\n }\n \n /// test123\n-fn doc_comment() {\n-}\n+fn doc_comment() {}\n \n fn chains() {\n     foo.bar(|| {"}, {"sha": "fa607e131eaa5cdb0e5d9e0205cfad01f3045e61", "filename": "tests/target/comments-fn.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fcomments-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fcomments-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomments-fn.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -16,8 +16,6 @@ fn foo<F, G>(a: aaaaaaaaaaaaa, // A comment\n \n }\n \n-fn bar<F /* comment on F */, G /* comment on G */>() {\n-}\n+fn bar<F /* comment on F */, G /* comment on G */>() {}\n \n-fn baz() -> Baz /* Comment after return type */ {\n-}\n+fn baz() -> Baz /* Comment after return type */ {}"}, {"sha": "9db1c8831b60c365c145c7812d8883e1491acf76", "filename": "tests/target/fn-simple.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Ffn-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Ffn-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn-simple.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -28,15 +28,13 @@ fn generic<T>(arg: T) -> &SomeType\n     arg(a, b, c, d, e)\n }\n \n-fn foo() -> ! {\n-}\n+fn foo() -> ! {}\n \n pub fn http_fetch_async(listener: Box<AsyncCORSResponseListener + Send>,\n                         script_chan: Box<ScriptChan + Send>) {\n }\n \n-fn some_func<T: Box<Trait + Bound>>(val: T) {\n-}\n+fn some_func<T: Box<Trait + Bound>>(val: T) {}\n \n fn zzzzzzzzzzzzzzzzzzzz<Type, NodeType>(selff: Type,\n                                         mut handle: node::Handle<IdRef<'id, Node<K, V>>,"}, {"sha": "674ce1c89f9b0d164a39648004d37f4c3bc7ae70", "filename": "tests/target/fn-single-line.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Ffn-single-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Ffn-single-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn-single-line.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -0,0 +1,63 @@\n+// rustfmt-fn_single_line: true\n+// Test single-line functions.\n+\n+fn foo_expr() { 1 }\n+\n+fn foo_stmt() { foo(); }\n+\n+fn foo_decl_local() { let z = 5; }\n+\n+fn foo_decl_item(x: &mut i32) { x = 3; }\n+\n+fn empty() {}\n+\n+fn foo_return() -> String { \"yay\" }\n+\n+fn foo_where() -> T\n+    where T: Sync\n+{\n+    let x = 2;\n+}\n+\n+fn fooblock() {\n+    {\n+        \"inner-block\"\n+    }\n+}\n+\n+fn fooblock2(x: i32) {\n+    let z = match x {\n+        _ => 2,\n+    };\n+}\n+\n+fn comment() {\n+    // this is a test comment\n+    1\n+}\n+\n+fn comment2() {\n+    // multi-line comment\n+    let z = 2;\n+    1\n+}\n+\n+fn only_comment() {\n+    // Keep this here\n+}\n+\n+fn aaaaaaaaaaaaaaaaa_looooooooooooooooooooooong_name() {\n+    let z = \"aaaaaaawwwwwwwwwwwwwwwwwwwwwwwwwwww\";\n+}\n+\n+fn lots_of_space() { 1 }\n+\n+fn mac() -> Vec<i32> { vec![] }\n+\n+trait CoolTypes {\n+    fn dummy(&self) {}\n+}\n+\n+trait CoolerTypes {\n+    fn dummy(&self) {}\n+}"}, {"sha": "0ae9fd7ef1fc871aa5166a9c25fbda2137acd2fd", "filename": "tests/target/fn.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Ffn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Ffn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -1,8 +1,6 @@\n // Tests different fns\n \n-fn foo(a: AAAA, b: BBB, c: CCC) -> RetType {\n-\n-}\n+fn foo(a: AAAA, b: BBB, c: CCC) -> RetType {}\n \n fn foo(a: AAAA, b: BBB /* some, weird, inline comment */, c: CCC) -> RetType\n     where T: Blah\n@@ -34,20 +32,17 @@ fn foo<U, T>(a: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n \n }\n \n-fn foo<U: Fn(A) -> B /* paren inside generics */>() {\n-}\n+fn foo<U: Fn(A) -> B /* paren inside generics */>() {}\n \n impl Foo {\n     fn with_no_errors<T, F>(&mut self, f: F) -> T\n         where F: FnOnce(&mut Resolver) -> T\n     {\n     }\n \n-    fn foo(mut self, mut bar: u32) {\n-    }\n+    fn foo(mut self, mut bar: u32) {}\n \n-    fn bar(self, mut bazz: u32) {\n-    }\n+    fn bar(self, mut bazz: u32) {}\n }\n \n pub fn render<'a,\n@@ -75,12 +70,9 @@ impl Foo {\n     }\n }\n \n-fn homura<T: Deref<Target = i32>>(_: T) {\n-\n-}\n+fn homura<T: Deref<Target = i32>>(_: T) {}\n \n-fn issue377() -> (Box<CompositorProxy + Send>, Box<CompositorReceiver>) {\n-}\n+fn issue377() -> (Box<CompositorProxy + Send>, Box<CompositorReceiver>) {}\n \n fn main() {\n     let _ = function(move || 5);"}, {"sha": "7b371409fba96c33557ba633d6bb99d808f1c8b7", "filename": "tests/target/multiple.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmultiple.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -26,9 +26,7 @@ mod other;\n // sfdgfffffffffffffffffffffffffffffffffffffffffffffffffffffff\n // ffffffffffffffffffffffffffffffffffffffffff\n \n-fn foo(a: isize, b: u32 /* blah blah */, c: f64) {\n-\n-}\n+fn foo(a: isize, b: u32 /* blah blah */, c: f64) {}\n \n fn foo() -> Box<Write + 'static>\n     where 'a: 'b,\n@@ -77,8 +75,7 @@ impl Bar {\n     }\n \n     #[an_attribute]\n-    fn f3(self) -> Dog {\n-    }\n+    fn f3(self) -> Dog {}\n }\n \n /// The `nodes` and `edges` method each return instantiations of\n@@ -118,8 +115,7 @@ pub struct Foo<'a, Y: Baz>\n     f: SomeType, // Comment beside a field\n }\n \n-fn foo(ann: &'a (PpAnn + 'a)) {\n-}\n+fn foo(ann: &'a (PpAnn + 'a)) {}\n \n fn main() {\n     for i in 0i32..4 {"}, {"sha": "7db4572e777c0010537f78b12a52687a36032383", "filename": "tests/target/nestedmod/mod2c.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fnestedmod%2Fmod2c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fnestedmod%2Fmod2c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fnestedmod%2Fmod2c.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -1,4 +1,3 @@\n // A standard mod\n \n-fn a() {\n-}\n+fn a() {}"}, {"sha": "ae09d8ddac0d14b172fa37ecf5cf444f1558a2f5", "filename": "tests/target/nestedmod/mymod1/mod3a.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fnestedmod%2Fmymod1%2Fmod3a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fnestedmod%2Fmymod1%2Fmod3a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fnestedmod%2Fmymod1%2Fmod3a.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -1,3 +1,2 @@\n // Another mod\n-fn a() {\n-}\n+fn a() {}"}, {"sha": "120b17145e3a0879c0bb973e8d3a4fffb4f788e1", "filename": "tests/target/nestedmod/submod2/a.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fnestedmod%2Fsubmod2%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fnestedmod%2Fsubmod2%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fnestedmod%2Fsubmod2%2Fa.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -3,5 +3,4 @@\n \n use c::a;\n \n-fn foo() {\n-}\n+fn foo() {}"}, {"sha": "f328e4d9d04c31d0d70d16d21a07d1613be9d577", "filename": "tests/target/no_new_line_beginning.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fno_new_line_beginning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fno_new_line_beginning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fno_new_line_beginning.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -1,2 +1 @@\n-fn main() {\n-}\n+fn main() {}"}, {"sha": "f1b142b3a5c46096e6d8d2096e17190cdd0e5ae8", "filename": "tests/target/paths.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15dc3d373681f1e3e0c2286fdc264c81a296efb/tests%2Ftarget%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpaths.rs?ref=a15dc3d373681f1e3e0c2286fdc264c81a296efb", "patch": "@@ -19,5 +19,4 @@ fn main() {\n     let x: Foo<A>;\n }\n \n-fn op(foo: Bar, key: &[u8], upd: Fn(Option<&memcache::Item>, Baz) -> Result) -> MapResult {\n-}\n+fn op(foo: Bar, key: &[u8], upd: Fn(Option<&memcache::Item>, Baz) -> Result) -> MapResult {}"}]}