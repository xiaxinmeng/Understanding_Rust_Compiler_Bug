{"sha": "18229bb1ad197fcc28ed2ff399c738bb500a3f0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MjI5YmIxYWQxOTdmY2MyOGVkMmZmMzk5YzczOGJiNTAwYTNmMGQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-03-09T14:41:01Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-03-12T07:25:03Z"}, "message": "syntax: Better recovery for `$ty::AssocItem` and `ty!()::AssocItem`", "tree": {"sha": "240fd10cb3393a2c2def8e9661cd263fd1dc4636", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/240fd10cb3393a2c2def8e9661cd263fd1dc4636"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18229bb1ad197fcc28ed2ff399c738bb500a3f0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18229bb1ad197fcc28ed2ff399c738bb500a3f0d", "html_url": "https://github.com/rust-lang/rust/commit/18229bb1ad197fcc28ed2ff399c738bb500a3f0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7486b9c208f7e1c4aa1e36961927327bd793e952", "url": "https://api.github.com/repos/rust-lang/rust/commits/7486b9c208f7e1c4aa1e36961927327bd793e952", "html_url": "https://github.com/rust-lang/rust/commit/7486b9c208f7e1c4aa1e36961927327bd793e952"}], "stats": {"total": 275, "additions": 198, "deletions": 77}, "files": [{"sha": "ba948d41c7ad7e6f42ad477a89b875aea5308fd2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 63, "deletions": 73, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=18229bb1ad197fcc28ed2ff399c738bb500a3f0d", "patch": "@@ -154,6 +154,21 @@ macro_rules! maybe_whole {\n     };\n }\n \n+/// If the next tokens are ill-formed `$ty::` recover them as `<$ty>::`.\n+macro_rules! maybe_recover_from_interpolated_ty_qpath {\n+    ($self: expr, $allow_qpath_recovery: expr) => {\n+        if $allow_qpath_recovery && $self.look_ahead(1, |t| t == &token::ModSep) {\n+            if let token::Interpolated(nt) = &$self.token {\n+                if let token::NtTy(ty) = &**nt {\n+                    let ty = ty.clone();\n+                    $self.bump();\n+                    return $self.maybe_recover_from_bad_qpath_stage_2($self.prev_span, ty);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn maybe_append(mut lhs: Vec<Attribute>, mut rhs: Option<Vec<Attribute>>) -> Vec<Attribute> {\n     if let Some(ref mut rhs) = rhs {\n         lhs.append(rhs);\n@@ -172,48 +187,38 @@ enum PrevTokenKind {\n     Other,\n }\n \n-trait RecoverQPath: Sized {\n+trait RecoverQPath: Sized + 'static {\n     const PATH_STYLE: PathStyle = PathStyle::Expr;\n     fn to_ty(&self) -> Option<P<Ty>>;\n-    fn to_recovered(&self, qself: Option<QSelf>, path: ast::Path) -> Self;\n-    fn to_string(&self) -> String;\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self;\n }\n \n impl RecoverQPath for Ty {\n     const PATH_STYLE: PathStyle = PathStyle::Type;\n     fn to_ty(&self) -> Option<P<Ty>> {\n         Some(P(self.clone()))\n     }\n-    fn to_recovered(&self, qself: Option<QSelf>, path: ast::Path) -> Self {\n-        Self { span: path.span, node: TyKind::Path(qself, path), id: self.id }\n-    }\n-    fn to_string(&self) -> String {\n-        pprust::ty_to_string(self)\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n+        Self { span: path.span, node: TyKind::Path(qself, path), id: ast::DUMMY_NODE_ID }\n     }\n }\n \n impl RecoverQPath for Pat {\n     fn to_ty(&self) -> Option<P<Ty>> {\n         self.to_ty()\n     }\n-    fn to_recovered(&self, qself: Option<QSelf>, path: ast::Path) -> Self {\n-        Self { span: path.span, node: PatKind::Path(qself, path), id: self.id }\n-    }\n-    fn to_string(&self) -> String {\n-        pprust::pat_to_string(self)\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n+        Self { span: path.span, node: PatKind::Path(qself, path), id: ast::DUMMY_NODE_ID }\n     }\n }\n \n impl RecoverQPath for Expr {\n     fn to_ty(&self) -> Option<P<Ty>> {\n         self.to_ty()\n     }\n-    fn to_recovered(&self, qself: Option<QSelf>, path: ast::Path) -> Self {\n+    fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n         Self { span: path.span, node: ExprKind::Path(qself, path),\n-               id: self.id, attrs: self.attrs.clone() }\n-    }\n-    fn to_string(&self) -> String {\n-        pprust::expr_to_string(self)\n+               attrs: ThinVec::new(), id: ast::DUMMY_NODE_ID }\n     }\n }\n \n@@ -1651,6 +1656,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_ty_common(&mut self, allow_plus: bool, allow_qpath_recovery: bool,\n                        allow_c_variadic: bool) -> PResult<'a, P<Ty>> {\n+        maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n         maybe_whole!(self, NtTy, |x| x);\n \n         let lo = self.span;\n@@ -1802,14 +1808,12 @@ impl<'a> Parser<'a> {\n         };\n \n         let span = lo.to(self.prev_span);\n-        let ty = Ty { node, span, id: ast::DUMMY_NODE_ID };\n+        let ty = P(Ty { node, span, id: ast::DUMMY_NODE_ID });\n \n         // Try to recover from use of `+` with incorrect priority.\n         self.maybe_report_ambiguous_plus(allow_plus, impl_dyn_multi, &ty);\n         self.maybe_recover_from_bad_type_plus(allow_plus, &ty)?;\n-        let ty = self.maybe_recover_from_bad_qpath(ty, allow_qpath_recovery)?;\n-\n-        Ok(P(ty))\n+        self.maybe_recover_from_bad_qpath(ty, allow_qpath_recovery)\n     }\n \n     fn parse_remaining_bounds(&mut self, generic_params: Vec<GenericParam>, path: ast::Path,\n@@ -1881,35 +1885,35 @@ impl<'a> Parser<'a> {\n     }\n \n     // Try to recover from associated item paths like `[T]::AssocItem`/`(T, U)::AssocItem`.\n-    fn maybe_recover_from_bad_qpath<T: RecoverQPath>(&mut self, base: T, allow_recovery: bool)\n-                                                     -> PResult<'a, T> {\n+    fn maybe_recover_from_bad_qpath<T: RecoverQPath>(&mut self, base: P<T>, allow_recovery: bool)\n+                                                     -> PResult<'a, P<T>> {\n         // Do not add `::` to expected tokens.\n-        if !allow_recovery || self.token != token::ModSep {\n-            return Ok(base);\n+        if allow_recovery && self.token == token::ModSep {\n+            if let Some(ty) = base.to_ty() {\n+                return self.maybe_recover_from_bad_qpath_stage_2(ty.span, ty);\n+            }\n         }\n-        let ty = match base.to_ty() {\n-            Some(ty) => ty,\n-            None => return Ok(base),\n-        };\n+        Ok(base)\n+    }\n \n-        self.bump(); // `::`\n-        let mut segments = Vec::new();\n-        self.parse_path_segments(&mut segments, T::PATH_STYLE, true)?;\n+    fn maybe_recover_from_bad_qpath_stage_2<T: RecoverQPath>(&mut self, ty_span: Span, ty: P<Ty>)\n+                                                             -> PResult<'a, P<T>> {\n+        self.expect(&token::ModSep)?;\n \n-        let span = ty.span.to(self.prev_span);\n-        let path_span = span.to(span); // use an empty path since `position` == 0\n-        let recovered = base.to_recovered(\n-            Some(QSelf { ty, path_span, position: 0 }),\n-            ast::Path { segments, span },\n-        );\n+        let mut path = ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP };\n+        self.parse_path_segments(&mut path.segments, T::PATH_STYLE, true)?;\n+        path.span = ty_span.to(self.prev_span);\n \n+        let ty_str = self.sess.source_map().span_to_snippet(ty_span)\n+            .unwrap_or_else(|_| pprust::ty_to_string(&ty));\n         self.diagnostic()\n-            .struct_span_err(span, \"missing angle brackets in associated item path\")\n+            .struct_span_err(path.span, \"missing angle brackets in associated item path\")\n             .span_suggestion( // this is a best-effort recovery\n-                span, \"try\", recovered.to_string(), Applicability::MaybeIncorrect\n+                path.span, \"try\", format!(\"<{}>::{}\", ty_str, path), Applicability::MaybeIncorrect\n             ).emit();\n \n-        Ok(recovered)\n+        let path_span = path.span.to(path.span); // use an empty path since `position` == 0\n+        Ok(P(T::recovered(Some(QSelf { ty, path_span, position: 0 }), path)))\n     }\n \n     fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n@@ -2574,15 +2578,6 @@ impl<'a> Parser<'a> {\n         ExprKind::AssignOp(binop, lhs, rhs)\n     }\n \n-    pub fn mk_mac_expr(&mut self, span: Span, m: Mac_, attrs: ThinVec<Attribute>) -> P<Expr> {\n-        P(Expr {\n-            id: ast::DUMMY_NODE_ID,\n-            node: ExprKind::Mac(source_map::Spanned {node: m, span: span}),\n-            span,\n-            attrs,\n-        })\n-    }\n-\n     fn expect_delimited_token_tree(&mut self) -> PResult<'a, (MacDelimiter, TokenStream)> {\n         let delim = match self.token {\n             token::OpenDelim(delim) => delim,\n@@ -2612,6 +2607,7 @@ impl<'a> Parser<'a> {\n     /// N.B., this does not parse outer attributes, and is private because it only works\n     /// correctly if called from `parse_dot_or_call_expr()`.\n     fn parse_bottom_expr(&mut self) -> PResult<'a, P<Expr>> {\n+        maybe_recover_from_interpolated_ty_qpath!(self, true);\n         maybe_whole_expr!(self);\n \n         // Outer attributes are already parsed and will be\n@@ -2826,29 +2822,23 @@ impl<'a> Parser<'a> {\n                     db.note(\"variable declaration using `let` is a statement\");\n                     return Err(db);\n                 } else if self.token.is_path_start() {\n-                    let pth = self.parse_path(PathStyle::Expr)?;\n+                    let path = self.parse_path(PathStyle::Expr)?;\n \n                     // `!`, as an operator, is prefix, so we know this isn't that\n                     if self.eat(&token::Not) {\n                         // MACRO INVOCATION expression\n                         let (delim, tts) = self.expect_delimited_token_tree()?;\n-                        let hi = self.prev_span;\n-                        let node = Mac_ { path: pth, tts, delim };\n-                        return Ok(self.mk_mac_expr(lo.to(hi), node, attrs))\n-                    }\n-                    if self.check(&token::OpenDelim(token::Brace)) {\n+                        hi = self.prev_span;\n+                        ex = ExprKind::Mac(respan(lo.to(hi), Mac_ { path, tts, delim }));\n+                    } else if self.check(&token::OpenDelim(token::Brace)) &&\n+                              !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL) {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n-                        let prohibited = self.restrictions.contains(\n-                            Restrictions::NO_STRUCT_LITERAL\n-                        );\n-                        if !prohibited {\n-                            return self.parse_struct_expr(lo, pth, attrs);\n-                        }\n+                        return self.parse_struct_expr(lo, path, attrs);\n+                    } else {\n+                        hi = path.span;\n+                        ex = ExprKind::Path(None, path);\n                     }\n-\n-                    hi = pth.span;\n-                    ex = ExprKind::Path(None, pth);\n                 } else {\n                     if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n                         // Don't complain about bare semicolons after unclosed braces\n@@ -2883,10 +2873,8 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let expr = Expr { node: ex, span: lo.to(hi), id: ast::DUMMY_NODE_ID, attrs };\n-        let expr = self.maybe_recover_from_bad_qpath(expr, true)?;\n-\n-        return Ok(P(expr));\n+        let expr = self.mk_expr(lo.to(hi), ex, attrs);\n+        self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n     fn parse_struct_expr(&mut self, lo: Span, pth: ast::Path, mut attrs: ThinVec<Attribute>)\n@@ -4581,6 +4569,7 @@ impl<'a> Parser<'a> {\n         allow_range_pat: bool,\n         expected: Option<&'static str>,\n     ) -> PResult<'a, P<Pat>> {\n+        maybe_recover_from_interpolated_ty_qpath!(self, true);\n         maybe_whole!(self, NtPat, |x| x);\n \n         let lo = self.span;\n@@ -4756,7 +4745,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let pat = Pat { node: pat, span: lo.to(self.prev_span), id: ast::DUMMY_NODE_ID };\n+        let pat = P(Pat { node: pat, span: lo.to(self.prev_span), id: ast::DUMMY_NODE_ID });\n         let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n \n         if !allow_range_pat {\n@@ -4782,7 +4771,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        Ok(P(pat))\n+        Ok(pat)\n     }\n \n     /// Parses `ident` or `ident @ pat`.\n@@ -5250,7 +5239,8 @@ impl<'a> Parser<'a> {\n                     self.warn_missing_semicolon();\n                     StmtKind::Mac(P((mac, style, attrs.into())))\n                 } else {\n-                    let e = self.mk_mac_expr(lo.to(hi), mac.node, ThinVec::new());\n+                    let e = self.mk_expr(mac.span, ExprKind::Mac(mac), ThinVec::new());\n+                    let e = self.maybe_recover_from_bad_qpath(e, true)?;\n                     let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n                     let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n                     StmtKind::Expr(e)"}, {"sha": "1d584757f2faf5ecd3f5ffc1a9ffae9fe8a1655a", "filename": "src/test/ui/did_you_mean/bad-assoc-expr.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.rs?ref=18229bb1ad197fcc28ed2ff399c738bb500a3f0d", "patch": "@@ -18,3 +18,19 @@ fn main() {\n     10 + (u8)::clone(&0);\n     //~^ ERROR missing angle brackets in associated item path\n }\n+\n+macro_rules! expr {\n+    ($ty: ty) => ($ty::clone(&0))\n+    //~^ ERROR missing angle brackets in associated item path\n+}\n+macro_rules! ty {\n+    () => (u8)\n+}\n+\n+fn check_macros() {\n+    expr!(u8);\n+    let _ = ty!()::clone(&0);\n+    //~^ ERROR missing angle brackets in associated item path\n+    ty!()::clone(&0);\n+    //~^ ERROR missing angle brackets in associated item path\n+}"}, {"sha": "2024564b911f635c9b8936e3ba7e5940b3e03ce0", "filename": "src/test/ui/did_you_mean/bad-assoc-expr.stderr", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.stderr?ref=18229bb1ad197fcc28ed2ff399c738bb500a3f0d", "patch": "@@ -34,5 +34,26 @@ error: missing angle brackets in associated item path\n LL |     10 + (u8)::clone(&0);\n    |          ^^^^^^^^^^^ help: try: `<(u8)>::clone`\n \n-error: aborting due to 6 previous errors\n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-expr.rs:32:13\n+   |\n+LL |     let _ = ty!()::clone(&0);\n+   |             ^^^^^^^^^^^^ help: try: `<ty!()>::clone`\n+\n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-expr.rs:34:5\n+   |\n+LL |     ty!()::clone(&0);\n+   |     ^^^^^^^^^^^^ help: try: `<ty!()>::clone`\n+\n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-expr.rs:23:19\n+   |\n+LL |     ($ty: ty) => ($ty::clone(&0))\n+   |                   ^^^^^^^^^^ help: try: `<$ty>::clone`\n+...\n+LL |     expr!(u8);\n+   |     ---------- in this macro invocation\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "7e7ba59dca8169f73af3637f5467bb2c94bd53ca", "filename": "src/test/ui/did_you_mean/bad-assoc-pat.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.rs?ref=18229bb1ad197fcc28ed2ff399c738bb500a3f0d", "patch": "@@ -16,3 +16,21 @@ fn main() {\n         //~| ERROR no associated item named `AssocItem` found for type `(u8,)` in the current scope\n     }\n }\n+\n+macro_rules! pat {\n+    ($ty: ty) => ($ty::AssocItem)\n+    //~^ ERROR missing angle brackets in associated item path\n+    //~| ERROR no associated item named `AssocItem` found for type `u8` in the current scope\n+}\n+macro_rules! ty {\n+    () => (u8)\n+}\n+\n+fn check_macros() {\n+    match 0u8 {\n+        pat!(u8) => {}\n+        ty!()::AssocItem => {}\n+        //~^ ERROR missing angle brackets in associated item path\n+        //~| ERROR no associated item named `AssocItem` found for type `u8` in the current scope\n+    }\n+}"}, {"sha": "e620e7b43565f8d3896c37c5db3c41e6f33b12f8", "filename": "src/test/ui/did_you_mean/bad-assoc-pat.stderr", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.stderr?ref=18229bb1ad197fcc28ed2ff399c738bb500a3f0d", "patch": "@@ -22,6 +22,21 @@ error: missing angle brackets in associated item path\n LL |         &(u8,)::AssocItem => {}\n    |          ^^^^^^^^^^^^^^^^ help: try: `<(u8,)>::AssocItem`\n \n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-pat.rs:32:9\n+   |\n+LL |         ty!()::AssocItem => {}\n+   |         ^^^^^^^^^^^^^^^^ help: try: `<ty!()>::AssocItem`\n+\n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-pat.rs:21:19\n+   |\n+LL |     ($ty: ty) => ($ty::AssocItem)\n+   |                   ^^^^^^^^^^^^^^ help: try: `<$ty>::AssocItem`\n+...\n+LL |         pat!(u8) => {}\n+   |         -------- in this macro invocation\n+\n error[E0599]: no associated item named `AssocItem` found for type `[u8]` in the current scope\n   --> $DIR/bad-assoc-pat.rs:3:15\n    |\n@@ -54,6 +69,25 @@ LL |         &(u8,)::AssocItem => {}\n    |          |\n    |          associated item not found in `(u8,)`\n \n-error: aborting due to 8 previous errors\n+error[E0599]: no associated item named `AssocItem` found for type `u8` in the current scope\n+  --> $DIR/bad-assoc-pat.rs:21:24\n+   |\n+LL |     ($ty: ty) => ($ty::AssocItem)\n+   |                   -----^^^^^^^^^\n+   |                   |\n+   |                   associated item not found in `u8`\n+...\n+LL |         pat!(u8) => {}\n+   |         -------- in this macro invocation\n+\n+error[E0599]: no associated item named `AssocItem` found for type `u8` in the current scope\n+  --> $DIR/bad-assoc-pat.rs:32:16\n+   |\n+LL |         ty!()::AssocItem => {}\n+   |         -------^^^^^^^^^\n+   |         |\n+   |         associated item not found in `u8`\n+\n+error: aborting due to 12 previous errors\n \n For more information about this error, try `rustc --explain E0599`."}, {"sha": "85e36f887be087d94c293a9f6831617fe4d672b6", "filename": "src/test/ui/did_you_mean/bad-assoc-ty.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.rs?ref=18229bb1ad197fcc28ed2ff399c738bb500a3f0d", "patch": "@@ -33,4 +33,16 @@ type G = 'static + (Send)::AssocTy;\n type H = Fn(u8) -> (u8)::Output;\n //~^ ERROR ambiguous associated type\n \n+macro_rules! ty {\n+    ($ty: ty) => ($ty::AssocTy);\n+    //~^ ERROR missing angle brackets in associated item path\n+    //~| ERROR ambiguous associated type\n+    () => (u8);\n+}\n+\n+type J = ty!(u8);\n+type I = ty!()::AssocTy;\n+//~^ ERROR missing angle brackets in associated item path\n+//~| ERROR ambiguous associated type\n+\n fn main() {}"}, {"sha": "7e7f18f2d6e43bd489ad7109930393f121b78eb1", "filename": "src/test/ui/did_you_mean/bad-assoc-ty.stderr", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18229bb1ad197fcc28ed2ff399c738bb500a3f0d/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr?ref=18229bb1ad197fcc28ed2ff399c738bb500a3f0d", "patch": "@@ -38,7 +38,22 @@ error: missing angle brackets in associated item path\n   --> $DIR/bad-assoc-ty.rs:27:10\n    |\n LL | type G = 'static + (Send)::AssocTy;\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `<'static + Send>::AssocTy`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `<'static + (Send)>::AssocTy`\n+\n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-ty.rs:44:10\n+   |\n+LL | type I = ty!()::AssocTy;\n+   |          ^^^^^^^^^^^^^^ help: try: `<ty!()>::AssocTy`\n+\n+error: missing angle brackets in associated item path\n+  --> $DIR/bad-assoc-ty.rs:37:19\n+   |\n+LL |     ($ty: ty) => ($ty::AssocTy);\n+   |                   ^^^^^^^^^^^^ help: try: `<$ty>::AssocTy`\n+...\n+LL | type J = ty!(u8);\n+   |          ------- in this macro invocation\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:1:10\n@@ -88,7 +103,22 @@ error[E0223]: ambiguous associated type\n LL | type H = Fn(u8) -> (u8)::Output;\n    |          ^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<(dyn std::ops::Fn(u8) -> u8 + 'static) as Trait>::Output`\n \n-error: aborting due to 15 previous errors\n+error[E0223]: ambiguous associated type\n+  --> $DIR/bad-assoc-ty.rs:37:19\n+   |\n+LL |     ($ty: ty) => ($ty::AssocTy);\n+   |                   ^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+...\n+LL | type J = ty!(u8);\n+   |          ------- in this macro invocation\n+\n+error[E0223]: ambiguous associated type\n+  --> $DIR/bad-assoc-ty.rs:44:10\n+   |\n+LL | type I = ty!()::AssocTy;\n+   |          ^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+\n+error: aborting due to 19 previous errors\n \n Some errors occurred: E0121, E0223.\n For more information about an error, try `rustc --explain E0121`."}]}