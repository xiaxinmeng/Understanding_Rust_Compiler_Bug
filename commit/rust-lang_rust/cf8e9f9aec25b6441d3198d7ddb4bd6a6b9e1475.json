{"sha": "cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmOGU5ZjlhZWMyNWI2NDQxZDMxOThkN2RkYjRiZDZhNmI5ZTE0NzU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-05-24T17:58:55Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-05-26T14:26:03Z"}, "message": "make the memcpy/memmove intrinsics higher-level\n\nThis allows them to make use of the type's alignment, instead of being\npessimistic and assuming it is only 1.", "tree": {"sha": "d6e7e72c11ed6ab0c10a8210596af1d530069007", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6e7e72c11ed6ab0c10a8210596af1d530069007"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475", "html_url": "https://github.com/rust-lang/rust/commit/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f254d119eab514c91fbd6590fba821ec7a0bfd7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f254d119eab514c91fbd6590fba821ec7a0bfd7f", "html_url": "https://github.com/rust-lang/rust/commit/f254d119eab514c91fbd6590fba821ec7a0bfd7f"}], "stats": {"total": 175, "additions": 111, "deletions": 64}, "files": [{"sha": "6f420fc44cac562190d26e20b23a0df96e62612e", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475", "patch": "@@ -846,44 +846,56 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             Store(bcx, morestack_addr, fcx.llretptr.get());\n         }\n         ~\"memcpy32\" => {\n-            let dst_ptr = get_param(decl, first_real_arg);\n-            let src_ptr = get_param(decl, first_real_arg + 1);\n-            let size = get_param(decl, first_real_arg + 2);\n-            let align = C_i32(1);\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+            let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n+\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(\n-                &~\"llvm.memcpy.p0i8.p0i8.i32\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, size, align, volatile]);\n+            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memcpy.p0i8.p0i8.i32\");\n+            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n         ~\"memcpy64\" => {\n-            let dst_ptr = get_param(decl, first_real_arg);\n-            let src_ptr = get_param(decl, first_real_arg + 1);\n-            let size = get_param(decl, first_real_arg + 2);\n-            let align = C_i32(1);\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+            let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n+\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(\n-                &~\"llvm.memcpy.p0i8.p0i8.i64\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, size, align, volatile]);\n+            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memcpy.p0i8.p0i8.i64\");\n+            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n         ~\"memmove32\" => {\n-            let dst_ptr = get_param(decl, first_real_arg);\n-            let src_ptr = get_param(decl, first_real_arg + 1);\n-            let size = get_param(decl, first_real_arg + 2);\n-            let align = C_i32(1);\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+            let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n+\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(\n-                &~\"llvm.memmove.p0i8.p0i8.i32\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, size, align, volatile]);\n+            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memmove.p0i8.p0i8.i32\");\n+            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n         ~\"memmove64\" => {\n-            let dst_ptr = get_param(decl, first_real_arg);\n-            let src_ptr = get_param(decl, first_real_arg + 1);\n-            let size = get_param(decl, first_real_arg + 2);\n-            let align = C_i32(1);\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+            let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n+\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(\n-                &~\"llvm.memmove.p0i8.p0i8.i64\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, size, align, volatile]);\n+            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memmove.p0i8.p0i8.i64\");\n+            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n         ~\"sqrtf32\" => {\n             let x = get_param(decl, first_real_arg);"}, {"sha": "a9416a46ddf0c19d0309bea979612e653775ba53", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475", "patch": "@@ -135,7 +135,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                 ~\"visit_tydesc\"  | ~\"forget\" | ~\"frame_address\" |\n                 ~\"morestack_addr\" => 0,\n \n-                ~\"memcpy32\" | ~\"memcpy64\" | ~\"memmove32\" | ~\"memmove64\" => 0,\n+                ~\"memcpy32\" | ~\"memcpy64\" | ~\"memmove32\" | ~\"memmove64\" => use_repr,\n \n                 ~\"sqrtf32\" | ~\"sqrtf64\" | ~\"powif32\" | ~\"powif64\" |\n                 ~\"sinf32\"  | ~\"sinf64\"  | ~\"cosf32\"  | ~\"cosf64\"  |"}, {"sha": "1d959a54c0ef0dd15c98f667263497573c1afbac", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475", "patch": "@@ -3538,59 +3538,59 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n           (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n         }\n         ~\"memcpy32\" => {\n-          (0,\n+          (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_mutbl\n               }),\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_imm\n               }),\n               ty::mk_u32()\n            ],\n            ty::mk_nil())\n         }\n         ~\"memcpy64\" => {\n-          (0,\n+          (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_mutbl\n               }),\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_imm\n               }),\n               ty::mk_u64()\n            ],\n            ty::mk_nil())\n         }\n         ~\"memmove32\" => {\n-          (0,\n+          (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_mutbl\n               }),\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_imm\n               }),\n               ty::mk_u32()\n            ],\n            ty::mk_nil())\n         }\n         ~\"memmove64\" => {\n-          (0,\n+          (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_mutbl\n               }),\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_imm\n               }),\n               ty::mk_u64()"}, {"sha": "97a7d0e11a6753d8e7779a0aa58dd4b8182f9358", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475", "patch": "@@ -26,12 +26,6 @@ pub mod libc_ {\n     #[nolink]\n     #[abi = \"cdecl\"]\n     pub extern {\n-        #[rust_stack]\n-        unsafe fn memmove(dest: *mut c_void,\n-                          src: *const c_void,\n-                          n: libc::size_t)\n-                       -> *c_void;\n-\n         #[rust_stack]\n         unsafe fn memset(dest: *mut c_void,\n                          c: libc::c_int,\n@@ -97,41 +91,69 @@ pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n  * and destination may overlap.\n  */\n #[inline(always)]\n-#[cfg(target_word_size = \"32\")]\n+#[cfg(target_word_size = \"32\", stage0)]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove32;\n     let n = count * sys::size_of::<T>();\n     memmove32(dst as *mut u8, src as *u8, n as u32);\n }\n \n+/**\n+ * Copies data from one location to another\n+ *\n+ * Copies `count` elements (not bytes) from `src` to `dst`. The source\n+ * and destination may overlap.\n+ */\n+#[inline(always)]\n+#[cfg(target_word_size = \"32\", not(stage0))]\n+pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n+    use unstable::intrinsics::memmove32;\n+    memmove32(dst, src, count as u32);\n+}\n+\n #[inline(always)]\n-#[cfg(target_word_size = \"64\")]\n+#[cfg(target_word_size = \"64\", stage0)]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove64;\n     let n = count * sys::size_of::<T>();\n     memmove64(dst as *mut u8, src as *u8, n as u64);\n }\n \n #[inline(always)]\n-#[cfg(target_word_size = \"32\")]\n+#[cfg(target_word_size = \"64\", not(stage0))]\n+pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n+    use unstable::intrinsics::memmove64;\n+    memmove64(dst, src as *T, count as u64);\n+}\n+\n+#[inline(always)]\n+#[cfg(target_word_size = \"32\", stage0)]\n+pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n+    use unstable::intrinsics::memmove32;\n+    let n = count * sys::size_of::<T>();\n+    memmove32(dst as *mut u8, src as *u8, n as u32);\n+}\n+\n+#[inline(always)]\n+#[cfg(target_word_size = \"32\", not(stage0))]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    #[cfg(stage0)]\n-    use memcpy32 = unstable::intrinsics::memmove32;\n-    #[cfg(not(stage0))]\n     use unstable::intrinsics::memcpy32;\n+    memcpy32(dst, src as *T, count as u32);\n+}\n+\n+#[inline(always)]\n+#[cfg(target_word_size = \"64\", stage0)]\n+pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n+    use unstable::intrinsics::memmove64;\n     let n = count * sys::size_of::<T>();\n-    memcpy32(dst as *mut u8, src as *u8, n as u32);\n+    memmove64(dst as *mut u8, src as *u8, n as u64);\n }\n \n #[inline(always)]\n-#[cfg(target_word_size = \"64\")]\n+#[cfg(target_word_size = \"64\", not(stage0))]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    #[cfg(stage0)]\n-    use memcpy64 = unstable::intrinsics::memmove64;\n-    #[cfg(not(stage0))]\n     use unstable::intrinsics::memcpy64;\n-    let n = count * sys::size_of::<T>();\n-    memcpy64(dst as *mut u8, src as *u8, n as u64);\n+    memcpy64(dst, src as *T, count as u64);\n }\n \n #[inline(always)]"}, {"sha": "c0975d6a5266f5cebd58940596a94f58264751fb", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=cf8e9f9aec25b6441d3198d7ddb4bd6a6b9e1475", "patch": "@@ -127,18 +127,31 @@ pub extern \"rust-intrinsic\" {\n     /// Get the address of the `__morestack` stack growth function.\n     pub fn morestack_addr() -> *();\n \n-    /// Equivalent to the `llvm.memcpy.p0i8.0i8.i32` intrinsic.\n+    /// Equivalent to the `llvm.memcpy.p0i8.0i8.i32` intrinsic, with a size of\n+    /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n     #[cfg(not(stage0))]\n-    pub fn memcpy32(dst: *mut u8, src: *u8, size: u32);\n-    /// Equivalent to the `llvm.memcpy.p0i8.0i8.i64` intrinsic.\n+    pub fn memcpy32<T>(dst: *mut T, src: *T, count: u32);\n+    /// Equivalent to the `llvm.memcpy.p0i8.0i8.i64` intrinsic, with a size of\n+    /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n     #[cfg(not(stage0))]\n-    pub fn memcpy64(dst: *mut u8, src: *u8, size: u64);\n+    pub fn memcpy64<T>(dst: *mut T, src: *T, count: u64);\n \n     /// Equivalent to the `llvm.memmove.p0i8.0i8.i32` intrinsic.\n+    #[cfg(stage0)]\n     pub fn memmove32(dst: *mut u8, src: *u8, size: u32);\n     /// Equivalent to the `llvm.memmove.p0i8.0i8.i64` intrinsic.\n+    #[cfg(stage0)]\n     pub fn memmove64(dst: *mut u8, src: *u8, size: u64);\n \n+    /// Equivalent to the `llvm.memmove.p0i8.0i8.i32` intrinsic, with a size of\n+    /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n+    #[cfg(not(stage0))]\n+    pub fn memmove32<T>(dst: *mut T, src: *T, count: u32);\n+    /// Equivalent to the `llvm.memmove.p0i8.0i8.i64` intrinsic, with a size of\n+    /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n+    #[cfg(not(stage0))]\n+    pub fn memmove64<T>(dst: *mut T, src: *T, count: u64);\n+\n     pub fn sqrtf32(x: f32) -> f32;\n     pub fn sqrtf64(x: f64) -> f64;\n "}]}