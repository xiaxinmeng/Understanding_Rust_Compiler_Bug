{"sha": "9bbec651dfff68c93d7213fceadecc21c324b0cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYmVjNjUxZGZmZjY4YzkzZDcyMTNmY2VhZGVjYzIxYzMyNGIwY2I=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-13T02:45:19Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T09:08:57Z"}, "message": "Replace *rust_task ptrs in taskgroup code with TaskHandle, for transitioning to newsched killing.", "tree": {"sha": "e24d1cf629094c67a166615d31b936e9b1855e97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e24d1cf629094c67a166615d31b936e9b1855e97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bbec651dfff68c93d7213fceadecc21c324b0cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bbec651dfff68c93d7213fceadecc21c324b0cb", "html_url": "https://github.com/rust-lang/rust/commit/9bbec651dfff68c93d7213fceadecc21c324b0cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bbec651dfff68c93d7213fceadecc21c324b0cb/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2a42416ddab88f7ed076cb9a4fd6ecc70be3278", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2a42416ddab88f7ed076cb9a4fd6ecc70be3278", "html_url": "https://github.com/rust-lang/rust/commit/e2a42416ddab88f7ed076cb9a4fd6ecc70be3278"}], "stats": {"total": 347, "additions": 219, "deletions": 128}, "files": [{"sha": "b331442eb4bc2c80520e453387f862217d586262", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9bbec651dfff68c93d7213fceadecc21c324b0cb/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bbec651dfff68c93d7213fceadecc21c324b0cb/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=9bbec651dfff68c93d7213fceadecc21c324b0cb", "patch": "@@ -16,6 +16,7 @@ use either::{Either, Left, Right};\n use option::{Option, Some, None};\n use prelude::*;\n use rt::task::Task;\n+use to_bytes::IterBytes;\n use unstable::atomics::{AtomicUint, Acquire, SeqCst};\n use unstable::sync::{UnsafeAtomicRcBox, LittleLock};\n use util;\n@@ -194,6 +195,17 @@ impl BlockedTask {\n     }\n }\n \n+// So that KillHandle can be hashed in the taskgroup bookkeeping code.\n+impl IterBytes for KillHandle {\n+    fn iter_bytes(&self, lsb0: bool, f: &fn(buf: &[u8]) -> bool) -> bool {\n+        self.data.iter_bytes(lsb0, f)\n+    }\n+}\n+impl Eq for KillHandle {\n+    #[inline] fn eq(&self, other: &KillHandle) -> bool { self.data.eq(&other.data) }\n+    #[inline] fn ne(&self, other: &KillHandle) -> bool { self.data.ne(&other.data) }\n+}\n+\n impl KillHandle {\n     pub fn new() -> (KillHandle, KillFlagHandle) {\n         let (flag, flag_clone) ="}, {"sha": "f6e2faf5bf1b92f832e9240eb8db0deeb2339109", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9bbec651dfff68c93d7213fceadecc21c324b0cb/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bbec651dfff68c93d7213fceadecc21c324b0cb/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=9bbec651dfff68c93d7213fceadecc21c324b0cb", "patch": "@@ -27,6 +27,7 @@ use super::local_heap::LocalHeap;\n use rt::sched::{Scheduler, SchedHandle};\n use rt::stack::{StackSegment, StackPool};\n use rt::context::Context;\n+use task::spawn::TCB;\n use cell::Cell;\n \n pub struct Task {\n@@ -36,6 +37,7 @@ pub struct Task {\n     logger: StdErrLogger,\n     unwinder: Unwinder,\n     home: Option<SchedHome>,\n+    taskgroup: Option<TCB>,\n     death: Death,\n     destroyed: bool,\n     coroutine: Option<~Coroutine>\n@@ -85,6 +87,7 @@ impl Task {\n             logger: StdErrLogger,\n             unwinder: Unwinder { unwinding: false },\n             home: Some(home),\n+            taskgroup: None,\n             death: Death::new(),\n             destroyed: false,\n             coroutine: Some(~Coroutine::new(stack_pool, start))\n@@ -102,6 +105,7 @@ impl Task {\n             logger: StdErrLogger,\n             home: Some(home),\n             unwinder: Unwinder { unwinding: false },\n+            taskgroup: None,\n             // FIXME(#7544) make watching optional\n             death: self.death.new_child(),\n             destroyed: false,\n@@ -121,6 +125,7 @@ impl Task {\n         }\n \n         self.unwinder.try(f);\n+        { let _ = self.taskgroup.take(); }\n         self.death.collect_failure(!self.unwinder.unwinding);\n         self.destroy();\n     }"}, {"sha": "303028b30a27d4c223c3fe0d9077a89c4491a6b9", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 202, "deletions": 128, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/9bbec651dfff68c93d7213fceadecc21c324b0cb/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bbec651dfff68c93d7213fceadecc21c324b0cb/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=9bbec651dfff68c93d7213fceadecc21c324b0cb", "patch": "@@ -79,7 +79,7 @@ use cast;\n use cell::Cell;\n use container::MutableMap;\n use comm::{Chan, GenericChan};\n-use hashmap::HashSet;\n+use hashmap::{HashSet, HashSetConsumeIterator};\n use local_data;\n use task::local_data_priv::{local_get, local_set, OldHandle};\n use task::rt::rust_task;\n@@ -88,32 +88,61 @@ use task::{Failure, ManualThreads, PlatformThread, SchedOpts, SingleThreaded};\n use task::{Success, TaskOpts, TaskResult, ThreadPerTask};\n use task::{ExistingScheduler, SchedulerHandle};\n use task::unkillable;\n+use to_bytes::IterBytes;\n use uint;\n use util;\n use unstable::sync::{Exclusive, exclusive};\n+use rt::{OldTaskContext, TaskContext, SchedulerContext, GlobalContext, context};\n use rt::local::Local;\n use rt::task::Task;\n+use rt::kill::KillHandle;\n+use rt::sched::Scheduler;\n use iterator::IteratorUtil;\n \n #[cfg(test)] use task::default_task_opts;\n #[cfg(test)] use comm;\n #[cfg(test)] use task;\n \n-type TaskSet = HashSet<*rust_task>;\n+// Transitionary.\n+#[deriving(Eq)]\n+enum TaskHandle {\n+    OldTask(*rust_task),\n+    NewTask(KillHandle),\n+}\n+\n+impl Clone for TaskHandle {\n+    fn clone(&self) -> TaskHandle {\n+        match *self {\n+            OldTask(x) => OldTask(x),\n+            NewTask(ref x) => NewTask(x.clone()),\n+        }\n+    }\n+}\n+\n+impl IterBytes for TaskHandle {\n+    fn iter_bytes(&self, lsb0: bool, f: &fn(buf: &[u8]) -> bool) -> bool {\n+        match *self {\n+            OldTask(ref x) => x.iter_bytes(lsb0, f),\n+            NewTask(ref x) => x.iter_bytes(lsb0, f),\n+        }\n+    }\n+}\n+\n+type TaskSet = HashSet<TaskHandle>;\n \n fn new_taskset() -> TaskSet {\n     HashSet::new()\n }\n-fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n+fn taskset_insert(tasks: &mut TaskSet, task: TaskHandle) {\n     let didnt_overwrite = tasks.insert(task);\n     assert!(didnt_overwrite);\n }\n-fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n-    let was_present = tasks.remove(&task);\n+fn taskset_remove(tasks: &mut TaskSet, task: &TaskHandle) {\n+    let was_present = tasks.remove(task);\n     assert!(was_present);\n }\n-pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) -> bool {\n-    tasks.iter().advance(|k| blk(*k))\n+fn taskset_consume(tasks: TaskSet) -> HashSetConsumeIterator<TaskHandle> {\n+    tasks.consume()\n }\n \n // One of these per group of linked-failure tasks.\n@@ -179,25 +208,23 @@ fn access_ancestors<U>(x: &Exclusive<AncestorNode>,\n //     taskgroups that forward_blk already ran on successfully (Note: bail_blk\n //     is NOT called on the block that forward_blk broke on!).\n // (3) As a bonus, coalesces away all 'dead' taskgroup nodes in the list.\n-// FIXME(#2190): Change Option<@fn(...)> to Option<&fn(...)>, to save on\n-// allocations. Once that bug is fixed, changing the sigil should suffice.\n fn each_ancestor(list:        &mut AncestorList,\n-                 bail_opt:    Option<@fn(TaskGroupInner)>,\n+                 bail_blk:    &fn(TaskGroupInner),\n                  forward_blk: &fn(TaskGroupInner) -> bool)\n               -> bool {\n     // \"Kickoff\" call - there was no last generation.\n-    return !coalesce(list, bail_opt, forward_blk, uint::max_value);\n+    return !coalesce(list, bail_blk, forward_blk, uint::max_value);\n \n     // Recursively iterates, and coalesces afterwards if needed. Returns\n     // whether or not unwinding is needed (i.e., !successful iteration).\n     fn coalesce(list:            &mut AncestorList,\n-                bail_opt:        Option<@fn(TaskGroupInner)>,\n+                bail_blk:        &fn(TaskGroupInner),\n                 forward_blk:     &fn(TaskGroupInner) -> bool,\n                 last_generation: uint) -> bool {\n         // Need to swap the list out to use it, to appease borrowck.\n         let tmp_list = util::replace(&mut *list, AncestorList(None));\n         let (coalesce_this, early_break) =\n-            iterate(&tmp_list, bail_opt, forward_blk, last_generation);\n+            iterate(&tmp_list, bail_blk, forward_blk, last_generation);\n         // What should our next ancestor end up being?\n         if coalesce_this.is_some() {\n             // Needed coalesce. Our next ancestor becomes our old\n@@ -219,7 +246,7 @@ fn each_ancestor(list:        &mut AncestorList,\n     //     True if the supplied block did 'break', here or in any recursive\n     //     calls. If so, must call the unwinder on all previous nodes.\n     fn iterate(ancestors:       &AncestorList,\n-               bail_opt:        Option<@fn(TaskGroupInner)>,\n+               bail_blk:        &fn(TaskGroupInner),\n                forward_blk:     &fn(TaskGroupInner) -> bool,\n                last_generation: uint)\n             -> (Option<AncestorList>, bool) {\n@@ -257,7 +284,7 @@ fn each_ancestor(list:        &mut AncestorList,\n                             None => nobe_is_dead\n                         };\n                         // Call iterator block. (If the group is dead, it's\n-                        // safe to skip it. This will leave our *rust_task\n+                        // safe to skip it. This will leave our TaskHandle\n                         // hanging around in the group even after it's freed,\n                         // but that's ok because, by virtue of the group being\n                         // dead, nobody will ever kill-all (foreach) over it.)\n@@ -271,17 +298,15 @@ fn each_ancestor(list:        &mut AncestorList,\n                 let mut need_unwind = false;\n                 if do_continue {\n                     // NB: Takes many locks! (ancestor nodes & parent groups)\n-                    need_unwind = coalesce(&mut nobe.ancestors, bail_opt,\n+                    need_unwind = coalesce(&mut nobe.ancestors, |tg| bail_blk(tg),\n                                            forward_blk, nobe.generation);\n                 }\n                 /*##########################################################*\n                  * Step 3: Maybe unwind; compute return info for our caller.\n                  *##########################################################*/\n                 if need_unwind && !nobe_is_dead {\n-                    for bail_opt.iter().advance |bail_blk| {\n-                        do with_parent_tg(&mut nobe.parent_group) |tg_opt| {\n-                            (*bail_blk)(tg_opt)\n-                        }\n+                    do with_parent_tg(&mut nobe.parent_group) |tg_opt| {\n+                        bail_blk(tg_opt)\n                     }\n                 }\n                 // Decide whether our caller should unwind.\n@@ -311,8 +336,7 @@ fn each_ancestor(list:        &mut AncestorList,\n }\n \n // One of these per task.\n-struct TCB {\n-    me:         *rust_task,\n+pub struct TCB {\n     // List of tasks with whose fates this one's is intertwined.\n     tasks:      TaskGroupArc, // 'none' means the group has failed.\n     // Lists of tasks who will kill us if they fail, but whom we won't kill.\n@@ -329,33 +353,34 @@ impl Drop for TCB {\n             let this: &mut TCB = transmute(self);\n \n             // If we are failing, the whole taskgroup needs to die.\n-            if rt::rust_task_is_unwinding(self.me) {\n-                for this.notifier.mut_iter().advance |x| {\n-                    x.failed = true;\n-                }\n-                // Take everybody down with us.\n-                do access_group(&self.tasks) |tg| {\n-                    kill_taskgroup(tg, self.me, self.is_main);\n-                }\n-            } else {\n-                // Remove ourselves from the group(s).\n-                do access_group(&self.tasks) |tg| {\n-                    leave_taskgroup(tg, self.me, true);\n+            do RuntimeGlue::with_task_handle_and_failing |me, failing| {\n+                if failing {\n+                    for this.notifier.mut_iter().advance |x| {\n+                        x.failed = true;\n+                    }\n+                    // Take everybody down with us.\n+                    do access_group(&self.tasks) |tg| {\n+                        kill_taskgroup(tg, &me, self.is_main);\n+                    }\n+                } else {\n+                    // Remove ourselves from the group(s).\n+                    do access_group(&self.tasks) |tg| {\n+                        leave_taskgroup(tg, &me, true);\n+                    }\n                 }\n+                // It doesn't matter whether this happens before or after dealing\n+                // with our own taskgroup, so long as both happen before we die.\n+                // We remove ourself from every ancestor we can, so no cleanup; no\n+                // break.\n+                for each_ancestor(&mut this.ancestors, |_| {}) |ancestor_group| {\n+                    leave_taskgroup(ancestor_group, &me, false);\n+                };\n             }\n-            // It doesn't matter whether this happens before or after dealing\n-            // with our own taskgroup, so long as both happen before we die.\n-            // We remove ourself from every ancestor we can, so no cleanup; no\n-            // break.\n-            for each_ancestor(&mut this.ancestors, None) |ancestor_group| {\n-                leave_taskgroup(ancestor_group, self.me, false);\n-            };\n         }\n     }\n }\n \n-fn TCB(me: *rust_task,\n-       tasks: TaskGroupArc,\n+pub fn TCB(tasks: TaskGroupArc,\n        ancestors: AncestorList,\n        is_main: bool,\n        mut notifier: Option<AutoNotify>) -> TCB {\n@@ -364,7 +389,6 @@ fn TCB(me: *rust_task,\n     }\n \n     TCB {\n-        me: me,\n         tasks: tasks,\n         ancestors: ancestors,\n         is_main: is_main,\n@@ -391,7 +415,7 @@ fn AutoNotify(chan: Chan<TaskResult>) -> AutoNotify {\n     }\n }\n \n-fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n+fn enlist_in_taskgroup(state: TaskGroupInner, me: TaskHandle,\n                            is_member: bool) -> bool {\n     let newstate = util::replace(&mut *state, None);\n     // If 'None', the group was failing. Can't enlist.\n@@ -410,7 +434,7 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n+fn leave_taskgroup(state: TaskGroupInner, me: &TaskHandle,\n                        is_member: bool) {\n     let newstate = util::replace(&mut *state, None);\n     // If 'None', already failing and we've already gotten a kill signal.\n@@ -426,7 +450,7 @@ fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n+fn kill_taskgroup(state: TaskGroupInner, me: &TaskHandle, is_main: bool) {\n     unsafe {\n         // NB: We could do the killing iteration outside of the group arc, by\n         // having \"let mut newstate\" here, swapping inside, and iterating\n@@ -442,20 +466,21 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n         // That's ok; only one task needs to do the dirty work. (Might also\n         // see 'None' if Somebody already failed and we got a kill signal.)\n         if newstate.is_some() {\n-            let group = newstate.unwrap();\n-            for taskset_each(&group.members) |sibling| {\n+            let TaskGroupData { members: members, descendants: descendants } =\n+                newstate.unwrap();\n+            for taskset_consume(members).advance() |sibling| {\n                 // Skip self - killing ourself won't do much good.\n-                if sibling != me {\n-                    rt::rust_task_kill_other(sibling);\n+                if &sibling != me {\n+                    RuntimeGlue::kill_task(sibling);\n                 }\n             }\n-            for taskset_each(&group.descendants) |child| {\n-                assert!(child != me);\n-                rt::rust_task_kill_other(child);\n+            do taskset_consume(descendants).advance() |child| {\n+                assert!(&child != me);\n+                RuntimeGlue::kill_task(child);\n             }\n             // Only one task should ever do this.\n             if is_main {\n-                rt::rust_task_kill_all(me);\n+                RuntimeGlue::kill_all_tasks(me);\n             }\n             // Do NOT restore state to Some(..)! It stays None to indicate\n             // that the whole taskgroup is failing, to forbid new spawns.\n@@ -475,43 +500,103 @@ fn taskgroup_key() -> local_data::Key<@@mut TCB> {\n     unsafe { cast::transmute((-2, 0)) }\n }\n \n-fn gen_child_taskgroup(linked: bool, supervised: bool)\n-    -> (TaskGroupArc, AncestorList, bool) {\n-    unsafe {\n-        let spawner = rt::rust_get_task();\n-        /*##################################################################*\n-         * Step 1. Get spawner's taskgroup info.\n-         *##################################################################*/\n-        let spawner_group: @@mut TCB =\n-            do local_get(OldHandle(spawner), taskgroup_key()) |group| {\n-                match group {\n+// Transitionary.\n+struct RuntimeGlue;\n+impl RuntimeGlue {\n+    unsafe fn kill_task(task: TaskHandle) {\n+        match task {\n+            OldTask(ptr) => rt::rust_task_kill_other(ptr),\n+            NewTask(handle) => {\n+                let mut handle = handle;\n+                do handle.kill().map_consume |killed_task| {\n+                    let killed_task = Cell::new(killed_task);\n+                    do Local::borrow::<Scheduler, ()> |sched| {\n+                        sched.enqueue_task(killed_task.take());\n+                    }\n+                };\n+            }\n+        }\n+    }\n+\n+    unsafe fn kill_all_tasks(task: &TaskHandle) {\n+        match *task {\n+            OldTask(ptr) => rt::rust_task_kill_all(ptr),\n+            NewTask(ref _handle) => rtabort!(\"unimplemented\"), // FIXME(#7544)\n+        }\n+    }\n+\n+    fn with_task_handle_and_failing(blk: &fn(TaskHandle, bool)) {\n+        match context() {\n+            OldTaskContext => unsafe {\n+                let me = rt::rust_get_task();\n+                blk(OldTask(me), rt::rust_task_is_unwinding(me))\n+            },\n+            TaskContext => unsafe {\n+                // Can't use safe borrow, because the taskgroup destructor needs to\n+                // access the scheduler again to send kill signals to other tasks.\n+                let me = Local::unsafe_borrow::<Task>();\n+                // FIXME(#7544): Get rid of this clone by passing by-ref.\n+                // Will probably have to wait until the old rt is gone.\n+                blk(NewTask((*me).death.kill_handle.get_ref().clone()),\n+                    (*me).unwinder.unwinding)\n+            },\n+            SchedulerContext | GlobalContext => rtabort!(\"task dying in bad context\"),\n+        }\n+    }\n+\n+    fn with_my_taskgroup<U>(blk: &fn(&mut TCB) -> U) -> U {\n+        match context() {\n+            OldTaskContext => unsafe {\n+                let me = rt::rust_get_task();\n+                do local_get(OldHandle(me), taskgroup_key()) |g| {\n+                    match g {\n+                        None => {\n+                            // Main task, doing first spawn ever. Lazily initialise here.\n+                            let mut members = new_taskset();\n+                            taskset_insert(&mut members, OldTask(me));\n+                            let tasks = exclusive(Some(TaskGroupData {\n+                                members: members,\n+                                descendants: new_taskset(),\n+                            }));\n+                            // Main task/group has no ancestors, no notifier, etc.\n+                            let group = @@mut TCB(tasks, AncestorList(None), true, None);\n+                            local_set(OldHandle(me), taskgroup_key(), group);\n+                            blk(&mut **group)\n+                        }\n+                        Some(&group) => blk(&mut **group)\n+                    }\n+                }\n+            },\n+            TaskContext => unsafe {\n+                // Can't use safe borrow, because creating new hashmaps for the\n+                // tasksets requires an rng, which needs to borrow the sched.\n+                let me = Local::unsafe_borrow::<Task>();\n+                blk(match (*me).taskgroup {\n                     None => {\n-                        // Main task, doing first spawn ever. Lazily initialise\n-                        // here.\n+                        // Main task, doing first spawn ever. Lazily initialize.\n                         let mut members = new_taskset();\n-                        taskset_insert(&mut members, spawner);\n+                        let my_handle = (*me).death.kill_handle.get_ref().clone();\n+                        taskset_insert(&mut members, NewTask(my_handle));\n                         let tasks = exclusive(Some(TaskGroupData {\n                             members: members,\n                             descendants: new_taskset(),\n                         }));\n-                        // Main task/group has no ancestors, no notifier, etc.\n-                        let group = @@mut TCB(spawner,\n-                                              tasks,\n-                                              AncestorList(None),\n-                                              true,\n-                                              None);\n-                        local_set(OldHandle(spawner), taskgroup_key(), group);\n-                        group\n+                        let group = TCB(tasks, AncestorList(None), true, None);\n+                        (*me).taskgroup = Some(group);\n+                        (*me).taskgroup.get_mut_ref()\n                     }\n-                    Some(&group) => group\n-                }\n-            };\n-        let spawner_group: &mut TCB = *spawner_group;\n+                    Some(ref mut group) => group,\n+                })\n+            },\n+            SchedulerContext | GlobalContext => rtabort!(\"spawning in bad context\"),\n+        }\n+    }\n+}\n \n-        /*##################################################################*\n-         * Step 2. Process spawn options for child.\n-         *##################################################################*/\n-        return if linked {\n+fn gen_child_taskgroup(linked: bool, supervised: bool)\n+    -> (TaskGroupArc, AncestorList, bool) {\n+    return do RuntimeGlue::with_my_taskgroup |spawner_group| {\n+        if linked {\n             // Child is in the same group as spawner.\n             let g = spawner_group.tasks.clone();\n             // Child's ancestors are spawner's ancestors.\n@@ -550,8 +635,8 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 AncestorList(None)\n             };\n             (g, a, false)\n-        };\n-    }\n+        }\n+    };\n \n     fn share_ancestors(ancestors: &mut AncestorList) -> AncestorList {\n         // Appease the borrow-checker. Really this wants to be written as:\n@@ -562,6 +647,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         if tmp.is_some() {\n             let ancestor_arc = tmp.unwrap();\n             let result = ancestor_arc.clone();\n+            error!(\"cloned ancestors\");\n             **ancestors = Some(ancestor_arc);\n             AncestorList(Some(result))\n         } else {\n@@ -570,9 +656,35 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n     }\n }\n \n-pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n-    use rt::*;\n+// Set up membership in taskgroup and descendantship in all ancestor\n+// groups. If any enlistment fails, Some task was already failing, so\n+// don't let the child task run, and undo every successful enlistment.\n+fn enlist_many(child: TaskHandle, child_arc: &TaskGroupArc,\n+               ancestors: &mut AncestorList) -> bool {\n+    // Join this taskgroup.\n+    let mut result = do access_group(child_arc) |child_tg| {\n+        enlist_in_taskgroup(child_tg, child.clone(), true) // member\n+    };\n+    if result {\n+        // Unwinding function in case any ancestral enlisting fails\n+        let bail: &fn(TaskGroupInner) = |tg| { leave_taskgroup(tg, &child, false) };\n+        // Attempt to join every ancestor group.\n+        result = do each_ancestor(ancestors, bail) |ancestor_tg| {\n+            // Enlist as a descendant, not as an actual member.\n+            // Descendants don't kill ancestor groups on failure.\n+            enlist_in_taskgroup(ancestor_tg, child.clone(), false)\n+        };\n+        // If any ancestor group fails, need to exit this group too.\n+        if !result {\n+            do access_group(child_arc) |child_tg| {\n+                leave_taskgroup(child_tg, &child, true); // member\n+            }\n+        }\n+    }\n+    result\n+}\n \n+pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n     match context() {\n         OldTaskContext => {\n             spawn_raw_oldsched(opts, f)\n@@ -590,8 +702,6 @@ pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n }\n \n fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n-    use rt::sched::*;\n-\n     let f = Cell::new(f);\n \n     let mut task = unsafe {\n@@ -686,12 +796,8 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n \n             let notifier = notify_chan.map_consume(|c| AutoNotify(c));\n \n-            if enlist_many(child, &child_arc, &mut ancestors) {\n-                let group = @@mut TCB(child,\n-                                      child_arc,\n-                                      ancestors,\n-                                      is_main,\n-                                      notifier);\n+            if enlist_many(OldTask(child), &child_arc, &mut ancestors) {\n+                let group = @@mut TCB(child_arc, ancestors, is_main, notifier);\n                 unsafe {\n                     local_set(OldHandle(child), taskgroup_key(), group);\n                 }\n@@ -707,38 +813,6 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n             // unsafe { cleanup::annihilate(); }\n         };\n         return result;\n-\n-        // Set up membership in taskgroup and descendantship in all ancestor\n-        // groups. If any enlistment fails, Some task was already failing, so\n-        // don't let the child task run, and undo every successful enlistment.\n-        fn enlist_many(child: *rust_task, child_arc: &TaskGroupArc,\n-                       ancestors: &mut AncestorList) -> bool {\n-            // Join this taskgroup.\n-            let mut result =\n-                do access_group(child_arc) |child_tg| {\n-                    enlist_in_taskgroup(child_tg, child, true) // member\n-                };\n-            if result {\n-                // Unwinding function in case any ancestral enlisting fails\n-                let bail: @fn(TaskGroupInner) = |tg| {\n-                    leave_taskgroup(tg, child, false)\n-                };\n-                // Attempt to join every ancestor group.\n-                result =\n-                    each_ancestor(ancestors, Some(bail), |ancestor_tg| {\n-                        // Enlist as a descendant, not as an actual member.\n-                        // Descendants don't kill ancestor groups on failure.\n-                        enlist_in_taskgroup(ancestor_tg, child, false)\n-                    });\n-                // If any ancestor group fails, need to exit this group too.\n-                if !result {\n-                    do access_group(child_arc) |child_tg| {\n-                        leave_taskgroup(child_tg, child, true); // member\n-                    }\n-                }\n-            }\n-            result\n-        }\n     }\n \n     fn new_task_in_sched(opts: SchedOpts) -> *rust_task {"}]}