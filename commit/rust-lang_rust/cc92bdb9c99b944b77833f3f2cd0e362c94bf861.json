{"sha": "cc92bdb9c99b944b77833f3f2cd0e362c94bf861", "node_id": "C_kwDOAAsO6NoAKGNjOTJiZGI5Yzk5Yjk0NGI3NzgzM2YzZjJjZDBlMzYyYzk0YmY4NjE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-26T06:53:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-26T06:53:22Z"}, "message": "Rollup merge of #106779 - RReverser:patch-2, r=Mark-Simulacrum\n\nAvoid __cxa_thread_atexit_impl on Emscripten\n\n - Fixes https://github.com/rust-lang/rust/issues/91628.\n - Fixes https://github.com/emscripten-core/emscripten/issues/15722.\n\nSee discussion in both issues.\n\nThe TL;DR is that weak linkage causes LLVM to produce broken Wasm, presumably due to pointer mismatch. The code is casting a void pointer to a function pointer with specific signature, but Wasm is very strict about function pointer compatibility, so the resulting code is invalid.\n\nIdeally LLVM should catch this earlier in the process rather than emit invalid Wasm, but it currently doesn't and this is an easy and valid fix, given that Emcripten doesn't have `__cxa_thread_atexit_impl` these days anyway.\n\nUnfortunately, I can't add a regression test as even after looking into this issue for a long time, I couldn't reproduce it with any minimal Rust example, only with extracted LLVM IR or on a large project involving Rust + C++.", "tree": {"sha": "26d0c7d4330ac06aafbdc5702ad2752fc8463b2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26d0c7d4330ac06aafbdc5702ad2752fc8463b2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc92bdb9c99b944b77833f3f2cd0e362c94bf861", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj0iNiCRBK7hj4Ov3rIwAA5Y8IAD+rLdjBgPp7xzvsCcUZAIQz\n5kqm3H+HHlSc5P6XbZtpG0bQBHKkz/HAJe0y+bXEqzHffe68IUICZRJQk49pfRzn\naVsFMEpkkaNM5N9JTgBC385WNzTDabqnGZuvt56WhTEckTLhVm/zCM6+xxkdGO67\nrHYbqDsFDdWO920q1dmQ6OLVXdfsyOgvLxskrc4cIen+uUyY7uTMmU2UMoK1Cyta\nsX5CiwBsGg+TpqinC2JS4uC9J/Xo9PKBW4AAiWzIVqgzmZct71aB57L4wSGQOC4W\nQ9S75ZRK7iubpJpoCffjijdKW0rqc21TPqpfJmJuc5Bvj80g6Oj3Jchl/nKjJig=\n=WWtC\n-----END PGP SIGNATURE-----\n", "payload": "tree 26d0c7d4330ac06aafbdc5702ad2752fc8463b2d\nparent b2448f9f9c8f22296e01072613fc17f69776280f\nparent a41c5f9c381aeb6cb29afd1a0ca79f31d257cd6c\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674716002 +0100\ncommitter GitHub <noreply@github.com> 1674716002 +0100\n\nRollup merge of #106779 - RReverser:patch-2, r=Mark-Simulacrum\n\nAvoid __cxa_thread_atexit_impl on Emscripten\n\n - Fixes https://github.com/rust-lang/rust/issues/91628.\n - Fixes https://github.com/emscripten-core/emscripten/issues/15722.\n\nSee discussion in both issues.\n\nThe TL;DR is that weak linkage causes LLVM to produce broken Wasm, presumably due to pointer mismatch. The code is casting a void pointer to a function pointer with specific signature, but Wasm is very strict about function pointer compatibility, so the resulting code is invalid.\n\nIdeally LLVM should catch this earlier in the process rather than emit invalid Wasm, but it currently doesn't and this is an easy and valid fix, given that Emcripten doesn't have `__cxa_thread_atexit_impl` these days anyway.\n\nUnfortunately, I can't add a regression test as even after looking into this issue for a long time, I couldn't reproduce it with any minimal Rust example, only with extracted LLVM IR or on a large project involving Rust + C++.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc92bdb9c99b944b77833f3f2cd0e362c94bf861", "html_url": "https://github.com/rust-lang/rust/commit/cc92bdb9c99b944b77833f3f2cd0e362c94bf861", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc92bdb9c99b944b77833f3f2cd0e362c94bf861/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2448f9f9c8f22296e01072613fc17f69776280f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2448f9f9c8f22296e01072613fc17f69776280f", "html_url": "https://github.com/rust-lang/rust/commit/b2448f9f9c8f22296e01072613fc17f69776280f"}, {"sha": "a41c5f9c381aeb6cb29afd1a0ca79f31d257cd6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a41c5f9c381aeb6cb29afd1a0ca79f31d257cd6c", "html_url": "https://github.com/rust-lang/rust/commit/a41c5f9c381aeb6cb29afd1a0ca79f31d257cd6c"}], "stats": {"total": 11, "additions": 3, "deletions": 8}, "files": [{"sha": "236d2f2ee29280cac96ce34c512c7bae291a0786", "filename": "library/std/src/sys/unix/thread_local_dtor.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cc92bdb9c99b944b77833f3f2cd0e362c94bf861/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc92bdb9c99b944b77833f3f2cd0e362c94bf861/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_dtor.rs?ref=cc92bdb9c99b944b77833f3f2cd0e362c94bf861", "patch": "@@ -11,13 +11,7 @@\n // Note, however, that we run on lots older linuxes, as well as cross\n // compiling from a newer linux to an older linux, so we also have a\n // fallback implementation to use as well.\n-#[cfg(any(\n-    target_os = \"linux\",\n-    target_os = \"fuchsia\",\n-    target_os = \"redox\",\n-    target_os = \"emscripten\"\n-))]\n-#[cfg_attr(target_family = \"wasm\", allow(unused))] // might remain unused depending on target details (e.g. wasm32-unknown-emscripten)\n+#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\", target_os = \"redox\"))]\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::mem;\n     use crate::sys_common::thread_local_dtor::register_dtor_fallback;\n@@ -89,7 +83,8 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     }\n }\n \n-#[cfg(any(target_os = \"vxworks\", target_os = \"horizon\"))]\n+#[cfg(any(target_os = \"vxworks\", target_os = \"horizon\", target_os = \"emscripten\"))]\n+#[cfg_attr(target_family = \"wasm\", allow(unused))] // might remain unused depending on target details (e.g. wasm32-unknown-emscripten)\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n     use crate::sys_common::thread_local_dtor::register_dtor_fallback;\n     register_dtor_fallback(t, dtor);"}]}