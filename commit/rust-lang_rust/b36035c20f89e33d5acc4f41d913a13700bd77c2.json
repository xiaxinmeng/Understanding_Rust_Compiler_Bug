{"sha": "b36035c20f89e33d5acc4f41d913a13700bd77c2", "node_id": "C_kwDOAAsO6NoAKGIzNjAzNWMyMGY4OWUzM2Q1YWNjNGY0MWQ5MTNhMTM3MDBiZDc3YzI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-08T04:51:46Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-08T05:16:57Z"}, "message": "Move vtable methods into its own module", "tree": {"sha": "53ff207afcfd67cee618f8989abb8200f06aabc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53ff207afcfd67cee618f8989abb8200f06aabc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b36035c20f89e33d5acc4f41d913a13700bd77c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b36035c20f89e33d5acc4f41d913a13700bd77c2", "html_url": "https://github.com/rust-lang/rust/commit/b36035c20f89e33d5acc4f41d913a13700bd77c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b36035c20f89e33d5acc4f41d913a13700bd77c2/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48270044b04750477da7276a8845ceb06d7b2185", "url": "https://api.github.com/repos/rust-lang/rust/commits/48270044b04750477da7276a8845ceb06d7b2185", "html_url": "https://github.com/rust-lang/rust/commit/48270044b04750477da7276a8845ceb06d7b2185"}], "stats": {"total": 776, "additions": 398, "deletions": 378}, "files": [{"sha": "c2104a98cea78e9f5c07721c796884e662b30327", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 363, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/b36035c20f89e33d5acc4f41d913a13700bd77c2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36035c20f89e33d5acc4f41d913a13700bd77c2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=b36035c20f89e33d5acc4f41d913a13700bd77c2", "patch": "@@ -20,25 +20,21 @@ mod select;\n mod specialize;\n mod structural_match;\n mod util;\n+mod vtable;\n pub mod wf;\n \n-use crate::errors::DumpVTableEntries;\n use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n use crate::traits::error_reporting::TypeErrCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{\n-    self, DefIdTree, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeSuperVisitable, VtblEntry,\n-};\n+use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeSuperVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n-use rustc_span::{sym, Span};\n-use smallvec::SmallVec;\n+use rustc_span::Span;\n \n use std::fmt::Debug;\n use std::ops::ControlFlow;\n@@ -567,368 +563,13 @@ fn is_impossible_method<'tcx>(\n     false\n }\n \n-#[derive(Clone, Debug)]\n-enum VtblSegment<'tcx> {\n-    MetadataDSA,\n-    TraitOwnEntries { trait_ref: ty::PolyTraitRef<'tcx>, emit_vptr: bool },\n-}\n-\n-/// Prepare the segments for a vtable\n-fn prepare_vtable_segments<'tcx, T>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-    mut segment_visitor: impl FnMut(VtblSegment<'tcx>) -> ControlFlow<T>,\n-) -> Option<T> {\n-    // The following constraints holds for the final arrangement.\n-    // 1. The whole virtual table of the first direct super trait is included as the\n-    //    the prefix. If this trait doesn't have any super traits, then this step\n-    //    consists of the dsa metadata.\n-    // 2. Then comes the proper pointer metadata(vptr) and all own methods for all\n-    //    other super traits except those already included as part of the first\n-    //    direct super trait virtual table.\n-    // 3. finally, the own methods of this trait.\n-\n-    // This has the advantage that trait upcasting to the first direct super trait on each level\n-    // is zero cost, and to another trait includes only replacing the pointer with one level indirection,\n-    // while not using too much extra memory.\n-\n-    // For a single inheritance relationship like this,\n-    //   D --> C --> B --> A\n-    // The resulting vtable will consists of these segments:\n-    //  DSA, A, B, C, D\n-\n-    // For a multiple inheritance relationship like this,\n-    //   D --> C --> A\n-    //           \\-> B\n-    // The resulting vtable will consists of these segments:\n-    //  DSA, A, B, B-vptr, C, D\n-\n-    // For a diamond inheritance relationship like this,\n-    //   D --> B --> A\n-    //     \\-> C -/\n-    // The resulting vtable will consists of these segments:\n-    //  DSA, A, B, C, C-vptr, D\n-\n-    // For a more complex inheritance relationship like this:\n-    //   O --> G --> C --> A\n-    //     \\     \\     \\-> B\n-    //     |     |-> F --> D\n-    //     |           \\-> E\n-    //     |-> N --> J --> H\n-    //           \\     \\-> I\n-    //           |-> M --> K\n-    //                 \\-> L\n-    // The resulting vtable will consists of these segments:\n-    //  DSA, A, B, B-vptr, C, D, D-vptr, E, E-vptr, F, F-vptr, G,\n-    //  H, H-vptr, I, I-vptr, J, J-vptr, K, K-vptr, L, L-vptr, M, M-vptr,\n-    //  N, N-vptr, O\n-\n-    // emit dsa segment first.\n-    if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::MetadataDSA) {\n-        return Some(v);\n-    }\n-\n-    let mut emit_vptr_on_new_entry = false;\n-    let mut visited = util::PredicateSet::new(tcx);\n-    let predicate = trait_ref.without_const().to_predicate(tcx);\n-    let mut stack: SmallVec<[(ty::PolyTraitRef<'tcx>, _, _); 5]> =\n-        smallvec![(trait_ref, emit_vptr_on_new_entry, None)];\n-    visited.insert(predicate);\n-\n-    // the main traversal loop:\n-    // basically we want to cut the inheritance directed graph into a few non-overlapping slices of nodes\n-    // that each node is emitted after all its descendents have been emitted.\n-    // so we convert the directed graph into a tree by skipping all previously visited nodes using a visited set.\n-    // this is done on the fly.\n-    // Each loop run emits a slice - it starts by find a \"childless\" unvisited node, backtracking upwards, and it\n-    // stops after it finds a node that has a next-sibling node.\n-    // This next-sibling node will used as the starting point of next slice.\n-\n-    // Example:\n-    // For a diamond inheritance relationship like this,\n-    //   D#1 --> B#0 --> A#0\n-    //     \\-> C#1 -/\n-\n-    // Starting point 0 stack [D]\n-    // Loop run #0: Stack after diving in is [D B A], A is \"childless\"\n-    // after this point, all newly visited nodes won't have a vtable that equals to a prefix of this one.\n-    // Loop run #0: Emitting the slice [B A] (in reverse order), B has a next-sibling node, so this slice stops here.\n-    // Loop run #0: Stack after exiting out is [D C], C is the next starting point.\n-    // Loop run #1: Stack after diving in is [D C], C is \"childless\", since its child A is skipped(already emitted).\n-    // Loop run #1: Emitting the slice [D C] (in reverse order). No one has a next-sibling node.\n-    // Loop run #1: Stack after exiting out is []. Now the function exits.\n-\n-    loop {\n-        // dive deeper into the stack, recording the path\n-        'diving_in: loop {\n-            if let Some((inner_most_trait_ref, _, _)) = stack.last() {\n-                let inner_most_trait_ref = *inner_most_trait_ref;\n-                let mut direct_super_traits_iter = tcx\n-                    .super_predicates_of(inner_most_trait_ref.def_id())\n-                    .predicates\n-                    .into_iter()\n-                    .filter_map(move |(pred, _)| {\n-                        pred.subst_supertrait(tcx, &inner_most_trait_ref).to_opt_poly_trait_pred()\n-                    });\n-\n-                'diving_in_skip_visited_traits: loop {\n-                    if let Some(next_super_trait) = direct_super_traits_iter.next() {\n-                        if visited.insert(next_super_trait.to_predicate(tcx)) {\n-                            // We're throwing away potential constness of super traits here.\n-                            // FIXME: handle ~const super traits\n-                            let next_super_trait = next_super_trait.map_bound(|t| t.trait_ref);\n-                            stack.push((\n-                                next_super_trait,\n-                                emit_vptr_on_new_entry,\n-                                Some(direct_super_traits_iter),\n-                            ));\n-                            break 'diving_in_skip_visited_traits;\n-                        } else {\n-                            continue 'diving_in_skip_visited_traits;\n-                        }\n-                    } else {\n-                        break 'diving_in;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Other than the left-most path, vptr should be emitted for each trait.\n-        emit_vptr_on_new_entry = true;\n-\n-        // emit innermost item, move to next sibling and stop there if possible, otherwise jump to outer level.\n-        'exiting_out: loop {\n-            if let Some((inner_most_trait_ref, emit_vptr, siblings_opt)) = stack.last_mut() {\n-                if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::TraitOwnEntries {\n-                    trait_ref: *inner_most_trait_ref,\n-                    emit_vptr: *emit_vptr,\n-                }) {\n-                    return Some(v);\n-                }\n-\n-                'exiting_out_skip_visited_traits: loop {\n-                    if let Some(siblings) = siblings_opt {\n-                        if let Some(next_inner_most_trait_ref) = siblings.next() {\n-                            if visited.insert(next_inner_most_trait_ref.to_predicate(tcx)) {\n-                                // We're throwing away potential constness of super traits here.\n-                                // FIXME: handle ~const super traits\n-                                let next_inner_most_trait_ref =\n-                                    next_inner_most_trait_ref.map_bound(|t| t.trait_ref);\n-                                *inner_most_trait_ref = next_inner_most_trait_ref;\n-                                *emit_vptr = emit_vptr_on_new_entry;\n-                                break 'exiting_out;\n-                            } else {\n-                                continue 'exiting_out_skip_visited_traits;\n-                            }\n-                        }\n-                    }\n-                    stack.pop();\n-                    continue 'exiting_out;\n-                }\n-            }\n-            // all done\n-            return None;\n-        }\n-    }\n-}\n-\n-fn dump_vtable_entries<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    sp: Span,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-    entries: &[VtblEntry<'tcx>],\n-) {\n-    tcx.sess.emit_err(DumpVTableEntries {\n-        span: sp,\n-        trait_ref,\n-        entries: format!(\"{:#?}\", entries),\n-    });\n-}\n-\n-fn own_existential_vtable_entries<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) -> &'tcx [DefId] {\n-    let trait_methods = tcx\n-        .associated_items(trait_def_id)\n-        .in_definition_order()\n-        .filter(|item| item.kind == ty::AssocKind::Fn);\n-    // Now list each method's DefId (for within its trait).\n-    let own_entries = trait_methods.filter_map(move |trait_method| {\n-        debug!(\"own_existential_vtable_entry: trait_method={:?}\", trait_method);\n-        let def_id = trait_method.def_id;\n-\n-        // Some methods cannot be called on an object; skip those.\n-        if !is_vtable_safe_method(tcx, trait_def_id, &trait_method) {\n-            debug!(\"own_existential_vtable_entry: not vtable safe\");\n-            return None;\n-        }\n-\n-        Some(def_id)\n-    });\n-\n-    tcx.arena.alloc_from_iter(own_entries.into_iter())\n-}\n-\n-/// Given a trait `trait_ref`, iterates the vtable entries\n-/// that come from `trait_ref`, including its supertraits.\n-fn vtable_entries<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> &'tcx [VtblEntry<'tcx>] {\n-    debug!(\"vtable_entries({:?})\", trait_ref);\n-\n-    let mut entries = vec![];\n-\n-    let vtable_segment_callback = |segment| -> ControlFlow<()> {\n-        match segment {\n-            VtblSegment::MetadataDSA => {\n-                entries.extend(TyCtxt::COMMON_VTABLE_ENTRIES);\n-            }\n-            VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n-                let existential_trait_ref = trait_ref\n-                    .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n-\n-                // Lookup the shape of vtable for the trait.\n-                let own_existential_entries =\n-                    tcx.own_existential_vtable_entries(existential_trait_ref.def_id());\n-\n-                let own_entries = own_existential_entries.iter().copied().map(|def_id| {\n-                    debug!(\"vtable_entries: trait_method={:?}\", def_id);\n-\n-                    // The method may have some early-bound lifetimes; add regions for those.\n-                    let substs = trait_ref.map_bound(|trait_ref| {\n-                        InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n-                            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                            GenericParamDefKind::Type { .. }\n-                            | GenericParamDefKind::Const { .. } => {\n-                                trait_ref.substs[param.index as usize]\n-                            }\n-                        })\n-                    });\n-\n-                    // The trait type may have higher-ranked lifetimes in it;\n-                    // erase them if they appear, so that we get the type\n-                    // at some particular call site.\n-                    let substs = tcx\n-                        .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n-\n-                    // It's possible that the method relies on where-clauses that\n-                    // do not hold for this particular set of type parameters.\n-                    // Note that this method could then never be called, so we\n-                    // do not want to try and codegen it, in that case (see #23435).\n-                    let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-                    if impossible_predicates(tcx, predicates.predicates) {\n-                        debug!(\"vtable_entries: predicates do not hold\");\n-                        return VtblEntry::Vacant;\n-                    }\n-\n-                    let instance = ty::Instance::resolve_for_vtable(\n-                        tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        def_id,\n-                        substs,\n-                    )\n-                    .expect(\"resolution failed during building vtable representation\");\n-                    VtblEntry::Method(instance)\n-                });\n-\n-                entries.extend(own_entries);\n-\n-                if emit_vptr {\n-                    entries.push(VtblEntry::TraitVPtr(trait_ref));\n-                }\n-            }\n-        }\n-\n-        ControlFlow::Continue(())\n-    };\n-\n-    let _ = prepare_vtable_segments(tcx, trait_ref, vtable_segment_callback);\n-\n-    if tcx.has_attr(trait_ref.def_id(), sym::rustc_dump_vtable) {\n-        let sp = tcx.def_span(trait_ref.def_id());\n-        dump_vtable_entries(tcx, sp, trait_ref, &entries);\n-    }\n-\n-    tcx.arena.alloc_from_iter(entries.into_iter())\n-}\n-\n-/// Find slot base for trait methods within vtable entries of another trait\n-fn vtable_trait_first_method_offset<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: (\n-        ty::PolyTraitRef<'tcx>, // trait_to_be_found\n-        ty::PolyTraitRef<'tcx>, // trait_owning_vtable\n-    ),\n-) -> usize {\n-    let (trait_to_be_found, trait_owning_vtable) = key;\n-\n-    // #90177\n-    let trait_to_be_found_erased = tcx.erase_regions(trait_to_be_found);\n-\n-    let vtable_segment_callback = {\n-        let mut vtable_base = 0;\n-\n-        move |segment| {\n-            match segment {\n-                VtblSegment::MetadataDSA => {\n-                    vtable_base += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n-                }\n-                VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n-                    if tcx.erase_regions(trait_ref) == trait_to_be_found_erased {\n-                        return ControlFlow::Break(vtable_base);\n-                    }\n-                    vtable_base += util::count_own_vtable_entries(tcx, trait_ref);\n-                    if emit_vptr {\n-                        vtable_base += 1;\n-                    }\n-                }\n-            }\n-            ControlFlow::Continue(())\n-        }\n-    };\n-\n-    if let Some(vtable_base) =\n-        prepare_vtable_segments(tcx, trait_owning_vtable, vtable_segment_callback)\n-    {\n-        vtable_base\n-    } else {\n-        bug!(\"Failed to find info for expected trait in vtable\");\n-    }\n-}\n-\n-/// Find slot offset for trait vptr within vtable entries of another trait\n-pub fn vtable_trait_upcasting_coercion_new_vptr_slot<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: (\n-        Ty<'tcx>, // trait object type whose trait owning vtable\n-        Ty<'tcx>, // trait object for supertrait\n-    ),\n-) -> Option<usize> {\n-    let (source, target) = key;\n-    assert!(matches!(&source.kind(), &ty::Dynamic(..)) && !source.needs_infer());\n-    assert!(matches!(&target.kind(), &ty::Dynamic(..)) && !target.needs_infer());\n-\n-    // this has been typecked-before, so diagnostics is not really needed.\n-    let unsize_trait_did = tcx.require_lang_item(LangItem::Unsize, None);\n-\n-    let trait_ref = tcx.mk_trait_ref(unsize_trait_did, [source, target]);\n-\n-    match tcx.codegen_select_candidate((ty::ParamEnv::reveal_all(), ty::Binder::dummy(trait_ref))) {\n-        Ok(ImplSource::TraitUpcasting(implsrc_traitcasting)) => {\n-            implsrc_traitcasting.vtable_vptr_slot\n-        }\n-        otherwise => bug!(\"expected TraitUpcasting candidate, got {otherwise:?}\"),\n-    }\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers) {\n     object_safety::provide(providers);\n+    vtable::provide(providers);\n     *providers = ty::query::Providers {\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n         codegen_select_candidate: codegen::codegen_select_candidate,\n-        own_existential_vtable_entries,\n-        vtable_entries,\n-        vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n         is_impossible_method,\n         ..*providers"}, {"sha": "fda415155c469b556c3206ad8223431625388eaa", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b36035c20f89e33d5acc4f41d913a13700bd77c2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36035c20f89e33d5acc4f41d913a13700bd77c2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=b36035c20f89e33d5acc4f41d913a13700bd77c2", "patch": "@@ -19,14 +19,18 @@ use rustc_span::def_id::DefId;\n \n use crate::traits::project::{normalize_with_depth, normalize_with_depth_to};\n use crate::traits::util::{self, closure_trait_ref_and_return_type, predicate_for_trait_def};\n+use crate::traits::vtable::{\n+    count_own_vtable_entries, prepare_vtable_segments, vtable_trait_first_method_offset,\n+    VtblSegment,\n+};\n use crate::traits::{\n     BuiltinDerivedObligation, ImplDerivedObligation, ImplDerivedObligationCause, ImplSource,\n     ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n     ImplSourceConstDestructData, ImplSourceFnPointerData, ImplSourceFutureData,\n     ImplSourceGeneratorData, ImplSourceObjectData, ImplSourceTraitAliasData,\n     ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized, ObjectCastObligation,\n     Obligation, ObligationCause, OutputTypeParameterMismatch, PredicateObligation, Selection,\n-    SelectionError, TraitNotObjectSafe, TraitObligation, Unimplemented, VtblSegment,\n+    SelectionError, TraitNotObjectSafe, TraitObligation, Unimplemented,\n };\n \n use super::BuiltinImplConditions;\n@@ -583,7 +587,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?nested, \"object nested obligations\");\n \n-        let vtable_base = super::super::vtable_trait_first_method_offset(\n+        let vtable_base = vtable_trait_first_method_offset(\n             tcx,\n             (unnormalized_upcast_trait_ref, ty::Binder::dummy(object_trait_ref)),\n         );\n@@ -904,7 +908,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         vptr_offset += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n                     }\n                     VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n-                        vptr_offset += util::count_own_vtable_entries(tcx, trait_ref);\n+                        vptr_offset += count_own_vtable_entries(tcx, trait_ref);\n                         if trait_ref == upcast_trait_ref {\n                             if emit_vptr {\n                                 return ControlFlow::Break(Some(vptr_offset));\n@@ -923,8 +927,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         let vtable_vptr_slot =\n-            super::super::prepare_vtable_segments(tcx, source_trait_ref, vtable_segment_callback)\n-                .unwrap();\n+            prepare_vtable_segments(tcx, source_trait_ref, vtable_segment_callback).unwrap();\n \n         Ok(ImplSourceTraitUpcastingData { upcast_trait_ref, vtable_vptr_slot, nested })\n     }"}, {"sha": "f3ca6a6c779a06b9ca34b584dde18fe5775f0516", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b36035c20f89e33d5acc4f41d913a13700bd77c2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36035c20f89e33d5acc4f41d913a13700bd77c2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=b36035c20f89e33d5acc4f41d913a13700bd77c2", "patch": "@@ -261,16 +261,6 @@ pub fn upcast_choices<'tcx>(\n     supertraits(tcx, source_trait_ref).filter(|r| r.def_id() == target_trait_def_id).collect()\n }\n \n-/// Given a trait `trait_ref`, returns the number of vtable entries\n-/// that come from `trait_ref`, excluding its supertraits. Used in\n-/// computing the vtable base for an upcast trait of a trait object.\n-pub fn count_own_vtable_entries<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> usize {\n-    tcx.own_existential_vtable_entries(trait_ref.def_id()).len()\n-}\n-\n /// Given an upcast trait object described by `object`, returns the\n /// index of the method `method_def_id` (which should be part of\n /// `object.upcast_trait_ref`) within the vtable for `object`."}, {"sha": "41ce6cdf789da381d32e3ec2f158faf63045afe9", "filename": "compiler/rustc_trait_selection/src/traits/vtable.rs", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/b36035c20f89e33d5acc4f41d913a13700bd77c2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36035c20f89e33d5acc4f41d913a13700bd77c2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs?ref=b36035c20f89e33d5acc4f41d913a13700bd77c2", "patch": "@@ -0,0 +1,386 @@\n+use crate::errors::DumpVTableEntries;\n+use crate::traits::{impossible_predicates, is_vtable_safe_method};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItem;\n+use rustc_infer::traits::util::PredicateSet;\n+use rustc_infer::traits::ImplSource;\n+use rustc_middle::ty::visit::TypeVisitable;\n+use rustc_middle::ty::InternalSubsts;\n+use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, VtblEntry};\n+use rustc_span::{sym, Span};\n+use smallvec::SmallVec;\n+\n+use std::fmt::Debug;\n+use std::ops::ControlFlow;\n+\n+#[derive(Clone, Debug)]\n+pub(super) enum VtblSegment<'tcx> {\n+    MetadataDSA,\n+    TraitOwnEntries { trait_ref: ty::PolyTraitRef<'tcx>, emit_vptr: bool },\n+}\n+\n+/// Prepare the segments for a vtable\n+pub(super) fn prepare_vtable_segments<'tcx, T>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    mut segment_visitor: impl FnMut(VtblSegment<'tcx>) -> ControlFlow<T>,\n+) -> Option<T> {\n+    // The following constraints holds for the final arrangement.\n+    // 1. The whole virtual table of the first direct super trait is included as the\n+    //    the prefix. If this trait doesn't have any super traits, then this step\n+    //    consists of the dsa metadata.\n+    // 2. Then comes the proper pointer metadata(vptr) and all own methods for all\n+    //    other super traits except those already included as part of the first\n+    //    direct super trait virtual table.\n+    // 3. finally, the own methods of this trait.\n+\n+    // This has the advantage that trait upcasting to the first direct super trait on each level\n+    // is zero cost, and to another trait includes only replacing the pointer with one level indirection,\n+    // while not using too much extra memory.\n+\n+    // For a single inheritance relationship like this,\n+    //   D --> C --> B --> A\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, C, D\n+\n+    // For a multiple inheritance relationship like this,\n+    //   D --> C --> A\n+    //           \\-> B\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, B-vptr, C, D\n+\n+    // For a diamond inheritance relationship like this,\n+    //   D --> B --> A\n+    //     \\-> C -/\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, C, C-vptr, D\n+\n+    // For a more complex inheritance relationship like this:\n+    //   O --> G --> C --> A\n+    //     \\     \\     \\-> B\n+    //     |     |-> F --> D\n+    //     |           \\-> E\n+    //     |-> N --> J --> H\n+    //           \\     \\-> I\n+    //           |-> M --> K\n+    //                 \\-> L\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, B-vptr, C, D, D-vptr, E, E-vptr, F, F-vptr, G,\n+    //  H, H-vptr, I, I-vptr, J, J-vptr, K, K-vptr, L, L-vptr, M, M-vptr,\n+    //  N, N-vptr, O\n+\n+    // emit dsa segment first.\n+    if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::MetadataDSA) {\n+        return Some(v);\n+    }\n+\n+    let mut emit_vptr_on_new_entry = false;\n+    let mut visited = PredicateSet::new(tcx);\n+    let predicate = trait_ref.without_const().to_predicate(tcx);\n+    let mut stack: SmallVec<[(ty::PolyTraitRef<'tcx>, _, _); 5]> =\n+        smallvec![(trait_ref, emit_vptr_on_new_entry, None)];\n+    visited.insert(predicate);\n+\n+    // the main traversal loop:\n+    // basically we want to cut the inheritance directed graph into a few non-overlapping slices of nodes\n+    // that each node is emitted after all its descendents have been emitted.\n+    // so we convert the directed graph into a tree by skipping all previously visited nodes using a visited set.\n+    // this is done on the fly.\n+    // Each loop run emits a slice - it starts by find a \"childless\" unvisited node, backtracking upwards, and it\n+    // stops after it finds a node that has a next-sibling node.\n+    // This next-sibling node will used as the starting point of next slice.\n+\n+    // Example:\n+    // For a diamond inheritance relationship like this,\n+    //   D#1 --> B#0 --> A#0\n+    //     \\-> C#1 -/\n+\n+    // Starting point 0 stack [D]\n+    // Loop run #0: Stack after diving in is [D B A], A is \"childless\"\n+    // after this point, all newly visited nodes won't have a vtable that equals to a prefix of this one.\n+    // Loop run #0: Emitting the slice [B A] (in reverse order), B has a next-sibling node, so this slice stops here.\n+    // Loop run #0: Stack after exiting out is [D C], C is the next starting point.\n+    // Loop run #1: Stack after diving in is [D C], C is \"childless\", since its child A is skipped(already emitted).\n+    // Loop run #1: Emitting the slice [D C] (in reverse order). No one has a next-sibling node.\n+    // Loop run #1: Stack after exiting out is []. Now the function exits.\n+\n+    loop {\n+        // dive deeper into the stack, recording the path\n+        'diving_in: loop {\n+            if let Some((inner_most_trait_ref, _, _)) = stack.last() {\n+                let inner_most_trait_ref = *inner_most_trait_ref;\n+                let mut direct_super_traits_iter = tcx\n+                    .super_predicates_of(inner_most_trait_ref.def_id())\n+                    .predicates\n+                    .into_iter()\n+                    .filter_map(move |(pred, _)| {\n+                        pred.subst_supertrait(tcx, &inner_most_trait_ref).to_opt_poly_trait_pred()\n+                    });\n+\n+                'diving_in_skip_visited_traits: loop {\n+                    if let Some(next_super_trait) = direct_super_traits_iter.next() {\n+                        if visited.insert(next_super_trait.to_predicate(tcx)) {\n+                            // We're throwing away potential constness of super traits here.\n+                            // FIXME: handle ~const super traits\n+                            let next_super_trait = next_super_trait.map_bound(|t| t.trait_ref);\n+                            stack.push((\n+                                next_super_trait,\n+                                emit_vptr_on_new_entry,\n+                                Some(direct_super_traits_iter),\n+                            ));\n+                            break 'diving_in_skip_visited_traits;\n+                        } else {\n+                            continue 'diving_in_skip_visited_traits;\n+                        }\n+                    } else {\n+                        break 'diving_in;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Other than the left-most path, vptr should be emitted for each trait.\n+        emit_vptr_on_new_entry = true;\n+\n+        // emit innermost item, move to next sibling and stop there if possible, otherwise jump to outer level.\n+        'exiting_out: loop {\n+            if let Some((inner_most_trait_ref, emit_vptr, siblings_opt)) = stack.last_mut() {\n+                if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::TraitOwnEntries {\n+                    trait_ref: *inner_most_trait_ref,\n+                    emit_vptr: *emit_vptr,\n+                }) {\n+                    return Some(v);\n+                }\n+\n+                'exiting_out_skip_visited_traits: loop {\n+                    if let Some(siblings) = siblings_opt {\n+                        if let Some(next_inner_most_trait_ref) = siblings.next() {\n+                            if visited.insert(next_inner_most_trait_ref.to_predicate(tcx)) {\n+                                // We're throwing away potential constness of super traits here.\n+                                // FIXME: handle ~const super traits\n+                                let next_inner_most_trait_ref =\n+                                    next_inner_most_trait_ref.map_bound(|t| t.trait_ref);\n+                                *inner_most_trait_ref = next_inner_most_trait_ref;\n+                                *emit_vptr = emit_vptr_on_new_entry;\n+                                break 'exiting_out;\n+                            } else {\n+                                continue 'exiting_out_skip_visited_traits;\n+                            }\n+                        }\n+                    }\n+                    stack.pop();\n+                    continue 'exiting_out;\n+                }\n+            }\n+            // all done\n+            return None;\n+        }\n+    }\n+}\n+\n+fn dump_vtable_entries<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sp: Span,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    entries: &[VtblEntry<'tcx>],\n+) {\n+    tcx.sess.emit_err(DumpVTableEntries {\n+        span: sp,\n+        trait_ref,\n+        entries: format!(\"{:#?}\", entries),\n+    });\n+}\n+\n+fn own_existential_vtable_entries<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) -> &'tcx [DefId] {\n+    let trait_methods = tcx\n+        .associated_items(trait_def_id)\n+        .in_definition_order()\n+        .filter(|item| item.kind == ty::AssocKind::Fn);\n+    // Now list each method's DefId (for within its trait).\n+    let own_entries = trait_methods.filter_map(move |trait_method| {\n+        debug!(\"own_existential_vtable_entry: trait_method={:?}\", trait_method);\n+        let def_id = trait_method.def_id;\n+\n+        // Some methods cannot be called on an object; skip those.\n+        if !is_vtable_safe_method(tcx, trait_def_id, &trait_method) {\n+            debug!(\"own_existential_vtable_entry: not vtable safe\");\n+            return None;\n+        }\n+\n+        Some(def_id)\n+    });\n+\n+    tcx.arena.alloc_from_iter(own_entries.into_iter())\n+}\n+\n+/// Given a trait `trait_ref`, iterates the vtable entries\n+/// that come from `trait_ref`, including its supertraits.\n+fn vtable_entries<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> &'tcx [VtblEntry<'tcx>] {\n+    debug!(\"vtable_entries({:?})\", trait_ref);\n+\n+    let mut entries = vec![];\n+\n+    let vtable_segment_callback = |segment| -> ControlFlow<()> {\n+        match segment {\n+            VtblSegment::MetadataDSA => {\n+                entries.extend(TyCtxt::COMMON_VTABLE_ENTRIES);\n+            }\n+            VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                let existential_trait_ref = trait_ref\n+                    .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n+\n+                // Lookup the shape of vtable for the trait.\n+                let own_existential_entries =\n+                    tcx.own_existential_vtable_entries(existential_trait_ref.def_id());\n+\n+                let own_entries = own_existential_entries.iter().copied().map(|def_id| {\n+                    debug!(\"vtable_entries: trait_method={:?}\", def_id);\n+\n+                    // The method may have some early-bound lifetimes; add regions for those.\n+                    let substs = trait_ref.map_bound(|trait_ref| {\n+                        InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n+                            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+                            GenericParamDefKind::Type { .. }\n+                            | GenericParamDefKind::Const { .. } => {\n+                                trait_ref.substs[param.index as usize]\n+                            }\n+                        })\n+                    });\n+\n+                    // The trait type may have higher-ranked lifetimes in it;\n+                    // erase them if they appear, so that we get the type\n+                    // at some particular call site.\n+                    let substs = tcx\n+                        .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n+\n+                    // It's possible that the method relies on where-clauses that\n+                    // do not hold for this particular set of type parameters.\n+                    // Note that this method could then never be called, so we\n+                    // do not want to try and codegen it, in that case (see #23435).\n+                    let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n+                    if impossible_predicates(tcx, predicates.predicates) {\n+                        debug!(\"vtable_entries: predicates do not hold\");\n+                        return VtblEntry::Vacant;\n+                    }\n+\n+                    let instance = ty::Instance::resolve_for_vtable(\n+                        tcx,\n+                        ty::ParamEnv::reveal_all(),\n+                        def_id,\n+                        substs,\n+                    )\n+                    .expect(\"resolution failed during building vtable representation\");\n+                    VtblEntry::Method(instance)\n+                });\n+\n+                entries.extend(own_entries);\n+\n+                if emit_vptr {\n+                    entries.push(VtblEntry::TraitVPtr(trait_ref));\n+                }\n+            }\n+        }\n+\n+        ControlFlow::Continue(())\n+    };\n+\n+    let _ = prepare_vtable_segments(tcx, trait_ref, vtable_segment_callback);\n+\n+    if tcx.has_attr(trait_ref.def_id(), sym::rustc_dump_vtable) {\n+        let sp = tcx.def_span(trait_ref.def_id());\n+        dump_vtable_entries(tcx, sp, trait_ref, &entries);\n+    }\n+\n+    tcx.arena.alloc_from_iter(entries.into_iter())\n+}\n+\n+/// Find slot base for trait methods within vtable entries of another trait\n+pub(super) fn vtable_trait_first_method_offset<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (\n+        ty::PolyTraitRef<'tcx>, // trait_to_be_found\n+        ty::PolyTraitRef<'tcx>, // trait_owning_vtable\n+    ),\n+) -> usize {\n+    let (trait_to_be_found, trait_owning_vtable) = key;\n+\n+    // #90177\n+    let trait_to_be_found_erased = tcx.erase_regions(trait_to_be_found);\n+\n+    let vtable_segment_callback = {\n+        let mut vtable_base = 0;\n+\n+        move |segment| {\n+            match segment {\n+                VtblSegment::MetadataDSA => {\n+                    vtable_base += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n+                }\n+                VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                    if tcx.erase_regions(trait_ref) == trait_to_be_found_erased {\n+                        return ControlFlow::Break(vtable_base);\n+                    }\n+                    vtable_base += count_own_vtable_entries(tcx, trait_ref);\n+                    if emit_vptr {\n+                        vtable_base += 1;\n+                    }\n+                }\n+            }\n+            ControlFlow::Continue(())\n+        }\n+    };\n+\n+    if let Some(vtable_base) =\n+        prepare_vtable_segments(tcx, trait_owning_vtable, vtable_segment_callback)\n+    {\n+        vtable_base\n+    } else {\n+        bug!(\"Failed to find info for expected trait in vtable\");\n+    }\n+}\n+\n+/// Find slot offset for trait vptr within vtable entries of another trait\n+pub(crate) fn vtable_trait_upcasting_coercion_new_vptr_slot<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (\n+        Ty<'tcx>, // trait object type whose trait owning vtable\n+        Ty<'tcx>, // trait object for supertrait\n+    ),\n+) -> Option<usize> {\n+    let (source, target) = key;\n+    assert!(matches!(&source.kind(), &ty::Dynamic(..)) && !source.needs_infer());\n+    assert!(matches!(&target.kind(), &ty::Dynamic(..)) && !target.needs_infer());\n+\n+    // this has been typecked-before, so diagnostics is not really needed.\n+    let unsize_trait_did = tcx.require_lang_item(LangItem::Unsize, None);\n+\n+    let trait_ref = tcx.mk_trait_ref(unsize_trait_did, [source, target]);\n+\n+    match tcx.codegen_select_candidate((ty::ParamEnv::reveal_all(), ty::Binder::dummy(trait_ref))) {\n+        Ok(ImplSource::TraitUpcasting(implsrc_traitcasting)) => {\n+            implsrc_traitcasting.vtable_vptr_slot\n+        }\n+        otherwise => bug!(\"expected TraitUpcasting candidate, got {otherwise:?}\"),\n+    }\n+}\n+\n+/// Given a trait `trait_ref`, returns the number of vtable entries\n+/// that come from `trait_ref`, excluding its supertraits. Used in\n+/// computing the vtable base for an upcast trait of a trait object.\n+pub(crate) fn count_own_vtable_entries<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> usize {\n+    tcx.own_existential_vtable_entries(trait_ref.def_id()).len()\n+}\n+\n+pub(super) fn provide(providers: &mut ty::query::Providers) {\n+    *providers = ty::query::Providers {\n+        own_existential_vtable_entries,\n+        vtable_entries,\n+        vtable_trait_upcasting_coercion_new_vptr_slot,\n+        ..*providers\n+    };\n+}"}]}