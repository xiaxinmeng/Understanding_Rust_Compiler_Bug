{"sha": "95285c496f58a326eace11bddb25a7ce7adcfe44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1Mjg1YzQ5NmY1OGEzMjZlYWNlMTFiZGRiMjVhN2NlN2FkY2ZlNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-08T14:04:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-08T14:04:41Z"}, "message": "Auto merge of #28621 - tshepang:move-safety, r=steveklabnik", "tree": {"sha": "e393951e7713951d16c1296225235368be3a07a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e393951e7713951d16c1296225235368be3a07a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95285c496f58a326eace11bddb25a7ce7adcfe44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95285c496f58a326eace11bddb25a7ce7adcfe44", "html_url": "https://github.com/rust-lang/rust/commit/95285c496f58a326eace11bddb25a7ce7adcfe44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95285c496f58a326eace11bddb25a7ce7adcfe44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc", "html_url": "https://github.com/rust-lang/rust/commit/b75fe81055f58b6de45ff6f9c5d40772dc1fa6dc"}, {"sha": "4a5e190d46336e1daf209791de65f534b4496c4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a5e190d46336e1daf209791de65f534b4496c4d", "html_url": "https://github.com/rust-lang/rust/commit/4a5e190d46336e1daf209791de65f534b4496c4d"}], "stats": {"total": 186, "additions": 93, "deletions": 93}, "files": [{"sha": "a3fda91a6cf0042270dc3e1e8b238a96d22be2a7", "filename": "src/doc/reference.md", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/95285c496f58a326eace11bddb25a7ce7adcfe44/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/95285c496f58a326eace11bddb25a7ce7adcfe44/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=95285c496f58a326eace11bddb25a7ce7adcfe44", "patch": "@@ -984,99 +984,6 @@ The type parameters can also be explicitly supplied in a trailing\n there is not sufficient context to determine the type parameters. For example,\n `mem::size_of::<u32>() == 4`.\n \n-#### Unsafety\n-\n-Unsafe operations are those that potentially violate the memory-safety\n-guarantees of Rust's static semantics.\n-\n-The following language level features cannot be used in the safe subset of\n-Rust:\n-\n-- Dereferencing a [raw pointer](#pointer-types).\n-- Reading or writing a [mutable static variable](#mutable-statics).\n-- Calling an unsafe function (including an intrinsic or foreign function).\n-\n-##### Unsafe functions\n-\n-Unsafe functions are functions that are not safe in all contexts and/or for all\n-possible inputs. Such a function must be prefixed with the keyword `unsafe` and\n-can only be called from an `unsafe` block or another `unsafe` function.\n-\n-##### Unsafe blocks\n-\n-A block of code can be prefixed with the `unsafe` keyword, to permit calling\n-`unsafe` functions or dereferencing raw pointers within a safe function.\n-\n-When a programmer has sufficient conviction that a sequence of potentially\n-unsafe operations is actually safe, they can encapsulate that sequence (taken\n-as a whole) within an `unsafe` block. The compiler will consider uses of such\n-code safe, in the surrounding context.\n-\n-Unsafe blocks are used to wrap foreign libraries, make direct use of hardware\n-or implement features not directly present in the language. For example, Rust\n-provides the language features necessary to implement memory-safe concurrency\n-in the language but the implementation of threads and message passing is in the\n-standard library.\n-\n-Rust's type system is a conservative approximation of the dynamic safety\n-requirements, so in some cases there is a performance cost to using safe code.\n-For example, a doubly-linked list is not a tree structure and can only be\n-represented with reference-counted pointers in safe code. By using `unsafe`\n-blocks to represent the reverse links as raw pointers, it can be implemented\n-with only boxes.\n-\n-##### Behavior considered undefined\n-\n-The following is a list of behavior which is forbidden in all Rust code,\n-including within `unsafe` blocks and `unsafe` functions. Type checking provides\n-the guarantee that these issues are never caused by safe code.\n-\n-* Data races\n-* Dereferencing a null/dangling raw pointer\n-* Reads of [undef](http://llvm.org/docs/LangRef.html#undefined-values)\n-  (uninitialized) memory\n-* Breaking the [pointer aliasing\n-  rules](http://llvm.org/docs/LangRef.html#pointer-aliasing-rules)\n-  with raw pointers (a subset of the rules used by C)\n-* `&mut` and `&` follow LLVM\u2019s scoped [noalias] model, except if the `&T`\n-  contains an `UnsafeCell<U>`. Unsafe code must not violate these aliasing\n-  guarantees.\n-* Mutating non-mutable data (that is, data reached through a shared reference or\n-  data owned by a `let` binding), unless that data is contained within an `UnsafeCell<U>`.\n-* Invoking undefined behavior via compiler intrinsics:\n-  * Indexing outside of the bounds of an object with `std::ptr::offset`\n-    (`offset` intrinsic), with\n-    the exception of one byte past the end which is permitted.\n-  * Using `std::ptr::copy_nonoverlapping_memory` (`memcpy32`/`memcpy64`\n-    intrinsics) on overlapping buffers\n-* Invalid values in primitive types, even in private fields/locals:\n-  * Dangling/null references or boxes\n-  * A value other than `false` (0) or `true` (1) in a `bool`\n-  * A discriminant in an `enum` not included in the type definition\n-  * A value in a `char` which is a surrogate or above `char::MAX`\n-  * Non-UTF-8 byte sequences in a `str`\n-* Unwinding into Rust from foreign code or unwinding from Rust into foreign\n-  code. Rust's failure system is not compatible with exception handling in\n-  other languages. Unwinding must be caught and handled at FFI boundaries.\n-\n-[noalias]: http://llvm.org/docs/LangRef.html#noalias\n-\n-##### Behavior not considered unsafe\n-\n-This is a list of behavior not considered *unsafe* in Rust terms, but that may\n-be undesired.\n-\n-* Deadlocks\n-* Leaks of memory and other resources\n-* Exiting without calling destructors\n-* Integer overflow\n-  - Overflow is considered \"unexpected\" behavior and is always user-error,\n-    unless the `wrapping` primitives are used. In non-optimized builds, the compiler\n-    will insert debug checks that panic on overflow, but in optimized builds overflow\n-    instead results in wrapped values. See [RFC 560] for the rationale and more details.\n-\n-[RFC 560]: https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md\n-\n #### Diverging functions\n \n A special kind of function can be declared with a `!` character where the\n@@ -4050,6 +3957,99 @@ In general, `--crate-type=bin` or `--crate-type=lib` should be sufficient for\n all compilation needs, and the other options are just available if more\n fine-grained control is desired over the output format of a Rust crate.\n \n+# Unsafety\n+\n+Unsafe operations are those that potentially violate the memory-safety\n+guarantees of Rust's static semantics.\n+\n+The following language level features cannot be used in the safe subset of\n+Rust:\n+\n+- Dereferencing a [raw pointer](#pointer-types).\n+- Reading or writing a [mutable static variable](#mutable-statics).\n+- Calling an unsafe function (including an intrinsic or foreign function).\n+\n+## Unsafe functions\n+\n+Unsafe functions are functions that are not safe in all contexts and/or for all\n+possible inputs. Such a function must be prefixed with the keyword `unsafe` and\n+can only be called from an `unsafe` block or another `unsafe` function.\n+\n+## Unsafe blocks\n+\n+A block of code can be prefixed with the `unsafe` keyword, to permit calling\n+`unsafe` functions or dereferencing raw pointers within a safe function.\n+\n+When a programmer has sufficient conviction that a sequence of potentially\n+unsafe operations is actually safe, they can encapsulate that sequence (taken\n+as a whole) within an `unsafe` block. The compiler will consider uses of such\n+code safe, in the surrounding context.\n+\n+Unsafe blocks are used to wrap foreign libraries, make direct use of hardware\n+or implement features not directly present in the language. For example, Rust\n+provides the language features necessary to implement memory-safe concurrency\n+in the language but the implementation of threads and message passing is in the\n+standard library.\n+\n+Rust's type system is a conservative approximation of the dynamic safety\n+requirements, so in some cases there is a performance cost to using safe code.\n+For example, a doubly-linked list is not a tree structure and can only be\n+represented with reference-counted pointers in safe code. By using `unsafe`\n+blocks to represent the reverse links as raw pointers, it can be implemented\n+with only boxes.\n+\n+## Behavior considered undefined\n+\n+The following is a list of behavior which is forbidden in all Rust code,\n+including within `unsafe` blocks and `unsafe` functions. Type checking provides\n+the guarantee that these issues are never caused by safe code.\n+\n+* Data races\n+* Dereferencing a null/dangling raw pointer\n+* Reads of [undef](http://llvm.org/docs/LangRef.html#undefined-values)\n+  (uninitialized) memory\n+* Breaking the [pointer aliasing\n+  rules](http://llvm.org/docs/LangRef.html#pointer-aliasing-rules)\n+  with raw pointers (a subset of the rules used by C)\n+* `&mut` and `&` follow LLVM\u2019s scoped [noalias] model, except if the `&T`\n+  contains an `UnsafeCell<U>`. Unsafe code must not violate these aliasing\n+  guarantees.\n+* Mutating non-mutable data (that is, data reached through a shared reference or\n+  data owned by a `let` binding), unless that data is contained within an `UnsafeCell<U>`.\n+* Invoking undefined behavior via compiler intrinsics:\n+  * Indexing outside of the bounds of an object with `std::ptr::offset`\n+    (`offset` intrinsic), with\n+    the exception of one byte past the end which is permitted.\n+  * Using `std::ptr::copy_nonoverlapping_memory` (`memcpy32`/`memcpy64`\n+    intrinsics) on overlapping buffers\n+* Invalid values in primitive types, even in private fields/locals:\n+  * Dangling/null references or boxes\n+  * A value other than `false` (0) or `true` (1) in a `bool`\n+  * A discriminant in an `enum` not included in the type definition\n+  * A value in a `char` which is a surrogate or above `char::MAX`\n+  * Non-UTF-8 byte sequences in a `str`\n+* Unwinding into Rust from foreign code or unwinding from Rust into foreign\n+  code. Rust's failure system is not compatible with exception handling in\n+  other languages. Unwinding must be caught and handled at FFI boundaries.\n+\n+[noalias]: http://llvm.org/docs/LangRef.html#noalias\n+\n+## Behavior not considered unsafe\n+\n+This is a list of behavior not considered *unsafe* in Rust terms, but that may\n+be undesired.\n+\n+* Deadlocks\n+* Leaks of memory and other resources\n+* Exiting without calling destructors\n+* Integer overflow\n+  - Overflow is considered \"unexpected\" behavior and is always user-error,\n+    unless the `wrapping` primitives are used. In non-optimized builds, the compiler\n+    will insert debug checks that panic on overflow, but in optimized builds overflow\n+    instead results in wrapped values. See [RFC 560] for the rationale and more details.\n+\n+[RFC 560]: https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md\n+\n # Appendix: Influences\n \n Rust is not a particularly original language, with design elements coming from"}]}