{"sha": "f727f8ae5e1663557904c23438ea9525d50e9abc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3MjdmOGFlNWUxNjYzNTU3OTA0YzIzNDM4ZWE5NTI1ZDUwZTlhYmM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-10-12T11:31:58Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-10-12T11:31:58Z"}, "message": "move Formatting Traits down", "tree": {"sha": "e0338671903e5b3bdf01e0e9e1e85b06427ebe7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0338671903e5b3bdf01e0e9e1e85b06427ebe7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f727f8ae5e1663557904c23438ea9525d50e9abc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f727f8ae5e1663557904c23438ea9525d50e9abc", "html_url": "https://github.com/rust-lang/rust/commit/f727f8ae5e1663557904c23438ea9525d50e9abc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f727f8ae5e1663557904c23438ea9525d50e9abc/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a14601e06cba5bf4418f298929c2fad009bdbc51", "url": "https://api.github.com/repos/rust-lang/rust/commits/a14601e06cba5bf4418f298929c2fad009bdbc51", "html_url": "https://github.com/rust-lang/rust/commit/a14601e06cba5bf4418f298929c2fad009bdbc51"}], "stats": {"total": 364, "additions": 182, "deletions": 182}, "files": [{"sha": "bdd1583080bf4748e069f568bc26ac2111598da1", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 182, "deletions": 182, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/f727f8ae5e1663557904c23438ea9525d50e9abc/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f727f8ae5e1663557904c23438ea9525d50e9abc/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=f727f8ae5e1663557904c23438ea9525d50e9abc", "patch": "@@ -97,7 +97,187 @@\n //! actual object being formatted, and the number of characters must have the\n //! type [`usize`].\n //!\n-//! ## Formatting traits\n+//! # Formatting Parameters\n+//!\n+//! Each argument being formatted can be transformed by a number of formatting\n+//! parameters (corresponding to `format_spec` in the syntax above). These\n+//! parameters affect the string representation of what's being formatted.\n+//!\n+//! ## Fill/Alignment\n+//!\n+//! The fill character is provided normally in conjunction with the\n+//! [`width`](#width)\n+//! parameter. This indicates that if the value being formatted is smaller than\n+//! `width` some extra characters will be printed around it. The extra\n+//! characters are specified by `fill`, and the alignment can be one of the\n+//! following options:\n+//!\n+//! * `<` - the argument is left-aligned in `width` columns\n+//! * `^` - the argument is center-aligned in `width` columns\n+//! * `>` - the argument is right-aligned in `width` columns\n+//!\n+//! Note that alignment may not be implemented by some types. In particular, it\n+//! is not generally implemented for the `Debug` trait.  A good way to ensure\n+//! padding is applied is to format your input, then use this resulting string\n+//! to pad your output.\n+//!\n+//! ## Sign/`#`/`0`\n+//!\n+//! These can all be interpreted as flags for a particular formatter.\n+//!\n+//! * `+` - This is intended for numeric types and indicates that the sign\n+//!         should always be printed. Positive signs are never printed by\n+//!         default, and the negative sign is only printed by default for the\n+//!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n+//!         should always be printed.\n+//! * `-` - Currently not used\n+//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n+//!         be used. The alternate forms are:\n+//!     * `#?` - pretty-print the [`Debug`] formatting\n+//!     * `#x` - precedes the argument with a `0x`\n+//!     * `#X` - precedes the argument with a `0x`\n+//!     * `#b` - precedes the argument with a `0b`\n+//!     * `#o` - precedes the argument with a `0o`\n+//! * `0` - This is used to indicate for integer formats that the padding should\n+//!         both be done with a `0` character as well as be sign-aware. A format\n+//!         like `{:08}` would yield `00000001` for the integer `1`, while the\n+//!         same format would yield `-0000001` for the integer `-1`. Notice that\n+//!         the negative version has one fewer zero than the positive version.\n+//!         Note that padding zeroes are always placed after the sign (if any)\n+//!         and before the digits. When used together with the `#` flag, a similar\n+//!         rule applies: padding zeroes are inserted after the prefix but before\n+//!         the digits.\n+//!\n+//! ## Width\n+//!\n+//! This is a parameter for the \"minimum width\" that the format should take up.\n+//! If the value's string does not fill up this many characters, then the\n+//! padding specified by fill/alignment will be used to take up the required\n+//! space.\n+//!\n+//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n+//! left-aligned. The\n+//! defaults for numeric formatters is also a space but with right-alignment. If\n+//! the `0` flag is specified for numerics, then the implicit fill character is\n+//! `0`.\n+//!\n+//! The value for the width can also be provided as a [`usize`] in the list of\n+//! parameters by using the dollar syntax indicating that the second argument is\n+//! a [`usize`] specifying the width, for example:\n+//!\n+//! ```\n+//! // All of these print \"Hello x    !\"\n+//! println!(\"Hello {:5}!\", \"x\");\n+//! println!(\"Hello {:1$}!\", \"x\", 5);\n+//! println!(\"Hello {1:0$}!\", 5, \"x\");\n+//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n+//! ```\n+//!\n+//! Referring to an argument with the dollar syntax does not affect the \"next\n+//! argument\" counter, so it's usually a good idea to refer to arguments by\n+//! position, or use named arguments.\n+//!\n+//! ## Precision\n+//!\n+//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n+//! longer than this width, then it is truncated down to this many characters and that truncated\n+//! value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n+//!\n+//! For integral types, this is ignored.\n+//!\n+//! For floating-point types, this indicates how many digits after the decimal point should be\n+//! printed.\n+//!\n+//! There are three possible ways to specify the desired `precision`:\n+//!\n+//! 1. An integer `.N`:\n+//!\n+//!    the integer `N` itself is the precision.\n+//!\n+//! 2. An integer or name followed by dollar sign `.N$`:\n+//!\n+//!    use format *argument* `N` (which must be a `usize`) as the precision.\n+//!\n+//! 3. An asterisk `.*`:\n+//!\n+//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n+//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n+//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n+//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n+//!\n+//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n+//!\n+//! ```\n+//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n+//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n+//!\n+//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n+//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n+//!\n+//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n+//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n+//! //                          specified in first of next two args (5)}\n+//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n+//! //                          specified in its predecessor (5)}\n+//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n+//! //                          in arg \"prec\" (5)}\n+//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n+//! ```\n+//!\n+//! While these:\n+//!\n+//! ```\n+//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n+//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n+//! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n+//! ```\n+//!\n+//! print two significantly different things:\n+//!\n+//! ```text\n+//! Hello, `1234.560` has 3 fractional digits\n+//! Hello, `123` has 3 characters\n+//! Hello, `     123` has 3 right-aligned characters\n+//! ```\n+//!\n+//! # Escaping\n+//!\n+//! The literal characters `{` and `}` may be included in a string by preceding\n+//! them with the same character. For example, the `{` character is escaped with\n+//! `{{` and the `}` character is escaped with `}}`.\n+//!\n+//! # Syntax\n+//!\n+//! To summarize, you can find the full grammar of format strings.\n+//! The syntax for the formatting language used is drawn from other languages,\n+//! so it should not be too alien. Arguments are formatted with Python-like\n+//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n+//! `%`. The actual grammar for the formatting syntax is:\n+//!\n+//! ```text\n+//! format_string := <text> [ maybe-format <text> ] *\n+//! maybe-format := '{' '{' | '}' '}' | <format>\n+//! format := '{' [ argument ] [ ':' format_spec ] '}'\n+//! argument := integer | identifier\n+//!\n+//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n+//! fill := character\n+//! align := '<' | '^' | '>'\n+//! sign := '+' | '-'\n+//! width := count\n+//! precision := count | '*'\n+//! type := identifier | '?' | ''\n+//! count := parameter | integer\n+//! parameter := argument '$'\n+//! ```\n+//!\n+//! # Formatting traits\n //!\n //! When requesting that an argument be formatted with a particular type, you\n //! are actually requesting that an argument ascribes to a particular trait.\n@@ -220,7 +400,7 @@\n //! assert_eq!(format!(\"{} {:?}\", \"foo\\n\", \"bar\\n\"), \"foo\\n \\\"bar\\\\n\\\"\");\n //! ```\n //!\n-//! ## Related macros\n+//! # Related macros\n //!\n //! There are a number of related macros in the [`format!`] family. The ones that\n //! are currently implemented are:\n@@ -300,186 +480,6 @@\n //! it would internally pass around this structure until it has been determined\n //! where output should go to.\n //!\n-//! # Formatting Parameters\n-//!\n-//! Each argument being formatted can be transformed by a number of formatting\n-//! parameters (corresponding to `format_spec` in the syntax above). These\n-//! parameters affect the string representation of what's being formatted.\n-//!\n-//! ## Fill/Alignment\n-//!\n-//! The fill character is provided normally in conjunction with the\n-//! [`width`](#width)\n-//! parameter. This indicates that if the value being formatted is smaller than\n-//! `width` some extra characters will be printed around it. The extra\n-//! characters are specified by `fill`, and the alignment can be one of the\n-//! following options:\n-//!\n-//! * `<` - the argument is left-aligned in `width` columns\n-//! * `^` - the argument is center-aligned in `width` columns\n-//! * `>` - the argument is right-aligned in `width` columns\n-//!\n-//! Note that alignment may not be implemented by some types. In particular, it\n-//! is not generally implemented for the `Debug` trait.  A good way to ensure\n-//! padding is applied is to format your input, then use this resulting string\n-//! to pad your output.\n-//!\n-//! ## Sign/`#`/`0`\n-//!\n-//! These can all be interpreted as flags for a particular formatter.\n-//!\n-//! * `+` - This is intended for numeric types and indicates that the sign\n-//!         should always be printed. Positive signs are never printed by\n-//!         default, and the negative sign is only printed by default for the\n-//!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n-//!         should always be printed.\n-//! * `-` - Currently not used\n-//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n-//!         be used. The alternate forms are:\n-//!     * `#?` - pretty-print the [`Debug`] formatting\n-//!     * `#x` - precedes the argument with a `0x`\n-//!     * `#X` - precedes the argument with a `0x`\n-//!     * `#b` - precedes the argument with a `0b`\n-//!     * `#o` - precedes the argument with a `0o`\n-//! * `0` - This is used to indicate for integer formats that the padding should\n-//!         both be done with a `0` character as well as be sign-aware. A format\n-//!         like `{:08}` would yield `00000001` for the integer `1`, while the\n-//!         same format would yield `-0000001` for the integer `-1`. Notice that\n-//!         the negative version has one fewer zero than the positive version.\n-//!         Note that padding zeroes are always placed after the sign (if any)\n-//!         and before the digits. When used together with the `#` flag, a similar\n-//!         rule applies: padding zeroes are inserted after the prefix but before\n-//!         the digits.\n-//!\n-//! ## Width\n-//!\n-//! This is a parameter for the \"minimum width\" that the format should take up.\n-//! If the value's string does not fill up this many characters, then the\n-//! padding specified by fill/alignment will be used to take up the required\n-//! space.\n-//!\n-//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n-//! left-aligned. The\n-//! defaults for numeric formatters is also a space but with right-alignment. If\n-//! the `0` flag is specified for numerics, then the implicit fill character is\n-//! `0`.\n-//!\n-//! The value for the width can also be provided as a [`usize`] in the list of\n-//! parameters by using the dollar syntax indicating that the second argument is\n-//! a [`usize`] specifying the width, for example:\n-//!\n-//! ```\n-//! // All of these print \"Hello x    !\"\n-//! println!(\"Hello {:5}!\", \"x\");\n-//! println!(\"Hello {:1$}!\", \"x\", 5);\n-//! println!(\"Hello {1:0$}!\", 5, \"x\");\n-//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n-//! ```\n-//!\n-//! Referring to an argument with the dollar syntax does not affect the \"next\n-//! argument\" counter, so it's usually a good idea to refer to arguments by\n-//! position, or use named arguments.\n-//!\n-//! ## Precision\n-//!\n-//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n-//! longer than this width, then it is truncated down to this many characters and that truncated\n-//! value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n-//!\n-//! For integral types, this is ignored.\n-//!\n-//! For floating-point types, this indicates how many digits after the decimal point should be\n-//! printed.\n-//!\n-//! There are three possible ways to specify the desired `precision`:\n-//!\n-//! 1. An integer `.N`:\n-//!\n-//!    the integer `N` itself is the precision.\n-//!\n-//! 2. An integer or name followed by dollar sign `.N$`:\n-//!\n-//!    use format *argument* `N` (which must be a `usize`) as the precision.\n-//!\n-//! 3. An asterisk `.*`:\n-//!\n-//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n-//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n-//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n-//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n-//!\n-//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n-//!\n-//! ```\n-//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n-//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n-//!\n-//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n-//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n-//!\n-//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n-//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n-//! //                          specified in first of next two args (5)}\n-//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n-//! //                          specified in its predecessor (5)}\n-//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n-//! //                          in arg \"prec\" (5)}\n-//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n-//! ```\n-//!\n-//! While these:\n-//!\n-//! ```\n-//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n-//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n-//! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n-//! ```\n-//!\n-//! print two significantly different things:\n-//!\n-//! ```text\n-//! Hello, `1234.560` has 3 fractional digits\n-//! Hello, `123` has 3 characters\n-//! Hello, `     123` has 3 right-aligned characters\n-//! ```\n-//!\n-//! # Escaping\n-//!\n-//! The literal characters `{` and `}` may be included in a string by preceding\n-//! them with the same character. For example, the `{` character is escaped with\n-//! `{{` and the `}` character is escaped with `}}`.\n-//!\n-//! # Syntax\n-//!\n-//! Below, you can find the full grammar of format strings.\n-//! The syntax for the formatting language used is drawn from other languages,\n-//! so it should not be too alien. Arguments are formatted with Python-like\n-//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n-//! `%`. The actual grammar for the formatting syntax is:\n-//!\n-//! ```text\n-//! format_string := <text> [ maybe-format <text> ] *\n-//! maybe-format := '{' '{' | '}' '}' | <format>\n-//! format := '{' [ argument ] [ ':' format_spec ] '}'\n-//! argument := integer | identifier\n-//!\n-//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n-//! fill := character\n-//! align := '<' | '^' | '>'\n-//! sign := '+' | '-'\n-//! width := count\n-//! precision := count | '*'\n-//! type := identifier | '?' | ''\n-//! count := parameter | integer\n-//! parameter := argument '$'\n-//! ```\n-//!\n //! [`usize`]: ../../std/primitive.usize.html\n //! [`isize`]: ../../std/primitive.isize.html\n //! [`i8`]: ../../std/primitive.i8.html"}]}