{"sha": "2880fd23206042cc3564d388d2f991cb91e76c39", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ODBmZDIzMjA2MDQyY2MzNTY0ZDM4OGQyZjk5MWNiOTFlNzZjMzk=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-04-29T07:08:52Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:03:46Z"}, "message": "Complete usefulness::SubPatSet impl", "tree": {"sha": "12af7479559d4255c3863bacf8811cc9d806e9e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12af7479559d4255c3863bacf8811cc9d806e9e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2880fd23206042cc3564d388d2f991cb91e76c39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2880fd23206042cc3564d388d2f991cb91e76c39", "html_url": "https://github.com/rust-lang/rust/commit/2880fd23206042cc3564d388d2f991cb91e76c39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2880fd23206042cc3564d388d2f991cb91e76c39/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4c396036416eaa977876d8ff4afe7f58f93c09e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4c396036416eaa977876d8ff4afe7f58f93c09e", "html_url": "https://github.com/rust-lang/rust/commit/f4c396036416eaa977876d8ff4afe7f58f93c09e"}], "stats": {"total": 74, "additions": 71, "deletions": 3}, "files": [{"sha": "2e5d2fb6c49fc56df3ac25602e2bcb33c04c3ab9", "filename": "crates/hir_ty/src/diagnostics/pattern/usefulness.rs", "status": "modified", "additions": 71, "deletions": 3, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2880fd23206042cc3564d388d2f991cb91e76c39/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880fd23206042cc3564d388d2f991cb91e76c39/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs?ref=2880fd23206042cc3564d388d2f991cb91e76c39", "patch": "@@ -1,5 +1,5 @@\n // Based on rust-lang/rust 1.52.0-nightly (25c15cdbe 2021-04-22)\n-// rust/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs\n+// https://github.com/rust-lang/rust/blob/25c15cdbe/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs\n \n use std::{cell::RefCell, iter::FromIterator, ops::Index, sync::Arc};\n \n@@ -245,6 +245,33 @@ impl Matrix {\n     }\n }\n \n+/// Given a pattern or a pattern-stack, this struct captures a set of its subpatterns. We use that\n+/// to track reachable sub-patterns arising from or-patterns. In the absence of or-patterns this\n+/// will always be either `Empty` (the whole pattern is unreachable) or `Full` (the whole pattern\n+/// is reachable). When there are or-patterns, some subpatterns may be reachable while others\n+/// aren't. In this case the whole pattern still counts as reachable, but we will lint the\n+/// unreachable subpatterns.\n+///\n+/// This supports a limited set of operations, so not all possible sets of subpatterns can be\n+/// represented. That's ok, we only want the ones that make sense for our usage.\n+///\n+/// What we're doing is illustrated by this:\n+/// ```\n+/// match (true, 0) {\n+///     (true, 0) => {}\n+///     (_, 1) => {}\n+///     (true | false, 0 | 1) => {}\n+/// }\n+/// ```\n+/// When we try the alternatives of the `true | false` or-pattern, the last `0` is reachable in the\n+/// `false` alternative but not the `true`. So overall it is reachable. By contrast, the last `1`\n+/// is not reachable in either alternative, so we want to signal this to the user.\n+/// Therefore we take the union of sets of reachable patterns coming from different alternatives in\n+/// order to figure out which subpatterns are overall reachable.\n+///\n+/// Invariant: we try to construct the smallest representation we can. In particular if\n+/// `self.is_empty()` we ensure that `self` is `Empty`, and same with `Full`. This is not important\n+/// for correctness currently.\n #[derive(Debug, Clone)]\n enum SubPatSet {\n     /// The empty set. This means the pattern is unreachable.\n@@ -397,7 +424,24 @@ impl SubPatSet {\n             Full => Full,\n             Empty => Empty,\n             Seq { subpats } => {\n-                todo!()\n+                // We gather the first `arity` subpatterns together and shift the remaining ones.\n+                let mut new_subpats = FxHashMap::default();\n+                let mut new_subpats_first_col = FxHashMap::default();\n+                for (i, sub_set) in subpats {\n+                    if i < arity {\n+                        // The first `arity` indices are now part of the pattern in the first\n+                        // column.\n+                        new_subpats_first_col.insert(i, sub_set);\n+                    } else {\n+                        // Indices after `arity` are simply shifted\n+                        new_subpats.insert(i - arity + 1, sub_set);\n+                    }\n+                }\n+                // If `new_subpats_first_col` has no entries it counts as full, so we can omit it.\n+                if !new_subpats_first_col.is_empty() {\n+                    new_subpats.insert(0, Seq { subpats: new_subpats_first_col });\n+                }\n+                Seq { subpats: new_subpats }\n             }\n             Alt { .. } => panic!(\"bug\"),\n         }\n@@ -417,7 +461,31 @@ impl SubPatSet {\n     /// containing `false`. After `unsplit_or_pat`, we want the set to contain `None` and `false`.\n     /// This is what this function does.\n     fn unsplit_or_pat(mut self, alt_id: usize, alt_count: usize, pat: PatId) -> Self {\n-        todo!()\n+        use SubPatSet::*;\n+        if self.is_empty() {\n+            return Empty;\n+        }\n+\n+        // Subpatterns coming from inside the or-pattern alternative itself, e.g. in `None | Some(0\n+        // | 1)`.\n+        let set_first_col = match &mut self {\n+            Full => Full,\n+            Seq { subpats } => subpats.remove(&0).unwrap_or(Full),\n+            Empty => unreachable!(),\n+            Alt { .. } => panic!(\"bug\"), // `self` is a patstack\n+        };\n+        let mut subpats_first_col = FxHashMap::default();\n+        subpats_first_col.insert(alt_id, set_first_col);\n+        let set_first_col = Alt { subpats: subpats_first_col, pat, alt_count };\n+\n+        let mut subpats = match self {\n+            Full => FxHashMap::default(),\n+            Seq { subpats } => subpats,\n+            Empty => unreachable!(),\n+            Alt { .. } => panic!(\"bug\"), // `self` is a patstack\n+        };\n+        subpats.insert(0, set_first_col);\n+        Seq { subpats }\n     }\n }\n "}]}